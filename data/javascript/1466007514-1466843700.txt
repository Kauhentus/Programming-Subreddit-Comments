Yep it needs to be fixed for sure
Yeah I should probably just put it as 'div' in the first case
Another option besides running a self-hosted NPM-alike server is to use https://github.com/JamieMason/shrinkpack. Allows you to check in just the tarballs for each transitive dependency, rather than your entire `node_modules` folder. That means just a few hundred small files and a few megabytes rather than potentially 100,000 files and a couple hundred megabytes. Also, by checking in the tarballs, you can do `npm install` on any platform and have any platform-specific artifacts built then, rather than trying to have those checked in (like, say, the C library that `node-sass` relies on). Finally, by having all the tarballs there in the repo, `npm install` doesn't even have to go out to the network at all.
But the feature set in ES2016 (ES7) has already been finalized...
Or you could just use browserify, which does all that for you. No reason to do it yourself. I do use a similar Makefile command for my css. Just cat it together amd then minify the output.
Intellij Idea. How did you miss that one?
...wat http://imgur.com/6jz5ClW
Not having used Vue.js before I had a look thru the docs. It looks like when you need to bind data from a parent to a prop, you need to precede the prop with a colon like so `:t="tasks"`. This fixes it: https://jsfiddle.net/jqaue75s/ Edit: The reason you were seeing the error was because you were doing `for (var task in 'tasks')` which has 2 `s`'s and was seeing that as a duplicate.
Yep, that fixed it. I still don't understand the error message fully.
Here you go. https://jsfiddle.net/qr9gume6/ In your example you are looping thru a string ("tasks"). As it loops through tasks, it will hit 2 s's. I guess Vue attempts to track by the object in the loop, but because you have 2 s's they cant be reliably tracked as different elements in the loop. The error advises doing something like this in that instance: https://jsfiddle.net/cnn9vxbt/
I didn't miss it. I used to use IntelliJ and have a license for a really old version (9, I think). I switched to Netbeans at one point and stuck with that until now. Just downloaded the latest version and checking out the trial now.
I'm not sure how nobody has mentioned `shrinkwrap` yet: https://docs.npmjs.com/cli/shrinkwrap I would be more concerned with Angular and Typescript in 3-15 years than Node/npm, to be honest.
it may be better to do with promises and render once all have completed, but i would start with something like this var allusers = ['vex_i_am','user2'] var onlineusers = [] function add1(user) { $('#streamwidget').append("LIVE - "+user ) } function renderall() { onlineusers.map(add1) } function isonline(user) { $.getJSON("https://api.twitch.tv/kraken/streams/"+twitchUserName+"?callback=?",function(streamData) { if(streamData &amp;&amp; streamData.stream) //onlineusers.push(user) add1(user) }) } $(document).ready(function() { allusers.map(isonline) //renderall() }) maybe someone else can write a promised version, it would be like `allusers.map(isonline).then(renderall)` edit: this doesnt have the no users online part, i would put that as default html and remove that near the `if(streamData &amp;&amp; ...)`
One way to go about this is to store your streamer names in a list: var streamers = ["streamer1","streamer2","streamer3"]; Then loop through them to create an element for each streamer. If this sounds too difficult I can come back to you in a few hours and write an example if someone else hasn't already.
`shrinkwrap` + `greenkeeper` + CI can pretty much eliminate problems #1 and #2.
And it would then only remove it if ALL of the users don't have a response on streamData &amp;&amp; streamData.stream right?
That is not going to solve for the scary 5082. https://github.com/npm/npm/issues/5082 Also, I would not want to trust the health of business critical applications to those. Consider this from the greenkeeper website: &gt; You could manually track updates of your dependencies, and test whether things continue to work, but that takes a lot of time and is rarely done. I disagree from experience. It might be rare on the web, but not generally. Large corporations with critical SLA dependent applications absolutely test dependencies before updating them. This is common practice in any sort of security driven environment.
ya :&gt;
&gt; var allusers = ['vex_i_am','user2'] &gt; var onlineusers = [] &gt; &gt; function add1(user) { $('#streamwidget').append("LIVE - "+user ) } &gt; function renderall() { onlineusers.map(add1) } &gt; &gt; function isonline(user) { &gt; $.getJSON("https://api.twitch.tv/kraken/streams/"+twitchUserName+"?callback=?",function(streamData) { &gt; if(streamData &amp;&amp; streamData.stream) &gt; //onlineusers.push(user) &gt; add1(user) &gt; }) &gt; } &gt; &gt; $(document).ready(function() { &gt; allusers.map(isonline) &gt; //renderall() &gt; }) Alright going to give this one a try. thanks for the help!
You made me realize I left out the import part of the story. I worked with a designer who knew HTML/CSS and learned JS to build better front-ends. He went on to build a full Meteor app to analyze instagram, using nothing but JS/Meteor.
Sorry to bother again. How do I go about making it marked as the default html ? If I just put it as html above the &lt;script&gt; I'm not sure how I'd hide / remove it within the script.
This would be one of the times I'd advise using an API in the wild -- using Lumen or other various micros, I'd recommend making a very small API just to post data to asynchronously (especially in a game setting). Then you can consume this same data in real time for a leaderboard! Good luck!
I made a probably useless time traveler. https://gitlab.me/wski/eightyeight
This doesn't seem like an official proposal (not listed as a proposal on ecma262 GitHub), and even if it were a stage 0 proposal (meaning brought before tc39), no way would it make the cut for 2016 so late.
Personally and at work, I use karma with phantom as my test environment and chai/sinon for my assertions. I've got a karma configuration here which you can use: https://github.com/echoes221/Grid-Games/blob/master/karma.conf.js and an example of some unit tests here https://github.com/echoes221/Grid-Games/tree/master/client/core/tests they're not the best, but should give you enough of an idea to get you started. 
Can anyone demonstrate to me what this does? I don't want to use it, I just can't seem to make it work. What am I missing? Thanks Maybe it doesn't do anything and is just pseudocode for demonstration?
If you `npm shrinkwrap` you won't run into that problem until you explicitly install a new version of a dependency that happens to be affected by it. But yeah — that's a pretty shitty bug.
Yeah its a known bug, its actually 410px minimum, going to be fixed imminently
npm can pull out of a git repository. Nothing to worry about.
It is called self-invoking function or self-executing function. It is an anonymous function that is run right after it is defined. Proper explanation can be found here: http://stackoverflow.com/questions/592396/what-is-the-purpose-of-a-self-executing-function-in-javascript
Just to add to what everyone else is saying, it is formally called an [IIFE immediately invoked function expression](https://en.wikipedia.org/wiki/Immediately-invoked_function_expression).
I'm about 100% sure what he's talking about is the main point (closure scoping) only worded for a layman.
With TypeScript gaining broad popularity in the JavaScript community, we could see future versions of JS/ECMAscript incorporate some features of TypeScript. So even as JS-only developer (for now), I like to here about what's going on with TypeScript.
The important word here is **immediate**. Once that function fully enters the interpreter/compiler it executes without regard for anything. Consider this example: var myStr = (function () { return "asdf"; }()); typeof myStr; //"string" In that example the function executes immediately, which means before the outer assignment completes. The result is that the variable believes it is assigned a string. It never sees the function, because the function is already long gone. This was handy before block scope when you needed some variables for a contained operation on the fly in the middle of a large piece of logic. It keeps everything contained in a tidy bundle both for human reading and for code execution. Thanks to block scope from ES6 IIFE is not needed so much anymore, but it is still helpful if you need to automatically generate a primitive from separate logic on the fly.
I tried to google it but i didn't know the name. This helps a lot, thanks
It auto downvotes posts from the_donald...
It would seem to downvote all visible posts from /r/The_Donald when run.
You can use typescript types in a plain JS project if your editor is smart enough to take advantage of them. JS devs would be doing themselves and their users a favour by including type definitions. I wouldn't be surprised if other compile-to-JS languages can find ways to leverage typescript types as well. My choice of JS libraries is heavily influenced by whether or not they have types, as are a lot of other devs I'm sure. Something to consider if you're publishing libraries and want others to use them.
&gt; This doesn't seem like an official proposal (not listed as a proposal on ecma262 GitHub), and even if it were a stage 0 proposal (meaning brought before tc39) Does ANYONE know what the real process for it is? Because there are many contradicting sources about it and no one seems to be sure what it is. On ecma262 "0 stage proposals" have champions, but document from TC39 says that "0 stage proposals" don't have champions (it's reserved for stage 1 proposals).
I can't get it to work regardless of the value in place after href$=. Can you instruct me on what to do to see it work? thanks
I use Selenium, however I create these tests in Python since it is an easier language to use and the support for Selenium seems to be much better. Don't forget that if you are developing a large number of tests it is better to write some support code for your test so that the tests become clearer. There are plenty of tutorials around for Python/Selenium that discuss this concept, the term they often use is Page Objects.
/u/cae2000: You're asking us to help you break reddit's rules. &gt; Can you instruct me on what to do to see it work? No. Please don't ask again. 
I don't think it's necessarily against the rules to mass upvote/downvote, provided you're doing it manually. Scripting it is certainly against the rules.
/u/ioi20: Neither of your accounts has ever posted in a programming subreddit before today, much less in /r/javascript, and you want me to believe that you just want to know how it works... what kind of fool do you take me for?
It would have been shorter to just say, "I'm 12" instead of that long tirade you just typed out. &gt; I've literally posted in javascript hundreds of times asking questions. FUCK YOU!!!!! No, no you haven't... not unless you've deleted all of them (which wouldn't make any sense at all for an uncontroversial sub like /r/javascript). This goes for both accounts.
Locally vendor all the dependencies you use, and periodically update them.
Your syntax is pretty wrong. Try /r/css for help with styling. Also use display: none to truly hide elements
&gt; we could see future versions of JS/ECMAscript incorporate some features of TypeScript We could even see *past* versions of ECMAScript incorporate features of TypeScript: http://www.ecma-international.org/activities/Languages/Language%20overview.pdf Sorry, couldn't resist that joke! Agreed, though; people definitely pay attention to the JS sibling languages and things that work well end up in future ES versions. 
Cookies will do the job you're describing, but if they clear their browser it will release all that data. If that's not an option for you I can only guess that an authenticated (user sign in process) server side setting would work, but once again, they can log out and all the data would be gone.
To help you out further: Here's what your first part (adding removing) will be like: document.getElementById("floatbar-cap-show-hide").innerHTML = "&lt;a href='javascript:void(hide);' onclick='javascript: HideFloatbar();'&gt;Hide Floatbar&lt;/a&gt;" setCookie("floatbarview", "show", 60) And then related to that is: function setCookie(cname, cvalue, exdays) { var d = new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); var expires = "expires=" + d.toUTCString(); document.cookie = cname + "=" + cvalue + "; " + expires; } function getCookie(cname) { var name = cname + "="; var ca = document.cookie.split(';'); for (var i = 0; i &amp;lt; ca.length; i++) { var c = ca[i]; while (c.charAt(0) == ' ') c = c.substring(1); if (c.indexOf(name) == 0) return c.substring(name.length, c.length); } return ""; }
&gt; My choice of JS libraries is heavily influenced by whether or not they have types, as are a lot of other devs I'm sure. More echo chamber. Sure there are devs like this but it isn't most of them. It's a very small subset of them.
One thing that I'm noticing is that people aren't explaining exactly why someone would do this. Before let and const variables defined within a javascript file are hoisted all the way to the top of the block scope of the surrounding block scope. Using an IIFE gives you function scope which is a nice block in which you can use to isolate the code inside from external code.
Not to discourage you from using npm, but you should also be aware that even without NPM going down it can still break your build: http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/ If this is something critical that you need to be able to reliably build or else, you'll definitely want to use one of the solutions smarter people than I have suggested in this thread.
http://www.espruino.com/ (not affiliated... just own one)
Generally not needed if you use ES6/7+ with modules and const/let scoping.
What advantages does this have over https://modernizr.com/ ?
And if you want to take it further, I strongly recommend ROS. The latest version has a client library for node. http://www.ros.org/ https://github.com/RethinkRobotics-opensource/rosnodejs Admittedly I only use the C++ and Python libraries at work, but am eager to check out rosnodejs.
You're out of luck for the most part if you want to do it in JS, since anybody that _really_ wanted to get the token could check out the XHR that you send to Instagram and get the token there. The best way to do something like this would be server-side rendering, in which you would perform the call that gets the feed on the back end, and then print out the HTML on your site without using JS at all. That way, the token never appears on the page.
uhhhh server-side coding, servers and all that has been very complicated for me to understand i just dont get it. Do you mean I should do all the instagram feed process in a server and just send the response back to my script in the hosting? I think ill never understand this it just sounds very complicated for me. btw is it dangerous for my access token to be exposed to the public?
Yeah, I mean you should use PHP or some other language to make the feed instead of using in-browser Javascript. PHP is a good first server language, because it doesn't require that you understand many things about how servers work. I recommend trying it out, it's actually very easy. I've never used the instagram service before, but if they have a snippet for you that they wrote in JS and expect you to pass your token into at runtime, it's most likely fine to follow their lead and do it.
WoW extremely helpful ill try my best and ill keep trying does it bother you if i message you if I have any extra doubts?
The objects are passed in by reference, that means you can surely change them... If I do $.test = 'test', it will be available everywhere. 
If you want to concentrate on 2D, I would suggest learning the Canvas API directly. A library will just get in the way. If you want to do 3D stuff and want to see how it fundamentally works, I would suggest looking at http://seenjs.io It is not as elaborate as three.js, but it well documented and shows how 3d calculations are performed. Mortals can peruse the code and have a clue what is going on. I have shamelessly stolen their quaternion functions for my own amusement. 
I'd go with Vanilla.js :P http://vanilla-js.com But seriously it depends on what you want to do. If a graphic library supports the specific thing you're trying to accomplish then great, otherwise the canvas primitives are great enough by themselves.
This is badass
(gulp user) I do this : + src/ + module-1/ + module-2/ + dist/ - module-1.min.js - ... + gulp-tasks/ - module-1.js - module-2.js - gulpfile.js In each gulp-tasks/\*.js file, I export my tasks : exports["build-module-1"] = function() { /* ... */ }; In gulpfile.js, I use [require-dir](https://www.npmjs.com/package/require-dir) : var requireDir = require('require-dir'); var tasks = requireDir("./gulp-tasks"); for(var filename in tasks) { if(tasks.hasOwnProperty(filename)) { for(var taskName in tasks[filename]) { if(tasks[filename].hasOwnProperty(taskName)) { gulp.task(taskName, tasks[filename][taskName]); } } } } Then `gulp --tasks` shows all the tasks in gulp-tasks/. If things get too messy, I can create src/module-1/gulpfile.js, in which I will do : var tasksModule = require("../../../gulp-tasks/module-1.js"); for (var taskName in tasksModule) { if (tasksModule.hasOwnProperty(taskName)) { gulp.task(taskName, tasksModule[taskName]); } } So that `src/module-1/$ gulp --tasks` will output only the tasks related to this module. There are probably better ways to do it but it works for me.
It's just more lightweight &amp; small without extra features without custom tests &amp; without testing media queries.
Given how little the CTO post mentions Node (namely not at all), I think Joyent pivoted away from Node, and that not being what Samsung's interested in. Hence, I'm speculating that it won't affect it in a big way.
Vanilla.js is awesome! It's so great it is already implemented in every modern browser!
Because /r/javascript is WAAAAY more active than /r/typescript so the blog spam wouldn't generate much ad revenue when posted there only.
If subscription counts for anything, /r/typescript is has only ~2.6% of the subscribers of /r/javascript. So it's an extremely small but extremely vocal minority that thinks Typescript is worth talking about. Sorry Typescripters, you're practically irrelevant. 
 navigator.permissions.query({name: 'geolocation'}).then(function(status) { console.log(status); });
Also agree on learning `CanvasRenderingContext2D` directly, as working at a lower level for graphics is really fun! Plus, as you progress, you can begin to implement design patterns to make your app or game logic more scalable and reusable e.g. Entity Component System.
How does it compare to node security project? 
I hope it won't change anything for Node. Samsung is not a company known for its programming chops.
Maybe it does, because you are not waiting for the sprite nor the image to load. You should use callback functions for that, like img.onload = function(){//do stuff}, but it gets messy when you doing it for more than one image. Try promises instead, then do Promise.all(). http://stackoverflow.com/questions/24596536/image-loading-deferred-jquery
I suggest you do some research into the IIFE pattern. There is a lot of confusion in these comments and some misleading explanations as to why it is typically used. Your questions are valid, mainly because the explanations are limited. The main things to understand are block scoping, top level scope pollution, difference between function expression and declaration, variable hoisting, encapsulation and the module patter. I'm not going to try and explain it all in a comment, but I can recommend Kyle Simpson's explanation of how the compiler works either from his blog or talks (https://app.pluralsight.com/library/courses/advanced-javascript/table-of-contents ). The IIFE is something that evolved over time as a way for JS developers to work around the languages attempts to make it's self accessible to novice developers. Which ironically lead to things like this that make it really confusing ;)
This is actually the module pattern (http://eloquentjavascript.net/10_modules.html). IIFE typically adds to this pattern, but has other use cases. 
This isn't the main reason an IIFE is wrapped in (). It's so you can convert it from a declaration to an expression when it's not assigned to a variable. function iife(){}(); // Leaked onto lexical scope (function iife(){})(); // Not leaked as it's an expression [EDIT] Worth noting, you also can't have a un-named function declaration, which is another need for the outer (). So the iffe name is not needed on the last example, however I would recommend always naming functions for debugging reasons.
Just as APIs are ruled copyrightable, a large corporation is acquiring the company behind NodeJS. ~~What could go wrong?~~ **Edit:** Luckily Joyent does not own the node apis.
They're not acquiring it for Node.js though. Samsung isn't really known for their Starbucks-drinking, Macbook-toting, thick-frame-non-prescription-glasses-wearing, ironic-mustache-sporting, persons.
Google won on its most recent appeal, so your statement isn't true. 
[Phaser] (http://phaser.io/) Desktop and Mobile HTML5 game framework. That is if you are interested in creating games.
You can do the same without shrinkpack by using `npm install --ignore-scripts` which won't build any native dependencies, then checkin your node_modules, do an `npm rebuild`, then something like `git status` to see what files were added and you can add them to your .gitignore file. It's not as simple, but it puts everything in your hands.
Sure theres things that could be improved but... Take the 'non resizable till you hit step 1' issue for example. There are things about D3 that are much, much more subtle than this 'problem'. For someone to struggle at that point SHOULD, IMO, filter out people that cant / wont try / experiment. Sure, it stumped me. For all of 10 seconds. Till I read all the instructions. Leave it in. :)
Samsung is a fucking massive company which actually does contribute to product-related open source projects quite a bit. http://browserg.nom.es/#commitsByOrganization
Moving the declaration files to npm is a very sensible choice because you need Node for the compiler anyways.
&gt; if you are large then it is more cost effective to self-host Is it? [Netflix went full cloud](https://media.netflix.com/en/company-blog/completing-the-netflix-cloud-migration). There isn't anyone out there much larger than Netflix right now, and they shut down their self hosting and went full AWS cloud services. 
netflix went full amazon servers, which have a specific api and configuration, calling it cloud is kind-of silly, it is a specific environment. (trust me, not all "clouds" are the same, it is just a marketing term) plus there is some political motivation if you are a target like netflix, and amazon is also a video streaming competitor as well. You can get the hosting people to fight for you when the streaming people want to kill you.
i would probably go with storing it into a DB, that way you're future proofing and have the option to do interesting queries with the data if you need to. with [rethinkdb](https://rethinkdb.com/api/javascript/http/) you can even straight up make an http call from the database and store it in the database in one fell swoop. or you can just use rethink to parse the data. like this for example: r.http('http://jsonplaceholder.typicode.com/comments').filter({'email': 'Lew@alysha.tv'}) that will parse an api, then filter it out to only return documents with that email, doesn't even store it in the db. or you can store it in the db, then parse. pretty cool stuff. Either way, i would say probably use a database anyways, never know when the client is gonna want you to add features that end up requiring db stuff down the road!
Yeah...but TouchWiz on Android has always sucked ass. 
Thanks! Enjoy the reading :)
I liked the ironic clickbait title. I've wanted to get into TDD for some time. But all I can find are examples that test a function that adds two numbers. Then they assert something like, "expect(add(3, 5)).to.be.(8)". And I'm like, that's great. Now how do I make a test for a real function? Then I read this from your post: "I’m not going to run through building the whole application, but just a single step." That's too bad. You should do the whole thing and put it on github so we can steal it and learn from it. There is a scarcity of simple-but-real-and-practical applications written using TDD out there to be used as examples and references.
I doubt the Samsung Telecommunications division will be taking care of Node. 
There content is hosted near the end of pops. Real traffic and storage is not done on amazon. The API is in the cloud, the rest near costumers.
You realize the Samsung browser on their phones outperforms Chrome on the same device, right? https://meta.discourse.org/t/the-state-of-javascript-on-android-in-2015-is-poor/33889
It's kind of an art that you learn by trial-by-fire unfortunately. If your functions are too complicated, unit testing is going to force you to design them differently. processBankTransactions() is probably going need to be a bunch of small functions like processDeposits() and processWithdrawals(), and those can be tested a lot easier. So it's probably more like: (I wrote this off the top of my head. Apologies if it's stupid or doesn't actually work.) var initialBalance = 100; var withdrawals = [3, 5]; var deposits = [1, 2]; var account = new Account(); account.setInitialBalance(initialBalance); expect(account.balance()).to.be(100); account.processWithdrawals(withdrawals); expect(account.balance()).to.be(92); account.processWithdrawals(deposits); expect(account.balance()).to.be(95); Note that I've put all of these in a single test and that's probably not the ideal situation because you want to know if each piece fails at a glance, and not have to fix the first piece to check the second piece, etc.
Uh... no, that's definitely _not_ the same thing. The point of Shrinkpack is that you're checking in _tarballs_, not your `node_modules`. For comparison, my current prototype project's `node_modules` folder is currently 48,992 files, 5059 folders, 189MB in bytes / 346MB size on disk. The `node_shinkwrap` folder containing the package tarballs is "only" 44MB, 1098 files. (The biggest factor in both of those is the Cesium 3D globe library, which is 53MB / 1800 files unzipped, and 15MB zipped). If I do a package upgrade, say, bumping Cesium to the latest version, there's only one net file change: swapping out `cesium-whatever-old-version.tar.gz` for `cesium-new-version.tar.gz`. In contrast, if I tried to record the changes to `node_modules/cesium`, there's be hundreds of files changed in the process. So, with Shrinkpack, there's way fewer total files being checked in, those files are smaller, and there's way less total churn on an upgrade.
I made a fiddle how my case scenario looks. All three canvases are rendered but for each added canvas the render speed is multiplied. Any idea why? https://jsfiddle.net/s2wkdLy0/9/
Nice game ! It mostly works in Firefox (yay for standards), yet there is a few annoying bugs : * I need to click on the left of mirrors to take them * Taking a mirror drags him to the lower right of the mouse (making small moves hard) * time is not in its box Now, I'll retry this level 3... ;-)
How is one bad product relevant to a completely different division of a huge company? It's like bringing up Bing on a Microsoft Surface conversation.
Correct, we try and cut down on bandwidth costs by locating media as close to the consumer as possible through something called Open Connect. All of our internal apps and APIs are also in the cloud, which is pretty awesome for cutting down on IT and support. The biggest downside I've seen so far is that it's tough to integrate with other companies who haven't made the move yet. For instance we cannot use powerful industry standard tooling for streamed editing w/ Adobe (http://www.adobe.com/products/adobeanywhere.html) since they require a full data center to transmit the 4k assets directly into Adobe Premiere. I think we made the right decision for sure to build internal infrastructure to make spinning up and maintaining an application easy (to align with our micro-service architecture).
Yeah, someone has brought up the binary size issue just about every time I've mentioned Shrinkpack. Maybe it's just that I'm working in a specific corporate environment, but I personally don't see that as an issue. One of our projects has several Java sub-apps that we've vendored JARs for, and the repo's somewhere up around a gig. We've got our few developers, and the repo isn't exactly being cloned on an ongoing basis, so it's not like clone times are a concern. Beyond that, it's also a question of how big those tarballs are, and how frequently you're updating them. The Cesium library I mentioned is an outlier - of the 1100 packages in my `node_shrinkwrap` right now, the top 100 by size add up to 40MB of the 44MB, and the remaining 1000 are only 4MB total and average like 4KB apiece. So, if any of those get updated, the size change is hardly meaningful. All that said, Shrinkpack isn't perfect (because no tool is ever perfect), but it sure seems like it solves a whole lot more problems than it creates.
I really struggle with TDD in JavaScript, when I'm working in a statically typed language like Java it's the only way I can code. In something more dynamic like JavaScript I far prefer experimenting in the console then formalising into tests and don't even get me started on TDD for the UI.
You're so.. red! Just what you deserve, little asshole.
You can use TypeScript definitions without using TypeScript with IDEs like WebStorm. It supports the many available built-in inspections you can individually enable that check your code while you are writing it. Detecting types with only a static analysis sometimes (or often, depending on the code) fails in Javascript - since you can assemble objects during runtime and don't have a static definition. So you would have to actually run or actively interpret at least parts of the code to find out how a returned object might look like, and even then you might be missing cases, because what if a function returns a different object for a different input?
Once you navigate to a different page, your script is discarded and garbage collected. You need a separate script (which is tied to a different path) which continues where you left off. Anyhow, this kind of thing is much easier done with Selenium/WebDriver. E.g. install the Selenium IDE addon for Firefox and just record those steps.
Me? **You** are so.. red! Just what you deserve, little asshole.
Same here. Unfortunately, the prevailing notion that fair use can only be decided in court means the folks with the pricey lawyers can still easily extort settlements.
I work on applications for our tagging and categorization. Feel free to DM me w/ questions.
If by "prevailing notion" you mean the Supreme Court has decided that fair use is an affirmative defense, rather than a pre-emption to litigation, you have it right; I'd like to think that just as with other common cases of fair use (like educational copying), best practices will emerge, under which most copyright holders won't bother suing, and that in this case, the best practices would extend to any use of a public API, after a string of similar cases finds such uses to be fair.
Note that Instagram just changed their API to require a sandboxing period before applications are approved. In order to be approved, your app has to be a complete, production quality app. You also have to supply a video showing its functionality. Needless to say, this app is not likely to get that far. But maybe it will be useful to someone as a proof of concept sort of thing? My bad luck for not realizing that sandbox mode means you can test your app, but the data it returns is highly restricted! Still useful if you only want to know basic stats about your own account, tags, locations, etc.
Although, I have some theories of my own if you'd like, or have the time, to hear about them.
&gt; because right now with ES6 and ES7 Javascript is going through some major feature creep. I lol'd. Compare JavaScript's standard library to C++, C#, Java or Python.
The core might be the same but, for me, it has gone from looking simple and easy to get started to looking a bit daunting given all the options and features. That's why I game rethinkdb a try and I'm liking it so far.
Yeah. There’s decent base reasoning behind fair use as an affirmative defense. The problem is that it even with the best practices, it can still be costly to get to the point where the case will be thrown out. As such, vexatious litigation by bad actors will still be a problem.
Doug continues to lead Express development. Things were sorted out after the project was moved to the Node.js Foundation.
 document.getElementById("floatbar-cap-show-hide").innerHTML = "&lt;a href='javascript:void(hide);' onclick='javascript: HideFloatbar();'&gt;Hide Floatbar&lt;/a&gt;" setCookie("floatbarview", "show", 60) What is this? Is this copypasted from somewhere (including the `&amp;lt;` in the for loop declaration)?
I do a lot of interviews. The questions we ask tend to be the 'fizz buzz' test (make sure you know how to get the remainder when dividing) and asking stuff like 'how big is this box with 20px of padding' (trick question ask what the box-sizing attribute is first). How would you center align something... its probably a lot of stuff you've picked up as you went. I'm not formally trained either but I haven't had too much trouble with these interviews. If they use a term you haven't heard; just say "I think I know what you are asking but that term I am not familiar with" 
If you think Javscript needs a standard library then you likely don't understand the use case. Javascript for the browser is downloaded via HTTP and including a standard library would require downloading that code. Instead only the code necessary to render a web page is downloaded. Javascript isn't like other languages in that respect - you don't download C source code via HTTP and compile at runtime. A standard library could be included in the web browser binary but that is another can of worms to get browser manufacturers to agree on a standard library, so if anything blame browser manufacturers for the lack of a standard library, not the language.
I wrote that for blogger. It had to be that way. That particular part would create/insert an item (a link that hides/shows an element) for a page dynamically and set its cookie value.
Ok, I can tell what does, I'm just not sure why you'd provide example code to the OP that references specific IDs on your site, uses onclick attributes, single-letter variable names, etc.
It doesn't. Not trying to be a dick, just pointing out that this doesn't make for particularly helpful example code, especially to a beginner.
I disagree.
It is interesting that you said RethingDB as I was also considering the same option, before taking the PouchDB path. But I just stepped on a landmine in PouchDB so now I am switching to RethinkDB. But you are spot on what Google did to Firebase, as before its simplicity was main selling point, now I am lost about what they aim to achieve. 
We are already using V8 within this project, which produces MASSIVE binaries. We plan on versioning these outside of Git, so we can likely do the same with `shrinkpack`. They will most likely live on our build server, and we'll use a python script to fetch the dependencies off of our build server. We currently do this with one of our products to manage third party binaries and it works well.
Because it works right in the browser which everyone has, so it's easy to run, and it doesn't need too much boilerplate code
Read about binary trees, depth-first search and breadth-first search, and practice writing some related code. These people love asking about that sort of shit.
So how it ended your story with couchdb/pouchdb?
It was a great option, especially for use cases where offline access is essential. However, In my case access control was more important than offline access. Access control in couchdb was terrible and I didn't like the sound of creating one database per user. So that was the end of that.
My argument is structure over convention. In classical languages like C++ and Java you are required to learn use classes and inheritance. These qualities benefit reuse, but come with a lot of boilerplate. This forces you think of the code in pieces that gets stitched together. There are a couple of problems with learning this way: * You are always thinking small picture... your piece in extension of existing pieces. * The conventions of inheritance and object oriented nature are hard to learn at first. Once learned they become your entire definition of programming, which creates a very narrow view of how to solve a variety of problems. Most programmers who come to JavaScript after spending most of their lives in these other languages continue trying to write these older conventions in JavaScript without learning the language or consideration for harm. * Convention oriented programming almost always means more code to accomplish a given task. * Inheritance supplies qualities to your object from the thing you are extending, but imposes no limitations upon availability. To supplement for this Java has various states like public, private, and static to address this concern, which is still more overhead and complexity. In JavaScript inheritance and object oriented design is available to you. It is similar to the inheritance model used by C++ and Java, but a little bit different. Fortunately, though, inheritance is optional and not required. A more important concept to JavaScript is scope, specifically lexical scope. Lexical scope means that **where** you define things determines their availability as a reference, so you never need to worry about declaring things as public or private. If a reference needs to be more public simply declare it in a higher scope. Benefits to programming with lexical scope and without inheritance: * You are absolutely forced to think about programming with at least some consideration for organizational depth. This means your application will have a natural organization and structure in the actual code and not just by convention at execution time. * A fully structured application is far easier to read and debug than sifting through break points guessing at where in the stack the problem occurs. * A structured application ultimately means less code. Generally substantially less code. Many of the web technologies created in the 90s have baked in sloppiness by design. You can argue about this either way. On one handy the sloppiness makes programming easier to learn for people completely new to programming, but it also means toleration for really bad and dangerous conventions. Some examples of sloppiness: * loose typing * type coercion * semicolon insertion * hoisting * overloaded operators * debugging post-increment/decrement versus pre-increment/decrement operators * C style curly brace insertion
Beyond /u/Lucky_Chuck's response... * It's the next step from HTML - which is a simple, visual way to introduce students to programming concepts * Adding to this, it extends what you can do with HTML and provides a relatable way for students to see results * There are no IDE requirements - though editors with linting tools are very useful * It's well known and widely used so help resources are vast
Wow. This is good. Thanks!
Exactly this. It is rumored that they get a 85% discount.
Interesting assignment. I would say usability and barrier to entry are the selling points of JS. Anyone can setup a development environment by opening a browser and accessing the console. Also JavaScript code is very interactive with events and canvas, and there is no compilation step so loading new code is as easy as pressing F5 and waiting half a second.
Why do we keep seeing these DI libraries pop up in the JS world? There's literally no need for it. This isn't java.
Technical Communication. We have to come up with a question, each have our own stance, and decide on a decision. So we decided to ask "what should the programming language be for the Intro to Software Engineering class?" and I choose JavaScript as my stance. It's kind of a weird assignment.
What language should by first? Python? C?
How do you play this online?
Maybe check out horizon as well
Thanks! Also more people should be using telegram
Those who cannot comprehend prototypal inheritance shall be cast off a cliff. 
Hi /u/garik2110, Firstly, please use a title that accurately describes your problem as best you can -- just asking for help doesn't really tell us anything about what might be wrong. Also, if you indent your code with 4 spaces, it'll be formatted properly, making it more likely for someone to help you. Please re-post with proper title, thanks!
At first I was like “not another router…” then I saw who wrote it. Curious at the least, though most of my router problems are on the redux side. If I could just have route params in redux I'd be so happy ):
Also around 70 000 global variables
The Joyent CEO is on the Node.js steering committee. http://news.softpedia.com/news/node-js-foundation-announces-its-first-ever-board-of-directors-491014.shtml So are people from Microsoft, IBM, Paypal, Godaddy and Intel. I assume the Joyent guy will change to a Samsung guy.
Object is at the root of the type hierarchy. Everything that's not a primitive(*) is an object. An array is an object. A function is an object. A regex is an object. And so on. You can only use the function-call operator with a function. Generally speaking, when talking about the type of something you use the most-specific (or most-derived) type. So if someone says something like "this function takes an object", that means that it takes a plain object, it doesn't take a function or an array or anything else, despite those also being objects. (*) Despite not being objects, primitives will auto-box themselves using object wrapper classes, so they act like objects under most circumstances. 
&gt; primitive Does that mean everything that you cannot access is not an object? Also, can/should the child of an object be called an object?
The introductory CS class (and more) from Harvard is available for free on iTunesU and many lectures are also on youtube. The MIT opencourseware Data Structures and Algorithims class is also on both sources. Also, if you don't have a opy of Cracking the Coding Interview or some such preparation book, get one Like last week. I found them to be super helpful. (Self taught to boot camp to employed within a year) Don't worry about being weeded out. Big companies like Uber and Google still take candidates from alternate paths, assuming you have the skills. Go in with confidence, it really makes a world of differemce. And if you don't make it in this first round, don't give up! 
What's the issue, exactly? With route params and Redux?
Late response, been a bit busy this week; thank you so much for this comment! I will save this and use this as a referall when I'm stuck with closures :)
Mobile website content is squished to the left side of the page
This is an O(n^(2)) algorithm. It would be better to use a `Set` if you are using ES6, which makes it O(n). If you can't use ES6, you can fake a set with object keys as long as you can assume that all the values will be numbers, or all strings, and not a mixture of the two, and not including arbitrary objects. 
Bless your soul. 
How is this nice exactly? I don't think a basic application of Array.prototype.filter is nice.
That `getCookie` and `setCookie` code was ripped from somewhere too. I have seen it before.
Their is the basic hero's tutorial on their site. The crud part is more of a server question but if you have an API set up then the hero's tutorial should give you all the tools to do what you're asking.
(**) This is true only for the scalar primitives: `null` and `undefined` will not be boxed this way; in strict mode, functions indirectly invoked on them will use the values directly (while attempts at direct property access on those nothingness values will throw `TypeError`s), and in non-strict mode, the global object will be used instead. Also, the `Object` constructor makes explicit wrapper objects for the scalar primitives, but an empty plain object for `null` or `undefined`, as if no argument were passed in. --- That is a bit wordy, but it clarifies what is meant by "most".
Yeah, that's mostly what I came in here to say. It's all about the queries. Also, doing complex queries in-process on a node application will block the event loop. You'd likely get better throughput using an async DB query over an in memory search, even if the in memory search is slightly faster than the DB's latency.
http://prog21.dadgum.com/203.html
I'm actually looking for the EXACT same thing.
I thought it was "approved" when the finalized standard came out that said that ES2016 would only have `Array.prototype.includes` and the exponentiation operator. Does this mean that the standard might not get approved after a finalized version comes out? 
Huh, didn't realize the nuance there. Thanks for pointing that out. 
Lol
Which way is easier to test? Do it that way.
Route params (the ':param' in 'path/:param') are only accessible from the router prop passed to the root component in a route. Unlike query params, they are not represented in the redux store via react-router-redux
There is some native support in browsers for encoding in shipping versions of Chrome and Firefox using the [MediaRecorder API](https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder_API). The [Chrome blog](https://developers.google.com/web/updates/2016/01/mediarecorder) showing the initial announcement links to an [example program](https://webrtc.github.io/samples/src/content/getusermedia/record/). Something to look into :)
can you post your errors or link to the examples that your trying to follow?
Do you use Lynda? Is it any good?
It's the current year-- &gt; article from 2010 Carry on.
I'd use WebRTC for this, any day. But you're in for a world of pain. Most packages have about no support these days, and the server infrastructure for WebRTC is a real pain in the ass. But I wouldn't use websockets anyway, because WebRTC was BUILT for this.
Yea, wherever an expression is expected, an arbitrary complex expression can be used. For example, default parameter values are also expressions. You can put an entire application there if you want.
It's not too surprising you can, but I'm not sure if you *should*
Okay, I'm not the most experienced JS developer out there but I'll weigh in with my vote for method A. Method B should be used only if layoutView modifies or otherwise has decisions about siteConfiguration. If no modification has taken place, e.g. like this case where it is a constant object, then let SiteDetailsView depend on siteConfiguration. But you can get too many dependencies? Well you should have modular code, in that if there is a natural break (CMS functionality, User permissions logic, Gallery management) then make them their own package/module, otherwise you don't need to worry. No one pulls out code for an editable textbox out of a page and thinks "if only we'd decoupled all our input fields!". That's a bit extreme but I hope you get my point, in that you have to have a line where you go "okay, we might need to do X some day but is it worth Y hours of effort now to reduce that possible technical debt?" Blurb: I have been a web developer for 10 years, professional full time for 4. Concentrated on JS for the past 18 months with approximately 12 fullstack JS sites under my belt, one a fully offline capable web app in Backbone.
The Function() constructor expects any number of string arguments. The last argument is the body of the function – it can contain arbitrary [JavaScript](http://learnwebdevelopment.info/javascript/) statements, separated from each other by semicolons. Notice that the Function() constructor is not passed any argument that specifies a name for the function it creates. The unnamed functions created with the Function() constructor are called anonymous functions.
I'm working on a babel plugin [1] that should make the migration from an untyped codebase soft and gradual. At the end of the process you get both static and runtime type safety (using Flow). [1] https://github.com/gcanti/babel-plugin-tcomb
javascript is "functional programming", which is * almost * like math. (math has functions but purists will tell you programmers got it all wrong and programming is shit for not being pure functional) in programming, a function is like a formula `SomeFunc = (P + 1 + B)` and an object is like a variable, `n` only we added a concent like "data store", so a single variable could have multiple properties: `player1.health, player1.magicpoints, player1.stat` and functions `player1.dostuff()` 
yea thats one of the problems with that solution um. you could do something like in the `add1` function as the first line you can do `if( $('#streamwidget').html() == "NO USERS ONLINE")) $('#streamwidget').empty()` 
The points of this article are still valid. No-one wants to read through multiple nested if statements. if not ... return if not ... return if not ... return if not ... return if not ... return do stuff ... is still better readable than ... if ... continue if ... continue if ... continue if ... continue if ... continue do stuff ... when not only using pseudo code but performing actual checks and doing configuration/changes on results.
I'm in a similar boat to you. I studied Computer Science at university but it was a really watered down curriculum (we even did Excel as one of our first year modules for fuck's sake; I was so desperate to code that I made a VBA frontend haha), so there are many gaps in my theoretical knowledge. I'm currently reading [MIT's Structure and Interpretation of Computer Programs](https://www.amazon.co.uk/Structure-Interpretation-Computer-Electrical-Engineering/dp/0262510871). It's based upon Scheme, a dialect of Lisp, but covers many important topics, such as: * Tree recursion * Hierarchical sequences * State, mutability, and immutability * Streams * Compiler design Now I just need to find more time to read it!
I had es6 in mind until I read your comment.
Thank you for your feedback. Really nicely put. I will honestly say that I recently started to do unit testing. This approach was more of an experiment. It will backfire if your jquery dependent files import other jquery dependent files because of the proxyquire thing. However, like you said, for small, unbound from the dom, functions it could be a faster way to test them.
JS is capable of proper OO programming?
You made currentRow variable global, so it is used by all render functions. What to correct: var currentCol =0, currentRow = 0; instead of var currentCol = currentRow = 0;
they said that they want to drop the one digit versions so that people don't get confused
Probably being the devils advocate, but there is no way to win this debate. The first "language" learned should not be a programming language, but programming jargon, development philosophies and techniques. If examples are necessary, show it in pseudo-code. After those things it would be irrelevant what language to program in, its just learning a new syntax and some quirks of that language.
Wow, you aren't kidding. It's really PHP-biased. Almost like it was written by a PHP zealot and is only using the "front end" term as a hook for more converts. I'm a PHP developer who has spent most of the last few years doing Javascript front-end stuff instead. If I were recommending something for front-end developers to learn next, it'd probably be NodeJS and not PHP simply because they already know the language. That said, I do think PHP is easier to get into and deploy than NodeJS, so if they didn't know *any* language I'd probably go with PHP instead. 
In what universe is 2 worse than 0?
I agree with the article. It's just something I learned a long time ago.
&gt; Maybe this can be a more efficient way of zero-dependency templating. why do you think that is a possible scenario? 
As a newbie to this stuff about 18 months ago, yes. This all confused me so much. But that also made me research and ask questions and I ended up learning way more than I set out to.
https://vuejs.org/guide/application.html#Unit-Testing
This would be worth a look https://auth0.com/blog/2015/05/14/creating-your-first-real-world-angular-2-app-from-authentication-to-calling-an-api-and-everything-in-between/
No async-await then? Pity.
It's just a little anticlimactic, even after 'only' a year. Still no object rest/spread for example.
ES5 to ES6 took 6 years. Would you prefer if nothing changes until 2021? I'd like to see SIMD before that. Same deal with async/await, decorators, and property declarations.
Interesting typo in the headline - Angular2JS vs AngularJS2. I say that because we're about to enter a difficult-to-search-for-info era when Angular2 and Angular1 search results will be co-mingled. Some people too, may want to develop Angular2 applications in JavaScript instead of TypeScript, and no amount of Google fu is going to make that easy .. w/o a planned tagging system. Retagging of old articles might be needed, if search engines can't make tagging decisions based on time (2009 to 2014 must be about Angular1 by definition) or content.
I'm a long time Firebase user (more than 2 years) and was very disappointed by the new release. They went from a very simple and straightforward Database/Server as a Service provider to 'we want to do everything for everyone'. I mean, Firebase is now also an Ad, messaging, analytics, storage and testing provider! Now, this may sound great but it really isn't. The hole point of 'X as a Service' is that you very specifically can choose what you want, and you find the best possible provider for that one very specific thing. Even though Firebase is now owned by Google, there is just no way that they can excel in everything they are trying to do now. And that's already becoming clear by the lack of JavaScript support for many of the newly introduced feature, and lack of improvements to the one thing they should be spending attention to: the real-time database. For example: They still haven't introduced full offline persistence for the JS client, even though there has been a massive outcry by the community for this feature. And get this: with the new Firebase there currently is no way to get even the most simple statistics about your data usage! You really can't call that an improvement. PouchDB/CouchDB is indeed looking more and more like a very good alternative for anyone who's just interested in using Firebase as a database.
In languages like `C#` which do allow a true pass-by-reference, you can write code like: string src = "1000"; int result; bool status; status = tryParseInt(src, out result); if (status) { Debug.Assert(result == 1000); } JavaScript has no way to pass by reference, so we can never write code like that. http://stackoverflow.com/questions/388464/whats-the-difference-between-the-ref-and-out-keywords
That's a different story and I agree, but I'd rather have 2 complete features right now than wait for them another year to be included in a bigger package 
The main problem with this benchmark is that it doesn't do anything. A *sufficiently smart compiler*^TM can throw the entire thing away. The inner variable is never read, therefore the assignment can be skipped. The loop is now empty, therefore it can be thrown away, too. The loop counter is never read either, therefore we don't even have to set it to 1000000000 + 1. Writing micro benchmarks is hard. Without special tools, you can't even tell what you're measuring.
So can it be assumed that there will be a new spec every year? Did this only start with es2015? Why did TC39 just start to do this? Is here a write up on this decision?
And [this](https://www.destroyallsoftware.com/talks/wat) should come up somewhere in the first lessons. (no pun about `this` intended, although it kind of fits ;D) *EDIT: found out why audio didn't work for me, was an error on my end, so removed the inofficial mirror again*
Yeah, that was the reason for the name change. "ES6" had a huge release of changes, and to be more practical they decided to have a new release every year which would be smaller, but more frequent. You can read about the new release process [here](http://www.2ality.com/2015/11/tc39-process.html). 
The first example, executes the alert function and returns its return value (undefined) The second example returns a function that can be executed later that will call alert with OK. 
There's a lot of relatively small changes that most people probably won't notice. There are two appendices listing loads.
"I wanted to make Pod Casting as simple as visiting your site"... you already HAVE a server in that case... really not sure what the goal is here but there are a heck of a lot of variables introduced.
ooh, `Array.prototype.includes` seems cool! gone are the days of setting a trigger and looping through a huge array i guess.
Ignoring that at some point some place must serve the URL somehow, the biggest challenge I see is the application's link to the network where it shares content. We aren't at a place where that link will generally be of a quality to allow bit torrent style p2p to be timely or efficient. Maybe some day public wireless and cellular data will be of higher quality than today, but for now it seems like this concept is very forward-looking and not so much for the here and now.
Anything that isn't a primitive (number, string, boolean, undefined, null), i.e., anything that doesn't have any properties, is an object. This includes functions, i.e., functions are objects. Functions, however, can be executed.
I'm kind of curious as to what you tried to Google? It shouldn't be too difficult to find exactly this sort of thing I found a few hits with "js string similarity"
http://stackoverflow.com/questions/762011/let-keyword-vs-var-keyword Good answers. Worth a read.
if the source code is minified you can run it through an unminifier, unless you've got the original source for it, as for finding what code is causing the changes to be made, you can use the "break on" feature in Chrome to break on Attribute modifications on the element which is having a class set, this should get you to (roughly) the right location to find what code is being called from.
you can also check npmjs for indexeddb implementations: https://www.npmjs.com/search?q=indexeddb But I think the answer from /u/voidvector is the correct one : ). Go with a simple object in memory and maybe add lodash for some "queries". 
I think theoretically you could have your whole app in one giant template string.
Yeah but i'm not finding anything on the website that makes it a clear read. Surely others have summarised it, but it would go a long way if they made it easier to see from the source
They're having yearly releases to make sure that they don't have another 6 year period without any updates. Either way though you're still going to get the same number of updates as you would before. They're just going to be released in small yearly releases so the features that are completed can be released when they're ready, instead of releasing them in 5ish years along side the next big update.
This is the same as var a = "..." = (function(){ return "-" })() + "..."; Why would it be considered bad to use self invoked functions anywhere?
Why would you pick JavaScript?! There are way to many gotchas in the language that will mess up and confuse new programmers A new programmer should start by learning something like Python or Java
The whole es 2016-2017 yearly release cycle and how poorly managed its been was one the main motivators for me moving away from js/node development. That and the clusterfuck that npm has become.
If you are excited for async/await, you can get pretty much the same functionality using generators and promises. 
When were those the days? `arr.includes(foo)` and `arr.indexOf(foo) !== -1` are already basically equivalent. The only exception is when you're trying to find if the array includes NaN. I mean sure, includes is more readable, but you've never had to loop through an array manually to check if it includes some value
Because it's not particularly readable. You might as well just do function getWoop() { // For loop to do stuff here } var template = `This is a test. ${getWoop()}`;
You're right, you have a server. But one that is just serving a — mostly static — SPA. As opposed to one that is hosting/streaming terabytes of data. That's quite the difference.
I think that's the point of template strings, to be a language-level template engine. When you use a tagged template helper it makes them even more powerful, since you can return non-string values. They have access to scope variables. Basically they win over traditional engines in everything except syntax which I find to be ugly in complex cases.
Thanks for clarifying.
Oh yeah, totally; it's called [levelDB](https://github.com/Level/level) and is one of the staple technologies in Node. `level` also happens to be the technology that powers IndexedDB in the browser. `level` is the "L" in the `lebron` stack - http://lebron.technology/
String manipulation is a bad way to code. This changes code that your editor can understand and check into essentially a type of eval. I would really hate to debug code if someone wrote the strings incorrectly.
I would argue that it would impact code readability in a bad way.
As a noob, please enlighten !!!
What's your problem?
&gt;They really should have waited a year or something, Feature creep waits for nobody.
&gt; ES5 to ES6 took 6 years. Would you prefer if nothing changes until 2021? &gt; yes.
yeah and so?
So don't use let?
I'm looking samples too and I found this one: http://4dev.tech/2016/03/login-screen-and-authentication-with-angular2/ I think it is a good start point. I dont want to use Oauth samples because it works with them, I want something I can use with out a third party to handle my authentication.
Why? Or are you being sarcastic?
The only thing I'd really love to see is a good binary format and a VM standard for executing these binaries. In this world of transpiling I don't care about vanilla JS anymore.
it just seems a little off, torrent works by having data that lots of people are interested in, and it is a static copy of it. That is where the robustness of it comes in, someone is bound to be online that downloaded the version of the thing you are looking for. web app sync data doesn't seem to be either something lots of other people would download, or that is very static over time. So you would still have to have something out there, online, waiting to serve up the sync data that is unique to your web app... and we aren't talking terabytes if it is your desktop at home.
Its not even clear what this project is about, what is a javascript search engine, how to use it, what can I use it for, and why VB, most of all. If you are to release an open source project to the public you better describe it.
&gt; es 2016-2017 It's es2015 and es2016 &gt; how poorly managed its been In what regard? I've been very pleased with the consistency and transparency of the ECMA team. Besides, it's hardly been 2 years. &gt; That and the clusterfuck that npm has become. Eh, no disagreement here ;)
Static vs dynamic content is not the primary benefit of distributed hosting here. If he has only 1 server and 100,000 users then all 100,000 users have to share the 1 server. In a torrent, or distributed scenario, everyone is downloading from each other. This is more affordable for the content distributed (because maybe they cannot afford the necessary amount of bandwidth to accommodate all their users). An example, lets say the static website is 0.5mb and the podcast is 10mb. Without distributed hosting, OP's server has to spend 10.5mb each time someone visits his website. In a distributed system, his server only has to spend 0.5mb because the 10mb podcast is being downloaded from peers. This is much more manageable and scales to more users without having to do anything. And if OP uses app cache each site visit is really like 0.1mb.
Adding more features to Javascript every year *will* bring it to the same clusterfuck that is PHP. Javascript was intended to be a simple dynamic language. Suddenly it's started incorporating features from other languages and adding syntactic sugar that isn't really needed except by people who dislike javascript because it isn't more like their favorite programming language - and they still shit on it, it will never be as good as they think it should be. Sorry, no thanks. I'll stick with simple Javascript, not the clusterfuck it's becoming. 
That was my takeaway as well. It seems very simple, but from reading the documentation, a lot of the heavy lifting is actually delegated to D3, which, while the abstraction can be handy, would leave more room for error when things become considerably complicated. From what it looks like, in the attempt to improve modularity, it results in less portable chunks of code, which doesn't sit well with me. What I mean by that: breaking up the functionality of a graphical representation in a way that separates concerns seems less intuitive when all that functionality is baked into a single component.
I'm saying the nature of the data is what makes bittorrent work :/ your app still needs to seed the data, offload it to a server and hope someone else downloads it AND seeds it. Who is your first seeder, once you get it off your phone? When does it decide it is safe to delete its copy (what guarantees that anyone wants to watch your video AND serve it up to other people?!?) There seems to be a large gap between simple peer 2 peer, and data that is actually torrent-worthy where it will self sustain. plus anyone that wants to can poison your application data, https://en.wikipedia.org/wiki/Torrent_poisoning &gt;This is much more manageable and scales to more users without having to do anything. I think that might be the naive statement of the week.
As the other comments are noting, they aren't really the same. If the aligned the year and the old name like that, even accidentally, it would lead even more people to think they were actually related, when they aren't. https://www.reddit.com/r/javascript/comments/4ohk1e/ecmascript_2016_approved/d4cz0p8 
I haven't figured out ES5 yet and I'm still trying to grasp ES6... fuk
I don't recall if its a plugin or comes with Chrome, but when viewing JS in the Source view you may see a {} button which pretty prints the javascript for you.
So you don't like anything in ES2015/ES6? How can you not like arrow functions?
checkout protractor http://www.protractortest.org/#/ It was written for angular for equally works for other frameworks. I am using it for testing backbone.
The widgets are built into OS X. AFAIK there is no support for custom widgets.
You should consider adding context and putting the error message if you want help with debugging. 
your missing a } at the end? your indenting is off by 1. this works (i simplified it and added a `}` at the end, and fixed the tabs). not sure tbh function changeImage(element_id, other_element_id, link_id) { foo(); if (false) { foo(); } else { $.getJSON("/javascript_functions/click_handler.cfc", { foo: bar }, function(success_or_failure, other_element_id) { if (success_or_failure == true) { foo(); } }) } }
I was searching on AngularJS2. I can't believe I made that typo in the title. 
I think I'm going to buy this course: https://www.udemy.com/angular-2-and-nodejs-the-practical-guide/ It's only $15. It won't break the bank and I think it will help me out.
I'm going to take a look at this tutorial: https://www.udemy.com/angular-2-and-nodejs-the-practical-guide/ I'll give you some feedback if it's good or not.
they are not completely the same, the first is just a line-saver/shortcut, its the same as: alert('ok') return people write like that so they can do if (foo) return alert('ok') bar() // dont have to write {} and else{...} // wow such save the second is returning a function... so you can do like `foo = somefn(); foo(); //alert('ok')` or `somefn()()`
What is the output of the console thing? Either firebug or the google thingy? What is /javascript_functions/click_handler.cfc returning? (are you sure the response header [is correct](http://stackoverflow.com/questions/477816/what-is-the-correct-json-content-type)?) 
Thanks I will check it out! 
"*clean*"
I wish there was a widely used tag on Stack-overflow and google search/trends recognized called Angular2JS as well as Angular2TS :) For example, see https://www.google.com/trends/explore#q=angular%2C%20angularjs%2C%20angular.js%2C%20angular1%2C%20angular2&amp;cmpt=q&amp;tz=Etc%2FGMT%2B4
add the colors to the 2nd one and delete the first one (i didnt know what one to use :p) or just merge the two, var options = {a: 1, b:2} ... chart.draw(data, { c: 3, d: 4}) becomes var options = { a: 1, b: 2, c: 3, d: 4 } chart.draw(data,options) just take out the ones you dont need 
Currently they don't have much for Angular 2, just a quick overview of the various things in Angular 2 http://www.lynda.com/AngularJS-tutorials/AngularJS-2-Essential-Training/422834-2.html?srchtrk=index%3a1%0alinktypeid%3a2%0aq%3aangular+2%0apage%3a1%0as%3arelevance%0asa%3atrue%0aproducttypeid%3a2
You can do this in C# as well. It's a side effect of allowing expressions inside strings.
I'm self taught as well and decided to help bridge the gap in 2 ways: Read this book...Its not gospel for how every interview will go, but will give you an idea of how a CS heavy interview might go: https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/098478280X If you have enough time, follow the videos in this course and also get the pdf of the book. The topics will be quite dense at first, but keep at it and they will eventually make sense: http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/calendar/ To reiterate the same as others, its meant to weed out people who don't have a CS background; but don't be afraid to say you don't know something. Use that as an advantage and come prepared with situations where you didn't know something, but were able to read up/comprehend it and then applied the knowledge as a new skill :) Its impossible for everyone to know everything as a developer, we can only keep learning :)
es2015 is here already, 2016-2017 are the next two releases. I believe it is poorly managed because the entire js community is now depending on babel to make these features available for use in a timely manner. Not to mention what a pain in the ass it is going to be in a couple years to try to untangle all the different js versions in use now. I dropped js as my primary dev language. im investing heavily in elm for the front end, and a variety of languages on the backend that are chosen depending on my use case. Right now that is mostly Haskell, Scala, and Go.
I'm a big fan of Go too. Not brave enough to use anything but JS on the frontend.
Is that because the objects are released more quickly?
Thank you for your help. Just to let you know that Chrome for iPad does not support 'constant' or 'let' as of today. I was enjoying the cleanliness of let instead of var. Oh well, maybe one day.
&gt; Why are these kinds of releases always so damn unreadable. Simply give me a list of things that changed... Because it's strict specification for implementations, not for everyday use.
&gt; [arrow functions] don't make getting work done any easier They do though. There are many cases where a lexical `this` is more convenient.
btw, some of us browse with third-party traffic disabled: http://i.imgur.com/0rVpx6t.png
Not true, i browse on mobile with js disabled most of the time.
There is WebAssembly (wasm) for that. https://webassembly.github.io/ Since we'll need JS polyfills for that, adding things like SIMD and threads to JS will help a lot.
Use your own logging function: function log() { if (environment === "development") { console.log.apply(console, arguments); } } Then use it like log("something"); 
ES7... 2017 ES11... 2021 Yea, doesn't help one bit. Well, we could just skip the "20". ES16 instead of ES2016.
Hi /u/FQueiros, `webynote.com` is now banned for plagiarism. http://weblogs.asp.net/dwahlin/getting-started-with-es6-%E2%80%93-the-next-version-of-javascript
I and others have no problem using javascript effectively on 100,000+ lines of code, YMMV.
should be called partial. I think https://github.com/mindeavor/es-pipeline-operator would be a more valuable addition to the language.
Thanks!! 
Are those all the increment and decrement operators? Seems to be missing a++ and --a. 
Could anybody tell me why `var f=function(){}` seems more popular than `function f(){}`? The latter is named function and we can see its name on the stack trace if an error occurs.
sounds cool
This is not the fault of JS. It's browsers, specifically IE.
Err, they do? I actually worked on the source for a JS engine for a while, and that was actually when I started running NoScript in anger.
Not sure if this meets your exact specifications, but still pretty great nonetheless: https://github.com/getify/You-Dont-Know-JS
&gt; PHP is a clusterfuck because of its history and people requiring backwards compatibility for shitty things like PHP 4 style OOP, or the ineptly named standard library functions. You haven't convinced me that the future of javascript isn't going to be a clusterfuck, similar to PHP. It's already a cluserfuck because now anything goes - javscript is getting bloated already, and with each passing year comes more bloat, more feature creep and with it even more ways for people to fuck it up.
Wow. I'm way behind in webpack. I was happy to get it to uglify. Why the bundle was nearly 2 megs was a project for another day. 
second one is hoisted to the global scope the other is defined within whatever scope it is declared in. you can always do var f = function f(){} for stack tracing purposes too. 
The second one stays within its function scope just like the first one, although it is hoisted to the top of it.
Missing all bitwise operators (eg: `&lt;&lt;` `^`, `|`, `&amp;`, `&gt;&gt;`)
Uh, it's missing a lot of ES6 stuff. Arrow functions, classes, generators, etc. ES6 is standard now, so it should be part of the picture.
I do tantrum? You do timeout.
how do you handle `environment` when you're serving up a package on npm? If I assume the consumer is using webpack + node, i could write in `'process.env.NODE_ENV'`, but I think it's kinda unfair to assume they'll include that as a compile-time variable, right? 
Can I get a TL;DR for the changes from ES2015 to ES2016?
http://exploringjs.com
For future readers, that last link referenced using uglify to do this with a DEBUG constant, so i think i could do something like `DEBUG &amp;&amp; this.debug &amp;&amp; console.log('foo')` where `DEBUG` is an uglify constant, `this.debug` is a runtime variable that can be toggled in development. So when someone includes my package, their uglify process will nuke the logs. 
Came here to recommend Kyle Simpson's Advanced Javascript course on Frontend Masters. He wrote You Don't Know JS, also. Fantastic resources. 
Then the second one should be preferred for same reason `const` is better than `let`? Unless the function catches some variable?
Indeed.
So what? are you the only developer in the whole while world? Let a chance to the new ones to learn too!
JavaScript is a strange choice. People complain about how Java function signatures are just magic incantations when you start programming, but what are the odds any new programmer would understand the point of the IIFE or the countless gotchas in JS? Sure, JS is accessible, because anyone can write a line or two of JavaScript and probably get it to do what they want, more or less, without using the best practices, but it makes it somewhat hard to write sound, well-structured code unless you have a lot of discipline.
In this case the benefit of P2P isn't about creating a self-sustaining ecosystem, but rather to be able to handle large spikes in traffic (reddit hug of death) and reduce bandwidth costs for popular content.
I thought one point of await, among others, was to avoid multiple nesting. With your proposal, you don't get this.
Thank you for the elaborate answer, kind stranger. I have read half of the javascript Allonge a few months ago but I felt that at times it was progressing to slow and then it had random picking-ups (so to say) of the pace which made me scratch my head for dozens of minutes at a time and read-read through long bits of code (which I find rather hard to do on a kindle). Overall I felt it was too focused on patterns and not enough on why those patterns are good and why they work. I have downloaded and will hopefully be able to go through the "You Don't know JS" series within the next month. I've also treated myself to Eloquent Javascript but it seems the the foremost (while a little bit longer) is written more to my liking. I shall also try looking into the ES6 "way" of doing things. Is there a book that specifically deals with ES6 javascript but includes older features that are still needed ? (As in: talks about new ES6 features, talks about old javascript features which are still very much needed but ignores outdated practices that might crop up in other "beginners books")... that is, of course, if there is such things are outdated practices that are still supported in js (I know PHP had plenty).
Also the new exponentiation operator (`**`), although I don't know if they were planning on including all the es-next stuff.
I'm not sure I would agree that either one is necessarily more popular than the other. You can still see the former in a stack trace if you name it. var f = function f(){}
This sub is called r/javascript. And this answer is downvoted. Am I taking crazy pills? 
Not sure who told you no-one cares about TypeScript. https://www.google.com/trends/explore#q=typescript%2C%20coffeescript&amp;cmpt=q&amp;tz=Etc%2FGMT%2B7 And the answer is yes, it can. ES6 has classes. TypeScript is obviously the next step up from there.
`` is template string. Other one is JSX which gets transpiled to function calls 
I like Javascript a lot, I use node.js at work, ajax is great, but I don't like entirely javascript-rendered sites and SPAs. I think that a site should be able to function with Javascript disabled, because everybody has Javascript disabled while the page is in the process of loading. So if your site is 100% reliant on Javascript to load, it is quite poor UX to expect the user to sit there and wait before they can click anything, or in some cases even see anything. A lot of developers lose sight of the time it can take for a page to load too because they're often sitting in front of 4k retina displays with a fibre connection piping data into their face, they're not on an old phone in a mobile blackspot with 2 bars and an edge connection (which incidentally is what I get in this new house I'm moving into). There are also a lot of people in the developing world who rely on old, sometimes non-touchscreen mobile phones running browsers like Opera Mini which are used to reduce mobile data usage because Opera run everything through a proxy that precomputes all of the Javascript and compresses the resulting html/css before sending it to the browser, meaning you can't have interactive Javascript on a device running Opera Mini. So yeah Javascript is great, that doesn't mean you should ignore users who can't browse your site under optimal conditions.
The current design doesn't feel right. Because `await` as a function is what my brain is expecting. It's just weird to look at since JavaScript is asynchronous. It feels impure.
Cool!
Make it actually relevant. https://www.google.com/trends/explore#q=typescript%2C%20javascript&amp;date=1%2F2016%2012m&amp;cmpt=q&amp;tz=Etc%2FGMT%2B7
Dependency-free, on-screen logging tool: https://github.com/jonbri/ticker-log Show logs in a "ticker-tape" fashion made interactive via keyboard chords. Useful for: - quick, ad-hoc testing (a replacement for `alert(someVariable)`) - testing on mobile devices where the console is not easily view-able Play with ticker-log: https://jonbri.github.io/ticker-log/ 
That's just syntax. That's like printing all Chinese characters and saying "Chinese in one picture". If you know nothing about Chinese, have fun learning anything from that. So, at most it is "Javascript *syntax* in one picture".
This is OSS, no? Why not just submit a PR?
Why aren't all the commenters in this thread talking about omissions forking and doing a pull request instead of leaving a Reddit comment? Even an issue would be better than a Reddit comment - this is the whole point of OSS, no?
Maybe you generate that kind of picture which is contains ES6 :))
I understand the intent, but this has some issues. If you are doing anything with that number inside the complex logic part, an object won't work. I am not a fan of passing an incorrect type for the sake of testing. Garbage in, garbage out. An object avoids the false positive problem, but introduced an issue if anyone tries to use that index instead of just passing it through. If I made a change to use the index in that function, the test shouldn't fail. This function doesn't take an object. I guess you could implement valueOf on the object, but that seems too clever and will probably lead to issues. The best way to test this is just write 2 tests with different values. It doesn't cause issues and doesn't have false positives.
When doing helper packages like this, I often wonder why people give them random names and not just short descriptive meaningful names. You named about 50 lines of code, and now I will never use it because when I look at NPM, I'm not going to know what "durare" is. If you named it "time-conversion" or something like that, I'd at least know what it does. Named packages make more sense when they aren't single purpose packages. For instance, "Moment" is a good name for a package that handles time conversion... And when you were Googling around and getting frustrated, I wonder if you came across Moment? I for one have never once been frustrated while working with Moment to manage time.
Ideally if you had the control over the backend of the API you could either make a single endpoint with all this "metadata" so you could make a single request, or work on optimizing the backend queries. Obviously this is out of your control, so you'll have to be more creative. Personally, I would create a pleasant "loading state" experience in combination with Promise.all. I think users are ok with something like a loading spinner, which you then transition out of when all the promises resolve. Especially if it's only 1-2 seconds. Another approach is designing your app to lazy load the data either when the user scrolls to a certain point, or create a simple nav menu that makes the requests only when the user wants that data. Then you have the data if the user clicks back to a state they have already visited. In general, think about it more like a UX problem than a technical problem, and design an experience that helps you work around the sometimes slow requests. Even if the API requests were faster you would want to consider this, because no API is perfectly fast all the time.
i just can't find beauty in that. Do you find it symmetric with the other language syntax?
I got ripped a new one on my early packages. The first few lines in your README should contain a usage example which illustrates what it does. Then a quick summary, these are examples. Then the appendix of each method which links to an example. As valuable as your package may be, imagine how frustrated you were and put yourself back in those shoes and read your README as if a stranger wrote it. Did it reduce anxiety?
Hi, thanks for the reply. My app works in a way that lazy loading wouldn't work. You get to the index, and you type a steamid you'd want to check. The server then redirects you to a page with the requst-params set to the steamid and the backend chekcs the req-params and then sends the API request with that. But I guess it's fine if I redirect the requests and render the page, since they probably wouldnt notice the diffrence of 1-2s.
Not directed at OP, just general banter: Can we get a rule that says if you're going to be posting asking for help on a piece of code, that you have that code in JSbin or Codepen or something like that? 
It may look better but the `async` is the parent of the operation and is visually contained by its children. In your second example, the relationships are honestly represented.
Why using `var f` then?
Sorry it's hard to visualize just what you mean without seeing the code. Anyway you can put it on code pen? 
&gt; If you are doing anything with that number inside the complex logic part, an object won't work. That is why the other example uses `new Number(5)` instead that should be duck typed to a primitive. &gt; The best way to test this is just write 2 tests with different values. It doesn't cause issues and doesn't have false positives. It is a good robust alternative, but doesn't work in 100% of the times if we expect is a collection instead of a single value...
I'd, but I realized it wouldnt make a diffrence. Gonna close the thread. Ty for reply tho.
The article tests something different, in the examples of the article we are not checking the property of the function so that that any 0-based index `n` should return a valid value, but checking whether the mock is called with the same argument of the parent function. We can easily test that the function return valid values if `n` is greater than 10 by checking the property, something like if `!!factorial(Number.MAX_VALUE)`. I agree that there are many other strategies for different use cases.
&gt; This approach seems limited to functions only where you know for sure the function you're calling isn't going to do any input validation and type conversion on the value before calling the callback with the sanitised value. You're right, it assumes duck typing to the number. &gt; In that case, passing in an object and expecting it to be passed directly through to the callback would give a false negative test result. Definitely, although I would argue that a false **negative** has more value than a false **positive**, because a false positive will go unnoticed.
Go for OpenID
I dont punctuate
Semantically they are the same, both sets the value of a variable somewhere else in the application. I could've just defined a function called `Return` and invoked it: function myFunc (input) { // arbitrary implementation whether it be array indexing or complex operation Return(result); } 
&gt; second one is hoisted to the global scope a function is hoisted to the top of the scope in which it is defined. ftfy
I've had this working recently. If you download the repo from Git it will have example pages in there for you to look at.
Considering all you have posted is links to your own blog, I feel a need to politely point you towards Reddit's policy on self-promotion: https://www.reddit.com/wiki/selfpromotion
The readme pretty much lays out the JS for you. Looks like the only real thing missing are the other dependent js files and the html5 call
Yes, any expression can go in a template string. This means you can use sequence expressions too: `${1, 2, 3, 4}` --&gt; 4 
Thanks!
&gt;Despite not being objects, primitives will auto-box themselves using object wrapper classes, so they act like objects under most circumstances. A caveat with this is that it can sometimes make unexpected things happen if you don't know the details. For example, what is the output of the following? let x = 1; x.y = "It's-a me, Mario!" console.log(x.y); The answer is `undefined`. On the second line, `x` got autoboxed so that it could be treated as an object, but the *variable* x was not affected. You could roughly rewrite this as: let x = 1; new Number(x).y = "It's-a me, Mario!" console.log(x.y); which is more or less equivalent.
This is one my biggest annoyances with JS. I really wish they'd just done the maybe-monad thing and let null and undefined simply swallow property accesses.
I don't think you've thought this through. "One word" is a superficial similarity. There's no reason similar things must use the same number of words, though I do think it'd be a nice coincidence. More importantly, `forEach` is fundamentally different from what you want it to "fall in line with": all of the others return their result, `forEach` does not. The name "forEach" makes that clear, the name "each" does not. In fact, a bare "each" is synonymous with "every", already creating a big ambiguity problem. And that problem arises because "each" is less precise. I don't know how you can imagine a single word is "more precise" than that word and another. Speaking of falling in line with things, "for ... each" and "for ... in" are by far the most popular identifiers for what `forEach` does. Is there even a language that uses a bare "each"? The "pain" the four extra key presses inflict is trivial and far outweighed by the ambiguity that `each` introduces. &gt; frankly, the other languages are laughing at us about this. And that statement, if I had any respect for your argument before, just blew it. Pointing and laughing is how children influence others, not adults.
I agree with this aspect of it. "Back in the day", which for me was the early 80's, you learned on computers like the Apple ][, VIC20, C64, PET, TRS80, Atari (my first), etc. and you turned them on and you were "in" BASIC and could write a program and run it. And for the most part, the "basic" BASIC was the same across all of them. No loading, no compiling, it just ran. Today's browsers, with JavaScript and HTML, are the equivalent for the most part.
Only exported ones or internal ones as well? For exported ones, you can just import them, and loop thru the names. If you want internal ones, Regex is probably the easiest for one-time runs, but it might not be accurate, so you would need to clean up the results. If you need highly accurate version, you parse the AST using a parser (Esprima, TypeScript compiler API). E.g. http://esprima.org/demo/parse.html?code=%2F%2F%20Life%2C%20Universe%2C%20and%20Everything%0Avar%20answer%20%3D%206%20*%207%3B%0A%0Avar%20x%20%3D%20function%20()%20%7B%0A%7D%0A%0Afunction%20y()%20%7B%0A%7D%0A
Store JWT in cookie, not LocalStorage. 
I hope you're not planning to do anything with that information.
Of course they are (incoming psuedocode) if ({the number} == +[]-+[]){return true;}
https://www.reddit.com/r/ProgrammerTIL
I think head/body doesn't matter: scripts are blocking either way. However, they can be set to be async via an attribute. It is complicated and browsers are often tooling around with exactly how this works. 
I think once you've had a bit of experience with Javascript, what can be hard is picking a style. Javascript is such a sloppy, ultra-powerful language (that's not a compliment: what I mean is that it can do just about anything at any point in a program, and that's not always a good thing for coding discipline) that there is no one right school or right answer. The Object-Oriented and Functional styles are two big "disciplines" I'm familiar with that can help guide HOW you write code and think about a complete application. I happen to prefer the FP side of things, but again: there's no "right" answer. However, there ARE a lot of cool tools out there that can help enforce certain styles. ESLint and style guides like airbnb's are a good place to start: get those working on your project, and be prepared to get tons and tons of warnings to fix... and learn a heck of a lot by going through and fixing them all.
Not if you were german during the interbellum. 
That's what I use with express. I think it uses cookies by default but can use tokens if configured that way.
Your second line sets both prototypes to the same object. Any methods you add to Child's prototype would appear on Parent instances as well, which is almost certainly not what you want, because the whole point is that Child has additional or more specific capabilities that Parent does not. 
Yes, that can work, but the problem is that you're calling the constructor. Often, a constructor has effects that you don't want to happen on a prototype.
Exactly, it will say that Parent is not a constructor.
Are you sure? console.log(0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000247032822920623272088284396434110686182529901307162382212792841250337753635104376) here prints 5e-324. Note that Number.MIN_VALUE is the smallest representable number greater than 0. A number one digit smaller than it, therefore, is rounded to 0.
Super easy for spammers to strip all the shit between + and @. Do you people not have a Hotmail account for shit like this? 
Coming across this issue in day to day coding has led me to realise that this is a form of code smell, I then usually break the complex operation up into a series of small pure function calls that I can test deterministically. When I know that these functions are really doing their job properly, I can be safe in the knowledge that calling them in the top level function will produce the correct answer. I'll then potentially run an integration test over the top of it just to make sure it all hangs together properly. 
This is definitely a code smell and an integration test is definitely a good approach for this type of testing, that's why the article mentions to imagine handling this while trying to test a legacy code (where sometimes integration tests can't be done). Ideally if one will create a new application, that application should use the lowest amount of mocks as possible, and code that do IO/database operations should be abstracted away into the application domain (with functions that have no business logic, only adapters).
What does that do?
&gt;1p-1075 What's that?
Sorry, I'm very green and a tad dumb. Still not getting it. This part looks very odd to me: &gt;+[]-+[]
Actually `+[]` is equal to 0 and not one, since `[].toString()` will be `""` and when that is casted to number it'll be 0.
Are cookies more secure?
Not sure if the 'p' is a typo or notation I'm not familiar with, but `1e-1075` is shorthand for 1 * 10^(-1075) (and in general XeY is shorthand for X * 10^Y https://en.wikipedia.org/wiki/Scientific_notation#E_notation). Of course that's all in base 10, but in this number's 'natural base' of 2, we might think of 1e-1075 as 1 * 2^(-1075).
I finally got it to work, At the end of the day I used php. I never knew php was able to run in a hosting. If anybody needs the source code pm me.
That's likely me just screwing up then. Thanks for the correction. Edit: +!+[]
Yeah, that's my bad. It's actually +!+[] that maps to one.
No code?
Shit I didn't link it. Will update now
Use typescript. You don't have to go all in. Just use the parts that help you.
No idea what you've written or what you're asking.
https://github.com/coodict/javascript-in-one-pic/pull/40
now we can code the memes... feelsgoodman
Yeah I think this is only way you can send the jwt on first request, which is important if you have server side rendering.
I forgot about Akinator! After some Googling, I was pointed in the direction of _20 Questions_, which led to binary search trees. There's a good [C# tutorial](http://www.c-sharpcorner.com/uploadfile/4a950c/20-questions-guessing-game-using-binary-trees/) I found, and consequently maybe I've found a new weekend project...
This is an amazing teaching tool. Thx
[The accompanying blog post](https://glebbahmutov.com/blog/journey-from-procedural-to-reactive-javascript-with-stops/) provides some more context and a sensible order of going through them.
Thanks, I've completely missed it out. Will take into consideration!
For discussion only, which was your favorite? My personal go-to style was 2-oo.js but I really liked the look of the 2-es6.js. I haven't gotten into es6 yet at all but this simple intro helped me understand a little better
Definitely get into ES6 or, at it's supposed to be called now, _just Javascript_. The language has gotten so much leaner. It also works very smoothly with reactive programming. Check [this example](https://jsfiddle.net/vhb4jcw9/) I made for a recent blog post, and compare it with [a version without ES6](https://jsfiddle.net/d7hvta70/1/). And that's only using arrow functions!
What do you mean by work? If none of the interactive stuff works then it's probably because you need some simple webserver to serve the .js files, otherwise your browser won't want to load them. 
ES6 conveniently introduced it into the Number object: [Number.EPSILON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON)
I do use Atom, have you managed to fix it somehow ?
It _should_ work after closing Atom, but I'm not sure if theres a real fix for the issue.
That's what I'm leaning towards too! Thanks!
That may just be a quirk about your specific code - if you're triggering additional async functions from your listener, they occur *after* all the currently scheduled listeners in the event queue. So all the results would happen at the same time. 
Hey /u/chedderslam if you want to get help in the future you either provide us with the details we asked for. instead of just dumping your shit in here and hightail it out of here :( It's not like we are getting paid to do this, or I could paint you a gorgeous "javascript" and you pay me and I'll fix your problem.
ASM is beautiful.
Are there any bindings for BLAS or ATLAS libraries for numerical computations in JavaScript? I'm curious, because it can be quite interesting to build complex machine learning algorithms in JavaScript.
Cool, didn't think it'd be entertaining with such a simple example, but it was. Some additional possibilities: monads, CSP, actor model, parallelism through web workers, list/generator comprehensions. Never ending list with javascript. Hell, you could probably make a lisp out of tagged template literals.
I dont think there are, this is a simple custom implementation from scratch.
Thanks
I don't know if JS will be helpful for you to learn, especially if you plan on doing complex math. You may look into R.
Cool, I have a free web-host set up with cpanel. Ill upload the example files from the repo and give it a shot. Thanks!
was bored so heres a es6 version //to fill top to bottom images.map((i,img)=&gt;$(divs[i/6|0]).append(img)) // to fill left to right (ex 3 col layout) var row = 0 images.map((i,img)=&gt;{ $(divs[row]).append(img); row = ++row &gt; 2 ? 0 : row }) two line full solution var row = 0; $('#someContainer').children().sort(sorter).map((i,img)=&gt;{ $(['#div1', '#div2', '#div3'][row]).append(img); row = ++row &gt; 2 ? 0 : row }).remove() 
Look at the very last line of the file. When the IIFE is invoked, the argument is passed as `typeof self !== 'undefined' ? self : this` So if self is already something defined, it will use that. Otherwise, it will use `this`, which is a reference to the global scope (window in the case of a browser).
Where did that "json" file originate? This is definitely not a standard JSON. Is it from some *object serialization* maybe?
&gt; code written using 2 spaces end up looking like my rear end [citation will be provided upon request]. Who's going to be first to ask for pics of his rear end?
There are plenty of simple and free webservers to download if you can be bothered with that. 
I hate all of you that do this: function foo() { }
Why should you have to do something more complicated than this ? [3, 1, 7].map(n =&gt; n * 2)
It's all personal preference and with a good programming font the issue is basically moot. I've been coding since the BC3.1 days and even then never used 4 but rather 3 spaces for tab indents. A while back I decided to try 2, took a day or so to adjust but now am a full convert. All that aside your editor/ide should be able to adjust the indent spacing to render it a non-issue. 
Because `self` works in Web Workers, whereas maybe `window` doesn't? Fetch can be used in workers, so maybe this was just an attempt at supporting both.
Chrome dev tools has a promise inspector built in that does a pretty good job
He's not saying that you should use any of these particular methods, the blog post that goes with this code is simply an exploration of these different styles of thinking with a simple example. Not only is it a good source for showing how the code looks in each, it explains some of the possible benefits of each, which when looked at through the lens of this example, is overkill, but can be helpful in explaining "why" these styles of coding exist. 
No offense, but it sounds like you may be chasing a fool's errand... people have been trying to "protect" their scripts for almost 20 years, and I believe they've all failed miserably. &gt; at least some impossible-to-reverse behaviour. How so? JS can't be compiled down any further than JS, so whatever you're trying to do in JS will always be reversible if you don't produce a binary. WebAssembly may change this though. &gt; Is there a library that I'm missing, or JS obfuscation really ends at minification + mangling? I think by definition of JS being the target language, that is all you'll be able to do, at least in the browser; if you were on Node perhaps there would be some other options (e.g. targeting C/C++/etc. with a binary).
So, a prop can be used as a function too instead of just storing data into it?
That wouldn't cover rejections, would it? I admit fiddling with a system object is not very elegant, but neither is console.log-oriented debugging and still I find it's the most productive way for me. I do a lot of REPL testing too, and the node REPL isn't very friendly so the less typing the better.
&gt; then you can't reverse it that easily. &gt; [...] &gt; might make someone's job quite hard That's all very subjective, what's "quite hard" for you and I is going to be trivial for the highly-skilled (those in the security industry, for example). Every time obfuscated code gets posted here, it's decoded in a matter of hours at most. The only thing obfuscation, regardless of what flavor, is going to do for you is buy you a few minutes or hours. Only the very naive will be unable to break it, since if anyone even has the idea to post it to /r/javascript or similar then the obfuscation will be virtually worthless. Ever find a page that had disabled right-click? I'm sure that developer (or the PM perhaps) thought they were real clever, but just how much did that slow you down from inspecting the code? That's essentially what obfuscation is, a speedbump at most. Additionally, if you consider the development time in creating, configuring, and maintaining the obfuscation, and whatever runtime overhead, then you're actually losing value overall. I would advise to spend your resources on proper licensing and contracts _instead_ of obfuscating, as opposed to in addition to. 
I disagree, 2 spaces is just fine. I've seen plenty of C code written with 2 spaces (e.g., GNU code) and they are plenty readable.
Yep, remember in js functions are objects and can be passed as such. This isn't something unique to react
Ah! Feeling stupid as this is such a fundamental principle of JS.
Hi /u/28blabs, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
True, still ops answer is the correct answer 99% of the time. Map is so powerful it feels like cheating! 
Nope. That's a regular notification. I'm looking to make a "widget" that goes inside the "notification center" (the thing that slides in from the right of your screen that shows the date, etc..)
But `this` would be undefined if you `use strict`
Heck: .then(x =&gt; !console.log(x) &amp;&amp; x) is usually so quick and easy that I just type it out. Or just wrap it in a curried function that allows pre-configuration of the static part of the message. Adding a method to a strictly defined Type is probably a bad production practice in general (though obviously harmless for one offs/dev use).
A competitor to Baobab maybe?
If you have python3 installed (there's another command for 2) just run `python3 -m http.server` in the dir and it should start serving on localhost. 
Now I'm not going to be able to get the Clapton song out of my head all day.
Yeah, I've seen that pattern floating around a lot lately, and it definitely has a lot of benefits with regards to pairing up components with styling. The way the app is currently structured actually allows for this, but it might be worthwhile adding another 'step' that reorganises the components to each get their own folder with *.js and *.less files Also, you made me realise I have no images in here whatsoever, which is definitely an issue. Will need to add them to. Maybe with an image babel-loader
would you have to do css imports if doing this? does this make it difficult to use a css preprocessor or to share some basestyles?
What you think happens, is indeed what happens. If during parsing a HTML file, the browser encounters a script tag, it will download the file and execute it before continuing (more or less). This ensures that the script files are executed in the load order as defined in the HTML file. What you need to keep in mind is that JavaScript in the browser has a single name space, the global name space. In the browser you can refer to the global name space through the window variable, which is essentially a pointer to the global object. This JavaScript run time environment is created as soon as the browser window or tab is created. All "magic" variables (such as the document variable) are exposed to the loaded scripts through the global object. This also includes any browser specific APIs, such as XMLHttpRequest and many others. Every variable you create which doesn't have ```var``` in front of it, will automatically become a global variable, and as such a property on the global object. This is what is called an implied global. In JavaScript every variable can have any type at any time without having to define that first. The same goes for object properties. This means that a property can also be a function, and then suddenly is an object method. This is how the DOM (document object model) is exposed to the JavaScript runtime. It is a browser specific API which allows the embedded JS engine to change things in the displayed page. All in all this all very much looks like a much easier version of a C or C++ program running in a desktop environment. You can do things with or without display, but for the result you will have to interface with the libraries doing the interface. In order to make this interaction as smooth and fast as possible, many libraries have been created in order to make "real" applications in the browser. The libraries which come closest in my experience to a desktop like environment are SproutCore and Cappuccino, but there are many others which vary in how much the HTML interface has been abstracted away.
There are multiple approach how to build styles grouped per UI component, one of them is CSS Modules (via Webpack and its css-loader); another approach is CSS-in-JS that is used at Facebook; there is also BEM..
The next step might be implementing declarative data fetching (e.g. via GraphQL/Relay)
Look into reduce
&gt; people have been trying to "protect" their scripts for almost 20 years, and I believe they've all failed miserably. I wouldn't say that, e.g., **Gmail**, **google.com**, or **groups.google.com** "failed miserably" in doing so. I don't know of any successful attempt to "de-obfuscate" a few megabytes of their client-side Javascript.
I've been banging my head against the wall with PhantomJS for a couple of years, trying to make a usable test framework with it, but it's just not good enough. I really hope headless chrome can deliver all it promises but I really just need two things: * The ability to inspect the state of the browser at any time with modern dev tools * A well-documented and sane API for interacting with web pages (simulating user actions, injecting scripts, etc).
Huh this is like CS 101. Simple for loop would suffice, but as some guy mentioned below, since you posted this in JAVASCRIPT, I'd look into [array].reduce. 
I think the main problem you describe here is not caused by the combination between line-by-line and async, but the combination between async and mutability. As long as the operations you perform are kept entirely within the functions called in an asynchronous manner, it is very easy to reason about it. The same goes for functions interacting with a static environment. As soon as that environment is dynamic, and more specifically dynamic in a unpredictable way, all hell breaks loose, because suddenly all assumptions about the environment are out of the window. If you still are making assumptions that you think you can make, the chances for all kinds of race conditions skyrocket. Because pure static environments are very hard to use in a real-life environment, and also that most environments are dynamic, the most practical way is to make the dynamic environment less dynamic. The programming language Clojure does this by making every operation immutable, except a handful which can be used in a mutable way. This makes the mutability stick out, and because the mutable actions will become predictable, consequently it becomes easier to reason about. Another way of reducing the dynamics of the environment is to use state charts. In an MVC environment this very often is the role of the application controller. A state chart allows for controlled changes in application (or other) state, which makes it possible to have an asynchronous operation perform within a momentarily static environment, as you can cancel any async action if the state changes. My main experience is writing apps using SproutCore. While it doesn't carry an editor like you envision (which would be very appropriate in many other kinds of environments, think musical composition for one), it does break apart things very much in the way as you describe, and includes a state chart mechanism. My main doubt about such an editor however is that it is visual and consequently is not very suitable for sight impaired programmers, of which there are many.
Thanks :)
Got the latest episode waiting for me at home! Great show!
Spaces? Please! I use Unicode 6 emojis which are transpiled to spaces with Babel. Amateurs.
Wow how has this been open for so long?
Happens in Chrome 51, 64-bit Linux, too. And it is [clearly not a case of undefined behavior](http://www.ecma-international.org/ecma-262/5.1/#sec-11.4.3).
Visual programming (node based) unfortunately has a massive problem with not scaling very well. It becomes a mess of spaghetti incredibly fast. Although most visual programming tools are not really targeted at working *with* traditional code writing but more at replacing it. So it might well be possible to make something that has the best of both worlds.
While this is trippy, when would you need to check if `null`'s type is undefined?
Yeah it seems to only happen if you're checking, literally, `null === 'undefined'`. This evaluates correctly for me: function foo(bar) { return typeof bar === "undefined"; } var baz = null; for(var i=0; i&lt;10000; ++i) console.log(foo(baz)) `$- 10000 false`
Thanks for your feedback. Some really interesting ideas here. While I agree that a more static the environment would foster fewer side effects such as race conditions I don't feel that immutability fully addresses the issue here. I don't perceive this as a language issue nor an issue of abstraction. In javascript development it's not uncommon to have a mixture of concurrent and dependent callbacks to perform an abstracted task. Putting these callbacks in the same function in the past has lead me in to the pyramid of doom which I feel brings the issue full circle with the focus once again being on the way source code is presented. Many attempts have been made to solve such issues as race conditions. Await and promises come to mind. While both these mechanisms have merit and go some way to solving issues such as race conditions your still left with the same problem. A text file that has sequential line numbers, a set of defined functions(in the form of call backs) and no connect between these and program execution. I can't really comment on state machines in this context and I don't have any experience with SproutCore or clojure. Your thoughts on sight impaired programmers is interesting. I wonder how other applications that support node editors handle this issue.
Heh, you're definitely right - the colleague quip was meant to be tongue-in-cheek. If you're actually using reactive programming (/a framework that fully uses it), of course the entire team needs to be on board. If you aren't a beginner, though, I really do believe this style of programming helps you avoid mistakes.
Hmm... the code op posted will return true for me though after about 100 iterations, as he said it would.
Spaghetti is an issue I have been thinking about. The 3D software package blender has a node editor in it which is core to working with materials(and other things). It's powerful however node tree's can quickly become complex. I see these as UI issues and with out getting too deep in to the how rather than the why I have a couple of ideas to mitigate the spaghetti issue. The first is to support collapsible zooming. I imagine zooming as well as dragging should be a natural interaction or at least as natural as scrolling a text file. I envisage node groups that allow a number of nodes to be grouped in to a higher abstraction and to appear as a single node next to other less complex nodes to exist within the same abstraction level. The last and I feel most important mitigation of this issue is the concept of layers. Each node editor I have seen and used thus far has no concept of layers. A layer in this context can be thought of as an extra dimension of the program. I imagine layers appearing as vertical zones running form left to right. The first layer is the entry point of the application. Each layer thereafter represents one callback operation away from that layer. These layers coupled with node separation should make it easy to determine a given line of code with in the context of a program. It is this dimension I hope that will simplify more complex call backs that consist of a mixture of both dependent and concurrent operations.
Hard to tell *how* the code is optimized in your case. It's possible for example that the `foo(baz)` function is just optimized away and replaced with the result. 
but when you move variable to that function scope... function foo() { var bar = null; return typeof bar === "undefined"; } for(var i=0; i&lt;10000; ++i) console.log(foo())
That fix stops working if you set the loop to 100,000 cycles (at around the 12k mark) function foo(bar) { return typeof bar === "undefined"; } var baz = null; for(var i=0; i&lt;100000; ++i) console.log(foo(baz)) - 12291 false VM1493:5 87709 true VM1493:5 undefined https://postimg.org/image/sdwp5ttcn/ https://s31.postimg.org/t3fhi6tw9/failcase1.png A better fix would be to add true to the expression inside the function: function foo() { return typeof(null) === "undefined" + true; } for(var i=0; i&lt;100000; i++) console.log(foo()) - 100000 false VM1494:5 undefined https://postimg.org/image/gctc5qm9z/ https://s31.postimg.org/c3om3kj0p/wincase1.png This is on OS X 10.11.5, Chrome 51. I haven't tested it on Windows, so YMMV. 
Good job digging that deep in one day !! 
&gt;Twenty Oneth
They dropped today jQuery dependecy :)
Also happens in the latest node.js 6.2.2 I simply used for (let i=0;i&lt;10000;i++) {typeof null === 'undefined'} That loop only prints the final result when run on the console. The threshold value for "false" turning into "true" was around 4610 for me. Using that value (plus minus a few numbers) I got "false" the first two times I ran that loop and from then on "true".
still wouldn't it be more proper to check if(some_variable === null)
I've run into JIT bugs in other browsers too. What a pain in the ass. An easy fix is to disable the JIT by wrapping the effected code in a try-catch. 
Any body reproduce in chakra or gecko?
"Asynchronous" vs. "synchronous" is ultimately determined by something very far away from our algorithm: The properties of the hardware running our code. If you were to run the exact same algorithm on different machines, one where the data is stored on a slow medium (network, disk) and one where the data is stored in very fast storage you would end up with different async. vs. sync. code. Yes, you *do* write the asynchronicity into the code right now, by your choice of code construct. But the reason you do that is what I just wrote, the speed you expect from the medium you write to. Only that those assumptions are baked into the system: The Javascript environment expects certain kinds of operations to take a long time, and others to take place quickly. You *can* wrap each and every access to anything into an asynchronous construct (promise, callback). Ultimately the distinction is caused entirely by expectations of what physical hardware will run the code. You don't wrap an access to data in RAM into a promise, but you do so for data on disk or on the network. Even if it's the same data. The problem is that coding our algorithm's logic simultaneously with taking into consideration of those hardware limitations makes it hard: We would very much prefer to concentrate on our algorithm and let the underlying system take care of its issues on its own. On a higher level it's similar to including caching into your code - a high potential to mess your nice and thus far easy to comprehend algorithm up. In the past we tried this approach: Ignore the hardware-related speed issues and assume everything is instantaneous. Let the (operating) system decide when/if something takes too much time to wait: In that case the OS simply suspends the program and does something else. to the code itself time stands still, and when the OS has the requested data it wakes up the thread. No asynchronicity issues. That's what writing a batch script of using node's synchronous methods is like. It was/is a very convenient system. The reason we didn't completely go down that route and even went back to forcing normal code to consider the hardware it is running on is that it is more efficient. but it makes programming more complex, because it mixes concerns that are in completely different realms. Your solution doesn't do anything to make that problem easier it seems to me. Programmers still can't concentrate on their algorithm and still have to consider asynchronicity issues caused solely by the physical system running the code. **In the end**, writing asynchronous code means programming close to the hardware - only in a difference sense compared to programming in assembler or C. An actual solution for us to be able to concentrate on the (business) logic of our algorithm would be not to have to consider asynchronicity at all, which basically just means considering how long it takes to retrieve data from some physical location or knowing some computation will take too long and will have to be run in a different thread, process, or even computer outside our main program. . PS: By the way, async/await in some future Javascript version (or in Babel now) will *not* make it all feel like programming synchronously. Not unless you write 100% pure functions using immutable data and having no side-effects. For all other code it often matters quite a lot that a function is interrupted in the middle, and that other code of the same program runs, potentially changing shared data. But immutability is a very incomplete solution for most business apps: The problem is not just data in RAM but also on storage - unless the storage also is immutable - and your screen, haha - only ensuring that it is so for structures in RAM solves only a small part of the problem. Immutability is great when your code mostly uses data in RAM. [There are immutable databases](http://www.pwc.com/us/en/technology-forecast/2015/remapping-database-landscape/immutable-data-stores--rise.html), but that's not common. Not to mention that you still have to remember whether a value is behind a promise or not, which requires different code to write. You can't just `a + b` where `a` is a value and `b` is a promise with a value. So hold your excitement about those language features, as convenient as they may be. 
I get that but what I'm saying if you have some function and i want to know if the argument is null wouldn't it make more sense to check it like this function foo(my_arg) { if(my_arg === null){ console.log("arg is null here insert logic for null case here."); } } I'm not getting why anyone would need to check type equal to undefined.
For inspiration/reference i would take a look at the various visual programming options in game development (UEs [Blueprints](https://docs.unrealengine.com/latest/INT/Engine/Blueprints/), various third party assets for Unity like [FlowCanvas](https://www.assetstore.unity3d.com/en/#!/content/33903), [uScript](https://www.assetstore.unity3d.com/en/#!/content/1808), [uFrame ECS](https://www.assetstore.unity3d.com/en/#!/content/47548), ...). Those offer a complete programming experience with visual nodes. They offer hierarchical structure (subtree collapsed into one node), and usually free zooming and dragging. You can also combine separate node graphs with some messaging/communication to form a larger program. Custom nodes with a handwritten code-behind reduce the spaghetti problem but make it a bit less clearer to read as you now have two completely separate parts of your program. I think the idea of having an IDE that merges actual written code into the nodes is interesting. The concept of layers as "async stack depth" so to speak is also intriguing. Would need some sketching/prototyping with an actual program to see if it has merit.
We have been pretty successful training devs all the way from imperative to reactive, you just have to get to the limit of each technology and then show how the next one solves the problem. https://glebbahmutov.com/blog/journey-from-procedural-to-reactive-javascript-with-stops/
Because he's not checking if it's `null`, and you can't actually strict-equals compare to `undefined` in this language in a bunch of common circumstances. It is very common to have to check if something is `undefined`. By example, if you retain a JSON object from an API, and you want to check whether the server actually set some or another value, before you attempt to use it. He's talking about the `undefined` comparison. I'd like you to stop focussing on `null`, please. It's beside the point. Thank you
Absolutely! In fact, that's why I am trying to do here as well. In [my previous post](https://vincenttunru.com/2016-javascript-framework-overview/) I looked at the currently popular frameworks and what problems they solved, and this post demonstrates how reactive programming solves the problem of cumbersome asynchronicity in e.g. React. The timing of your post was excellent :)
Interesting, I wonder what they are using to gain file access?
It has the most comprehensive, most configurable collection of desktop widgets. However it built its own OO system over ES3 with a toolchain to manage it. It even has tree shaking. However, now that we have better tools, it feels clunky. I'm still waiting for an as good widget library that takes advantage of modern tools.
So if you run it with the console.log in the loop all of them evaluate false for(var i=0; i&lt;10000; ++i) console.log(typeof null === 'undefined') // 10000 false But if you change the var to a let and run the console.log right in the loop it's almost 50/50 split for(let i=0; i&lt;10000; ++i) console.log(typeof null === 'undefined') //4917 false //5083 true
Anyone have any insight into why this happens?(Newbie here)
Amazing, this will change the future
FadeOut made problems as you noticed. When I avoid to use it the slider works fine (except I get blank white page on every jump between last to first slide). I am not sure how to solve problem with fadeOut involved in code, but that is not my primary task right now. Thanks, sudocmd. 
Thanks for the notification. Will do my best to be a good citizen.
You do, however, have to worry about whether or not `x` is defined, as `x === undefined` will throw an error where `typeof x === "undefined"` won't.
I would love to see an example that shows how to use gitkit from the browser
Most likely flash.
That's awesome! I mean it's really bad, but think about what we can do before they fix it. I'll bet you the reason this shows up after about 100 iterations is that's when the optimizing compiler kicks in. Which means, we can actually tell if our code has been optimized or not. Time to see just how much good the optimizing compiler is doing us! [Here's a quick gist that logs the performance improvement](https://gist.github.com/twhb/abfb5bf7f510d6985b2effd7f588aa38), modify it to test your own code. For the dummy code I'm seeing an 80 to 90 percent improvement.
I found the [bugfix](https://github.com/v8/v8/commit/7dfb5beeec8821521beeb2b8eac36707a663064c). Suffice to say (and I am probably wrong here, having next-to-no knowledge of the codebase) that the optimizer keeps track of "special" strings (booleans, "undefined", some integers, etc). It also does some type propagation (as in what types a variable etc can be). There's a special "undetectable" type for when a variable is undefined or null. In this case the optimizer goes "null is undetectable, so it can be replaced with the "undefined" string for the comparison. Oh look, both strings are the same!" If you notice, this: for(let i=0; i&lt;10000; ++i) console.log(typeof null === 'object') exhibits the same incorrect behavior, albeit reversed. Same thing. The initial interpreter thinks 'typeof null' is 'object' for comparison purposes, but the optimizer thinks 'typeof null' is 'undefined' for comparison purposes.
Me? **You** are so.. red! Just what you deserve. People downvoted **you** into oblivion for a reason, little asshole.
Instead of trying to wrangle a massive amount of code at once, why not start with something very small and build it into something bigger. Learn some fundamentals first.
Version 53.0.2767.4 dev (64-bit) prints false
After it switches from false to true (around iteration 130), I also can't seem to delete foo anymore. I *can* set it to other values (123, undefined, null) but 'delete foo' keeps returning false and it retains the last-set value. Edit: ok, that is /also/ seemingly random..
Got it in Chrome 51, but it took 12292 iterations.
&gt; ... switch my production servers Try on your dev servers then before dismissing it so easily. I am receiving 1.000.000 connections monthly without crashes or anything so I already know it works fine - also it's a game where people stay connected for hours - not just some casual web app. It's not a circlejerk - I am doing my best to spread the word simply because I want to show my gratitude - if that was a paid product - I would pay, but it's not so that's the way I do. I didn't expected extreme interest on that thread but really wasn't ready for any hatred on something that is proven to do what it claims and contributes to open source.
Well that's exactly what I was going for. I didn't really plan to build a framework, it started with the factory method and hand wiring functions as you mentioned. But that latter part was getting ugly very quickly, so I wanted to encapsulate that away from my application code. Thumbs up for derpie :D 
Instead of guessing a loop size, just: let x=true; while (x) { console.log(x=typeof null==='object') }
duly noted, thanks for the heads up
Can you talk a bit about where this stands in relation to https://github.com/creationix/js-git ? At first glance, the obvious difference is promises instead of generators, but are there other interesting/important differences?
i recently started a project that i hope i will have some time in the future to work on https://github.com/arturkulig/deferred-di i've noticed that you are using declarations of dependencies in object destruction, but it doesn't **seem** to be resilient to transpilation and/or name mangling during minification. That was the reason why in Angular you have to either specify deps in function property... (function yourModule(){}).$inject ...or in array. [dep1, dep2, yourModule(dep1, dep2){}] I've decided to work on DI not only to have a modules that could be easy testable, but to have a way to write universal apps that could be isolated on a server and run in the same way in a browser. Maybe that is what you should consider supporting too.
Thanks for this comment. My noob ass finally gets it.
What about ES6 features? 
Now we can run git in astronauts' suits!
It's not a bug, it's a feature!
Hi /u/timgfx, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
"Uh we modified a built-in prototype in our shitty CRM and now things don't work" - Microsoft
&gt;I want to warn other web-developers for this bug, to avoid many $$$ being wasted (or becoming insane ;-)) Consider using a highly opinionated linter. JSLint would flag `return typeof null === "undefined";` as a weird statement. You don't have to use JSLint, since Crockford is very opinionated and very draconian. At my job we use ESLint with a ton of rules turned on both to catch errors and enforce a consistent coding style. For a language like Javascript I'd say its a necessity because there's so many different ways to do things. Also I'm not sure why you're actually using this statement in your code. In any case I hope you filed a bug report. I'd be curious to see if this affects node.js since node uses V8 as well.
ws is pure garbage. If you compare the two "established" libraries WebSocket++ and ws you will see ws performs about 30x worse than WebSocket++. How ws even ended up being called "fastest" is beyond my understanding and what bothers me still is how they refuse to change their aggressively false marketing where they keep on claiming to be "fastest" (superlative, insanity to even consider using a superlative). Thanks, bruh.
To be fair, TC39 has considered the behavior of other software (mootools, I'm looking at you) when determining the current JavaScript spec.
I found that if the variable is defined within the function as null that it does still has the error. function foo(){ var thing=null; return typeof thing === "undefined"; } for(var i=0; i&lt;10000; i++) console.log(foo()); &gt; 265 false &gt; 9735 true And when null is passed as an argument, it doesn't. function foo(thing){ return typeof thing === "undefined"; } for(var i=0; i&lt;10000; i++) console.log(foo(null)); &gt; 10000 false
New update on the SO post. It is not because of Atom.io as I was successfully able to reproduce the problem without it.
ok, so in a browser, what can be done with this?
This kind of behavior is pretty par for the course for Alex Hultman. That alone is reason enough for me to never touch this repo with a 10ft pole.
Seems like this would make it easier to build git into the editors. Sublime, Atom, vsCode, etc. 
This is an easy fix. The problem with that part is that you are simply jumping to the *next()* element, which is the list of dots for the slider. To avoid that, replace the if (nextSlide.length === 0) with if(nextSlide.attr('class').split(' ').indexOf('slide') === -1) This will check if the next element is a "slide" or not.
This library gets it's speed by completely disregarding security, safety, and many best practices. [He posted it to hacker news a month or so ago and they uncovered a ton of issues](https://news.ycombinator.com/item?id=11736938) like unchecked pointer math, no stream backpressure, gotos everywhere, and a shitton of compiler warnings that the author disables. This library should be avoided if you need any kind of secure environment, and even outside of that you should beware as there will probably be many small gotchas that you can hit without warning (like if you are slow on the processing of the data, it can build up a never ending queue which will just end up crippling the server).
https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#1-tooling
Git in pure JS for node means git integration can now be added to anything without needing git installed locally. If this is built into tools/websites the potential is unlimited.
XMLHttpRequest
Pardon my obvious ignorance, but your promise accounts for an error state, but no success state. Is `.login` some black magic that fires when the promise successfully resolves?
You're going to want a limit counter on that, otherwise if it works as intended it's going to hang
I was able to calculate additional digits before eventually converging. ...(continuing from 4375) 932649918180817996189898282347722858865463328355177969898199387398005390939063150356595155702263922908583924491051844359318028499365361525003193704576782492193656236698636584807570015857692699037063119282795585513329278343384093519780155312465972635795746227664652728272200563740064854999770965994704540208281662262378573934507363390079677619305775067401763246736009689513405355374585166611342237666786041621596804619144672918403005300575308490487653917113865916462395249126236538818796362393732804238910186723484976682350898633885879256283027559956575244555072551893136908362547791869486679949683240497058210285131854513962138377228261454376934125320985913276672363281250...01` http://codepen.io/sscotth/pen/wWzdKq Also using scientific notation I got a different, slightly higher, number 0.25000000000000002775557561562891351059079170227050781250...01 * 10 ** -323 http://codepen.io/sscotth/pen/zBKXbJ
Thank you, that makes sense :)
Thanks for the link, very interesting!
Ok I see what you mean, glad you said that my result was var dateString = dateToBreak.split('/').join().split(':').join().split(' ').join();
I love posts like these, just because I've noticed a trend that experienced computer scientists are much more likely to say "Fuck I'm not coding that, someone else has already done it. better than I could code it too probably". It's a good way of life, even if you miss out on some very nitty gritty experience
Yea, it's certainly not as cut and dry as /u/jcready or I are making it out to be. See my response to his comment. 
Thanks, will have to look into this later. 
You need to resolve the deferred object and then force a digest. See below. var deferred = $q.defer(); loginServiceMock = { login: sandbox.stub().returns(deferred.promise) }; controller = $controller('loginController', { 'loginService': loginServiceMock }); describe('when controller is initialized', function() { beforeEach(inject(function(_$rootScope_) { $rootScope = _$rootScope_; })); it('calls login service', function() { controller.login({$valid: true}); deferred.resolve(); $rootScope.digest(); // expect/assert goes here. }); }); 
Probably create a queue of requests that you can replay and diff between the front and back end. 
I figured there was a reason. Thanks for explaining!
Create a browser UI for Git. Now you can have Git on mobile devices if for some reason you want to write code on an iPad. It might be a decent starting point for building a version control webapp for non-programmers too. Graphic designers and digital musicians have sometimes expressed interest in such a system.
Praise "Bob"
To do this properly depends on the constraints you've been given for the problem. Is this an assignment or exercise from somewhere with a specific input date format strictly defined, or are you just playing around and making up your own rules? Is the input date guaranteed to always be in the weird American format "mm/dd/yyyy hh:mm:ss tt"? Are the month, day and hour fields always 2 digits? Are the seconds always included, even if they're zero? Are you always assuming local timezone (i.e. local to whatever system it's running on)? Is there always a space between the time and meridiem? As pointed out by another comment, the native Date will likely handle it with its own parsing heuristics. But if your goal is to do the parsing yourself as a learning exercise, then you're on the right approach. Splitting the string on spaces, slashes and colons is a good first step. You can do that in one step using a regex. var dateStr = "12/21/2017 12:59:59 PM"; var dateFields = dateStr.split(/[\/\s:]/); Then, assuming the input format is strictly defined and thus the number of fields resulting will always be the same, you can just read them directly from the array. var month = dateFields[0]; var year = dateFields[2];
I think standard refactoring techniques should be able to keep the hand wiring in check. I've never gotten into a situation where I couldn't extract a function to another file. If you have any source code that you felt got out of hand I can look at, I would love to give some feedback
~~Monkey patching strikes again.~~ Actually the issue was they forgot to use `hasOwnProperty`. So while it used to be that `someArray.values` was falsy, now it's truthy. What they needed to do was `someArray.hasOwnProperty('values')`.
Have created_at and / or updated_at timestamp(s). 
It is a homework problem, the teacher says we can use what method pleases the topic so long as it is confined in the general topic we are discussing, and that we understand it without the usage of documentation. I noticed what you did on your first quote is exactly what I did, however you used the regex which is not what I am familiar with. The example is constant, always in that format and never changes. I may take you up on that method you posted by I guess towards more of the split().join() method as I am not familiar with the regex within your split().
Just `.values()` itself, since it basically duplicates the existing array iterator. I don't have a problem with iterators or the `for...of` loop in ES2015. It appears to exist purely as a compliment to `.keys()` and `.entries()`, but having multiple standard ways to handle things isn't always good (it often creates baggage long-term).
I don't think it's quite ready yet but there's https://github.com/paldepind/synceddb . Backend has a MySQL adapter.
Yes, a stateless function (as in React's stateless components) is the same concept as a pure function: for a given input, the output is always the same, with no side effects. I would not say they are always interchangeable, as "pure function" has specific meaning in programming/math, whereas I've only heard the term "stateless function" used in a React context.
I have got questions. Why did v8 determine that null is a undetectable in this code? Are there any performance benefits, when null is replaced with "undefined"?
The two conditions for a pure function are 1. Deterministic output based on input 2. No Side-effects A stateless function component definitely fulfils requirement 1, but I'm not sure about requirement 2. 
CoffeeScript's existence operator does not distinguish between own properties and properties on the prototype.
Repros in Node 6.2.1 $ cat v8_bug.js function foo() { return typeof null === "undefined"; } for(var i=0; i&lt;10000; ++i) console.log(foo()) $ node v8_bug.js &gt; v8_bug.out $ uniq -c ~/tmp/v8_bug.out 132 false 9868 true $ node --version v6.2.1 
Ditto 6.2.1, unsurprisingly. I posted without seeing yours but I will leave mine up because it has my shell session.
I guess it was a joke. I hope so, at least.
Doesn't the React dependency make it not a pure function? If I upgrade React I could conceivably get a different element - if I was passing a specific version of React as an argument it'd be pure. (?)
If that's the case it went straight over my head
It's not a "stateless function" but a "stateless component", which is, in React terms, a function that takes props as a parameter and returns a React element, and is opposed to a stateful component, which is a standard React class. s There's nothing that enforces stateless components to be pure (as in free of side-effects and deterministic). Sure, they should be, but you can do whatever you want inside that would break the purity (but please don't).
Seriously, don't attempt such thing. Here's an edge case: internet is disconnected, but the user has a mobile device so he makes the order anyway, then when connection is restored you duplicate the same order. Besides not handling all the edge cases, you'll potentially be writing sensitive data to the local storage. If you absolutely need to, read local storage as soon as the user opens the page, and make an Ajax request to server, and delete the data from local storage after you get the request result.
Hmm. I tend to disagree here, changing the version of the Haskell compiler could change the output of an otherwise pure function as well. React is an upstream dependency just like the compiler. Though granted it's less likely for a compiler change to change your output. 
Just to clarify, this bug obviously manifested itself in an indirect way, in thirdparty libraries we were using, that had code like: export function isUndefined(obj: any): boolean { return (typeof obj) === 'undefined'; } 
Hey thanks! Maybe I was overconfident that my code had to work correctly, LOL ;-) No, the moment I noticed that stepping through the code gave a different behavior, I realized I had to search for compiler bugs. I experienced the same problems ~30 years ago with C/C++ compilers (it was one of the reasons I kept programming in assembly language for so long). To be honest, since we switched from Silverlight to HTML5+ Javascript at smartphoto.com, we have to workaround browser and driver bugs almost weekly. Standard features that worked fine tend to break in new releases. It's a living organism, and it makes me wonder about modern QA... 
interesting. i thought the fact that stateless components call ```React.createElement``` made the function inherently impure. And in that light: would compiling to raw objects instead of react function calls make it pure again?
But that does not trigger the bug for me. Only if there is `typeof null` directly and not null passed into via variable indirectly.
There is a [linked bug](https://bugs.chromium.org/p/chromium/issues/detail?id=409858) that predates the recent issue (2014). Microsoft should have fixed this by now... 
jsbin and jsfiddle at least use Ctrl-Enter, plus Alt-Enter is fullscreen for me
Your reflexes weren't fast enough to catch it?
Not really true at all. If you find any security issues you are free to post an issue, otherwise please refain from such bullshit claims. I do check bounds of every buffer and every "unchecked pointer math" is really only "unchecked" to the inexperienced eye. I do break some best practices yes, but thats why I manage to build it this fast. There are zero warnings, I disable none of them, there is a total of one goto and the reason for being fast is zero-copy, SIMD masking and inlined paths in the parser. So yeah, you are pretty much just spewing bullshit, please stop that. If you can actually trigger a buffer overflow or something like that I would love to hear from you.
Hey, Mr. Expert. Can you point to one single "unchecked" thing? If you do, I can explain where that assumption comes from and where this assumption is checked. If you find anything "unchecked" I will fix that. If you cannot find anyhing, well then maybe you need to be a little bit quiet.
Given the same set of inputs, you get the same set of outputs. If you change anything, then you should expect that there can be a change in the output. There are very few useful "pure" functions that don't rely on some code that are from outside itself, such as libraries/etc. If you change that library, it could change the function itself. That doesn't make it less "pure", since you changed something.
lol, interactivity IS everywhere on the web as far as javascript is concerned, just open a dev console. "Alan Kay: It is, but go to the article on Logo, can you write and execute Logo programs? Are there examples? No. The Wikipedia people didn’t even imagine that, in spite of the fact that they’re on a computer." Nope, it would be insane to put it on wikipedia to make everything interactive, this is one hell of a boondoggle of a "vision". i.e. wikipedia should do interactive OPENFOAM renderings in the browser, because alan kay thinks so. or it should do protein folding. nope, the scope is words and pictures and external links because that is sane.
Then maybe you shouldn't make up bullshit claims you cannot explain. You are just in it to throw dirt on this project even though it is currently used in production by many users which are all pretty happy with it, expect for some users that report issues (helpful issues).
Client to server: I will rather use CQRS and store the commands on a queue. Then, when you got connection, you send that commands as ajax request, websocket or whatever you think it is appropriate. You can use the same queue while you have internet and send the commands. Just remember to create and UUID for the commands and return an exception if you already executed a command with that uuid and this will solve duplication. Server to client: You can do sync after sending all the commands, then you can just overwrite everything you have on your indexdb.
&gt; and you can't actually strict-equals compare to undefined in this language in a bunch of common circumstances. Of course you can. The only case where you can't is if you're checking existance of a global variable for feature detection, in all the other cases === undefined works like a charm.
That's me :)
:) I made [this app](https://makeapoint.vincenttunru.com/) in Cycle.js. There's [a stream with the message to be displayed](https://gitlab.com/Vinnl/makeapoint/blob/master/src/selectors/selectCurrentMessage.js), which can be either what the user entered (provided by the DOM driver), or the message set in the URL (provided by the History driver). That message is then wrapped in a `&lt;p&gt;` and passed to the DOM driver.
Thank you Alex for the library. It looks great. You've got +1 follower on GitHub.
You shouldn't be proud of that
Websites I visit in the mornings, most everyday, excluding reddit: [EchoJS](http://www.echojs.com/) [Javascript News](https://www.javascript.com/news) [PonyFoo](https://ponyfoo.com/) [HotJS](https://www.hotjs.net/) As for newsletters: [Front End News](http://frontendnewsletter.com/) [Javascript Weekly](http://javascriptweekly.com/) [Node Weekly](http://nodeweekly.com/) Have fun ^^ Edit: FIX layout was all over the place
&gt; 2 . No Side-effects Basically, a stateless function can affect objects outside of its own context? And if so, could it be stateless then?
RemindMe! 7 Days
I will be messaging you on [**2016-06-28 14:39:30 UTC**](http://www.wolframalpha.com/input/?i=2016-06-28 14:39:30 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/javascript/comments/4p34os/a_new_way_of_blogging_about_javascript/d4i08q5) [**CLICK THIS LINK**](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/javascript/comments/4p34os/a_new_way_of_blogging_about_javascript/d4i08q5]%0A%0ARemindMe! 7 Days) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! d4i0cdf) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Just forget about the browser for a moment. You are writing a desktop application that stores data in a local db file in a regular file system. You will need just some kind of a module like [this one](https://github.com/mapbox/node-sqlite3) to access your data. Accidentally, browser can have its own local storage, but it should not be your concern. These are different databases.
Thanks!
But no audio([slide 15](https://docs.google.com/presentation/d/1gqK9F4lGAY3TZudAtdcxzMQNEE7PcuQrGu83No3l0lw/preview?slide=id.g135a740781_0_85))?
shit....
Correct. "Purity" has nothing to do with dependency and everything to do with mapping input to output. What /u/askuriel is alluding to is that React (or other external library) could be observing the function and causing side effects. That doesn't change the nature of the pure function, however - one of the great advantages of stateless functions in React is that you can test them in a total vacuum, just by isolating and running test values through them.
Hi /u/nparsons08, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `getstream.io`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.getstream.io](/search?q=%28and+site%3A%27blog.getstream.io%27+author%3A%27nparsons08%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|26|84% [cabin.getstream.io](/search?q=%28and+site%3A%27cabin.getstream.io%27+author%3A%27nparsons08%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|3|10%
For sure, you'll probably eventually want to look in to creating script files, adding a CSS file, etc to manage your styles and JS as your code/project gets more and more complex. Writing everything 'in-line', like you're doing now, is difficult to manage at large scale.
Anything wrong with using W3Schools? :)
Can also confirm getting this on the 6.2.2 Linux x64 build. I guess this is a good reason to go with stable instead of latest Node.
Just dated and usually poor examples/etc. Most developers I know (and myself included) prefer MDN.
So the CSS was right according to some CSS friends of mine. But still when I go the print media query route, the css just shows up at the top of the print preview and still wants to print the whole page. It's nasty looking too. All overlaps and stuff. I wonder if it's because the div I want to print is the dynamically generated content dictated by the form. It's not just static text. 
"undetectable" in this case means "I do not yet know what type this variable is". v8 can do a lot of optimizations when variables are known to be of a specific type. But null and undef don't actually tell you anything about what type(s) a variable can be - they can effectively be any type. So as long as you only assign null or undef to a variable, v8 just goes "I don't know what type this variable is yet" and leaves it at that.
It does that on Ctrl+Enter. It already did that before you edited your comment.
Can you create a jsfiddle or codepen with an example that reproduces your bug?
That's interesting. I've been writing javascript for more than a decade, and I've never ever come across anything like what you recently found. I do come across the occasional rendering inconsistencies, however.
Does Keystone configure Mongo to be safer and more stable than a default Mongo install? Does Keystone have a path for moving from Express to Koa?
Odd. When I do the comparison as a function it takes fewer iterations. function f() { return typeof null !== "undefined"; } var i; for (i = 0; f(); i++); console.log(i); // Outputs 12291, then subsequently starts outputting zeroes Versus: var i; for (i = 0; typeof null !== "undefined"; i++); console.log(i); // Reliably outputs 18436
Right, and this is exactly what babel does for [its async/await support](https://babeljs.io/docs/plugins/transform-async-to-generator/). It does all the transforms for you. Pair this with the [babel polyfill](https://babeljs.io/docs/usage/polyfill/), which includes a generator runtime, and you can use effectively use async/await today. It works really well. Source: using `async/await` in production code already :D
[Codrops Collective](http://tympanus.net/codrops/collective/) is by far my favorite.
You have an array of objects, not an array of arrays. 
&gt; And if so, could it be stateless then? Yes. var x = 0; function changeX() { x = 1; }
Exactly this. JSON is extremely picky about trailing commas. Even though this would be syntactically valid in Javascript, this is malformed JSON.
To be clear, you aren't talking about syncing per se, but simply saving the order locally while offline and then submitting it when the network is restored. Correct?
Wrote this earlier for my blog and thought I might as well release it - so did! :) This plugin essentially takes something like &lt;h2 id="some-cool-title"&gt;Some cool title&lt;/h2&gt; and wraps it inside an anchor link for linkable headings. You can preview it on my blog by clicking any headings inside an article: https://toddmotto.com/rewriting-angular-styleguide-angular-2 Hope it's useful for somebody!
For me it depends on the level of expertise. Listed so far are really good for those who've been in the industry for awhile. But for those a little newer needing more intermediate information [these](https://medium.com/@lee101ying23/new-to-js-these-blogs-got-your-back-da2f6bb0e2a6#.wmgekgfgn) are a good start. 
^ ^ ^ agreed.
https://webplatformdaily.org/
But isn't [bash coming to Windows 10](https://blogs.windows.com/buildingapps/2016/03/30/run-bash-on-ubuntu-on-windows/)? So won't that blow cross-platform/OS issues out of the water? Granted you'd need to be on Win 10, but still. Just wondering.
It can also be used to shallow cloning objects. var a = {hello: 'Bye'} var b = {...a} console.log(a === b) //&gt;false Much better than `Object.assign`.
I'm wondering what issues you had with Feathers and React Native. It should work out of the box and there is a demo React Native chat application at https://github.com/feathersjs/feathers-react-native-chat.
i think [coffeescript](http://coffeescript.org/#destructuring) beat vanilla js to the splats but JS is beating coffeescript on the [copying](https://github.com/jashkenas/coffeescript/issues/3894)... hopefully we see this in CS though.
As an ex-CoffeeScripter I always have issues to remember if the splat goes ahead or behind though.
`Object.assign` is nice for extending multiple objects into an empty object or for extending a target object. As your comment pointed out, there is a better built in for object copying now (even if it's shallow).
I agree it's cool, but you should really clarify this is only a proposed feature, it is neither ES6 nor ES7.
Babel just translates it to `Object.assign` though.
No worries, it happens. It's https://github.com/sebmarkbage/ecmascript-rest-spread which is a stage 2 proposal.
Stage-0 all the way! Living on the bleeding edge!
This guy's demos are amazing!
I like how you included the copyright notice in your copy. rip.
[WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
You can bypass this directly by just passing arguments directly into the `filterNumbers` function and naming it there. I also think that has a benefit of creating more reusable functions when they don't have to rely on an outer closure's state. You can always pass in an array or array like argument and receive the output as an array of numbers no matter where you use that function.
I've been working on a Backbone+Marionette app since early 2013. Still as-is, haven't tried to make any changes to it. Also gone all-in on learning React and Redux in the last year. I now maintain a list of links to high-quality React and Redux tutorials and articles, over at https://github.com/markerikson/react-redux-links. So first, a few thoughts off the top of my head: - Start trying to apply one-way-dataflow principles to your app. Don't let child views make changes to models - use event buses to send Flux-action-like data back to some controller logic, and let _that_ do the work. - In addition, aim to make your views as stateless and data-driven as possible, whether that mean re-rendering from scratch on change, or using something like Backbone.Epoxy to do one-way databinding. (Our app uses a mixed-together version of Marionette.ItemView and Epoxy.View, giving us Marionette's lifecycle methods and Epoxy's databinding abilities. We also use Backbone.Subviews to mark where children should go in our templates, and initialize them.) - Might want to start looking at ways to change your build process. I know that things are more complicated when you're using something like Django or Rails, which are more server-centric and have their own asset pipelines, vs an app that's a pure SPA from day one and just doing everything in a JS bundle. Still, worth looking into things like Webpack. - If you're interested in migrating your Backbone code to React, you can definitely do that incrementally. There's a number of interop libs out there that will let you hook together React components and Backbone Models/Views/Collections in various ways. I've got a number of articles and libraries bookmarked at https://pinboard.in/u:acemarke/t:backbone/t:react/ on that sort of topic, and a few more articles at https://github.com/markerikson/react-redux-links/blob/master/react-vs-backbone.md that give some comparisons between Backbone and React. 
I find this to be really unclear. If you want to (deep) copy an object, you should use a function that explicitly does this. Even a simple wrapper called deepCopy that uses ... would be better.
It supports not only the traditional two-pane mode but also the WYSIWYG mode that is more than syntax highlighting.
[`Object.assign` is part of `babel-polyfill`.](https://babeljs.io/docs/usage/polyfill/)
Ok, thanks. But the point still stands, it's not clear enough and can cause issues when maintaining it.
Not really, it works the same is the splat operator in any other situation, it doesn't deep copy.
Yea, it looks like without `babel-polyfill` and just using `babel-es2015` will just use `Object.assign` if it is defined and an inline polyfill that looks something like this: function (target) { for (var i = 1; i &lt; arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }
`countries.push(...['USA', 'Japan']);` reduces down to `countries.push('USA', 'Japan');`
Babel is a little risky, as they tend to march forward with proposed features. If you prefer to stick closer to where actual ECMAScript is going, TypeScript is a better option (you can completely ignore the static typing and treat it is modern JS if you prefer)
Good to know, thanks!
It's not necessarily making everything interactive, but they could make an interactive LOGO turtle graphics. That wouldn't be too difficult. Their own version of a codepen as /u/chevex says sounds like a good idea.
Babel is completely configurable. If you want to stick to a standard (and translate it to an earlier standard), use the correct Babel preset.
Well, there **was** dailyjs.com: [dailyjs.com/2015/07/07/the-end](http://dailyjs.com/2015/07/07/the-end/). And... do you remember [badassjs.com](http://badassjs.com/)? I can say it was **incredibly** serious and interesting resource. But as of now its last post is “WebKit.js: It’s happening for real, with Emscripten’s help” (from January 16th 2014). It always makes me sad when some really good and useful project ends, and there’s no one to revive it.
The verbose part is not only the additional variable declared, but also working with the array-like objects. The rest parameter doesn't need additional variable declarations and provides an array, so you don't have to use duck typing `Array.prototype.filter.call()`. This is mentioned in the paragraphs below.
I get that you're making a joke, but I don't agree. I assume they designed it this way so that the simple weakly-typed case is usable, e.g `!el.canPlayType()` The language is amusing but it's really not so bad. The developer can still consume the API naively if they want, but the return types expressly communicate that this is a heuristic.
Surely that library should throw an exception if asked to parse a request body in a format it doesn't support, rather than silently failing. No? 
that would make for some interesting falsy checks `if (someVar == 'lolnope') return 'gtfo';`
I edited my post, to reflect the real code. The code was part of thirdparty libraries that checked if a value was undefined. Many popular libraries have code likes that.
So ... okay ... when did the Mozilla developers lost their minds?
I once did the same within one single .js file and one singe .html file.
ANY language should be extremely picky about ALL syntax elements!
&gt; Typescript is not ecmascript compatible You can certainly use it as such thought, being a strict superset. &gt; Babel is actually very strict when it comes to draft specs and you are not allowed to use them out of the box. Maybe I haven't read the good ones, but all of the tutorials I've seen, as well as most codebases, use the "stage-0" preset like it's not a big deal
And more people should do this. Also, fewer tutorials should simply say to enable `stage2` without explaining (or even understanding) what that does.
Thanks a lot for the ideas! I'll definitely look into Backbone.Epoxy. I know that devs working on a project related to ours were using Backbone.stkickit for 2-way binding, while in our project we did not use any plugins or libraries to help with data binding. Epoxy looks very interesting. As for the build process, thankfully we aren’t using Django’s asset pipeline (don't know if it has one; I am familiar with the Rails pipeline and am grateful to the previous devs for not relying on anything like it). I am already in the process of migrating the app from Require.js that it used before to Webpack, so that’s covered :-) Also, do you know whether React can receive html pre-rendered by Django, and take over from there? In my (rather limited) experience with React, I always started from clean slate that was populated React-generated views. How good is React with hooking into already existing html? Judging by the fact that it supports isomorphic javascript apps, that shouldn’t be a problem, right? Also, have you ever tried MobX instead of Redux? It looks more magical and less rigidly structured, but sweet :-)
It's not Mozilla, it's what WHATWG (or the W3C?). And they're limited by Javascript although usually, numbers are used instead of strings to compensate for the lack of enums or something else.
There's still sometimes when you have to do that, for the time being. But if you also use the proposed [bind syntax](https://babeljs.io/docs/plugins/transform-function-bind/), then you can pretty much eliminate `fn.apply` altogether.
Good article, but just to have that said, it is "destructure" not "destruct". Destruction is something completely different.
The issue is that sometimes all you got is a mime-type, which isn't enough to decide whether something is playable. That is, unless you attempt to play. Example: the mime-type `video/mp4` doesn't say what are the codecs inside this mp4, so you get a "maybe". But if you get a more descriptive string like `video/mp4; codecs="avc1.42E01E, mp4a.40.2"`, you will get a "probably" (if the browser supports playing H.264 and AAC, that is) Well why "probably" instead of "yes"? Well here the browser is just being honest. The user may have installed a buggy GPU driver or something. Now, returning an empty string instead of null is inexcusable.
I think it's because you're in the same thread when executing the JS. The first time it's executed is the first time the compiler has seen it after that is is associated null with undefined and does so ever more.
It doesn't work with the latest react 
too bad it doesn't use prosemirror :)
Use `map`: const elements = ["x","x","x","x"] const indices = elements.map((_, i) =&gt; i) // the _ means we don't care about the actual element console.log(indices)
 var a = ['a', 'b', 'c', 'd']; var indices = Object.keys(a); If you don't care that the indices will be stored as strings.
It would be great for all javascript to be like this. It would make us slow down a bit and chill as a society. console.log(new Date()) // "one of these days" console.log(arr.length) // "a few"
probably now allows for a future value of yes, if that certainty can ever be achieved, without breaking everything. 
~~Maybe I'm misreading your statement, but just a reminder: empty strings evaluate to true in JavaScript. !'' evaluates to false. If a function canPlay() returns '' when it can't be played, then !canPlay() would be false when it can't be played.~~ Too early in the morning for me. (And I could have sworn I had experienced empties returning true before, but maybe it was spaces.)
Inexcusable? Why would `null` be a better choice here? * A semantic refusal would be `false` (responding to the *can play* question in the function name) * Both `null` and `false` would introduce situations where a function returns different types at different points, which is even worse than the current solution.
You have no idea how tempted I am to write a library for my team to do this... stop giving me ideas (actually don't stop...)
I haven't worked with video much, but, is it actually useful is it to distinguish between "maybe" and "probably"? I feel like you'd want to try to play it in either case, and if it fails, you should be handling that gracefully anyways. "Maybe" and "yes" I could potentially see handling differently, but even then I'd probably still try.
No. Empty Strings evaluate to false in JavaScript. console.log(!!"") // false
`'probably'` and `'maybe'` mean the same thing to my ear. Something like `'likely'` and `'possibly'` might have drawn a better distinction. The empty string makes sense though. I love me some falsey values.
Stringly-typed is best-typed.
Probably denotes that it's more likely than not (probability &gt; 50%), "maybe" just says probability &gt; 0%.
Nah, it's just a simple example how to use `.push()` with spread operator. 
Well, `.play()` does return a promise which will be rejected if it fails for any reason, so you're right. But it's a usability type of thing. If the result is `maybe`, you probably want to display a warning saying "This media may not work on your device" or whatever. But in the simpler case as you're suggesting, just check for truthyness `if (m.canPlayType())`. 
Some bullshit library like TrumpScript?
I would have preferred anything over silently ignoring the body! 
Hi /u/hfeeri, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `risingstack.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.risingstack.com](/search?q=%28and+site%3A%27blog.risingstack.com%27+author%3A%27hfeeri%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|14|88%
Hi /u/JsObserver, this post has been removed. Please feel free to repost as a link submission (and not a text submission). Thanks!
Yea, large parts of the webaudio api operate on magic numbers so like 4 would represent playable in a method (I don't have the documentation in front of me). I'm not sure why they couldn't polyfill enums for these complex returns. 
&gt; is it actually useful is it to distinguish between "maybe" and "probably" From a UX perspective, yeah, "probably". :-D More seriously, the problem here is that media containers/codecs/streaming is fundamentally broken in that a computer can't possibly know whether it can play a given stream or file until it tries, and catches any errors that occur. Given that fundamental gap in functionality, "definitely not" (""), "maybe" and "probably" are the best the browser can do. Certainly it's better than reporting true/false/null, that naive devs may take as gospel but which may be highly inaccurate for many users.
Where'd you get `o`? Do you mean `elements`?
It's middleware for handling certain request content-type bodies. How would it know that you hadn't also put another piece of middleware for handling multipart/form-data right after it?
This is nonsense. The problem is that with the wide variety of codecs and container types it's often impossible to know if a given browser can play a given file without actually requesting it and trying, so all this API call can do is give a best-guess (hence the weird return types to make that abundantly clear to the developer using it). It's true that JS doesn't have enums, but that's a distinctly side-issue, and it could be easily worked around by defining `HTMLMediaElement.PROBABLY = 1; HTMLMediaElement.MAYBE = 2;`, etc. JS devs do this all the time to avoid magic numbers in their code. The problem is that `1` doesn't scream "you can't rely on the result of this query" every time you look at the code, whereas `"probably"` is almost impossible to miss.
&gt; jsnice.org i think that site is down. well, it doesnt load for me. anyway i have used it and it comes up with an array that is referenced in the code later and if the code is long its hard to replace all of that with the values manually so im looking for a way to do it automatically. like a tool or something.
Thing is that it doesn't have to do with the scroll event sadly. When I comment the code out, the bug still occurs
It would be much better to return an integer from 0 to 100 as "percent sure it can be played". That would be forward compatible with more than the current 2 values and more robust against e.g. spelling errors.
What kind of actions would an application take if it got back 'maybe' vs 'probably'? It seems like in either case the application would attempt to play the media so the distinction is useless. It may as well be refactored to .cannotPlayType() which returns true if media is definitely unplayable, false otherwise.
Wait, people use that?
It worked putting it at the end of body. Thank you so much! :)
&gt; Time for a language where everything is a string. bash?
No problem. Have fun!
That is simply not true. TypeScript is a proper superset of JavaScript, in particular ECMAScript 2015. All ECMAScript 2015 code *is* TypeScript. TypeScript also follows the standard better. For example, Babel allows `import React from 'react'`, which is incorrect as React does not have a default export. In TypeScript it needs to be `import * as React from 'react'`, because that is what the standard calls for.
Yeah, I've been pretty happy with Epoxy in our app. The built-in binding commands are useful, and it lets you define your own. Definitely a good first step in the direction of making your UI purely data-driven. It's worth reading the source to see how it works. There's one specific bit of "magic" internally related to how it turns your binding options into attribute lookup functions, but otherwise it's relatively straightforward (which is still the biggest pro of Backbone in general - predictable and readable behavior). Not entirely sure on the "absorb existing HTML" aspect, but I think the answer is "probably not". React expects that everything inside a given React render tree is managed by its virtual DOM. You can certainly start multiple React render trees in various places in your UI, allowing you to iteratively start swapping out different widgets with React piece-by-piece, and React does give you enough hooks to wrap things like jQuery-based plugins inside a React component, but I don't think you can tell React to "take over" a given element the way you can with a Backbone View. Note that the isomorphic app thing involves creating a React component tree and rendering it all out to a string from the virtual DOM. I'm not using MobX myself, but am aware of it and what it does. There was a good thread the other day comparing the two. The authors of both MobX and Redux popped in to describe their respective libs, and I gave a use case and behavior comparison: https://www.reddit.com/r/reactjs/comments/4npzq5/confused_redux_or_mobx/ . If you've got further questions, feel free to ask. Would actually be interesting to compare notes on our Backbone apps at some point. Reddit comments are fine, and I also hang out in the Reactiflux chat channels most evenings. Invite link is at http://reactiflux.com.
It could be handy to notice that "probably"&gt;"maybe", so you can pick the type that has the greatest return value.
True, but it does allow to say `x !== false`... or `x === true` or whatever appropriate combination, which is more explicit as to what behaviour is expected.
Ah, I see. I changed it the WebGL canvas to just normal positioning. I also use a second normal canvas to display text that is above the normal canvas. Should I try to also use normal positioning on that? If so, how could I get it to be above the other canvas? I tried little tricks like negative margin but they didn't work out... EDIT: I've tried removing the fixed positioning, it seems to help a bit, but not a lot...
 !!x !== false !!x === true
http://stackoverflow.com/questions/29408492/is-it-possible-to-combine-react-native-with-socket-io shows hot to get Socket.io working with the latest React Native. Unfortunately the actual Socket.io fix (https://github.com/socketio/engine.io-parser/pull/55) has been sitting there for quite a while but never been released.
Yes, but as a programming language, not a scripting language.
Or Boolean(x) so that the type conversion is more explicit, although it's not as brief.
Explain?
You want to wait until the DOM loads (the html elements) before you try to manipulate them. document.addEventListener('DOMContentLoaded', function () { initializeClock('clockdiv', deadline); })
With modern JS development for the web, you definitely should not just throw global variables around on the page and hope that they exist. You should be using a module system to help mitigate this issue, which renders this discussion moot. However, if you really need to rely on global variables, they do exist as properties on window, so if you need to check for its existence, you should check for `if (window.foo !== undefined) { ... }` instead. I see no valid reason to be concerned about the existence of global variables when you shouldn't even be using global variables anyways.
Canvas is just too intensive. Should should only run one canvas on a page at a time. Try not "stretching" it; thats a draw penalty too. An old hack was to z-pos(0) using translation; but i think chrome built this in
&gt; Try not "stretching" it Currently, I set the width and height of the canvas equal to the page when the window size has changed, is that good or not?
Because do is a reserved keyword?
&gt; you definitely should not just throw global variables around on the page and hope that they exist if (window.foo !== undefined) { ... } Two problems: 1. `window` isn't guaranteed to be the global object in all JavaScript engines, so you'll want to replace that with `(function () { return this; })()` like I wrote above. For example, it returns `window` in Chrome and `global` in Node. 2. `undefined` is a global variable, which, like you've expressed, shouldn't be trusted. What happens when someone sets `undefined = 42`? The solution is to use `typeof window.foo !== "undefined"`, at which point you may as well just be writing `foo !== "undefined"`. QED.
All evergreen browsers, and IE10+.
These are the attributes right? if(canvas.width != canvas.clientWidth || canvas.height != canvas.clientHeight){ //Resize canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; }
You mistake `Boolean` used as constructor (bad) and `Boolean` used as function (coerces value to boolean; useful for `Array.prototype.filter`)
Blog to follow
Yup. Like i said; it'll improve it... not fix ut. Canvas is a CPU hog
Seems like this one was designed to be wrapped and not used directly.
Ugggghhhh, really? There was article up here not too long ago that explained `this`. I understand it is confusing, but the solution is simple. Don't use it. It is easy to achieve code reuse in this language without inheritance. This isn't Java... pun intended.
Don't waste people's time asking about libraries and frameworks. If somebody is drug addicted to a particular framework and cannot write JavaScript without it then fortunately you don't have to hire them. If this is an entry level position ask them about how to write code like in your examples. If it is a senior level position they should already know this. Instead ask them about the subjects here: https://github.com/prettydiff/wisdom/blob/master/Web_Education.md
&gt; Don't use it. That's the wrong decision.
 "ithinkso" "gotmedude" "hahayouwish"
First of all, you cannot overwrite the global undefined in modern JS engines anymore; that was fixed a while back. Secondly, I used `window` as an example for the global scope. Whether or not you have `window` or `global` means naught--all of points are still entirely valid. Thirdly, your function to retrieve the global context does not work in strict mode, which is what all modern JS moving forward is/should be written in. If you're concerned about the global `undefined`, you are able to use the `void` keyword to retrieve the true engine's undefined, but using the global undefined is safe on its own.
Fuzzy logic return values, I like it.
Can you show me a running example of JavaScript you've created?
I don't think you've read the docs or the specs carefully. There's a difference between the Boolean constructed object and the function. The function performs type conversion. const testBoolean = Boolean(""); // used function, not object constructor testBoolean ? console.log("true") : console.log("false"); // =&gt; "false"
Why? If you can achieve the same goal, code reuse, without the extra convention based archaic boilerplate then why bother with it? My guess is that people punish themselves with this madness, because it's familiar for Java developers.
Ask them if they could be any kind of tree, what tree would they be. If they answer with binary, make them sort it. ES7 only.
So not only are you down voting me for pointing out a place where Boolean object instantiation behaves differently than expected but you claim that I didn't read the docs, then you show a completely different usage pattern that works as intended. The point is that the Boolean object behaves in unpredictable manners depending on implementation, and for new developers that are prone to making simple mistakes, like using 'new' when they shouldn't, they should stick to the simpler methods instead, such as using !! for booleans.
Thx, fixed it
It doesn't necessarily have to be a PDF. I apologize if my post was a bit poorly written. I currently have a PDF with all of the files, but I also have all of them saved as images as well. Is there a way to do it in Visual Studio without having to enter each question manually? The multiple choice "bubbles" are already present - I would just like to find a way to make them "clickable".
No it doesn't necessarily have to be within the PDF itself. I don't have much experience with programming languages or anything, but I am pretty computer-literate. I was just wondering if there was a way to achieve what I am trying to do without taking an enormous amount of time.
Ah so my first post was right :p
My guess is, then, that IE10 and IE11 are the only browsers you test with that require the polyfill.
The Boolean function works as intended, and if browsers are following the ES specification, then there's a definition for both the object and function. Otherwise, whatever browser version you're talking about has not implemented ecmascript. You say that Boolean() behaves unpredictably based on implementation. What browser version are you talking about? This "usage pattern" (using the function) is the prescribed one by the Mozilla docs, and the Mozilla docs distinguishes between the object constructor and the function. As does the specs. It works exactly as intended. You're the one who insists on framing the discussion around the Boolean object constructor. The !! pattern is worse than the Boolean function because type conversion should be done explicitly and without extraneous effects. The reason why people do double-negation is because they only wanted type conversion, but the ! operator converts type *and* negates. http://stackoverflow.com/a/1406618/5050271
Hmm, there's not many easy ways out there to take an image and convert it to something (like text) that can also then be interacted with and styled accordingly/automatically. Additionally, if you're going to distribute this test as a HTML/JavaScript file, then technically you're opening yourself up to cheaters (e.g. a user could simply inspect your document and read the full source, so any hidden pictures, sections, etc - could be exposed). I would recommend converting your PDF image (just a blank test example) to text (try one of the sites under these [search results](https://www.google.com/#q=convert+a+scanned+image+to+text)) and then manually pull out all the questions/answers and build the test out with an online tool (such as [qzzr](https://www.qzzr.com/tour)) where they can handle obstrucifying the source correctly through a back-end/etc &amp; storing all your results. Good luck!
You seem to be reading too much into it. Try to read that first code example in the MDN again. It uses the new operator. Wouldn't that be confusing to a new developer looking for examples? I think so.
tcl!
The organization of the content into category cards is pretty nice. Its easy to focus or ignore certain content.
You just aren't trying hard enough.
/r/cscareerquestions is probably better for this.
&gt; Integers are fine. This isn't necessarily true in JavaScript because the integers are still stored as IEEE floating point numbers internally, so if you enter a large enough integer, you lose precision (only the last digit of these integers differs): js&gt; 123456789012345678901234567890 == 123456789012345678901234567891 true Whereas in Python, which has native big-integer support, this correctly evaluates to False: python&gt; 123456789012345678901234567890 == 123456789012345678901234567891 False 
&gt; What's different? All languages that use IEEE floating point will give you the exact same result. The differences that you are seeing are only a matter of display, i.e. they use different algorithms for converting a floating point value to a string. Some languages try to pick the shortest string that will still round trip to the given value. That sometimes hides the inaccuracy, but it's always there. The fundamental problem with what you're trying to do is that is is *impossible* for the computer to represent the value 2.05 using binary floating point. As soon as you typed 2.05 in your program, there was an inaccuracy. It has nothing whatsoever to do with the multiplication; it already existed before you tried to do anything with the value. When you write 2.05, the number you're actually using is 2.04999999999999982236431605997495353221893310546875 which is the closest value that the computer can represent. But again, due to the way that the float-to-string routines work, if you try to print 2.05 you usually will get the string "2.05", not the string "2.04999999999999982236431605997495353221893310546875", even though the latter is the value you're actually working with. But as those two strings unambiguously represent the same floating point number, the implementation chooses the shorter representation. That doesn't mean that it's actually using the value 2.05 though. Again, that value *cannot be represented.* It's impossible. It would require an infinite number of bytes, because in base 2 it requires an infinitely repeating fraction to represent that value. Floating point (or more precisely, the type of floating point commonly used by languages) does not use base 10, it uses binary. So you can't reason about the digits as powers of base 10, as that's not what the computer is doing. 
&gt; Changing the scope of wikipedia because LOGO?!? Show that it's outside of the scope, because you've asserted that without proving it. They do video and audio, so it's not just words and pictures as you claimed. And I suspect that if they asked for a safe environment for JavaScript embedding and execution like a codepen or [jailed](https://github.com/asvd/jailed) etc that was mapped to a canvas then they would get some interest.
Only several dozen million. 
*shrug* At least they document their return values. API docs that make no mention of possible exceptions or return values are one of my pet peeves.
It's called bleeding edge because it's covered with blood. Your blood! DUN DUN DUUUUH!
Perfectly achievable already: const sleepAsync = time =&gt; new Promise(resolve =&gt; setTimeout(resolve, time)); // Async/Await (async function () { await sleepAsync(3 * 1000); return "Hello"; })().then(console.log.bind(console)); // Or use a coroutine co(function* () { yield sleepAsync(3 * 1000); return "Hello"; }).then(console.log.bind(console));
This is trivial to implement yourself using the existing setTimeout and Promise. function asyncTimeout(delay) { return new Promise(resolve =&gt; setTimeout(resolve, delay)); } asyncTimeout(500).then(() =&gt; console.log(1)); 
Cool, didn't know that. I always treat this as [int-max](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER) 9007199254740991 So this explains why I've never come into that problem.
Does this support environment support ("env" in .babelrc)?
Can you pass arguments to plugins? e.g. [ "babel-gettext-plugin", { "functionNames": { "t": [ "msgid" ] }, "fileName": "strings.po" } ] ],
Sure. Just saying there are different words that would make the semantic distinction more clear. In life, I would say "probably" and "maybe" in similar circumstances, even though they mean different things. 
Semi-newbie? Seems like you know (typeof null); // "object" (typeof undefined); // "undefined" // anyway, the bug is that ... for (let i = 0; i &lt; 10000; i++){ console.log(typeof null === 'undefined'); } // somehow returns 50% false and 50% true in Chrome yet for (let i = 0; i &lt; 10000; i++){ console.log(typeof null === typeof undefined); } // returns 100% false, so you're right in your suggestion ... of course traditional use of var ... for (var i = 0; i &lt; 10000; i++){ console.log(typeof null === 'undefined'); } // returns 100% false ... interestingly enough, declaring let before the loop ... let i; for (i = 0; i &lt; 10000; i++){ console.log(typeof null === 'undefined'); } // returns 100% false ................ what a crazy weird error 
I understand wanting to have middle of the road rest parameters, but the restrictions in place in ES6 force better code style. If it were up to me, rest parameters would not be a thing, since any function that has a rest parameter should probably just take an array instead.
For now, why not just ask users if the plugin has options, and let them input free form JS? It's not great, but it's something.
Agree with that.
Awesome man, I starred your repo on github. Our babel configuration is fairly complex and managing it has become not a chore per se, but enough that a utility would be a godsend! 
It has to do with how operations are handled once the numbers are converted to binary. It is also not only a problem limited to javascript. Other people have given websites so i'll link a video explaining it: https://www.youtube.com/watch?v=MqHDDtVYJRI
It actually tells you this in the "Description" section of that very page `;)`: &gt; The reasoning behind that number is that JavaScript uses double-precision floating-point format numbers as specified in IEEE 754 and can only safely represent numbers between -(2^53 - 1) and 2^53 - 1.
https://www.reddit.com/r/javascript/comments/4oxtgk/javascript_developers_be_warned_about_this_crazy/
They could certainly, but I was more hoping that larger blogging platforms would take it up and enable that sort of interactive plugin.
I think the accepted way is to not use .defer() style development. You could wrap in new Promise or use Promise.resolve/reject. 
along with listing your previous non-development jobs, list your personal projects that you have worked on in your free time, also I find lots of employers like to see what your hobbies are if you have any hobbies that you are really passionate about , and achievements in that regard, the more relevant to development the hobby is, the better. For a junior level position they are more so looking for someone enthusiastic and capable of quickly learning way more than for someone with tons of experience that is already a really good dev.
You could try Object.keys combined with Array.reduce to loop over the properties of the object and build out the new one.
Interesting I'll try those together
Well if you have jQuery then there's var merged = {}; jQuery.extend(merged, a, b); or jQuery.extend(true, merged, a, b); for a deep copy. Or there's http://underscorejs.org/#extend Or if you have an NPM build process then there's https://www.npmjs.com/package/deepmerge 
The problem with asking specific questions like those is that everyone has strengths and weaknesses, and it can come down to luck whether the few choice questions you ask match their strengths. Someone might know the jQuery API like the back of their hand but might know "this"-binding just well enough to get stuff done. Or they might have built cool stuff with jQuery and Angular and React and others, but if you ask about a specific API, they might need to check the docs, because that's what we'd do in real life; we don't need to memorize those things. I think you best bets are either: 1. Give them a problem and let them code from scratch, and let them use whatever language they want and whatever framework they want. This is about checking their ability to build software and solve problems with good, maintainable code, not whether they've read the ECMAScript spec. 2. Or make them do a code review. This is a good way to check their knowledge of language nuances in a way that reflects real life work. Whichever you go with, make sure the candidate knows about the test in advance, and let them use their own system. For example, I have ESLint integrated into my editor, and that can make a world of difference, especially for code reviews.
The problem with asking specific questions like those is that everyone has strengths and weaknesses, and it can come down to luck whether the few choice questions you ask match their strengths. Someone might know the jQuery API like the back of their hand but might know "this"-binding just well enough to get stuff done. Or they might have built cool stuff with jQuery and Angular and React and others, but if you ask about a specific API, they might need to check the docs, because that's what we'd do in real life; we don't need to memorize those things. I think you best bets are either: 1. Give them a problem and let them code from scratch, and let them use whatever language they want and whatever framework they want. This is about checking their ability to build software and solve problems with good, maintainable code, not whether they've read the ECMAScript spec. 2. Or make them do a code review. This is a good way to check their knowledge of language nuances in a way that reflects real life work. Whichever you go with, make sure the candidate knows about the test in advance, and let them use their own system. For example, I have ESLint integrated into my editor, and that can make a world of difference, especially for code reviews.
Ya but I need the product to be in a pretty specific format. This is what I have so far: let x = 0 let y = 0 let tmpArr = [] let {categories, emojis} = this.state for (var cat in categories) { tmpArr.push({ id: cat, title: categories[cat].title, emojis: [] }) for (var emoji in categories[cat].emojis) { tmpArr[x].emojis.push(emojis[emoji]) tmpArr[x].emojis = _sortBy(tmpArr[x].emojis, 'position') y++ } x++ }
The problem with asking specific questions like those is that everyone has strengths and weaknesses, and it can come down to luck whether the few choice questions you ask match their strengths. Someone might know the jQuery API like the back of their hand but might know "this"-binding just well enough to get stuff done. Or they might have built cool stuff with jQuery and Angular and React and others, but if you ask about a specific API, they might need to check the docs, because that's what we'd do in real life; we don't need to memorize those things. I think you best bets are either: 1. Give them a problem and let them code from scratch, and let them use whatever language they want and whatever framework they want. This is about checking their ability to build software and solve problems with good, maintainable code, not whether they've read the ECMAScript spec. 2. Or make them do a code review. This is a good way to check their knowledge of language nuances in a way that reflects real life work. Whichever you go with, make sure the candidate knows about the test in advance, and let them use their own system. For example, I have ESLint integrated into my editor, and that can make a world of difference, especially for code reviews.
The problem with asking specific questions like those is that everyone has strengths and weaknesses, and it can come down to luck whether the few choice questions you ask match their strengths. Someone might know the jQuery API like the back of their hand but might know "this"-binding just well enough to get stuff done. Or they might have built cool stuff with jQuery and Angular and React and others, but if you ask about a specific API, they might need to check the docs, because that's what we'd do in real life; we don't need to memorize those things. I think you best bets are either: 1. Give them a problem and let them code from scratch, and let them use whatever language they want and whatever framework they want. This is about checking their ability to build software and solve problems with good, maintainable code, not whether they've read the ECMAScript spec. 2. Or make them do a code review. This is a good way to check their knowledge of language nuances in a way that reflects real life work. Whichever you go with, make sure the candidate knows about the test in advance, and let them use their own system. For example, I have ESLint integrated into my editor, and that can make a world of difference, especially for code reviews.
The problem with asking specific questions like those is that everyone has strengths and weaknesses, and it can come down to luck whether the few choice questions you ask match their strengths. Someone might know the jQuery API like the back of their hand but might know "this"-binding just well enough to get stuff done. Or they might have built cool stuff with jQuery and Angular and React and others, but if you ask about a specific API, they might need to check the docs, because that's what we'd do in real life; we don't need to memorize those things. I think you best bets are either: 1. Give them a problem and let them code from scratch, and let them use whatever language they want and whatever framework they want. This is about checking their ability to build software and solve problems with good, maintainable code, not whether they've read the ECMAScript spec. 2. Or make them do a code review. This is a good way to check their knowledge of language nuances in a way that reflects real life work. Whichever you go with, make sure the candidate knows about the test in advance, and let them use their own system. For example, I have ESLint integrated into my editor, and that can make a world of difference, especially for code reviews.
The problem with asking specific questions like those is that everyone has strengths and weaknesses, and it can come down to luck whether the few choice questions you ask match their strengths. Someone might know the jQuery API like the back of their hand but might know "this"-binding just well enough to get stuff done. Or they might have built cool stuff with jQuery and Angular and React and others, but if you ask about a specific API, they might need to check the docs, because that's what we'd do in real life; we don't need to memorize those things. I think you best bets are either: 1. Give them a problem and let them code from scratch, and let them use whatever language they want and whatever framework they want. This is about checking their ability to build software and solve problems with good, maintainable code, not whether they've read the ECMAScript spec. 2. Or make them do a code review. This is a good way to check their knowledge of language nuances in a way that reflects real life work. Whichever you go with, make sure the candidate knows about the test in advance, and let them use their own system. For example, I have ESLint integrated into my editor, and that can make a world of difference, especially for code reviews.
Isomorphic code runs on client and server. `require('babel-loader!file.js')` doesn't work on node unless you want to make a bundle for that too.
~~A little algebra will get you on the right track. Google "sum of first n natural numbers"~~ ~~10 * 100 + 10 * 200 + 10 * 300 + ... + 10 * n * 100 = 1000 * (1 + 2 + 3 + ... + n) = 1000 * n(n + 1) / 2 = 500n^2 + 500n.~~ ~~So, when level = 10*n, then xp = 500n^2 + 500n. A quick sanity check when n=2: Level = 20 and xp = 3000.~~ ~~Assuming the amount of xp needed between levels is linear, you can extend these formula passed integers into the real numbers. That is, when level = 10x, then xp = 500x^2 + 500x.~~ ~~So, if you're given a value for xp, just solve for x.~~ ~~For example, if xp = 8000, then 500x^2 + 500x = 8000. Using the quadratic formula gives you a positive root of ~3.53. So level is 10*3.53 = 35.~~ ~~So, an un-simplified formula would be:~~ ~~var level = (-500 + Math.sqrt(250000 + 4 * 500 * xp)) / 100;~~ EDIT: formatting math is hard EDIT2: This is wrong.
&gt;I--along apparently with at least a couple of other users--may have been defrauded. I'm mostly interested (which is to say not very) in this bit. but not even a fiddle or live example? and you don't want to waste anyone elses time you say? the do nothing at the end part, if you run it in dev console a bb-flip-next-end class is added when you click, you can probably hack on that definitions in bookblock.css or see what is injecting it.
Semi-newbie as in "I've been programming for some time now, not necessarily in JS" ;) it's just that I don't why you'd want to check types by string comparison not types comparison. 
Write some sample JavaScript code and have them debug it in the chrome debugger. I've found good debugging skills really make a huge difference to productivity of a programmer. Show them some code with unsafe equality checks and ask them what is wrong with it. Eg testing a value for falsy when the value may legitimately be an empty string. Ask them to configure a small webpack project. ;) Ask them if they know the difference between npm 2 and 3 (that would demonstrate familiarity with the ecosystem. If they describe flat vs nested structure, props). Ask them about their experience with js modules (if they can tell you the differences between commonjs and es6 modules they may know something). Ask them how const and let differ from var (if they mention block vs function scope and hoisting you may have a winner). Have them describe what a polyfill is and under what circumstances they might use one. Ask if they have used any. Ask them about experience with any js templating libraries they may have. What's a transpiler and why would you use one? Have them use jquery or some other library to attach an event handler. Then ask them to do it using plain js. If they have used react, ask them what benefits they believe react has (composability and purity means they are paying attention). Ask them if they have ever considered using immutable objects, and why (advanced). Ask them what are some of the limitations of JavaScript? Eg, no integer type. Weak typing leads to errors. Ask them if they have ever had challenges using two frameworks or libraries together and how they overcame the issues. Don't ask stupid questions about confusing, non real world syntax or esoteric problems. Let them look anything up. A good programmer might not / won't have all the things memorized but will be good at quickly researching. Quick debugger use, quick terminal use, and quick google use are all good signs, as long as they can also write some code. ;)
no dice in the codepen "Failed to load resource: the server responded with a status of 403 (Forbidden) http://i.imgur.com/eWtfMME.png tried a second time, picture showed up but no lines or controls or anything... what do you mean you've been "looking" at next-end? did you try to force a refresh between modifications to the css file?
Babel, Immutable.js, Web pack, mocha and chai 
neither of these options are great...try something like router.get('/', async (req, res, next) =&gt; { const results = await getResults(); res.send(results); }); I wrote a blog post about how you can then use a simple wrapper to catch errors and pass them to your express error handler http://madole.xyz/error-handling-in-express-with-async-await-routes/ 
Nice work! You should probably add a `Math.floor()` in there too.
I guess never before have we had such a fierce commercial competition between compilers. Short life cycles, performance oriented, over the subset of a language that constantly changes its syntax... It must be hard.
First, learn JavaScript
I know javascript.
Possibly from Google Analytics' cookie API.
"Creating your own command line tool is amazing " wat?
Direct link: https://medium.com/yet-another-node-js-blog/architecture-of-node-js-internal-codebase-57cd8376b71f#.e1kmj9bz4
Take a look at http://survivejs.com/webpack/introduction/ and https://blog.madewithlove.be/post/webpack-your-bags/
Real title: How to make a jQuery plugin.
if you're using Node you'll be able to freely make use of ES6/7, since you have full control of the environment that your code is executing in, you don't have to worry about polyfills for old browsers. That said V8 is still in the process of implementing all of ES6 so you won't be able to use some features yet. Promises, they're amazing. Asynchronous operations are going to be everything you do in Node, you can't afford synchronous code blocking the stack, since that stack is being used by everyone who connects to your server. Promises make async very easy to work with. Unit tests. There are testing frameworks like Nodeunit and Mocha, but they tend to be overkill for what most people want to do. Tape is one that is very lightweight. I don't know how much Javascript you know, but it'd be worth watching the Crockford on Javascript lecture series, he goes into some depth, though its quite dated since its from circa 2009 and the release of ES5, its still applicable and won't harm your understanding. https://www.youtube.com/playlist?list=PL7664379246A246CB I'd recommend working with a highly opinionated linter if you don't already. Javascript is very 'beginner friendly' meaning it'll let you do some really stupid things, a linter can help you avoid antipatterns, ambiguous code and errors. Many IDEs come with linter plugins that you can use, Atom and Sublime have a bunch. Personally I use ESLint with most of the rules turned on.
This might actually be a good case to write a (convoluted) test first and _then_ refactor. Having a test in place can make refactoring much quicker (and safer).
OP are you the creator of this? It's really amazing. I'm interested lately in functional programming and so this is a great way to explore it 
I like this approach, more than I like a typescript-like approach.
Nice article for jQuery plugins (spoiler alert)?
Why so? What are the tradeoffs? (never used typescript but hate working without types)
What's the difference to a TypeScript-like approach, according to you? The main difference I see here, is that this also adds runtime type-checking (which may or may not be what you want), but otherwise, especially in terms of adding it gradually, it looks pretty similar.
Agreed, this is a brilliant piece!
If we're talking about flow vs typescript (so only the static parts), then the major win for flow is it's ability to infer types. Consider for example the following snippet: function multiply(a, b) { return a * b } multiply("foo", "bar"); Typescript will happily compile this snippet without errors, but flow automatically infers that `a` and `b` must be numbers, and will throw. A Flow project generally contains significantly less type annotations than a typescript project, while providing stronger guarantees than Typescript. Other than this the type system of flow is also generally more powerful, and additionally flow is actually JavaScript, while TypeScript is a separate language. 
If I had written this it'd have been MUCH shorter. That integrity tag seems nice, but how are failures handled?
Here is the companion blog article https://tonyspiro.com/getting-started-with-mobx-an-easy-example
To hell with Boolean values dammit :)
Noticed that now! :) But if i want, lets say xp=600 to show the number 6 instead of all the decimals. Where would i put the Math.floor? Or other code that might work better. Also, i noticed the numbers (xp) from 200-600 shows one level higher, any workaround for that? :)
http://i.imgur.com/HoaSDzm.png
Off the top of my head: 1. I believe css-loader does parsing and following of CSS imports, whereas style-loader creates the `&lt;style&gt;` tags in the DOM and updates them as needed. Normally you'd use them together - css-loader first, style-loader second. 2. file-loader generates a URL for an imported file; url-loader will turn a file's contents into a base64 string if it's less than the designated size, and fall back to file-loader otherwise; and html-loader appears to load an HTML file as a string, and turn referenced images into `require()` statements. 3. I think that `webpack -p` implies `UglifyJsPlugin`. Personally, I just specify the plugins I want directly in my production config. 1. Most of the time you wouldn't specify the entire filename, especially if you're doing multiple output bundles. You'd specify the output name as `filename : '[name].js'`, which would automatically generate the name for each output file based on the `entry` field, and write them to the folder specified by `path`. Beyond that, I keep a list of links to high-quality React-related articles over at https://github.com/markerikson/react-redux-links. One of the pages is a list of [Webpack tutorials](https://github.com/markerikson/react-redux-links/blob/master/webpack-tutorials.md) that you may find useful. In particular, https://medium.com/@rajaraodv/webpack-the-confusing-parts-58712f8fcad9 gives a lot of great information about many of the options you'll see in a Webpack configuration.
Thanks for the answer. 1. What do you mean by the file system? disk read/write performance? The time node takes to read/write from the file system? (slow db's etc..) 2. It depends on the code but I think it's better to use API functions of whatever environment you're using. This will prevent you from causing accidental security issues or bugs.
As Sandern pointed out, do not directly set the style property, it works in some browsers, but it's better to just set the attribute instead. el.setAttribute('style', 'font-weight: bold')
&gt; and additionally flow is actually JavaScript, while TypeScript is a separate language. Both Flow and TypeScript are super-set of JavaScript and not equal to JavaScript itself. Also I'm sure that `function(a: number) {}` (which is both valid Flow and TypeScript) is not valid JavaScript.
Hi all, after playing a few days with this plugin I can say I want a static type checker, *any* type checker. I picked Flow because was the easiest path and its semantic is close to tcomb's (e.g. non nullable types, union and intersection types, ..), so the translation has been straightforward. I'm eager to see TypeScript 2 coming out and try the same thing using TypeScript at least as a type checker if not as a compiler. Another thing: static and runtime type checking are really complementary. Having the runtime type checking as a fallback is pretty handy: sometimes Flow can't infer the correct type because the JavaScript code is too dynamic or "magic", other times Flow seems buggy and sometimes, even more useful, the runtime highlights some problem with my type definitions and I can amend them accordingly. Definitely they work toghether nicely.
That's not correct, setDate works from the start of the month. So you need to include the actual day of the month. date.setDate(date.getDate()-60) 
Going to toss out some generic advice for you: First, there's many, MANY resources out there to help you learn JS. Tutorials, articles, books, online live editors, games that teach you JS as you play, etc. I maintain a list of articles and tutorials related to a library called React, and as part of that I've recently added a page that points to many of these other resources. My list is at https://github.com/markerikson/react-redux-links/blob/master/javascript-resources.md , and should give you some places to go look for more information on JS in general. As for your specific problem: there's two main ways you could approach trying to display "colored lights". One would be to use HTML elements and specify their current location, size, shape, and background color, such as `&lt;div style="width: 20px; height: 20px; background-color: red" /&gt;`. Another would be to use the Canvas API to draw the correct shapes onto a `&lt;canvas&gt;` element. One good place to learn how to use a canvas is http://www.html5canvastutorials.com/ . Either approach would work fine, just up to you. Hopefully that's enough info to get you started on the right path.
Webpack runs isomorphic code, which is what i said. As for loader directives, you don't have to do it that way and you most likely wouldn't. You just say require('file.js') and declare the loader in your config. Or you bablify it otherwise and require the transpiled result.
I guess any fail over would need to be handled in js?
I've just implemented it to test and so far it looks good as far as I can tell: Chrome x64, Firefox x32 and IE11 (x32... duh) on my Win7 x64 machine all produce the same results in that one unscientific "does it look the same" test I made, crashing a bunch of breakable objects together. I'd assume that google, mozilla and microsoft probably use wildly different compilers and stuff, so this seems to indicate that at least recent browsers try to strictly follow a certain standard (presumably IEEE754?) on how to handle floating point operation/optimization. Lots of assumptions based on one single test though.
I sometimes use it in event handlers as a shorthand back to the firing node if the node isn't otherwise clear. There will always be edge cases. I am just of the opinion that `this` should be avoided without some minimal experience already established in the language, as it seems to generate more pain than is immediately clear.
CodeSchool and FreeCodeCamp.
&gt; Defining the runEmeraldCode function is left as an exercise for the reader. 
&gt; the integrity attribute would prevent the malicious script from running. Which would break your site most of the time. It is possible to code such that an `integrity` failure doesn't break anything, but it's tricker. I agree about browser caching, it would make this feature MUCH more valuable.
Or, someone accidentally added an extra newline, or made some other trivial change. It's just as possible for this to break your code as it is for it to catch a real modification unfortunately.
&gt; *Is there ever a good use for document.write?* &gt; None that I’m aware of. What about local CDN fallbacks? &lt;script src="https://code.jquery.com/jquery-2.2.4.min.js" /&gt; &lt;script&gt;window.jQuery || document.write('&lt;script src="jquery.js"&gt;&lt;' + '/script&gt;')&lt;/script&gt; Seems to be common enough. *inb4 &gt;using jquery in 2016*
Y'know what... I'm realizing now I misunderstood the problem. My solution is not correct. For example, 1200 XP should be exactly level 11. My formula gives 11.28. I'm at work now but will take another look this evening.
I think you need to clarify this question. Maybe include the code you have already written. But as I understand now is that you want to iterate `n` times to create multiple concurrent processes? To my knowledge this is not possible in regular JavaScript. You will either need to spawn multiple child process using nodejs or utilise web workers to do the work for you. But that is to complex( for lack of a better word ) for what you are trying to achieve.
Oh freecodecamp is new, thanks I'm trying that now :)
Some context here would definitely help us address your question (along with sample code). Are these users each on their own PC/app instance, are they sharing the keyboard/etc together all on the same pc?
Right, but the file you're pointing to could change in a trivial way, at any point, breaking your app. If you really care about reliability, I'm starting to think you should just self-host your dependencies.
I can deduce just by looking at your code that the issue has to stem from the fact your gif path is relative. Try opening your console (F12 in Chrome) and reload the page, does an error pop up indicating it was unable to load the image? If so, it's probably because your path is relative and you either moved your HTML file or moved the location of your GIF file. You can always do absolute paths (I advise against this) or restructure your folders/files correctly so your relative path works.
CodeSchool is what you described as well. It's not the same thing as CodeCademy.
Take a look at: https://help.disqus.com/customer/portal/articles/1104798-using-the-api https://disqus.com/api/docs/
True; it's mostly useful if you a third-party CDN such as S3, i.e. you posted the file there, but it's still an external provider that might be compromised.
For beginners, perhaps React/MobX is more friendly. Angular 2 will take some time to be completed, but it's gonna be popular once it is ready.
What they did here is not inference, but "disallow type coercion". `multiply('2', '3')` is entirely valid usage. To properly inference this without removing coercion from a category theory standpoint, you need to implement types for `string_coercible_to_number` (e.g. '1', '2', ...) `string_not_coercible_to_number` (e.g. 'a', 'b'...). 
To be honest, I think the usage of `this` in event handlers is awful. It makes function binding complicated. 
But remember that it's not supported by IE &lt; 9 and it works differently in ES5 and ES6. From [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions): &gt;In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return it. Object.preventExtensions(1); // TypeError: 1 is not an object (ES5 code) Object.preventExtensions(1); // 1 
X-Post referenced from /r/aureliajs by /u/Davismj [Introducing the Aurelia HUB Beta](https://www.reddit.com/r/aureliajs/comments/4pizwt/introducing_the_aurelia_hub_beta/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Facing a similar type of situation. I wouldn't use the term "flop", but even when Angular2 is officially released, there's going to be the managerial reaction that it's "too new", so there'll be an additional window of time where the canaries in the coal mine upgrade their *production* application / stack fully over to 2.0. Once there's a critical mass of production adoption, along with the usual Medium / HN posts of "Why we finally went to Angular2", then I suspect there'll be less angst (hopefully)... Right now, when companies are paying me money and I'm responsible for delivering a product, I'm still shipping with Angular 1.x. Wish I could comment more on the React side, but I've just been mainly deep focusing on Angular 1.x and Backbone work.
It is IEEE 754 double precision round-to-nearest for almost everything. http://www.ecma-international.org/ecma-262/5.1/#sec-8.5 If some implementation doesn't do that, you can probably report it to them as a bug, since they didn't follow the spec. 
"The RC isn't going to last long. We're going to RTM before the end of July." **R**elease **T**o **M**anufacturing seems odd to use in this case. Who are the manufacturers? Does this mean a public v*Whatever* release?
That is a good use for it, thanks for pointing it out!
You cannot check if the for loop is running, because Javascript is a single threaded language. Whenever a for loop starts, IT WILL FINISH before any thing else can happen. 
RTM, RTW.. same diff. But yes, it means the v1.0 release will happen before the end of July
Thanks! Some context, this is for testing security for a single page app. I have to make sure that securedObject singleton is wiped on logout, and that I haven't accidentally added some property to my singleton that is persisted after logout. So it's not important to work on all browsers as long as I've tested thoroughly on a compatible browser.
# Complex library, multiple exports As someone who makes a library you don't have to bundle at all, your clients do. You publish your bablified modules to npm, someone npm installs your lib and picks out whatever needed either using paths: import This from 'aws-sdk/this'; import That from 'aws-sdk/that'; Or, you have provided something like a [index.js] in which you are re-export everything in one file: export This from './this'; export This from './this'; your client then can extract: import { This, That } from 'aws-sdk'; In Node no bundling is needed. In the browser it has to be bundled. This is great because only the portions that are actually used will end up in the production build. Webpack2 also tree-shakes, even your index.js, which exports everything, will be cut down to what is actually used. If you need to make a global namespace script-incude, you provide a bundle right next to the modules you already ship. The easiest way would be to create a file called [browser.js]. You import everything you need, put it into your namespace: import This from './this'; import That from './that'; window.AWS = { This, That } and run webpack over it. Your client includes it and accesses it like always: AWS.This(...); AWS.That(...); Additionally webpack can do that for you using some config options but the documentation is awful in that regard. # Simple library, single export If your library is really simple and you're dealing with a single export, don't worry about any of it. Just wrap it into a UMD: https://github.com/umdjs/umd
I'm in the same boat too, with a large "in production" project, to future proof and speed things up personally I like the idea of switching the views out to react, however I think that switching the routing and more "top level" stuff from angular to react might be tricky. I am more familiar with angular but as I understand it react doesn't really have the same inbuilt functionality as angular to deal with this sort of stuff. Therefore I'm going to wait for angular 2, version 1.1 ish then decide again, for me there is no nice solution to switch a large project too, or at least the pros are not worth man hours.
There are a lot of ways to solve this, but here's a simple example: https://jsfiddle.net/4pLa7d8o/ 
Right. "Flop" may be a little strong. I think it's fair to say the timeline has stretched as things have gone on. Anyway, they say this is the last release candidate (I believe), so hopefully we'll start seeing lots of posts from early adopters.
Side note : I found going from 1.3 to 1.5 a simple case of swapping numbers in my bower.json - pretty much everything just worked. Easy win.
Context : I've worked with angular 1.4, migrated to 1.5 (component based) then migrated to React. React + redux is definitely a great combo, and I find it much more pleasant to work with. I'm also a single developer, very passionate about this stuff, which means I spent countless hours documenting myself on personal time. You could also consider migrating to React/Redux the other way around, by starting by the business logic to redux+ngRedux before migrating the view layer. Start easy, convert stuff to components, refactor 2 way data bindings out, use redux when appropriate for state management. You should know that writing ES6 with Redux/one way databinding/immutability is very different from traditional ES5/Angular providers/services. ES5 to ES6 is quite simple. The steepest curve lies in data flow and state management. These concepts are just guidelines to structure your app though, you can apply them with any framework, even though React feels the more natural. In my experience, focusing on the business logic first enabled me to get familiar with these new concepts without having to worry about pure view dependencies. I was very dependent on angular-material, not having to worry about migrating my stuff to material-ui was helpful. Also, your codebase should feel pretty clean afterwards and moving from angular to React will be quite simple. Be advised though, should you choose this path, I have no idea how ngRedux performs performance-wise.
It won't matter even if the AJAX is async. The AJAX request will be issued and the loop will keep looping until it ends. And only after that the AJAX callbacks are executed, one at a time.
Another potential use: SVGs can embed raster image files inside themselves using a tag like the img tag called the image tag. Also, SVG css display none will not prevent the downloading of assets associated with an unused css selector, preventing CSS based solutions for the retina image display feature. One can use JS to set the image src after the page loads, but that means delaying the initial start of the correct image download until the page finishes loading. Using document.write, you can inject the correct image tag as the page is being loaded.
What is this for? You can use yargs, optimist, or minimist for awesome option parsing...and what else do you need? I've created tons of cli tools with node and don't really understand what this thing is supposed to be used for. 
It's a great learning experience and you can make some incredibly useful shit. 
https://github.com/ngReact/ngReact https://github.com/angular-redux/ng-redux Gradually replace ng1 components with React while moving the model layer to redux. Once you've got a handle on React/Redux, the rest of the conversion will be easy.
Famous last words.
Javascript is single threaded, so yhou cannot do that. The closest you could come would be to invoke ajax calls inside the loop. I dunno. You weren't very specific, and I think i just reiterated what the other two commenters said. 
Yep.... ;-) 
Decide on a small project that doesn't take much skill and try to build it. As you build it, you'll inevitably need to learn new things. So, as you go along, look up those things that you need to learn.
Cool! I don't know if it's your case but you can try the new Object.freeze too, although I think it do not throws an error, can't check it right now.
Could you please to elaborate on why 2 will be popular?
Is Aurelia worth learning? 
Or you can take the third way. **Stick to angular 1.x** &gt;But angular 1.x will die soon enough. so why stick to it? Incorrect. angular 1.x will not *die*, but the ng1 community will move to other. The key here is angular 1.x will solve the problem you are trying to solving. &gt;For now, yes. But what about the future? FYI, you are not the only one in this situation. In future, many will attempt to migrate from ng1 to ng2, aurelia, react, vue etc. Those brave hearts, who try first, will be the ones who will make many mistakes and suffer the consequences. But they will be *successful*. And when they succeed in migrating, others will follow and simplify **the upgrade path.** you see where I am going with this? The ng1 community will eventually come up with a upgrade path. So have patience, and upgrade when a tried and proven upgrade path is available. PS: this is called [game of chicken](https://en.wikipedia.org/wiki/Chicken_(game\))
Yeah, i get all that. What I mean is: let say I want to check if variable type is number. I'd rather do `typeof var_name === typeof 0` than `typeof var_name === "Number"`. My reasoning is that on both sides of comparison I'd use operation to get type(as string) instead of hardcoding the type, because if someone changes specs for JS(let say ES9?) and rename number type to "whatever" first code would still work. As I've said I really don't write much JS so maybe there are some downsides to what I suggest here.
 function message(inputDate, days, processType) { var tempDate = new Date(inputDate); tempDate.setDate(tempDate.getDate() - days); return 'Process ' + processType+ ' in this ' + Math.abs(days) + ' day window ' + tempDate + ' to ' + inputDate; } Don't forget to format your dates in the return statement.
don't worry about how many functions you create. modern js engines aggressively optimize code during compilation, including inlining functions if possible. your code is only a loose suggestion compared to what's actually run. in other words, if you can make your code more readable (and splitting out functions definitely achieves this) then leap for it.
At first it didn't make much sense to me, but then I realized you can simply return a value to resolve, or throw an exception to reject. It makes a strange sort of sense. 
Splitting functions for no good reason often makes code far less readable because you might have to jump around to figure out what is happening. 
His example literally created a function called _a so he wouldn't need to indent. I'd say that's a bit excessive and doesn't really help. 
Well basically I am making a Steam bot that loads users inventories. When somebody sends the Bot Account !buy in the chat it should load their inventory and send it back. Everything works, but not perfectly. I am using a var refamount = 0 at the top. In that the amount of the item Refined Metal will be stored. If only one person uses the command it works fine, but when 2 people use it at the same time it adds it all up, so it sends back double the amount than it has to be. I can't send code right now but I can later
You can try a demo at http://nhnent.github.io/tui.editor
This is a great framework if anyone cares to try it.
Especially when you can basically just take your existing angular code and use it very easily with mobx. Just replace scope with your mobx observable and you're good to go. Rewriting your html templates will be more work than your state.
I think that you can solve this problem by creating objects for each user that interacts with the bot and set the refamount in the scope of a user instead global as your description suggests you do now. Do you have the project on Github?
Some times it is Release To Market
Hey /u/dwighthouse! I hope this thread is still alive. Looks like plain n.childNodes[0].clientWidth==n.childNodes[1].clientWidth&amp;&amp;n.childNodes[0].clientWidth==n.childNodes[2].clientWidth is compressed better than (e=n.childNodes[0].clientWidth)==n.childNodes[1].clientWidth&amp;&amp;e==n.childNodes[2].clientWidth Also, could we replace `&lt;div style="...;white-space:pre"&gt;` with just `&lt;pre style="..."&gt;`?
I don't know where you say it saying that it's the last but it says on their within that there's up to RC 5 planed, but once it is released it'll be beatiful
What a frustratingly directed video. Interesting stuff!
I stopped reading at "you should learn Express and Mongo DB."
Amateur 
It's not broken by default, it's a Fallback when the cdn is offline and the browser doesn't have a local cached Version of the script.
Today the most prominent options are: * Webpack or Browserify: you use CommonJS in your modules like you would in a node.js script, but instead of loading required modules in the browser, those tools will bundle your whole app into one (or possible multiple) js files which you'd serve to your client * System.js: basically a shim which lets you use ES6 modules in your browser; you require modules via import, and those modules are loaded asynchronously; note that because of the possibly huge number of modules this may require an HTTP2 compliant server to work efficiently
slideOut is an empty node list. By the way, if you only want the first match, use querySelector instead o QSA.
&gt; this may require an HTTP2 compliant server to work efficiently it does work quite fine for HTTP1, you just bundle it. For development you can work without bundling-it is plenty fast if your latency is small and your machine is fast. Check out my boilerplate on github for more details on JSPM: https://github.com/capaj/jspm-react
That's great to hear. I think Angular 2 is a flop. Angular 1 actually tried to make frontend development easier. It succeeded in many aspects. Angular 2 does not make it easier, no way. 
I prefer Redux over MobX. I think it's a great idea, but there's too much magic in MobX for me. Redux is a simple, elegant idea where I can read the source code (tiny) and fully understand what it does. It also has a growing list of interesting surrounding libraries and middleware. Redux does seem to lead to a lot of boilerplate, but, for me, it's much easier to understand what's happening. That's good for code clarity and for on boarding new devs. This is really important to me. No offense to MobX, it's an awesome library.
Is there anything wrong with that?
Ah, that would make much more sense for my pea brain. Perhaps that was their intention.
I've been waiting for the public release so I'll definitely be checking it out, have been waiting for it for a while. Have Angular 1.x and React experience. Well, knockout and backbone, too, but the latter group was replaced with the former group...If you have React experience, how would you say Aurelia compares?
Not a bad point. I never questioned why strings are typically used. This is just the way I've always seen it. 
Your point about it being early for Angular 2 is well taken, which is another reason why I lean towards React/Redux. I have built my last two projects using these tools, so I also just feel comfortable with them. The job is come in and get this taken care of in the 6-9 month timeframe, so just waiting is not an option. The main motivation, for me, is not that Angular 1.x is going to die. The main benefits for this move is performance, which Angular openly has acknowledged is a problem. Angular 2 will be much, much faster and React has already proven its performance advantages over Angular 1.x. This only REALLY matters if you have tons of DOM elements on your pages. This particular app has lots of tables, charts and custom data visualizations, so the performance gains are real. Also, bloated controllers in Angular 1.x as the complexity grows are a real issue that I have seen in quite a few apps. This one included. So performance and reducing complexity would be key drivers. That with switching ES6/Babel will have a real impact in my mind.
The department I'm in in split in two halves (we're enterprise land). The other side decided to do an app in Angular 2. I was in the tech stack meeting for the app and when asked my opinion, I suggested they stick to Angular 1 at this time because we've done Angular 1 apps, have experience in them and don't have to go through re-learning what's new/changed/different in a beta/possible breaking changes because who knows what is actually happening. I thought the learning curve in Angular 1 was steep, why would you not want to leverage that investment as much as possible? They went with Angular 2. They've been at it for, it's gotta be over 6 months now, it might be like around 8 months. I lol, it's not even a big or complicated app and it's a *team* working on it. The best part was their tech lead/manager said over and over in the meeting "we don't always have to use the latest shiny". So what do they end up doing? lol. I think Angular 1 was/is very interesting, can't say I'm a total fan boy (right now, I'm more into React and I'm awaiting the public release of Aurelia to check out), but I will say a front end developer can be massively productive in Angular 1 if they just have to hit exposed web services to get data.
Hey thanks! I had considered both of these already. Using a pre tag instead of a div will certainly compress better, but it is not as generic of a tag. The end user page is much more likely to provide default styles for a pre tag than a div tag. To default style a div would be bad practice, but to do so for a pre not so much. To avoid that potential conflict, I will use div here. It is true that looking up the width a second time will compress better than caching the value, but I believed that the interaction with DOM was very expensive. Each lookup of actual widths may cause a complete repaint. I wanted to avoid that kind of runtime performance cost. However, now that I think about it, I am doing DOM traversal each time anyway. I will need to research the runtime performance to see if it is safe to do the width calculations twice, or if I need to increase the size in order to cache the DOM references.
I just uploaded it to PasteBin with some notes explaining the module! Please check if this is what you meant (it works!). [Pastebin link](http://pastebin.com/nNznAKG8)
ES6 is more or less universally accepted now, but transpilers like Babel are still necessary. The standard is officially accepted, but browser support is still a concern. Only a few prerelease browser versions actually support all of the standard natively. Angular alienated most of its users by initially announcing what appeared to be a massively un-forward-compatible version for version 2. They have since announced a conversion plan but people are still miffed. Also, the format of Angular 2 looks highly exotic and people don't really like it. Ultimately, they are still trying to put stringly defined js behavior into html, rather than putting html into js where the full power of programming can be leveraged. React's architecture ideal, one-way binding, instead of two-way binding, is now considered almost always better. Angular 2, Ember, and React all encourage this form. One way binding reduces the need for highly structured MVC systems in favor of simplier data stores that are updated in various ways. Just as functional programming styles were becomming more popular in 2013-2014, the immutable style of data management has been increasingly popular for its performance benefits, particularly in React. A lot of the build tools have churned, with the growing idea of "no defaults." If you want to use build tools, be prepared to specify everything. Babel is considered almost a must have these days. Webpack appears to be replacing Browserify. A huge problem with dependences occurred when an upset programmer unpublished a bunch of his npm modules. As a result, thousands of projects that had been using one of his low level modules suddenly were unable to be built correctly, for a period of a few hours. This revealed a malicious package naming security vulnerability, and also started discussions about flattening delendencies or other ways to prevent this problem again. We'res till working on a good solution.
I understand the reference. I'm just saying for SEO purposes it might be advantageous to pick something more unique. 
and typescript is getting a lot more attention, because types. (either via tsc or flow-&gt;babel) and ms seems a little less evil these days with visual studio code 
I've always done one top-level describe per file corresponding to a particular component / code file. 
Yep. I would love to hear how this was ever sold to the business, especially at a startup. &gt; We want to spend our limited funds and time building yet another node framework because...we can?
* Angular fucked up and people are jumping ship to React * React made immutable datastructures and unidirectional data flow cool again * Webpack is the shit, but hard to figure out, but people are figuring it out anyways * Chrome is still the best * Google is trumpeting progressive web apps ( web apps that can operate very functionally offline on many platforms ) * Material Design is still cool amidst a plethory of shitty UI libraries * IE kinda sorta has redeemed itself with some cool support for features in latest Edge browser * There's alot of emphasis on building with components * NodeJS is getting more es6 features That's the highlight reel from my perspective. 
"a lie told often enough becomes the truth"
I'm thinking I don't have time to even look at yet another framework. But good luck anyway.
&gt;they are still trying to put stringly defined js behavior into html, rather than putting html into js where the full power of programming can be leveraged. This is said from a React perspective, and is not indicative of any best practice outside the React world. HTML inside javascript is still considered a bad practice by a significant segment of front-end developers. React is one way, but not necessarily the best way to do things.
Point taken. They are fundamentally different for sure. This post is more about opening a dialogue for the 1000s of devs who are facing this type of decision in production apps and want/need the performance improvements and like the clarity of a more "flux" like architecture. To me, if you look at what has happened over the last couple of releases of 1.x they are in fact giving you some tools to help the migration, but it is not going to be easy. Breaking with exclusive two-way data binding is a good example. One-way data binding if you plan to move to a more "flux" style architecture is a key aspect: https://toddmotto.com/one-way-data-binding-in-angular-1-5/ The other significant thing I see is moving towards components in preparation for Angular 2: https://docs.angularjs.org/guide/component When I look at the the component spec it makes me wonder why I just wouldn't move towards React which is stable and ready to go. I am honestly looking for other perspectives, but, really, these components with life cycles methods, a controller, and a template look pretty much like React components. Templates become JSX in React, but really not much different conceptually. 
You don't have to be a react fanboy to want more programming features when writing templates. I think that people who think HTML in JavaScript is bad would also think vue / angular / asp / php templates have too much JavaScript in HTML.
So cool! Love the globe effect on hover. &lt;3
Observables !== Object.observe
Aren't this all easily achieved via Webpack?
https://www.google.dk/trends/explore#q=%2Fm%2F0j45p7w%2C%20%2Fm%2F012l1vxv&amp;cmpt=q&amp;tz=Etc%2FGMT-2
Here is a list of them: http://www.conwaylife.com/wiki/Category:Oscillators I wrote a simple parser for the Life 1.06 files that are provided on the wiki: https://github.com/tofuness/eex/blob/master/life/parse.js
Thanks &lt;33
They give with one hand and take away with the other.
there's so little learning invovled. you write code and aurelia is like "yea that's what I was thinking!"
For legacy reasons only I'd have thought. Angular 1.x has the propensity to create the most insane code architectures I've ever seen in the front end space, at least in all but the most disciplined of hands.
&gt; Only a few prerelease browser versions actually support all of the standard natively. If you're looking for 100% perfect coverage, you are correct (only unstable JSC releases have full coverage) but [release versions of FF and Chrome](https://kangax.github.io/compat-table/es6/) have coverage for everything you're likely to be using from Babel. I expect to see a "no babel in development" movement starting up in the near future.
I've worked at several companies of varying size that use Angular 1.x and each one has been quite easy to pick up. Those companies aren't jumping to 2.0 and will likely stay with 1.x for quite some time.. probably many more years because the code bases are large and aren't crumbling at all. Angular 1.x has made it easy for developers to move from job to job and start contributing quickly because the architectures are well defined and easy to understand once you understand how Angular 1.x works. The common thing between all these companies is that they follow John Papa's Angular Style Guide https://github.com/johnpapa/angular-styleguide . This makes it easy to transfer knowledge from job to job, something that can't really be said about react. Angular 1.x is going to be around for many more years, it isn't going anywhere.
&gt; IE kinda sorta has redeemed itself with some cool support for features in latest Edge browser ...and Safari is the new IE... 
Really? I'm an Angular 1 dev and I want it to die in a fire. :)
That's why I used the phrase "all of the standard". One of the most important feature of ES6, proper tail calls, is still barely supported by anything, and it can't be polyfilled. Babel will not go away because Babel is not about ES6, it's about transpiling future versions of JS into lower versions. ES6 is standard and almost finished in the most modern of browsers, but ES7 (ES2017) is already being developed. ES2018 will come after that. Babel will continue to provide this transpilation service. Instead, what we may see is to default the compiled version down to ES6 instead of ES5.
It is correct that this is said from a React perspective. Angular puts kinda-sorta JS in HTML (bad practice for separation of concerns), and React puts HTML rendering inside JS (kinda sorta bad practice for separation of concerns). It's a subtle point, but either way, when HTML is controlled by JS, any possible HTML structure can be rendered. When HTML is controlled by templates, there are significant structures that cannot be accurately represented (such as arbitrary component boundaries for table-related tags).
Serializing works with default JSON.stringify. Just implement toJSON. 
Where can we read more about the finalized web component spec? I thought I keep up pretty well with the JS news but the last time I looked into it people were still saying that this was years out (and it wasn't years ago that I last looked into it ;-) I just did a search for "web component" on Reddit and I'm not seeing any news from the last year. 
why all the downvotes people? web != javascript. Also, css != javascript.
It's not just a React perspective. There's an entire functional front-end movement filled with similar smaller time frameworks &amp; libraries all going this way.
Genuinely curious - why?
No idea why you're post is marked down. Good info. Thanks.
Another use case is loading Web Component polyfills, which you have to load at the very beginning if they aren't supported natively.
I tried it, it's really neat to skip the compilation step. I used system.js to get commonjs support, so I didn't really need a build step at all. Just save the file, let browsersync refresh immediately and boom, everything just works!
nope, I just use the typescript compiler tsc, it converts all my ts files to js files, but I have used flow with babel experimentally. https://www.typescriptlang.org/
I like this article. It makes total sense without getting overzealous.
And by the same token, most of the time, the html rendered in React components doesn't put arbitrary JS code in the middle of it's rendered output. If you are going to argue from the "well, yeah you can do bad things, but just don't be a bad developer and it will be good", you can say that about everything. Regardless, js controlled rendering is unavoidably more powerful, and yes, I have had significant and painful problems due to the limitations of templates that are trivially solved with js. I've been an Angular dev longer than a React dev. I know how it works. It still makes life hard once you start doing things beyond small forms and demos.
Be careful about your end size. I have two builds, one for easy and quick dev and debug, the other is highly compressed, optimized, and cache busting for best possible production performance.
You just wrote me a *things to learn* list, and I didn't leave Javascript for a year and a half Thanks
I like this recently published video on comparison of 6 JS frameworks by the lead of the Aurelia team. He is obviously biased and perhaps sometimes misinformed (when he speaks on React licence issues, and when he says that Google itself doesn't use Angular, although parts of Youtube are written in it), but still he makes valid points. https://www.youtube.com/watch?v=PrNYL42x85o
Not op, but angular 1 dev working with angular 2 now, I don't have a solid answer, but it feels wrong. Especially when you try react in between. 
Two reasons: 1. A significant amount of our codebase is forever locked (until the next full rewrite) to Angular 1.2 release candidate 3. This was the last RC before 1.2.0, and yet, I have tried and failed to upgrade because of significant and subtle bugs and behavior differences between the two. Further attempts to upgrade to 1.3 failed. Without a rewrite, it's virtually impossible to upgrade angular apps in my experience. Now, don't worry, because Angular 2 is just really great! You should use it! Even though it's completely incompatible with my slightly older codebase. I don't trust the angular team to make future upgrades smooth because past ones were train wrecks. By contrast, React's api has always had a much smaller surface area, and the abstractions they define are more clean (there are no scopes and transclusions, there are just plain functions, parameters, and closures). As such, the very few breaking changes in React's versions have been mostly limited to direct dom manipulations and startup code, each easily found and replaced, each with good warnings provided at least one version before, and none of the very subtle, implicit changes to under-the-hood behavior. 2. While I get that the weird bracket notations and such for new attributes in Angular 2 are technically valid, they don't even try to resemble a regular webpage. For jamming js calls and for loops into html, they sure do make it ugly and hard to type. And for what purpose? So "you will know a angular attribute from this other attribute"? Except, no, I won't because the weird syntax is technically valid html5, so I can break things by putting the wrong text string in my html attributes. In React, where the rendered output and the coded behavior are well-separated, I get a js runtime error if I do something wrong. In angular, you have to rely on angular's parsing and evaluation of js and its own added syntax, and it may just silently eat errors or do the unexpected.
I have some React experience. As others have said it is a different idea. React is basically view only. Having said that, there is a lot of React-ness in Aurelia, the big one that is missing is JSX. Good news though, in theory you should be able to plug React in as your rendering engine. I don't know how much you gain in all honesty though as the rendering engine in Aurelia is as fast or faster than React. They ran the same DB Monster test that wowed everyone when React was released and actually beat React's performance by ~15-20% IIRC. The best part of Aurelia to me is that it is pure ES6/7 and uses polyfills for now. Once adoption of ES6/7 features becomes more wide spread they can shrink the size of the framework which in theory should also help performance. Also the whole mentality to use/build towards standards is great as well. There is very little "framework code" so to speak.
I fully get 1 for people with a large existing codebase, but that's mostly just an argument against moving to *anything*. If they'd tried to simply tweak Angular 1 to make it a bit more modern, they would have almost certainly produced a Frankenstein mess. I'm not an expert on Angular 1, but I get the impression that it had far too many issues to be successfully built on. For 2, I find it very easy to read. There's a tiny handful of concepts to learn and then you're good to go. I've not tried React, so I'll have to take a look at that, but compared to my brief experience of Angular 1, it's a breeze.
For 1. we had a very large app that I single handedly moved from angular 1.2.x to 1.5.7 recently in less than a week. I'm surprised that you are having so many problems(I believe you that you are having legit issues, I'm just surprised). Most of 2. I think is a problem with angularjs as well as angular so I don't think it is really a valid reason not to use angular 2.
&gt; React made immutable datastructures and unidirectional data flow cool again hyped again. I am not sure they are that cool especially when redux app gets large and every dispatch churns through hundreds of reducers.
Another real usage (a rather dirty one, but still real) is to add unremovable ads, like the ones in those shady sites. You add your ad (hehe), and a Mutation Observer so that if an ad blocker or something removes your ad, you just add it again.
Everybody now completely agrees about libraries &amp; standards and we all write clear, understandable, interchangeable code that never needs refactoring. Also, unicorns.
$25 = 15mins of my time. This is easily a days project.
I'm glad it wasn't a problem for you. Given enough time, I'm sure I could upgrade too, but we do not have the time budget for that. It "works", so there is little business incentive to upgrade. However, even if I were to do the upgrade, it would involve changes to behavior or core systems. It would not be as simple as "change this function to this function," as it has been in React so far. You don't find stringly-defined, non-standard code in your html even slightly disturbing? Do you also use eval in your js?
How long will it take you to make just 1 product tracker for a specific item? Let's talk business
I find it is not WHAT is going on is the question, but WHY? Why? Why are we doing this insane thing...? Sometimes it is hardware compatibility and I'll include the bits or conversion tables of craziness required to make everything work. Or is there some insane edge case that brought the system to its knees 5 years ago. Yeah, I can see you are checking some bit somewhere and then executing some procedure somewhere...why? Or is there some 1960's regulation we are having to comply with that makes no sense, but has to be done regardless...?
Is there anybody you can refer me to, who can help me with this project?
Good stuff thanks. Been trying to decide what is framework to start learning. I know he's biased but he's also extremely qualified to back up his opinions. Gonna give Aurelia a try
All of javascript is awful from my point of view, so it doesn't really bother me what flavor of awful i'm using at the moment.
React and redux developer tools, basically. 
Angular isn't really cool (personally i'd wait till the next version before breaking out the champagne) and MVC is just a model, there's also MVVM for exmaple. As for ES6 yea i would say it's standard. Not in terms of browsers, that's still a ways off but the fact that nodeV6 is over 90% compatible with ES6 and you can transpile to ES5 means there's not real excuse not to be using it if you have a build process within your project(s). What to look for? I'd say keep an eye out for webassembly. Nothing more then a rumor at the moment but the gist is compiling web assets down to bytecode for better compression and execution.
Comments are still required some situations, especially when they "why" of it can't be explained in a few words. 
Yeah, it's this kind of WHY stuff that I find myself writing comments for most often. Your code can't self document this type of logic/process I don't think. Even if the code is easy to understand, if it's doing something out of the ordinary, document why it had to be that way.
no way pal. People try to make things more complicated than what it actually is.
It can be really different at first glance, but the biggest change is tooling, which back in the days there was none. And it looks awkward if you never transpiled code, but it's how front-end dev evolved since browsers' limitations dictated how much you could do and how. If you got back to js from this long and find too much to deal with (babel, webpack, react, flux, angular/angular2, ember etc) remember that what we did back then still works today, at least most of it, just drop some script tags and only go to tooling when in need.
Holy shit that was the worst for my ADHD riddled brain. 
upwork.com
Hmm well the deferred promise is a private variable inside the class, the class returns this as part of the `start` method and it is resolved in the `end` method. A bunch of stuff happens in between start and end. The way I am doing it now, it makes it trivial to chain from the start method and then have the subsequent code run at the right point in the `then`. One way I've seen people do it is like this return new Promise(function (resolve, reject) { end = resolve }); I haven't tried this out yet but I can see how it might work. 
its like the whole python 2 vs python 3
Yup. arr.slice() works for for non-mutation. I personally prefer Object.assign() Mutation: var pubObj = {} function sameObjTest(obj){ const newObj = obj console.log(newObj === pubObj) // true } sameObjTest(pubObj) Non-mutation: var pubObj = {} function sameObjTest(obj){ const newObj = Object.assign({}, obj) console.log(newObj === pubObj) // false } sameObjTest(pubObj)
God. My eyes bleeded Backbone. It wasnt worth two cents without Marionette to automate all the shit you didnt want to do. Never again. 
It was very good at making websites look like complete crap. 
"Back in my days we used Netscape... and we liked it!"
Really? Well ok then. I always choose the lesser of two evils if given the choice. Refusing to make a choice means I have no control over what happens.
Ah i see. An animation queue is definitely on the "more complex" side of what I originally described of a pattern that could be handled by Promise/Deferred. But since it is for backwards compatibility, it is probably not worthwhile to refactor beyond the original API anyway. 
You can get react dev tools for Firefox, and you can embed the redux debugger right in your page 
Hoooo boy. That's a big argument. I don't really want to get into it. Let's just say that whether you agree or disagree, there are a couple of arguments, not all of them good, but I will provide them anyway. I will not be debating the these arguments beyond stating them here. Resistance to Type Systems: 1. They represent a limitation on the programmer for how generic their code can be. 2. Types, even in programming languages that support them natively, are not actually there. They are just compile-time checks. Many of the benefits of compile time checks can be had without strong types with the correct tooling and a defined API (see Flow). 3. Types could, in theory, be used to provide high-level protections, such as preventing programmers from accidentally adding a floating point temperature value to a floating point weight value, because temperature and weight are not addable in a meaningful way. However, most type usage by programmers is for: A. building structs/objects (groupings of things with a name), and B. enforcing that a string is a string, an int is an int, etc. For A, this can be accomplished more quickly and as needed using object literals inline. For B, loosely typed languages will try to work with the bad input and produce a bad output. Strongly typed languages will fail at compile time, except when they don't because you used a void pointer or any other number of ways strongly typed languages provide around their own rules. 4. Some programmers simply don't make the kinds of errors that type systems were designed to prevent. For them, types represent purely boilerplate code that adds no benefit, but leads to analysis paralysis (Should I divide up my types this way? Should this inherit from that type?) As team size grows, the enforced rules help more, but only if other programmers make those types of errors. Either way, if you control the API type barrier, the internal type structure of loosely typed programs is often obvious or tool-predictable. Resistance to Class-based Structures: 1. In JS, it is just sugar. It doesn't provide any additional meaning, at least for now. 2. No private variables. Private variables in JS can only be produced with closures. 3. Questionable performance claims. In JS, while class-based/prototype object construction is usually faster at runtime with lots of objects than a similar closure-based solution, it is nowhere near as fast as literal object creation and pure functions. And don't get me started on using Emscripten to compile low-level C code into ASM.js. 4. Class-based structures encourage inheritance. While it is true that one can use classes without using inheritance, in all the articles and books I've read in my entire life, using languages from C++ to JS and everything in-between, when reading about the benefits of Object-Oriented Programming, the primary (often ONLY) stated benefit is the ability to use inheritance. Inheritance, in programming, is almost always the wrong solution to a given problem. The Gang of Four, who literally wrote the book on design patterns, state: "prefer composition over inheritance." Inheritance creates known structural problems and inhibits future refactoring efforts because it assumes both that the program's structure is fundamentally hierarchical, and that it is unlikely to change in the future. Neither of these is usually true. Finally, I am unaware of any structure inheritance can create that composition cannot.
Examples or it didn't happen.
Agreed. The particular approach being described seems a bit quirky to me (I love React, but the idea of using it _inside_ of a Web Component seems sort of the wrong way around), but the content itself is perfectly reasonable and informative.
Don't forget to mention Electron, http://electron.atom.io - cross-platform desktop apps with JS / HTML / CSS
Now that job is taken care of by flash and we use js for things that flash did (building user-friendly interfaces).
Angular 1 works great with es6 
Yep, 100%. People misuse the downvote button so much, it's not an "I disagree with this" button, instead people should give constructive feedback in comments.
I don't know man, IMHO the standard Promises are flawed without a `.done` statement. Without it, any error prior to finishing the promise will fail silently or trigger the `onReject` callback. It's a real headscratcher when debugging, since a code error down the line could make your promise to silently fail.
Yeah and forget about Sublime, now Atom is all the rage.
I'm going to have to take a look at React, but "strictly better" seems a very bold statement. My impression (and I could be wrong, it's only what I read), is that React is largely a library for handling page rendering, whereas Angular is a complete framework for client-side development. By being minimal, React seems to give developers a lot of choices about how to implement much of their app. Angular 2 looks to be much more opinionated about how things should be built. To me, there's fairly clear pros and cons of both choices - it's great having, and being expected to have, loads of flexibility but all of those choices take time. And it's fairly likely that in most cases, the designers of a framework like Angular are in a better position to make those choices than my developers are. My point isn't that Angular is better - I've not used React, so I don't know. But statements about the objective superiority of one over the other, particularly as they tackling slightly different problems, don't seem to align with the rather more nuanced position I've seen elsewhere.
You're correct, of course, I should have referred to React + Redux (+React Router). And I sympathise with your wariness of claims of strictly better, but honestly I think if you give both of them a genuine attempt to learn then I think it will become clear!
&gt; While it is true that one can use classes without using inheritance, in all the articles and books I've read in my entire life, using languages from C++ to JS and everything in-between, when reading about the benefits of Object-Oriented Programming, the primary (often ONLY) stated benefit is the ability to use inheritance. I'm not a fan of throwing the baby out with the bathwater, and I don't really like arguments based around the word "encourages". But I do see where you are coming from and there does appear to be something wrong with how OOP is taught and how people apply it. The core ideas of encapsulation and using inheritance to describe related classes of entities, are good where 'good' in this sense means that they are often very useful. These ideas describe how objects should appear from the outside. They talk about the APIs which we expose with our objects to the systems which use them. But the teaching of OOP tends to be quite light on saying much about how we should implement the insides of our objects. Sure, you can subclass something and override its methods as needed, but beyond that it is implied that you should just slap some procedural programming in there to fill up the rest of the space. And this is where things seem to go wrong. This is where things go off the rails and you get implementations of classes which depend on each other's insides and are all intertwined and tangled. We get inheritance being used to share implementation code. Instead we could view the OOP hierarchy as being separate (or more separate) from the implementation and make more of an effort to choose a better approach for the implementation code, be it a functional approach or an internal set of objects/classes etc etc which can be shared behind the scenes with other class implementations. 
Not talking about the code, but functionality: * Add a few dots in the bottom middle so the user can see how many images there are and which image they are viewing. They could also click a dot to change to that slide. * Allow clicking and dragging, so user can "swipe left" with your mouse (and finger on phone). See the slider here, this is what I'm referring to: http://www.jssor.com/
Wow that's even before jquery I guess?