Thank you for the links.
Possibly, FF must be able to catch infinite loops then. Try it and see! 
Thank you for clearing it up; the diversity of web development never ceases to amaze me. It seems very fragmented, which creates substantial overhead for web developers. A somewhat related question - why is the browser space not standardized? It seems every organization is has their version and each does something a bit different. Is it OS/hardware related or is it simply a case of branding and marketing? I'm not sure I understand what is gained by having IE/Chrome/Firefox/Opera/Safari and all their different versions and iterations (IE7-11, Chrome dev/canary, etc.)
`whilte`
You started a written explanation with "So". You are the most smug, self-satisfied holier-than-thou Americunt WASP cumdumpster I have ever had the displeasure of witnessing.
They're not catching infinite loops. They're just keeping track of the stack with a timer running. Detecting an infinite loop would mean they had solved the [Halting problem](http://en.wikipedia.org/wiki/Halting_problem) - safe to say that didn't happen. 
Maybe it just depends on what's my goal: to code things in a more modular fashion. In this case, both Polymer and React work towards the same goal of mine.
 whilst(true){ hark("thine computation device will self destroy"); }
Thats weird. Installing Node is pretty straightforward with aptget. Are you using Digiral Ocean?
&gt; Detecting an infinite loop would mean they had solved the Halting problem It doesn't. You only have to check how long it takes until the script returns the flow back to the UI thread. If it exceeds 5-10 seconds, ask the user if they want to kill it. All current browsers do this.
That is only if you analyze it, not when you run it.
I think we've made some really important progress here today.
I think you have the general idea down, but there are a few things I wanted to note: &gt; Without the closure in the above example, the this variable in the button.onclick function would be the button object and not the counter object with the increment function. `this` in onclick is still the button object. Nothing changed what `this` represents. I suspect originally you used `this.increment();`and changed the `this` reference to `closure` which got you what you wanted. And that's fine, just as you know what `this` is. That's not to say you can't change `this`. That's another alternative (one I personally tend to favor over inheriting local variables created in the parent scope). &gt; A closure is the combination of a private variable outside a function that is accessed within the function. It's a little awkward to say that and then create a variable called `closure` which itself is not a closure. ;) Also, if you haven't already figured this out, all javascript functions are closures; they all have access to parent scopes and the variables defined there. Note that these variables don't necessarily have to be "private". Anything *out there* is accessible *in there*, with the exceptions of shadowing and the such.
 Its pretty easy to attach "refs" to elements then simply using jquery in the react events with the real DOM nodes. I have not done it extensively but it should work.
Catches yes. Detects no.
&gt; Detecting an infinite loop would mean they had solved the Halting problem Detecting *all* infinite loops would mean they had solved the Halting problem. Detecting *some* infinite loops isn't difficult at all.
You can't determine it at runtime either. Example (writing code on a phone is painful, so bear with me for a textual description): Take an algorithm that does arbitrary division, and prints each digit. Exit, if and only if you start seeing repeated decimal (sequences). If the number is rational, the program will eventually exit. However, if the number is irrational (such as pi), it won't ever exit. You cannot determine at runtime determine whether this program will exit or not. (Or by analysis, for that matter). 
My advice is to skip jQuery. The main issues are for plugins mutating the DOM.
It is hard to imagine how an algorithm could determine when it was seeing repeated decimal sequences, anyway.
Yea, its possible to detect some special cases, but doing so would be counterproductive - it's more than enough to detect that executing a particular piece of code is taking too long. 
yea that worked back in 1998
[Here](https://m.youtube.com/watch?v=FxHYktIBp_4) is a video that should explain how to do it on paper. Doing it in code is possible, but eventual inconvenient, because you need to store and exhaustively search those past results for each digit you compute. 
It means quickly in Swedish 
Yes, I thought about the name for the closure variable. I was thinking of calling it `closureSelf` according to the naming convention closureName. But since it was just one closure variable I simply called it `closure`. I have seen the name `that` used by others. Yes, the `this` variable will still be the button in this case. You mean that the `this` can be changed from a button call like that? Surely it's not possible to use apply() or call() in this case, or?
I feel bad for your employer.
Hmmm? You can prove in for(;;) that the loop invariant is always true. There is no possible way that it can change states. Then some induction. Now a parser can detect that this program will not halt because it has this statement.
Truly a breakthrough in computer science.
Hi, thanks so much for your help. I have a quick question: if I have want to make the bullets rotate in the correct direction while shooting out of the ship, how would I go about doing that? For example: https://jsfiddle.net/studentlearning110/c2quhdad/4/
Are you going to delete it this time too? Thought you might be going to post into /r/learnjavascript instead. Here's how I did it. Note your problem is partially caused by repeated IDs when they should be unique. Those were converted to classes. http://jsfiddle.net/malwinsc/5u5oeqqb/
I'm not really sure why you're being downvoted so hard. I feel exactly the same about Angular. I could imagine React would be the same, according to what you write. Like it or not but it's a matter of fact that a vast majority of new frameworks skip on jQuery and have no intention on bringing it back. And they have chosen to do so *on purpose*. The general interest in jQuery is steadily in decline while React and Angular are exploding. Once you get into it, it's easy to understand why. I know this might sound harsh but if you have a problem doing 95% of the usual jQuery plugin stuff with Angular, you've probably gotten too used to just hacking stuff together. This is understandable since JS used to be a bitch but with the newer frameworks, everything is much easier once you get into their paradigms. They will handle DOM manipulation and data binding for you which was one of the big reasons we needed jQuery ealier. For stuff such as tabs, conditional visibility, forms etc you hardly even have to program anything. An excel-like table with sorting, filtering etc. took me about half an hour. If you can't do this in Angular, I think you should go though some tutorials in both Angular/React and vanilla JS. It won't be many years until you'll be a legacy programmer otherwise. EDIT: see the top answer here for a more technical explanation: http://stackoverflow.com/questions/23585765/how-to-go-from-jquery-to-react-js
Chrome has a special url for crashing: `chrome://inducebrowsercrashforrealz`
This idea is cool. There are other videos where you watch people code BTW. And they all have one thing yours does not. Audio. Hearing how you think out loud is more valuable than your code. 
Webpack. It would be hard to live with hot module reload at this point. 
I'm not up on these sorts of tools, could you explain JSPM, Webpack, and Browserify (how they work, their advantages/disadvantages)?
Forgetting jQuery was our huge step towards a new level of web programming. I'm developing in javascript before even jQuery was born, coming myself from YUI and dojo: i'm sorry to disappoint all the jQuery fans, but jQuery to me never felt right. The huge ecosystem comes with a lot of bad written code. Unit testing is hard. Modularity is bad. Performance sucks. Our software was a pain to maintain and it was no fun working on it: sometimes my job was just to spot well written plugins, to find after a while they didn't fit our needs. Life is so much easier now that we adopted a more modular architecture (npm modules). Beside all the other benefits, React fixed the DOM events inconsistency between browsers. I honestly don't see any good reason for using jQuery in 2015.
[imgur.com/FQ5e1s3.jpg](http://i.imgur.com/FQ5e1s3.jpg)
Thank you! I'll start doing it then. Do you have some videos you like?
Hahahaha what! But seriously, though. I'm not a native english speaker, so what is all that about? "whilte" has a special meaning?
So I think you meant to write "holier-than-thou" there. 
I like to use mean.io
Not really. But I'd suggest you watch some to see what works and what doesn't. Then just make yours better than all the others :-)
Addressing your points: - You say shims aren't really required in webpack and then linked me to a webpack url that says "shimming modules". Their solution is to make everything global which is arguably less useful since you don't know exactly which file needed that shim in the first place. It still needs to shim. - What friction exists when using Bower and AMD? Or even NPM for that matter? Sure it doesn't do the module name resolution automatically, but that's because it loads dynamically in the browser without a build step. I suppose this one is preference and a large majority sides with you on it. I personally haven't had issues locating a file and requiring it, but hey I'm a hard worker! - I don't understand this point, we've been over this before with your last post too. You get the same problems regardless of optimizer if you screw things up. The consistency is the same across the board. If *you*, the developer, screw things up the system will not work. Some optimizers just make it easier to not shoot yourself in the foot. - You don't include a loader, and you also don't execute code exactly as you wrote it. You're sacrificing the loader for a build step. It's definitely a trade off. - AFAIK, nothing popular exists for hot module reloading in RequireJS. Something could be easily written to use file watching/web sockets and then wipe out and reload the module you want. It wouldn't be terribly complex, but if nobody has made it yet, probably means it's not in high demand. - If you mean client and Node, I'd agree. Maybe this should be the main point of your argument then. If this is a hard requirement, then RequireJS/AMD is probably not the best choice. (Although still totally doable and fairly easy depending on your structure). "JS was the only thing causing troubles, and it was because of RequireJS. Most of the problems were fixed by hacks." - I agree that for *you*, personally, RequireJS probably was the problem. I don't think it's a problem for everyone, and once you understand the pathing semantics it's quite easy to use.
add $(bullet).css('-webkit-transform', 'rotate(' + (angleDeg) + 'deg)'); somewhere
This title is misleading. I thought it was a chrome plugin that would replace the chrome console with something somehow more helpful... Instead it looks like a REPL that redirects me 4 times when I click the link. I'm sure it's cool, but can you explain a little of what you want us to use it for?
&gt; Their solution is to make everything global which is arguably less useful since you don't know exactly which file needed that shim in the first place. It still needs to shim. It does it automatically. You don't add it to a config. It's not global per se, it just recognize when $ is expected, and imports it for you. Although it sounds like a global and acts like a global, there's a small difference. "The module is required only if you use the variable. ". If you open the console and type $, it won't work, for example. &gt; What friction exists when using Bower and AMD? Or even NPM for that matter? Sure it doesn't do the module name resolution automatically, but that's because it loads dynamically in the browser without a build step. I suppose this one is preference and a large majority sides with you on it. You can argue it's preference. I argue it's efficiency. Sometimes packages changes directory layouts between versions. If you do it manually, it'll break on update... and yes, it happened to me while I was using requirejs. Does that count as friction? I suppose you could check the dirs every time you update a package... or you know, just use a loader that does it for you. &gt; I personally haven't had issues locating a file and requiring it, but hey I'm a hard worker! Cool for you, I value efficiency more than hard worker, but okay. &gt; I don't understand this point, we've been over this before with your last post too. You get the same problems regardless of optimizer if you screw things up. The consistency is the same across the board. If you, the developer, screw things up the system will not work. Some optimizers just make it easier to not shoot yourself in the foot. When a system has too many points of failure, maybe it's time to call it a bad system. There's clearly no advantage of using RequireJS optimizers. If you could tell me an advantage of it so that there would be a trade off.. I'd understand. But there's no tradeoff. It's not as good, not as flexible, and easier to shoot yourself in the foot. What's the point? Please, let me know. When will you acknowledge that it's flawed? If R.js was simple to use, then I'd agree... but it's not even simple to use! &gt; You don't include a loader, and you also don't execute code exactly as you wrote it. You're sacrificing the loader for a build step. It's definitely a trade off. You need a build step anyways for optimizing requirejs. What's the advantage of requirejs then? Nothing. Build step AND requiring a loader. It's really like R.js optimizer was an afterthought. RequireJS is a pipe dream. Loading multiple small modules asynchronously absolutely sucks when introducing latency. You need to optimize. &gt; If you mean client and Node, I'd agree. I'm glad we agree on something. &gt; I don't think it's a problem for everyone, and once you understand the pathing semantics it's quite easy to use. It's easy to use, but not easy to serve. Hopefully this article will show that requirejs is not made to fit big complicated projects, and that the next me will stumble upon it before committing to use it. I'm showing the lessons I've learned with it, and I simply want to share it. When I started Player and did research for loaders, all I heard was good thing about Require JS. It's what made me choose it in the first place... and I hated it. I couldn't understand why people spoke so highly of something inefficient. Good thing alternatives came out later. 
&gt; The requireJS philosophy of asynchronously requiring modules is very flawed. It leads to longer load time. The requirejs philosophy is also one of letting you pack things that should be packed together. http://www.requirejs.org/docs/optimization.html In other words, you can develop quickly, but you'll still want to build before deploying. But then I saw this: &gt; I still occasionally forgot to add shims config, making it look fine in development but broken in production And I realize you are going from dev straight to production without actually testing anything. And then this: &gt; Load times somehow suffered.. Looking at the waterfall, scripts aren’t downloading all at once, the browser was downloading require.js… then parsing it, then downloading common.js, then parsing it… then downloaded main.js, then parsed it. As my common.js grew, this started to become noticeable. Yes. This is how it works. It is known. Which is why they have a way to optimize all of this. Webpack might be great, but I can't help but think the problems weren't related to requirejs.
I run into your same issues some years ago, when I was working with dojo (which also uses AMD). The main reason was the missing AMD support for many js modules (I guess today is better). So I ended with webpack, supporting both AMD and CommonJS. I'm very happy with it - the hot module replacement is a must have.
&gt; define(function(require) { &gt; var Moment = require('vendor/moment/moment'); .... &gt; return SomeDummyClass; &gt; }); actually it should be &gt; define('path/to/momentjs', function(Moment) { &gt; //use Moment here &gt; return someDummyClass &gt; }); Require is usually use ONCE for a single page application. Yes I know the difference you lose all the async loading of stuff, but you dont need it. Define everything require it once. 
 var button = document.createElement("kill-result-target"), action = function () { this.parentNode.parentNode.removeChild(this.parentNode); }; button.onclick = action; I should point out though that your HTML is flawed. The id attribute values should be unique.
Sure, I don't mean to diminish the jQuery role in web development, yet the last years the javascript world changed a lot. Also IMHO its popularity doesn't make justice to other tools like dojo and YUI, which were really innovative at those times.
In that case, what does this offer over, say, JSBin besides the remote debugging? (In case anybody was wondering, the instructions are on the [site root](http://howjs.com/), and remote debugging is covered [here](http://howjs.com/remote-debugging.html)) 
Thank you so much! That clears up a lot of things. I do have some further questions on some of the stuff you said, if that's okay. I get that the argument to Reflux.connect indicates which state property to update, but is it possible to do the opposite? I.e. just listen for changes to a particular key of the *store's* data? For example pretend I added a 'title' to the to-do list which was also stored in the TodoStore, how would I tell the TodoList component to just use the 'list' property and not the 'title'? What would you do in that situation? Also in terms of the Flux philosophy, say I introduced a search field that filtered the TodoItems, should that search term be contained within a store, or should it be a view state property only? If it was, it would mean `.filter()`ing the array in the view, which seems like too much logic. But filtering it in the store seems wrong as well because the actual data isn't changing, just what is displayed. 
I accept this answer.
[**@malyw**](https://twitter.com/malyw/) &gt; [2015-03-15 18:30 UTC](https://twitter.com/malyw/status/577175169359282176) &gt; Crashing Safari with one line of \#JavaScript: \&gt; document.body.style.setProperty('-webkit-alt', 'initial'); \&gt; \#webdev \#js [[Attached pic]](http://pbs.twimg.com/tweet_video_thumb/CAKJwdbWYAAZeom.png) [[Imgur rehost]](http://i.imgur.com/njcsrGL.png) ---- [**@malyw**](https://twitter.com/malyw/) &gt; [2015-03-15 20:02 UTC](https://twitter.com/malyw/status/577198313994379264) &gt; Crashing Chrome by opening URL: \&gt; about:inducebrowsercrashforrealz \&gt; http://en.wikipedia.org/wiki/About_URI_scheme \&gt; \#chrome \#webdev [[Attached pic]](http://pbs.twimg.com/tweet_video_thumb/CAKezptWsAESC-L.png) [[Imgur rehost]](http://i.imgur.com/rjytxG0.png) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Open up the browser console, and work with the DOM, basically in realtime. On _any_ website, not necessarily the one you built yourself! JS is the only language to communicate with a Browser at runtime. No compiled-to-js language keeps up with this enormously helpful feature. Think of debugging: set a breakpoint (or use the debugger; statement) and copy-paste relevant code from your source to the console input and observe what happens. Can't do this when your source isn't javascript. Neither when you don't speak javascript at all but, let's say go, dart or whatever only.
(this is the second reply, I didn't read the other one and replied, reread your posts and realized it didn't make sense, so I deleted it) Your syntax doesn't make sense. http://requirejs.org/docs/api.html#modulename I think you meant define(['path/to/momentjs'], function(Moment) { //use Moment here return someDummyClass }); This is called the alternative syntax, which is really stupid because if you have 20 reqs, it winds up looking like this define([ 'req1', 'req2', 'req3', 'req4', 'req5', 'req6', ], function(req1, req2, req3, req4, req5, req6) { }) A normal entry in my app has an average of 15~ requires. That would be very silly to use this syntax. 
Thank you so much for your help. I spent over 10+ hours this week trying to get the bullets moving correctly in the right direction, and almost gave up trying entirely. With your help, I can finally move on to other things for my game. Thank you again!
Does JSPM have something like transforms being specified in package.json on a per module basis? This is one really annoying thing missing from webpack and that keeps me using browserify. That and the fact that you can't have a bundle you can load at runtime. I'm assuming the lack of a build step being necessary means it can load modules at run time
Yes, but so is converting an ordinary, untrusted string, into a template string. If it contains expressions, those expressions have arbitrary authority to execute code under the (commonplace) JavaScript model. I guess what I’m trying to say is that `eval` is no more terrible than a feature that converts a string into a template string literal.
I see, thank you!
Why do you have to make this about rce?
Ok so as I understand I think the question should be: "Why are people using JavaScript over Elm?" I imagine its difficult to use other js libraries when developing with Elm. Can I use lodash, moment.js, numeral.js etc., or do I basically have to rewrite everything from scratch? I will have to write a simple app to truly understand it more.
Huh, you say after optimizing? It builds into a single script that is parsed and evaluated at the same time, there is no waterfall, unless you intentionally exclude files. Can you expand on that?
You made me break my record of no longer logging in just to down vote one comment. Blast. 
You made me break my record of no longer logging in just to down vote one comment. Blast. 
No, that's incorrect. Template strings are just interpolated variables- not executed code. For example: var somevariable = '; console.log("test");'; eval(somevariable); // test `Template string ${somevariable}` // "Template string ; console.log("test");"
Can someone ELI5 what polyfills are and what they are for?
No, I totally agree with that point. The library ecosystem is milleniums behind JS. Btw: everything lodash/numeral/etc has to offer, Elm has much, much better (lodash is inspirated on Haskell's prelude, which was more-or-less copied by Elm). But I see your point for things like widgets &amp; cia.
That's neat. One problem unfortunately is that IE9 or later is needed for bind(): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Browser_compatibility
So unless I missed it, you left all of that out of the post. You literally talk about moving from dev and not finding out until production and now you are saying you have a staging environment. Maybe you should go back and clean up what you wrote because what I responded to was what you wrote, and what you wrote is apparently not accurate.
A polyfill is like a stand-in replacement for a feature that hasn't yet been implemented in a particular browser. For example, [promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) are a really useful new feature that has recently been added to JavaScript. While some new browsers may support them, not all do, and certainly older browsers that came out before promises exists don't. A polyfill creates the functionality for that feature so that it can be used in those browsers that don't support it natively.
90% of jQuery plugins shouldn't be jQuery plugins at all. Some of them should be jQueryUI plugins if anything, but most of them should be small libs that depend on jQuery if absolutely necessary. jQuery is a cross browser wrapper around several JavaScript APIs with convenience functions and its plugin system has been abused for image sliders and all sorts of things that absolutely do not belong in jQuery's namespace. The second you free yourself from shoddy jQuery plugins you'll become a better developer.
Sure. &lt;https://d1zqrvc06emslq.cloudfront.net/media/originals/feedpost/6c/38/b6/6e8bb1b02dacc2ee3a5de81985ea4520.jpg&gt; Relevant files for RequireJS: - require.js - common.js - feed-v2.js Relevant files for Webpack: - common.js - commonAuth.js - feed.js The rest are external stuff. I do the multiple entry + common file pattern. Even after optimizing, you still need requirejs. It simply doesn't download all the files at the same time. When you build it as a single file, you have the possibility to use [almond](https://github.com/jrburke/almond).. but I can't use that if I split them up. 
If you're getting a waterfall load pattern after running the requirejs optimizer your setup is not correct. The requirejs optimizer will concatenate and (optionally) minify all of your dependencies. We have an AngularJs application setup using requirejs and all of the JavaScript and template html are bundled into a single 300kb download (850kb without gzip support, 1.6MB without that and minificatiom).
Serious question: What is rce? Remote Code Execution? Reverse Code Engineering?
https://github.com/webpack/docs/wiki/shimming-modules Scroll down to `plugin ProvidePlugin`. This is my config new webpack.ProvidePlugin({ React: "react/addons", "window.React": "react/addons", Fluxxor: "fluxxor", $: "jquery", jQuery: "jquery", "windows.jQuery": "jquery" }) Every time a module calls a "free" `$` or `jQuery` or `window.jQuery`, it maps it to jQuery.. but if a script were to do `var $ = 'hello'`, it wouldn't overwrite it globally, it'll only overwrite it for this specific module. That's why I said it's not really "global", but it almost works like it's global. How it works, I imagine, is that the loader parses the code.. and check if that var has been initialized. If it hasn't been initialized, automatically add `var $ = require('jquery')` on top. 
&gt; If you used requirejs in the past, it's a little bit implied. I have, and no, it's not implied. Especially the way you are talking about it. &gt; Why would it be different if I wouldn't be compiling? What? Because then you are having to load each JS file from the server. Is that what you are really asking? What's the difference between downloading many files and only having to download one? &gt; I don't build locally because we have a CI, as soon as I push, it builds on the staging. After that step, I push to production. Well... you test on staging before you push? Right? &gt; My environments doesn't really matter, the relevant part was that compiled build !== dev build. This happens in all cases where you have a build process. This isn't unique to requirejs. I'm sorry, but what you wrote and what you are saying here don't mesh.
The whole reason why I chose RequireJS is because I was lured with this idea of not requiring a build step.. which is nice if it worked 100% the same built and not built. It's not the case. Dreams were shattered, precious time were wasted. &gt; You claim that you build anyways during production, so therefore you need a build step anyways, therefore why not build all the time. Because the Optimizer is wayyyy too slow. If I did this with r.js I'd have to wait 10 seconds every time I press save. Webpack-dev-server does incremental build in memory. The builds are &lt; 1s. The builds are also hot replaced in the browser so if I work with React, I don't even need a reload. &gt; There are definitely tradeoffs. I don't claim R.js is easy or intuitive, it's neither of those things, but it's not exactly bad. Absolutely not an afterthought, as it is an optimizer, just like Browserify and webpack. Hmm... What does it have to do so that you call it bad? Cause I really think it's bad. It's slower. It's less flexible. It's harder to setup. There's just no tradeoffs.. If I were to make a comparison charts between R.js and Webpack, all the points would be towards Webpack. What am I winning from using requirejs? Nothing... I'm actually losing since it's more convoluted. In my book, that's called bad.. or less good. When I was in the process of converting to webpack and I did it without modifying existing AMD modules, I was super surprised that webpack optimizer simply worked better and faster than R.js.. Think about this: Webpack is better and faster at optimizing AMD files than R.js, the tool where its sole purpose is to optimize AMD files. =|. 
Wow, you really didn't understand, let me re-explain everything. - When developing with RequireJS, the upside is that you don't need a build. Require.js fetches the dependencies, and it just kinda works. Awesome. - Obviously, using this method is not really good in production, because if you really modularize everything, you end up with hundreds of modules to fetch in the browser asynchronously... so... you build it by passing it trough r.js optimizer. - My problem is that the "before the build" and the "after the build" has **different behaviour**. Before the build, it might work perfectly. After the build, it might NOT work perfectly. You might have forgotten to include a shim config, for example.. THIS is my problem. The behaviour can be different. It might not have compiled the way you thought it would be compiled. If it worked in dev without build, it doesn't mean it'll work when it's built. &gt; Well... you test on staging before you push? Right? Yes, but my QA process has nothing to do with all this. I don't have to explain how I use docker/ansible/drone to automatically build a brand new staging per branch. &gt; This happens in all cases where you have a build process. This isn't unique to requirejs. Yes, it's pretty unique to RequireJS, because other loaders all have a build process. Browserify needs build. Webpack needs build. RequireJS is the only one that I know that doesn't have a build process and can be used "as-is" in the browser.. and it can explode in your face. 
Ohh man, You're using the single entry pattern. I'm using the multi entry pattern. It doesn't work the same. If my app had a total of 300kb gzipped, I'd do the same. Unfortunately, it's much bigger. 
pfff. you know what's faster than writing components? Using components already written by other people.
If you still have to download require.js after optimizing then you are building incorrectly. That or I am misunderstanding what you are doing. Are you leaving resources out of the build to be later downloaded? If so then yes you need to load require separately. If not you shouldn't have to load requirejs...for example, here is the [main docs website for footwork.js](http://latest-docs.footworkjs.com/) which is optimized with r.js: http://i.imgur.com/mN6nqDC.png
The spec is done. Only minor bugs are still being fixed. It will be ratified (officially become a standard) in June 2015.
Thanks for the clarification...I still think it is possible to use the pattern you are talking about and not need to load requirejs again. I think it is the manner in which you are initializing your application which is making require a necessity after it is all built. At least, there is nothing inherent in requirejs which would keep this from working.
No
but you need to keep it for safari. you need both
Because one of these things is a JavaScript library and the other is a new functional reactive language.
I agree. I've put off a lot of times from using it because of that.. until I found this: &lt;https://github.com/petehunt/webpack-howto&gt;
And if you do TDD and like to keep your stuff linted, you're going to need a build step anyway.
Did you file a bug report? Arbitrary DOS is a pretty good find. 
JSPM simple? Compared to Webpack? Aurealia has adopted JSPM/SystemJS. Here's their starter pack's config.js and package.json: https://github.com/aurelia/skeleton-navigation/blob/35d5885312c2ae6bc5f11a9e1f1a50446b37d978/config.js https://github.com/aurelia/skeleton-navigation/blob/35d5885312c2ae6bc5f11a9e1f1a50446b37d978/package.json#L48-L58 Seems like a metric shit ton of boilerplate to me.
I've never heard of jspm until this reddit comment, that has to mean something.
Yeah, and I don't really think scouring random articles on github or the web is the best way to learn a platform. I'd like the documentation to at least get me up and running. :( Example, that article doesn't cover how to set up using absolute paths, such as `ns/components/fooComponent` instead of doing all relative stuff.
I was afraid you might ask me to try...although I am nearly certain I could I just don't have time right now. So for the moment I will just have to disagree.
&gt;this is well worth doing. It works fine and will save you headaches in the long run. . &gt;If you're still looking for a general toolset for doing these things, you should try Webpack[3] , I agree, though while I like webpack, I wouldn't entirely recommend it unless you're cool with figuring out a lot of it on your own. It's a lot easier to get something like `grunt-contrib-watch` or `gulp-watch` up and running if you're just doing a simple compilation step and aren't taking advantage of all of the module stuff webpack offers.
I have now.
How about component(1)?
Think of it as a way to "level the playing field" when writing apps that target or need to support older browsers that might not have newer features. It's a way to keep your javascript modern and more or less standardized.
Thanks for the input! The event handling abstraction is optional, but was meant as a way to instantiate an object that handles the event if suspending the callback function is all someone is concerned with. var resize_wait = new Suspend(); resize_wait.callback(function() { console.log("wait to trigger after 500ms with no event activation"); }); window.onresize = function() { resize_wait.trigger(); }; The goal was to simplify the _old paradigm_ that requires keeping track of a `setTimeout` ID and clearing it on every event trigger. That process is already pretty minimal, but to me is confusing and causes callbacks within callbacks within a setTimeout, which I found to be difficult to read at times and hard to remember. The primary reason for going with a class-based design was because I wanted it to be more flexible than a simple helper function, i.e. multiple ways to do the same thing. The above code could be implemented in quite a few different ways using `Suspend.js` and clocking in at under 2kb minified. 
1) With resolve.alias, you can easily define what loaders to use for each module. 2) Webpack allows you to split your bundle into multiple chunks which you can require at runtime. 
What's the bug #?
Thank you! I want to make something similar to this: http://harthur.github.io/clusterfck/demos/colors/ in the next episode.
Should have asked about the would be successor to component duojs as well. I use component(1) at work and it helps bring a simple package management system to the development process. Our systems are not that complex and I've been able to take advantage of most of the things that component offers. Along with a lazyload script that's pretty straightforward. I'm re-evaluating the choices we'd made so far and this helps, but wanted to make sure that I stress that component is not they complex or difficult an idea to grasp. 
The above links provide some good guidance. I like the explanation listed here: https://github.com/ryanflorence/react-training/blob/gh-pages/lessons/05-wrapping-dom-libs.md
What is your use case for absolute paths?
The OP asked for: &gt; a Function that parses a String and returns a TemplateString? I understood that to be something like this: You would write: const harmless = “benign”, result = parseTemplate("I am expecting a ${harmless} value”}); console.log(result) //=&gt; "I am expecting a benign value” This fictional `parseTemplate` function would take an ordinary string and act like it’s a template string. But to do that, of course, it would need to `eval` any expressions in the interpolation. So no, people cannot use a template string to trick our code into executing something, but if we had "a Function that parses a String and returns a TemplateString,” then we would have exactly the same vulnerabilities for such a function that we’d have for `eval`, because it could contain any arbitrary expression. Summary: Template strings are not vulnerable, but a function or other feature that converts an ordinary string into a template string would be as unsafe as arbitrary `eval`, because it’s equivalent to parsing a string as an arbitrary expression.
&gt; a function or other feature that converts an ordinary string into a template string would be as unsafe as arbitrary `eval` I still disagree. A template string will only eval 1-level deep. This means that... var hopefullyHarmless = 'alert("boogers!")'; `${hopefullyHarmless}` // Will result in a string: "alert("boogers!")" That's significantly less terrible than `eval`: var hopefullyHarmless = 'alert("boogers!")'; eval(hopefullyHarmless); // Will shout "boogers!" at the user See what I mean? **Edit**: At this point I'm pretty sure you and I are just nitpicking with each other. I doubt OP is even paying attention. ;)
Nicely done. I'd suggest making this change: var defaults; if(typeof title === 'object') { defaults = title; } else { defaults = { title: 'Confirm', subtitle: '', okFunction: null, cancelFunction: null }; defaults.title = (typeof title === 'string') ? title : defaults.title; defaults.subtitle = (typeof sub === 'string') ? sub : defaults.subtitle; defaults.okFunction = (typeof okFunction === 'function') ? okFunction : defaults.okFunction; defaults.cancelFunction = (typeof cancelFunction === 'function') ? cancelFunction : defaults.cancelFunction; } This would allow you to pass in all parameters as an object in lieu of requiring them to be function parameters, but would still support the function-style syntax.
We experienced the opposite after switching *to* requirejs. We learned that good dependency management meant things like avoiding globals, shimming 3rd-party/legacy code, and being explicit about requiring dependencies. In a nutshell, when it comes to dependency management, the only assumption you should make is that the dependency you require will be responsible for loading its own dependencies. Any other assumptions, like `$` or `_` being available, is going to result in trouble down the road. This is especially true when you consider that all javascript you write will be executed in at least two contexts: the web page itself, and a unit test environment. In the latter, strict dependency management is crucial. You can no longer depend on globals or preloaded libraries. This is also true if you want to share your code with another project, or open source it for others to consume. So learning how to properly shim code and be explicit about dependencies will help prevent headache down the road. It doesn't matter if you're using requirejs, browserify, webpack, or your own home grown solution -- they are all fantastic dependency managers. Using them incorrectly is not justification for switching.
Considering how many people are using for the enterprise, evidence points to yes.
You were not using require.js/r.js correctly, or at least the most efficiently. When building to prod, you can and should build require.js into your common.js file. You do that by specifying requirejs in the paths and then include it in your initial load. Here's an excerpt from my Gruntfile: requirejs: { compile: { options: { ... paths: { 'requirejs': "../vendor/requirejs/require", }, modules: [{ name: 'init', include: [ 'requirejs', 'jquery', ... ] }...
I am almost positive there was something wrong with your build configuration. Almond is just a lightweight AMD loader, I am not sure why you think you couldn't use it (unless something wasn't built correctly). Almond does not do dynamic loading, so if it fails, that means something wasn't optimized correctly (are there any define calls in the output without a module id?) Here is our app using the Dojo AMD loader, and a few AMD modules: http://i.imgur.com/jdTF6rG.png All of those scripts minus argos-dependencies at the top are all AMD bundles. The ones towards the bottom are required in the &lt;body&gt; when the app initializes (localization, configuration). Our CRM mobile app is open source, here is our index file for the screenshot I just took: https://github.com/Saleslogix/argos-saleslogix/blob/develop/index.html#L80
Yeah, it'll be updated with the full team list tomorrow. I posted a little early, oops.
Where is this information published?
You could apply a transform, just like you do with the ship. &gt; bullet.style.transform = 'rotate(' + angleDeg + 'deg)'; While I'm here, you can get atan2 to give you results relevant to your coordinate system by modifying the input you pass to it. You don't need to adjust it haphazardly afterward: &gt; //Angle between them in degrees &gt; angleDeg = Math.atan2(p1.x - p2.x, p2.y - p1.y) * 57.29; (note that I pass x first, and invert y)
Do they publish meeting minutes or have a mailing list? I'm getting antsy. 〠_〠
How about doing 5 minutes of research before asking others? http://en.wikipedia.org/wiki/Polyfill
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Polyfill**](https://en.wikipedia.org/wiki/Polyfill): [](#sfw) --- &gt;In [web development](https://en.wikipedia.org/wiki/Web_development), a ___polyfill___ (or ___polyfiller___) is downloadable code which provides facilities that are not built into a web browser. It implements technology that a developer expects the browser to provide natively, providing a more uniform API landscape. For example, many features of [HTML5](https://en.wikipedia.org/wiki/HTML5) are not supported by versions of [Internet Explorer](https://en.wikipedia.org/wiki/Internet_Explorer) older than version 8 or 9, but can be used by web pages if those pages install a polyfill. Web [shims](https://en.wikipedia.org/wiki/Shim_(computing\)) and [HTML5 Shivs](https://en.wikipedia.org/wiki/HTML5_Shiv) are related concepts. &gt; --- ^Interesting: [^Shim ^\(computing)](https://en.wikipedia.org/wiki/Shim_\(computing\)) ^| [^Web ^Components](https://en.wikipedia.org/wiki/Web_Components) ^| [^Lea ^Verou](https://en.wikipedia.org/wiki/Lea_Verou) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cpgc2fe) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cpgc2fe)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Oh. Right, Safari.
Fucking safari. Good js performance but shitty at everything else.
I'm pretty sure I tried this, but for the benefit of the doubt, I went there and tried it again. I started from this: https://github.com/requirejs/example-multipage-shim BTW, really weird that the official optimization example doesn't even bundle requirejs with the common file.. hmm.. food for thought. In `tools/build.js`, I added require include: [ 'require', 'jquery', 'app/lib', 'app/controller/Base', 'app/model/Base' ] I ran the optimizer, for some reason, it doesn't crash but it doesn't seem to compile it: js/lib/../common.js ---------------- js/lib/../common.js js/lib/jquery.js js/app/lib.js js/app/controller/Base.js js/app/model/Base.js I edited index1.html to this: &lt;script src="js/common.js"&gt;&lt;/script&gt; &lt;script&gt; require(['app/main1']); &lt;/script&gt; And when I load the page... `Uncaught ReferenceError: requirejs is not defined` So, maybe I called it wrong.. so I just tried &lt;script src="js/common.js"&gt;&lt;/script&gt; Ignoring main1 for now... and same error. So, what's wrong? Let me know. **--- edit** OK so, it doesn't work when you include `require`, it only works when you define a path to `requirejs`. Even though `require` is found and all. You have to workaround and include `requirejs`. Fucking wow. How is that even logical. I'll stand corrected, edit that point from the article, and say that I bundled it wrong. But by doing that, The complexity of the build just grew. Now I need to make sure my bundled scripts are called one way, and my unbundled scripts are called another way.. more moving targets, yay. 
Why_would_mentioning_php_in_a_comment_on_an_article_about_php_be_relevant -&gt; areYouStupid('really?'); 
Hey, sorry for the slow response. Thanks for the help, I'll try this when I get the chance to :)
That code is generated. Usually, developer doesn't even touch config.js.
Thanks! Was not expecting this to be here...
I thought this was pretty informative. Thanks.
I've been using [this](https://github.com/Sage/streamlinejs) for ages, now of course the standard is preferable, but there was no need to wait for ES7. EDIT: since people seem to be confused, Streamline does *not* use fibers by default. That is an option (I never used it). Also: Browser-side use You have three options to use streamline in the browser: The first one is to compile the source with _node --standalone -c. The compiler generates vanilla Javascript code that you can load with &lt;script&gt; directives in an HTML page. See the eval unit test for an example. You can also transform the code in the browser with the transform API. All the necessary JS code is available as a single lib/callbacks/transform-all.js file. See the streamlineMe example. A third option is to use the streamline-require infrastructure. This is a very efficient browser-side implementation of require that lets you load streamlined modules as well as vanilla Javascript modules in the browser.
Yeah I know, it's his code. I fixed what I had to make it work. Opted to 'pick my battles' and focus on the unique ID requirement over explaining how to define ID/Classes in HTML. But I will fix it since it's on my jsfiddle account. 
Please let me know if I can help anyone? :)
Never heard of it, to google we go! Thanks for the suggestion
This is what the lifecycle methods are for.
All of this is beginner stuff; You didn't even elaborate on the use of 'arguments' for #5.
Is this available in a commonjs format? Not really liking the require-js esque "needs" method.
It is not going to be like that forever. Browsers are working on fixing it (I'd link bug reports if I wasn't on my phone). And you can use libraries like Bluebird today to solve the problem.
`return condition ? true : false;` Instead of this, you can just do `return condition;`. If `condition` isn't a boolean and you need it to be, you can convert it using double negation, but that shouldn't be necessary. Also checking if a condition isn't strictly equal to true is not necessary. For that matter, don't use nonstrict comparisons at all. `For of` is part of ES6. This is fine, but know that if you use it, it won't be supported in a lot of browsers. You'll need to use a transpiler if you want any sort of cross-browser support. An easier way to handle optional parameters is to write `var param = param || "default value"`. The logical OR operator returns the first operand that isn't falsey, so if `param` is undefined, it will return `"default value"`.
&gt;2020 - IE32 finally supports ES6 and old browsers are finally dead, so we can use it natively now. I know you kid, but IE12 (or spartan, whatever they're going to call it) the most overall ES6 support for a browser. [Lookie](http://kangax.github.io/compat-table/es6/#ie11tp). Granted, it is missing some important stuff, like destructuring and generators. 
It calls out to a server to download the polyfills you need. A commonjs format wouldn't work without some kind of pre-processor in the mix, which is way out of scope for a project this specific.
That said, this isn't really something you would use per module. You would use this once for your whole project before everything really "start running". You won't have these `.needs` calls scattered throughout every file in your project.
which doesn't work in the browser and never will . Fibers aren't part of ecmascript.
I think that argument only holds for new topics or technologies. Information about polyfills is everywhere. So the approach should be look first then ask if you can't find.
No offense taken, just responding to the point you made :) I greatly prefer commonjs style myself, it's just not really feasible for this kind of project. 
Great idea in theory. Adding a dependency on an external service just to get my code running sounds like a horrible idea, however. No telling how long this will be supported, what uptime is, how bad latency can get... Provide a way to host this on my own server and I'd use it. At that point I guess you may as well serve up the polyfills immediately.
I am too noob for this shit.
Interesting. I guess that has some good and bad to it. The positive being that you don't need to wait for the initial scripts that do the "checking" for absent functionality to load. And obviously, like you said, the negative -- UA sniffing. I personally feel that the pitfalls of UA sniffing aren't worth that boost in initial load.
But if you do want coercion, you can also use a = myCondition ? 5 : 10; 
&gt; An easier way to handle optional parameters is to write var param = param || "default value". The logical OR operator returns the first operand that isn't falsey, so if param is undefined, it will return "default value". A caveat to this is if you are passing "falsey" parameters around. var logSomething = function(something) { console.log(something || 10); }; logSomething(); // 10 logSomething(20); // 20 logSomething(0); // 10, uh-oh
That was my general takeaway as well. There certainly would be some speed increase by getting your polyfills in the initial load instead of needing a second script request, but actually doing feature testing instead of UA sniffing just seems more reliable and more "correct".
Generators (`function *`) are though. And [the async/await strawman](http://wiki.ecmascript.org/doku.php?id=strawman:async_functions) describes async/await as &gt; thin sugar over generators and a `spawn` function which converts generators into promise objects with theoretical optimisation possibilities due to the internal generator not getting exposed. At the core though, most (if not all) of what async/await provides can already be done with ES6 generator functions.
Babel will be a dependency for at least a few more years for you in that situation, won't it? ES6 is supposed to be finalized this year, if I'm not mistaken, so where does that put ES7 on the timeline?
socket.io is about websockets (with some pub/sub features wrapped around that). This appears (after glancing at the source) to be a purely in-memory pub/sub implementation. It looks to be more similar in nature to [postal.js](https://github.com/postaljs), although less feature-full or robust.
&gt; In JS land, everything (except for web workers or child processes) is ultimately run inside the global event loop You actually don't know that. The beauty of all the async developments is that the JS engine can run many things in separate theads. And we're not talking about the ancient setTimeout, which was never promised to run in parallel. 
Take a look at http://gruntjs.com/api/grunt.option 
I'm fine by having Babel as a dependency for as long as it's needed for transpiling. What I meant was that I don't think Babel should act to quickly on adding support for new language features that haven't even been discussed in the committee. Worst case is we get a bunch of features supported by Babel which isn't in the standards that makes my application dependent on Babel for the wrong reasons.
This is sort-of what I'm trying to do. However, the instructions are explaining how to call a different initConfig task key. I want to pass an argument that says which directory is being processed (which is part of the value). sample: { src: [ './dynamic_value/*.json' ] } 
I just read through your blog post again to try to get a better understanding of why requirejs wasn't meeting your needs. I'm interested because my team has had quite the opposite experience, and maybe you know something that we don't know. But out of the issues you've listed, none of them have been problems with our team. Regarding dev and prod being different, this has not happened to us. There are two reasons why we haven't experienced this: 1. We rely heavily on unit testing, which means each JS file must declare all of its dependencies and 2. We avoid global variables like the plague. For example, if we're going to write an angular module that relies on functionality from ui-router, we don't assume the `angular` global or ui-router are available. We explicitly require them: define(require =&gt; { 'use strict'; let angular = require('angular'); require('ui-router'); angular.module('foo', ['ui.router']) .config(function($stateProvider) { /* ... */ }); }); We never use shims for our own code. So all of our JS is written like the sample above, and they can be loaded independently in unit tests without issue. If you were following this pattern throughout your code base, did you still run into dev/prod discrepancies with requirejs? You also listed npm/bower issues. We don't use npm for client side code, so I can't speak to that, but we've been using bower with requirejs without issue so far. One of the first things we did was update our `.bowerrc` to set the download path for bower components to a publicly accessible directory. This way we could `require()` them without having to copy them. We then use the `paths` option in requirejs to simplify how we load them: var requirejs = { "angular": "bower_components/angular/angular-min", /* ... */ } Many of the bower components we use require shimming, so we configure that as well. For example, ui-router has a dependency on angular, and our shim configuration enforces this. So far, we have not needed to directly modify any of our bower dependencies. Do you have an example of one that could not be shimmed properly with requirejs?
How do I tell it to load the closed class instead of the expanded one?
Thanks for the info, I didn't think about it doing that. Going to play with the CSS and see if I can get them to load closed.
Additionally, instead of having two elements with different classes, just use one element and change or add a class to change the element state. 
Thanks for the suggestion, I will look into doing that. This JS stuff is making my head spin. Got what I was aiming for, for the moment at least.
In my opinion transpilers are a great solution, they allow you (and your team) to write as much or as little of the new features as they want and still have them all transpile to ES5. This means nothing is going to all of a sudden start breaking if a member of your team isn't using every latest and greatest method. The only "drawback" is that they require a build step, but at this point I would imagine most front-end developers are using a build tool at this point so this doesn't really much effort.
Get your learn on.
[**@ivanoats**](https://twitter.com/ivanoats): &gt;[2015-03-16 16:47:01 UTC](https://twitter.com/ivanoats/status/577511399359840257) &gt;JavaScript: "In an insane world, it was the sanest choice" [#SarahConnor](https://twitter.com/search?q=%23SarahConnor) [#JavaScript](https://twitter.com/search?q=%23JavaScript) \(OC\) [*pic.twitter.com*](http://pbs.twimg.com/media/CAO7jsDUkAEpcuX.png) [^[Imgur]](http://i.imgur.com/D1UQsRS.png) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2z97uf%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Dunno if you've solved your problem, but this is more along the lines of what I'd do. HTML: &lt;div class="expandable"&gt; &lt;div class="summary"&gt; This will be the collapsed text. &lt;/div&gt; &lt;div class="full"&gt; This will be the expanded text. &lt;/div&gt; &lt;a href="#" class="toggle"&gt; &lt;span class="more"&gt;+More&lt;/span&gt; &lt;span class="less"&gt;-Less&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; CSS: .expandable .full, .expandable .toggle .less, .expandable.expanded .summary, .expandable.expanded .toggle .more { display: none; } .expandable.expanded .full { display: block; } .expandable.expanded .toggle .less { display: inline; } JS: (function ($) { $(function () { $('body').on('click', '.expandable .toggle', function (e) { var $toggle = $(this); var $expandable = $toggle.parent(); $expandable.toggleClass('expanded'); e.preventDefault(); }); }); })(jQuery); And here it is loaded into JSBin: http://jsbin.com/xipibewemi/1/edit?html,css,js,output
Good idea. I mean the overall idea is that you can write the new syntax now and just transpile to ES5. Later, when the features you use in ES6 are widely supported, all you have to do is remove the transpile step and you are good to go
I agree. It's less typing, but more decrypting what's going on.
Could you provide a http://jsfiddle.net/ for this ? It's hard to help without being able to replicate the problem :) Are you sure `thisClick.next('.collapsible-div')` returns the DOM Element(s) you want ? 
&gt; In the dev environment, if you don't write the shims, it sometimes works, it sometimes don't (it depends on the load order I guess). Yea, in the browser there's a chance that the load order will satisfy the dependencies, but that's mostly coincidence and relies on globals to work. It's not reliable, and I can understand the frustration when things work in dev but not in prod. `jQuery.noConflict()` might help you here by killing the global `$`, so at least you'll get immediate feedback when you attempt to load a plugin that isn't properly shimmed. Also see the docs for [more tips on how to use jquery with requirejs](http://requirejs.org/docs/jquery.html). &gt; What's your bundling scenario? (single entry, multiple entry) We are using a single-entry bundle to power a SPA with AngularJS. We actually have two SPAs, both based on the same codebase, but one is for authenticated users and the other is for unauthenticated users. &gt; Who set up the whole thing? Was it you or someone else, or a team effort? It was mostly set up by me but the whole team was involved. We spent time evaluating requirejs and browserify, and at the time requirejs was a better solution for us. I'm sure browserify (or even webpack) would have met our needs, but we already had some requirejs experience so we went ahead with it. The only dependency management issues we've encountered were due to developer mistakes, like forgetting to `require()` a dependency that was used. But these issues reveal themselves when unit testing, so they're caught early.
Yeah, if you need those features now, I can see the value in investing the time to learn TypeScript. My gripe was that we shouldn't need to wait for 1-2 decade long development cycles for JS, HTML and CSS. I know they're supposed to be going to a yearly cycle which is great but I'll believe it when I see it :)
Thank you! I will try to add benchmarks as soon as I know more about the engines you mentioned and how they work.
&gt; We have are using a single-entry bundle to power a SPA Ahh that explains the lack of headaches :-) We actually started as a single-entry but the codebase was really starting to get big, so we split it up.. and then the headaches began. The first 5 months when it was single entry was amazing. I still remember the pain having to change a lot of the folder structure in order to satisfy R.js and the loading. *shivers* If one day you have to split it up, and r.js gives you pain, give webpack a try.. if you've been rigorous like you explained, switching to a webpack build shouldn't take you more than a couple of hours.. it's also a much better optimizer than r.js. 
&gt; I still remember the pain having to change a lot of the folder structure in order to satisfy R.js and the loading. shivers Can you elaborate on this? I don't recall ever needing to move files specifically to satisfy R.js.
Is there a point to this?
It's when I converted from single entry to multi entry + common + shim. You probably never had to do it because you're using single entry. Take a look at this repo: https://github.com/requirejs/example-multipage-shim For r.js to work right on multi entry, you need dummy routing files. It's quite convoluted, really. Oh, btw, I found the problematic shim thing. I remember doing a repo about it: https://github.com/maktouch/requirejs-shim-fail The fix was using inline requires instead of data-main.. another weird RequireJS thing. Anyways, like I said, single-entry is awesome. Multiple entry is nightmare. All sort of weird things popup, and suddenly "you have to do it this way, because.". 
Some tips: - To catch the escape key, listen for "keydown", not "keypress". The escape key doesn't trigger keypress, at least not in Chrome and IIRC not generally. - Be conscious of modifier keys. Your escape key listener doesn't check modifier keys, so shift+esc, ctrl+esc, etc, are all treated the same as pressing escape by itself. Is that really what you want? When in doubt, implement nothing more than necessary. - Use `window.addEventListener('load'` instead of `window.onload =` to avoid getting clobbered by other things on a page that run onload. - `remove` can be fired when the popup is not visible. Though it isn't causing bugs now, I'm guessing this wasn't the intent. I suggest attaching listeners that close the box when it's shown, not onload, and removing them in the `remove` function.
So keeping your js/css as small as possible and at the end of the body tag. Use uncss and critical css, and a lazyloader for images. 100% on Googles mobile speed test. 
I'd suggest removing the position:fixed because when the modal content is taller than the page it's fixed offscreen and you can't even see it. This is obviously more of a problem on small screens, on smartphones.
Putting your CSS at the bottom of the page doesn't seem like a good idea as it will cause a FOUC along with the added penalty of a superfluous DOM reflow.
Hmmm? Not a chance without an explicit API to indicate you would want things multithreaded. There is simply too many consensus complications with shared state that it would be too hard to guarantee global linearization that is expected with JS. Not only that, it's incredibly hard to know *when* creating a thread will actually be worthwhile. Even purely functional languages don't just go spawning threads when just because they can guarantee a certain dependency DAG. There has to be an API for users to specify what exactly they would want to run multithreaded.
If you have source maps set up correctly you won't have to do much ES5 debugging. I've done a fair amount of work with coffeescript transpilers and it was quite painless once everything was set up. There is one thing you have to watch out for. Make sure your build tool serves up updated source, map, and js files at the same time. I had grunt misconfigured and the map files weren't always being updated. That made debugging very very confusing.
Try this: $('.thing').each(function() { var entry = this; if ($(this).find('a').attr('href').indexOf('imgur.com') !== -1) { $(entry).remove(); // Or .hide(), whatever floats your boat. } }); Note: This finds imgur links, not images specifically. 
Can you give us more details? I like the idea.
Thank you. What does .each() do?
Did you try googling? http://stackoverflow.com/questions/20936486/node-js-maximum-call-stack-size-exceeded
Nice watch :) thanks for sharing
I wish the creators of things like this would use lots of examples. People truly learn from examples. If you're trying to do this, do this. If you're trying to do this other thing, do this, etc, etc
I would expect the `await`-ed thing itself to be able to run in a different thread, but not anything else. Currently, the result of a successful execution gets returned to the site of the `await`. As do errors, if you have a try/catch -- they act as if they are thrown at the site of the `await` as well. However, if you don't have a try/catch, it sounds like these errors just get swallowed. But I would expect the error not be swallowed; it should propagate from the site of the `await` and get handled by the normal global-level error handlers like `window.onerror` if it's there, or else get logged to the console (as happens in Chrome and most other browsers these days). In Node, for example, I would expect the process to log the error and die, because that's how other uncaught errors are handled on that platform. 
This might be an acceptable level of LMGTFY if your link actually solved the specific problem instead of being a general reference on call stacks. 
I believe it's awesome. This is for validations like templates are for plain old html strings. It would need a lot more documentation to list all the possible filters/validators. I'm not familiar with validator.js, but -for example- it's confusing to say that main methods are *to* and *is* and then pull method *from* out of nowhere. 
What the hell does this thing do? I clicked on all your examples but they just seem to show css being applied to some content. Why would anyone need an extra step to apply css? What am I missing? For some reason, no one will answer this question. One guy was even a huge dick to me just for asking a simple question.
Yeah ! it applies CSS just a small CSS plugin to create a lightweight Modal. Cheers !
Also, Move focus to the dialog. Limit keyboard access to prevent tabbing outside of the dialog when it's open. Currently I can access all the elements of the page when your modal is open. Bonus points for wrapping everything in the &lt;dialog&gt; element.
Man, I'm just confused. What am I not getting? I click on Try It and the example just shows some content that has been styled. What am I supposed to see?
&gt; We need to identify the parts of my.js and my.css needed to render the initial content, inline those parts, and delay or async load the remaining JavaScript and CSS needed for the page. Not sure how I feel about this.
Found it on his twitter: http://www.slideshare.net/HunterLoftis1/forwardjs-we-will-all-be-game-developers
Assuming you need to lint all of these files then I would look for ways to shard the files into multiple directories and then do separate scans/lints on each directory instead of hitting the whole tree at once.
But you want that in the places Typescript is used, isnt that the whole point? Stuff like Models and Services should have strict, thoughtful, verbose typing and polymorphism . Meanwhile places where you are working with the DOM can benefit from the flexibility of JS...
I've actually been messing with this code trying to make it work with what I have. I'm looking through other grunt-specific articles as well. I haven't found anything that does what its supposed to do. Every time I try this approach, I just get "Done with no errors" in the console.
Sounds like a good idea to me. Webpack is great on the front-end because you need to transform your JS, and its good to see you don't need to use an alternate transpilation system when you're running the same code. This used to be solved with require extensions, but those are deprecated in current versions of node; now they suggest you compile the code ahead of time. Webpack does that and uses incremental compiles during development. Webpack's Hot Module reloading is a lot like WebStorm's live reload, but its available free of charge and in the editor of your choice. Unlike nodemon, hot module reloading can replace your code without requiring the whole app to be restarted. Its much less big of a deal server-side than client-side, provided your server doesn't have slow setup/teardown, but its still nice to have. 
Thanks man!
Here is a great explanation regarding the acao header. http://stackoverflow.com/questions/20433655/no-access-control-allow-origin-header-is-present-on-the-requested-resource-or You could accomplish this on the server quite easily... http://stackoverflow.com/questions/19539391/how-to-get-data-out-of-a-node-js-http-get-request
Yeah, I really enjoyed the topic and learned a lot (as a newish JS developer) and found that the presenter had a great light-hearted but sincere approach. 
Thank you; I have a lot to learn.
you pointed to a library that uses fibers.
Also, a completely different _context_; back-end _anything_ has a different set of concerns from the client side. While the language might be the same more or less as it were, the audience is completely different. Know your audience.
This is disappointing. This offers nothing on top of the existing XHR implementation except for useless sugar and it doesn't offer even offer chunked responses which *SHOULD* be the backdrop for any [new streaming api](https://github.com/whatwg/streams).
...a *just as bad* xhr api... that uses promises
forEach is by far less optimized than a classical for loop, because it has to set up scopes etc. Also, if you are already using forEach, why don't you use indexOf, which for arrays is also a valid ES5 method? You are comparing apples to oranges.
I don't think either one of these solves my problem. The first suggestion is saying to either be on the same domain or have the server (Craigslist) spit out a response with the correct header. I can't do either. The second suggestion is only solving an asynchronous issue. Really nothing to do with ACAO. Here is a js.fiddle example of my issue: https://jsfiddle.net/NF2jz/4927/
tl;dr requestAnimationFrame has non-deterministic behaviour, so ~~don't use it~~ using it for physics simulations yields non-deterministic animations.
http://updates.html5rocks.com/2015/03/introduction-to-fetch The actual implementation of the fetch API has a couple of benefits: 1. It _does_ use the Stream API for responses, meaning that chunked responses is a possibility. It may not be doing it this very second in time, but it's at least got the fundamentals. 2. By transforming the AJAX syntax into something which is inherently promise-based, it paves the way for it being used as part of the "async function" syntax introduced in ES7, which also in turn feeds into the concept of an "observable", which is outlined rather nicely in this comment: http://www.reddit.com/r/javascript/comments/2ywqif/if_we_have_functions_and_yields_why_do_we_need/cpdtknf So I wouldn't say it offers *nothing*. Plus, come on man, where's your sense of invention? Just because it doesn't do X and Y instantly out of the box, it's completely useless, will never get any better, and shouldn't have been done? Howays.
&gt; I've seen many frontend developers preferring large frameworks instead of smaller components (LEGO-driven development). And that's not minimizing or isolating state. Well, kind of. You end up with tons of state in those kinds of frameworks, but their selling point is that they *manage* the state (and transitions) for you — so you don't really have to care. I guess you could kind of say most advanced template systems are really state DSL:s; which — if not isolating the state itself — is at least explicitly specifying it. &gt; (...) doing everything the angular/backbone/jQuery way It's kind of odd grouping MVC frameworks together with jQuery, no? They do very different things. &gt; This is essentially MapReduce in a way. How would it be? His point it separating something that behaves non-deterministically and something that does. MapReduce isn't in any way related.
There's more to this then promises
If you're still interested, using the [MNIST](http://yann.lecun.com/exdb/mnist/) handwritten digit data set I achieved a success rate of 82.36% without optimizing the configuration (still 400 input, 40 hidden, 8 output, 0.1 learning rate). Only preprocessing was subsampling the 28x28 images to 20x20 and bounding box centering. EDIT: I should also mention that my processing power is a 2.5 year old MBA so progress is slooow...
Awesome! &gt; At the cinema, you get 24 FPS. Do not think that means 24 FPS is okay. This cannot be stated enough. You'd not believe how many people buy the "it's more cinematic!" argument as something *positive*. &gt; This is a little test of a physics engine that I wrote [...] *It's a terrible physics engine, never use it* How I feel whenever I make a physics engine. How I'm sure **anyone** feels when they make a physics engine.
Fantastic presentation.
Copy/pasting the comments I made on another post regarding fetch as a counter-point: http://updates.html5rocks.com/2015/03/introduction-to-fetch The actual implementation of the fetch API has a couple of benefits: 1. It does use the Stream API for responses, meaning that chunked responses is a possibility. It may not be doing it this very second in time, but it's at least got the fundamentals. 2. By transforming the AJAX syntax into something which is inherently promise-based, it paves the way for it being used as part of the "async function" syntax introduced in ES7, which also in turn feeds into the concept of an "observable", which is outlined rather nicely in this comment: http://www.reddit.com/r/javascript/comments/2ywqif/if_we_have_functions_and_yields_why_do_we_need/cpdtknf
&gt; or you could just use reduce Reduce is a more general operation. You can implement a traverse using reduce, but they are different things. Mind you I'd be perfectly fine with an implementation using reduce. It's slightly more boilerplate, but the thing I was trying to avoid was unneeded mutable references. &gt; Anyway, your exemple didn't demonstrate what's wrong with the snippet. Apologies, I probably should have clarified. I fall into the functional programming camp, so my philosophy heavily revolves around avoiding mutable state. It's up for debate exactly how strict one should be about this, but in general avoiding mutable things where there's minimal overhead for doing so is considered a good idea, even when using other paradigms. In that simple snippet it's pretty easy to see that 'promise' is a variable that's getting changed on each iteration, resulting in a final promise that will return when all operations are complete. It seems pretty innocuous.. However as the complexity of the codebase increases, it's just another moving part to make a mistake with. It's slightly harder to reason about the value of a mutable reference, and it's easier to make a mistake during a refactor that breaks it. The difference is subtle for small examples, but as complexity increases these things have a habit of breaking first - it's easier to make a mistake during a refactor or something else that screws it up. If there's a simple solution that avoids using mutable state and doesn't involve pulling teeth to achieve it (i.e. difficulty is less than the imperative solution), then it seems like a win-win in my mind.
This is just one contrived example. Do not take it too seriously. Well this is created because personally I find this https://github.com/ctavan/express-validator to be too verbose. My creation is similar to https://github.com/dandean/express-form but I intend to make it even more powerful and easier to use. This is one example use case. var registrationData = is.has({ email: to.normalizeEmail().is.maxLen(100).email, password: is.maxLen(100).str, firstName: is.maxLen(30).str, lastName: is.maxLen(30).str, }).obj; app.use(… function(req, res, next){ var params = registrationData.from(req.body).data; if (!params) // failed validation and parsing }); How else would you achieve the same result using something else? 
Then create a revision perf.
You should probably still use requestAnimationFrame, but to get more consistent results you'll want to use a fixed or max size time step for the physics. Making a deterministic sim would be pretty tough with Javascript (or with floating point math in general.)
I hope one day I'll be able to say that I can make a shitty physics engine that no one should use.. That seems like something very complicated and far beyond my skill set! I can dream though ;)
This API is a less powerful XMLHttpRequest with a different mechanism of notifying completion. If an API can be [polyfilled](https://github.com/github/fetch), it offers no more power than what can be done today. And in the case of `fetch()` not exposing events for the `OPENED`, `HEADERS_RECEIVED`, and `LOADING` events, currently **less** power than what can be done today. How about something that gives us access to handling or detecting the presence of a redirection response? It's currently impossible to consume valid HTTP APIs which make use of 300 Multiple Choices from within a browser.
To add to some of the other comments, this is *only* supported on Chrome and Opera http://caniuse.com/#search=fetch
Promises have the contract of only calling exactly one of either the resolved or rejected callback at most once. XMLHttpRequest calls the readystatechange callback multiple times in order to notify the client about the various state changes that a request goes through. This allows you to read the response headers before the body has finished loading or present to the user a percentage loaded indicator. In this case, promises cannot by definition duplicate this behavior, so it is a poor design choice for a flexible HTTP request API.
Gretchen, stop trying to make fetch happen! It’s not going to happen!
I might be misreading the actual workings of the API here, but isn't the resolution from the Promise for fetch a Stream which is enhanced to include extra functionality such as header access and access to the response body. It may not work like this currently, in spec or in polyfill, but surely since all the methods for accessing the response body in the Stream returned are asynchronous, it would make sense to have the fetch API work so that the Promise is resolved after the connection is made and response headers returned (Or connection failed, either way), and then the Stream can be polled for more information to allow the exact scenarios you've listed above? I would have thought that would be what was going on, i'd be amazed if they bypassed this opportunity.
Yup, scripts written in Java sucks.
...I'm very close to telling the new girl all your secrets.
Actually 82.36% is kind of low, at least compared to the NN's on the MNIST website, so I don't think I would recommend using it for handwriting recognition. The training set is actually generated from [node-captcha](http://npmjs.com/package/node-captcha), so it certainly could be used for captcha solving with some additional pre-processing.
Huh? What "iPhone?"
I think the point is, if you understand ACAO, that you can't get this data via an AJAX request. They've disallowed it via ACAO header.
You have to select the "Smarter" option and then scroll down to see the iPhone that is being referenced.
&gt; In my opinion transpilers are a great solution, they allow you (and your team) to write as much or as little of the new features as they want As I work in an office, my team does not have the freedom to do whatever they want. We have strict style guidelines. &gt; The only "drawback" is that they require a build step, but at this point I would imagine most front-end developers are using a build tool at this point so this doesn't really much effort. So you're saying that the transpiled code is actually good code with acceptable performance?
At first I thought that this is like gulp or grunt browser-refresh plugins, but then I watched video... Is this.. Is Amok really updating like code inside page so it will immidiately have effect on page, Without refreshing it? Are you going to make something for webpack, so after build it will refresh browser?
there's a polyfill: https://github.com/github/fetch
I don't think I've seen improvements above 60fps because that's the refresh rate of my monitor. I'd say for the moment 60fps is the right target in general, but there are platforms that support higher refresh rates that are likely to be more commonplace in the future.
The library you chose, Ramda, embraces curring and composition (akin to Haskell) and less so on chaining or piping (like JS and Elixir respectively) which explains Ramda's argument order. This is what separates it from lo-dash and friends as well as native array built-ins. That's not going to give you really any performance gain, but it *will* help in reusability, statelessness, and can be reasoned about in terms of mathematical composition. That being said, JS has neither the concept of laziness nor tail call optimization built in to assist in performance like some of the other functional languages. However the [transducers pull request last week](https://github.com/ramda/ramda/pull/878) will give some mighty assistance to Ramda in the coming weeks because it'll give the library some laziness. I use Ramda sometimes and I don't even bother with the `pluck` function outside of composition because there's nothing preventing you from use using the vanilla obj.propName in its higher order functions. Of course that wrapper is going to take a performance hit, but it's unnecessary to use it that way for this benchmark. Now do a benchmark for `zip`, `mapObj`, and `unfold`. Oh, it seems vanilla JS is missing a lot of built-ins. You gonna put those on the Array prototype or build a fancy pants library to do that?
On closer look at the spec, there is the ability to read headers before the body is available: var result = fetch(url) .then(function (response) { // response.headers exists, but the response text does not return response.text(); // this is necessary to load the response body }) .then(function (body) { /* now we have access to the body as text */ }); However, there doesn't appear to be any way to partially read the body (or get notifications on its loading progress), as you could do with XMLHttpRequest: var xhr = new XMLHttpRequest(); var contentLength = null; xhr.open('GET', url); xhr.onreadystatechange = function () { if (xhr.readyState === xhr.HEADERS_RECEIVED) { if (xhr.getResponseHeader('Content-Length')) { contentLength = parseInt(xhr.getResponseHeader('Content-Length')); } } else if (xhr.readyState === xhr.LOADING) { if (contentLength !== null) { console.log('Loading progress: ' + (100 * xhr.responseText.length / contentLength) + '%'); } else { console.log('Loading...'); } } else if (xhr.readyState === xhr.DONE) { console.log('Loading complete'); } }; xhr.send(); Note: the above code will produce incorrect percentages on compressed input and not show loading, so the `LOADING` state is more as an indication of loading process is being made or the partial processing of response content before it is all complete.
You are correct in that IE 10 does not support many ES6 features... including let and const. And they will likely never support it, but people are saying the Spartan will (most likely). Additionally, for older browsers you would still need to transpile ES6 code into ES5 (which you can do with [Babel](https://babeljs.io/)).
Agreed completely. I've started on a browserify-esque optimizer for AMD and it works really well (so it's definitely possible!). But before I get ship-crazy I'd like to step back and try and figure out the specification first. That way I can completely align with loader/optimizer semantics.
This is really great. When I click one of those links, there are several places I could imagine ending up developer.mozilla.org, WebPlatform.org, w3c.org or caniuse.com. It would be cool if I could get to some of these other sources too. Not that this tool isn't badass already. Also, have you heard of Dash documentation app for Mac or Zeal documentation app for windows? 
The issue is that you are calling the loaded function before the xhr request has finished. I added a callback function to be called when the xhr request is finished **and** when the script has loaded, since it has the async property. http://plnkr.co/edit/ByQ4sgAnqMMmtU9OliqB?p=preview
Make your own Console class 
Good stuff. Went to playful JS to check out the 3D rendering, learned a little about ray casting and immediately thought "this would pair well with augmented reality" which I personally believe will change the way we interact with the web and apps. 
A lot of people have provided solutions to this problem: https://www.npmjs.com/search?q=console+color My favorite is: https://www.npmjs.com/package/chalk
The warning is telling you not to use synchronous AJAX. Heed it. You're going to have to rethink your approach and figure out how to load libraries in serial order using asynchronous requests. What you're trying to do can be done with async. requests, I assure you. You're just going to have to do more work.
Is the slide deck available anywhere *else*? Can't watch a video or browse Slideshare right now. 
&gt; It's kind of amusing to see how JS is finally catching on to very basic patterns from other programming languages, presenting it as some kind of revolution. I'm not sure what this has to do with the language. Nothing in the video should be new to most developers. &gt; This is exactly why jQuery spaghetti code is on the way out. It's simply too hard to figure out the state when you have a gazillion lines of code that all manipulate the DOM directly. "Spaghetti code" results from poorly managed flow-control, which isn't the issue here. (It's all in the name, trace the execution and you have what looks like a plate of spaghetti. In case you were curious.) On state, that's a reasonable complaint about jQuery, and one of many reasons I recommend against using it. Though React isn't much of a solution either, as if it helps at all, it only helps you manage one aspect of your application's state. It does nothing at all to *reduce* state, which is far more important.
That's not nearly as quirky, though. People love quirky. I eat babies.
Hey there. Props for trying to improve AMD. As you know, I've had a lot of issues with AMD, but it wasn't because of the syntax/spec, it was more about r.js. Couple of questions/comments: - How will you resolve node and bower lookups? Does that mean node and bower has to be in a publicly-accessible path? - I saw this in the github thread: "I'm thinking AMD v2 spec needs to move forward and not be backwards compatible". What backwards compatibility are you talking about? Will AMDv2 be able to require AMD files? - I think the biggest improvement that can be made to the AMD ecosystem would be to work on r.js. Optimizing is a very important step and it really feels like an afterthought because it's so complicated to setup and debug. Cheers and good luck. 
the colors hurt my eyes
Yes, it should... Whoops. (You can probably tell I just typed that up on the spot.)
- They must be publicly accessible. I can't do any magic beyond accessing files over HTTP. This does mean your module system works for the web, and is not confined to Node (like browserify/webpack). - Some AMD files, not all. I can't promise an adapter, but it would be really nice to have. - Yup, agreed. Unfortunately the complexities of current AMD &amp; co. prevent that from happening.
&gt; `let` doesn't work correctly in any stable browser. IE11 included. "Just fine" may have been a bit strong, but there's a sizeable subset we'll be able to use when IE10 falls over the support edge (assuming it does so before the last Safari not supporting `let` falls over...)
Crucial are the lack of progress events and cancellation. While I understand the desire to move to a Promise based API, without these options it seems like a severe step backwards.
I don't think it's a good idea to use features which work differently across browsers. Well, the good news is that the vast majority of IE11 users will upgrade within a few months after Spartan's release. And Spartan is supposed to be an "evergreen" auto-updating browser. So, a year from now, thing should look quite differently.
What caused the bug?
1) Obviously? I don't know of many abstractions that are faster than their raw equivalents. It's not their purpose. 2) One could argue that the "no libs functional" approach isn't even purely functional given that you are using fluently chained native methods rather than creating parallel higher-order functions. And if you did, where would you put them? Presumably in a library of your own. 3) The no lib version is significantly less readable than the Ramda version, with much more room for errors. 
which platform ? osx, linux, windows ? which use ? server, client ? web ? application ? framework ? libs ? c++ addons ? 
Check this out: http://yuiblog.com/blog/2010/04/09/node-js-yui-3-dom-manipulation-oh-my/
It's absolutely possible to combine JavaScript, game and mobile development. Look into [canvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API) and [WebGL](https://developer.mozilla.org/en-US/docs/Web/WebGL?redirectlocale=en-US&amp;redirectslug=WebGL). With [Cordova](https://cordova.apache.org/) you can access native APIs on mobile devices. Just play around with the technology and create something. Just keep in mind to focus and finish some project, even a small one. Good luck.
FYI most (all?) transpilers (including babel) "fail" at properly transpiling `let` statements: if( true ){ let x=10; } console.log( x ); most of them just convert `let` to `var`, so the above code doesn't function as expected
Nice, thanks. Actually I made library a couple of years ago, just now make it open source, and just the description remain. For sure will need to improve something in performance, to make it better. Thanks for suggestions.
babel handles that case just fine, i know this because i reported this bug forever ago on the tracker the inner x will be aliased, correctly giving ReferenceError on the outer
Wow, just wow. You're the real MVP.
Nice! I'm gonna mess with the canvas right now! Thanks!
ES7? Say what?
sweet jesus
Do user groups normally charge you to attend? I mean, how is this different from any random "*casts" site (other than the "live" element).
I use this in my boilerplate code console.zdebug = console.debug.bind(console, '%cDEBUG:', "color:#A39;font-weight:bold;"); console.zlog = console.log.bind(console, '%cLOG:', 'color:#090;font-weight:bold;'); console.zinfo = console.info.bind(console, '%cINFO:', 'color:#33C;font-weight:bold;'); console.zwarn = console.warn.bind(console, '%cWARN:', 'color:orange;font-weight:bold;'); 
What a hideous UI
My prediction: not many people are going to use let
I laughed
`let` and `const` are block scoped. This is explained in the article. `var` hoists variables to the top of a function, so declaring a `var` inside an `if` or a `for` statement sometimes results in inexplicable bugs. ```const``` is especially useful in cases where a variable reference will never be changed.
&gt; if you want to generate JSON from a querySelectorAll I really hope you don't do this a lot.
I love 'em! You can do some fun stuff with Objects, too. ["foo", "bar", "baz"].reduce(function (partialObject, key) { partialObject[key] = 1; return partialObject; }, {}); //=&gt; { foo: 1, bar: 1, baz: 1 } http://i.imgur.com/7dpx5i2.gif // I just made this name &amp; func up... // It's probably a real pattern with a real name var dig = function (host, properties) { return properties.reduce(function (object, property) { return object[property]; }, host); } var object = { foo: { bar: { baz: "qux" } } }; var path = ["foo", "bar", "baz"]; dig(object, path); //=&gt; "qux"; 
Hi, for the current best JavaScript learning, I would recommend: Programming JavaScript Applications by Eric Elliott http://chimera.labs.oreilly.com/books/1234000000262 You don't know JavaScript book series by @getify https://github.com/getify/You-Dont-Know-JS Edit: This link is very useful: Essential JavaScript https://gist.github.com/ericelliott/d576f72441fc1b27dace
How is this example different than var?
Using var, since i is being incremented by the loop, the modified value is used by the closure. So instead of printing 0 1 2 it would print 3 3 3 There are ways around this, but it can be a real pain in the ass to deal with and debug.
I will bookmark this for later. I like doing stuff the extremely hard way first. It's so I can learn and appreciate the abstractions. Thanks for the share! :D
not-so-secret-tip:- Install this as a chrome app and `ctrl+L` type `devdocs` hit `tab`and type `#q=js array` for eg. given that you have javascript enabled.
What IDE are you using? Sublime?
Yes, you don't have to do that. Just like you don't have to look left and right before crossing a street. Increasing your chances of survival is completely optional.
 var a = 1; delete a; console.log(a); // ReferenceError: a is not defined Anyhow, the big idea is that you can't change the value of a `const`(ant). Its value is set in stone. const x = 1; x = 2; // SyntaxError: invalid assignment to const x
Or name them and it becomes even prettier: return b() .then(doSomething) .then(doSomethingElse) .then(doThisOtherThing);
I totally agree, but I'm hoping aurelia gets some traction. It looks like what Angular 2 should have been.
This is pretty cool. Now you just need an example `/log` endpoint we can plug in and we're off!
Yea, that's kinda pointless. You don't need a framework for Hello World. Vanilla JS wins. Fewest bytes and best performance. For a meaningful comparison, you have to write an actual application. And maybe the whole thing once more with tests. Y'know, because some people actually do write tests and testing is therefore kinda important to them. You also might want to try different templates. And how about TypeScript or Dart? Types and tooling is kinda nice to have.
I think you can get lower input latency with even higher FPS. So, even though it will still look the same on your monitor, it will feel more responsive.
I don't know... Imo, "Why? Because V8, SpiderMonkey and JavaScriptCore are all too big and complex. MuJS's focus is on small size, correctness and simplicity." is not enough for new JS interpreter. It's just fancy words.
`delete` doesn't do that.
I'll try to work it into a fiddle tonight. Thought it was useless to do without a file upload box and pdf.js next to it tho.
Exactly. As you can see when you actually read the code, this is digging deeper and deeper into the structure to finally fetch an imploded array of data of the text on that page. That is the output of the promise.all, and those get joined with "\r\n" to denote the next page. Flattening the promise structure wouldn't have made a lot of sense in this case imo.
&gt; Nothing in the video should be new to most developers. Agree - my point is that in frontend web development *it is* new to a lot of people. And it shouldn't be. It's about time more emphasis is put on it. I mean, how old are for instance the first JS MV* frameworks? 5-7 years? And we've been using it for decades in other programming languages. &gt;"Spaghetti code" results from poorly managed flow-control, which isn't the issue here. Well, I think it can be, in my opinion. I know it's not spaghetti code in the classical sense but once you have e.g. multiple handlers tied to the same buttons/events, perhaps affecting the same state and data, maybe even triggering other handlers, it becomes almost impossible to figure out the flow. I've seen jQuery projects where we had to backtrace by doing a "Search all files" on specific IDs and see what in which files showed up just to try to figure out what the app was doing. I did search for what you described and found a [beautiful picture of IIS](http://jeremybuchmann.com/wp-content/uploads/2013/06/iis_425px.jpg) though. :) &gt;Though React isn't much of a solution either, as if it helps at all, it only helps you manage one aspect of your application's state. It does nothing at all to reduce state, which is far more important. I haven't had the time for React myself yet. Could you give an example or short explanation? It would be much appreciated. :)
I did this in 2013, albeit using a command line tool and node's exec function... This is a pure JavaScript solution though, right?
Correct :)
Oh yeah, that's way better! Thanks :)
Thanks for the answer, it makes sense. What about declaring variables within loops or looped functions, how expensive is re-initialising a variable multiple times, should I; function foo(){ while(i){ var bar = a + b; } } or function foo(){ var bar; while(i){ bar = a + b; } } or is there no real difference/benefits.
A `GET` request to add a log entry...? :-(
This is a bullshit comparison, I'm sorry. Part of what makes angular 2 examples here longer is the fact, that the aurelia examples leave out stuff like "what template belongs to what controller" or "what modules are used in this code". If these examples are meant to tell me that aurelia.js handles all this without a sane module/DI system (aka global everything) and template variables are inferred globally (aka global everything) then I will happily stear clear of aurelia.js. Also, with two-way data-binding aurelia.js is bound to run into the same problems Angular 1.x has. Touting that as progress with only toy examples to show (instead of real solutions) is wasting my time.
Yeah, I never use `delete`... that sh*t be crazy. :)
Okay, this makes a lot more sense. Thanks!
Are you generating sourcemaps? I never used TraceKit but perhaps you could make it so when it crashes the browser sends the sourcemaps instead of the minified code?
The reason for the `GET` request was to minimize potential issues. If you take a peak at the source, you'll notice that the requests are being generated by setting the `src` attribute of an `&lt;img&gt;` tag: https://github.com/mmaelzer/uhoh/blob/master/uhoh.js#L45
I use D3, and this would be a cool way to do map textures for sure. Or maybe other uses, I dunno right now. Nice!
Doesn't that mean that the client needs to download the huge sourcemap-file? We can't afford to waste network resources...
Why not use XHR?
Var still has it's uses.
I considered using XHR, but hijacking an `&lt;img&gt;` tag should just work everywhere without issue. Also, it may be weird to use `GET` to send data to the server, but it doesn't bother me in this scenario. Also, if you _really_ want to use XHR, you could always do it by passing a callback to `uhoh`. What are your thoughts? I could add XHR if you think it'd more useful to folks.
Delete removes properties; it doesn't work on variables or functions. If you add 'use strict'; it will throw a SyntaxError.
Thanks! You can use it in combination with colors to highlight something or for selecting further variables/categories.
For all the added size of sourcemaps in your project, you could probably optimize one or two png files and free 10x more network resources. If you want to optimize the JS itself even further and buy yourself more room for sourcemaps, you can compile your JS using Google Closure Compiler tools and remove dead/unused code. TraceKit itself seems to use Closure Compiler.
Although I haven't tried it yet, are their pre-made svg maps of countries and their states available?
Good point. In the mean time you can download the raw file from github https://github.com/riccardoscalco/textures/blob/master/textures.min.js. That is, this one https://raw.githubusercontent.com/riccardoscalco/textures/master/textures.min.js
pdfjs is great, but in my opinion we should get rid of pdf
&gt; is great, but in my opinion we should get rid of pdf And then use what as an alternative?
Oh neat, I didn't know we had an elected president of dev tools :P
I've found [this article](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch3.md) with a lot of samples and I think it's quite a bit better.
Something flexible, open, something that would make this post i.e. pointless
I can hardly wait for this to be embedded somewhere, and then see someone else write a Trojan Horse that executes it's own code using the lightweight, embedded interpreter!
&gt; And of course you'll again say that none of this matters to you and therefore it shouldn't matter to anyone else either. &gt; But seriously, being able to work around some downsides does not mean that said downsides don't exist. As I wrote below, this is especially true if working many people on a huge project over several years. People are not equally skilled and people make mistakes. Removing as many pitfalls as possible makes a lot of sense.
I went to a talk Rob Eisenberg did on Aurelia late last week. It seems to be a very forward-looking framework. His methodology for handling two-way data binding (and insight into Angular's problems both now and in 2) were very interesting. There are a lot of polyfills going on, but with planned support back to IE 9 it seems like a hella good start.
A while back looked at a few options for a similar type of project [jointjs](http://jointjs.com/) [draw2d](http://www.draw2d.org/draw2d/) [jsplumb](http://www.jsplumb.org/demo/flowchart/dom.html) In the end wrote what I was after from scratch using div's for boxes and generated svg for the links, heavily based on findings of assessing above 3.
A few quick points here to address some things that posters have mentioned: * Angular 2 has been in development for about 18 months. Yes, it's in alpha, just like Aurelia, but it's been in development for 3x as long as Aurelia. I'm not sure if that makes it completely new or not. You can decide. * The Forms Model example that is shown in "Part 2" has been in development for at least 6 months. It is intended, among other things, to be an alternative to two-way binding. I know because they had me work on it before I left. I worked on it in October 2014. Not much in the design or methodology has changed since that time. * Aurelia supports both Unit Testing and e2e testing out of the box. If you start with our skeleton, it's already set up for you and has some tests. We leverage ES6 modules and Dependency Injection in order to facilitate writing testable code. * Aurelia supports TypeScript just fine. We've actually participated in the design process for the ES7 Decorators proposal along side the EmberJS and TypeScript teams. * Aurelia supports a pluggable view engine and a pluggable binding syntax. So, if you want to write your templates in a different way, you just implement the classes and register them with the Dependency Injection container or even with the ES6 loader. For example, we have people writing Aurelia apps with Jade templates today. * Aurelia templates and view models don't leave out anything, nor are there any globals. Aurelia leverages Convention over Configuration by default, just like RoR. We can infer a great many details without the developer needing to write boilerplate configuration code. If you want to specify everything, you can. We allow customizing of the conventions as well as explicit configuration for everything in your app. But the conventions make sense for most cases, are simple to understand, and greatly reduce work. * Two-way databinding does not suffer from the same problems as Angular 1 because it is not implemented in the same way. We have an observable model, not a dirty-checked system. There is no digest and we do not have to keep running it in order to wait for the model to "stabilize". Our binding engine is adaptable and can be taught to observe different kinds of models. It also uses the browser's Micro Task Queue in order to perform efficient, automatic aggregation and batching of changes. Any-side effects to binding changes are processed as part of the same queue drain, and all of this happens as soon as possible and before the browser's layout/render phase. * Simple examples were used in the post because it makes it easy to see the differences side-by-side, not because we think all apps have two input fields. However, seeing the complexity level at a small scale is generally indicative of what will happen as your application grows. As far as Aurelia goes, we have several larger examples including our starter kit, a contact manager and several todo app implementations from the community.
You can still have meaningful markup without necessarily using IDs. You can locate tags by name, by class, by structure (i.e. parent/child relationships), and so on. For example, if you had an input element in a header element: &lt;header&gt; ... &lt;input&gt; ... &lt;/input&gt; ... &lt;/header&gt; You can attach an event listener to that using something like: document.querySelector('header input').addEventListener('keypress', function(...) { ... }, false); HTML5 gives you a lot of semantic elements to work with, e.g. `&lt;aside&gt;`, `&lt;main&gt;`, `&lt;footer&gt;`, `&lt;header&gt;`, and so on. I don't know why your goal is to eliminate IDs, though. 
The query selector seems messy to me. Even worse than getElementById(). My idea is to keep all DOM references as ordinary JavaScript variables. I believe the code will be much cleaner. It has to be tried in practice and not only with the small examples in the OP. I haven't done that yet and wanted to make sure it's something to examine further.
really good slideshow im totally mad i have to refactor 5000 lines of javascript now at that point its a jquery bug. especially $.html(str) being slow and .hide() being the slowest...
this is a good sln for that -- compile with something that can give u a sourcemap; log the error on server side, and match it up via sourcemap. dont serve the sourcemap just keep it on ur development machine.
The idea is to keep the DOM variables within components. Let's say a color picker component. The DOM variables related to the color picker would be contained within only that component. Convenience methods can be used for creating DOM elements instead of writing `createElement` and `appendChild` everywhere. If an app has a huge DOM, doesn't that make `document.querySelector`and `document.getElementById` very complicated?
For the love of god, avoid making globals by purposefully not putting var. It is just a nightmare waiting to happen.
* `+foo` -- convert to number * `foo + ""` -- convert to string * `foo = foo || "default"` -- set a default value (won't work if `false`, `0`, or `""` are valid inputs) But seriously, save the `!0` stuff for minifiers.
Why don't people just post a video of the presentation? Slide decks suck sweaty monkey balls.
Thanks for your answer. My attention is currently going somewhere else, but it's fun to see efforts for this.
But that's still like having all ids being like global "variables". Pretty horrible, isn't it?
That doesn't seem to be what the article is saying: "... in ES6 a const represents a constant reference to a value (the same is true in most languages, in fact). In other words, the pointer that the variable name is using cannot change in memory, but the thing the variable points to might change...."
For the love of god please use Math.floor, Math.ceil, and Math.round to convert floats to ints, and not something like |0. If it's ever in a piece of misbehaving code then it's going to be tough to find out exactly what it does in all cases. ParseInt may work on a floating point number, but you should only use it on strings. On floats, it yields the same number as Math.floor while you would usually want Math.round.
So you basically want to create an alias for getElementById? The way jQuery uses $ as an alias for "jQuery"?
Or just have everything with an ID be instantiated as a variable? That would be pretty straight forward to do. You could have a global object that's a collection of every DOM element with an ID where the variable to that object would be the ID. That would let you do something like: dom.colorPicker.addEventListener('change', someFunction);
For the default pattern I usually use this. It's a lot more verbose but after having to spend hours tracking down a bug because of the `foo = foo || "default"` pattern I vowed to never use it again. `foo = (foo === undefined) ? "default" : foo;`
Then the colorPicker has to be a DOM element. I read somewhere that extending DOM objects could lead to problems. The shadow DOM may solve some of that, but that looks like an ad hoc solution that just adds lots of complexity.
**Cast as a boolean** !!value First, not the value, which implicitly casts it as a boolean. Then, not it again to get the correct boolean value. **Shorthand for finding substrings or items in an array** if (~stringOrArray.indexOf(value)) { console.log('Value found!'); } Apply a [bitwise not](http://en.wikipedia.org/wiki/Bitwise_operation#NOT) to the number returned by `indexOf`. If it's -1 (not found), you'll get 0, which is falsy. If it's positive, you'll get a negative number, which is truthy. **Why?** But before you do this or anything else in this thread, ask yourself: why are you doing this? * Is it to save keystrokes because you don't want to type `Boolean`? If so, why don't you use an editor that autocompletes? * Are you doing it so your code is smaller in size? If so, have you heard of UglifyJS? * Are you doing it because you want your code to look cool? Don't do that. Please. My personal opinion? Instead of doing this: // WTF? var valueFound = !!~stringOrArray.indexOf(value); Just do this: // Makes sense var valueFound = stringOrArray.indexOf(value) !== -1; Unless you're writing code for the [JS1k golfing competition](http://js1k.com/), these little shortcuts just make life harder for those who must maintain your code (including your future self).
You need to capitalize the 'L' in Listener - the functions name is "addEventListener". https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener For questions like these, try to post related code on a website like JSFiddle (https://jsfiddle.net/), so other people can more easily help you :)
&gt; foo = (foo === undefined) ? foo : "default"; Huh? That's: if (foo !== undefined) { foo = "default"; } Use the ES6 stuff if you can: function whatever(foo = 'default') { ... } function ohai({greeting = 'hello', subject = 'world'} = {}) { return `${greeting}, ${subject}!`; } console.log(ohai({subject: 'peter'})); // hello, peter! The syntax for named arguments with default values is kinda ugly. Dart does this better: ohai({greeting: 'hello', subject: 'world'}) { return '$greeting, $subject!'; }
Well actually, I was just messing around with the shortest way to initialize an array with a set amount of variables to feed to Promise.all settled for `` var pages = new Array(pdf.numPages).toString().split(',') `` In *this* specific case I am against rewriting the code to use predefined functions since tearing it apart will create at least a page full of code with just one-line functions calling eachother, which is imo much less clear than this.
My question would be: why are ids needed at all? If the elements are referenced as ordinary JavaScript variables, then that's direct access. Why the need for first finding an element through a global heap of ids and then having to deal with the low-level details of what primitive DOM elements those ids refer to?
&gt;As I already told you a few times, block scope is nicer because declaring variables on first use works fine. Their lifetime is more restricted. They are more local. The declaration of most of the variables you'll be working with will be on-screen. The question is "How does block scope offer you any benefits over function scope." "They are more local", for example, is just descriptive. It doesn't tell you *why* that's a net positive. If you can't actually answer that, fine. At this point, I don't expect anyone to offer an actual reason. &gt; And of course you'll again say that none of this matters No, I'll ask how whatever feature you list benefits offers any benefit over function scope. &gt;But seriously, being able to work around some downsides does not mean that said downsides don't exist. What downsides? I've yet to see any. Lack of block scope hasn't caused me any problems. Which is odd, as i've seen block scope cause problems for beginners. (A rather common: They expect the sentinel of a loop to be available after the loop.) Of course, I won't claim that block scope is harmful, just that it's useless. I'd say I don't know why this is so controversial, but I think I know the reason. &gt; Having to use an IIFE like this also sucks: C# has block scope and you have the same problem. That has absolutely nothing to do with block scope, and everything to do with the behavior of for loops. I can't find the reference for that I wanted, but here's this: http://blogs.msdn.com/b/ericlippert/archive/2009/11/12/closing-over-the-loop-variable-considered-harmful.aspx
You're pursuing a declarative form of programming UI. That idea is good and well worth the exploration, because less id-wiring means more predictable code and that leads to a better understanding of what's going to happen when events are fired. As you've observed, ids are a fragile alternative because even though JS and HTML are separated, they're implicitly coupled to one another. By changing the HTML just a little your JS is broken, vice versa. Enter React and JSX. JSX allows you to separate the JS and the DOM functionalities completely, while writing the HTML literally as JSX in your JS. That's as declarative, predictable and separated as it can get. Separated because React works with a virtual DOM and manages the actual DOM for you. You just have to declare how it should work.
`eval()` is evil
&gt; That has absolutely nothing to do with block scope, and everything to do with the behavior of for loops. I just said that this *also* sucks. The handy for-loop iteration scope thingy is a feature which was copied from Dart.
I looked up JSX: "JSX offers a solid class system much like Java, freeing the developers from working with the too-primitive prototype-based inheritance system provided by JavaScript." I have my doubts about that. Douglas Crockford said that the object-based approach in JavaScript is actually more powerful than classical OO-languages like Java. Trying to force a class-based view on top of JavaScript is probably only beneficial because most developers are familiar with using classes. 
That's basically what I described earlier. A collection of variables that point to various elements. You'd still need IDs in the HTML though so that you could name your variables after them.
I think that's a different JSX from the one I referenced. Here's what I meant: http://facebook.github.io/react/docs/jsx-in-depth.html Even though I think JSX is good declarative form, it's possible to use React with just regular JavaScript. See the link. 
You are right, edited the article, thanks.
I don't think there is a good way to benchmark any of this without calling the responsible C++ functions directly. These engines cache stuff and their caches aren't necessarily cleared when you reload the page. They also do as much as they can in a lazy fashion. E.g. V8 doesn't compile functions before they are used. I'm also not sure if the AST exists at this point or if it was just cut into bits by a simplified parser.
"doesn't compile functions before they are used. " See... this is the behavior I was expecting, and want to exploit for a lazy-load. But I don't have enough certainty that this happens consistently.
Actually, native Object.observe does solve the problem of cascading updates because O.o uses the Micro Task Queue and cascades get batched to the same update queue as the triggering update. So, even cascaded updates are part of the same batch processing. Our "pollyfiil" also uses the Micro Task queue in the same way and thus, even with IE9, for example, we can have the exact same behavior as we would with Object.observe. In fact, at present, our polyfill is actually faster than Object.observe. As far as real world examples go, we have a number of very significant apps in development with Aurelia. We'll be making those announcements in the coming months. We are working on several official samples that show off much more than "hello world". If you are interested in seeing something that does a little more, you can always check out the contacts app I mentioned above. It's still relatively small, but demonstrates more than has been shown for Angular 2.0 yet, for example.
Awesome library! Seems like a really easy/nice way to implement color-blind support in color-heavy interfaces :)
As far as I know you also worked on the change-detection in angular with O.o, so maybe you can explain this to me: If O.o is enough to make two-way databinding work (fast and predictable), why did angular decide against it anyway for 2.0? I'm curious about the rationale. I think there has to be more to it, otherwise they could have replaced digest/dirty-checking by O.o and called it a day. I could find this quote from yourself: &gt; Actually, O.o wasn't that slow. It depended how it was used. An important thing to note is that it scales differently than dirty checking. O.o can handle larger sets of bindings easier, but might take more time to set up. Dirty checking might be quicker to set up, and is fast for a small amount of bindings, but doesn't do as well as things grow. Also, I say "might" because extensive tests haven't really been done to test a variety of scenarios and to test different aspects of performance, such as setup time vs. cost of notification. These two beasts are quite different in nature. [Source](https://github.com/angular/angular.js/issues/3601#issuecomment-61118490) I'm assuming a lot of work and testing has been done in both frameworks since then, so I'm not sure how relevant it is today.
It says "video coming soon" below the slides, so I assume it's just not out yet.
&gt; C# has block scope and you have the same problem. That has absolutely nothing to do with block scope, and everything to do with the behavior of for loops. &gt; I can't find the reference for that I wanted, but here's this: http://blogs.msdn.com/b/ericlippert/archive/2009/11/12/closing-over-the-loop-variable-considered-harmful.aspx[1] It even says at the very top of the article, with a bold **UPDATE** that this has been fixed in C# 5. It's been released in 2012.
Can you explain? What can you do with var that you can't do with let?
I still crack up every time I look at Javascript specifications...they are all .txt files...love it. 
&gt; But you have to be aware of implicit and explicit hazards. Sorry, I don't understand what you mean by that.
Yay native template subscriptions! The workaround was really annoying. 
JavaScript types are floating point numbers so this isn't any faster.
Yes. I saw it and am very thankful for that person. I just wanted to thank him in a video and record the actual pull request merge :) Will do it later this week.
TIL wtf is a TLD.
https://gist.github.com/tkmagesh/8d4df2e3d2527be2c0fb
http://i.imgur.com/d01CnKF.jpg
That comment `//*` one, is going to be my new time saver.
Nice find, thanks!
Great question! I actually did do work on one of the versions of change detection, the version before the present one. It was an intermediary version but was used to discover several of the flaws in earlier designs and led to many of the performance improvements of the present version. You can actually see the work here: https://github.com/angular/watchtower.js/commits/master So, to your question...the answer is...I don't actually know. I couldn't get a reasoned answer as to why not to go with an observable model. I guess...and purely my observation...dirty checking is sort of ingrained as part of the Angular Team's culture and so much time and money had been spent on it that it was very difficult for the team to realistically consider an alternative. It looked to me that they were more interested in dirty checking than they were interested in binding. In the end it was a pretty big point of contention because I felt that a number of restrictions and complexities that were being introduced in Angular 2.0 could be avoided if an observer model was used. There's more I would like to share about the story behind this, but I'm not sure it's appropriate to share some of the internal details unfortunately. Just remember that Google is a big company...and they have their own agenda. Regarding my quote from earlier, I've done significantly more work with O.o and observer binding models since then and have discovered a number of ways to make the system more performant. We're putting in place new benchmarking apparatus right now specifically so we can re-implement some of our binding systems internal details. I'm really looking forward to this because we're going to do this work in the public and I'm pretty excited to share with the global community the details of how we are going to make it faster. It's a neat opportunity to disperse some less well known information about JavaScript performance optimization. It's going to be interesting.
I'd suggest using a more pixelated font like "[Press Start 2P](http://www.google.com/fonts/specimen/Press+Start+2P)" or maybe whatever the font DOS actually used/uses.
&gt; So now I need to rewrite or refactor thousands of lines of legacy code written by someone else years ago when programming paradigms were different? If you have a function that's thousands of lines, you're going to save significantly more time in the long-run (and likely in the near-term) by rewriting that function. &gt; What if I really just needed to add a bit of if statements here and there and be done with it? You mean ADD to the problem? If your primary need for block scope is to make bad code worse, I'd urge you to seek out a different profession. &gt; Do you think this is a coincident? Who cares? The question I only want to know what advantages block scope offers over function scope. What I'm getting here is "how dare you ask!" If you don't have an answer, fine. Just say so, or say nothing at all. It's nothing to feel bad about, no one else seems to have a answer either. &gt; Or have you considered that, perhaps, you might be the one who enjoys a practice that is worse for everyone else? Aren't you the guy who thinks functions comprised of thousands of lines of deeply nested loops and conditionals should be left as-is? Like I said, you're the first person to have an answer. Block scope makes it easier to write terrible code. Thanks, I guess...
void 0 === undefined
Hi /u/TimTams553, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Most editors have keyboard shortcuts for toggling comments.
&gt; At some point, you have to ask the DOM for a reference to any element you want to work with. I doubt that. That's like saying that at some point C++ is needed because the memory will need to be accessed directly. That's only true for really low-level and native programming. For the DOM, having to access the whole tree to find an element sounds like a massive potential source of bugs and incredibly complex code that gets ever more difficult to maintain over time.
You're losing me here. Are you asking how browsers actually work or how they could work hypothetically? Because I'm not speaking hypothetically, I'm explaining how web browsers do in fact work in this regard. If you're asking hypothetically if there's some inherent need for ID attributes, then no. There are various other ways a web browser's scripting language API could be designed to allow interacting with DOM objects. Even so, you'd have to have a way to specify what element you're referring to and to do that directly, in an intuitive way, you'd need to have names. You can call these names variables or IDs but they're the same thing. A direct way to address an object in memory requires a unique identifier. If you want a less direct way to refer to a particular DOM object, you can use an integer index or some sort of hierarchical path such as XPath.
If there are cases where DOM ids really have to be used, that can still be contained within components. I don't see the need for accessing the whole DOM tree via ids.
I of course don't get the usage of the WTF example, but I've grown to like: // Short and sweet array search ~[].indexOf(key) // I get what you're saying, but its verbose, and you really can't learn `~`? [].indexOf(key) !== -1 If you truly only want a boolean value from an indexOf call, it makes sense to apply bitwise operations to get what you want. Plus if I ever see a '~' at the beginning of an expression, I can safely assume that the rest of the line is going to be checking the existence of a key in an array. Quick reading.
the problem is there are caveats when using bitwise shift to divide that make it incorrect.
Looks good, one thing you might want to consider is updating the gulp tasks setup to use require-dir. https://github.com/aseemk/requireDir
You're thinking of multiplying, not dividing. Dividing is perfect from top to bottom. It works exactly as expected. You do, however, need to remember that you're dealing with 32bit *Ints* with the familiar operator. Sensibly, JS includes both a signed and unsigned operator, so that you'll always get the expected results depending on your intention to divide or shift. (This is not the case in C, where the behavior of &gt;&gt; on signed Ints is implementation defined! JS got this one right.) Curiously, there are caveats when dividing normally as JS uses floats. They're the exact same problems every other language faces, of course, though I really wish they'd picked a different type! Multiplying, on the other hand, you've got to watch out for overflow, like every other language, and the fact that you're dealing with 32bit Ints. There is no unsigned left-shift operator, which is very frustrating, but it's probably what you want when multiplying anyway.
What a sad day...
I personally wouldn't throw on NaN, and just have the function isNaN in the prototype, which would also mean you could inline your tryParse. But if you do want to throw, just `throw new Error('... is not a number')` directly where the error occurred to get a good stack trace. Use Number(...) over parseFloat(...). Don't make a variable called `Set`, that's already a thing. I'd also leave it up to the user to provide polyfills if they feel it's necessary. Other than those points, looks good!
x + '' doesn't always convert to a string. ``` let x = { toString() 'Real string conversion', valueOf() 'Fake string conversion' } ``` Use `String(x)` to convert the proper way.
Sounds cool but ... how does hoisting work if you haven't even downloaded the entire script?
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 3. [**Non-equivalence of arithmetic right shift and division**](https://en.wikipedia.org/wiki/Arithmetic_shift#Non-equivalence_of_arithmetic_right_shift_and_division) of article [**Arithmetic shift**](https://en.wikipedia.org/wiki/Arithmetic%20shift): [](#sfw) --- &gt; &gt;However, arithmetic *right* shifts are major traps for the unwary, specifically in the treatment of rounding of negative integers. For example, in the usual [two's complement](https://en.wikipedia.org/wiki/Two%27s_complement) representation of negative integers, −1 is represented as all 1's; for an 8-bit signed integer this is 1111 1111. An arithmetic right-shift by 1 (or 2, 3, …, 7) yields 1111 1111 again, which is still −1. This corresponds to rounding down (towards negative infinity), but is not the usual convention for division. &gt;It is frequently stated that arithmetic right shifts are equivalent to [division](https://en.wikipedia.org/wiki/Division_(mathematics\)) by a (positive, integral) power of the radix (e.g. a division by a power of 2 for binary numbers), and hence that division by a power of the radix can be optimized by implementing it as an arithmetic right shift. (A shifter is much simpler than a divider. On most processors, shift instructions will execute more quickly than division instructions.) Guy L. Steele quotes a large number of 1960s and 1970s programming handbooks, manuals, and other specifications from companies and institutions such as [DEC](https://en.wikipedia.org/wiki/Digital_Equipment_Corporation), [IBM](https://en.wikipedia.org/wiki/IBM), [Data General](https://en.wikipedia.org/wiki/Data_General), and [ANSI](https://en.wikipedia.org/wiki/American_National_Standards_Institute) that make such statements. [*[page needed](https://en.wikipedia.org/wiki/Wikipedia:Citing_sources)*] However, as Steele points out, they are all wrong. &gt;Logical right shifts are equivalent to division by a power of the radix (usually 2) only for positive or unsigned numbers. Arithmetic right shifts are equivalent to logical right shifts for positive signed numbers. Arithmetic right shifts for negative numbers in N−1's complement (usually [two's complement](https://en.wikipedia.org/wiki/Two%27s_complement)) is roughly equivalent to division by a power of the radix (usually 2), where for odd numbers rounding downwards is applied (not towards 0 as usually expected). &gt; --- ^Interesting: [^Bitwise ^operation](https://en.wikipedia.org/wiki/Bitwise_operation) ^| [^Logical ^shift](https://en.wikipedia.org/wiki/Logical_shift) ^| [^Status ^register](https://en.wikipedia.org/wiki/Status_register) ^| [^Circular ^shift](https://en.wikipedia.org/wiki/Circular_shift) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cpjp55h) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cpjp55h)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Interesting handbook 
&gt; Again, that example has absolutely nothing to do with block scope. Of course it does. While it is an implementation detail of for-loops, it's something which only makes sense with block scope.
You don't have to worry about hoisting until execution time. Parsing doesn't have any need to wait. To be honest, I'm a little surprised they weren't doing this already! Seems like an obvious optimization. I'm sure there are plenty of complicated details I'm not aware of, though. 
&gt; Spartan is supposed to be an "evergreen" auto-updating browser. *Finally*. I'll be looking forward to this. :)
Fresh meteor dev here, could you please elaborate on this? I mean, why is it used for and what was the previous workaround to get this done? Thank you :) 
It might be easier to know that your prototype is built in one section alone. So, if you want to add things later, you know that you have to insert them in the `assign(...)` section without littering the codebase with several `Dispatcher.prototype`. At least that's what I think...don't quote me.
&gt;If you have a function that's thousands of lines, you're going to save significantly more time in the long-run (and likely in the near-term) by rewriting that function. Sure. But let's say I work for a small company that maintains a huge system over a long period of time. We don't always have the capacity to rewrite everything we'd like. Sometimes, we just have to fix some legacy code. It's not pretty but we have no choice. Would this be easier to do with block scope? Yes. Would JS be harder to program with block scope? No. &gt;You mean ADD to the problem? If your primary need for block scope is to make bad code worse, I'd urge you to seek out a different profession. Relax, Dunning-Kruger. Some people are in different situations than you. &gt;The question I only want to know what advantages block scope offers over function scope. What I'm getting here is "how dare you ask!" Seriously? You're just going to keep sitting in the corner with your fingers in your ears, screaming about how nobody can come up with an argument? This thread, along with the article OP posted and [this article](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch3.md) all come up with good examples of why this makes sense. We can present them to you but we cannot understand them for you. &gt;Aren't you the guy who thinks functions comprised of thousands of lines of deeply nested loops and conditionals should be left as-is? Yes I am. If legacy code does not present an immediate problem and something else presents a more pressing problem, the legacy code should be left as-is. Some of us work with very real time limits and budgets where we have to prioritize what needs to be fixed and what does not. Sure, the time will come to fix it but it's not always an immediate option. Remember that JS is the only option for frontend web development. People can't just say "oh, let's use perl instead of python then" and switch. We'll be stuck with JS for a long time and thus we need to make it as flexible as possible for the people who need it. Instead of acknowledging that, you keep completely disregarding the opinions of other people by just calling their arguments irrelevant and pretending you're the only guy who *truly* understands.
IDs are pretty bad anyway and you don't need to use them. Firstly, IDs create global variables just by existing, e.g. [this](http://jsbin.com/cugenilafe/1/edit) But tying JS and HTML so tightly can be really bad for maintainability and debugging and just about everything. You're also losing any server side rendering which is pretty bad in most cases. Some good practices are writing reusable JS components which look for classes; for example `js-colorPicker`. This is the pattern a lot of jQuery plugins use and it's really maintainable. You can easily change either the HTML or JS or CSS and nothing should unpredictably break. If you really want to do something like this, use one of the many tried and tested techniques, like React, Angular, or Web Components (Polymer or X-Tag), which all do self-contained modules in one way or another.
It does not.
Maintainability and stylistic hazards of always using let. Not to mention sometimes variable hoisting is nice.... For example if God for bid you had to use a try{}catch{} and wanted to use a variable after the catch... 'Let' would be lost in the try. Var would allow you to use it after catch because it's hoisted up. 
I used it with a couple of friends for a hackathon project over a weekend. Not the biggest community, but on [Github](https://github.com/kikinteractive/app) there are recent commits and issues so I think it's still supported. Very little to learn, just some basic life-cycle methods. CSS takes care of almost everything, it's simple to make a decent looking app. For rendering dynamic lists etc it uses Zepto.js (a lightweight jQuery-like library), so I think it might go well with Backbone as well. With the community being very small and documentation quote short; if you think you would have any problems that would be hard to solve, then go with something else; otherwise App.js should be fine for a simple quiz app
totally possible, that's how most companies seem to ease into it. And I'd say it's pretty well suited to those types of apps, one of the examples at react conf was a pretty complex looking ads interface.
Thanks for the code review! Great points. - Switched out parseFloat() for Number(). Tests still pass so no worries - Modified the Exceptions to be a little less over-engineered. - Renamed Set Also planning on adding an optional options object so you can just assume '0.00' for invalid values - things like that.
Great point. I modified the Computation prototype functions to just return this instead. That feels a lot cleaner. I would still prefer to keep number sets distinct from computations because I plan on adding some more collection focused methods (like stdev, etc). Not a bad idea though. Thanks again for the code review! I really appreciate it.
[Clickie](https://www.discovermeteor.com/blog/template-level-subscriptions/) Scroll down to "The Whole Thing" to see the complete workaround followed by a list of practical uses. 
Thanks for the read and the suggestion! I'll check out requireDir and see how it works. 
Well, if it's feeling awkward for front-end with JavaScript, maybe that is because it is. I'd suggest giving the [Elm](http://elm-lang.org/) a go since it's a language designed specifically **for** FRP on the front-end. It has a bit of a learning curve if you've never used a purely functional language, but it starts to make more sense as your application complexity increases as statelessness is key. If you needed some learning material, [U of Chicago](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/Schedule.html) posted course curriculum and the author recently posted [example architecture for apps](https://github.com/evancz/elm-architecture-tutorial#the-elm-architecture). 
Yes. It's just pleasant.
It's pretty simple to drop in. Instead of requiring tasks from index.js in your gulp folder, you just have a tasks folder and use the following in your gulpfile. var requireDir = require('require-dir'); var dir = requireDir('./tasks'); https://github.com/gulpjs/gulp/blob/master/docs/recipes/split-tasks-across-multiple-files.md
Yes, especially ES6. Refactoring js, on the other hand...
Once you know the quirks: lightweight, many libraries, many platforms (servers, shell scripts, robots, databases, etc.), good at both object-oriented programming and functional programming, malleable.
I personally enjoy using FRP for state management, I find that it starts being beneficial even in fairly small applications. I use it as a flux-like state management tool where Bacon Busses are used as actions and streams/properties are used as stores for my React views. Its a sort of hybrid FRP approach. I've written a few smaller applications using this model, and have found that state management was simplified a lot. This is a small example, but bacon js stuff at the top gets the point across. http://jsbin.com/pehawe/79/edit
Did you try react before asking that question ? sometimes I wonder why people waste their times posting things such as this.
I am trying store songs on my website.I want the user to be able to search and enter any song details in the forms e.g.artist name or title of the song then play the song. I would also want an audio tag bar showing the audio playing just above the Play,Pause buttons.There is one song far i am trying work on.If im not clear I am happy to explain again in the comments.Thanks in advance.
*Actionscript scowls through the window*
thank you &lt;3 i can't believe it was that simple i was staring at the document for at least 2 hours last night.. thank you dude. 
I used to think that JavaScript was inferior to Java. Recently I learned that JavaScript is actually a powerful language so I'm currently experimenting with object prototyping, function closures etc. I believe JavaScript will become even more popular than it is today, including on the server side. The class-based approach in JavaScript still sucks imo, while the object and functional aspects seem really good. I enjoy programming in it, although I must confess that most of the JS frameworks look too complicated to me. Node.js seems to have a lot of potential though, and I will probably look into it soon.
It has gotten *so much better* compared to (more or less) a couple of years ago, for the following reasons: * ES6 and up has landed, and is usable today through [transpiling](http://babeljs.io/); * We've got excellent frameworks now, such as [React/Flux](http://facebook.github.io/react/) and [Angular](https://angularjs.org/); * Package managers such as [npm](https://www.npmjs.com/) have rid us of having to do tedious manual dependency management; * Build systems are super easy now thanks to [Grunt](http://gruntjs.com/) and [Gulp](http://gulpjs.com/) and other systems; * Dev tools are much better now and vastly cut down on debugging time, e.g. the Chrome dev tools or [Firefox Developer Edition](https://www.mozilla.org/ja/firefox/developer/); * JS VM performance has vastly improved over the years; * JS code is now usable both on the client-side as well as on the [server-side](https://nodejs.org/). Everything used to be so tedious and annoying compared to other languages, but now that's all changed. The tools I mentioned aren't experimental anymore, either—they're mature and have stable codebases.
I do, but not as much as a statically typed language. I'm a little bit against projects like Node as it's not a very good language to run on the server. People get tunnel vision and try and do everything in one language. It's not always the best tool for the job. 
I love it, but wonder if it's some sort of Stockholm Syndrome...
First of all every language has its quirks, and javascript certainly has its own. That being said, what does it for me is its flexibility. Apparently objects with prototypal inheritance and first class functions is more than enough. It allows you to program the way you think. It doesn't make you think in a matter that everything is an object that inherits from more general ones, or think in a way that everything is a functions, or whatever. It lets you express yourself the way you think, it doesn't get in the way. So if you're having a bad day you'll end up with bad code. It doesn't help you not to be stupid, but it doesn't help you be smart either, it's a reflection of your thoughts without constraints (not in an absolute way of course).
Like I said, I haven't.
Thanks. I'll give it a go then.
Exactly. We've been working with others in the community, particularly EmberJS and TypeScript, to help define the ES7 Decorators proposal. It's looking pretty good so next week we are actually going to implement a decorator for this. It will actually look something like this in the end: export class Foo { constructor() { this.prop1 = 'prop1'; this.prop2 = 'prop2'; } @computedFrom('prop1', 'prop2') get bar() { return `${this.prop1} ${this.prop2}`; } } The `declarePropertyDependencies` api will then be used only for languages that don't support decorators. We may also even be able to do something like this in the end: export class Foo { constructor() { this.prop1 = 'prop1'; this.prop2 = 'prop2'; } @computed get bar() { return `${this.prop1} ${this.prop2}`; } } The decorator could use the getter function on the property descriptor and do some RegEx magic on the function body to auto-determine the dependent properties. Not sure if we'll add this in the end, but it's an interesting possibility we'll probably at least experiment with. 
Depends on the design of the API how easy it is; if the parser previously expected the whole contents of the file in one chunk it could be a fair bit of work to do so.
I love it. When I want to write functional code, I can, since I get first class functions. When I need an OO design, I can use es6 classes. It's evolving to become one of the most powerful languages available.
once microsoft gets involved its over.
 !0===true !1===false Save a few bytes... at the cost of extra operations (not, coercion), and probably waste more than a few hours on maintenance.
I've been using JS since it first came out in Netscape 2, and yes, I absolutely love it. I've worked in over a dozen other languages in the past 20 years and JS is still my favorite. Even more so since Node came on to the scene. Its structure, behavior and syntax just mesh perfectly with the way I think.
What is the bug in foo = foo || "default" ?
Most of these techniques are meant exclusively for code golfing, not for real life code (don't do that at home, kids!). But it's good to know the dark alleys of the language you use, don't you think?
It was just an example. Read it as, ``` var x = new Daisy(5); var y = x; x = x.add(5); ``` Now y is 5 and x is 10, because the add function doesn't mutate the current object. We're talking about completely different API approaches here though.
Some automation to more complex startup or prerending and or migration. Script to convert some DB information into HTML and SSH that to the server when certain enviromental variables are met. Monitoring for build passing and auto redeploy. 
Again, inline the error so you get the right line number at the top of the stack trace. I think it also misses the beauty of NaN: you can do a whole calculation without checking anything, and then at the end, check if the calculation succeeded. With your approach, you'd have to do the checks for each operation, or wrap the whole thing in a try catch statement.
I should know that !0 will evaluate to true, yes. I should also know that a=b will return b. I should -not- know that in context of a 'shortcut'. Code should be clear and intentional. !0 is a maintenance problem. if (a=b) {...} is not a 'dark alley', it's a readability issue. I would outright fail a review if I saw these 'neat tricks', and have a stern talk with my developer about how little consideration they have for the people who are fixing their defects.
Exactly, same here except I'm using the Meen stack instead of the Mean stack. 
:( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( :( 
I agree, that's fuckin weird.
I do enjoy it, because it pays my bills.
If you try to squeeze code into 140bytes of JS, readability is definitely not an issue. Please bear in mind that this code is meant to be written as a sport, not for serious development.
Can you explain? `(foo === undefined)` is evaluated into a boolean value in place and then used for the ternary expression. It ensures that the default is set only if foo is actually undefined, rather than a falsy value. I don't see how that would make foo equal foo + 'default'.
I do sometimes. I wish there was a better standard library. More along the lines of Ruby or Python. Every time I want to do something I need to find a third party library and then make the client download it. This leads to extra http requests and site size. It also leads to fragmentation because everyone is creating a library to do the same thing instead of improving upon the standard. I would take a better standard library over half the new syntax in es6.
I didn't call it a bug. I said I was chasing down a bug caused by that pattern. Often it's because the developer doesn't know what the requirements for the expression are. I'd still call that a bug. If the code doesn't do what the developer expects it to do, I'd say that's a bug, even if it comes from a misunderstanding of how the code works. I agree, both are valid it's just important to know what the needs of the overall program are. I've generally found that it's safer to check for undefined as that's usually what I want. 
You could even statically generate the JS file and insert the JSON into it. Then there is no need for an Ajax call.
Ah, fair, I read it as 'a bug in the pattern', not one enabled by it. 
It looks like the code is not transpiled, but preparing for the future where ECMAScript 6 includes `Object.assign()` (after which the package `object-assign` seems to be modeled).
Thank you, really appreciate it! 
pretty satanic duration you chose there, mr. evil helping friend. Do you think there's any easy way to create a JSON file like that from, oh let's say, a thousand mp3s?
Yes. Pretty much since all the browsers got good debugging tools, it has become a lot better. As i've learned the language more, and started using ES5 &amp; ES6 features it's gotten even better.
Depends, it could well be that you don't need it, but it can be useful for automating certain tasks. For example, you could push to SSH automatically with key authentication. Also, if you have Less/SCSS you'll need to compile that to CSS. If you have other tasks that need to be run, like checking your code consistency or style, that's yet another task. Personally I also have some automated tasks for converting templates into HTML, minifying my code, crushing PNG files, copying over static files to a public directory...and some other stuff. What Grunt and Gulp do is provide a framework to easily automate tasks like the ones I mentioned. It's not necessary by any means but it can simplify this sort of automation.
You could also use the rewire or proxyquire packages, which allow you to override dependencies inside the module you're including
It used to back in the day (https://github.com/douglascrockford/JSON-js), but not anymore. Modern browsers have JSON.parse now, which does *not* use eval. &gt; The parse method uses the eval method to do the parsing, guarding it with several regular expressions to defend against accidental code execution hazards. On current browsers, this file does nothing, prefering the built-in JSON object.
Yep. That is a very good suggestion :)
Yes. You can ex. scan a directory with all the songs and generate said file. Node is excellent for this (but just about every other language out there has JSON transcoders by now) :)
Hey, I didn't know you lurked around these parts! Off-topic comment: Thank you for everything you have done with Browserify. After years of RequireJS config hell, you helped make writing modular JavaScript fun again.
Unless something has changed in the last couple years, debugging GWT was simply a matter of turning on the debugger browser plugin and debugging in any ide directly in Java. You never had to look at the javascript unless you were doing some really compiler level stuff. It was a bit slower, but otherwise easy.
Microsoft is pretty committed to NOT building a framework. They are most interested in building tools for whatever libraries their developers are interested in.
Heh, *dev mode* never worked that great. Firefox 24 was the last supported Firefox browser. Chrome's browser struggles immensely for some reason to run it efficiently. Even then, standard *dev mode* allowed you to debug from an IDE. *Super dev mode* is now the default in GWT 2.7. You have to pass the flag `-noSuperDevMode` to go back to the old way. *super dev mode* only allows you to debug in the browser with source maps. IntelliJ streamlines a lot of setup for you, but Eclipse is a freaking pain to set up. And then there is the CLI. So much boilerplate and debugging issues for such little gain...
Lexing/Parsing can be done in a more or less in a single pass, and can easily be done 'incrementally'. While still expensive, they are faster (wall clock time) than network IO. So instead of sitting idle waiting for network io (downloading the JS), they now start lexing/parsing what they have so far. That way when the download completes, they're also done parsing. In the old model they wouldn't even start parsing until then.
Nice work!
Ahh. I only used the standard dev mode. I stopped using GWT just as super dev mode went into beta.
Yeah, that's exactly right. It's to avoid writing `Dispatcher.prototype` over and over. Another common approach is: var Dispatcher = function () {}; Dispatcher.prototype = { constructor: Dispatcher };
I enjoy all kinds of programming
Lodash.js
Maybe he is not as skilled as you man. Try to be helpful instead of a pompous asshole.
Ember.js
Node is a javascript runtime that runs on a server. not sure what else you might mean. There are some JS build tools and testing tools that utilize Node to simulate the client side environment, but that doesn't mean Node isn't a server side JS runtime. That's what it is. Its not anything besides that.
It's a bad idea because of a bug in IE&lt;8 and several other reasons (read this: http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/) ~~If you're using ES6, no problemo, go ahead-o (see http://babeljs.io/docs/learn-es6/#subclassable-built-ins). But you have to use a transpiler with polyfills like babel because no browser has implemented this feature yet (see http://kangax.github.io/compat-table/es6/#Array_is_subclassable)~~ EDIT: Oops, I stand corrected, you **cannot** subclass Arrays in Babel/transpilers: &gt; Built-in classes such as Date, Array, DOM etc cannot be properly subclassed due to limitations in ES5. http://babeljs.io/docs/usage/caveats/#classes
rapid page loads
Heavily disagree with the AngularJS comment. React is backed by Facebook and is actually being used heavily throughout their site. They also are releasing React Native soon which allows you to actually build native applications instead of a hybrid application.
The [multiline](https://www.npmjs.com/package/multiline) package does exactly this. It's how we write large sql queries in our Node services. edit: Also, ES6 template strings will support line endings.
&gt; die soon with no migration path Apparently they back tracked on that and components from angular 1 will function in angular 2.
In this specific use case, frontend DOM templates, I find the script type=plain/text trick to be better as it separates concerns better. In HTML5 we have the template tag, which is even better, though last I checked it wasn't available everywhere yet. 
Yes hybrid still sucks and angular performances is a disaster on mobile,especially with Ionic that is even slower than vanilla angular. And frankly with Swift today ,there is very little excuse not to go native on IOS. I love js, i'm a big fan of angular but the right tool for the job first and foremost. Or at least use something like Titanium so you get real native UI. and yes , users will notice the difference. they are not stupid.
your development machine is a local server. when you serve your website over localhost that's what you're doing. for a web application there is always a client (the part thats runs in a browser) and a server (your dev machine, or your production server). when you run a tool like grunt you're running it on the server. it certainly isn't running in the browser. that's besides the point anyway. the post to which I responded said "there's an enormous client-side developer ecosystem flourishing in node". which is untrue. there is an enormous ecosystem of developer tools (which are sometimes also used on production servers) that is flourishing with node. node is server side technology, even if some of the tooling is used to assist front end development.
I feel like a b̶e̶g̶i̶n̶n̶e̶r̶ anyone and everyone in io.js/node would benefit from using `fs.createReadStream` instead of `fs.readFile`. So rather than: http.createServer(function(req, res){ fs.readFile('test.html',function (err, data){ res.writeHead(200, {'Content-Type': 'text/html','Content-Length':data.length}); res.write(data); res.end(); }); }) They would write: http.createServer(function (req, res) { fs.createReadStream(__dirname + '/test.html').pipe(res) }) 
This is where promises come in handy. With ES6 it might look like this: Promise.all(someThings.map( x =&gt; x.load() )).then(doSomething) Another common pattern is using [async](https://github.com/caolan/async).
&gt; var operations = 10e5; // 1000 That's 10 with 5 extra zeros. 1,000,000. Also, what the fuck is that even supposed to benchmark? If you toString your numbers, you'll have a bad time. I also recommend to use something like [jsperf](http://jsperf.com/) for silly micro benchmarks.
Sounds like you need to try coffeescript
If your problem is that `i` changes before the `.then` callback is called, you're going to want to "catch" the current value of `i` before continuing, by creating a new scope with its current value in it: for (var i = 0; i &lt; 10; ++i) { // create and run an anon function with // the current value of 'i' as a parameter (function(i){ whatever.loaded().then(function(){ if (whatever[i] &gt; 10) console.log("Pass") }); })(i); } Or alternatively: for (var i = 0; i &lt; 10; ++i) { whatever.loaded().then((function(i){return function(){ if (whatever[i] &gt; 10) console.log("Pass") }})(i)); }
&gt; cargo-cult accept that === is the right operator It's only cargo-cult-ish if you don't know the reason. === works like the equality operator in most other languages. If the types aren't the same, the two compared values aren't equal. `"5"` isn't `5`. `[]` isn't `""`. Makes a lot of sense to me.
I don't mind it, but I'm a lot happier writing (and reading) coffeescript (in before haters). ES6 syntax and features look like an improvement, but not a massive one in this aspect.
It's easier with types. No one has 100% test coverage. If you add type annotations to the signatures of functions, you'll have at least that part 100% covered. So, if the signature of one of the functions changes, you'll be told about all the call-sites which pass the wrong parameters or which do something seemingly odd with return value. This makes it easier to move things around and it also catches the majority of breaking changes in 3rd party libraries. Without this safety net, you'll need to write a lot more tests. If you haven't written a serious project in a language with types or optional types, I highly recommend to give it a try. It really does make some things quite a bit easier.
Is it ever actually a problem to just leave the white space there? e.g. http://jsfiddle.net/z06a2gxx/ 
What, exactly, is that fiddle illustrating? I see no JS.
The blur animation of show makes it looks like it's lagging/broken, I'd fix the default up a bit.
&gt; extjs THE HORROR
This has nothing to do with whether or not whitespace matters in HTML. This is about whitespace in a string, in JavaScript. Have you ever had the misfortune of doing DOM templating in JS? Take a look here: http://jsfiddle.net/w78e6Lcq/1/ Because of the whitespace, you'll get syntax errors.
No. It's a horrible language. 
I have tried it, and I like it. I expected to like it, since I've done lots of programming in Ruby and Python and like both of those languages too. If I was starting a new project from scratch I would choose it.
In the last months I've been writing most of the scripts I needed (for kind of any purpose) in JavaScript (NodeJS) rather than Python. I *love* how everything's non-blocking and asynchronous. I *love* the load of great tiny libraries that infest github. I **love** how fast and painless it is to install all the dependencies you need through NPM. I *love* how many different paradigms are available to do anything, and you're free to pick the ones you prefer. Yeah, the language itself has its own quirks (many and big! D: ). There are many languages that are plainly better than JS, but man, it's not *that* terrible (just think of Perl or PHP, if you want something really that terrible :P), and the ecosystem is the best one by far.
I would agree, even Xamarin you need to edit the layout
Hence the question. It was a question, after all. And using HTML as the example kind of leads one to believe it might be to do with markup.
Are you high?
I use a sting array syntax. var str = ['&lt;div&gt;', 'More text', '&lt;\div&gt;'].join('\n'); No regex, which makes me happy. When the text gets large I switch to lodash templates.
Loved it. Using it in production already. :-) 
/u/mattdesl's solution is probably the best way to go, but implementing this with a for loop is sometimes an interview question and it's worth writing this manually someday if you're bored/curious. One approach is, start a counter at zero and increment it for each finished task until `count === tasks.length`, at which point you're done and can move on. Try out serial and parallel versions. Async is fun!
Once you learn your way around the pain points you can do really advanced things with amazing speed. You don't any OOP boilerplate nonsense to write large elegant applications.
Firefox already had it.
You don't see the irony in the pedant attack, do you? ;) Now, write it on a Turing tape. And then write a program on a Turing tape that can prove that it halts. The difference being your for loop has no input, no "side effects," and has no output. It is, essentially, not a program at all. It is a syntactic anomaly. 
Have you tried any of the [flags](http://www.chromium.org/developers/how-tos/run-chromium-with-flags)? I don't know how current it is, but [this page](http://mrale.ph/blog/2011/12/18/v8-optimization-checklist.html) might help as well. Otherwise you might try the [discussion group](https://groups.google.com/a/chromium.org/forum/#!forum/chromium-discuss) or [search for issues](https://code.google.com/p/chromium/issues/list). Sorry I don't have the answer for you.
Where did you find this code? It really isn't very good... For one, the `.bind(this)` doesn't serve a purpose. Also there are a bunch of needless global variables. But forgetting that... Quickly moving the callbacks to their own functions really works wonders for readability: function handleError(err) { if (err) console.log('Error writing file: ' + err); } function readFile(filename, fileIndex) { console.log(filename); function resizeImage(width, widthIndex) { height = Math.round(width / aspect); console.log('resizing ' + filename + 'to ' + height + 'x' + height); this.resize(width, height).write(destination + 'w' + width + '_' + filename, handleError); } function handleImage(err, values) { if (err) { console.log('Error identifying file size: ' + err); } else { console.log(filename + ' : ' + values); aspect = (values.width / values.height); widths.forEach(resizeImage); } } gm(source + filename).size(handleImage); } fs.readdir(source, function(err, files) { if (err) { console.log('Error finding files: ' + err); } else { files.forEach(readFile); } });
Neat trick. But, how about just using a hidden DIV containing the desired HTML elements? That would allow you to access the fully parsed DOM object directly or its text using innerHTML.
Absolutely. It's even more obvious when you end up with an iOS-like theme on Android or vice versa. I actually had a discussion with someone the other day about performance, which slightly amused me; he pointed out that lots of "native" Android apps had poor performance and kind of looked like iOS, so why bother with native development if using something like Ionic worked about the same. I pointed out that poor performing apps that had vaguely iOS like themes were probably not native at all. It's frustrating to realize that many people have simply come to expect that kind of performance in a mobile app, and have fallen prey to the impression that JS wrapped web pages are "native".
What is language at all, but a syntactical anomaly?
Flags were tried, common mistakes was fixed. 
Thank you for support! :)
Looks good, could be an alternative to toastr.js
Thank you so much kenman! This is awesome. Just got back to my computer and am looking into it now. I love how there has been so much activity on the doc already, thank you everyone that has contributed! I'm answering questions and resolving comments as fast as I can.
My comment about ternary operators is correct. "Conditional operator" is another name for ternary operator. That's why the text refers to three expressions. "The conditional operator works in a similar way. The first expression is always evaluated, but the second or third value, the one that is not picked, is not." From wikipedia (http://en.wikipedia.org/wiki/Ternary_operation): "Since this operator is often the only existing ternary operator in the language, it is sometimes simply referred to as "the ternary operator". In some languages, this operator is referred to as "the conditional operator." Thanks for pointing out the typo where isNumber should be theNumber. Just fixed it.
just use slice and you can avoid the manual array construction. You can see my reply above.
&gt; There are two hard things in computer science: cache invalidation, naming things, and off-by-one errors. So it appears that the hardest things for me are maintaining formatting and avoiding typos :( 
so like. make a program that adds two numbers together. then make a program that let's you input numbers using your input setup. then combine the two. step 1: let the user enter one number, wait for them to press plus let them enter another number, wait for them to press equals, return the sum step 2: let the user press the inputs to tell you some number step 3: combine
You can obfuscate your code so that a computer can't easily access the game state and therefore the computer would need to use the same interfaces a human would (reading the visuals and simulating input). You can't get around input simulation. This is easy for a not to do. So that leaves visually interpreting the game. It's hard to circumvent this. You can make it harder to visually interpret the game by for instance using weird shaders. It might make your game less easily readable for humans as well, but on the other hand it could give a psychedelic vibe ;). As for sending score to server, if you want the server to check that the way the player got the score is legit, you need to send all input the player did to the server as well. The server could simulate the whole game and this would result in the score.
You can put everything in a closure and try to disable debugging. Still not 100% safe from cheating.
Not quite sure how I feel about this article. 
You wouldn't. If they cared when it happened, they would have to check manually.
This is great. I've been struggling with wrapping my head around some of the concepts of the book. I'm new to javascript (and programming in general). I've spent so many hours on understanding Chapter 7. I combed through it and started writing in my own words my interpretation of the code into a document to help myself map through everything that's going on in the program. I feel really dumb that it's taking me so long to understand it :(
 Also, how do I lock it down so that I can't just send win events to the server and cheat the game that way? I know some games solve this by sending the exact user input that lead to a supposed win. The server then simulates the input and figures out if the simulated game actually won. This makes it like so that the user can send 1000 win events, but if the server can't win the simulation with the supplied input pattern the win is then invalid. I do not take a position on whet ever this is a good idea to implement, but I guess it could work with smaller / simpler games, say tetris or something.
Woot! This made it to #1 on Hacker News! http://imgur.com/Zdf46Au
Hi Marijn. Really sorry about that. Just added it right at the top along with the license. This started out just as a project to help out some fellow Redditors in a random Slack group that was created a few days ago, so apologies that I didn't put it up there to start. Thanks for authoring such a great resource. Like so many others, Eloquent JS was one of the first books I used to learn JS and programming, so I really can't thank you enough.
At a very basic level, you can just run a local js file in your browser. If you need to do more advanced stuff, you can use a simple script to act as a host for your files. Google Chrome also has a built-in console (other browsers do too by the way), just press f12
Except that this doesn't work when you use any form of tooling, e.g. pretty much all minifiers will remove your "multiline string" (as they should). For the love of god, please don't use this. If you need large multiline strings then: - Use ES6 with backticks - Place it in an external file and load that (either at compile or at runtime) - Use a template engine - Put the lines in an array, and then join But don't use this. 
This thread has been linked to from another place on reddit. - [/r/badcode] [Because comments are the perfect place to put your multiline strings](http://np.reddit.com/r/badcode/comments/2zol53/because_comments_are_the_perfect_place_to_put/) [](#footer)*^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote. ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
I love the internet... I really do... bossier330 props... I presume you are the guy that made it?
Do you want to make one or help out an existing one? If you want to make one just keep to the js programming style guide https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml If you want to support, try to adhere to the style of the authors code since they will be the ones maintaining your contribution when merged in. Good documentation, comments and examples are always great :)
Just curious but why not react? I've been looking through these 3 and I never really liked angular. 
Relay is more suitable for large applications.
Your politeness is hilarious. I'd be pretty pissed if I were you.
\#58FAAC is not valid JavaScript. It should be a string "#58FAAC".
If you want some nativy enhancements, checkout [Supersonic](http://www.appgyver.com/)
http://sanestack.com/
I don't consider loading two libraries until you can rewrite things a migration strategy. There is still no clear path of how I turn my 1.x code into 2.x code. As far as features, from what I've read about 1.4 it seems the only big new features are ones that happen to be applicable with 2.x, but most of the core team is focused on 2.x. 
Yes it integrates nicely the best parts of the both worlds.I have been playing with it recently. Nice Opensource product which I dearly recommend to check out.
It's my favourite language
* Open your IDE * Create a new .html file * Add JavaScript to it * Find the file and right click it * Open it with Chrome * Your JS will run You can also open [Chrome Dev Tools](https://developer.chrome.com/devtools) and select the "Console" tab. Then just type your JS there. You can do that on any web page/site
Or look for 'javascript calculator' on google. For instance, for me the first link is [this](http://thecodeplayer.com/walkthrough/javascript-css3-calculator) 
This is a poor way to solve this problem unless you are dealing with some very complex games. An easier solution would be to limit the amount of wins you can get during X where X is less than the average game time
Are you looking for something like this: https://github.com/airbnb/javascript
Single- or double-quote strings automatically terminate on new line though. 
Flux is a subset of this architecture. This is their diagram of how Relay applications work: http://facebook.github.io/react/img/blog/relay-components/relay-architecture.png The Store -&gt; Components -&gt; Actions loop in the lower-right corner is your basic Flux loop. But Flux only covers unidirectional flow within an application; it doesn't really outline a good way to interact with the server. Relay adds all server interactions in a way that precludes you from adding a new AJAX call (and corresponding API endpoint on the server) for each bit of data you want to show on the client. 
I did this with [Nevergrind](http://nevergrind.com) and it helped quite a bit. When I create a "build", I concatenate and minify my javascript into one file, wrap it in a closure, and upload it. Keeps out amateur hackers at least. But if they are determined and skilled enough they will figure out how to set break points in the code. Nonetheless, this simple step along with minification does make it a lot harder. If you write your code in a manner that allows for obfuscation it's even better. Unfortunately I didn't have the foresight to do that as my code often relies on string building to call functions.
I want to say no,... this breaks more than it fixes. Data being loaded via a channel usually has to be studied a bit by the javascript and it usually preforms more than 1 action.
I'll try to keep this as objective as possible. * babel is the future, it lets you use the JavaScript of tomorrow today and so on. You'll be writing ES6/ES2015 eventually anyway, so it's the obvious choice. You can still pick up a few to-JS languages further down the road, but a good understanding of JS won't ever hurt. * Node.js is the status quo. Io.js is not intended to be a replacement, although many have been treating it as such. Unless Joyent screws this up (which they very well might), io.js will eventually be merged back into Node.js proper. But until that happens it's probably a good idea to keep an eye on io.js to see where Node.js may be going. For production, you should probably stick with Node.js for the foreseeable future, though. * Koa is neat, but it relies on ES6 features that aren't activated by default in current JS engines. It's interesting and may indicate how we'll build Node.js apps in the future, but right now Express is a lot more popular (though it'll get you a lot less geek cred). Get a solid understanding of Express, then give Koa a spin (and look into other frameworks like Hapi, too). It's a good idea to understand the problems something solves. * React is hot shit. I love it and personally I think it's the future of frontend development in JavaScript. But with that said, I'd recommend getting a solid understanding of vanilla first. Don't bother learning about IE8/legacy compatibility, it may have become irrelevant by the time you're done. For simple web pages jQuery (or an equally battle-hardened set of tooling) will still be sufficient. * I personally don't see Meteor going anywhere, but it might be worth a look when you're done with everything else. There is so much hype surrounding it it's impossible to determine how much attention it actually deserves, so I'd be wary of that. If nothing else, it may give you some alternative ideas. * AngularJS is yesterday's hype, but it seems to be amazingly well-established. AngularJS knowledge seems to be marketable than React knowledge at the moment, so it's a good choice if you desperately need a job. The market seems to be pretty saturated right now and with AngularJS 2 around the corner, now is probably a bad time to get started with it. I'm not sure how AngularJS's success will translate for AngularJS 2 either. * If you want to be a "full stack" developer, you should also look into databases. MongoDB is a popular choice in the Node ecosystem, if only because it is popular. It's worth taking a look, but you'll want to make a more educated choice when picking a database for production. I'd also recommend taking a look at ArangoDB because it lets you write JS directly in the database, but I'm biased (I'm a maintainer). There are other JS-oriented databases, too. * Bootstrap is a difficult one to answer. If you want to be a full-stack developer doing frontend, you should also have at least a working knowledge of CSS and be fluent in HTML. Bootstrap is a good way to get started with prototypes but I'm biased against using it for production. Think of it as the IKEA of frontend components. It's workable and looks good, but everybody knows your furniture and how much you paid for it.
And unnecessary. 
[this should do the trick] (http://m.linuxjournal.com/content/tech-tip-really-simple-http-server-python) 
This is some kind of joke...right ?!
http://stackoverflow.com/questions/3075577/convert-mysql-datetime-stamp-into-javascripts-date-format http://stackoverflow.com/questions/1765803/convert-a-mysql-date-to-javascript-date Basically, dates can be represented differently in any programming language. You may well need to parse the date in any language you have or it may have a built in parser for you. 
Seems everyone in the thread is opposed and I'm too new to JS to know why. Would anybody bother to explain the opposition?
I feel like someone just wanted to make a big dick joke with this one.
Probably not exactly what you're looking for, but still interesting. There are two npm packages for checking code styles: https://www.npmjs.com/package/standard https://www.npmjs.com/package/semistandard The second package is the same as the first, except that it allows you to use semicolons.
Arbitrarily paired quote characters! Bestest feature ever! "PeNgU1N oF d00m"-style quotation. Such random. Wow.
&gt; You must include testing. It will soon be a requirement for any new, serious projects. I would say that this is already a requirement for any new (or old), serious project. Glad to see that pointed out. 
It's like, super cereal for reals. Because reasons. \#strokehaiku
Yep. I listened to the random mix for wayyyyy too long.
The guy clearly has no experience doing anything in JS. He sounds like someone who read a few framework tutorials, got confused, and just dreamed up this whacky solution. Here are some reasons as to why it's awful: * **Most importantly**, this is the opposite of the purpose of HTML. HTML is a markup language that defines a document's structure and has nothing to do with "apps". The application side is left up to JS, and styling is up to CSS. Having these functions overlap leads to a chaotic mess. * Most calls to the server to get data are usually passed through more logic in JS to convert values, calculate totals, etc. So this non-JS approach is only good for static content. * He suggests allowing SQL statements in the href. This is the worst idea possible and makes me think this whole proposal is a joke. It is completely and utterly susceptible to SQL injection (Anyone could change the query to "SELECT password FROM users"). Plus, SQL isn't the only database language, and favoring one language is against the idea of the W3C. Additionally, this also implies there's no standard way to send data back to the client. SQL certainly doesn't output data that looks anything like that weird XML format he uses, so you'd have to have some way to specify it. * Lack of flow control (if, while, for) severely limits the usefulness of this and would mean you have to resort back to JS anyway to accomplish these tasks. Existing templating engines like Handlebars solve this problem already. All of this could just as easily be accomplished in JS in a much more flexible way that supports all back-end systems.
 var mystring = "\ this works \ just as \ well! \ ";
Based on what /u/Knotix said I think we can boil the problems down to: Breaks [Separation of Concerns](http://en.wikipedia.org/wiki/Separation_of_concerns). 
I understand the opposition (at least several of the arguments), but this is probably something best solved by the browser, not by ad-hoc javascript implementations. The counter-example I would point to is the [whatwg datetime input](https://html.spec.whatwg.org/multipage/forms.html#date-and-time-state-(type=datetime\)). Instead of every datetime input doing their own, ad-hoc, slightly broken, non-accessible implementation, we do it once and let the semantics take over. Channeled loading makes sense to hand off to the browser, since the browser would know best how to handle it: pipelining, parallel requests, or the server could eagerly send it (HTTP 2.0 does this). The JS implementations are just as much a hack as dynamically adding image nodes instead of using &lt;img&gt;.
https://twitter.com/sanestack/status/576782858146086912
[**@sanestack**](https://twitter.com/sanestack/) &gt; [2015-03-14 16:32 UTC](https://twitter.com/sanestack/status/576782858146086912) &gt; Want to know what the A in SANE stands for? Any database - check out http://www.programwitherik.com/how-to-connect-sails-js-to-multiple-databases/ from @ErikCH to learn why!. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Well, yeah they let anyone make proposals. That's how an open committee with an open mailinglist work. I'm pretty sure nobody will take him seriously though.
&gt;More advanced link URLs could include SQL statements - “&lt;A href=“http://...“&gt;" becomes “&lt;A href="sql:select from *”&gt;". The author has no concept of web security.
Yes, agreed. And those who are opposed to it are often thinking about it backwards. When you develop something, you *are* already testing it in *some kind of way* since you have to see if it actually works. Be it a test script, a test page or something else. Testing frameworks just create a more stable structure around this, automating everything for you. Sure, testing adds some additional work but much of it you'd have to do anyway manually. It not only serves as a way to test if something works but also provides a great piece of documentation for other programmers that need to find out what the code does. Even non programmers can often read a test and figure out what a certain piece of code does from that. On top of that, it enables you to fix other peoples code without worrying about whether you broke something else in the process. Run the tests and they will tell you. Everything becomes much more maintainable. (You probably already knew this, just wanted to point it out if people in here were wondering...)
Plenty: * http://contribute.jquery.org/style-guide/js/ * https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Coding_Style * http://dojotoolkit.org/community/styleGuide * Crockford's http://javascript.crockford.com/code.html
Your method is also faster. Unlike most other languages, `str + str` is faster than `[str, str].join("")`.
You picked up on that, did you?
Do keep in mind that the datetime input was introduced around 3 years ago and still has no traction or buy in from anything outside of Blink. Similar to this, to cover a wide array of necessary features it would become far too bloated. Meanwhile there are plenty of patterns available mixing other available HTML standards with JS standards. 
Except HTML5 was finalised and published as a standard last October.
[this](http://gmaps-samples-v3.googlecode.com/svn/trunk/styledmaps/wizard/index.html) is a useful tool for styling google maps. there only appears to be one category for water. [here](https://developers.google.com/maps/documentation/javascript/reference#MapTypeStyleFeatureType) is a complete list of map "features" that are available to be styled 
I was curious if there was a way to divide the water feature into a hierarchy like the road feature above. Doesn't seem like it. Thanks though!
You forgot &lt;a href="sql:select * from table" user="hiMom" secretPassword="dontlookhere"&gt;&lt;/a&gt;
That's awesome! Way better than I could build.
Agree that Angular is slow and ionic is slower. But performance of the web apps are not bad. Android 4.0 was as not that good, but its been improving ever since. Its very close to native on both platform. It also allows developer like me to have an app on iOS and Android. My app on iOS and Android has 4.5 star ratings. iOS: https://itunes.apple.com/us/app/hacker-news-yc/id713733435 Android: https://play.google.com/store/apps/details?id=com.premii.hn Or you can try it out on the web; http://hn.premii.com/ If I had gone native, my app would have been only on one platform.
&gt; Can DICSS be extended?
I'm going to get filthy rich when I can run sql queries on other peoples websites ;) 
Heh... that's because it's not an "article", it's a book chapter! But yes, it has many more examples. Kyle and I have discussed the topic quite a bit, actually, and his opinions are slightly different than my own.
We will see. I predict that all-JavaScript websites will become commonplace. With developer tools the HTML design and the JavaScript code can be separated automatically and still remain within the same code.
Yes, I found: http://davidwalsh.name/multiline-javascript-strings Will definitely try it (I'm new to using the full potential of JavaScript).
Thank you. At least _someone_ has a sense of humor.
well some folks think it can pretty much do anything anywhere: https://atom.io/
There is no such thing as an error for no reason.
Or they could compare them automatically, with a framework.
That's the problem I am finding. There are som many people with different opinions each with some good points but I don't know enough to make an informed decision. Maybe I am to old for the changes coming. :)
&gt; What does static content have to do with converting values? When you pull data from the server (for instance, in an AJAX call), you typically want to do further processing in JS such as summing numbers, converting dates, caching the data to be used in other parts of the page, etc... The proposal completely skips JS, meaning the data must be completely processed on the server. This forces you to use a [thin client](http://en.wikipedia.org/wiki/Thin_client) and actively prevents a [fat client](http://en.wikipedia.org/wiki/Fat_client). ----------------------------------------- &gt; Out of your entire reply, this is the part that's so stunningly thoughtless that I can't bring myself to give you a polite response. Is the shell, then, "completely and utterly" insecure because I can type whatever I want into it? Are banks insecure because I can ask for other people's money? Name-calling. You're thinking I'm afraid of you, the developer, typing something stupid. Wrong. I'm afraid the **user** will type something stupid. A malicious user can right-click, inspect element, and change the query in the HREF attribute to run any query they want to. They could steal credit card numbers or drop databases. This is giving every user of your website permission to run any query they want just by changing the attribute. The very fact that you misunderstood this argument tells me you don't know what you're talking about. ----------------------------------------- &gt; What "tasks"? That's the question. Nobody's end goal is a while loop. Aside from variable injection, flow control is the number one feature in every templating engine. The proposer himself says he wants HTML to be a templating engine, yet this suggestion lacks the fundamental feature for it to be useful. ----------------------------------------- &gt; I don't know of a single webpage that supports more than one backend. You've never heard of using different database types for a single app? Some people use SQL for general storage, Redis for key-value storage, Mongo for arbitrary data storage, and ElasticSearch for fuzzy text searching all within a single app. Furthermore, that's not even what I was getting at. I was trying to say that this implementation ONLY supports people who choose to use a SQL database and ignores **other people with other apps that use other back-ends**.
I believe they allow comments to separate different queries. Just an option though it sounds like you have a good solution in place.
Not at all. We can type whatever we want into the shell. We can ask a bank teller for whatever we want. The permissions involve what can be divulged, not the way that somebody goes about getting it.
What is JavaScript? A programming language! That's it's place in modern program development. If you want to write a program for web, or robots, or controllers, or anything really, you can do it JavaScript. 
I'm not sure how you are locked into meteor when you can use arbitrary Javascript on the front end, node on the backend, and write a DDP client if you want to use a different language on the front end.
Javascript is confusing because we're using to thinking of Programming languages and programming platforms as being synonymous, but that's just not true any more. Javascript is a programming language, but there are several environments that run Javascript now. Web Browsers are the traditional one, which enable client side development in Javascript. Node is a server side environment that enables a more traditional programming environment for Javascript. Using Node is much like programming in Python. Which is to say that you can write little utilities you invoke from the command line, or you can write whole Server applications that accept http requests and produce responses. Amongst _limitless other things_, just like any other programming environment. There are other environments that run Javascript as well. And there are things like node-webkit which cloud those boundaries. But the simple answer is that Javascript is a programming language and there are many different platforms which can run it. 
Best thing about modern JavaScript is that it can run anywhere. This creates a huge ecosystem. You can literally do anything and run it anywhere; client, server and dev, all blend together. For example when building forms you'll have noticed you're writing validation code twice, once in JS and once in whatever server language. Or maybe it'd be cool if your serverside templates (and support code) could be used on the client?
Oh, you mean the FrameworkNoFrameworkComparisonFramework?
[Google already evaluates JS](http://googlewebmastercentral.blogspot.com/2014/05/understanding-web-pages-better.html)
&gt;I am struggling to understand what is happening with Javascript these days. I was always under the impression that javascript being clientside meant that it was mostly utilized for the interface. **Client Side in Browsers** Yes, this is true. Javascript is used client side in web browsers quite a bit. **Libraries and Frameworks for Client Side in Browsers** A while back there were 'issues' with incompatibility between the different versions of javascript in different browsers, and programmers wanted some snazzy new functions for animation and whatnot. jQuery fixed that. jQuery is a library (written in javascript) that added a lot of great functions for manipulating the DOM, animations, selecting things, etc. It has the added bonus of clearing up goofy problems between browsers. Since jQuery, all sorts of other javascript libraries have come out. MVC! Everyone LOVES MVC! Why should javascript be left out of all the MVC fun! I know! Let's make 50+ frameworks that deal with MVC all in the DOM! (Sorry about the sarcasm. Its late afternoon on a Friday where I am.) Anyway, right now, there is a plethora of javascript based frameworks. Angular, reactJS, backbone, many others... These are frameworks designed to make writing very long and complicated client side applications easier by using well-known patterns and code reuse. The issue is that a new javascript framework seems to pop up every week. Also, the existing frameworks seem to change quite a bit. In a way this is good because it promotes improvement, but in a way it is bad because its difficult to justify investing a lot of resources (time and money) into learning a particular framework and/or developing a corporate application that relies on a framework. **Server Side** Someone somewhere said "I like using javascript client side, but I hate switching to .php or .NET for the server side. Why not create something that uses javascript server side? One language to rule them all! I think its actually kind of a good idea. Context switching between between javascript client-side and .php server side can be... a bit... irritating... The idea is to eliminate that irritation by making javascript throughout the whole stack. Economies of scale and all that. NodeJS and Meteor (I think) seem to do this. They both have raving fans, although they are both sort of new and maybe need a little more work (I think). **Unity** Want to program 3D or 2D games like Portal, Duke Nukem and Angry Birds? Want those games to play on iOS, Android and Windows desktops (and other platforms)? Then Unity is a good thing for you. A lot of Unity is drag and drop and similar to the "properties" menus of Visual Studio - but there is still a great deal of code behind the scene that keeps it all working and talking. C# is usually the language of choice, but for some reason javascript is also an option. NOTE: I just learned its not the exact same javascript that's in browsers... there are some little differences. **Desktop Applications** Are you a web guy who wants to build Windows desktop apps without learning WPF or .NET? Do you already have an HTML5 app you just want to make stand alone on a desktop? There's ways to do it. Haven't done it myself, but it sounds interesting. **PhoneGap/Other** Same thing as above except for iOS, Android and Windows Phone. Build an HTML5 app using javascript and "compile" it into an app that you can sell in the app store. With PhoneGap (and a couple of others) its easy! So... As you can see... Javascript is pretty damn ubiquitous and versatile and seems to be on the upswing with people adding to it and making new things with it.
Many have tried. Even I tried. After seeing the monster I created, I, like so many others before me, said "Oh, that's why this is a bad idea!" You're welcome to try as well, and learn that lesson the hard way.
&gt; HTML5, which is just a fancy word for, moving shit to the client Stuff moved to the client a while back. HTML5 is just standard for describing what was already happening. It added and normalized a few things, (like local storage and canvas) but most of it already existed in some form.
Ok this has turned on some lights. I thought Node was another presentation framework. So Node really is a server runtime to use javascript as its language to do back end work. 
I find it interesting the way you talk about not needing classes and interfaces. I started with Cobol, and moved into C and we never had true objects in any way shape or form. Maybe we are moving back to simpler programming to get more developers involved. I have always had issue with how complex we have made programming over the years.
Node *is* the key here. And its not just limited to servers. Its taking that cross-platform JS runtime and ripping it out of the browser and making it accessible through a CLI. You can have it run your server, or you can even use it to run and test your client code... and just about anything else too, because why not. And that's what you're seeing happen.
I don't see any factories there.
Exactly. At my current work, the trend is going the other direction. Do stuff on the server, so that our poor client doesn't have to. Well it won't be long now until most client devices are very powerful machines. And it is a shame not utilising their CPU cycles. Especially on high traffic websites. 
Loved that comparison on bootstrap to IKEA :)
And embedded systems if you want too! [Tessel.io](https://tessel.io/) is a arduino-ish chip that was made to work with node code. 
Maybe I'm too old as well, as I've definitely felt a lot of projects I come across stretch javascript way beyond what seems sensible (to me, obviously). If devices like chromebooks were more ubiquitous, it might start to make sense for some things. Clients being far more powerful than ever is not, imo, a good excuse to unnecessarily throw more work at them.
*console output:* heyooo im Reddit_JS_Bot\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
I am not OP, but I quite like it. Certainly better than Angular 1.x and all the other frameworks currently. If you don't care about IE, go with it.
When I first heard about node my reaction was, "why would you want to use javascript if you don't have to?" My view was that in a browser you have no choice if you want a dynamic application, but on the server side you have a ton of (arguably) better choices for languages and platforms. However, over the last year in my current job I've been hopping from ruby for chef provisioning, bash and make for build tools, python (with some occasional java) for web services and less dynamic sites, Perl for our legacy web platform, and javascript with AngularJS for dynamic web apps. On a bad day I'm in all of those languages and I spend a lot of time context switching. Given that, I can appreciate the allure of node on the server and sticking with the same language for all tasks, especially if a developer's strongest language is javascript. For me, my strongest language at this point is python, so I'd rather take the context switch penalty and not be stuck in javascript all the time. 
Exactly, Node lets you run JavaScript on the server to build server type applications. It also lets you run JavaScript locally to build desktop or command line applications. JavaScript has evolved from being purely a language to add some interactivity on a web page to a multi purpose language used in many different environments, as others have pointed out. Folks have built multiple tools around javascript that make development easier, but there is also a renewed focus on writing better javascript. It used to be the case that developers would spend hours getting server side code architectred and organized correctly. Then just spit out javascript with all kinds of hacks and repeated code. As a result we ended up with a ton of unmaintainable code. On the front end we know have a lot of javascript libraries and frameworks that are meant to help in that area and get stuff organized following a lot of patterns that have come from the server side world. 
FWIW You could run JScript on the server ages and ages ago. It's just popular to do that now since Node didn't suck at it.
*console output:* hello world\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs while(true); console.log('omg'); -endjs
-runjs var util = require('util'); console.log(util.inspect(process.env)); -endjs
-runjs console.log(process); -endjs
*console output:* { stdout: {} }\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* stdout\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs var fs = require('fs'); console.log(fs); -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(typeof require); -endjs
-runjs console.log(typeof __dirname != 'undefined' ? __dirname : false); -endjs
*console output:* false\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
Not sure about libraries, but the TypeScript compiler will do that.
-runjs console.log(typeof Buffer) -endjs
Well, you can make things private by using a `Symbol` as a computed method name. Without access to this specific `Symbol` instance, you won't be able to invoke those methods. Anyhow, I highly recommend to use ES6's classes instead of something custom. Tooling, standardization, and interoperability are more important than access modifiers. **Edit:** Something like this: let MyClass; { const shoutify = Symbol('shoutify'); class C { constructor() { this.foo = 'foo'; } shout() { return this[shoutify](this.foo); } [shoutify](s) { return s.toUpperCase() + '!'; } } MyClass = C; } let mc = new MyClass(); console.log(mc.shout()); // FOO! With a new Symbol instance, you get a TypeError: mc[Symbol('shoutify')](); // TypeError: mc[Symbol(...)] is not a function
-runjs console.log('f' + ([].slice.call(new Array(1000))).join('u')) -endjs
*console output:* fuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(typeof window, typeof process) -endjs
&gt; Why not use an IIFE? Because it's more annoying to type. let MyClass; { ... MyClass = C; } let MyClass (() =&gt; { ... return C; }());
*console output:* { console: {}, process: { stdout: {} } }\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(new [].constructor.constructor("")) -endjs
*console output:* null\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* null\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
Take a look at the sheer volume of packages available for Node. There are build systems, test runners, code quality tools, boilerplate generators, and more every day. That whole ecosystem is exploding with creativity and new tools right now. https://www.npmjs.com
-runjs console.log(([].constructor.constructor("console.log(this)").call())) -endjs
*console output:* { console: {}, process: { stdout: {} } }\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
That sounds awesome! Currently reading eloquent JavaScript and throwing stuff together in jQuery, but I want to get into angular, which is pretty scary! Gone on a ramble but does anyone have advice on a best approach?
-runjs console.log(([].constructor.constructor("console.log(Object.getOwnPropertyNames(this), Object.getOwnPropertyNames(global))").call())) -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
do you remember how java was supposed to be a run-anywhere, do-anything language? and then how they named javascript after it even though they're not the same at all? well javascript became what java was supposed to be. (not hating on java - it just never did that thing it was going to do.)
-runjs console.log(([].constructor.constructor("process.execPath").call())) -endjs
-runjs console.log(([].constructor.constructor("return this.toString()").call())) -endjs
*console output:* [oject gloal]\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(([].constructor.constructor("return postMessage.toString() &amp;&amp; print.toString()").call())) -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* function () { [native code] }\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(([].constructor.constructor("return print.toString()").call())) -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(([].constructor.constructor("return console.log.toString()").call())) -endjs
-runjs console.log(([].constructor.constructor("this.postMessage = this.console.log").call())) -endjs
-runjs console.log(([].constructor.constructor("return postMessage({}, "*")").call())) -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
sure
*console output:* 1\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* "-runjs (function (){console.log(-+runjs (+arguments.callee+)() -+endjs);})() -endjs\n" ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs (function(){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs
*console output:* -runjs (function (){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(([].constructor.constructor("var keys = []; for (propName in arguments) { keys.push(propName) }; return keys").call())) -endjs
*console output:* -runjs (function (){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* []\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* []\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log(String.fromCharCode(45,114,117,110,106,115,32,40)+arguments.callee+String.fromCharCode(41,40,41,32,45,101,110,100,106,115));})() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
Thank you! That worked:)
-runjs a=arguments; console.log(([].constructor.constructor("this.postMessage=function(){ }; console.log(this.postMessage)").call())) -endjs
*console output:* null\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs a=arguments; console.log(([].constructor.constructor("this.postMessage=function(){ }; return (this.postMessage.toString())").call())) -endjs
*console output:* function (){ }\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
For private functions, is there much to gain by having them be part of the class? Why not split them out entirely and have the class methods just call the standalone function and pass a reference to `this`? And for private variables, you can use WeakMaps, then things are truly 100% private. The symbol method still allows access via Object.getOwnPropertySymbols.
-runjs a=arguments; console.log(([].constructor.constructor("this.console=null" }; return (this.postMessage.toString())").call())) -endjs
*console output:* function (){ console.log.apply(console, arguments) }\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* null\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* []\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(([].constructor.constructor("return Object.prototype.toString.call(this.constructor)").call())) -endjs
*console output:* [oject Function]\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* function Oject() { [native code] }\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(([].constructor.constructor("return this.constructor.prototype.toString()").call())) -endjs
*console output:* [oject Oject]\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(([].constructor.constructor("return this.constructor.prototype.constructor.toString()").call())) -endjs
Sure
-runjs var s = '-runjs \n\n console.log("swag") \n\n-endjs'; for(var i =0; i&lt;5; i++) console.log(s); -endjs
-runjs console.log(([].constructor.constructor("return this.constructor.prototype.constructor.prototype.constructor.toString()").call())) -endjs
-runjs console.log(([].constructor.constructor("return this.constructor('retutn this.constructor.toString()').call()").call())) -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(([].constructor.constructor("return this.constructor('return this.constructor.toString()').call()").call())) -endjs
-runjs console.log(([].constructor.constructor("return this.constructor('return this.constructor.toString()').call()").call())) -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(([].constructor.constructor("return this.constructor.prototype.constructor.keys.toString()").call())) -endjs
*console output:* function keys() { [native code] }\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* function getOwnPropertyNames() { [native code] }\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(([].constructor.constructor("a = this; return this.constructor.prototype.constructor.getOwnPropertyNames(a)").call())) -endjs
*console output:* "[ a,\n decodeURI,\n DataView,\n Float32Array,\n parseInt,\n Uint8Array,\n ArrayBuffer,\n parseFloat,\n Uint8ClampedArray,\n unescape,\n encodeURI,\n Function,\n Uint32Array,\n Boolean,\n Symol,\n Date,\n WeakMap,\n escape,\n Array,\n eval,\n Int8Array,\n postMessage,\n TypeError,\n WeakSet,\n isNaN,\n process,\n encodeURIComponent,\n SyntaxError,\n Infinity,\n EvalError,\n Float64Array,\n Error,\n Int32Array,\n Map,\n String,\n Promise,\n Uint16Array,\n Oject,\n undefined,\n Set,\n Int16Array,\n decodeURIComponent,\n console,\n RangeError,\n isFinite,\n RegExp,\n Math,\n Numer,\n print,\n NaN,\n JSON,\n URIError,\n ReferenceError ]\n" ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
&gt; -runjs console.log(([].constructor.constructor("a = this; return this.constructor.prototype.constructor.getOwnPropertyNames(a.constructor.prototype)").call())) -endjs 
*console output:* "[ constructor,\n toString,\n toLocaleString,\n valueOf,\n hasOwnProperty,\n isPrototypeOf,\n propertyIsEnumerale,\n __defineGetter__,\n __lookupGetter__,\n __defineSetter__,\n __lookupSetter__,\n __proto__ ]\n" ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(([].constructor.constructor("a = this; return this.constructor.prototype.constructor.getOwnPropertyNames(a.constructor.prototype)").call())) -endjs
-runjs var s = "swag"; for(var i =0; i&lt;32; i++) s+=s; console.log(s) -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
Angular version: `['$frameworkNoFrameworkComparisonFrameworkFactory', function($frameworkNoFrameworkComparisonFrameworkFactory) ...`
-runjs console.log(this) -endjs
 -runjs var _ = require('lodash'); console.log(_); -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runsjs console.log('I love that, at least since the time of this writing (' + (new Date).toDateString() + '), there hasn\'t been a single actual comment -- just a lot of devs hacking away at a new toy.'); -endjs
*console output:* \xe2\x96\x80\xe2\x96\x88\xe2\x96\x80 \xe2\x96\x88 \xe2\x96\x80\xe2\x96\x88\xe2\x96\x80 \xe2\x96\x84\xe2\x96\x88\xe2\x96\x80\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
Damn, OP thought of everything.
-runjs console.log("buttcoin") -endjs 
*console output:* uttcoin\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(window) -endjs
-runjs while(true){console.log(this.process)} -endjs
-runjs console.log(this) -endjs
*console output:* { console: {}, process: { stdout: {} } }\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* null\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
Hey, hard problems are hard to solve. No arguments there. My view is that it's better to handle native things natively. Input controls are a great example, so is network handling. At best, Javascript is just mimicking what the browser itself could do much better.
If you're doing it to learn JS, you'll want get as far away from classes as you can. Even ES6 classes are just unnecessary sugar on top of a far more interesting system.
-runjs var a = ['b','u','t','t','s']; a.map(function (c) {console.log(c);}); -endjs
*console output:* i like oos\n\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log("b bbb bb") -endjs 
*console output:* \n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs var x = 0; for (var i = 0; i &lt; 10; i++) { x += i; } console.log(x); -endjs
No loops...?
-runjs console.log('thanks a lot!') -endjs
*console output:* thanks a lot!\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
It's a new ES6 feature: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol
hahahaha taking it down so I can fix that
pretty much what I expected. Everyone is trying to break it haha. 
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* this is so cool!\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
Hey make sure your bot doesn't get shadowbanned! Great work!
-runjs console.log("-runjs" + console.log("-runjs" + "lol" + "endjs") + "-endjs"); -endjs
-runjs console.log(require('http')); -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs poop -endjs
-runjs console.log("-runjs-endjs"); -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log('test'); -endjs
Also `Oject` is in the list.
*console output:* {"console":{},"process":{"stdout":{}}}\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
The letter `b` appears to be missing from this output.
*console output:* Something first\n\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* Something first\\\n\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(function(){ return JSON.stringify(root.process.env); }()); -endjs 
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(function(){ return Object.keys(root); }()); -endjs
-runjs console.log(function(){ var foo = Date.now(), i = 0; while (Date.now() - 1000 &lt; foo) { i++; } return i; }()); -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(function(){ var foo = Date.now(), i = 0; while (Date.now() - 5 &lt; foo) { i++; } return i; }()); -endjs
*console output:* 1426816383441,1426816383444\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(function(){ process.exit(); return "foo"; }()); -endjs
*console output:* {}\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(function(){ try { var foo = require('http'); return Object.keys(foo); } catch(e) { return "err" + Object.keys(e); } }()); -endjs 
-runjs console.log(function(){ try { var foo = require('http'); return Object.keys(foo); } catch(e) { return typeof e; } }()); -endjs 
*console output:* oject\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* ayy lmao\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* ReferenceError\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
Does this work outside of the sub? Would be great if it would support username mentions.
*console output:* -runjs console.log("-runjs console.log(\ayy lmao\); -e" + "ndjs"); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs console.log(ayy lmao); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log( '-runjs console.log("-runjs console.log(\\"ayy lmao\\"); -e" + "ndjs"); -e' + 'ndjs' ); -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log( '-runjs console.log("-runjs console.log(\'ayy lmao\'); -e" + "ndjs"); -e' + 'ndjs' ); -endjs
*console output:* -runjs console.log(ayy lmao); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs console.log("ayy lmao"); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* ayy lmao\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log('beans!'); -endjs
*console output:* eans!\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
No, the only thing some browsers let you disable is opening windows, and even then... But you could use GreaseMonkey/TamperMonkey and *undo* the stuff that page does. It's only clearing the three or four event handlers they set and voiding the style they set.
(function(){ return "test" })()
&gt; But you could use GreaseMonkey/TamperMonkey and undo the stuff that page does. It's only clearing the three or four event handlers they set and voiding the style they set. Wouldn't that be specific to each website? Or are there a set of common menu disabling methods that would work across the board?
-runjs (function(){ return "test" })() -endjs 
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs ("test") -endjs
-runjs 1+1 -endjs
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString() + ")(); -endj" + "s")})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(1+1) -endjs
*console output:* 2\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString() + ")(); -endj" + "s")})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString() + ")(); -endj" + "s")})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString() + ")(); -endj" + "s")})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
In general yes, it would be site specific. But most of those tricks tend to be similar because, well, there is only a number of ways to do it. So you *may* be able to apply a batch of generic *fixes* and have it work on a lot of sites.
-runjs console.log('-runjs\nconsole.log("Recursion?!")\n-endjs'); -endjs
-runjs console.log((function(){ for (var i=0, o='l'; i&lt;100; i+=1) o+='ol'; return o })()) -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs new Array(100000000); -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs [][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(+!+[]+[+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(+![]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(+![]+[![]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]+!+[]+!+[]])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])() -endjs
-runjs console.log(["c","o","n","s","o","l","e",".","l","o","g","(","'","-","r","u","n","j","s"," ","c","o","n","s","o","l","e",".","l","o","g","(","\"","R","e","c","u","r","s","i","o","n","?","!","\"",")"," ","-","e","n","d","j","s","'",")",";"].join('')); -endjs
-runjs console.log(arguments); -endjs
-runjs console.log(arguments.callee); -endjs
*console output:* null\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
Genius. 
-runjs console.log(process.env); -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
--runjs navigator. userAgent; --endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
This will never output anything.. Also, I propose this loop instead. while("pigs" != "fly"){ console.log('omg'); }
http://www.reddit.com/r/javascript/comments/2zr71d/hey_guys_im_writing_a_bot_that_lets_you_run/cplw0so This one did IMHO. 
/u/greatsawyer OP, you might want to make sure that input text is different from output text to circumvent infinite regress by quines. :) 
*console output:* Stewie is cool.\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log("Hello world") -endjs
*console output:* Hello world\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs setTimeout(function() { console.log("foo"); }, 1); -endjs
-runjs console.log(require) -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log(setTimeout) -endjs
-runjs console.log(new Date().getTime()); -endjs
*console output:* 1426827831818\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs var t = new Date().getTime(); var x = 0; while (new Date().getTime() &lt; t + 10) { x += 1; } console.log(x); console.log("foo"); -endjs
-runjs var t = new Date().getTime(); var x = 0; while (new Date().getTime() &lt; t + 2) { console.log("bar"); x += 1; } console.log(x); console.log("foo"); -endjs
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString() + "1;)(); -endj" + "s");}1;)(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function (){console.log("-runjs (" + arguments.callee.toString().slice(0,-1) + "1;})(); -endj" + "s");1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;1;})(); -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
By coincidence, I saw a Firefox plugin yesterday, whiCH does exactly this. It gets rid of right click and other disables It was called something like allowtobrowse or allowtoclick... not sure edit: [it was called rightToClick](https://addons.mozilla.org/nl/firefox/addon/righttoclick/?src=cb-dl-featured)
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
I'd even say don't let the bot reply to itself 
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
I think Haxe does this, to some degree? Not sure. It may be worth looking into.
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs console.log((function (o) { var cache = []; console.log(JSON.stringify(o, function(key, value) { if (typeof value === 'object' &amp;&amp; value !== null) { if (cache.indexOf(value) !== -1) { return; } cache.push(value); } return value; })); })(this)); -endjs
You can, but you shouldn't as that blurs the separation of View and Model, and there's already best practise of using a ViewModel.
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs (function () { var str = arguments.callee.toString(); console.log('-runjs (' + str + ')() -endj' + 's'); }) (); -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
I tried... Where are my single-quotes going?
Just for reference purposes, Facebook is doing something similar - in core idea - with Relay+GraphQL but much better and not a standard proposal [Relay+GraphQL](https://facebook.github.io/react/blog/2015/03/19/building-the-facebook-news-feed-with-relay.html)
Only lowercase, though.
Oh I absolutely agree. I abhored C# in my razor views. I was trying to say that JavaScript is similar to .Net in that you can use it anywhere in the stack.
That's something that drives me nuts about how people do angular. You could do ['$frameworkNoFrameworkComparisonFrameworkFactory', function($comparisonFactory) ... Or WHATEVER you want to call it, but almost nobody does, they repeat the name verbatim.
-runjs console.log("sup"); -endjs
-runjs (function () { console.log(String.fromCharCode(45, 114, 117, 110, 106, 115, 32, 40) + arguments.callee.toString() + String.fromCharCode(41, 40, 41, 32, 45, 101, 110, 100, 106, 115)); }) (); -endjs EDIT: I DID IT
*console output:* -runjs (function () { console.log( String.fromCharCode(45, 114, 117, 110, 106, 115, 32, 40) + arguments.callee.toString() + String.fromCharCode(41, 40, 41, 32, 45, 101, 110, 100, 106, 115)); })() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* -runjs (function () { console.log( String.fromCharCode(45, 114, 117, 110, 106, 115, 32, 40) + arguments.callee.toString() + String.fromCharCode(41, 40, 41, 32, 45, 101, 110, 100, 106, 115)); })() -endjs\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs eval("console.log('hello');"); -endjs
Are there any easter eggs? Like: -runjs console.log(greatsawyer); -endjs
Good for you, always keep experimenting. But I don't see how this is relevant for anyone else on this sub...
-runjs function runMe(a){console.log(a);runMe(Math.floor(Math.random()*99999));}runMe(Math.floor(Math.random()*99999)) -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs function runMe(a){console.log(a);}runMe(Math.floor(Math.random()*99999)); -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs eval("setTimeout(function(){console.log('lol');},3000);"); -endjs
*console output:* hello\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs eval(function(p,a,c,k,e,d){e=function(c){return c};if(!''.replace(/^/,String)){while(c--){d[c]=k[c]||c}k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}return p}('1(0(){2.3(\'4\')},5);',6,6,'function|setInterval|console|log|hello|500'.split('|'),0,{})) -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* s\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
I am extremely interested in this..!
Thanks. Since `$` is used in jQuery I chose `_`. Ok lodash is a common library. I have now changed `_` to `c` in the OP.
This sounds insanely powerful. 
Yes I do. My company uses Angular, so I've recently been told to get to grips with it. Your comment was no help at all. 
-runjs console.log((function() {return 1+2+3+4+5+6+7+8+9;})()); -endjs
*console output:* 45\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
-runjs alert(1); &gt; -endjs
*console output:* undefined\n ^this ^bot ^is ^sandboxed ^to ^console.log. ^errors ^or ^exeeding ^computation ^time ^will ^result ^in ^undefined
Your code is awful. Just use return instead of while/break.
I use React and I love it but it the "hottest" if you measure what people seem to be using/developing/learning/asking question about is Angular by far. It is probably 10 times as big as React.
-runjs console.log(([].constructor.constructor("console.log(this)").call())) -endjs
:D
Which is the point. 
No I mean, it will never hit the console.log, and I assume what wasn't the point, what he really wanted to write was: -runjs while(true) console.log('omg'); -endjs Notice the missing ; after while(true)
The comment says anything that exceeds maximum computation time will result in undefined. If you think about it, loops would very well break the bot, as it would not post a comment until the loop is done outputting, although someone already found a good way to make it reply to itself a couple times.
Ok.
Yeah, symbols are awesome, but they are meant more as a 100% unique alternative for strings to avoid variable collision, since they allow stuff like let o = {iterator: 'omg'}; o[Symbol.iterator] = function*(){ }; with confidence that the newly introduced function will not collide with existing keys. There are several new public symbols that allow you to modify the behavior of objects like this.
That is a fantastic article, so well-written and lucid. 
Yep. But there is a possibility the bot won't run if theres nothing to console log. 
*Nice*. :-D
the fuck is the "role" of a programming language? Its role is to build shit
One of the things that you could potentially do across the board is something like this: (function() { var _preventDefault = Event.prototype.preventDefault; Event.prototype.preventDefault = function () { e = this; if (e.ctrlKey &amp;&amp; (e.which == 65 || e.which == 66 || e.which == 67 || e.which == 70 || e.which == 80 || e.which == 83 || e.which == 85 || e.which == 16 || e.which == 73 || e.which == 74)) { return; } _preventDefault.apply(e); }; })(); I looked at the inline JS that yooplugins used to disable certain keyboard hotkeys, and monkey patched "preventDefault" to not do anything when those hotkeys are hit. The function will still work as intended in other scenarios, though, so it is less likely to break legitimate functionality that a site is providing by using the function. Executing this script in the console allows Ctrl+U, Ctrl+B (really, they disabled opening bookmarks?), etc. Though Ctrl+A is still broken because they've bound an event handler to "onselectstart". This sort of script is one of the few ways I can think of to make something that is close to universal. The other things that yooplugins is doing are more site specific and don't involve a function we can monkey patch. There are some generic things we can do that will work for yooplugins, but possibly not other sites. For example, yooplugins sets a lot of event handlers by direct assignment instead of using `addEventListener`. So we could do something like: document.oncontextmenu = function() { }; And now we can right click again. Other sites preventing `oncontextmenu` might end up using `addEventListener`, however. Or they might extend `oncontextmenu` in a more legitimate way (e.g., Dropbox's web app) where we wouldn't want to disable the functionality. **EDIT:** It's kind of funny, too... They assign to `document.onkeypress` multiple times, each time blowing out the last event handler that they had assigned. You'd have to do something like `document.onkeypress = function() { };` to fully take back your hotkeys (like F12---char code `123`), but this has the same issues as reassigning `oncontextmenu`.
Angular source code. You may never understand Angular without reading the source code.
-runjs ["Badger","Mushroom","Snake"].forEach(function(a,b,c) { b&lt;1&amp;&amp;(b--); console.log(Array(c.length-b).join(a + ' ') + a); }); -endjs
If you're a "new" full-stack web dev, why not start with current javascript and not jump so quickly at ES6? You probably think you're good enough with javascript, but I doubt it if you have to ask reddit what technologies to use. 
two points... If you mention that your company has made it their solution, probably wouldn't have needed to go back and forth... If someone wants to use Angular to do all of their web apps....what is the point of pointing out there are ten thousand different ways....I've always hated those responses....short of someone accidentally running something completely malicious unintentionally....let people go down a road they want to go down, especially if it leads to failure. That is easily 99% of learning right there. You are merely pointing them in a direction, no need to rob them of an opportunity to learn why or why not. (Not saying Angular is a bad choice, my company is using it as well and I like it just fine) Finally with Angular, check out sites like http://plnkr.co/ as well as angulars getting started location... https://docs.angularjs.org/misc/started If you are past that point already, being more specific with your question would definitely help. 
Cool, since you're looking to learn, I'd probably do what you've written as something like // A 'private static' is easiest to just put outside the class // since having it attached to the class doesn't add any value // and module scoping will make it inaccessible outside. let myStaticVariable = 2; let myPrivateVariable = new WeakMap(); // The function is scoped in the module, so it is private. // There is nothing wrong with passing in the object // to do some modifications of it. function privateHelper(instance){ instance._protectedState += 1; } class MyClass extends OtherClass { // Making something 'protected' isn't really possible // in JS, but some people like to mark protected // (and maybe private) values with prefixed underscores. // 'final' would probably require a runtime check, // but honestly I'd say you should just skip it. _myMethod(){ privateHelper(this); super._myMethod(); } constructor(num){ // A weak map allows storing data by relating it to // an object, but making sure it will be GCed properly // and since `myPrivateState` is scoped to the // module, it's private. myPrivateState.set(this, num); // Protected variables prefixed for clarity. this._protectedState = num; } } let myObject = new MyClass(123); The main thing I'd keep in mind is that it's just JS, so the class syntax is only syntax sugar, there is little reason to try to shove everything into the class syntax, because you can pretty much just use normal functions and scoping to address things. My WeakMap example achieves private state, but the next question is simply how much that is worth. Most of the time, I'd probably just opt to prefix everything with an underscore and treat it as protected. Or clearly document that you expect it to be treated as a private.
To store the values in an array you can start out by making 'dvd' (probably should call it 'dvds' now) an empty array assigned outside of the function (like before the alert at the top, for instance). var dvds = []; In doSubmit() use the .push() method to add objects to the array: dvds.push({ name: document.myForm.dvdName.value, release: document.myForm.releaseDate.value, actors: document.myForm.dvdActors.value, duration: document.myForm.dvdDuration.value }); For the listing you have to loop through the array to get the values from each DVD object. I don't want to do the whole thing for you so I'll let you give that part a try :)
Could you possibly explain your methodology for making that. I just can't get my head around it! Edit: never mind, I worked it out. Awesome.
jquery. read it. understand why and how it works
The developer tools in modern browsers offer all kinds of ways of setting breakpoints. You can configure a breakpoint when an element's attributes change, or when an element's children are modified, and so on. And you can view all the events with handlers attached for any given element, so you can e.g. set a breakpoint on the onlick handler. And in the very worst case you can always use "break on next".
Didn't add much info, sorry; there's a second program called the 'producer' which has phaser and devkit (Gameclosure/Weeby's framework) , and from there you can port games. You -should- be able to sign up for that at http://js.io I'm more curious about thoughts on the layout and idea than functionality at this point 
read D3.js -- it is absolutely awesome code.
https://www.youtube.com/watch?v=bo36MrBfTk4 watch it all, source code is in the presentation
The source code for lodash is very, very well organized - https://github.com/lodash/lodash/blob/master/lodash.js It taught me how to think in terms of reusability and modularity, and also some neat performance tricks. Also: read the unit tests, as well. Extremely thorough.
I'll try that. Is there any tutorial on this? Tuts+ codeacademy? On Video? 
Have you learned about *for* loops yet? I have no problem helping but this looks like a class assignment and you'll be worse off if somebody does all the work for you. You can PM me if you want.
That pattern is called [fluent interfaces](http://en.wikipedia.org/wiki/Fluent_interface), and it dates back to Smalltalk (1970's). JQuery uses it heavily.
Yeah, they're debating now on how to let users without the producer (which has a console, is a full IDE, etc) write apps. Possibly, for people who won't pay for premium/producer, they can make single-file games. Ill definitely start thinking of some ideas to make it more social. There used to be (dunno where it went) a video on how everything worked and stuff but maybe it's being re-done. Thanks! 
I guess the *dialect* thing comes from the devkit /u/Giraffestock mentioned which I think has its own build tools. Which again means that they clearly need to link back to that. (I never much liked the idea of a committee, but I actually lost most interest in tc39 a while ago)
Anything by TJ Holowaychuck. https://github.com/visionmedia https://github.com/tj The express js code from when he was writing it is really good. 
Yes, I am complaining about Backbone.
Actually... what is Java-like about Backbone?
I'm noticing many grammar issues in your post. I'm guessing you're not a native speaker. That's fine, but if you want to post quality content, you should have a friend or two help you fix these issues. You introduce problems by mentioning only one specific solution. Take including other modules. You only mention Bower, when there are many others, such as Browserify and WebPack. You could write a lot on just the differences between these technologies. A very ambitious post leaving much to be desired.
How does this work when the data requested can change often.
There's far more than JavaScript available when building "modern" web applications... 
http://www.bahadirakin.com/kimim-ben/cv/ Also, HTML is not a programming language.
OMG! THANK YOU! I didn't know Chrome had that!
I love the [three.js source code](https://github.com/mrdoob/three.js/): people go crazy about being forced to put so much whitespace everywhere, but Mr Doob seems great at using it to ensure everything is mostly small functions that do a single thing. I find it really easy to dig through.
The book [Secrets of the JavaScript Ninja](http://www.manning.com/resig/) by John Resig/Bear Bibeault goes into examples of the jQuery and other frameworks source code and explains the decision making processes behind doing things a certain way. It is enlightening!
Trying to tell people to look at your code some more are you? edit: you could at least advertise that your biased since you wrote it. 
also Marionette is worth a read if your familiar with backbone. 
I dislike both bower and grunt - they are absolutely not needed to develop a modern web application. They might be trendy .. but not everything that's trendy is the answer.
Saving
&gt; we are going to follow ES6 syntax here. The code is written in TypeScript 1.5+, actually. As with all optionally typed languages, I highly recommend to add types to the signatures of all functions. It's very little work and you get massive tooling benefits in return. Additionally, it serves as basic documentation which is also a big plus. For example: add($event,newtodo) { ... } What's `newtodo`? By looking at the source of that function, I can only tell that it's *something* which happens to have a "value" property. I have to find some call-site to figure out what's passed to that function. But that won't actually answer that question, because I can't be sure that the thing which is passed in this particular case aligns with the *intention* of the person who wrote that function. Another nitpick: if($event.which === 13){ That's an [unnamed numerical constant](http://en.wikipedia.org/wiki/Magic_number_%28programming%29#Unnamed_numerical_constants). Unfortunately, Firefox is the only browser which has predefined constants for this (`KeyEvent.DOM_VK_RETURN`). So, you either have to create your own (e.g. `const RETURN_KEY = 13`) or at least add a comment.
Take a look at [sweet.js](http://sweetjs.org/). You could probably build macros that will allow this.
There's absolutely no reason to set up a variable for the return key for a simple demo. That's such a ridiculous nitpick. 
It's general advice. You shouldn't have *any* unnamed numerical constants in your code. I know what 9, 10, 13, 32, 37-40, and 48 is (in this context), but that's purely coincidental. I wouldn't assume that everyone else happens to know this pointless crap. Also, some 5 over here isn't necessarily the same as the 5 over there. Anyhow, just read that section of the Wikipedia article. It explains it very well, I think. By the way, "nitpicking" means "to correct minutiae or find fault in unimportant details". So, I already said that I was splitting hairs.
Candor is appreciated! Trying to aim for the middle-beginner level understanding. :)
So this is going way over my head. Can anyone ELI5 or link some reading material?
[agreed](https://github.com/joyent/node/tree/master/lib). It also has some good C++ parts too ;)
:)
Pretty sure that's a localstorage issue; I'll get that popup once. What browser/OS/etc?
Chrome 41.0.2272.89 (64-bit) Mac OS X Mavericks
Yeah it is particularly nitpicky *but* isn't that kind of the definition of picking nits is?
Legitimate question: why is it almost *always* a todo app? I get that a todo app is simple and easy to digest. I get that it let's you demo basic things like CRUD ops. What I don't get is why we don't ever do something closer to real world stuff. I doubt all of us are currently working our 9-5 gigs making todo list apps.
What's it do? In simple english?
Wow........ that's........ detailed.
I just looked a bit more and now I'm really feeling like I love this post and the potential your blog has here. Seriously there are so many blog posts and articles out there that are just 90% fluff and 10% 'why did you even bother publishing this'. I like the idea of a blog with intermediate level concepts that is clean, thorough, and well written. So keep posting please!
Are you looking for [preventDefault](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault) and/or [stopPropagation](https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation)?
&gt; Note importantly we also remove the cached request when the request is complete. This prevents data consistency problems: a get request can return different data over time (e.g., more records), and we want to make sure the user receives the most up to date data.