^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/iXRPnsk.gifv** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
This is awesome. I am going through it now and it's already helping me so much. I thought I knew OOP, but then I started trying to learn JavaScript. JS is pretty different, ***WEIRD***, in the way it works. 
Do you want to load the data or the filenames?
like do a forloop and just attach + '.mp3' to the end for the source....( for(i=0 ;i &lt; mp3folder.length; i++){ $("#soundboard").on('click', 'files\[i\]' + 'mp3'', function(){ var audio = new Audio(sounds\[i\]); [audio.play](https://audio.play)(); })......kinda
I actually came across something like this recently. I’ll get back to you in a bit.
i greatly appreciate it 
You can’t read from the file system in browser javascript.
I don’t think this is a caching issue. Have you tried logging the time to see if there are any inconsistencies there? I’m on mobile so haven’t been able to test it myself. 
Check out the header in index.html and app.js from www.therapboard.com Looks like the dev implemented what you’re asking for. Let me know if this helps.
Last week I was too late, but I would like a review and feedback from the community. Feel free to praise or criticize :) Any feedback is good feedback :) I've created standalone JavaScript framework called PlazarJS. Here is the github link: [https://github.com/ProticM/plazar-js](https://github.com/ProticM/plazar-js) Thank you all and best of luck.
Simply amazing. I enjoyed reading the post, the way you describe implementing it step by step is very helpful. Thanks a lot!
Thank you so much! If you have any questions, I’ here to help!
You should use `setDate` to modify the date because this handles changing months and years when needed: var billingdate = new Date(); billingdate.setDate(billingdate.getDate() + 30);
Google chrome employees hate him ...
Awesome! Implemented it into my code and everything seems fine, i'm not getting any outcome but there's probably something wrong elsewhere and i'll look into it. Thanks for the help!
For the first few weeks while it was working I console logged the time and checked on various different devices/accounts (logged in and logged out)/different IP's to ensure it was working. At first I used Liquid's time object but then that stopped working after a few weeks, now it's doing the same with plain JS. 
Thanks a lot!!! That's definitely a life saver. I guess I have to work more on my math and logic skills. 
Pepperidge Farm remembers!
[Popout](https://bitbucket.org/lowtolerance/popout.js/src/master/) I actually created this back in 2011, but a recent submission here on “Creative Coding” renewed my interest. I spent some time this week cleaning up the code, removing the dependency on jQuery and did a bunch of optimization. Forgive the terrible design of the web page itself, that’s next up on my agenda. But you can see a more tasteful implementation of it [here](popoutz.netlify.com/generica). 
And user could just update their computer's time to get past the button being disabled
Yes. I need to leave now but once I'm back I can help you if no one will =) PD: You need to generate a new obj, you can use reduce() for that.
Untested but should probably get you on the right track: &amp;#x200B; const fs = require('fs'); const countries = JSON.parse(fs.readFileSync('countries.json'); const languages = countries.reduce((partialLanguages, country) =&gt; [ ...partialLanguages, ...country.languages, ], []); fs.writeFileSync('languages.json', JSON.stringify(languages, null, 4));
Well, first of all the http module in the library is mainly for testing purpose. In general I guess XmlHttpRequest is slightly more cross browser than fetch, but I also guess that's secondary if you transpile the code. Open a issue to discuss using fetch instead of XmlHttpRequest if you want.
As a developer it's up to you to lead your client to making good technical choices. This is definitely not one of them. Why would your client be interested in paying you to build and troubleshoot such a useless "feature" that can ONLY result in a LOSS OF SALES. 
Moment could help you calculate the time at the store location based off the local time in the users browser...but remember that dates and times are really hard.
Yes GIF is old and there are better ways to encode images and animations, but I guess GIF is still interesting because it's been the first. I send a clear code when the dictionary reach the maximum capacity, that is 4096 entries, but in general an encoder could send a clear code "whenever" it wants. For instance the spec explicitly says that decoders should support encoders that once the dictionary is full don't send a clear code and instead use the existing dictionary.
What’s the sell on this vs. Formik?
Chill buddy, a lot of assumptions there. I built the whole store/theme and this is a new feature they want adding on. They haven't lost any sales because I built a manual switch in case of a situation like this. They're actually doing very well.
const countryData = &lt;your original data here assuming it's an array of these country objects&gt;; const languagesWithDuplicates = countryData // Turns country data into Language [][] .map(country =&gt; country.languages) // Flattens those arays into single array .reduce((accumulator, currentLanguageArray) =&gt; [...accumulator, ...currentLanguageArray], []); // Now just filter for duplicates const uniqueLanguages = []; languagesWithDuplicates .forEach(language =&gt; { if (!uniqueLanguages.some(uniqueLanguage =&gt; uniqueLanguage === language) { uniqueLanguages.push(language); } }); // Unique language is your final answer // Notably I wrote this all on my phone so I haven't actually been able to test it
What do you mean with libraries, some sort of a database where everything is just available? I live in Holland so it might be named differently.
It's up to you how to spend your clients money sure. Your right, I di assume that &gt; the 'Checkout' button will always be disabled at some point randomly after working for a few weeks was a major problem. 
Sorry to nitpick but this assumes a Node environment, and doesn't filter for duplicates.
Check out https://momentjs.com for full info and how to use it. There are many many JavaScript libraries available.
Oh my god that is just glorious. Thank you guys so much, this is really gonna help me in the future. Thanks!!
It's the english developer word for it, if you're a programmer professionally in the future, libraries will be a very big part of your life. Let's say it's a collection of functions (or some logic) that can be imported and used. It simplifies workflow very much if used right. If you import the Moment.js library it lets you do funny stuff like: \`\`\` const today = moment() const tomorrow = today.add(1, 'day') \`\`\` You can check a tiny jsfiddle I created.
You don't know if it was a development store, you don't know if it was a family members store, you don't know if I'm working for free... lol and so on. I appreciate your input but that's not the bit of advice I asked for or wanted. 
Awesome! I’ll check that out after this. I’m also wanting to learn some frameworks. 
You're very welcome. You can always use libraries in your personal projects. I'm wishing you the best of luck :)
Well, I only said it would get them on the right track. Besides, what other JS environment would be able to read from and write to a filesystem easily? Good point with the dupes though, maybe reducing into a object keyed by the country code, then finally flattening into an array (\`Object.values()\` would do the trick there), would be a good way of handling that. &amp;#x200B; Not the source of the downvote, btw.
thank you... ill see if i can reverse engineer it
Definitely true, Node is a fair assumption but also by the vagueness and mistakes in the original post I can't actually tell how much experience OP has, if any.
thank you
Good point!
Not 100% sure what you are expecting as an output, as \`\`\` \["languages":\[ ...\]\] \`\`\` is not valid syntax. &amp;#x200B; If you want one array with all languages, you could do \`\`\` const countries = \[ /\* your data \*/\]; &amp;#x200B; // this will pick out the language arrays, they are still grouped by the country they are from,it is an array of arrays of languages const languagesGroupedByCountry = countries.map(country =&gt; country.languages); &amp;#x200B; // this will remove our grouping, it is an array of languages const languages = \[\].concat(...languagesGroupedByCountry); &amp;#x200B; // if you want to ensure uniqueness const uniqueLanguages = languages.reduce((uniqueLanguages, language) =&gt; { if (uniqueLanguages.every(ul =&gt; ul. name !== [language.name](https://language.name)) { uniqueLanguages.push(language) } return uniqueLanguages; }, \[\]); \`\`\`
Awesome! Thanks!
XHR has way more browser support, and having babel throw in a polyfill for fetch is pretty unnecessary when the only use case for it is just 10 lines long already.
Your language de-duplication function might fail. You are comparing objects, which are most likely not the same. You would have to compare based on a primitive value.
It's important to learn standard JavaScript (usual referred to as vanilla JavaScript. It's what these libraries are written in (although libraries can also depend on other libraries). The libraries are very useful, especially ones like moment.js, but there are many instances where using vanilla is best due to it running faster, or if the library your are using is huge but you're only using a couple of functions in it. JQuery is one that divides developers. Some love it and some hate it. A lot of other libraries depend on it. JQuery is worth looking at. Many jobs list it in their requirements, although it's easy to learn. Good luck!
Eh, I agree with the solution. It's actually a great answer because if OP has potential as programmer, they'll look up the methods used and figure out the meaning and learn a lot of fancy syntax along the way. If they don't have potential as a programmer, well then at least the code runs. 
Yeah that makes sense. I'll have a look at JQuery! Thanks!
Hi /u/petsyart, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/FeedMeGraphics, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Not sure which screenshot you are talking about, sorry.
The one in the story 😉
Last week I created [this game](https://studio.code.org/projects/applab/p8LMIXnGaGgKP7Yy-eso2YPXnIAEMwKYcl2ENLqDal4) in Code.org, which is sort of like scratch, but the blocks are optional, so I didn't use them. However, it did allow me to not use any html or css, which definitely made it quite a bit easier for me. I posted it here last week and made a few changes based on what you guys said and I think this is the final version. It's based on the game shown in [here](https://youtu.be/9KABcmczPdg)
Does it work on phones? Coz I just see a white square with dropshadow.
Class components are unfortunately tied to the concept of instances. React is moving towards a world where a render might be tried, retried, and retried again before actually committing (hence depreciation of certain pre commit lifecycle methods). In that case these hooks are great, they force you to think about things in terms of only state and renders, no this allowed.
I was actually looking for something exactly like this the other day. Downloaded. Nice job and thanks for sharing!
Good question. Formik is great. This adds more value to it: `&lt;Field select options={animals}&gt;Label | Placeholder | name&lt;/Field&gt;` and you have a select, all options, label, placeholder, validation &amp; error message, stylings, onChange. What else do you need? :)
Just checked, works on chrome on phone 
Updated Readme: Shorthand syntax &lt;Field&gt;Label | Placeholder | name&lt;/Field&gt; (yes, child is a string for convenience, props work too but it's up to you) generates more code for you. (inspired by Styled Component literal string for CSS)
Jest isn't the best tool for integration testing, but we had to do some recently. The `jest.conf.json` for those tests looked like this: ``` { "testMatch": ["**/?(*.)(spec|test).js?(x)"], "rootDir": "integration-testing", "globalSetup": "./utils/integration-testing-setup.js", "globalTeardown": "./utils/integration-testing-teardown.js", "testPathIgnorePatterns": [ "utils" ], "testEnvironment": "node" } ``` `globalSetup` and `globalTeardown` might be what you want. You can then set e.g. ``` global.myExpressServer = ... ``` On first run, jest will run the tests in order of descending file size. After that, it uses a cache to run the tests in a more efficient order. You may want to use `jest --clearCache` to run without this.
What is your problem and what error message are you getting?
Ofc, many people loves using ES6 in day to day works, even in backend. In the projects I work, we use classes (to pass methods to MongoDB), import/exports, some new ES funcs...
All day, every day, as standard. How many browsers, out of curiosity, still don't support it?
Every single day. We transpile it using Babel and Webpack to support most browsers.
I don't think this is really a great feature to include in an online commerce store but regardless the biggest issue I see here is that your using whatever time it is on the users PC to disable or enable the checkout button. That means it could be 6pm where I am and 4pm where your store is located but I'd be unable to place an order as the button would be disabled. A solution to this would be using moment.js to convert all times (including opening / closing times) to UTC+0 and going from there but ultimately this sort of code should probably be handled by the server as enabling the button would be trivial.
Yup. Destructuring and the rest operator is the shit.
ES6 erry day
Features that rely so heavily on date/time are always full of holes, due to the complexity of date/time. Some alternatives I have used include: 1. Handle appointments on the backend using pre-established time frames. This works really well when you want to prevent double-booking, because when a user selects a time, you can remove it as an option, and they don't schedule an appointment within some time limit (say 10 minutes) you can open that time slot again. 2. Limit their options, but have a fallback of being overly descriptive. So as an example, have a select of times that they can select, and use a library (I prefer moment), to limit their options, But be descriptive in their choices just in case there are some time shenanigans going on. Delivery Day: This could be a date picker, or even just a select with options you generate (n) days from the current date. This mostly depends on how far out you want people to be able to schedule the service. Delivery Time: 1:00 pm (EST) 1:15 pm (EST) or Delivery Time: (Times are based on EST) 1:00 pm 1:15 pm This option can be made dynamic by having a list of locations that have a time zone property, and even if needed a list of standard open hours to base the Delivery Time options off of.
Es6 everyday. Our projects use Webpack for package management, node.js for libraries, Vue.js for Frontend framework and Cypress for testing. (Some projects still use React as we are migrating) Lately, we have moved everyone Ms visual studio code so we can use the live share extension for pair programming. Once we got used to programming with these tools we can’t imagine working any other way.
Of course. Why wouldn't you? It should be the standard now.
I think ES6 support is really only a problem for those of us who still have to make stuff run in IE8. It's the unfortunate side effect of working for a company particularly terrified of upgrading to new tools, but I dunno how common it is.
IE11, mostly. Still required for Win7 users who prefer IE, or Win10 users who are restricted to MS and can't/won't use Edge. (Eg: Corporate users.) I use Typescript and compile it to ES5. Gets me the ES6 features, and some of the Typescript features are nice too.
How come the migration from react to vue?
Our team read wired magazines’ recent interview with Evan You and we’re inspired. The React framework is powerful and well supported, but it’s a pain to optimize. We also have a few projects where Vue’s integration is much simpler.
That’s the one. I’ll share an image of other sides of the cards next time 😉
Constantly
I created a temporary button linked to the same function to call the JS whenever I want, to isolate if it was an issue of timing. So even if the document has been loaded for a full minute and the button is pressed, nothing happens. 
Yee changed my life never going back
ES6 is like. Never looking back. 
&gt;https://jsfiddle.net/7vmtuzsL/12/ Can you show that on this code? I am not familiar with onchange event. You can save the code.
Maybe instead of disabling checkout, they can consider adding a feature of choosing delivery time or something similar to that. What if I want to place order tonight because I don't have time to place order tomorrow morning? Just a thought. 
It depends, but here is a tip. Learn how JavaScript `this` behaves. Why? Because it will get you comfortable with how the language actually acts. It's very much different from other languages which tend to be a bit more intuitive. Plus, you'll automatically be thrown into various other JS concepts.
Use ES6 and then transpile w/babel - in my personal stuff I just serve different js based on an arbitrary new/old threshold that I've decided on, haha.
oh god, I can't even imagine life without destructuring anymore.
No, you'll have to do that yourself. Here is some help. There are several ways you can go about it. You can simply get the values from the selected food when the button is clicked. So, it's similar to what you have now. Or, you can capture the values as soon as the food is chosen. Then, you'll store them in an object for use in the calculation. You'll need an event listener for that. Do you know how to listen for events with JavaScript?
this duck has a birth defect
Also seems weird to me, but I believe that the Fetch API has no way to track the progress, and XHR does. Still kind of weird to call it fetch and not have it return as a promise or having it yield the progress/response.
\&gt; I dunno Sums up your post quite nicely
Yea absolutely. In the browser, and on the server. And anytime we touch legacy code we refactor it to es6.
Does not work on mobile safari
It does return a promise though https://github.com/andreupifarre/preload-it/blob/master/src/fetch.js
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [andreupifarre/preload-it/.../**fetch.js** (master → 2d19d1f)](https://github.com/andreupifarre/preload-it/blob/2d19d1f94b6d1cd9ce85fce65cbd9e11058ea4e4/src/fetch.js) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e8k42uk.)
The fetch function is unintentionally called fetch like the Fetch API, to me it simply made sense to call it like that, at the end it is fetching assets. I added a promise already, so you can also return a promise, if you wish. ;)
hell yeah, 90% of es6, typescript compiles everything down to es5 why would you stil lwant to write stuff like this param = typeof param !== undefined ? param : 'default' var _this = this;
Callback hell, huh? .then( async () =&gt; await this.jumpOutOfWindow());
I love PRs!
cool!
nahhhh, just makes passing objects around way more pleasant and it leaves a bunch of room for commenting. const { age = 10, // (int) current age in years name = "Gary", // (string) friendly moniker to call the monkey hairyness = 0.5 // (float)[0-1] percentage value of hair coverage } = monkey; You know what an object contains all in one place, you can set defaults, can leave useful comments everywhere about how stuff is going to be used. \*\*kissess fingers\*\* mwah. DELICIOUS.
Yes since 2015, using TS
*\*DrakeNo.jpeg\*:* ES6 *\*DrakeYes.jpeg\*:* [**ESNext**](https://kangax.github.io/compat-table/esnext)
I need some feedback and also contributors for a couple of my projects. https://github.com/phenax/pipey https://github.com/phenax/enum-fp 
Best way is to pick a part of a simple website and try to build it. In turn trying to build it will mean you need to research how to do certain tasks. The researching is the crucial part. Once you have experience building things you will have memories to associate things you learn to which will make remembering things easier 
Looks pretty awesome! Love the direction react is headed.
At this point, i cant even imagine what it would be like to code without it.
[removed]
I have posted these projects on show off saturday too. But I'd love some feedback on them and I am also looking for contributors for the project. EnumFp - A library to create sum types/union types/tagged sums in javascript with simple pattern matching. https://github.com/phenax/enum-fp Pipey - Functions to convert instance methods to curried context free functions for clean function composition. Also supports the esnext pipelime operator. https://github.com/phenax/pipey
This is life-changing for me. Had no idea I could add comments like this! Thank you for sharing, good sir! 
Thanks, what makes Jest a poor tool for integration testing? What is a better alternative?
Yeah, it's the import/export that is getting me. I could rewrite the server using CommonJS require but it feels like overkill just to get integration tests running.
import/export errors since node from importing my application server doesn't support it and the globalSetup is processed in the node, not the jest, environment.
Open your editor, blank page, build stuffs. Play around structures. Try to create your ideas, using last techs. Read a lot around specs, but don't follow tutorials and courses, it's lame as you said. Repeat till you don't need to refer to docs to use them. Repeat, hundreds of times. Master your tooling. The simpler the better. Structure your code, each round get better, faster, cleaner. That is discipline. At the end of the journey you will be able to do big with little effort, ninja level! Everything is like so, practice. This will never end. You must find your own way to learn. Don't rely on the internet, use specs, mdn docs. Learn the differences in behavior between browsers! 
You can put em nearly anywhere! const /* this */ may /* not */ = /* be */ "convenient";
All the time and really enjoy it. Because of it I use \_lodash much less often now. We mainly use ReactJS so using ES6 fits right end. Also, ES6 helps when I need to do anything in NodeJS.
Build a website from scratch. Nothing overly complicated, pick something you enjoy - coffee, programming, blogging, sports, etc .. than build a site around that, from scratch. When you have to do something and you have no one telling you how to do it and all you're doing is looking at a blank page -&gt; that's the best way to learn. 
You don’t deserve downvotes for this comment since it’s probably a place many very unhappy developers are in. If you don’t yet track browser usage metrics on your sites you should. Those metrics are the fastest way to *prove* when you can drop support for an old browser.
Try it yourself: \[new Date(2019, 0, 1), new Date(2018, 0, 1)\].sort((a, b) =&gt; a.getTime() &gt; b.getTime())
Here's the screenshot from Chrome and Chrome Canary: https://imgur.com/EwQWgQ8
Gosh, that was painful to read .
One of the things that Babel/web pack/ whatever is cool these days give you is the ability to take your ES6 code and transpile it to a version that is supported by any web browser like IE8. You may need to install a few polyfills to get some modern apis, but your transpiler will handle that for you. Supporting older browsers is not a good reason to not to switch to ES6. 
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
&gt; Do you work in it then compile down (with external tools) to something that is supported by more browsers? Yup. For front-end stuff babel/webpack will compile it down to whatever compatibility you need in the final code. At this point it's no different than compiling any other language down to the form supported by the platform (e.g. machine code, Java bytecode, etc). &gt; Or do you just ignore es6 features for now ? Anyone doing that is so far behind the times that I'd be surprised they can still get hired doing JS work.
unfortunately not
Makes me glad I use moment
Isn't the sort callback supposed to return a number? Maybe that is the thing that is breaking? Maybe someone bothers enough to check the ECMA spec. 
Same, except TypeScript instead of Babel. Wouldn't go a day without it nowadays.
Shouldn't that be `a.getTime() - b.getTime()`? If the compare function returns false, then it falls into this part of the spec: &gt; elements that compare equal do not necessarily remain in their original order [1](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-array.prototype.sort) 
Yeah, I'm not sure about the spec, but at least [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) specifies what happens when the compare function returns different numbers, but not other values. So I'd say if the compare function returns a boolean, it's undefined behavior, in which case there's no bug.
I notice a possibly significant difference between your original version and the workaround is that the first supplies a compare function to sort() whereas the latter doesn't. Upon closer inspection I notice also that your compare function returns the boolean result of the comparison, whereas according to the spec it should return an integer where negative values mean that *a* comes first, positive values that *b* comes first, and 0 means they're equal. Of course booleans, when converted to integers, can only represent 0 and 1, which is asking for trouble in this case. My suspicion is that V8 changed something with regards to their sorting implementation which results in you seeing different results, because your comparison implementation was actually leaving the order undefined! In other words, the fact that your test passed in the first place was probably accidentally relying on the previous sort implementation used by the V8 engine.
I can recommend `date-fns`! It's a pretty cool alternative to `moment`, which is starting to fall a bit out of favor, with one of the maintainers creating an alternative themselves in `luxon`.
They actually switched to Timsort which is a stable sorting algorithm (in case two elements are equal their order is kept). I think this is what is going on here! 
Update: the mobile version had different element ID tags, and I printed innerHtml in the iOS app to find out.
Already? Js fast obsolescence strikes again. 
My job uses jQuery still so I come into work every day a little more sad, but I make sure to use it in my personal projects and I love it
I use TypeScript on both back-end and front-end.
Lemme give you a brief leg up, my dude. Here's the key things to know for navigating the ecosystem right now: * **Node.js** is a way to run JS outside of a browser. Think of it more like Python in that it can read/write files, run a web server, etc. that JS in a browser just can't. * Node also gives you **npm** the Node package manager. Package managers are tools that make it easy to install, update, and uninstall packages (preloadit package we're discussing) * **Babel** is a *transpiler* - it let's you write fancy new syntax (like **import**!) in your Node.js project, then *transpile* it into older syntax (like require) that Node or the Browser can understand. So Babel doesn't just get Node to understand import, it also gets ie11 to understand ES6. * **Webpack** is a *bundler* - it lets you sprawl your project out across multiple files for a more pleasant development environment, then it takes care of bundling them up into a smaller number of files for a more pleasant page load experience. Webpack is especially fancy and powerful, more than I can get into here. * The only other thing you need to know about are **frontend frameworks** like React, Angular, Vue, etc. All of them are trying to solve the same problems in slightly different ways: how to create interactive applications that are easy to develop and maintain. If you are truly adrift in the sea of modern web development, I recommend the following: 1. Know basic HTML and CSS, you can learn this in a day 2. Know vanilla JS. Teach yourself what ES6 is. Try to make a simple interaction with only these tools. (eg I click a button and a popup appears) 3. Learn Vue via CDN only. Make a simple interaction and see how much easier it was. I recommend Vue because it leverages plain HTML/CSS skills more than other frameworks, and you don't have to learn an additional tool to use it unlike React (JSX) and Angular (Typescript). Vue is also much cleaner and easier to read. If you're interested in joining me on my quest to forcibly convert the world to Vue, I have pamphlets. 4. Dive into Node.js. Just download it, then `npm install -g @vue/cli` to install the Vue CLI tool (CLI = command line interface) which can spin up ready-to-use webapps. Use it to create a Vue site. Get it running locally. Enjoy the utter majesty of hot reloading and single file components. From there you'll be empowered to create modern web applications that are trivial to create, set up, and run, and very easy to edit. 
The library makes use of rollup.js which is a module bundler widely used for libraries, it uses the new standardized format for code modules included in ES6
But you are not sorting by Date, but by integers.
Apart from that most modern browsers already support it natively to large parts, webpack and babel help greatly. You can also use TypeScript, which will also give you all these features plus typing and compile down to any JavaScript feature-set you like.
Hi /u/skatedc4455, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
This guy actually reads code before saying things.
Hi /u/rickymcallister45, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Oh boy yes you did write this a while ago haha that was nostalgic, sorry I cant be more useful though it hurt my eyes so I closed it, but I'm glad your interest has been renewed!
I wrote down this today, lately I have not been using React or Vue, just creating stuff with a simple virtual dom library and es6 modules. [https://github.com/cjh9/NoMoreFrameworks.js](https://github.com/cjh9/NoMoreFrameworks.js)
The model and its rendering really needs to be separated, too.
I want to write html, not some abstraction garbage layer. &amp;#x200B; This reminds me of writing html 20 years ago using CGI.pm.
Jesus christ. You migrated libraries because you're "inspired" by an interview? How does management feel about it? 
&gt; it hurt my eyes so I closed it Ow, my feelings 😂
I am the management. Going forward it makes more sense to choose one, instead of supporting both as we did. The developers input was one sided preference of Vue over React. The article included solid geek reasoning and thus was inspirational. 
bookmarked this seems like it can be useful! Kinda curious how you made it though
People still use ES5?
No need for comments though. Your code is usually better off without them.
One, non standard approach would be to convert it to a string and extract the values using a regex.
Absoluuuutely disagree there - good variable naming is essential for saying what something is - sometimes even how to use it - but comments allow you to to specify context and explain *intended* use; they allow one developer's intentions for a block of code to be maintained by the next person. In my example above - even just knowing that age is expected to be an `int` and not a `float` is useful - what if I hadn't defined defaults? You'd need to log or breakpoint it to see what it was. Age in what? Months, years, seconds? Is it a date object? If I was omitting comments I would need to do something like `ageInAbsoluteYears` or `hairynessPercentage` \- by concisely commenting the context for my variables I can reduce the amount of code I need to write later, and improve readability throughout. Sometimes it's even useful to write comments as an exercise to ensure that the code you've written is concise - if you're having trouble describing what a code-block does, then you've probably made it too convoluted. There's a few code academies out there that preach that comments are a sign of flawed code; if your code was good enough it wouldn't need comments. They should know better. \---------------------------------- **p.s You have an amazing username**
Have you thought about using a CI/CD tool? That could orchestrate a process that could do something like: when you commit to a particular branch in GitHub, build your app, run unit tests, deploy to a staging environment if unit tests pass, run integration tests and then deploy to wherever you want if they pass.
You're basically just recreating a framework except without proper state management or VDOM diffing. Additionally, one benefit of frameworks is that anybody with experience in that framework can jump in and contribute to the codebase, this makes that much more difficult. Get a lightweight framework like HyperApp if you're afraid of Angular/React/Vue.
I worked at the BBC and BSKYB, and I can tell you they both have “no comments” as part of their standards. Tests should document the use, not comments. Comments go out of date and sometimes lie. If you feel the need to write comments all the time, it likely means your code isn’t self documenting. In your example, just renaming the variables is all you need to do. Tests are how we make change easy to deal with over time. You inherit my code? You won’t find a single comment. You will find simple logical flows, well named variables and functions, almost no nesting and functions that do only one thing, backed up by a comprehensive test suite that documents every intended behaviour and ensures you don’t break existing behaviour when refactoring or building new functionality, though.
If you use types correctly, name your variables and write your code cleanly, you shouldn't need to use comments.
Or if that's a bit too much, can't you just start your app server separately and then run your tests? Or perhaps I misunderstood your problem.
+1 for the best thing to ever happen to JavaScript 
It is the standard
mmh, your test suite needs a bit more work.
Why are frameworks a bad thing? They're absolutely necessary for scaling any engineering team
I'd rather fart needles than go back to using ES5. I've done everything in my power to forget it exists.
I honestly don’t get it. Why wouldn’t I use something like React which covers most of these concepts and has been benchmarked by people waaaaay smarter than I am?
See my reply to @penguinspe, it's called hyperscript and they are essentially the same as JSX [https://reactjs.org/docs/react-without-jsx.html](https://reactjs.org/docs/react-without-jsx.html) \+ They are the main way to declare views in MithrilJS. They are essentially eqvivalent to html + you get automatically integrity checking that the html is not malformed. It only take a day to get used to. We use them at scale where I work. &amp;#x200B;
React you have state that is tied to the dom, and components. Here a component is a simple javascript function. I use petit-dom in the examples and it s faster than react [https://stefankrause.net/js-frameworks-benchmark8/table.html](https://stefankrause.net/js-frameworks-benchmark8/table.html)
I’ll admit, I admire you for this. But in my experience, it’s idealistic and depends very much on the capabilities of your team over time to instigate and keep up. I have probably become slightly less militant recently in my opposition to comment-less, self-documenting code, but there are still occasions in the large code bases I’ve dealt with where I’m both writing comments and asking others to do so, too. It’s the only way I’ve found to provide adequate context and explanation of what’s what. I fully accept they can be overdone, but are meaningful, occasional comments really that bad?
You're missing an /s
So...what should I be doing when I need state in multiple places? Just grab some sauce for my spaghetti code?
Sorry man, you really don't know what you're talking about. First of all, superfine is technically a spin-off of hyperapp, it's just hyperapp without the built in state management. Hyperapp does not "recalculate on each render", in fact you'd be more accurate to say the opposite. Hyperapp is built off of the idea that the application should never have to rerender unless the state changes. It does this by encapsulating all possible actions that could cause a state change, and rerendering when one does, but again using VDOM diffing it only rerenders what needs to be rendered. By "proper" state management, I mean well thought-out and consistent state management. This can be accomplished in any style of programming, but it becomes difficult when you have to manage a complex UI. Imagine you have a listing of items, when you click on an item it loads a separate view to edit the item. Using your architecture, how do you pass data from the listing component into the editing component. Using the hyperapp/elm/redux approach, you'd dispatch an action to update the root store which would then flow down into the view components, rerendering the DOM as needed. Angular has a few more options, you could have a service to pass state between these two components, you could use an ngrx solution (which is essentially the same as redux), or you could rely solely on inputs and outputs. How would you pass state between these two components? You would either re-implement one of these solutions, or use some ad-hoc approach that wouldn't remain consistent throughout your codebase because..well it's ad-hoc.
What do you mean with "state in multiple places". State should be in you models, MVC, build an UML with your application state, and lift up.
Okay but why wouldn’t I just use redux then? I’m just not seeing the benefit. If it’s a benchmark benefit only I really don’t see the point in adding another abstraction layer to gain a half millisecond of performance. No one will ever notice. 
Woa you're old. They still let you code?
Upvoted for Vue evangelism. I understand the arguments for other frameworks, but Vue is just SUCH a pleasure to use.
its either code or lick some ass and go into management.
Out of interest, how would you write the first example in es6?
Use Babel to compile it to IE11-compatible ES5 code. 
yes. not from Babel either. real men write their own code. 
Default value assignment would be my guess: `(param = 'default') =&gt; {}`
That is an example of destructuring (ie. pulling the values off the monkey object) whilst also assigning default values 
Seems a bit drastic. I'm also all for no comments, but sometimes you want to leave notes to self, for example "this is a weird way of doing this, but we had to because of legal requirements" or "this bit would crash safari if done the 'obvious' way" or something. I.e., things that cannot be derived from the code itself. It doesn't happen often but it does sometimes
What value would the first comment give you? I see no value. The second - no need for a comment. Instead, lock that fix down with a test that clearly describes the problem. That way, if a developer removes that fix and introduces a regression, the will get an instant failing test that communicates the regression they’ve reintroduced. No comment needed in either case, and we’re all the stronger for it.
Are you writing tests? Try learning test driven development. You should have automated tests that clearly describe the required behaviour and do not test implementation details wherever possible. In that model, your comments are replaced with an executable specification that provides instant feedback for regressions and makes all form of changes, whether change is a refactor or a new feature, easier.
The legibility is tremendous. I could almost teach a chimpanzee to read and write Vue - it's so intuitive.
When I started working with Vue, I thought I was doing it wrong because it made sense and actually worked and I didn't find myself ever saying, "ugh, I wish this was different." I'm very unused to that.
It was literally *just* added. It probably wasn't there when the guy commented. 
I don’t want a comment to scare me off doing a refactoring. Why should I be scared of doing a refactoring? I should have tests that make refactor cheap and easy, so this problem can go away. Why the “lol”? Yes, I meant it when I said instant feedback. I would expect to know I’d broken a feature within 5 seconds of breaking it.. this is normal and perfectly possible. Literally the complete opposite of what you are saying is the case - if I have a failing test (yes, instantly failing), then this saves me time by TELLING ME what the problem is, and I know what broke it because it was a change I made in the last 5 seconds. Or I could waste a tonne of time by reading through comments that may or may not be out of date, trying to fix something that broke god knows when, against a code base full of spaghettified crap because people are too afraid to refactor anything. I know which code base I’d rather work on.
Yes. 
&gt; Type Coercions so what?
Find it hard to believe that you get feedback in 5 seconds in all supported browsers, but I am glad it works out for you.
[It depends on what you’re using](https://babeljs.io/docs/en/caveats).
Find it hard to believe then. You’re an amateur at the end of the day. And it wasn’t me who downvoted you, cunt.
Windows 7 users who prefer IE... this can’t be a significant demographic haha.
You're right, in the entire industry those are the only 2 options for you. /s
I can vouch for luxon as I am using it in a sizable project right now. The only downside for my project is having to go in and out of the luxon date wrapper between data layers and vuejs, its very easy just long winded.
ie8, may your monkey feet rip... I thought my life was bad there where we had IE11 with ie10 compat mode turned on .
I prefer static type checking systems like [Flow](https://flow.org), these are actually statically analyzed and enforced, unlike comments (obviously, this adds a dependency).
All I want in life is optional chaning and nullish op. I will also take finalized decorators for 200.
Every day. We are building in react, which relies heavily on es6 syntax. That said, the most basic es6 features are supported by browsers going pretty far back now. No chance I'm going back to using var. 
Windows 7 is still 37% of Windows users; Win10 is 50% http://gs.statcounter.com/windows-version-market-share/desktop/worldwide IE is 6.5% of browsers, Edge is 4.3%. http://gs.statcounter.com/browser-market-share/desktop/worldwide If you've got Win7 users, you probably have IE users. And if you've got Corporate users, you can't just ignore IE/Edge users.
&gt; I am the management. *drops mic*
Sometimes. I occasionally have to work on a legacy project that’s incredibly large and so fragile with the existing build system that upgrading it to slip in a transpiler just isn’t worth it while our browser target isn’t evergreen. So I still have to write plenty of ECMAScript 5 there. Occasionally we’ll get a new dev that is used to only using ECMAScript 6+ with transpiling and they’ll think it’s an easy move. Then after pulling their hair out they don’t try again 🙂 Then there are newer projects I work on. Lots of ECMAScript 6+ there. It’s nice. So it really depends on what needs to be worked on at the time but usually it’s ECMAScript 6+.
&gt; Anyone doing that is so far behind the times that I'd be surprised they can still get hired doing JS work. That seems a bit much. If you had to ignore them that doesn’t mean you don’t know them. While ECMAScript 6+ has a lot of awesome features it’s not like the language is that different. Any developer working in ECMAScript 5 should be able to pick up the new stuff fairly easily. When I do hiring I don’t care about them not knowing ECMAScript 6+ at all. 
More I was poking fun at saying they “prefer” IE, like there’s a good reason to use such an outdated browser, rather than they’re technologically illiterate.
Do you have benchmarks?
Ah yeah nothing like gaslighting a random stranger on the internet, too bad we have version control to protect the victim :D
I breakfast ES6
Slice
You can, it's just a bit hanky. Not a simple event 
I'd like to do TDD, but the deadline doesn't allow that.
https://davidwalsh.name/fixing-coercion
&gt; I ask because classes deceive people about how JavaScript works I don't think they do. There are as many implementations of classes as there are languages. As such, JavaScript's implementation is similar to some languages and different from others. The class and inheritance implementation in Python, Ruby, and Smalltalk, for example, are all very similar to JavaScript's implementation. In those languages, classes are objects, and inheritance is done by delegation, just like in JavaScript. For example, [Python and JavaScript side-by-side](https://i.imgur.com/p9Kw815.png).
Array.map and eval() will get you there 
_preload_ would have worked probably just as well and not collide with the fetch API. 
How are your React skills though? Do you know redux or mobx? HOCs? Typescript? My opinion is that you should have something eye catching, personally I use animation and ui for that, but also back it up by being able to at least understand some of the more advanced parts of React and better yet demonstrate them in tiny digestible projects that you understand well.
&gt; If you don't find the way js does coercion useful, simply don't use it. What's the problem? How to disable JavaScript's Type Coercion? The problem is: "It seems no one can prevent JS from doing this."
Whoever is in charge of that decision should be fired
Nope they can be transpiled down and used with no problems
Stage 0 😎
Get whoever is in charge fired for being so ignorant of the industry they work in
Yeah but heavy reliance on polyfilled generators are slow is what I meant 
Your comments are obnoxious. Sometimes companies have technical debt that ends up taking precedent over using the newest stuff. It sounds like you’re an ignorant young developer whose never worked on legacy systems with sprinkled in new functionality. You can’t always start fresh and rewrite when there are more pressing matters. 
I have to support IE11, so I would really like to do something like this. Do you have any tips/suggestions/word of wisdom for setting up Babel and Webpack? I use ASP.NET MVC and AngularJS 1.7.x.
There's only so many words that can be used as analogies with regards to programming. Fetch means "go for and then bring back (someone or something)", so as long as it loosely fits this definition then it's fine in my book. The word fetch wasn't invented for the Fetch web API.
One pamphlet please.
Yes.
I wouldn't suggest taking extra responsibilities at work nor working extra long hours. I don't know anything about your company so this may not be the case, but many companies just want to spend less money and get more results. People like you, who want to learn more and are willing to put in more work are usually the first ones being used by the company. You should find some personal project to work on, try to copying an existing application or make something for yourself that you can use, or do something for a friend etc.
You can do it with a few regular expressions like this. const creditCardNumber = '1234567890123456'; creditCardNumber.replace(/[0-9]{1,12}/,'**** **** **** '); or this if you want it in a function ``` const creditCardNumber = '1234567890123456'; const getCreditCardNumber = ccNumber =&gt; { const lastFourDigits = new RegExp(/[0-9]{1,4}$/).exec(ccNumber); return `**** **** **** ${lastFourDigits}` }; getCreditCardNumber(creditCardNumber); ```
Is there any major benefit to using one over the other ? I thought that these weren’t as necessary anymore? (Amateur here) 
Exactly. My current job has me using old JS. Most of our stuff is written in razor. Our UI is internal facing. It isn't economical whatsoever for us to arse with retrofitting transportation into a 10 year old system using minimal JS to begin with. 
:(
Typescript gives you static typings, so there's a huge benefit there. I can't see there being many cases where I would use Babel over typescript nowadays unless I'm just creating a rapid mockup.
How are you calling `projectHTML`? Since that function is also an async function, it would mean it also returns a promise... so if you tried to place its output directly into the markup, this is the result you would get.
its being called on a click eventlistener... its only async because of the `getProject()` 
yea i have it ...it was just a typo on reddit
This statement really makes no sense at all. The whole point of doing TDD is so that you can deliver business requirements quickly with confidence, and that means being able to handle change without stress. Moving quickly is the WHOLE POINT of doing TDD in the first place. So claiming "we don't have time for TDD because we have tight deadlines" is completely counter-intuitive. What you're really doing is embracing techniques (or a lack of a technique in this case) that will actually cost you time and slow you down, all in the name of moving faster.
the first function was a typo on reddit it is a async function in my code... also the `getProject()` function doesnt return a promise but it does contains a fetcg get request which i await instead of promise syntax. so in order to do that i need to make the `getProject()` function async.
Here you have them [https://vuejs.org/v2/guide/render-function.html#Complete-Example](https://vuejs.org/v2/guide/render-function.html#Complete-Example)
I use it on a daily basis for front-end work. I am always trying to keep up with the standard as soon as features become available and then use tools like webpack and babel to compile down for a better browser support. On the back-end, when writing for NodeJs for example, I prefer to write code which can run without the need of transpilation. Usually, by targeting a minimum version of Node to support I try to keep my code compatible with that version.
As someone pointed out, it was not on the time of commenting 
thanks for help i figured it out. I forgot to turn my event handler on the click that called projectHTML into a async func.. smh
snarkyComment.then(_ =&gt; actuallyThatsCool())
This is true, but it's also a buzzword in modern js. I think since the application is similar, why not implement it as such?
This is also true.
const preload = Preload(); preload.preload([‘file1’,’file2’]); It just doesn’t read well. ‘load’ is a term used on different libraries and APIs and they don’t necessarily collide.
Babel 7 fully supports typescript now with @babel/preset-typescript.
I don't understand all the hype around hooks. In my opinion they just bring impurity to components. Wouldn't hocs be a better solution 90% of times?
lol yeah I know, it was a bit of a harsh joke. I'm just memeing 😇
When hyperapp decides to render due to state change from actions it will recalculate the vdomtree for the whole application, right? And then diff it to the previous. In react or vue using stateful components it will only recalculate the vdomtree from the node where state was change. &amp;#x200B; This is how I would do this (link: [https://github.com/cjh9/NoMoreFrameworks.js/blob/master/examples/EditorWithSideBar.html](https://github.com/cjh9/NoMoreFrameworks.js/blob/master/examples/EditorWithSideBar.html)): &lt;body&gt;&lt;script type="module"&gt; import { h, setup } from "https://unpkg.com/lifecycle-petit-dom?module" var items = [ {name:'Test', address:'Teststreet 32', phone:202342}, {name:'Test', address:'Teststreet 32', phone:202342}, {name:'Test', address:'Teststreet 32', phone:202342}, {name:'Test', address:'Teststreet 32', phone:202342} ] var RightPane = ({item}) =&gt; h('div', {}, item ? Object.keys(item).map( key =&gt; h('input', { type:'text', style:`display:block;`, oninput: evt =&gt; { item[key] = evt.3.value, render() }, value: item[key] }) ) : 'please select your item' ) var SideBar = ({items, onclick, activeIdx}) =&gt; h('div', { style:` width:300px; ` }, [ items.map( (itm, idx) =&gt; h('div', { style:` cursor:pointer; ${activeIdx === idx ? 'font-weight:bold;' : ''} `, onclick: ()=&gt; onclick(idx) }, [ itm.name ]) ) ]) var activeIdx = -1 const Root = () =&gt; { return h('div', { style:` display:flex; ` }, [ SideBar({ items, activeIdx, onclick: newIdx =&gt; { activeIdx = newIdx render() } }), RightPane({ item:items[activeIdx] }) ]) } const render = setup(Root) &lt;/script&gt;&lt;/body&gt; Any suggestions?
I need to run tests for a library that works on node.js, browser, React Native - and on [low.js](http://www.lowjs.org/). I use mocha, and so far I can run the tests on node.js and in the browser, exactly the same tests, only that the browser tests are run through an index.html page that loads them through SystemJS using the webserver started by WebStorm. Does anyone know how I would extend that to include React Native? What would Jest give me over mocha, especially in this cross-platform scenario?
Thank you for that, however I am very likely missing something here, how does this code relate with anything? 😅
IE11 isn't very old compared to ES6, babel will have a setting to offer IE11 support. The only feature it won't transpile are proxies, which it can't do for other browsers either (although other browsers have added support for it by now).
Is that all? Are the benefits of these optimizations documented somewhere? 
You don't think someone well versed in ES5 wouldn't take a few days to adjust to ES6 and be up and running optimally? 
That code is atrocious to look at. You could have commented that in the old way too. const age = monkey.age; // (int) current age in years const name = monkey.name; // (string) friendly moniker to call the monkey const hairyness = monkey.hairyness; // (float)[0-1] percentage value of hair coverage You can't set defaults like this but you should really be setting a default when the object is initialized, not when using it. The comments should also be in the class/object initialization too. Fuck that's messy.
We do lmao. I wish we would do ES6 or start using TypeScript religiously.
My boss hates polyfills and want us to write a manual hackjob for Array.find and Array.findIndex instead. :(
Not as much as I would want to. **slaps the 10 year old company codebase** This boy can fit so much inline vanilla js and legacy jQery in it. All mixed up.
HOC's also can't use lifecycle methods.
I get to work for a controlled enterprise environment that has Chrome 60+. So picking ES6 was not a complicated decision.
&gt; I can code close to a functional language but don't have to use a functional language Especially when combined with object literals.. in the most common format we have to use every day for everything else... JSON. i.e. a config object passed to a constructor... instead using a bunch of setter mutable methods. And really great with typescript given you can use interfaces without even implementing them in a class.
Over the weekend I created a small Chrome extension that gives you a random programming question for every new tab. &amp;#x200B; The questions aren't exclusively Javascript, but most of them will end up being JS as it's basically my default pseudo-code. &amp;#x200B; [https://chrome.google.com/webstore/detail/astro-bot/acjiedbilhbchmjblapmekfajpplpgdo](https://chrome.google.com/webstore/detail/astro-bot/acjiedbilhbchmjblapmekfajpplpgdo)
How come? For example react redux connect hoc uses lifecycle methods? 
Well, **redux** **connect** undoubtably extends React.Component. Using a classical component kind of defeats the purpose of your argument, doesn't it? Hooks are intended to replace the requirement of extending React.Component. &amp;#x200B; Hooks bring the power of class components to functional components. Technically speaking from a javascript perspective, they're not pure functions, but from a react perspective they're still pure **components.** Hooks make writing and reading components easier and faster. Could you accomplish the same thing with todays API? Of course. They're not adding anything new. They're just making what already exists better.
No idea but another way to implement currentTime is `hours*100+minutes`
But let's say I have a week-by-week deadline where each week I aim to demonstrate some new features and let users play with them to see whether they like it or not. Additionally those features are not known in advance because that's what we're trying to find out. If I spend a couple of days each week writing tests, I won't have the time to actually implement things.
Hook is best
Is there any reason not to stick with class components? I've definitely run into occasions where I want to share functionality but in those cases I just create pure functions as separate utils. I'm not decrying the hooks API as bad, but there is something about it that sits... odd to me. It's adding blackbox to what are otherwise very straight forward and "pure" code. I know there are tons of examples in React where this happens, but for some reason I'm wary of this one. Might just be being over defensive having had worked on Ember for so long.
I honestly don't understand all these workarounds to problems React creates for itself. The value is in the DOM and renderer. Everything else should be left up to the developer. They keep introducing stuff and then they keep adding stuff to fix the previous stuff. Before long this is gonna start looking like Angular. Which would be a real shame, because unlike Angular, React's core concept is solid and its execution doubly so.
something like: &amp;#x200B; const arr = [ ["1", "2", ","], [ "1", ",", ","], [ "," , "," , ","] ]; const sparr = arr.map( innerArr =&gt; { return innerArr.map( innerValue =&gt; { if( innerValue === ',' ){ return ' '; } return innerValue; }) }) console.log(sparr); &amp;#x200B; &amp;#x200B; &amp;#x200B;
Very well written tutorial! Thanks for sharing!
The hype is certainly _artificial_ and intentional, which is sort of a shame but also all too common in the development community. Now, there _is_ some merit to hooks, mainly one similar to the merit of context earlier this year. Context is a way of bypassing or subverting the original idea of _one-way-data-flow_. There was no real "need" for it -in the sense that it's not doing something _new_ but offering an alternate way-, except that it makes life somewhat easier for certain developers that were doing some things in a non-optimal way. Hooks are, in a sense, the same. They're not introducing something really _new_, but offering a way to bypass some decisions and ideas set by React in the past. In this case about _state-management_. Personally, I think all this is not really a reason to rejoice about React. Instead it makes me feel like they're patching particular developer struggles through _magic_ and hidden rules. In fact, I think it's a classical problem: You start with an apparently "simple" idea and work from there. Then, as time passes you discover the original idea wasn't really that good or that well thought. Complexity has started to appear in various forms and places. There are different approaches one could take; React goes for hiding complexity through some _magic_ rules which, being mostly mechanical, do -to some extent- alleviate _some_ developer's struggles. I think it's a bad approach, but that's just me. --- Turning to the article... I think it makes a number of obvious mistakes. I'd tend to think these are intentional to produce the narrative, but, again, that's just my personal opinion. In any case: The author incorrectly identifies some of the problems and exaggerates them. First, in the _mixins_ example, he states: &gt; indirection from magic undocumented methods appearing out of nowhere and being used on components. The developer has no idea what functionality is available to them and more importantly what is not. Methods are _not_ appearing out of nowhere. You, the developer, are importing them and setting them up in the `mixins` property. You cannot really argue ignorance here; you chose to use those mixins _supposedly_ for a reason. (Personally I think this argument denotes either ill intention or indicates that the author is speaking towards a very particular audience: those "certain developers" I mentioned earlier). Then, when talking about HOCs, he draws some conclusions which are highly dubious: &gt; You can not distinguish between data that was coming from the HOC and the data that was passed to the component. &gt; The HOC is external to the component yet the component remains dependent on the HOC. Remove the HOC and the component would not always work if it depends on the HOCs data. Your component **should not** distinguish if a particular piece of data comes from a wrapping component or from somewhere else. It is precisely when you do that, that your wrapped component ends up being dependent on the wrapping component. This argument _clearly_ indicates bad understanding of the design. Not of the design of React, even, but of general design and architecture. At one point, the author mentions _"needing to understand"_. This, clearly, indicates what we're dealing with here. _Needing to understand_ should be **required**. You should never do things you do not understand. Otherwise you're not a developer but a _cog_. Please, don't be a cog and don't argue against understanding. you're not doing anyone a favour. If you want, argue against complexity, but never against understanding. And also, argue in favour of _simplifying_, not in favour of _hiding complexity behind magic or comfort_. The author also presents as arguments some general failings which he even reckons are not really related to the other approaches (hint: they are related to bad programming). And finally, the author downplays as "minor", what is actually a _hideous_ thing: that these hooks rely on hidden rules and calling order. And, sorry, but some [linter rules](https://github.com/facebook/react/blob/46952bcea5b84f3d1c1e2f4d9b9eb35a58d34e6f/packages/eslint-plugin-react-hooks/src/RulesOfHooks.js) are **not** an appropriate solution. --- All in all, going a bit further, I can't help but consider how _distorting_ React is and how _farcical_ the development community is. They spit out some _proposal_ -yes, let's remember this is still a proposal, in an _alpha_ branch-, and just a couple of days after that, we get dozens of articles about how this is "a game changer" and how everything is so great. The paranoid in me would suspect major astroturfing here, but sadness just makes me fear people actually believe this shit when they write about it.
This is the destructuring thing that was mentioned earlier - I'm pulling out those variables from an object called `monkey` and if any of those values are `undefined` or the keys don't exist then it'll assign them a default value.
All this 'no framework' trend is kinda funny. Even if you go full vanilla you will inevitably give birth to your own rules and patterns. Which will in essence give birth to your own framework. Problem is, you on your own aren't competent enough to form those most optimal Rules and make all those decisions. That being said, no framework argument has it's merits. There are a lot of developers especially younger Ones, who lack competence in basic things and rely on framework api too much which gimps their competence and growth.
Thanks for the constructive reply. IMHO I find hooks encouraging to bring state management complexity inside component, whereas hocs encourage to extract it to the hoc, keeping the component simple and pure. That being said, I see a lot of potential in hooks, when used correctly.
I see that Babel now support TypeScript, so no I guess not. The only reason to keep using it this way is that I work with Angular and that already comes with TypeScript configured so why bother switching :)
Yup, that's an argument against destructuring and an alternative if you don't like using it - if you'd like to stick to pre-ES6 formatting then you could also implement defaults by doing : `const age = monkey.age || 10;` The monkey example I gave was just to give a bit of levity to the discussion - the development community has a real bad problem with getting serious and and angry at the drop of a hat, so I chose monkey - if you'd like a more real-world example then look no further than React's `this.props`; destructuring that object allows you to combine it with the tasty `...spread` operator : const { age = 10, name = "Gary", hairyness = 0.5, ...remainingProps } = this.props; This what you can extract what you currently need from the props, and have everything you're explicitly *not* using as a single variable to do with what you will later. Ofc, these ways to implement all of this pre-ES6 - it's all sugar that can be used or ignored based on personal preference / standards that your current team has decided on.
Completely agree with you here. I had a look and it struck me as something that was added to compensate for edge cases, perhaps exaggerated by laziness/bad design decisions. Side note: actually not enjoying the hype either, it feels like people are being paid off to shout from the roof tops how great it is.
&gt; const ssn = '123456789'; const tmp = '*****'+ssn.slice(0,5) This would produce `*****12345`, which is both the wrong length and the wrong part of the string is used.
That is great bud, but how to do that by regex?
only the core concept, and probably best extracted out (forked) and put on a newer, better API over it
The motivations for the Hooks feature proposal are the following ones: * **To reuse the Stateful components logic** * **Reducing complexity from components to make it easier to understand** * **Get rid of the phenomena “Classes confuse both people and machines”**
The good things about hooks and why you don’t need to be worried are explained below. * **Hooks don’t replace our knowledge of React/Vue concepts.** * **There are no plans to remove classes from React/Vue by the creators.** * **Crucially, Hooks work side-by-side with existing code so you can adopt them gradually.** * **Fully backwards compatible.** The motivations for the Hooks feature proposal are the following ones: * **To reuse the Stateful components logic** * **Reducing complexity from components to make it easier to understand** * **Get rid of the phenomena “Classes confuse both people and machines”** r/https://medium.com/@shuvohabib/vue-js-hooks-and-react-js-hooks-at-a-glance-fe5623e9ac52?source=friends_link&amp;sk=9659c72e31769a52f1a831a7bdbbe9c4
The good things about hooks and why you don’t need to be worried are explained below. * **Hooks don’t replace our knowledge of React/Vue concepts.** * **There are no plans to remove classes from React/Vue by the creators.** * **Crucially, Hooks work side-by-side with existing code so you can adopt them gradually.** * **Fully backwards compatible.** The motivations for the Hooks feature proposal are the following ones: * **To reuse the Stateful components logic** * **Reducing complexity from components to make it easier to understand** * **Get rid of the phenomena “Classes confuse both people and machines”**
Safari and iOS
I would say that is the *correct* way. The current approach seems horribly broken. If minutes is 0 you now get 170 not 1700. I suggest to correct that and see what happens.
For my day to day work, my main issue is Safari and iOS. Last week again, a fairly new work mate pushed some JS using let keyword into one of our sales app. A part of sales use iPad with iOS 9 which doesn't support let. Basically, for sales apps we try to keep it ES5 friendly to ensure it works in most iPad generations. 
You could do this. ```JavaScript const oldArr = [ ["1", "2", ","], [ "1", ",", ","], [ "," , "," , ","] ]; const newArr = arr.map(a =&gt; a.map(b =&gt; b.replace(",", " "))); // ​​​​​[ [ '1', '2', ' ' ], [ '1', ' ', ' ' ], [ ' ', ' ', ' ' ] ]​​​​​ ``` If you want to use RegEx, just replace `","` with `/,+/`.
Nope, you're missing the point. TDD helps you move quickly. The problem you are describing is down to bad tests, not tests themselves. &gt; because as requirements change, all the tests need to be rewritten. That is not going to help anyone move fast - sorry but it just is not You are correct. But this has nothing to do with TDD, and everything to do with badly written tests. TDD doesn't force you to write tests that need to be rewritten when requirements change. That's the whole point - your tests should help you to make changes, not get in your way, and this is possible by focusing tests on behaviours and not implementation details. TDD when done well works wonders for working in small, fast increments. All you are doing is taking your experience on a project with badly written tests and projecting it onto others. I can make changes to my code quickly, with confidence, and without having to manually check the whole world every time I make a change. This is due to TDD and the way I write tests. Sort your attitude out. You are speaking to someone with far better experience on this matter than yourself, and by taking a step back and listening instead of instantly dismissing something you clearly don't understand, you might stand to learn something. This works in practice at scale. I worked on the football scores on the BBC Sport website. On a busy day we can have 20 million views on that page, and we often released changes to it without manually testing, because the tests gave us that freedom. 
Why not? Simply cast the variables. For example: Let y = Number(el.value) If (y + 1 == 1000)... 
No, that's not how it works at all. In TDD you're in a cycle. And that cycle is usually fast, like just a few minutes or even seconds long. Don't write a load of tests upfront or anything like that - you write one test at a time, before writing your implementation, and then see that test fail. You then write enough implementation to make that test pass, then tidy up/refactor anything that needs to be tidied. Then you add another test for the next behaviour, and repeat until you're done. Alongside this, you should focus on testing behaviours, not individual units of code, and you'll find you actually move quickly. BTW, I'm coming from a model where we demo things usually on a weekly basis. TDD helps me do this faster. Imagine inheriting a new code base and you've been asked to write a new feature. While working on your new feature you have a screen running with your tests in continuous watch mode, so every time you save a file all your tests run. Then imagine your tests are written in such a way that if you break something, you get a failure in seconds that not only tells you something is broke, but what is broken and why that matters. So you start coding your new feature, but you didn't know the full context behind every line of code, so you break some existing behaviour without realising it. Your tests go red in seconds, so you take a look. There, there's a human readable explanation of a feature that you've broken. You can check in the browser and you'll see the feature is indeed broken. So you go back to the code you just changed and revert it. The tests go green, and the old feature works again. Then you figure out what the cause was so you ensure your new feature goes in without breaking that original test. Your own feature was coded against a failing test, which helps the next person who comes along. This is the rapid feedback I'm talking about, and I experience it every day. Have done for about 5 years now. I can only say that people in here who dismiss this instantly are plain wrong. Can you see how this model works nicely though? You can then code out your own feature in a nice fast feedback loop, and when you finish you have high confidence that your code didn't break anything existing. Nice and easy and in time for your end of week demo - but this time you have the added confidence that you didn't break something that already existed.
&gt;l in essence give birth to your own framework. I wouldn't say a short markdownfile is eqvivalent to a framework with a huge api surface such as angular. &amp;#x200B; &gt;Problem is, you on your own aren't competent enough to form those most optimal Rules and make all those decisitions. Even using a framework you run in to these problems. Then you have to employ an expert with 5 yrs of experience with that particular framework. Try and test. &amp;#x200B; &gt;Writing your own vanilla code provides no Age over 'framework wont survive'. Your legacy wont survive either. I would rather maintain a well structured nativejjs app from 2011 than a backbone app. Maybe it's just me..
Your example is the reason I hate JavaScript's Type Coercion: If I miss to care about a type conversion, JavaScript's Type Coercion will surprise me someday in future. Also `Number(...)` is a part of Type Coercion, and you have used it in your example, therefore you didn't avoid using abnormal behaviour of Type Coercion.
Team lead at a big 4 bank, but keep making excuses 🙃
Server side, yes. Front-end, mostly no (only for personal projects). There are PCs at my work still running Windows 7 with strict IE only policy, so...
Congratulations! That's a *big* step. Be proud that you were able to make the switch. Not many people manage to transform ideas into results. I think there are **four areas** on which you need to focus, in order to go from mediocre to great. Those areas are: 1. Theoretical foundation. 2. Working knowledge. 3. Software engineering practices. 4. Soft skills. Now, these areas don't include things like marketing yourself or building valuable relationships with coworkers or your local programming community. I see those as being separate from being great at what you do. However, they're **at least as influential** in creating a successful and long-lasting career. Let's take a look at what you can do to improve yourself in those four areas. I'll also suggest some resources. &amp;#x200B; **1. Theoretical foundation** Foundational computer science. Most developers without a formal degree have some knowledge gaps here. I suggest taking a MOOC to remediate this. After that, you could potentially take a look at improving your data structures and algorithms knowledge. \- \[CS50: Introduction to Computer Science\]([https://www.coursetalk.com/providers/edx/courses/introduction-to-computer-science-3](https://www.coursetalk.com/providers/edx/courses/introduction-to-computer-science-3)) \- \[Grokking Algorithms\]([https://www.amazon.com/Grokking-Algorithms-illustrated-programmers-curious/dp/1617292230?keywords=grokking+algorithms&amp;qid=1540726964&amp;sr=8-3&amp;ref=sr\_1\_3](https://www.amazon.com/Grokking-Algorithms-illustrated-programmers-curious/dp/1617292230?keywords=grokking+algorithms&amp;qid=1540726964&amp;sr=8-3&amp;ref=sr_1_3)) \- \[Algorithms by Sedgewick\]([https://www.coursera.org/learn/algorithms-part1/](https://www.coursera.org/learn/algorithms-part1/)) &amp;#x200B; **2. Working knowledge.** I'd suggest doing a JavaScript deep-dive before focusing on your stack. I prefer screencasts and video courses for this, but there are also plenty of books available. After that, focus on the specific frameworks that you're using. While you're doing front-end work, I also suggest you to explore the back-end. &amp;#x200B; \- \[FunFunFunction on Youtube\]([https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q](https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q)) \- \[You Don't Know JS\]([https://github.com/getify/You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)) \- \[JavaScript Allonge\]([https://leanpub.com/javascriptallongesix/read](https://leanpub.com/javascriptallongesix/read)) \- \[JavaScript Design Patterns\]([https://addyosmani.com/resources/essentialjsdesignpatterns/book/](https://addyosmani.com/resources/essentialjsdesignpatterns/book/)) &amp;#x200B; **3. Software engineering practices.** Design patterns and development methodologies. Read up about testing, agile, XP, and other things about **how good software is developed**. You could do this by reading the 'Big Books' in software, like Code Complete 2 or the Pragmatic Programmer, in your downtime. Or, if you can't be bothered, just read different blog posts/Wikipedia articles. &amp;#x200B; **4. Soft skills.** 1. Actively seek to **mentor and teach others** (perhaps an intern at work, or someone at a local tech community, or create blog posts or videos online). 2. Get a mentor. 3. Go to programming meetups. 4. Try public speaking, go to a Toast Masters meetup. 5. Learn more about and practice effective communication. 6. Learn more about business and the domain that you're working in at your company. 7. Read \[Soft Skills\]([https://www.amazon.com/Soft-Skills-software-developers-manual/dp/1617292397?keywords=soft+skills&amp;qid=1540728095&amp;sr=8-3&amp;ref=sr\_1\_3](https://www.amazon.com/Soft-Skills-software-developers-manual/dp/1617292397?keywords=soft+skills&amp;qid=1540728095&amp;sr=8-3&amp;ref=sr_1_3)) or \[Passionate Programmer\]([https://www.amazon.com/Passionate-Programmer-Remarkable-Development-Pragmatic/dp/1934356344?keywords=passionate+programmer&amp;qid=1540728127&amp;sr=8-1-fkmrnull&amp;ref=sr\_1\_fkmrnull\_1](https://www.amazon.com/Passionate-Programmer-Remarkable-Development-Pragmatic/dp/1934356344?keywords=passionate+programmer&amp;qid=1540728127&amp;sr=8-1-fkmrnull&amp;ref=sr_1_fkmrnull_1)) for more tips. &amp;#x200B; Some closing notes: \- If you can't be bothered to read or do large online courses, or just want a structured path to follow, subscribe to [frontendmasters.com](https://frontendmasters.com) and go through their 'Learning Paths'. \- 4, combined with building relationships and marketing yourself, is what will **truly differentiate you** from a lot of other programmers. &amp;#x200B; Sorry for the long post, and good luck! :)
I've recently created a project with around 60kloc and many hundreds of components. I can't imagine doing it without HOCs. How else would you reuse logic between components? Please don't say mixins or inheritance.
Don't use cannon for mosquito. Frameworks have most common problems already solved in scalable way. It wont be well structured.
The hype is because Dan Abramov announced it and everyone blindly accepts what he says because he’s a god like figure, it’s bizarre 
I'd like to be more helpful, but basically none of this makes any sense. I would suggest visiting the MDN documentation site and reading up on events, functions and... everything.
Are you trying to set a onclick event on a button that you created? If so, check this page at W3School and use the onclick function on the element you created https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_onclick_dom
Exactly! Don't use a cannon for a mosquito. Don't start to learn an over bloated framework with unnecessary abstractions "that scales" when you just want to build stuff. Work like an startup, build, iterate, refactor. Angular is not even used internally at Google, even though they have super experienced people developing it. I have a problem with that authority argument, it never applies to the reality. &amp;#x200B; &amp;#x200B;
This is real interesting. Cool concept for learning!
this is the common hangup i've heard with respect to hooks. react has been (or has felt) very explicit up until hooks when it introduced a bunch of implicitness. i do not buy their reasoning that the hardest part about learning react is dealing with classes, when the common "learn react arc" goes something like: learn react, find out about redux, learn redux, use redux everywhere, hate redux, try to find out how to do things without redux, struggle with state, eventually settle in some middle ground of state management.
 You're calling the function in quotes. Change att.value = "fun(x)"; to att.value = fun(x);
Except you kinda sorta need to worry, because sooner or later you will encounter codebase with hooks. Given how developers love their new toys (especially JS developers ;D) just hope it won't be 100% functional components with hooks. I like the idea, it does look promising, but it looks pretty immature right now. I think they are just trying to push functional components into React way too hard and I'm afraid it will cause more bad than good.
i think what you're trying to do is create an onclick handler for a button using the function `fun`? I think you want to do something like: var btn = document.createElement("button"); btn.onclick = function(result) { console.log(result); }; start with that and go from there. i don't think you'll be able to use `result` the way you're expecting to though.
If you expect the computer to lucky guess what you want you'll get unpleasant surprises. Yeah, JavaScript type coercion work could more like unaware people expect it to work. For example, there could be another operator for concatenation and + would try to convert strings to numbers such that `el.value + 1` with el.value being `"1"` would evaluate to `2` instead of `"11"`. But then you could go lengths without noticing `el.value` is a string and it could eventually blow up in your face. So, you shouldn't be using type coercion unless you know how it works or even using it without being are that you are using it. But then, if you were aware that `el.value` is a string you could simply cast it to a number... Maybe things like adding a string to a number shouldn't be allowed, or at least throw a warning. But I understand this is JavaScript and it will work no matter how weird is your code. I perfectly understand why "1" + 1 can't be 2, it makes sense to me because + is also the concatenation operator and sometimes you really want to concatenate "1" with 1. Maybe the problems some people have is that they expect things to work in a certain way without being aware that in other circumstances they would want it to work in a different way, and the computer can't guess.
Hooks were to solve issues developers had with classes. I'd recommend checking out the first two speakers for React Conf. The first introduces the biggest problems developers have with React, the second covers hooks and how they solve these problems.
Why do you want to use regex for one character? Oo
When you call `document.createTextNode(result[l].name)`, `result` will be undefined since it's only declared in the context of `fun()`. This will throw a ReferenceError. Perform any actions that require `result` inside of `fun()` instead of outside.
Haha, maybe the author saw it? Either that or it was super ironic timing.
Ok, so that means you’re in an industry where they can throw money (eg large human capital) at problems. Try working with smaller businesses where they have legacy systems and very small teams where you have to balance tight budgets and new features / systems with old ones. You still need to maintain the old while working towards a new future. You still come off as a pompous ass who’s disconnected from many of the realities of the real world. Claiming someone should be fired who has years of intimate knowledge about the inner workings of a company both technically and on the non tech side is something a very naive and ignorant thing to say. There’s a difference between embracing new technology and facing the realities of having to maintain old technology. It takes someone who knows both, as well as a HUGE change management aspect for moving from old software to new from the end user perspective and that doesn’t happen overnight, especially in small teams. 
Entirely for reusing logic between components? Yes, almost exclusively. Again, what would you say are the sane alternate methods?
async functions return promises
Remembering that [Markdeep](https://casual-effects.com/markdeep/) also supports LaTex, and a whole lot more as well, I wondered how they compare in size: (open devtools + network tab, and click these links to verify for yourself) - [Minified TeXMe](https://raw.githubusercontent.com/susam/texme/master/texme.min.js): 2.29KiB transfered, 3.44KiB - [Markdeep](https://casual-effects.com/markdeep/latest/markdeep.min.js): 50.13 KiB transferred, 119.26 KiB Markdeep contains its own markdown renderer. TeXMe uses [commonmark](https://cdnjs.cloudflare.com/ajax/libs/commonmark/0.28.1/commonmark.js) for rendering markdown: 40.56 KiB transferred, 165.03 KiB. TeXMe and Markdeep both use MathJax, but slightly different versions: Markdeep uses MathJax 2.7.1, TeXMe uses 2.7.5: - [MathJax 2.7.1](https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js): 18.68 KiB transferred, 61.57 KiB - [MathJax 2.7.5](https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js): 18.83 KiB transferred, 62.04 KiB So in total: - TeXMe: 2.29 + 18.83 + 40.56 = 61.68 KiB - Markdeep: 50.13 + 18.68 = 68.81 KiB This is of course all on first load since the stuff will be cached, commonmark might already be cached when using TeXMe, so it can have a bit of an advantage there still (since they both use MathJax it's a tie in that regard). I think in contexts where I want to render LaTeX I usually would want to make use of the extra features that Markdeep offers. But if I want plain markdown, the [MdMe](https://github.com/susam/mdme) spinoff looks appealing.
You can use it with jQuery unless you're supporting older browsers. Even still if you create a build system you can still use it.
It’s 2018. I’d expect that if someone were gunning for a job with an explicit ES6 requirement in the job description, they’d have taken the few days to study up before applying. Experience as a hiring manager tells me that doesn’t happen. I’ve had a few candidates on phone screens be able to speak to what ES6 provides at a high level, but when it comes to the assessment, end up delivering jQuery (which contradicts the existing pattern in the assessment and throws everything off). There’s a definite divide in the discipline between those stuck in ES5 and those who’ve clearly made the jump. Again, it’s 2018: Make the damn jump.
If you watched Dan's (and Ryan's) talk and still say this then I'm genuinely confused as to your goals in development.
That's pretty badly taken out of context. The part that's confusing in classes is there are a lot of gotchas. Binding methods (or using weird property syntax), lifecycle method headaches, duplication of logic. It all leads to not having clear code. The talks they have are really great at showing the improvement. I was also skeptical at first, but am eagerly awaiting more info from the proposal and release.
The hate and myopia I'm seeing in the comments is jarring People are speaking with certainty that hooks is a solution in search of a problem, that the hype for it is artificial, and people who are excited for it are sheep who'll cheer for anything that Dan Abramov presents. React is the _most popular front-end framework in the world_. Consider the possibility that people who make different products with React may use it differently, and perhaps the use cases of React you're familiar with is a fraction of what the entire community uses it for. Vue's creator Evan You hasn't always had good things to say about React. His reaction to hooks was - "For the record, I think hooks is a pretty genius idea in terms of composability and overcoming JS’ language constraints." ([link](https://twitter.com/youyuxi/status/1056043229030817792?s=19)) Is it more likely that all the people who are excited about hooks, e.g. thought leaders like Ryan Florence, KCD, (who aren't Facebook employees) are all misinformed or in cahoots? Consider also that react-powerplug has 15k weekly downloads, and recompose has 900k (nearly double that of the Vue framework) https://npmcharts.com/compare/react-powerplug,recompose,vue . Clearly there is a sizable number of people who have felt the need for a feature similar to what hooks provides, and have felt it enough to use third party libraries for it. Hooks solve that problem in a flatter and more standardized way. 
given: &lt;form id="form" data-validate="validate" data-success="success" /&gt; you can write: const form = document.getElementById('form'); const fns = { validate() { return true; } success() { console.info('Hooray!'); } }; form.addEventListener('submit', async () =&gt; { const validate = fns[form.dataset.validate]; const success = fns[form.dataset.success]; if (validate()) { const res = await fetch('blahblahblah', { body: JSON.stringify('blah blah blah') }); if (res.ok) { success(); } } }); There's really no good reason to use eval. `new Function` is better in most cases, and there's rarely a good reason to use that, either.
I agree we need to evolve but someone that doesn't use es6 is not automatically a bad dev. In my case my current job has a large database that has to support ei11, the company doesn't want to invest the time and money to develop a sane build system so we are stuck in 2014. Last time i tried to use let/cons or an arrow function I broke the server build and I got yelled. I try to stay on top of things but this far I only have a theorical understanding of es6, never been able to use it on real life projects (appart of some personal small projects).
Why wouldn't it? The only `return` statements you have are inside the arrow function, so they're only returning from that context - not from the `getSame` context. You probably want the `squared.forEach` to have a `return` in front of it. 
Also foreach doesn't return anything, you are looking for filter
Assuming you want to return a new array where each value is true if the item at the same index in each array is equal: const a1 = [121, 144, 19, 161, 19, 144, 19, 11]; const a2 = [11 * 11, 121 * 121, 144 * 144, 19 * 19, 161 * 161, 19 * 19, 144 * 144, 19 * 19]; const getSame = (arr1, arr2) =&gt; arr1.map((x, i) =&gt; x === arr2[i]); console.log(getSame(a1, a2)) // [true, false, false, false, false, false, false, false]
&gt; You probably want the `squared.forEach` to have a return in front of it. But `forEach` will always return `undefined` 
Can I have a pamphlet please?
Loving this but you don't happen to have a database compatible with Anki? Would love to incorporate it in my daily studying routine.
Hi /u/lil_falco, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
The article announcing hooks on the react website. They also say that learning 'this' context is too hard.
Where do you have logic duplication in classes that you wouldn't have elsewhere?
Yes, you're right, I was thinking of `map`.
Doesn't Vue have more stars?
Ah, thank you, [found it](https://reactjs.org/docs/hooks-intro.html#classes-confuse-both-people-and-machines) &gt; In our observation, classes are the biggest barrier to learning React. You have to understand how `this` works in JavaScript, which is very different from how it works in most languages. You have to remember to bind the event handlers. Without unstable syntax proposals, the code is very verbose. People can understand props, state, and top-down data flow perfectly well but still struggle with classes. The distinction between function and class components in React and when to use each one leads to disagreements even between experienced React developers. I agree that seems like a weak argument to lead with
Some cases can be solved with renderprops others with FAAC. Not saying HOC's are bad, they have many uses, but there is overlap between them, and often I would rather have a FACC instead of a HOC. 
 async function getProject(id) { try { return fetch(`http://127.0.0.1:5000/api/projects/${id}`).then(res =&gt; res.json()); } catch (e) { console.error(e); } }; I think I would do it like this
The hype comes from functional programmers that believe in composability, the fact that custom hooks allow for composability of state management has potential for making state management insanely readable, kind of like how monads make IO more readable, except its much more readable than a monad and much easier to use. The absolute bonkers part of this proposal is how insanely SIMPLE the api is. In hindsight it doesn't seem that impressive, but imagine all the problems that they were trying to solve: complex inverted dependencies through render props, indirection in higher order components, reactivity, moving away from classes etc. The fact that they were able identify and solve all these complex problems with such a simple api that is also composable, flexible, extendable, while keeping it reacty is rediculous. 
Source? Would also be appreciated if the code was highlighted and wouldn't use obsolete `var` keyword.
Why not just call the functions from Window? const funcName = "sucFunc" const result = Window[funcName]()
The talks explain all of this (and more) better than I could in a Reddit reply. 
Or at least not wrong would also be nice. The function depicted on the screenshot returns an array of four times undefined which isn’t one of the options. “output” could of course also mean something like “printed by this function”, but in that case the use of `map` instead of `forEach` Is confusing. Also, `console.log` appends a newline, so again none of the options would be correct.
Thanks, this is a good solution!
I had no idea this was possible, I'll try it out, thanks!
Everyday. Even in legacy code when it's possible. 
Good call. I think I've just been getting used to writing arrow function notation after starting using ES6 far more extensively only recently. I find it an oddly appealing syntax.
Hey, just for completeness, is this a cross browser solution?
Thats one of the current shortcomings of typescript. It compiles to es5 without providing es6. WIth &lt;script module&gt; we can now tell if browser will support our code and serve more performant version (es6) to majority of the users. I'm sure it will catch up, but it's kinda weird. For the longest time typescript was somewhat ahead of the curve. :D
Pretty cool, I would actually like to use this if it allowed me to proceed to my default homepage and listed the language being used above the code block. 
&gt;Babel is a transpiler - it let's you write fancy new syntax (like import!) in your Node.js project, then transpile it into older syntax (like require) that Node or the Browser can understand. So Babel doesn't just get Node to understand import, it also gets ie11 to understand ES6. So, just for my own personal understanding - it basically just kinda acts like a way to polyfill newer syntax for older technologies?
Hooks are a new feature proposal that lets you use state and other React features without writing a class. It’s currently in React v16.7.0-alpha and for Vue JS it’s experimental. Hooks are very easy to learn and very much manageable for complex components r/https://medium.com/@shuvohabib/vue-js-hooks-and-react-js-hooks-at-a-glance-fe5623e9ac52?source=friends_link&amp;sk=9659c72e31769a52f1a831a7bdbbe9c4
I’m still kind of confused (perhaps missed it) as to where the state is scoped. 
Sorry, I didn't understand. Could you please clarify your question?
Sorry I’m not even sure how to ask this correctly. I guess I’m asking ‘where does the state that is connected to the hooks live’. Is it a global react api or is it tied directly to a component it’s being used in? Hopefully that makes a little more sense 
Sorry I’m not even sure how to ask this correctly. I guess I’m asking ‘where does the state that is connected to the hooks live’. Is it a global react api or is it tied directly to a component it’s being used in? Hopefully that makes a little more sense 
State is still local to the component. Think of it as a this.state replacement. For global-ish state you can use the new useReducer hook. 
Oh okay that makes a lot more sense. I think this is going to be one of those things where I need to play with a working repo to ‘really get it’ but that’s good to know. Thanks! 
Ok now do that for everything in a way that is readable and never forget to do it once and also write a chrome plugin to traverse and sniff your custom state logs and replay them with a gui...
If you are going to do that you might as well just make an internal library imo
&gt;r everything in a way that is readable and never forget to do it once and also write a chrome plugin to traverse and sniff yo I honestly never use the timetravel functionality, not even when debugging. But if you really like that stay with redux :) 
Even if you can’t refactor old code there’s simply no excuse to not use it going forward. Industry, team size and money have nothing to do with it. Learning how to use the tools of the trade is one of the most basic requirements for the job.
You said to fire someone for not using it. You simply can't just ignore using it if there's legacy code. I never said to NOT use new stuff when you can, but your comments were simple ", HOW DARE THEY, THEY SHOULD BE FIRED" 
So much for Hooks just being a proposal then... this whole team have already made up their minds
This could probably use more detail about what kind of testing you're looking to learn better. As is it could be confused with anything from just basic debugging to more useful testing.
The proposal is about *implementation* not the feature. You're not going to propose an implementation unless you've already decided you're going to do it. You seem unhappy about it, there a reason why?
Right? I'm not sold on hooks yet. They seem very magical, and there are some weird caveats with them that I don't like. Why must they be called in the same order and unconditionally? Why can't I return early without calling some? Why must they be named a certain way? They may be useful and cool, but that doesn't mean they should be used. I'm happy that they are a supplemental addition to react, but since they are maybe they should just be a separate library instead. Besides, I really don't see the need for them much in my code. I don't have many components that need to share logic. I usually need to share DOM structure or styles instead. 
Is there something like this for Firefox?
 &gt;Why must they be called in the same order and unconditionally? Dan mentioned why order matters in the React Conf talk—its a pretty neat talk and I highly recommend watching all of it and Ryan's as well (it went right after Dan's)! &gt;Why can't I return early without calling some? First question's answer will answer this as well &gt;Why must they be named a certain way? They don't gotta be, it's just a convention for the optional eslint plugin. &gt;maybe they should just be a separate library instead. They rely on using the fiber reconciler to work, so it has to be in React core. 
I started testing with Jest just by tossing it into any new projects I would begin working on. Forcing myself to follow the documentation and write tests for my code definitely helped me see the benefit, and now it means I don’t have to write weird demo scripts for my libraries, I can be confident my code works for most cases, and I can catch bugs as I introduce them. I’ve really enjoyed writing my tests in tandem with my coding, and sometimes I even find myself writing tests first and then implementing to get the tests to pass. As for learning resources, I found the part that took me the most time to understand was what exactly a test was supposed to do. The best advice I can give is to just imagine you were using this package in another project, or imagine that you’re writing some example code. Then ask yourself, “what did I start with before calling this code?” “What do I get after running the code?” “Is this what I expected?” Tests are one of the most controversial topics in programming, just because everyone has their own opinions about how it should be done. I would recommend reading a little more about general testing paradigms, then sticking with what makes the most sense to you, and what helps you the most. Test frameworks are a dime a dozen, as are articles that help you get from nothing to a project that you can start writing tests in. Remember, everyone does testing differently, so it’s only natural that there should be choices! If you have an existing project, or something small you’ve been wanting to make, I’d highly recommend just writing a test or two and seeing what you learn! Remember, tests aren’t required, they serve to give YOU and other developers peace of mind! If you have any questions about testing, feel free to PM me and I’ll help in any way I can!
You have no idea what the RFC process is. 
Sorry, you're absolutely right. All bugs are being fixed ASAP.
Yep I'm adding Firefox support this week - I'll reply here when it's available.
if its not html its crap!
It's not a why that means "what is the technical reason for", is a why that means "why make design an API that requires that trade-off". The concerns are pretty fair. I love how hooks make things so much composable but as far as I am concerned I will not use them for anything else than pet projects. I don't want my colleagues to trip up on the gotchas of hooks.
VanillaJS will always be the framework for me. React is bloated and made for less skilled or lazier programmers.
Thanks, I'm glad you liked it!
Lol the best programmers are lazy. You are busy generating technical debt making custom frameworks for state management.... or you are too noob to even care about that problem.
Cool, thanks for your useless input. They hired the guy that wrote recompose, and if you think that was coincidence, good for you.
Thanks! It helps! 
This is a ridiculous statement and really shows how junior you are. The best programmers rely on abstractions when a situation calls for it. &amp;#x200B; I would hope that a Microsoft dev wouldn't freely make such ignorant/elitist comments, but nowadays people feel like they need to have a strong opinion in order to be seen as intelligent.
&gt; **When to follow this process** &gt; You should consider using this process if you intend to make "substantial" changes to React or its documentation. Some examples that would benefit from an RFC are: &gt; &gt; * A new **feature** that creates new API surface area, and would require a feature flag if introduced. &gt; * The removal of features that already shipped as part of the release channel. &gt; * The introduction of new idiomatic usage or conventions, even if they do not include code changes to React itself. Further reading: https://github.com/reactjs/rfcs/blob/master/README.md
That is actually is a good insight! The platform I’m working with is archaic and complex, but we’ve been refactoring/rewriting stuff to simplify it quite a bit. A good ole rewrite of the js in es6 might be just the thing we need
feature, not implementation
You aren't following here. The RFC doesn't change anything about what I said. It's clear the core team wanted this, so they released a probable implementation then did an RFC. This is going into React either way, it was just a matter of getting feedback on how it works. But sure, they just coincidentally hired the recompose author who EOLed his product but this totally may not make it into core.
Again, if this is what you think, then you have a fundamental misunderstanding of how the RFC process is supposed to work. 
When using TDD there is often 3x the code being written. You're still just completely being ignorant here - there are some types of programming work that would be ridiculous to use TDD for. To force TDD into every type of work is just ignorant that TDD isn't necessary. It's a premature optimization at some level. You just willfully ignore that fact because you've drank some kind of koolaid and refuse to believe that there are other workflows that make more sense for some types of work that won't benefit from TDD. &gt;This works in practice at scale. I worked on the football scores on the BBC Sport website. On a busy day we can have 20 million views on that page, and we often released changes to it without manually testing, because the tests gave us that freedom. You're huffing your own farts here. I told you - TDD works fine for this sort of thing - but NOT EVERYONE IS YOU. NOT EVERY PROGRAMMING WORKFLOW BENEFITS FROM TDD. &gt;Sort your attitude out. You are speaking to someone with far better experience on this matter than yourself, and by taking a step back and listening instead of instantly dismissing something you clearly don't understand, you might stand to learn something. hahahahhahalollllololol You fucking this so, huh. Good fucking luck dude. You sound like you graduated from a code camp where they only taught TDD, so you think that's the only way any programming work should be done. That's just fucking hilariously daft. Seriously, how many years have you been programming? 5? 10? hahahalol try 40 over here. You really think you're gods gift to programming don't you. hahha you come off sounding like a stupid fucking cunt that can't think outside themselves. 
&gt; They don't gotta be, it's just a convention for the optional eslint plugin. As I understood it that's not true - they actually parse the name of the functions, and if it starts with `use`, they add it to the list of hooks.
&gt; They seem very magical, and there are some weird caveats with them that I don't like. They _are_ pretty magical, but [I'm less worried about that than usual](https://twitter.com/VincentTunru/status/1055747566393085952). It allows you to get rid of some other magic, and will, I think, actually feel less magic in practice.
&gt; they actually parse the name of the functions, and if it starts with use, they add it to the list of hooks. That's what the linter does, yes. But other than that, custom hooks are just plain javascript functions which you can write to extract common code for reuse. React doesn't parse them, add them to a list, or even know that they exist at all.
As far as I can tell, `useReducer` still is for local component state. Do yo know if there is any way I can share state across components? (Maybe through context?)
&gt; they actually parse the name of the functions, and if it starts with use, they add it to the list of hooks. The linter does that, yes. But other than that, no. Custom hooks just exist in your code (or in packages you import), as helper functions to extract common functionality. Custom hooks don't get passed into react for react to parse and add to a list. Rather, you call the custom hook, and if necessary the custom hook calls one or more of the built in hooks. 
Anyone got some links for explaining this new Hooks feature? 
Thing is that Recompose does a lot more different than just hooks does (branch/mapProps etc). Recompose lets you separate your view and other logic (not just state) it doesn't kill HoC's, but is more for replacing classes with with functional components. Even then, they're no longer functional components as they rely on some form global black box logic and side effects. They can't be composed easily as they must be defined in the component function themselves. On the surface, I still think I prefer recompose and wrappers for the pure fact that it's predictable and everything remains functional. Though hooks are still nice and you can separate logic out nicely, it feels imperative more than declarative.
So the more useful automated testing. PremiumHugs pretty well covered it below, it seems; I'll try to add what little I can though. I'm only a hobbyist, but personally I use Mocha + Chai for testing as they're what I learned first and I liked the lack of camelCasing in their assertions. I never tried Jasmine, but looked at it a few times. I can't recommend Mocha as it's very simple to write tests that will always pass (evergreen) and are then useless, though it is very simple to write tests. Other frameworks may also have this issue, but the only other one I've tried yet was Jest and it was only once, because I didn't like the camelCaseAssertions. Lol. Jest also has asynchronously running multiple test files going for it, which sounds nice and I don't believe Mocha has that support by default, though IDK for sure. Another great addition to automated tests is Git hooks that can run them (and more) before allowing a commit to be made, or pushed, or etc. IDK if all GUI clients support these, but CLI Git does and anything that uses it (which some GUI apps do behind the scenes) should. And on a somewhat related note I am working on a Mocha-like test framework + Chai/expect-like assertion library, but have been sick for a month and am still recovering after a minor surgery, so haven't done much with it and it's not quite useful as of yet. [The assertion library](https://github.com/l3laze/expect) is working and includes loose, strict, and deep equality testing but does not yet throw for errors. And so far [the testing framework](https://github.com/l3laze/testease) is only really useful for async/await or Promises and needs some help I can't yet manage to give it. They're each about 2x as fast in initial amateur testing with console.time or just Date logging, and using [benchmark.js](https://github.com/bestiejs/benchmark.js) the assertion library is usually a little more than, but I haven't yet figured out how to run Mocha or my own through this so the test frameworks have not been properly benched. They're both very small and simple, if you'd like to see how a test framework could work internally and try to make your own or contribute to my monstrosities; not that it's the greatest idea. Lol.
Thanks for the links. In previous React feature updates, sometimes it was handier to have a "what does this mean to me" explanation, but in this particular update, they seem to do pretty well on this. Seeing some examples of it, it really seems to make some good sense -- a lot of people complaining about the API and it's requirement for ordered calling, which seems strange, but eliminating that requirement would probably add a lot of crap to it, and it would be far less elegant -- For some reason, I'm thinking of C-like language include files, when I see it in use -- at the top of a React component function, you're declaring the resources that it's going to use -- a state variable, an effect -- so both the programmer, and the program, know in advance, what is going to follow. Then you use it. I think I like it! I'll be sure to explore it next time I get to working on my personal React stuff. 
Hi /u/PussyDestroer666, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/mohamedimy, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/Salomon81, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
ITT: people who can't let go and are butthurt that React is evolving so fast
You're an amateur and a waste of my time. This conversation is over.
So transpire it to ES5 with Babel?
A bit late, but I extended last weeks already cool ts2redux with support with selectors using "reselect" -library. Class getters are automatically compiled to selectors. https://github.com/terotests/ts2redux#selectors
that he wont be adding features doesnt mean its not still useful or viable if react stopped adding features today it’s not as if it would not be a useful library
Most open source libraries are published with MIT license, which states: &gt; Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
Is it too late? Almost certainly, considering what you're talking about here is *not* a refactoring but more like a rearchitecting. If you're really, really sure the project as it stands will fall apart in production, you might consider documenting the particulars so that when the inevitable happens, you'll be in a good position to start picking up the pieces. Depending on the climate in your company, it may not may not be wise to actually *show* anyone that documentation.
You're deluded. Get that checked. Your head is fucked. You actually think you're better than other people - that's ridiculous and false. If anyone in this conversation is an amateur it's you. You have no clue about anything I've worked on in 40 years and call me an amateur?? That's just projection, and it's hilarious that you think it's somehow making me feel bad. It just shows your own self delusion.
&gt; I've been eyeing the Secrets of a JavaScript Ninja but I would like to get the community's recommendation first before making a purchase. I got my copy at the local library. There may be lots of other titles there for you
You have it so backwards. Yeah, react is overkill for some small projects, but it makes you write better js. 
&gt;They keep introducing stuff and then they keep adding stuff to fix the previous stuff. Can you give an example? Not being facetious, just can't think of any of the changes in React when there was a new feature that needed to be "fixed."
/u/aaarrggh wrote: &gt;So transpire it to ES5 with Babel? HAHAHA doesn't even know the word is *transpile*. What an amateur you are!!! lmfao 
Nobody said it's too hard at all. It's all relative. Did you watch the talks? It's baffling why you'd argue against the obvious improvement that they've shown so far with hooks. It seems objectively better, not subjectively. The best part though is that they did it all with 100% backwards compatibility. So if you really do like classes still, you don't have to change anything (for now). Aside from the rewrite effort though, I don't know why you wouldn't want the newer style.
The problem is i'm overseas in a non english speaking country... so i dont really have many choices... what did u think of js ninja?
I havent read it yet lol. just picked it up a couple days ago 
They said this... both in the talk and on the website. It's also not objectively better because there is a clarity cost, and when you work on a team of people you often don't get to decide what patterns they use. So even if you don't want to write code with Hooks, they're going to be pretty unavoidable eventually.
oh for sure lol... the reviews were pretty good on amazon... might have to find a pdf version and check it out then pull the trigger
yeah i was going to say, you can find lots of books online.....then get the hardback
This is a step in the right direction and looks like React is finally taking lessons from libraries like re-frame (clojurescript)
yeah ill just take a peek to check it out... have u read any JS books that u enjoyed?
I was on my phone you dipshit. Autocorrect. Christ, what an amateur.
You might check out the [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS) series by Kyle Simpson.
Can you make it s.t. the js and other languages are seperate? I don't want to think too much about what the code wants to do rather than the "CS" applications of it.
You can't even proofread what you type and blame it on autocorrect? Amateur. Maybe you should write a test for that. 
&gt; I highly recommend watching all of it and Ryan's as well do you happen to have a link to the video or transcript?
This feels way too magic for me. It feels so fragile to have to do things in order, have a linter to help enforce it, use particular naming conventions etc. HOCs/render props are at least semantically correct. Yeah they can cause pyramids, yeah it couples components, but this just feels like another way to skin a cat.
&gt;Dan mentioned why order matters in the React Conf talk So... why? Do we need to watch the whole talk to understand, or is something that can be explained in few sentences?
First two videos: https://www.youtube.com/watch?v=V-QO-KO90iQ&amp;list=PLPxbbTqCLbGE5AihOSExAa4wUM-P42EIJ
If you don't need to share logic you're either using using libraries that use these techniques or you're duplicating a _lot_ of code. That said, Hooks does not immediately usurp all Higher order Components, just maybe ones with _only_ logic in them.
Context. Only one I can think of. Some might argue the lifecycle methods, but I think that those got changed because of architecture changes, more so than because it was "broken" and had to be "fixed". 
Pick a project that you like and know that has no tests, and go for it. :-D Alternatively, make it your pet project at work to write tests for things. This may only work if you have a company that hasn't yet discovered how awesome automated testing is. 
Not really, but if you want to declare a variable conditionally, you can use the shorthand syntax - Assuming `foo` equals 'text' - `foo = foo === 'text' ? 'test complete' : 'test failed';` If `foo` equals 'text', make `foo` store 'test complete', else make it 'test failed'. Learn more about the ternary operator [here](http://javascript.info/ifelse#ternary-operator) 
Thanks a lot for putting in so much time and effort to mention all the resources above. This definitely gives me a good idea of things to work on :)
🙉🙉 That's you two. You have two ears and one mouth for a reason.
Thank for your kind advice :)
I dont know redux much and I plan to learn it next. Can you throw some light on what you mean by tiny degestible projects? Thanks a lot for your response.
But why would the order ever change? You put your hooks at the top of the function and that’s it.
To be fair, every single reference that Facebook made to the old context API in the docs, blog posts, demos at conferences, etc had very explicit warnings about how context was 'unstable' and the API would change. And regarding the churn in lifecycles, I think that changes such as deprication of `componentWillReceiveProps` has more to do with the flexibility/idiot proofing the API than anything else. People have used react to do all sorts of weird things ilconcieved/brilliant/unexpected ways than the developers could never have anticipated. Hindsight is 20-20 
I don't disagree with you in the slightest. They put out the original Context to solve a problem that they knew was there, and it took a few iterations on it to come up with a better solution. I don't know anyone who's used the Context API, I don't even know what problems it solves. :-D 
I don't really like the writer's tone. It sounds and reads too much like a novel imo. I just want straight to the point or close enough. No like abstract reflection on life analogy stuff lol
&gt;If you don't need to share logic you're either using using libraries that use these techniques or you're duplicating a _lot_ of code. Or I just don't have logic that needs repeating. Sometimes that happens too. I do have some common components, they mostly wrap up a few bits of simple logic or styles with some defaults filled in. And where I do have the need to share logic I usually just pull it out into functions. &gt;That said, Hooks does not immediately usurp all Higher order Components, just maybe ones with _only_ logic in them. I don't have any of those either, and don't see a need for them in this project. ¯\\\_(ツ)\_/¯ 
Ill have to check that out. Ive read a lot of good things about his series
Alright that seems like sound advice. Ill check that website out also
If you know React, then you can make some kind of UI for an appointment scheduler. Or a online store front. Anything that looks like a real-life business need would look good for a portfolio. 
In there a tl;dw, for mobile on the go people?
The key is to think of a project with a really small scope. So the last one I did was a menu system. It was a picture and when you clicked on it broke into a three by three grid where each panel had a menu option. That's the whole project. Another one I did was making a little chat app with web sockets. Setting up a simple social media profile page template that read through a database and pumped out routed profile pages. The trick is to plan a lot before you code. Just my two cents :)
His answer is better, just wanted to add this ugly one foo === «text» &amp;&amp; text = «test complete» 
Last I checked, Epictetus never said to listen to all-comers equally. The fact remains he completely misunderstood my point, decided to start the conversation by insulting my intelligence and dug himself further when I tried to clarify that I was in no way talking about the formal RFC process. There's no obligation to suffer fools gladly on an internet forum.
Feedback: If you want peoplversion of ite to test your projects have a live 
It's difficult to say without knowing all of the possible permutations of variable.
It's crazy to me graduating less than half a year ago and thinking you can identify good programming, let alone good programm*ers*. That was years ago and I still get a bout of impostor syndrome from time to time. How in the world does this type of arrogance not come through in interviews?
&gt; It's also not objectively better because there is a clarity cost According to whom? You can't properly compose in classes, you have to use arrow functions or bind to this to use event handlers and those things certainly don't make code "more clear". &gt; and when you work on a team of people you often don't get to decide what patterns they use. Honestly if myentire team is in favor and I'm not, my knee-jerk reaction would be to understand what I'm missing that they are seeing.
&gt; just hope it won't be 100% functional components with hooks all over the place. I'm super confused on why you see this as a bad thing, assuming your idea of a good code base is mostly class components with lifecycle functions all over the place? &gt; I like the idea, it does look promising, but it looks pretty immature right now. Well it kind of is by definition, but it's kind of not since this is based on an existing library (Recompose) the author of which now works on the React team. &gt; I think they are just trying to push functional components into React way too hard and I'm afraid it will cause more bad than good. Again, I'm so very confused on why in the world anyone would consider composable functional components a *bad* thing? This just feels like an example (which is all too common in the frontend community) of "this is different than what I'm used to and I don't like it."
Yeah. We also thought of include (or import) as a conceptual model.
Cause why leverage the collective experience of an entire industry, hey?
It sounds like you may be looking for a switch statement. 
Don't do the work of your minifier. Your job is to produce clear code. Its job is to compress it.
I acknowledged that. Seeing alternative ways of doing things can open people up to new ideas and new concepts, even if the ones they see shouldn’t be directly used.
Basically it's like a global state for the entire tree. things like react-redux used it so that you can set the store instance at the top of the tree and then a connect(WrappedComponent) further down the tree can still access that store instance without having to pass the store prop down to for each single component in the tree
I think the best way to hammer these concepts home would be to investigate why they exist, or what they are used for. What is the purpose of the this keyword? When are closures useful? Simply memorizing a definition probably won’t give you an intuitive (and therefore more permanent) understanding. 
`recursion` is when a function calls itself repeatedly to get a job done. ---- `closures` are where a function pulls values and references into from the outside (you know how there's a global `i`, then you run your function and it has access? that's where.) ---- `this` is the target of context. so, like. say you make a dog class. `class dog {};` say the dog class stores a name. if you have three instances of dog, each one gets its own name. when you make a `new dog`, there has to be a way to refer to the stuff that's about this instance, rather than the other two. that's `this`. `class dog { constructor(name) { this._name = name; } };` the reason `this` gets so much flak in javascript is a few weird details weren't done in the convenient way in old-js, and they're some of the more common minefields for new programmers but honestly it's pretty straightforward
recursion doesn't apply to javascript too much. it's used a lot in languages like C++ when working with linked lists and memory objects and pointers etc. etc. 
Beer to this man. I have read countless articles about closures, books explaining closures on 40 pages, I know examples of closures, I know definition of a closure but to be honest I still could not explain what it exactly is.
&gt; your idea of a good code base is mostly class components with lifecycle functions all over the place? I think you got me wrong. I'm just afraid people will dive head first into hooks without really thinking about using them. &gt; why anyone would consider composable functional components a bad thing Except I don't. I like functional components. It just feels like React team tries to force everyone to use them everywhere, not just introduce another way to skin a cat.
The way I understand closures is that they are functions that can access members within their own lexical scope even if that function is executed from outside its scope. //A function with it's own scope that returns a function const post = (message) =&gt; { //Member within the returned function's scope const subreddit = "r/javascript"; //The returned function that can access the constant above within it's scope return () =&gt; console.log(`Posted ${message} in the subreddit ${subreddit}`); }; //Call a function that returns a function const closure = post("what a closure is"); //Execute that function's returned function from outside it's scope closure(); 
Google recursion. It's delightful.
&gt; why should i care? Sounds like you haven't learned it because you don't care. Why should we?
Uhh.. well, I just did the Star Wars API challenge for a job at a major fintech company and the only way to complete it was to use recursion. You had to loop through multiple fetched JSON files containing urls to other JSON files until you reached one with the appropriate data. And then wait until all searches were completed this way, and return the data at the same time (Promise.all) I would definitely suggest getting practical experience with recursion in JavaScript. 
show me a single place its actually used in javascript outside of job interviews
OP shouldn't have much to worry about. The fact that this is getting upvotes shows most of the community doesn't know what these things are either ¯\_(ツ)_/¯
Actually I think you explained both closures and recursion in your post pretty accurately
A closure is useful for when you want a function to be able to access a variable that will be persistent between calls, but you don't want it in the global scope. Here's a contrived example: function outer() { let count = 0; function inner() { count++; console.log(`This function has been called ${count} times`); return count; } return inner; } const fn = outer(); fn(); // This function has been called 1 times fn(); // This function has been called 2 times Even though the outer function has already been run and returned its result (the inner function), the variable `count` remains in scope and is accessible by the inner function when it's called. But nothing outside of that `outer` function has access to the variable. Closures are used very often in JavaScript, even when you may not realise it. They're very useful for creating maintaining access to private data that you don't want accessed by external code, and which needs to be persistent. Also very useful for ensuring all your variables aren't polluting the global scope, which helps ensure you avoid conflicts when using 3rd party scripts in the same page that may happen to use the same variable names.
I feel like your post is mostly summed up in the "why should i care?" question. At risk of sounding like a parent, when you need it you'll be glad you learned it. &amp;#x200B; Here's the thing. If you're adding hover/click listeners to buttons and doing minor interactivity with JavaScript you'll likely never need to have a deep understanding of these concepts. I'm not sure if that's your situation, but I've met devs who went a very long time in their careers before working on a bigger web application. And if that's not your speed, maybe just getting a good enough understanding for interviews is sufficient. &amp;#x200B; But once you start working on large (hundreds of thousands of lines of code) applications, the way your code is organized and interacts with itself is critical. And these coding patterns help with structure, and understanding them means when you read recursive code for instance, you get it easily, or if you're working with an application built very functionally (the programming style) you'll need to understand closures very well (it's not a lot though, so don't worry). &amp;#x200B; So I guess I'm saying understanding "on the surface" can get you started, but once things grow, it becomes hard to understand how code is working without the conceptual backing. It also makes it dangerous to write code because you'll end up having bugs you didn't foresee due to the lack of overall understanding of the ways the code will interact in a variety of abstract scenarios. &amp;#x200B; I don't know if that helps. I have experienced a lot of what I mentioned here from my own lack of knowledge and that pain has pushed me to become very diligent with reading documentation about the language I'm using, and understanding the code CS concepts underlying how it works.
If it doesn't have a valid use case then it probably isn't very useful either. Now, recursion is useful, try writing a program to print all the permutations or combinations of a given set of characters or write a program to convert numbers to words without using recursion and you will understand its utility. Sometimes the only way a problem can be solved in a straightforward way is to use recursion. I would suggest that spend some time and try to write simple programs, one program that I will recommend personally is one that converts numbers to words. &amp;#x200B; &amp;#x200B;
I'm a heavy MobX user at the moment, and I'll probably start using hooks from now on. Code is a bit more readable, reusable and rigid with hooks than with MobX, I feel.
I'm not lamenting the fact that there are trade-offs; there always are. I'm pointing out the fact that it's legitimate to ask why that trade-off is made. We don't really know yet.
HTML with SVGs?
Hook state works similar with other hook (effect). It is: * Scoped per each component * Dependent on order-of-call for each react hook call * Unique per each useState call * Will cause re-render if modified For example, [in my gist](https://gist.github.com/fendy3002/6abcc0e6bc91f0f97c6b6df2776fe035#file-reacthookstatescope-js) for file ReactHookStateScope.js. One element use 1 state, 2 custom hooks which each use 2 states. So that one element use 5 distinct state, all scoped in that one component, based on call order. Because I render 2 element, in that gist has 10 distinct states, each 5 scoped per each component.
i want tl;dr =)))
For most of these, the answer to "why should i care" is "because most [traditional] programming languages don't behave this way". If your first programming language is Javascript, they may not seem as important of language features to you. Less evasively: `closures`: You should care because this affects how variables are shared throughout your program. In languages like C++ and older versions of Java/C#, the idea of a local scope variable being accessed outside its immediate scope is bonkers. `recursion`: You should care because some algorithms are best defined recursively. Some code is going to have to call itself, even in simple web programming (setTimeout loops anyone?). Understanding the need for a stop condition, and how to think about recursion, is a good skill to have. `this`: You should care because the javascript ecosystem isn't fully settled on how to use this language feature, and you'll inevitably have to debug some code where it's getting used wrong or set improperly. Also, at some level, all 3 of these concepts can have major implications on the stack &amp; heap of your program. As an interview question, I'd probably look for basic competency, and knowledge of stack &amp; heap implications as bonus points. `closures` can imply that variables are moved from stack to heap; `recursive` functions can easily blow the stack unless you can implement them as iterative algorithms using the heap.
read javascript allonge
I feel that part of the reason why you don't see any benefit to learning how these things work is because you haven't had the experience to know when these things should be used over another tool. It's like that quote, "when all you have is a hammer, everything looks like a nail". You can do a lot with a hammer, but removing a screw is still a screwdriver's job. Closures are extremely important to understand because it determines whether you have access to a variable or not, and how that variable is shared between functions. It can be used to [implement private variables](https://stackoverflow.com/a/2728341/135318), hold state [that's not exposed globally](https://stackoverflow.com/a/39045098/135318), and write cleaner code that would otherwise be difficult without them. They are also a fundamental part of how JS works; you're always using them whether you're aware of how they work or not. Recursion becomes extremely useful when you deal with things of arbitrary depth. For example, searching a folder plus its sub-folders for a file name is a prime example of where recursion would be extremely helpful because you don't know how deep the folder structure runs. Another is the [Eight queens puzzle](https://en.wikipedia.org/wiki/Eight_queens_puzzle), where you don't know how many moves ahead you need to calculate in order to solve the problem. Every recursive function can be written as a standard loop, but the code to do so will be more messy and harder to follow. Understanding `this` is also important because it's fundamental to how JS works. You mentioned that there's a bunch of gotcha's because the value of `this` can be unexpected depending on how you call a function, but understanding how JS sets the `this` variable allows you to do things like borrow functions from other classes: ```js // getGamepads() returns a GamepadList which doesn't have a forEach function, // so we'll just borrow Array's forEach function to iterate over it Array.prototype.forEach.call(navigator.getGamepads(), (gamepad) =&gt; console.log(gamepad)) ``` overriding functions that are declared on an object, but don't do what you want them to: ```js // Let's assume that there's a legacy array implementation that adds a filter // function, but rather than accepting a function, it can only filter by ID function LegacyArray(items) { ..., filter(id) { return _.find(this, id) } } let arr = new LegacyArray({ id: 1, name: 'Bob' }, { id: 2, name: 'Sue' }) // I need to filter by the name, but the .filter() function on the legacy array // only allows me to filter by ID. That's ok, I'll just override it by calling Array's // filter() function instead, padding in the legacy array as the 'this' value. Array.prototype.filter.call(arr, ((x) =&gt; x.name == 'Bob') ``` and change the value of `this` to make the code easier to work with: ```js class BetterButton(buttonElement) { constructor() { this.element = buttonElement this.element.addEventListener('click', function() { this.setButtonText('clicked!') }.bind(this)) setButtonText(text) { this.element.innerText = text } } ``` You can do all of this without overriding `this` or even understand how it works, but you'll find that it becomes harder if you don't understand all of the options available to you.
Dan did a pretty good job of explaining why they exist in one of the two videos explaining them. 
Then open DT console and google 'adventure game' or 'text adventure' and forget about everything you were going to do.
&gt; It feels so fragile to have to do things in order You have to try pretty hard to get functions to initialize variables in a different order every time they run. &gt; have a linter to help enforce it, use particular naming conventions etc The naming conventions are for the linter and the linter is to tell you to keep any of your 'use' functions **out** of any blocks (that are not other 'use' functions). &gt; HOCs/render props are at least semantically correct. Yeah they can cause pyramids, yeah it couples components, but this just feels like another way to skin a cat. * hooks will *never* have props collisions. * You dont have to plumb extra props (or refs) through piles of HoCs or RenderProps. 
I didn't upvote because I don't understand them, I upvoted in case others don't, because the answers are in the comments
You hammer them in by writing code that uses these patterns. Which parts are you exactly having trouble with? &amp;#x200B; As to why you should care: You should care because these (minus recursion) are frequently used in javascript and interviewers want to make sure you can navigate and make changes to their codebase. &amp;#x200B; TBH, I don't think I've ever used recursion in practice. If you're being asked about it it's because the interviewer hasn't put much thought into their questions and like to pretend they're writing trees all day, when in reality they're copying and pasting css from stack overflow.
That's a great use of a closure, but that's not what a closure *is*. I'd say a closure is a function with a set of variables holding the values they had at the time the function was created.
A closure is just a function and some data. For example image a function "add" which take two numbers as arguments. You can make a closure "addfive" which combines "add", and the value 5. const addfive = n =&gt; n + 5; That's really all it is. 
OP should worry about it. It distinguishes people who get hired always from people who get hired sometimes. :)
You'd have to wrap `text = "test complete"` in parens or it'll error. I appreciate showing the alternative, even if it's shitty and no one should use it.
There are actually many algorithms where the recursive definition is straightforward and the loop-based version is insanely hard to follow or even create in the first place.
a pairing of a function and a set of variables that the function had access to at the time of its creation, that's how i think about it
Framework? Check sample code. https://github.com/1j01/jspaint It is paint, not Photoshop though
Recursion is really simple. It's a function that calls itself. That's basically it. Now, why would you want to do this? Say you have a big problem, but you can break it up into smaller problems. Then you can have a function that solves the problem by looking at its sub-problems and recursively calling itself on those, and then each of those sub-problems will get solved by having the function call itself on *their* sub-problems, and so on. A great example is when you have some sort of hierarchical structure, like a table of contents, where there are sections, subsections, subsubsections, etc. You want to do something with this table of contents, so for each heading, you do whatever you need to do and call the function to process its subheadings; for each of those, the function will do what it's supposed to do and then call itself for *its* subheadings, and so on, until you've gone as deep as your hierarchy happens to be. Recursion is especially useful for things like nested objects. Say you have two objects and you want to know whether they're the same. So you go through each key on the first object and check that the corresponding key on the second object has the same value. How do you check whether the value is the same? Call the function you're in right now, but on the sub-object! This can get a bit problematic because you can actually have circular references and then you're fucked, but anyway. Closures are even simpler. They're just functions that are defined inside some context, and then you can pass the function someplace else and the context goes with it. Basically, you can think of a closure as a method on an object. It's really not very different. One big difference, actually, is that while the function retains its context, *you can't actually see the context*. JS doesn't have access controls for objects, so if you define a key on an object, you can always change its value. But if you make a closure, you no longer have access to the variables defined in that closure except through that function, which is a good way of enforcing limited access. This... Kinda hard to explain, but not hard to understand. Of course, I had a this-related bug *today* in my code, so look who's talking! If you create a method on an object, and you call that method, `this` is the object you're calling it on. It should be simple, but it's not, because *unlike other variables*, `this` isn't the object it's *defined* on; it's the object you're *calling it* on. Here's my buggy code; can you see what's wrong? Spectrum.prototype.draw = function () { requestAnimationFrame(this.draw); // do stuff } It didn't work! The "do stuff" part of the code tried to do `this.`something and it was undefined. Why? Because of `this`. If I do `let spectrum = new Spectrum();`, I now have a `Spectrum` object. If I call `spectrum.draw()`, I'm going to do whatever's in this `draw` function, and `this` will refer to the `Spectrum` object itself. In particular, I'm calling `requestAnimationFrame()` on the function `this.draw`, which is... the function itself. RECURSION! MWAHAHAHA! What this does is draw a frame, and `requestAnimationFrame()` calls the function again when the frame is done so that the next frame gets drawn, and that will set up the next frame, and so on; you get an animation basically for free by requesting the animation frame. Except it doesn't work. Why? Well, when the browser is ready to do the next frame, it calls this `draw` function. `draw` is a key in the `this` object, and `this.draw` is the value for that key: this very function. The function gets passed to `requestAnimationFrame()` to get called later. Which it does. But NOT BY `spectrum`! The animation renderer calls the function! So `this` doesn't refer to `spectrum` anymore, because the function isn't being called by it like when you do `spectrum.draw()`. There are a few possible solutions. One is to bind `this`; JS provides a way to tell the browser which object the function should treat as `this`. ES6 provides ways to do that as well, since it's a common point of confusion in JS. Another way is to just use a new function like this: let self = this; requestAnimationFrame(function () {self.draw();}); That's what I did. See if you can follow. First, I defined `self` as `this`. The current object that is `this` is now stored in the variable `self`. `self` is not a keyword; it's a normal variable, and it happens to hold the object that's calling this function, `spectrum`. So, I define a CLOSURE! MWAHAHAHAHA! This closure calls `self.draw();`, and since `self` is the object calling this *original* `draw` function, things work as they should. The animation renderer calls this function I just defined, with itself as `this`, and the function I just defined calls `self.draw()`, where `self` is `spectrum`, from the closure. `spectrum.draw()` behaves as you'd expect, because you're calling `draw()` from `spectrum`, and `spectrum` is now `this` inside the function. Which then gets assigned to `self` in order to request the next animation frame, etc. So there's recursion inside a closure in order to avoid going afoul of `this`. It's all three of your issues in one tiny bit of code!
man lotta non-math majors coming in here and shitting up the elegant and arcane :P
When I do projects like this, I create two canvases. One canvas contains the composite image. The second canvas contains the same amount of pixels as the image canvas. Except here, the color of a particular pixel is actually an index to the owner muscle. When you click on the canvas it returns the index ID of the muscle you want to highlight.
&gt; plus you're awaiting something that isnt necessarily a promise If you await something that isn't a promise it behaves exactly as if it were a promise. func a() { return 'bar' } const f = await a(); is exactly the same outcome as func a() { return Promise.resolve('bar'); } const f = await a();
Awesome writeup
Even if you hard-coded the button being disabled, a malicious user could still enable it. You're going to have a server-side check because no matter what you do, no client-side security can be trusted since you're trying to secure the client against the client's own behavior.
Probably because it provides a *very* clean and simple API.
How are ya gonna tell me that's more elegant than this? var foo = 'test'; foo = ((val = foo, cond = foo === 'test', success = 'test complete') =&gt; ({ [cond]: success, [!cond]: val }).true)(); console.log(foo); // 'test complete'
Yeah I like that very nicely done. What an ambitious project(s)!! 
I just wanted to say that these explanations are short, sweet, and relay relevant information well. Super well put. Thanks fren. 
Beyond sticking with module/framework official documentations, I always go back to http://exploringjs.com/. This guy lays out stuff with concrete examples and elaborations, plus the book is accessible online. Metaphorically, this guy snorts Javascript like cocaine.
"You don't know javascript" is a great book series and covers all these things
Declare totalBooks outside the for loop... var total Books = 0 for ( // your stuff ) { // more stuff totalBooks += totalBooksEveryYear; // the rest of the loop }
I honestly don’t see the need for types - I just use clear names and the type is obvious to me. But I’m solo so who knows how it might go on a team ...
Just use the main source like MDN and search for closure. Closure is really easy to understand... well everything else related to JavaScript (webpack, react, closure..) are easy to understand if you us their official guide. Guide != Document 
Written by Indian btw. 
" ok so what. why should i care? " This is the root of your problem. WTF your inane post has been up-voted 70 times I have no idea. If I could take my 9.8K of karma and lose it all to downvote this post by 9.8K, I would.
This is my best source for learning the basics of javascript/programming https://github.com/getify/You-Dont-Know-JS 
Take a loot at my [blog post](https://gshen.site/2018/06/29/closure-easy-explanation/)!
The purpose of a closure is to wrap reference scope to external adjacent variables to itself. So that you don't have to do things like passing the variables as arguments all the time, and they can each have references to tiered scope levels further down the chain. Closures allow you to control reference scope. This is not something you can do with simple functions alone. You need `anonymous functions` / `closures` to accomplish this task. Also they allow you to hide knowledge of these references away from the interface of the returned closure. So basically they act as interface facades that handle more complex logic behind the scenes that you don't need to expose.
Sounds good I’ll give it a peep!
just because the engine automatically wraps it in a promise doesnt mean you should. 
Lexical Scope (or Static Scope) is what you already understand how general scope works in JavaScript, which is different than Dynamic Scope, which is not available in JavaScript. Here's an **[answer that details the difference between the two types of scoping](https://stackoverflow.com/a/1047491/336929)** from Stack Overflow.
You should care because understanding these concepts will become a necessity once you start writing applications with more than trivial complexity. And even if you're writing relatively simple stuff, understanding scope is very helpful in debugging and generally understanding what your code is doing. These concepts will make your life easier. 
I would recommend "You Don't Know Js" as well, he's explained it beautiful. And you learn better reading than watching hours of videos I feel. 
&gt; how do i hammer these topics into my head so that i never forgot how they work. Start caring and giving shit about how things work. Your post shows that you are not enthusiastic about programming and figuring out how stuff work in general. Seriously, these things could be understood in 3 weeks not 3 years. I was an educator at a programming bootcamp and they got it with zero coding background. 
Might have to do with it being the only comment. :P
Come on ... imagine folders, but in reverse!
I'm sorry, this is trash
Can you guys stop spamming in the dev subreddits?
Just a year ago I would have agreed with some of OP's points, but many people in the comments are shooting some solid knowledge into this shit-heap of a post. And I learned a few things from some of the comments, or anyways more firmly grasped it.
I have to agree, thought the title was bad enough, the actual content is even worse. 
Ok, well you may feel that way, but I'm not really sure what exactly you expect aside from offering alternative solutions. There's a lot of people he *did* convince so at this point you can either choose not to use it or give constructive feedback on how you think it should work.
Re-read your comment thread. Actually, the other dude is the one that is like 🙉, and also a little bit of 🙈. lol
Side note: Interestingly, the invalid version has never worked in IE or Edge.
babel with some build tool (webpack, gulp, browserify) is the way you want to go. with babel, look into babel-polyfill, which allows you to compile code for desired browsers
&gt; That does mean that the built-in hooks are somehow more special than my custom hooks, I take it? Yes, that's fair to say. Here's one way i think about it: we start with a small collection of functions that have a specific requirement about how they be used. Any functions that then make use of those functions become "tainted", and also need to obey that requirement or the system doesn't work. In this particular case, the requirement is that they be called in a predictable order, and the functions that start us off are the built in hooks. But i deliberately worded the previous paragraph in a generic way, because this "tainting" effect shows up in other unrelated scenarios. For example, if a function is asynchronous, any function that calls that function will also need to be asynchronous. Or if a function is impure (ie, it generates side effects), any function that calls that function also becomes impure. &gt; (Thanks btw for actually informing me, rather than just downvoting in letting me revel in my incorrect information.) No problem. This stuff is new and admittedly a bit weird, so we'll all have a bit of learning to do. I'm hardly an expert myself, i've just spent a bit of time the last few days on it (though not as much as i'd like, because i ran into a bug where it was spouting off errors that said "hooks can only be called inside the body of a function component" even though i was in function components)
Yes, that makes sense, thanks for that.
Best example I can think of for a real-world use of recursion is getting a full listing for a directory including all the subfolders. You have no way beforehand of knowing how my folders and subfolders there are so you write a function that takes a path and lists out the items. You loop through the items and if one is a directory you run the same function again with the new path. function listContents(path) { const items = fs.getDirectoryListing(folder); for(var x=0; x&lt;items.length;x++) { if(items[x].isDirectory) { console.log("Directory: "+ items[x].name); listContents(items[x].path); } else { console.log("File: "+ items[x].name } } }
We think it's clear by now (thanks in part to the community feedback) that there is a need for _something_ like this. Something that solves all these problems. The actual specifics of the RFC will likely change in response to feedback for sure. I don't think we can call it a day and go home though -- we need to figure this out. I agree it might be a bit too early to do something like this but that was Andrew's personal decision and not for me to analyze. It's still a proposal from our point of view though.
Recursion is simple. 
It's intentional, QuickSort was replaced with TimSort: https://twitter.com/mathias/status/1036626116654637057?s=19
The difference, in days, is 0. From 10PM today to 8AM tomorrow morning there's a difference of 10 hours, which is less than a day. If you want this calculation to return 1 day, you need to do the calculation without taking the times into account.
netlify does exactly this, I've found
I also suggest using pipenv [https://docs.python-guide.org/dev/virtualenvs/](https://docs.python-guide.org/dev/virtualenvs/) to isolate your python projects.
First of all there’s no reason to be so fucking rude. Second, the RFC process, as it states there, exists to prevent the core team or anyone else from unilaterally making changes to high level patterns. This is literally the purpose of an RFC process, for both the React team and other open source projects that conduct them. 
I might say anything here that hasn't already been said, but I understand that feeling of wondering why I should care about something I'm learning that makes sense but is unclear how it is applicable or why it has a specific name. Any JavaScript function can access values that are in the scope where that function is defined. It becomes a closure when that function gets passed to another scope. In the new scope, the function still has access to the values in the scope that it originated from, even though they aren't in the new scope. I believe the concept of 'closure' is only useful when you are passing a function around as a value. In your example, you asked why it matters that an inner function can access the outer function values. I can relate to your confusion because I already knew that functions could access values that were in scope long before I ever heard of closures, but it becomes significant if you return that inner function as the return value of the outer function. Then anywhere you call that returned function from that point on, it will always have access to those some values. Basically, the function is just 'remembering' the values it knew about when it was first created. Other programming languages don't do this by default, you have to specifically define what values you want to be 'closed' into your function. Personally, I like to not think of recursion as an alternative way to make a loop, but just as a way to simplify a problem. One use of a recursive function would be to generate a fractal. Like if you wanted generate a square that cuts itself into 4 smaller squares, which each cut themselves into 4 smaller squares, and so on. You could have a function called "fours" which takes in a square, cuts it into four new squares, and then passes each new square into a function called "fours", which takes in a square, cuts it into four new squares, and then passes each new square into a function called "fours", which takes in a square... and you get the idea. Obviously this would just run forever as it is, so you would some stop condition. So you could check the size of the square that's getting passed in, and if it is less than some minimum size you would just return the square as is instead of cutting even smaller and passing on. Recursion isn't something you usually have to use, but once you can wrap your head around it, it can be really useful. Unfortunately, I don't think I understand the "this" keyword well enough to explain it.
Yea saw a delightful comment in this thread, check it out: [https://www.reddit.com/r/javascript/comments/9s99nt/ive\_been\_learning\_javascript\_for\_about\_3\_years/e8n6tvs](https://www.reddit.com/r/javascript/comments/9s99nt/ive_been_learning_javascript_for_about_3_years/e8n6tvs)
it's a light weight module (636 B : minified and zipped) with 0 dependencies, while query-string is (1.3 kB : minified and zipped) with 2 dependencies.
Thanks for the response. Will take a closer look. 
What? How can you compare NodeJS with React/Angular. 
Got that, but I need the time due to timezone. No other way to do this with time?
I don't know the language or framework you are using but this is my guess. I have changed `/project/` to `/projects/` as described by you. Note that routes are processed in order. So the more specific one should come first. Otherwise, projectsHTML will always match and routed that way. No idea why you use the `g` flag. Instead use one or more matches: + ``` const routes = { default: userHTML, '/signin': signinHTML, '/signup': signupHTML, [`/projects/${/[a-zA-Z0-9]+/}`]: projectHTML, '/projects': projectsHTML, }; ```
This is so cool, I got stuck with the first archer for a while, but eventually got past it. Now I'm stuck trying to rescue the first captive who is behind me (level 6). For some reason, whenever I enter "warrior.feel('backward').getUnit().isBound()" it tells me "Error: Cannot read property 'isBound' of undefined". Same if I try isEnemy instead. This is only if I use the feel('backward') though. Using just feel() works fine. I did manage to get to level 7 by ignoring the captive, but I'd prefer to be able to rescue it too :)
Recursion think of solving a issue like N! By recursion I’m going to use pseudo language here so that it can be used universal. Func Fac(fac) { If (fac=1 ) { return 1} Else { return fac* Fac(fac-1); } Try it out with 5! 5! = 5* 4! 4! = 4* 3! 3! = 3* 2! 2! = 2* 1! 1! =1 5! = 1*2*3*4*5 = 120 
the key driver is often the need for good Lighthouse score and SEO
https://webpack.js.org/guides/getting-started/
There's never a good time for a rewrite, and it's almost impossible to convince the business of it. On the other hand, refactors can be done all the time. You do it piece by piece. Like that Router component you complained about. Just say that it wasn't working right and replace it with something that does. Unless it *is* working right, and then why would you replace it? Technically a bunch of if-thens and includes *are* a router. They just aren't a router made by someone else. But it sounds like you're actually pushing for a rewrite, and I do *not* recommend that. They almost never go right, even in the best of circumstances. The only successful rewrite I've been part of was just me alone, was mostly computational and not interface, and I wrote a *ton* of unit tests to capture the state of the existing functionality before I started. 
Also from Mr Abramov: &gt; Hooks are weird https://twitter.com/dan_abramov/status/1056808552180793344 &gt; I like them. But there’s no denying they’re weird. I look at them and see a new programming medium (like a function) whose potential I don’t fully understand it. https://twitter.com/dan_abramov/status/1056808888882757634 &gt; Like, is this... a model? A controller? An anti-pattern? I don’t know yet. &gt; [code](https://pbs.twimg.com/media/DqqLAUIVsAI3LGz.jpg) https://twitter.com/dan_abramov/status/1056809905116479488 
It's "proposal", if anyone else will ever read the code you write then stay away.
That's more of an instance of *currying* than a instance of closure, but the two are \*very\* closely related, as most closures involve functions that return functions. &amp;#x200B; // curried const times = (firstVar) =&gt; (secondVar) =&gt; firstVar \* secondVar; console.log(times(3)(4)) // =&gt; 12; const timesFive = times(5); console.log(timesFive(6)) // =&gt; 30; &amp;#x200B; // closure const countFrom = (init = 0) =&gt; { let count = init; const next = () =&gt; { init += 1; console.log(init); } return next; } const counter = countFrom(5); counter() // =&gt; 6 counter() // =&gt; 7 counter() // =&gt; 8 &amp;#x200B;
That will not work. Not that way. If you want to use regular expressions, you need to use regular expressions. I know it sounds obvious but it's not what you're doing. When you define `routes`, your keys are **strings**. When you later use `routes[pathname]` no form of pattern matching will be applied. The language simply does not work that way. Instead, you need to define your patterns as actual regular expressions and then use explicit matching to see which one matches. That is, instead of `routes[pathname]` you will need to iterate over all the patterns and see if each one matches or not.
Btw, circular references are easy to detect and handle; I wouldn’t say you are fucked.
Your attitude, kind sir, is part of the problem.
IE11 does not support arrow functions, promises, and a number of es6 array methods. I'm sure there is even more.
@OP While shitty\_tom is definitely right, please note that some features can't ever be properly transpiled (i.e. subclassing Array or Date), so if you need to support older browsers fully, you need to avoid them in your code. A list can be seen here: [https://babeljs.io/docs/en/caveats](https://babeljs.io/docs/en/caveats)
Sorry but I don't get it, why count doesn't restart from 0 in the second call?
I would recommendeed react beacause of large amount users will make your life easier.
Seems like a great use case for `reduce()`
When you declare ` const fn` it runs `outer` just once, but then _returns_ another function (`inner`) which is actually what is being called by `fn()`
Why is there always someone who's like "There is no spoon" when you ask them to pass you the cutlery...
Thanks a lot for your answer! 
I didn’t see if the recursion question was answered yet. But recursion simple is a method that calls itself and it MUST have an exit point or you will be getting a stack overflow error. Example a function that counts to 10. (Sudo code) Function(num) { If (num == 10) Return; Function(num++); } If you would like more complex examples of this I would look at some data structure text books. A lot of sorting and search algorithms use recursion. I don’t personally use recursion too often because it can be confusing, low readability, and hard to maintain. The most important attribute of good code to me is readability. That attribute seems to be lost on a lot of the development community. 10 times out of 10 I would rather have a slightly slower but more readable code base over some super fast codebase written and ancient Egyptian hieroglyphics. It’s much much easier to diagnose performance issues with a readable codebase too. 
Weird how they won’t take over [].contains but at the same time are willing to do this. 
System.log? It's Java not JavaScript
No, that's not valid javascript, and throws lots of errors. I'm curious why you've apparently written javascript in a text editor, and are asking us whether it's right, rather than using something like vscode or jsfiddle to actually point out the errors. I'm not sure if this is a school assignment, so I'm not going to give you the actual answers, or fix your code for you, but here's some hints: * Check the casing on your keywords (using uppercase/lowercase properly is essential - you can't get them wrong or the code won't parse) * Check your quotation marks on your strings * Check where you put your semicolons when defining functions. * Re-read about how JS functions are declared - that's not the right way to do things * Check your functions return values if you use them as an argument for another function.
This is my favorite answer, personally. Thank you. 
For recursion think of a n expanded file tree. Starting at the root you have files and folders. For functions you call displayFiles which returns a simple result of a list of files. For folders you call displayFolders which gets a list of folders then loops through each folder calling displayFolders and displayFiles. The displayFolders function would use recursion to keep calling deeper and deeper until there is no more to call. 
Your opinion is really valuable, I think I hear what you are saying, and I’m going to try an explain why I like them. If you haven’t had to deal with Render Props and why they are useful it is hard to explain but let me try. Basically we have a pattern which allows us to easily compose “behaviors” and dynamically render based off how we interpret that behavior. So in a components render you could render a component that tracks mouse position, which then calls a function where you can interpret that data and render whatever you want Also, having all that behavior in the render of a component makes it incredibly clear where data is coming from. One of the main reasons I love render props. The big problem is you enter a kind of “callback hell” similar to before we had async/await but worse because you are nesting unrelated behaviors, creating a confusing, false hierarchy. Also it’s disgusting to refactor. Hooks are exciting because they hoist those behaviors up and flatten them out, outside of the render. So you don’t end up with JSX anymore just regular JS syntax. At the same time they group together common behaviors. Often we spread or effects in classes through 2 or 3 lifecycle hooks intermixed with other effects. You can solve this by making HOCs for each, but honestly, why is a HOC any better then a hook. Hooks make you by default group the behaviors so I think it’s a huge win
Webpack doesn't transpile es6 to es5 out of the box
Hi! I'm quite new in the React world. I'm trying to learn React Native and Redux and I'm confused in how the all hooks principles could be effected by using Redux Will hooks be relevant with Redux? 
That's why Typescript exists!
I loved Helium in the Mac and was looking for an alternative after I moved to Windows. Thanks.
There's a css property for this, see [https://css-tricks.com/almanac/properties/p/pointer-events/](https://css-tricks.com/almanac/properties/p/pointer-events/)
You will definitely feel an impact, although it won't be with `redux` but mostly with `react-redux` (since `redux` alone is not dependent of `react`). The first one that comes to mind is the `connect` function, which is a High Order Component. You'll be able to replace it with a hook to get the state and actions directly inside your component. It might look like this: ``` /** * Before */ function MyComponent(props) { const [state, actions] = useConnect(/* some arguments */) // etc. } // You have to declare another component to use the `connect` HOC const ConnectedComponent = connect(mapStateToProps, mapDispatchToProps)(MyComponent) /** * After */ function MyComponent(props) { const [state, actions] = useConnect(mapState, mapDispatch) // etc. } ``` So, it won't change how you use `redux` but it will definitely change how you connect your `redux` store to your `react` components :)
You're can't write your own virtual DOM, templating engine, and state management, **and** expect it to be as polished as React.
[removed]
Look at parcel-bundler 
If you were an instructor with that attitude you definitely should not have been.
Has anyone got a good video tutorial they know of for setting this up? (babel)?
No. Unsafe mutation should not be mixed up with safe read.
The good trade off is the simplicity of the api and guarantee of veracity and performance of the reconciler. Limitations to how to use an api are not uncommon for either a language or a framework, especially if the limitations are minor and misuse of the api are made easy to debug (and are well documented).
A biased answer from me would be to use NativeScript. It has lots of modules that will make your life easier to design the app. They also have a strict guideline to how to structure your file tree which in my opinion is a selling point because I just don't like to experiment around all day long. On the hand more objectively, go with React Native if that's what your team is using. No need to learn a entire new framework and on the plus side the user base is really big, so it won't be a problem to find lots of libraries for your UI problems.
Thats really cool. Yeah I am looking to do something like you have on the right side of your editor. Can you suggest an ember/vue/react/other-javascript project whose code I can study from to implement that? What did you take inspiration from?
wow thank you for info
Thanks a lot for the reply, I think I'm going to dive into it to integrate it in the way I learn React =) 
&gt; Markdeep Wow. what a crazy and amazing project. Thats what i need thanks!
I created a tool that searches for keywords on YouTube and parses the video data. I plan to use this tool in order to source news channels that spread fake news. Here you can see the [blog post about the tool](https://incolumitas.com/2018/10/29/youtube-puppeteer-scraping/#youtube-puppeteer-scraping).
As others have mentioned--Closures are used quite a bit in JavaScript. To some extent that act as mini-classes essentially allowing you to re-use code while also protecting variables. I know many people use the "adder" type function/closure to illustrate but I think "fizzbuzz" can be a little more useful for the finer point. The closure below allows you to create new functions with different values for fizz and buzz. The standard one is fizz = 3, buzz = 5. But you can also make "fb27" and set fizz = 2 and buzz = 7. The two created functions keep their "fizz" and "buzz" values totally separate and once created can be called with any "x" value. In the more general sense this allows you to perform a common operation on a range of different values and inputs. Of course a function **is** used for doing a "common operation"--where closures come in is that they recognize that there are also sets of common values and inputs. function fizzbuzz(fizz = 3, buzz = 5) { return function(x) { return ("fizz".repeat(x % fizz === 0) + "buzz".repeat(x % buzz === 0) || x); }; } var fb = fizzbuzz(); // Default fizz and buzz (3, 5) var fb27 = fizzbuzz(2, 7) // fizz and buzz are 2 and 7 for fb27 for (var i = 0; i &lt; 20; i++) { console.log(i + "\t" + fb(i) + "\t\t" + fb27(i)); } 
Yeah exactly. But I meant what kind of programming patterns are employed. Do you have various models for each property sheet? oR one main one? etc
All those things are just programming tricks. You could even call them "design patterns". Which is a fancy name for a collection of names for a bunch of things you could also call: "common sense". But the names are there for us developers to communicate with. When we say "recursive function" we all know what it means. That's better than saying: "just use a function that calls itself time and again until it doesn't". That's why you should care. If you have troubles remembering them I'd just say: use them. Go for a design patterns book and practice by doing. That worked for me.
I responded to both of your comments.
I responded to both of your comments.
&gt; First of all there’s no reason to be so fucking rude. Did you bother reading? He started this by being rude so piss off. &gt; Second, the RFC process, as it states there, exists to prevent the core team or anyone else from unilaterally making changes to high level patterns. Good thing this isn't a change to a high level pattern. This feature already exists in an alpha version of React. I realize what the RFC is for. But the team opened the RFC with an existing implementation already in an alpha branch. So sure, maybe if the community was 100% against this it doesn't make it to stable. But my point was in response to the original comment saying "so much for this being a proposal". This is a proposal, but it's one that is going to be in the React core, so this particular RFC was for comments on implementation which is why it was provided as part of the RFC. You and the other dude are *way* too caught up on what the RFC process is supposed to be and seem to fundamentally lack the understanding of how projects largely backed by a major corporation, and community projects work.
Do not try to understand closures. Figure out what lexical scope is. Once you understand that closures seem like a simple concept.
Your point about recursion resonates with me; once I had to optimize a rather long running client side process in javascript that had been written as a single basic loop, but this loop was locking up the browser while it ran. So I rewrote the loop recursively and used setTimeout to defer the execution of each chunk in order to let the browser do its thing. If I hadn't understood recursion, I would have been dead in the water. 
`sort((a, b) =&gt; a &gt; b)` never worked in IE, so I guess they're more willing to break compatibility with code that was already broken in the first place.
A couple of things (I may be missing some), in tip.html I don't see how you are retrieving the data from localStorage and second, you can set either a breakpoint or a debugger on script.js line 118 and with google dev tools check the application tab then on the left under storage click Local Storage to see whats actually saved (you can do the same after tip.html is loaded). If the data is there is probably the way you're trying to retrieve it.
In my experience the boolean version never worked and it is not new at all. It might have looked like it worked but it was because you were lucky. It was especially obvious with a lot of identical items as I remember.
ship entire nodejs to the user and npm install react on the fronted💯💯💯💯
What’s crazy is he’s been learning js for 3 years and has this kinda attitude. It actually makes sense. 
For me, it's been a pleasure working with React Native and [Expo](https://expo.io/).
Proof it never quite worked $ node --version v10.12.0 $ node &gt; [5, 8, 7, 1, 2, 3, 4, 6, 9, 10, 11, 12, 13].sort((a, b) =&gt; a &gt; b) [ 4, 5, 3, 1, 2, 6, 7, 8, 9, 10, 11, 12, 13 ]
Don't feel so bad about `this` many developers have a hard time remembering the rules for it and often either use an arrow function (`=&gt;`)(to make it work like normal object oriented programming) or `.bind` It's highly context dependent and isn't always clear to the reader of code. 
Well. Not popular opinion, but this whole hook implementation is quite telling in some different area. React team decides to implement hooks as a solution to glaring problems they encountered during the years. Evan You just copies their work. makes a knockoff and reimplments in Vue without much forthought. I guess it's ok. But, sorry guys, doesn't it feel kinda lame for Vue? I mean, I don't mean that he shouldn't have done that or anything like that, but whole series of events it's kinda.. just meh. 
Hi /u/floodlitworld, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/ge0n1, please refrain from personal attacks. Thanks.
When an interviewer asks you about closures, sure the above example is great, but mention the scope part that's what they wanna hear about.
Ember together with ember-data defines all of this, if you follow their architecture (even when it hurts right at that moment), there isn’t much that can go wrong.
If you're interested in going deeper but your current professional experience isn't challenging you I'd suggest getting involved in some open source projects. Anything you find interesting would do. Start with their issues list and fix something. This is a great interview tool too, it's direct evidence of your work and skillset. 
https://www.youtube.com/watch?v=1TtGQnyPZ6g
Google analytics maybe?
[removed]
typescript wouldn't have changed a damn fucking thing. It's perfectly legal to compare 2 numbers in both languages.
Yeah that's what babel is for.
Looks like a good library! Should try it later with React Router
it works in firefox
8-800 2 8888
Google Analytics is pretty easy to implement. It's tracking will be able to give you site usage, audience demographics etc. Where is becomes powerful is when you add custom events to website actions programmatically. By this I mean firing a GA event when a video is watched for example. This can then be tracking in your GA events screens.
Agreed, I’ve never used it and I don’t know what’s it for... And I’m certainly not about to google for details 😅
I did google it. Didn't really inform me much more.
So does that mean it's a UI layer for e.g. React components?
NativeScript is a joy in some ways and a hell in others. It removes so many layers of complexity and magic that competing cross-platform frameworks like React Native add, due to running directly on the UI thread and not being much more than JavaScript bindings to native code (it's easy to make your own subset of it just by using JavaScriptCore). The lack of a reactive UI architecture (in fact, it's completely UI-agnostic and so supports various UI frameworks) makes things much simpler to start out with. In dev mode, it doesn't even use code bundling, so you don't have to spend days fighting a packager for trivial reasons that aren't your fault. More than anything, it's really refreshing to have such immensely short cold build times, due to the minimal size of NativeScript! I'm a big fan. It's far behind React Native in certain ways (not least community size), but it's very exciting to try out nonetheless.
I created a pull request.
Yeah I didn't get it either. The article was written like an informercial for daytime television.
Ah sorry! I meant to say your fix instead of stephanh42's. I'll be trying this out tomorrow and will let you know. Thanks :)
Does anyone know if you can mix `storiesOf` for HTML and React? 
I can’t wait for this to be expected. 
It's only used during development, run separately from your main app. It's meant for developing individual components and to easily see all their states in one place, without connecting any business logic to them.
I wasn’t attacking you ✌️
Use an array of knives/whatever and a loop to process all knives in the array
Check out Babel.
It's basically a catalog for your custom widgets. The idea is to render your widgets with different configurations, e.g. render the widget disabled, next enabled, Storybook then lets you easily browse through it.
Why downvotes?
They're solving a language problem with a framework. Its not like you can avoid using this, classes, binding methods when you're making a sizable SPA in JS. 
I'm a little late here, but by chance have you read [The Ultimate Guide to Execution Contexts, Hoisting, Scopes, and Closures in JavaScript](https://tylermcginnis.com/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/)? I teach JS for a living and this was my best attempt at explaining it. I even built a tool for visualizing JavaScript's execution context which will allow you to visually see what a closure is. Hope it helps.
You can also integrate Strorybook into Screener to get alerts for when your components change, so you can approve those changes (just to make sure no unintended changes get through). Kinda like Jest's snapshots
Came here to ask the same question 'cause I've seen it a lot but never bothered looking it up. Thanks for beating me to it. 
First of all why you care about UTC? Number of days between 2 dates will be exactly same in UTC as UTC+8; &amp;#x200B; Second, why do you need to use any library for this? What's wrong with VanillaJS approach? &amp;#x200B; Something like this will do: function daysBetween(from, to){ return Math.floor((new Date(to) - new Date(from)) / 1000 / 60 / 60 / 24); } console.log(daysBetween("2018-10-28T00:00:00.000+00:00", "2018-10-30T00:00:00.000+00:00")); // 2 console.log(daysBetween("2018-10-28T23:59:59.000+00:00", "2018-10-30T00:00:00.000+00:00")); // 1 console.log(daysBetween("2018-10-29T22:00:00.000+00:00", "2018-10-30T08:00:10.000+00:00")); // 0
Great tips! Thanks for sharing.
you can vote me down as you want, i'm native speak and a capital ß does not exist.
If your team is more comfortable with angular, Vue is probably going to be an easier transition. Why not later versions of angular? Though I know in all scenarios it's not a straight migration path.
Reject both of them. I've seen major projects run into issues with Vue and React (and they resolved those issues) but if you're going to run into issues with these major frameworks, why not just adopt something that is far superior, better written, and the only setback is a smaller community? **Choose Aurelia.** (Aurelia.io) We're deploying Aurelia apps next to React apps (that were once upgraded from Angular 1.x). No one even considers Angular 2+. The main question has been lately: Vue.js vs ReactJs (rather than angular), and well, when you compare Vue to Aurelia, you find some limitations with Vue. ReactJS style is very unique to itself and there are many who like it and many who don't. **The "experience" problem:** If you are trying to hire people based on "experience with framework X"; don't do that. Hire good Javascript, ECMAScript devs, and they should be able to figure out any framework. You may not find ppl with "Aurelia" experience, that's okay. Find people with any javascript framework experience. Aurelia is a smaller community, but you can talk in their discourse or StackOverflow for questions and people respond. There are already plenty of components built-in and available including a nice navigation/routing system. There is no limit, unless you have to support say IE 6/7 or something, &amp;#x200B;
Sure and because of that everyone uses it now :'D. Ask a another native on the street and they'll probably ask you what this is.
Total crap... AngularJS has issues... ReactJS has issues. NodeJS is back-end to be used with server side stuff like expressjs, or just to host static files or deploy a js framework. &amp;#x200B; The contest is really about: AngularJS vs ReactJS vs Vue.js vs Aurelia And I happen to think that Aurelia is smaller community but better designed. But a lot of it is preference.
Another vote for React Native. I use it with a whole lot of Firebase (Database, Auth, Crashlytics, Storage, FCM) and it has working dreamily well.
I see your point. However, although the ß character is only used in German, the main question here is not 'what is the correct capitalization of "ß" in German?' but 'what is the correct capitalization of the character "ß" from an international standpoint?' Logically, `string.toLowerCase().toUpperCase().toLowerCase()` should be equal to `string.toLowerCase()`. However, 'ß' is an exception that breaks that logic. In my opinion, if in the German language ß→SS, not ß→ẞ then the programmer should create that special case, not the programming language. JavaScript is an international.
I wish there was more to be done, but we (mods) can only remove posts. If there was a way to 'banish' a post, such that it falls off the front page yet still remains visible in the archives (search), that'd be a decent middle-ground, but there's no means to do so. It is sad that content gets lost, but reddit just doesn't work well for such content (StackOverflow, with 10 years and millions of dollars, still fail in many regards). I think there's at least 2 facets of the solution: 1. We (mods) need to improve our messaging at posting time to better inform the user, and automod conditions to catch those who don't read the blurb. We've been iterating on this but it's still lacking obviously; users who won't read likely also won't use easily-identifiable post titles which can be picked up via regex (automod). 2. We (users) need to stop feeding the wildlife, and instead be firm in referring them to /r/LearnJavascript. Growth is probably our biggest challenge which underlies these issues -- we're averaging around 1k new subs per day. It's a good problem to have, but brings with it a certain amount of chaos.
I think soon async render will support promises, I wonder if there will be a difference between using `useEffect` vs. the async render api. 
So before 2017 there was no other choice to put SS as capital of ß. Therefore it makes absolutly sense. 
That’s dope. 
So, I wonder... will JavaScript and other languages update their capitalization tables? Not that 'SS' is wrong, but 'ẞ' makes much more sense from a programming perspective.
good question, i guess it would be much easier to work with 🤔
Hi /u/aspmvp, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Hi /u/ScalaQuest, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Posts must directly relate to JavaScript, and content regarding CSS, HTML, general programming, etc. should be posted elsewhere. Thanks for your understanding.
This is dope! Does anyone know of something similar for Vue?
ok where can I test it
You've given no actual reasons to choose Aurelia, just a couple reasons to not choose other frameworks and unfounded assurances that Aurelia's "not that bad" (smaller community, just "competitive" in speed not better, and then super-nebulous "far superior" &amp; "better written").
The link leads to a 404, and you don't have anything else similar to what your talking about. I don't think you uploaded the repository correctly, could you try again?
&gt; you can use ES6 syntax or pre-ES6 format. You'll have to be more specific here. I think you mean _arrow functions_. There are a number of new functions/function syntaxes with ES6. Arrow functions is only one of them, and only they have specific `this` rules, specifically using the lexical `this`, not the calling `this`
I'll reply in a couple hours with the links. Have to do some more work before it can be public due to security reasons 
Have you tried puppeteer?
Maybe just give us a dummy repo with two files which do what you said. just to outline the issue
[PhantomJS?](http://phantomjs.org/screen-capture.html)
Ah that would be smart lol. I'll get on that
Thanks for the insight! Indeed a tricky situation.
 I want to code a random shuffling array of images, where each square pulls from a separate folder of images and every time it refreshes its another random array of images. I'm not sure how difficult this is any help would be amazing
You switched from Mac to Windows?
Yeah, my Macbook Pro was getting out of line and I couldn't afford a new one; so I moved to Windows. Has been better than I expected, I must say, but I miss a couple of apps.
I'm not going to write a comparison article here. The main reason is that it is a BETTER designed framework, and I've compared the codes side-by-side. You may PREFER your own frameworks that are more popular or have "more community/resources". However, I am opting for a smarter design for the way the code is written. Everything is nebulous... As far as speed goes it is one of the fastest performing frameworks. If there was ONE CLEAR winner -- then there would be no preference anymore, everyone would gravitate toward one framework. Aurelia, Vue, ReactJS, Angular, can all do the same things, it's not like one has a feature the other is missing. Not to mention, you have to trust my years of experience, if you don't trust it (because I'm a random person on the internet), that's fine, but I'm just ONE opinion out of many. There is no way for me to say "No you must use X because everything else sucks" &lt;-- and I made no such claim. I said that using Aurelia is a good framework and you should learn it because in my view it is written better than the others. And I'm not about to go line-by-line into details on a short reddit comment section.
I realized it was set to private xD but it doesn't matter as for I am scrapping the code as I didn't understand it and starting again by going though the HTML Game topic on W3Schools :D
I've migrated Angular 1.x apps all the time. Reject both of them. I've seen major projects run into issues with Vue and React (and they eventually resolved those issues so all these frameworks are "flavor") but if you're going to run into issues with these major frameworks, why not just adopt something that is far superior, better written, competitive in speed, and the only setback is a smaller community? If your team needs consensus, just show them various framework example code. Aurelia just looks a little better designed (in my opinion). **Choose Aurelia (not because it's the "best framework" there is no such thing; all the 4 major frameworks are just as competitive).** We're deploying Aurelia apps next to React apps (that were once upgraded from Angular 1.x). No one even considers Angular 2+. Aurelia is a split from Google Engineers who did not like the way Angular 2 was going so they left and created Aurelia and that's why it's so well-designed. The main question has been lately: Vue.js vs ReactJs (rather than angular), and well, when you compare Vue to Aurelia, you find some limitations with Vue. ReactJS style is very unique to itself and there are many who like it and many who don't. Aurelia uses classes and separates out the Html into files, it's just more organized. **The "experience" problem:** If you are trying to hire people based on "experience with framework X"; don't do that. Hire good Javascript, ECMAScript devs, and they should be able to figure out any framework. You may not find ppl with "Aurelia" experience, that's okay. Find people with any javascript framework experience. Aurelia is a smaller community, but you can talk in their discourse or StackOverflow for questions and people respond. There are already plenty of components built-in and available including a nice navigation/routing system. There is no limit, unless you have to support say IE 6/7 or something. You can deploy with WebPack, SystemJS, RequireJS, or its built-in bundler. It has Au-cli (a little console thing that lets you setup quickly). It has typescript if you don't like ES/js.
I think this is a fine way as far as validation goes. If I were making this, I’d probably split the form types into different functions as this seems a bit clustered, but that’s just my preference. Additionally, if you’re using this on an open and crawled page, I’d add an additional input and keep it hidden then validate that input to ensure its value is blank. The reason being that occasionally (albeit rare), crawlers will fill forms and if the hidden form is filled, you know it’s not a human. Though you’ve got so many validations here its probably not necessary. Although, if you’re using it on some system like Wordpress or Joomla, it might still be a good idea as these platforms are often targeted by spam and other bots whom scan the web for those systems. As for your method of notification, your users will hate you for having alert boxes rather than more subtle inline warnings on the form itsself or tooltips if you’re feeling extra fancy. They will extra hate you when they forget multiple fields and they are hit with a stack of 7 alert boxes back to back. It’s usually best to stick with inline, but if you must use alerts, absolutely terminate after the first failed validation to spare your users the endless pop up attack. As a good general rule, when making standard things like this from scratch it’s a good idea to visit them on well established websites and see how they’ve done them so you’re not missing anything. Though, I’m not sure what weight user experience has on a school assignment. I don’t know how they’re graded. In reality, with these things like forms, buttons, etc., while it’s great you’re learning the fundamentals, I wouldn’t stress too much because no developer designs without some sort of library that covers all these basics. One you’ve got that, you can go in and modify the design or feel after the fact, but writing new code for basic objects for every project will have you ripping your eyeballs out. I’m not sure what you mean by hidden tables/rows. If you mean design, typically I’d use either flex box or css grid (aka “display:grid/flex”) or maybe both, I avoid tables in any and all situations where possible (*except html for email). Good luck!
Yes it would, you can declare function return types too - the above wouldn't have compiled...
Well, it’s front end because it’s offloaded from the server (backend). JavaScript is exclusive to the clients browser. Most things are designed using either pre-existing or custom made libraries of css (and sometimes bits of JS). It would be a nightmare to design a full site and write the basics over and over from scratch on each site. So, I’d say most of the design is done in HTML as with libraries, the design is mostly just adding classes and ID’s. But that may just be semantics... If I’m being honest though, technically 100% of my time is spent with JavaScript as I’ve been doin mostly react lately which is exclusively JS (or actually JSX, but whatever). JavaScript is basically the backbone of user experience these days. Need to add, drop, move, hide, unhide, validate, fetch data, time things, catch events, react to input? All JS. You have to remember that even when you have a simple button with a hover effect, the click is an event. That event is handled by JavaScript. Many times, CSS is triggered in part or in whole by JS. CSS is dumb. It can’t do logic at all whatsoever. So if you need to respond to a hover event or run a basic animation, it’s great. Beyond that, nothing but JavaScript.
First off, you’ve done yourself a huge service starting vanilla. So so so so many people stat with something like JQuery (an antiquated monster) and ruin their learning units. I would probably start with React, but that’s only because I did and so it seams easier to me. Plus, if you know the basics of JS and you know HTML, react is a walk in the park — you just have to learn the structure and basic premise. Also, Vue is popular, but in no way is it even close to as popular as React. Might as well learn the most potentially lucrative library first (because that’s what Vue and react are: libraries). Node is server side js and is not required at all for Vue or React. They are both exclusively view controllers. Beyond that is irrelevant. I would most certainly learn ES6/7 before starting with either. It’s pretty crucial if you want to be serious about it. It’s really mostly just the same old tricks with a new hat. As for how much to learn before you jump into something like Vue, the only correct answer here is all of it. You don’t need to inscribe every possible prototype or reserved word to your brain walls, but you most certainly want to have a sound understanding of the fundamentals in entirety. Otherwise, you’ll keep hitting walls every step of the way and won’t understand why some things are and others aren’t. It’s bad news, big time. You just have to stick with it. Once you understand the core structures and fundamentals, you’ll begin to see all that confusing code in these libraries and see connections (which is key for mastering them). With that said, this does not include Angular. Angular is satans language of choice. Seriously, don’t even look at it until you’re level 100 JavaScript black belt.
&gt; at my company we have to deal with the fact that Angular 1.6 is the past I actually typed `date` in terminal and pressed enter to double check what year it is.
Its hard to explain closures if the student has limited background in cs or programming. First instance I saw of a closure I thought dangling pointer. Knowing the pros and cons of such a construct allows me to make the connection in a jiffy. When I examine code segments posted online or read blogs I fill in the gaps in knowledge for its use cases. As stated above it helps to understand them and use them to manage code complexity.
first off, thank you for your reply i really appreciate it... i know the basics of html/js so React is the way to go i don't know anything about Vue i just heared people saying it somehow between angular and react but others also said that react is pretty easy so i'll take your advice here and learn React.. about ES5/6/7 what version should i start to learn ? 
Vue has FLIP animations built in with transition-group
that still doesn't explain to me what it is doing or used for. I have components separated into their own directories with their CSS and test files, so is this providing graphs or analysis to show me the components' dependency trees? 
so it's a mocking and testing utility for development purposes?
Hi /u/Davidfosford, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Since you appear to have deleted your other comment with exactly this content, I'll repeat myself here ([this is the comment I replied to](https://www.reddit.com/r/javascript/comments/9shq40/migrating_from_angular_16/e8p9doo)to avoid the conversation being stifled while you continue to say that Aurelia is better but managing to give no real examples of any advantages Aurelia has over any other given framework: &gt; See, you've still given no upsides to using Aurelia. You've said it's "better written", but given no clear reason on why you believe that. It's one thing to say you like it more, it's completely different to say it's better. And of course there's no one clear winner - but there are definitely advantages and disadvantages to each framework. For example - one definitive pro for React is the one-way data binding. It's very explicit when data is passed, and React's immutable nature makes it changes in the data very clear - data is stored in one place, and it's either changed there or there's an explicit handler to change it right there (where the handler may be passed around). Angular has the distinct advantage of separating views from the javascript that drives them from the styling that prettifies them. However, you've provided none of this, just nebulous "Aurelia is good but doesn't have much community support so maybe use that"... which is a terrible piece of advice for anyone asking about moving their company to work with that, since "less community support" effectively means that when you have a problem, there's a good chance you won't be able to find a resource that helps you solve that problem. And of course all the frameworks can do anything you want them to, their point is to make that work faster, or more scalable, or easier to read, or [any number of other benefits]. Plain JS can do all those things too (since all the frameworks decompose to plain js eventually, since browsers don't know how to read an Angular directive or what have you). I'm not saying you should be able to "scientifically prove ... ONE framework is better than another" [emphasis mine], I'm saying you should be able to give at least one concrete advantage that a framework is better than another in a given context. Like Vue has at least an advantage over angular in that it supports putting everything for one component in one file, or React makes it simpler than Vue to break out more pure components (since you can literally have a component be a lambda that returns a jsx snippet), or Angular makes it easier than React to bind a variable directly to "whatever is put in that &lt;input/&gt;" (due to the innate two-way data binding). You've given no advantages whatsoever to Aurelia, while suggesting that someone migrate their codebase to a framework which has less support. It may be a little nebulous, but if you honestly believe you can't give discrete, concrete advantages or reasons to use a given framework, you haven't actually tried to find what's best, you've just looked at them and said you like one - with no regard to the actual, distinct benefits any given framework has over another framework. Don't try to sway others into decisions you didn't actually think through (or at least, where your words show no real thought into which is actively better - because as-is, your comments are just attempts at deflection without any substance; you've given no reason to use Aurelia over plain JS, let alone any reason to use it over another framework - surely there are reasons, no?).
Hi, no the webpage is just an assignment. How would I go about putting inline warnings instead of alerts in a table i meant. 
after i learn react is there anything else or react it self is so big for me? i also heard about the MEAN Stack Mongo, Express Angular and Node .. React in our case is this the path that you are taking .. learning react first and after that node and express and mongo .. can one individual learn all of those frameworks/DB or it's a team job where everyone learn one thing? if you don't mind tell me what do you want to learn or have learned so far?
Let me preface this by saying this answer is written without rereading the spec, so I might be off in some places. There are also some deliberate simplifications. Okay, let's do this. # Closure Simply put, closure means a function can access the scope it is defined in. A little vague, huh? Let's look at a common example. function createCounter() { let counter = 0 return function increment() { return ++counter } } const counter1 = createCounter() counter1() // 1 counter1() // 2 const counter2 = createCounter() counter2() // 1 First of all, notice `counter1` and `counter2` can access the `counter` variable even though the local execution context in which the latter is defined has long ended. Second, `counter1` and `counter2` have separate `counter`s. So, what are **some** of the things we can do with this? ## Functions that keep track of state The above counter snippet is an example of this. In other languages, in order to do something like this, you need to either create a class and instance; or pass the state back into the function. class Counter { constructor() { this.counter = 0 } increment() { return ++this.counter } } const counter1 = new Counter() counter1.increment() // 1 counter1.increment() // 2 const counter2 = new Counter() counter2.increment() // 1 or function increment(counter) { return ++counter.count } let counter1 = {count: 0} increment(counter1) // 1 increment(counter1) // 2 let counter2 = {count: 0} increment(counter2) // 1 ## Functional programming Let's look at a basic usage of `Array.prototype.map` [1,2,3].map(function(a) { return a + 1 }) // [2,3,4] One day you notice you are doing this a lot in your codebase, but adding different amounts each time. Hmm... only if we have a factory of addition functions... function add(a) { return function(b) { return a + b } } add(1)(2) // 3 This is known as currying, where you pass arguments one-by-one instead of all at once. Now your map code can be written as [1,2,3].map(add(1)) // [2,3,4] Much more readable and reusable, but this is only possible because the inner function (returned by `add(1)`) still has access to `a`. This style of programming where you pass around functions to express what you want instead of using imperative statements is known as functional programming. We are not even scratching the surface of functional programming here. Feel free to look more into it ## Memoization This is a special case of "keeping state". Suppose you have a time- and/or memory-consuming function function someFunc(integer) { // Heavy work return result } const r1 = someFunc(1) const r2 = someFunc(1) Having to recalculate `someFunc(1)` twice is bad. We can save the result in an object const cache = {} function someFunc(integer) { if(cache[integer]) { return cache[integer] } // Heavy work return cache[integer] = result } The benefit provided by closure here is the `someFunc` will always have access to `cache` regardless of where it is passed to can called, which brings us to... ## Avoid pollution / hide variable In the above memoization example, we have polluted the global scope by defining an extra `cache` variable. Moreover, outside code can freely read and modify our cache. We can prevent both of these by combining closure with IIFE const someFunc = (function(){ const cache = {} return function(integer) { if(cache[integer]) { return cache[integer] } // Heavy work return cache[integer] = result } })() Now, outside code does not even know about the existence of `cache`, let alone access it. Global code can define a different `cache` freely. # "this" Ahhhhh, good ol' `this`. So, what is `this`? Like you said, `this` can be whatever due to the existence of `.bind`? The way I think of it is a special argument that you have ways to pass explicitly, but the ECMAScript language sets some defaults if you don't. First of all, we exclude all arrow functions here, since arrows function do not bind `this`. For arrow functions, `this` behaves like any other variable, subject to closure rules above. For the time being, lets throw `.bind` and bound function out of the window. So, what are the default `this` values I talk about. That depends on how you call a function: - `Function.prototype.call`, `Function.prototype.apply`, and `Reflect.apply`: For these, you set the `this` binding explicitly - `obj.func(...args)`: `this` defaults to `obj`. Note that this includes `obj.nest.prop.func(...args)` because that's just `(obj.nest.prop).func(...args)` - `func(...args)`: In strict mode, `this` is `undefined`. In non-strict mode `this` is the global object - `new func(...args)`: `this` is a newly-created object with `func.prototype` as prototype So, with some (over?)simplification: - `obj.func(...args)` is same as `obj.func.call(obj, ...args)` - `func(...args)` is same as `func.call(undefined, ...args)` or `func.call(global, ...args)` - `new func(...args)` is same as `func.call(Object.create(func.prototype), ...args)` except the return value Now, we have specified all function calls as `.call/.apply`. Let's throw `.bind` and bound functions into the mix. Again with some simplification, `func.bind(this1, ...args1).call(this2, ...args2)` is same as `func.call(this1, ...args1, ...args2)`. That's all there is to it. # Recursion Sometimes, a problem is naturally defined as a "smaller" instance of a problem. As part of building a function to solve these problems, we can use the function itself to solve the smaller instances. The classic example is factorial, which is defined as: - 0! = 1 - n! = n × (n-1)!, for integer n &gt; 0 Now you start writing a function to calculate `factorial(n)`: function factorial(n) { if(n == 0) { return 1 } return n * //... Now you need the value of (n-1)!. Huh, if only you have a function to calculate factorial of a nonnegative integer... Oh wait function factorial(n) { if(n == 0) { return 1 } return n * factorial(n-1) } Admittedly, writing factorial as a loop is not that bad. But consider something more complicated as mergesort. To implement mergesort as a loop, you may as well have implemented a simplified call stack. So instead of just doing recursion, you simulate recursion using loops. And then there are stuff that can't be expressed as a loop like the Ackermann function.
Using `Boolean()` isn't casting. It does a truthiness check on what you pass to it and returns a boolean.
Most developers build web apps that use JS. What you are thinking about is more inline with content sites
You don't need to know everything. Learn react for ex. build spas, pwas, land a job, that's it. I understand your current motivation, and be patient, don't jump from Lang to Lang. As you told you already know es6, so well structured react spa with promises, async, mapping, etc would definitely show your passion for employer
Not only browse, but test, and also develop (in isolation).
I use it for developing UI components outside the context of my app. Sometimes a component has important visual states that are hard to reproduce, or it's just a pain to navigate to in the first place. Storybook makes it easy to create a webpage that shows the component in isolation, with mock data. That helps me iterate on visuals without dealing with the rest of the app.
[VS Code](https://code.visualstudio.com) has done well for me. 
Do you feel comfortable with the basics of programming? Trying to jump into a framework without understanding the underlying fundamentals will be a painful exercise to say the least. 
This. One of the best out there!
VS code us great undoubtedly the best free open source IDE right now.. But if you are looking for something simpler (not an IDE , but an editor) I'll suggest you to use sublime text 3.. Its the fastest amongst the all and with sone added pluginslike emmet, Its great..
My favorite part is Emmet. 
Vs code is pretty good and has an large amount of extensions to help you
That's pretty! 
At the most basic level it's just a structured place to render your components in isolation (away from your main app), and comes with a UI for viewing them. You can utilize this for a few purposes: - Component catalog or "showcase" for an app or library (with or without documentation) - Development in an isolated context - Testing isolated components in various predefined states - Manual or automated - Especially useful for visual/style testing, e.g. screenshot regression tests You could of course use other solutions for these things, or build your own; Storybook is just a popular (and I believe now, well-funded) abstraction with an ecosystem of addons for this stuff, so you don't need to get bogged down in the details so much.
Rather than looping through the various form fields, you could select the form fields by their id, then check each of them against the appropriate value. This would eliminate a lot of the nested control flow logic and be a great first step to improve the readability of your code. As [easyEs900s](https://www.reddit.com/user/easyEs900s) said, spamming the user with alerts is a bad practice. There are many ways to display validation messages besides alerts. Do some research and try some out, [https://css-tricks.com/](https://css-tricks.com/) is a good place to start. Try not to use 'magic strings' in your code. Lines like this are a 'code smell': `else if (forms[i].name === "Widget #1 quantity")` Instead, try rethinking your overall program design, or at the very least -- turn your string values into constants, so that your design remains clear as you improve upon it. 
I can also recomnend Sublime Text 3. It's not free, but it has unlimited trial, which I used for several years, until bying it recently :) It has a lot of useful plugins, works faster than those new Electron-based editors, like Atom and VS Code. Runs great on Linux too!
God damn, very nice job. Mobile support ftw
This is really cool! You should keep working on it. I want like a cool message when I get it right, and the question shouldn't be small and hard to read
Yes, pretty much. 
Worked in some of the newest Node versions for sure. I discovered it because one of my unit tests randomly failed when nothing but Node version was changed.
I haven't, I'll give it a shot, thank you!
This is the best. Sublime is also good if you don't mind repeatedly dismissing the Popup.
I don't think it does the inverse scale transform which makes this so awesome
maybe he really wants that t-shirt
Wtf, why so salty? Coding style is important, and if you think otherwise you should may not be in this profession.
Hmm. It seems that puppeteer is for Node.js only. Is there a way to use it outside of Node at all?
VS Code can use sublime like key bindings too. So still vs code is best one. 
Check this out: https://tylermcginnis.com/javascript-visualizer/
Edwards packer is written in .net, perl and php but not Javascript. :-\\ 
For frontend development its totally irrelevant which version you use (when tools like npm are not complaining about old version)
Thanks for your feedback! I'm planning on adding feedback for each question, as well as a leaderboard (that you can opt in to) so you can see how you compare to other people around the world. &amp;#x200B; I'll adjust the font size etc as well - thanks a lot for pointing that out.
[Here's an example](https://http://plaudit.pub/components) of a the Storybook output of a small app with a single React component: `&lt;Widget/&gt;`.
As many people have already said... VS CODE. An amazing open source editor created by Microsoft
html2canvas should support SVGs as the canvas itself does. Where are the SVGs coming from, if they are from an external source you would need to use a proxy to bypass the cross origin issue so the canvas doesn't get tainted when injecting the SVG. Do you have a sample of your code?
Vscode, hands down
Yup! VS Code for life!
Vim takes so many extensions to get it up to speed... it has you learn an alternative input system so you can... type faster. That's not an exciting value proposition compared to VSC's Intellisense, where you get information on other libraries for free just because authors have started to use TypeScript.
[removed]
A M A Z I N G
I found them online and was going to have it be an assignment for my web students but too much of it seemed dated and I didn't have the time to comb through. If you find that it works please share. Thank you! 
For me, it doesn’t matter. I work on a 12” laptop and alt-tab wicked fast, a crappy res mobile vertical 15”, or a 4K 24” asus. Just write good code... and make sure you’re testing on all types of screen sizes if you’re styling anything. 
Html2canvas doesn't support svg. The svgs are generated locally with a script. I got it working now though. What it does now is it generates the svg, copies it's xml, injects it into a canvas element and only then use html2canvas. Now it copies the whole page including the svgs.
If you need a monitor specifically for development, go for the following: \- 60Hz is enough. It really doesn't make any difference \- matte screen will help your eyes with light reflections \- IPS: since you're doing FE development, you need accurate colors representation \- ultrawide or 4k is strictly dependent to your tastes, but I personally would pick something between: curved ultrawide with 3440x1440 or a true 4k monitor. Higher resolution means "more stuff on the screen". Doing FE development, you may want to have the IDE, browser, browser's console etc opened at the same time. \- response time is not important \- pick something with higher brightness (at least 350cd/mp) if your monitor stays in direct light macOS' scaling is implemented correctly and you won't have issues with the resolution. Be careful to see what your is your laptop's max resolution.
god damnit emacs!
This is a really random and underdeveloped thought, but: Vue has single-file components that include a `&lt;template&gt;`, `&lt;script&gt;`, and `&lt;style&gt;` tags in the same file, mixing HTML, CSS (or whatever style language you use) and JS content. Extra content outside these tags is ignored. What about adding `&lt;example&gt;` or `&lt;story&gt;` tags to the file that define the scenarios for this component in some sort of expected format? The storybook server could parse these same source files and pull out the examples/stories. I wonder if having all of this content in the same file would encourage keeping them up to date.
We've opted to go for multi-package development. So all reusable («dumb») UI components are in their own packages called \`ui-kit\`. \`ui-kit\` runs storybook and showcases all components. This packages is consumed by n \`app\` packages that use these components. These \`app\` packages may also have their own components, but they are not exposed through storybook since they're not necessarily reusable from a design perspective. This basically increases the chance of a developer actually testing and previewing changes in storybook. To further ensure stories being updated, we also do code reviews, just like /u/ArcanisCz suggested.
I am 32 and have eye and neck strains already. I'd like to continue working as a web dev, so if I am buying a nice screen, I'd like it to be decent. 
[removed]
Your code formatting &amp; naming is all over the place. Try running your code through something like [Prettier](https://prettier.io/playground/), and use `camelCase` for your naming. This will make it much easier for people to read your code and help you out.
Thank you for your voice!
Thanks - I also think that 4k is just an overkill for daily usage. I'd probably get it only for gaming or if I was a graphic designer.
The same one everyone writes PHP with. And C, too.
See, you keep saying you've given several reasons why Aurelia is better... But you still haven't. Just the "easier to read" one with no reason of why (just that Vue can get cluttered and hat Angular also has file separation), and that it's a few milliseconds faster in some circumstances (which is a benefit, however small - it's not really a benefit to render 10,000 rows in 130 ms instead of 138 ms). Furthermore, guess what does a better job of showing advantages that you've stated: - actually listing advantages (and disadvantages, which are also useful) - incessantly claiming you've provided several advantages.
We mostly use it for development but later it gets a little useless indeed.
I created https://www.amptemplates.io It is a collection of free AMP templates from all over the web and an early stage drag and drop AMP template builder. Check it out on Product Hunt : https://www.producthunt.com/posts/amp-templates
I like Netbeans personally.
The same can be done with Mobx with [much simpler code](https://codepen.io/cvann36/pen/bmyoJv/). No need to use context, even.
Geany: [https://www.geany.org/](https://www.geany.org/) **Why?** \- Simple yet powerful. Very low consumption. \- Never fail when remote editing if the network switch off (Unlike atom/Vs). \- Powerful simple keyboards shortcuts (ex: CTRL+D copy line. CTRL+E Comment line.) \- Built in shell that never fail. \- Completion with plugins, macros etc. Visual studio is too fat and is updated every 3days. This is very boring. The only one better thann geany is sublime text, which is not free. 
This always happens to me I swear! Did you find your issue yet? I can only recommend using Chrome's debugger to its' fullest to track the values you throw in as arguments
I think I did. It seemed to be the env variable was using that threw the error. Not sure exactly why it only has issues on the live server but it works so I'm done toying with it lol. 
[removed]
10.x is the new LTS (stable) version. You may hit issues with packages using the bleeding edge, stick with the LTS.
NO. Learn vanilla ES6, vanilia CSS, canvas, svg ... Later you will see if you really need a framework. You will be able to create modules/plugins for this framework yourself as you need. Unless that you will be stuck in something slowly dying, whatever the framework, it's dead already. 
Indeed, `window.scrollTo({ behavior: 'smooth' })` would be a simpler, more effective solution. But I think the `behavior: 'smooth'` option is actually not as well-supported across browsers as `scrollTo()` itself, so you might want to verify that for your case. And as you've said, if you want more control over the speed and "flow" of the scrolling, then you might indeed need to implement it with `requestAnimationFrame()`.
Firstly, you should uncheck `screenshots in the dev tools - it _will_ affect your FPS measurement. You may find that you're hitting 60FPS without it.
Damn hooks are hella popular already
8-800 2 8888
I dont know why you got downvoted as op wanted to have non-ide editor. And ST3 is one of the best ”graphical” one in this category. Shame on you downvoters! :)
## Form a user perspective: #### Following through on actions There are a couple of situations where you perform an action but leave the user there, hanging. When you register a user, it shows "user created", but it just leaves you there. At the very least, you should automatically take the user back to the login form with a message of "You're now registered, please log in". Ideally you would automatically log the user in and take them to his user page as if they had just logged in. Something _similar_ but different happens when you upload an image. You upload the image correctly and it just shows you the upload again. Yes, you might argue that this allows the user to upload again. But on the other hand it gives the user no feedback at all about the upload done. Did it work? How does the picture look? It would make more sense to show them the result of the upload (i.e. send them to their page to see their photos). Also, after uploading a picture the caption input is _not_ cleaned up. If you do upload a second picture it will still contain the previous caption. #### Pictures are distorted Pictures are always presented in a square format. But they are not cropped to that format. And so, images are distorted and squashed into the square shape. There's also no way to see the image at it's original size. Not just aspect ratio, but size. Images are fixed into the 300x300 size and there's no way to see them bigger. #### The home page is a blank space full of nothingness If you have nothing to put there, then just eliminate that section and make the user page the home. I've now read in the readme from the UI that the home page is supposed to show pics from people you follow. Ok, that's fine. But then you need some sort of alternate message that serves as explanation for new users. Something like "You're not following any users yet" at least. #### "Load more" when browsing does not work It just doesn't. Nothing happens. This is all a user sees. If I open the console, then I can see a request is actually being made. The response is an empty array, so I guess there's nothing more to show, maybe. But a _user_ won't see this; no feedback is given at all for this situation and a _user_ will get no feedback at all and still see the button there to try again and again to no effect. #### No clean-up on user options I click to "edit my profile". I do nothing i.e. I neither click Update nor click cancel. I click "settings". I cancel deleting my account. Instead of taking me back to the "normal" state, I see the editing of the profile is still there pending. It is almost never a good idea to maintain hidden, unfinished actions. If I leave some action (as I did by clicking the settings icon) then either simply trash any pending unfinished action (with or without a warning) or do _not_ allow me to leave. #### Log out Log out is only reachable from the user page. Logging out should be an action that is available from anywhere. #### No way to unblock users I "accidentally" blocked someone while trying to figure out the icons. Their submissions disappeared and now I can't ever see them and I have no way to unblock them. This seems a bit extreme. #### Log in form is not submitted on pressing enter key You need to actually click the button. You can't simply press the enter key to have the form submitted. ## About the code For the UI, the code is pretty much a typical Vue application. Most of the problems mentioned above reflect in one way or another some missing piece in the code e.g. [this](https://github.com/ibrahimpg/venomgram-ui/blob/master/src/components/Login.vue#L78) is where nothing is done after registering. But other than that, _in general_, the code is fairly typical and generally ok. Some things may be done differently, but that doesn't mean there's something particularly _wrong_ with how it is now. The server seems to be also a _fairly typical_ Express application. This however is not as _ok_ because typical Express applications tend to fall down into the same general problems. #### index.js should be high level set-up with no detail `index.js` is doing too much stuff. You see lines 23-24? That is the level of detail you want to maintain in that whole file. That is, things like lines 26-35 are in a totally different level of detail. You should have something like... const ErrorHander = require('./blablabla...'); // ... app.use(ErrorHandler); The same applies to lines 9-17. #### Separation of concerns In a similar fashion, all the logic of your application is in the _routes_. **Everything** is there. leaving aside set up and schemas, all your application is mashed together into two files `api/routes/post.js` and `api/routes/user.js`. At this moment the app is "sort of small" and this may not seem like a big deal, but if you're doing this as an learning exercise, this is **certainly** a problem, because you're not learning at all how to structure a real application. And in any case, both have already grown more than enough to consider at least separating the logic of **routing** from the logic of the application itself. There's not much more that can be commented about the code in general as it is a very simple application and doesn't have much in the way of "interesting bits".
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ibrahimpg/venomgram-ui/.../**Login.vue#L78** (master → 556c5e2)](https://github.com/ibrahimpg/venomgram-ui/blob/556c5e25239afb2e1508b5587801918cec8e8348/src/components/Login.vue#L78) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e8q0gvt.)
SpOoPy !!!
I don't think that's where the issue is coming from, I've had the same issue without having the devtool open
[https://gist.github.com/leovdw/39ca564b1843f6413a7c800aca7dcb0a](https://gist.github.com/leovdw/39ca564b1843f6413a7c800aca7dcb0a) &amp;#x200B; Edited script
Hi /u/rayhan666, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Fair enough, I'm just suggesting that when you're measuring something, you need to make sure your measurement is as accurate as possible. If I'm profiling performance in the dev tools, I always try to use an incognito window (no extensions), and turn off things like screenshots and memory recording.
You could try getUserMedia api, although there will be browser incompatibility issue. So it depends on what you need. Is there any reason why do you want to generate the image dynamically? Also, what kind of browser support are you looking at?
And the documentation **specifically** says to take your time. Tsk tsk.
Dependency injection IS a thing, however it's mainly left to individual programmers to decide whether or not to use it. There are some frameworks which have DI built into their philosophy (I believe Angular does this), but it's not really part of the JS-zeitgeist at the moment. The good news is that it is 100% possible to achieve in JS. One method I use is to pass in my dependencies on "require": var myClass = require("path/to/class")(dependency1, dependency2); 
I love programming on my 5K iMac at work. The syntax is crip as fuck.
Aside from dependency injection are there other more common, or maybe more standard, ways of decoupling dependencies in js? I'm trying to write some testable codes. 
Glad you got it fixed! I guess you're providing html2canvas the canvas you've injected the SVG into?
Pardon my shade, but if you're looking for standards you might want to try another language =p I think a lot of Node devs look at npm as their way of "handling" dependencies, but IMO in practice it actually couples your dependencies closer together. The way you write highly-cohesive, uncoupled code is the same way you do it in any other language - write strong, testable interfaces for your logical units. Javascript happens to have more flexibility than other languages, so it might be tempting to forego the step of defining your interfaces, but if you stand firm your code can be just as loosely-coupled as any other language.
We're actually moving the types out of definitely-typed and back into the main repo, so we should have first class typescript support shortly. Thanks for your patience!
If you are that paranoid you can download the code, read it, and build VSCode yourself. Of course, that's a huge effort, but if you are actually scared of 'not being alone', you need to do this to any software that you use to work.
Good point there, I'm still testing the waters in js and trying to learn the best practices. Javascript is a lot flexible than other languages and I don't want to over do or under do it. I'll take your advice and start working on strong interfaces. Thanks a lot!
We're working with the ember core team--AFAIK storybook is simply another option for ember users, one with a bigger ecosystem of add-ons and view layers (but I haven't done a rigorous comparison)
That sounds great, but can I run Google analytics on an iPad? The whole content being shown is super locally in the iPad so there is no internet connection.
Good to know. Just wanted to hear that you guys are aware of each other's efforts, and nobody's wasting their time duplicating work.
What's ridiculous is all the magic and non-idiomatic behavior. The documentation even acknowledges how strange it is, multiple times. Neither `useState` nor `useEffect` work the way you would intuitively expect with no knowledge of React. However, this is not so for class components. Instance properties and lifecycle methods are very true to the fundamental workings of ES classes. If hooks improve performance and workflow, fine. If they don't, then it's another mistake that will need to be corrected in future API revisions. On that note, where the hell is async rendering? It's been in the works for years now. That is the reveal which should have been made at the conf, not an unearned API change.
I feel like it's 2 things 1. People want to be ahead of the game and get some notoriety 2. The fact that they showed it off at React Conf and had it pretty much fully working shows that they probably feel stronger about its viability than they led on. The first 2 talks focused solely on it, they were pushing it hard I think it's an interesting addition to React but also worry people will overuse it. We'll see!
Server side code isn't open source, don't get confused. It isn't a regular owner, and not friendly servers. Again there is too much obscure network calls, and flood of heavy ass updates . Instead of reading the ten thousands lines of spaghetti code, just wireshark. Too much network call and plugins leads to instability, this program is just freezing when the network goes off. Beside that, free product coming from a major multi billion company is a red flag for me, and for most in the unix world. There is big money in play.
glad it works now
I think this is a bit overdramatic, sure there is some magic, but nothing inane. &gt; Neither useState nor useEffect work the way you would intuitively please explain, the behaviour is simple and well documented. The issue that may be problematic is the non-intuitive second argument of useEffect, but the api is still in alpha so this may change &gt;On that note, where the hell is async rendering? It's been in the works for years now. That is the reveal which should have been made at the conf, not an unearned API change. This has nothing to do with hooks, but just as a comment, I'm glad they're taking their time to think through the design of async rendering. 
&gt;How is that different than casting? Boolean() does not do a "truthiness check", it does a type conversion through a type constructor. The effect may be the same as a "truthiness check", the intent / intension is quite different. Boolean absolutely does a truthiness check. In fact that's what it was implemented for. &gt;Either way, my point still holds... It is non-strict, error-prone programming; if I somehow end up with an invalid state, I implicitly ignore it instead of explicitly dealing with it (i.e. throwing an error). My example wasn't a comprehensive program. I didn't show error handling because that would be unnecessary for a simple example of an alternative to a poorly used ternary operator. &gt;It is essentially the same as implicit conversion through a conditional expression instead of non-conversion through triple equals (identity / strict equality). It's quite the opposite! Boolean() is the most explicit truthiness check you could make without a much more verbose solution. &gt;A and B are printed, C is not. Yeah because isActive is a string, which unless empty, always evaluates as true. If you are storing booleans as strings, you have much bigger problems in your software than Boolean is responsible for. There is no case where `"false"` will evaluate as false. C fails because the string is not equal to `true`. But `"true"` is also not strictly equal to `true`. So your point falls flat there. Moral of the story: don't store booleans as strings. It doesn't make any sense and is not maintainable at all.
You can add and use custom tags. https://github.com/mattrothenberg/vue-storybook also a quick code snippet used to have a `&lt;docs&gt;` and render markdown: ``` config.module.rules.push({ resourceQuery: /blockType=docs/, use: [ { loader: "storybook-readme/env/vue/docs-loader" }, { loader: "html-loader" }, { loader: "markdown-loader" }, ], }); ```
reactive frameworks make your life ALOT easier if you got used to them. I hopefully will never have to use jquery again.
Lol, I bet you're a terrible developer with an inflated sense of skill.
New! Shiny! is the main problem in web development these days.
At Uber we use [Fusion.js](http://fusionjs.com), it's built on top of a DI system that encapsulates koa middlewares and can tap into React tree in a universal way (i.e. both on server and browser). Testing was a pretty central concern when designing it.
Edwards uses different approach. He uses code minification techniques and I use gzip (deflate) compression. With jsdeflate you can compress minified JS code with good compression ratio.
Like, this and WinRar, if you’ve bought them both you get a ticket to heaven 
&gt; please explain, the behaviour is simple and well documented Being simple and well-documented is different from being idiomatic. For example, `useState` potentially returns a new value on every call despite receiving the same argument, because that argument is used one time and ignored on subsequent calls. Who writes code like this? I think hooks will change a fair amount before 16.7 goes to stable. &gt; I'm glad they're taking their time to think through the design of async rendering. In the meantime, Angular has become faster than React, and Ivy even more so. Async rendering might end up being the Duke Nukem Forever of framework tech. Again, they should be improving performance over the API. Performance was originally the primary appeal of React.
I know right! I read that first and then 8 thousand article on how to get on it!
"Classes are confusing, so here is come magic confetti that is even more confusing."
&gt; lifecycle method headaches I like lifecycle methods, because thinking about what is happening for a component chronologically is important. Hooks do away with chronological context with the more ambiguous `useEffect`.
I think you're on to something. Keeping the UI in sync with the state and writing complex, efficient and easy to maintain UIs is for the birds.
Anyone experienced with React can easily adopt Hooks. The bigger problem is that React has fallen behind Angular on performance with no evidence that it will catch up.
Your team's mistake was selling it as a refactor. Should have called it a security enhancement.
neat idea
Thanks for the downvote, it's a good indicator of your maturity level. Good luck with you future endeavors.
Using MVC [ASP.NET](https://ASP.NET) and life is a lot easier than any of those patchwork open source frameworks. And it's a common opinion. I see not one advantage about using one of those. Eplain.
&gt;Reply &gt; &gt;share &gt; &gt;report &gt; &gt;Save Lol what that does even means
I think it's Redux fatigue. I can't find an idiom for redux that I'm comfortable with. It all feels so confusing no matter how I write it even though I know how what it's doing.
No need to take it personal. I have undone my downvote before you commented.
I think it has more to do with Web devs needing to learn everything ASAP, because the standards of the platform have been replaced with frameworks. Interviewer: "You don't know the Sproingpoo library? Well, that is literally THE MOST IMPORTANT THING TO OUR COMPANY GET THE FUCK OUT!"
I'm not sure about how I feel about this. Do hooks really solve any problem with web components (or LitElement)? I'm not really familiar with them just yet.
Lol no need to take a downvote personal? It's quite personal. It applies directly to my comment. No need to show disagreement with downvotes. Plus I'm not even sure what you're disagreeing with because I'm not wrong. But we don't have to debate anymore if you don't want.
&gt; I think it'll be like jsx where the benefits of simplicity make the non-idiomatic nature of it worth it. You might be right, but JSX is syntactical sugar - not the same thing. Hooks are like the opposite of sugar. They're syntactically bland. &gt; I think over time people have come to appreciate the declarative and composable nature of react as well as it's performance I do as well, but ultimately what matters is the end-product. Performance is a big deal in a lot of enterprise apps.
Thanks for feedback!
Wow, that's a new one! I don't have an answer you might also try asking on the storybook discord: https://discord.gg/sMFvFsG
The author has no idea what they're talking about. He seems to think that because something is harder means there's no point, ignoring all the benefits.
Functional programming and static type checking are orthogonal concerns, you don't have to choose one or the other. This is one of many problems with this article.
umm lol, that's a backend framework while Vuejs is a frontend framework. It appears you fundamentally lack the understanding of what these tools are even meant for.
Knowing the kinds of people that Google hires, I assume "Russian" was mentally behind the word "bot" in that writer's mind.
Learning the basic API of a framework is much easier than learning how you glued your random spaghetti together.
Suspense is already out. react-cache is the missing piece in the works. React-cache will do a better job handling errors and edge cases and is what you should standardize on once it's out, but there's nothing wrong with doing fetch in useEffect.
i agree with you i will stick with the vanilla js for now until i feel like it's time to learn a framework. 
egg roll builder, weight loss tracker, video game loadout builder, world clock, italian restaurant mapper, etc etc
He also bases his opinions on assumptions about SPAs that are simply not always true, and his answer to tackling the concerns of MPA architects is a fucking joke - just use Turbolinks and Stimulus.js, and only use React when you need to (no shit?)! Why? He doesn’t even attempt to explain. Nothing against either, but it’s like the author expects “they exist and I’ve used them” to be sufficient for convincing people that these tools in conjunction with an MPA architecture addresses all of the criticisms he listed against using an SPA architecture.
Some of the worst code I’ve seen in my career was written with ASP.NET by a guy who thought “easier” equates to “better”. Incidentally, he thought Javascript was garbage, too, and it was evident in his front-end code that he was terribly unfamiliar with it. JavaScript isn’t for everyone. Then again, neither is web development.
Hi /u/HotPotato1990, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
1. Think of small things in your everyday life. These are many, generally easy/small things which can translate well into a small exercise. Many classic sample applications or exercises come from these. Some examples: A grocery list, _to-do_ list, contact list; an appointment tracking agenda; a simple budgeting notebook; a travel check-list... In general they sound somewhat boring tasks, but they fit very well as a basis for a smallish programming exercise. 2. Think of _simple_ games, specially simple children or card games. Tic-tac-toe, solitaires, number/word games, various _simple_ card games, guessing games, etc. The difficulty here can be more varied -some are simpler, some may not appear so but turn out to be more complex than expected-, so take some care in choosing. 3. Think of some program you already use in your computer or phone or whatever and pick a **very** small part which looks simple enough. This is trickier, but the idea is picking something small enough. You can also use web applications or course. Say you use... mmm... reddit. The _redesign_ uses a "subreddit menu" in which you can mark some subreddits as favourites and it places them on a special list, [like so](https://i.imgur.com/8ZbWQUK.png). So you might think of an exercise where you have these two lists and you can mark some items in one and they are copied into the second list. It is a silly example, but you get the idea... And many of them work precisely because they are silly/small enough. Start with very small things and grow from there if you find them too easy. 4. There are many places out there filled with katas, exercises, problems... You just search around. There are literally hundreds of them. One special piece of advice: In all of this -solving exercises- the exercise itself doesn't really matter much at all. You _will_ find many exercises out there or make them up yourself and instantly think they're silly/boring/uninteresting... It doesn't matter. Of course a _fun_ exercise is, well, more fun, but you need to keep in mind that it is an exercise. That you're not solving it because you will use this professionally, because it will solve some world problem, because nobody has done it before, because you will win money with it, because... No. You're solving it just to learn solving problems. So try not discard any exercise just because you find it boring or silly.
Nope, I havent tried that yet. 
Well, that site is down: "An error occurred during a connection to [tylermcginnis.com](https://tylermcginnis.com). SSL received a record that exceeded the maximum permissible length. Error code: SSL\_ERROR\_RX\_RECORD\_TOO\_LONG " 
&gt; Sproingpoo I think I'm going to create a framework and call it that.
Faster? Because of async which never was really good in [ASP.NET](https://ASP.NET). Executing Server-Code for every little bit sucks, too. Long loading times and a massive overhead on the server. For every user that uses the website... what can be worse? As a SharePoint Dev/Designer I'm crawling almost everyday through a forest of Scripts, Stylesheets, SharePoint related files full of [ASP.NET](https://ASP.NET) stuff and so on. Even reading a Masterpage sucks balls. You never know what a DelegateControl does and where it starts and ends... you can just guess by cutting it out and trying again. Except you accidentally cut out the wrong piece of ASP-Shit, then you can't even access the Website anymore... thanks. But yes, this 1960-Opinion is a common opinion in a society of 1960-People. I mean for real... you don't even have a proper documentation nowadays. [https://docs.microsoft.com/en-us/dotnet/api/microsoft.sharepoint.webcontrols.aspmenu?view=sharepoint-server](https://docs.microsoft.com/en-us/dotnet/api/microsoft.sharepoint.webcontrols.aspmenu?view=sharepoint-server) \- thanks. Hmm... what does the property... "UseSeparateCss" do? [https://docs.microsoft.com/en-us/dotnet/api/microsoft.sharepoint.webcontrols.aspmenu.useseparatecss?view=sharepoint-server#Microsoft\_SharePoint\_WebControls\_AspMenu\_UseSeparateCSS](https://docs.microsoft.com/en-us/dotnet/api/microsoft.sharepoint.webcontrols.aspmenu.useseparatecss?view=sharepoint-server#Microsoft_SharePoint_WebControls_AspMenu_UseSeparateCSS) Oh let's look... NOTHING. How does this shit work? Where do I define the separate CSS file?
This is really weird. "Hooks" are a hacky way of giving a pure function some state (basically turning them into pseudo-objects). _If you already have an object or class, they aren't needed._ This project isn't just duplicating hooks, it's turning a full HTMLElement sub-class into a single function, then adding back in lost functionality through hooks. Sooooo weird.
I think it has more to do with devs having nothing better to do with their time than follow whatever whim the echo chamber comes up with next. Been working in front-end dev for 20 years and I've noticed there are two kinds of developers - one type leverages the tools available to build a lot of creative things, the other type isn't really creative at all and need the 'new, shiny' to feel like they are accomplishing something. They would rather chase the next shiny new thing than be building cool things with what's available and stable. 
Used [DragonBones](http://dragonbones.com) for a project last year. Worked quite well and was easy to integrate into an existing app we were using PIXI.js for.
Read this stackoverflow thread: [https://stackoverflow.com/questions/49922708/how-to-integrate-mxgraph-with-angular-4](https://stackoverflow.com/questions/49922708/how-to-integrate-mxgraph-with-angular-4). The answer works for angular 6 as well.
thanks, I'm checking it out right now. the price looks great! :)
Plenty of people are given to that, and don't actually try to make interesting things. However, they're kind of just going alone with the culture at large.
Looking forward to my royalties. B)
You'd probably be well served by something like [Quill](https://quilljs.com/) or [Prose](https://prosemirror.net/). Both are excellent WYSIWYG libraries. However, if you want something *super* simple you can use a sequence of regular expressions to convert text to HTML in JavaScript: var html = text.replace(/\r?\n/g, '&lt;br/&gt;').replace(/\t/g, '&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;').replace(/&lt;/g, '&amp;lt;'); Possibly even more clever, you can instruct an HTML DOM element to preserve whitespace (line breaks, tabs, etc.) so you don't need to convert the text at all. Just store the text as is, and add this CSS class: .supertext { white-space: pre-wrap; } Then apply it to your HTML element that contains the text: &lt;div class="supertext"&gt;This text will preserve tabs, line breaks and whitespace!&lt;/div&gt; One final note, if you use a plain `textarea` to capture your text input, the browser is going to capture tabs and shift the focus out of the element, rather than actually typing a hard tab. If you want the tab key to actually type a hard tab into the element, you need some special JavaScript magic on the element: https://jsfiddle.net/2wAzx/13/ Good luck! 
You forgot streams...
I'm going to a meetup tonight and this is the description: Longer Presentation(20 - 30min): Stop trying to make `await` a thing - Dan Levy JavaScript's `async`/`await` is, in retrospect, a mistake. Despite being one of the most popular features recently added to EcmaScript, `async/await` comes at the cost of diverging from Functional Programming principles/values. (Immutability, Function building-blocks, State machines, Single purpose.) Obviously you feel differently about that. Interesting to see other people's perspectives.
I have no idea why people decided that 'callback function' was necessary terminology. When I was learning JS, this was confusing to me because it made it sound as though it was a special type of function, or that something extraordinary happened to it to differentiate it from a normal function. All you have to do is say 'function reference' and everything is immediately 100% clear, well, except why people decided to come up with a separate name for the idea.
Probably advocating to use observables everywhere. If you can get a large dev team to fully grok observables and ramp in new resources on it as well, more power to you.
Huh probably on my end. but this is weird. Firefox is blocking the loading of your page saying it is insecure ... but in Chrome you're being blocked by our firewall marking your site as Alchohol/Tobacco/Drugs. So ¯\\\_(ツ)\_/¯
Okay, **now** I'm happy at least Dan himself recognizes that this is still a propos ALL ABOARD THE HYPE TRAIN REWRITE EVERYTHING WITH HOOKS I REPEAT THE HYPE TRAIN HAS ARRIVED. Jokes aside, a very well written article and a solid explanation for the ideas behind hooks. Hope they polish the implementation by the time hooks hit production-ready build and we will be good to go.
Ok this sounds good!
They should rename it to something more accurate
It'll be open-source. Enjoy your $0.
Hi, I'm a Redux maintainer. Any specific aspects you're struggling with? Happy to offer advice!
The article starts well but quickly ends up with some pretty strange and wrong statements. For example, there's no requirement for an SPA to use JWT, that's at best tangential to the topic. Regarding ux and speed, if you make use of IndexDb then you can literally browse around an app without making any API requests at all, making the app responsive in a way an MPA cannot be. Also I wouldn't build an e-commerce site as an SPA, that would be bad for SEO. But something like Facebook or Slack, absolutely. 
Wow! Thank you for this! It is both a learning exercise as well as hopefully (when it is finished) a portfolio piece that shows knowledge of some common js tech. I will get cracking on fixing this stuff as soon as I get home. Again, thanks!
Now I want to play Warning Forever again.
@tyler-mcginnis, how do you find time to put together so much content for your site? you're literally a machine. i've recently noticed that every time I search for a JS issue online, there is typically an article by you in the top few results. super impressive. keep it up man.
Are you talking about http://static.iohk.io/butterfly/ ? Or something else?
Yes
Read up on WebGL, I guess, but why would you want that? It's tacky as fuck and a waste of everything, IMO.
Just expressing the flow of state and actions into component props through connect in a way that is terse, expresses intent, and that my co-workers will accept. I like redux, don't get me wrong. I'm really excited to try hooks though.
Hey I totally agree with you. And I'm definitely not going because of this guy, though I am curious to what he has to say, as well as how people will rebut it. Just thought it was interesting.
async/await is like Haskell's [do notation], except limited to just promises, so what you quoted is a pretty confusing take. There isn't anything you could do with promises that you couldn't do with async/await. It's just an alternative syntax that creates implicit continuations instead of having to pass callbacks to `then()`. [do notation]: https://en.wikibooks.org/wiki/Haskell/do_notation
Someone should inform Haskell and Idris that they should remove do notation because it's not functional.
I think its not about thinking in JavaScript but decomposing the problem into logic for instance, what's a to-do list? A simple collection of things that you need and you can check what you have done already. So you need: 1) Data input 2) Data storage 3) Save data input state (checked/unchecked) Once you have that you start using the tools you have to build it, for instance JavaScript, it is what it is just a tool like a hammer, wood and nails to build a table, you need to have the blueprints to do it first before start nailing wood, its the same with programming, my advice would be just practice, solve simple problems like to-do lists, counters, timers then get more complicated things to do and eventually you'll be good at decomposing problems and building solutions. &amp;#x200B;
Sounds like the firewall where I work. If the domain uses a certain ssl security feature, I just see a blank page and or security error. If not, I get the red firewall page. 
There is a difference: callback functions won't go right up on the call stack. The engine will *come back to call the function:* 1. after the call stack has cleared, and 2. after going through a job queue (either the microtask queue or the callback/event queue). This is what gives us JavaScript form of asynchrony. Any function could be used as a callback function – so, there is no syntactic or identity distinction between the concept of a "function" and a "callback function" – the distinction is procedural. But the distinction is *central* to understanding the runtime behavior of JavaScript. So the distinction is critical. We need the term.
This is pretty much exactly what I was looking for, more focus on decomposing the problem then build around that. I often just skip right in after completing the DOM structure and styling, and have a play around and learn that way but it's cumbersome at times. I should really be stepping back, figuring out the functionality of each component and going from there. Thank you
reCAPTCHA was invented to allow Google to keep track of visitors on other websites. When you click 'are you human' you are actually telling Google who you are, so they can continue tracking you on that website. 
You don't deserve to be downvoted, but I think there's more than just those two types. There's always a balance between exercising your learning (even if you are learning do an old thing in a new way) and being creative (and just expressing yourself in a way that you can) and people can fall anywhere on that spectrum.
Fucking awesome camarada ✌️
So after a day of reading stuff, here's what I thought about decoupling dependencies in js. I can use dependency injection to class constructor or I can inject dependencies into the method arguments. That way, I can test what's happening inside the method. I've read this in a blog: "Write functions that take arguments and return a value based solely on those arguments" I think this is the most basic way of writing testable code in js. I just don't know how scalable it is. But for now, I'm happy using DI either constructor or method parameters. https://www.toptal.com/javascript/writing-testable-code-in-javascript 
That's it, essentially. html2canvas is set to take a picture of a div that includes the canvases the svgs are injected into. Kinda like: &lt;div&gt; &lt;div&gt; &lt;canvas&gt; &lt;/div&gt; &lt;div&gt; &lt;canvas&gt; &lt;/div&gt; &lt;/div&gt; And the html2canvas captures the highest div and everything within it.
Well 10 has been out for a while... even numbered major versions are stable.
It's _so_ close to that... The glaring difference is that it doesn't handle errors for you. This makes it very, very, bad, and not functional. I don't think that guy understands this, though.
Errors are propagated with async/await just like they are with promises; you don't need try-catch everywhere more than you'd need `Promise#catch()` everywhere.
I posit that [CSP channels](https://github.com/slikts/queueable#similarity-to-csp-channels) are the next evolutionary step after async/await and ES2018's async iteration.
Thank you for everything Tyler! 
Ohhh, so more like a quick proof-of-concept than a try-hard project. I think I'm with you now ;)
[removed]
Sure, it's not black-and-white, it's more of a spectrum, but the type that gets too excited about the new/shiny shit without really even needing it is also the type that likes to reinvent wheels. They create a lot of noise in the ecosystem without much signal. It makes the state of Front-end look chaotic, and makes working in the industry a bit problematic as u / Baryn pointed out above.
FreeCodeCamp.com is an instructional format. It can get you started. But if you are serious about it you need to work on self study. It's pretty much a requirement to be successful, but definitely a skill you can learn.
Any chance this talk will be recorded?
&gt; Of course when you dislike imperative programming you'll dislike async/await functions. This makes no sense. It should be the other way around.
I would imagine so but not sure. I'll try and get some info if it is and report back
Change jobs
Serious question : why do you use dependency injection? I spent 12 years as a Java developer, and struggled with these questions myself when using javascript. I realized that the only reason I used DI was for the code to be testable. In javascript, you can have testable code workout dependency injection. If your code uses require like `const foo = require('foo')` you can easily mock the foo module by using a library like rewire. 
Nothing's stopping people from continuing to use promises if that's what they desire \*shrug\*
Noted with thanks
Noted with thanks 
Udemy offers online courses for many topics and they are usually on sale for a little bit of nothing. Not to sway you away from Javascript... But if you are a Service Desk person have you thought of focusing on Powershell first? Help you build a basic understanding first and very useful for your position. I started learning JS after powershell it and the transition was pretty smooth.
Async/await seems to appeal a lot to those who prefer an imperative style, which is fine. You're right, you can \`f().catch()\` an async function, but then you're using promise style chaining notation, rather than some \`const foo = await f()... do something with foo\`. If you want to use the "nice" \`const foo = await ()\` then you have to wrap it in a try catch to handle the error.
 Excellent free resource. https://www.w3schools.com/js/js_intro.asp
It's a callback function because it's a function that's used to call back your logic when ready. https://en.wikipedia.org/wiki/Callback_(computer_programming) The word is describing a usage pattern and is completely correct. The fact that it confused you is probably an issue with whatever learning material you were using, not with the word or its usage. 
Think big, then think little; that is, think about the big picture first, then break it down into the smallest problems possible. A big problem is just a composition of smaller problems. I'd start by putting myself into the mindset of the end-user. Who is this for? Just for you? Are other people using it? What does this to-do list look like as an end product? I would probably even draw pictures of the UI. Make notes of what it does, and what it looks like as it does things. Once I have a clear picture of that, I think about tools and features I need to use to make this happen: Languages, frameworks, databases, servers, APIs, security and authentication, etc. Break each part into the smallest of problems. Then start, and don't let the big picture scare you away. One small problem at a time, and it will come together.
The biggest tip I can offer: follow bunny trails and learn one small concept at a time. It will take time, so just be consistent, and do research on any small part that interests you. As you research one thing (How do functions work? What are first-class functions? What is 'this' and how does it work?), you will see other concepts referenced that you don't understand. Stop and go read about that. Then you might find some other bunny trail. Go follow it, if it interests you. At some point, go back to that original question you were researching. Read more about it. Then follow more bunny trails. Then go back. Repeat. As you do, play around with things. Write some functions. Open up the console on this Web page (or any Web page) in your browser, and see how it works. Try weird things out, but try to guess what will happen ahead of time. Then go see if you're right. Most importantly, try to understand WHY it does what you expected or didn't expect it to do. Over time, little by little, you will have 'aha' moments, and it will come together. But it takes personal interest + consistent playing around.
I'm saying that's a weird way of phrasing it in general. What's wrong with just saying that you are passing a function reference, or a reference to a function? I intuitively understood as a beginner that this is what I was doing when passing a function as a parameter, but then became confused by the new term used for something that did not seem unusual to me.
I'm curious, did you understand intuitively what was going on (that you were just passing a reference to a function) and then second-guess yourself due to the term? Or was your understanding different? JavaScript was also my first language, and I had not thought anything of the fact that I was making a function one of the arguments to another function. I'm aware now that this was not always a common programming technique.
Did I say it was incorrect? I said it was a confusing term, because it implies something special about the function when the only thing that is special is that you are passing it into another function.
Async/await is a great tool... That I use mostly to write unit tests. 
Could you explain how async/await are not functional programming? From my shallow understanding of functional programming, you have immutable data and avoid global variables. I don't see how async/await would violate either of these.
The thing with those tutorials is they've thought out designs for how their system is going to work ahead of time - so from the viewers prospective it might be a blur of tasks rattled off the top of the presenter's head - but in reality it's all thought up ahead of time. Actually, tangent - but I think it would be really interesting to see a tutorial without any sort of plan where buddy just builds from absolutely nothing into something - warts and all. Then adds some random feature and shows how "fun" (error-prone) refactoring can javascript can be if you never approached it with a plan in the first place.... this sort of thing would be a far more realistic introduction to real-world development than a tutorial. Anyway, in my eyes the first thing I think of is the data structure - basically database tables, and stored procedures and views that provide an interface into the data. From there, I'll figure out what the API endpoints will look like, and start to implement them - for the most part this is just validating and sending queries to the database and piping the result back to the client. From there it's more interesting, the front-end. If I'm working with a designer or ... just designs in general, I'll sketch out what the HTML structure needs to be, identify interaction points and what each interaction point does. I'm usually doing this in my head.... then, I dunno... magic happens, and voilla functional app.
Draw diagrams, if you can’t draw it, you haven’t thought enough yet. Then the diagrams are your program documentation.
Hey, man. I found your post doing a search. Would you mind sharing the resources you used to "get good" at Angular? I'm taking a course on udemy. And did some of the Tutorials on the official page. But there are still some holes in my knowledge. 
So basically... we have a problem with .. I know! We’ll use React! Now we have two problems. I know, we’ll use Redux! Now we have 3 problems... I know! We’ll use hooks, to be continued...
&gt; New! Shiny! is the main problem in web development these ~~days~~ years. FTFY. I wish it was only a matter of days. This cancer is never ending.
You work on your own projects to grow your skill. Keep them challenging. This will, at the same time, reinforce what you’re learning about the language.
I do have some experience with ruby on rails. So it's helping. Ok, cool Thanks a lot. I'll do the docs. 
Hosting Tip: Take a look at hosting your API out of an AWS S3 bucket... super cheap way of hosting an angular site.
I've given plenty of meaningful reasons and you just cited them. I already said there is no "knock out blow" reason to use one library over another. Just as no one goes around arguing with people about pepsi vs coca-cola because there will always be defenders of one vs the other because they are near-competitors that have survived the test of time. \&gt; is an opinion, so that statement doesn't actually add any value. This is where you are making actual mistakes in logic. Opinions do add value. My experience and effort in these javascript frameworks matter. Would someone else come by and say "no I disagree" sure, but you have no right to act like I'm not allowed to state my opinion on frameworks. If we had a knock-out blow, I wouldn't have to be typing anything, because people would simply gravitate toward Aurelia naturally. \&gt; I'm just asking for actual reasons and not a dozen repititions of it being "written better" with no reasons *why* you think that. I have stated the reasoning. You keep repeating that I haven't, but I have. You just refuse to acknowledge it. The MVC model is just better and using natural ECMAScript classes to its full potential is better than basically creating quick objects on the fly for the view and then later defining the functionality via a component. To me it's backwards, to Vue devs it's totally fine. As I said there is subjective line here, but before anyone can even say that you already reject all opinions, so how can you learn? There are no scientific observable properties that can be pit against one another to make an objective "X is superior than Y" argument. There are only subjective opinions that you openly stated you don't value. If opinions don't matter and milliseconds of speed doesn't make a significant difference, then what do you want here? I already told you I'm not doing a line-by-line feature-by-feature comparison article. Why would I spend that time doing so? &amp;#x200B;
Oh. Thanks! I didn't even know that was possible.
I thought the project was a wrapper around existing new shiny React hooks. Then I saw there is no React dependency. What the hell is going on? Did Abramov, aka the Taylor Swift of React fanbois, just discover a new subatomic creature in the field of particle physics and now everyone is copying it? (Let alone the fact that it was not Abramov who came up with the Hook pattern, he also stole the Redux pattern from Elm and made it look like he invented it) Seriously, if this project is not a wrapper for React hooks, then why couldn't the author write it 10 days ago? The hook pattern was even out there for a long time. This is why frontend is such a chaos.
It's a pretty ancient technique and not just in academic languages. C has used callbacks since forever. In PHP you could pass the name of a function (as a string) to another function. The typical use case was for sorting so you could supply your own comparison function. Then languages like Java and C# came along which removed the ability to create plain functions (!) so people got into the habit of constructing entire objects which would inherit from specific classes, overriding specific methods. All of this ceremony was required to achieve the same thing as a callback.
The only thing not "functional" about it is that Promises are not referentially transparent (Since the act of creating on starts execution immediately). Other than that, Async/await is just syntactic sugar for promises. The runtime can do whatever it wants for the underlying implementation, but semantically there's no real difference between using it or calling .then() directly. JavaScript also supports generators (yield syntax) which is much lower level, but among other things lets you build referentially transparent do-notation style code for any* monad. *Well not quite any, it can only handle monads that execute each continuation at most once - which means list is out. But you probably wouldn't use yield notation for that anyway. 
Observables are not a replacement for promises. They do different things. In particular, a promise guarantees at most one value. Observables don't. 
&gt;If you want to use the "nice" `const foo = await ()` then you have to wrap it in a try catch to handle the error. No you don't. They propagate the same way they do promises. Async/Await is just sugar over promises, and Async functions just return promises. 
A lot of node libs did dependency injection with require: const foo = require('foo')(dependency) But you could do it with modern imports as well: import Foo from 'foo' const foo = Foo(dependency) Where `dependency` can be... anything, really. If you're using Typescript you just need to make sure your types are compatible; you don't need to inherit things from the same base class/interface. You don't need to use classes or inheritance at all.
Such a good explanation. Super clear analogies. Thank you @tyler-mcginnis
Very nice tutorial, sir.
Try searching for the term webhook with Gmail API. This will allow your app to be alerted by Gmail when an event occurs like a new email and then you can filter by sender or any other data the API gives back. 
Got a git repo?
My guess is you’re suffering from tutorialitis. It’s when you spend too much time doing tutorials and not enough time breaking shit. Be bold, don’t plan, just build some shitty little thing and do it with no resources other than the mdn and stackoverflow. Once you’re done, leave it alone and go build another shitty thing. Do this until you have a few shitty things and then go look at them and you’ll see that they started getting better. You don’t learn the right way by having it spoon fed to you. You learn the right way by eliminating the wrong ways, and the only way to do that is experience. If you take anything from this post at all: two years is a long time. You’re good enough that you should never do another tutorial again. They do more harm than good in my opinion. 
Lots of little projects. Try to add one new technology or technique to each one, like functional style, immutable style, stateless rendering, recursion, unit testing, etc.
LOL was going to say the same thing. Not sure how async/await are in any way opposed to functional programming. Side effects exist in Haskell, too.
https://developers.google.com/gmail/api/guides/push
I actually struggled to understand what it was because of the way it was presented to me.It was made a big deal that it was a "callback" and I thought it was doing something magical and I was missing something - along with the fact the example I learned used callback as the callback function -as well as the callback argument (I had JUST started learning) until someone just told me to ignore that other shit and said exactly what you said - passing a function as reference. Once someone told me that and showed me a non confusing example it was just like..."so...why is that special - shouldn't you be able to do that?" lol 
So many libraries to choose Overwhelming come the blues The one you first thought to inspect Will not bring your code to spec Why you do this to yourself Put that lib back on a shelf Lest you think it’s worth importing So much filler that it’s toting No, you’ll do the work yourself It just cannot be that hard Now bring tears back to your eyes As your time loss you’ll despise 
Google for “mapbox gl clustering”. Format your data as geojson and mapbox do the heavy lifting. 
I've migrated Angular 1.x apps all the time. Reject both of them. I've seen major projects run into issues with Vue and React (and they eventually resolved those issues so all these frameworks are "flavor") but if you're going to run into issues with these major frameworks, why not just adopt something that is far superior, better written (according to side-by-side code comparisons which is subjective so again it's just an opinion), competitive in speed, and the only setback is a smaller community? **Choose Aurelia (not because it's the "best framework" there is no such thing; all the 4 major frameworks are just as competitive).** We're deploying Aurelia apps next to React apps (that were once upgraded from Angular 1.x). No one even considers Angular 2+. Aurelia is a split from Google Engineers who did not like the way Angular 2 was going so they left and created Aurelia and that's why it's so well-designed. As far as speed, Aurelia is one of the fastest in benchmarks. The other frameworks are not far behind either so you won't notice a major difference unless you adopted Angular 1.x (which is slower). I've studied all these frameworks side-by-side and built apps in all of them. If you're a fan of "view-only" designs and just pushing in html, you should go for React or Vue. But if you want a more angular-like Model-based design, you should use Aurelia. Again these are like LINUX FLAVORS so people will argue subjectively about "what they prefer" but this isn't a team sport and you should just check out Aurelia in addition to looking at Vue and React. The main question has been lately: Vue.js vs ReactJs (rather than angular), and well, when you compare Vue to Aurelia, you find some limitations with Vue. ReactJS style is very unique to itself and there are many who like it and many who don't. Aurelia uses classes and separates out the Html into files, it's just more organized. **The "experience" problem:** If you are trying to hire people based on "experience with framework X"; don't do that. Hire good Javascript, ECMAScript devs, and they should be able to figure out any framework. You may not find ppl with "Aurelia" experience, that's okay. Find people with any javascript framework experience. Aurelia is a smaller community, but you can talk in their discourse or StackOverflow for questions and people respond. There are already plenty of components built-in and available including a nice navigation/routing system. There is no limit, unless you have to support say IE 6/7 or something. You can deploy with WebPack, SystemJS, RequireJS, or its built-in bundler. It has Au-cli (a little console thing that lets you setup quickly). It has typescript if you don't like ES/js.
Try learning another language and doing console apps. Programming might be easier to think about when you can do it for a while without requiring html/dom. I highly recommend dot net core (C#)
You learn by doing. Stop "studying" and start making things.
I think it's incredibly shortsighted and stupid, and trying too hard to be ruby-like.
I use it for all my projects. It looks nice and clean and the syntax doesn’t interfere with anything I would write anyway. It was hard to get used to for a bit but it looks right to me now.
Can you show a code sample? I've checked mdn and a few blogs and I'm not seeing anything other than try catch.
This is extremely useful, thanks Google. I wonder: would it be viable to pop a reCAPTCHA v2 when v3 produces a low score? Would reCAPTCHA v2 know to pop the full CAPTCHA if it's only being invoked in suspicious situations, and thus doesn't have the normal legit traffic to compare to?
I much prefer semicolons (less can go wrong). Unrelatedly, I wish they had chosen a different name. 
Start as simple as possible, solve the problem using the console as your UI and build up from there. &amp;#x200B; A single statement can be considered a solution to a TODO list... window.todo = new Array() &amp;#x200B; The console can be your UI for both input and output... todo.push( "a todo list is a list of todo's (strings)" ) todo.push( "list can contain zero or more todo's" ) todo.push( "a new todo can be added to a list" ) todo.push( "an existing todo can be removed from a list" ) let index = todo.indexOf( "an existing todo can be removed from a list" ) todo.splice( index, 1 ) console.log( todo ) &amp;#x200B; &amp;#x200B; &amp;#x200B;
How do you propose handling errors without try/catch?
What do you mean by “component”? Are you referring to React components? If so, you can make your props required, so they’d need to be explicitly provided
I could see it confusing people without a computer science background. But then again if you're working as a developer you probably should study up on that.
When I teach development, I always teach that a developer should be explicit with there code. Say what you mean, spell it out, name things descriptively, and terminate statements explicitly. Automatic semicolon insertion is not explicit. It is implicit. "The semicolon is implied". If your code lacks semicolons, I won't know if this line will carry over to the next one without checking the next line. I have to think. It is not immediately clear. Coding implicitly encourages shortcuts and produces code which isn't clear about it's intentions. Be clear. Say what you mean. Be explicit.
I just added `'semi': ['error', 'always']` to my .eslintrc and ran the `lint:fix` task. I definitely like explicit clarity in my code.
Heyletsjustgetridofallsymbolsitsnotlikethosehelp usmorethanitdoesthemachinewhatcouldgowrongwhenyouhavenothingtovisuallylatchontotoquicklyreadandgrokcontextimeanwhyusethespecialpartofourbrainthatcaninstantlyidentifygrammaticalstructureswhenwecanjusttypeonelesscharacternothatwoulsbedumb
My team has used it for a couple years now. It's totally possible, and *does* look cleaner imo. As long as you're aware of the two cases where you still need to use them, it's pretty nice to be able to leave them out in the other 99.999% of your code. Case 1: IIFEs Need one before the IIFE so js doesn't think you're trying to call the previous statement as a function ``` const foo = 'bar' // no semicolon // need one here though ;(() =&gt; { //... })() ``` Case 2: inline arrays Similarly to how IIFEs appear as if you're trying to call the previous statement as a function, brackets make it look like you're trying to access properties of an object ``` const foo = 'bar' // no semicolon // need one here ;[1, 2, 3].forEach(num =&gt; { //... }) ```
Someone is missing the point of a subreddit. A """"dev""" who doesn't know how internet works. Fascinating.
I used Vue a bit, didn't make my life easier a single bit. All I had to do in 8 hours straight was solve random bugs and complicated configurations open source "developers" put togheter for making up a clumsy and clunky environment to run the such called "framework"
Check out how Shopify uses their product API. They default to sending 50 objects with a param that lets you get up to 250 at once. You can also query the total amount products. Therefore: (product_count_per_page_param / total_projects = total_pages). 
Many thing is js is implicit. So. 
I have no problem with the style, really, just that some ass-hat is calling it "standard". 
JavaScript’s automatic semicolon insertion is an error correction mechanism. In my opinion, omitting semicolons is equivalent to relying on a side effect of how a compiler fails to compile malformed code in a compiled language. Not only is it technically wrong, but you risk new language syntax or code refactoring breaking your application.
no semicolons makes my heart happy. semicolons make my brain happy its programming, go with the brain. leave the whimsies of the heart to romance
I mostly write JS when I make my personal Vue.js front-ends, using Vue CLI 3 and the default linter which means no semicolons. I got quite used to it and I don't see any disadvantages to it. Though I'm currently employed as a Node.js dev and I gotta use semicolons everywhere (at work). Again, I don't mind - the linter always alerts/corrects me and both styles are okay.
Hi, I'm glad you reached out! I too faced the same predicament and found myself constantly confused and stuck. My "aha!" moment was when i was well into doing my 20th algorithm where i realized not only was i learning, but also able to break down problems and become a better programmer. In layman's terms: Essentially, you are an engineer at a construction site, and you're tasked with building a house. Now, you know there's a way to build it since people have built it before. You know that once you start googling it, you can also build it, but you just don't know how to start on your own. Sure, google will help to a certain extent, but what about on the fly? Do you know that you need to use a hammer + nail to put in 1 nail in the wall or a hammer + nail with a loop to put in several nails in the wall? How do you even know you need a hammer and a nail?? It's tough and this is something I faced as I began. Now i'm well into my programming journey, while still learning, I have a few things to share. The best answer I can give you is to start practicing algorithms. Find questions online to solve and begin googling ways to solve small parts of the problem. Algorithm questions online are a great place to start. Look at other people's solution, then trying to figure out how you would've applied it. Over time, try to avoid using other people's solution and give it a go yourself. Google if you have it. Learn the methods and you'll eventually realize that you learned a lot of libraries, methods, etc Eventually you'll come to terms that now you understand the building blocks of solving problems. Knowing what .toUpperString, .split, .substring, etc is great, but being able to apply it and knowing when you need to apply it is greater! &amp;#x200B; Here's most of the methods "tools" you'll use to create something, without installing outside libraries to perform functions: [https://www.tutorialspoint.com/javascript/javascript\_builtin\_functions.htm](https://www.tutorialspoint.com/javascript/javascript_builtin_functions.htm) You should be able to solve most algorithms utilizing the methods in the link above. &amp;#x200B; Here's a way to become a better developer and prepare for interviews: [https://leetcode.com/](https://leetcode.com/) I would recommend you copy the question into an IDE and do it yourself. Don't worry about solving it in the browser.
I mix promise features with `async`/`await`; there are time I want a method to return `false` or `null` when it fails, I'll mix a `.catch()` in. e.g. `let result = await asyncFn().catch(() =&gt; false);` This is an alternative to extensively wrapping code in `try`/`catch` blocks just to fall back to an "empty" value. Other times I may be doing thing like mapping values through an `async` function, in that case I'd do something like: let mappedPromises = valuesArray.map( (value) =&gt; (await asyncFn()) ); let results = await Promise.all(mappedPromises); The code above could also be written as something like: let results = await Promise.all( valuesArray.map( (value) =&gt; (await asyncFn()) ) ); I've found `async`/`await` to be incredibly useful and allow for much simpler and more legible code.
What the guys mean is that you don't have to handle the errors locally. You can just let them propagate up the calling chain and handle them somewhere else. Besides, how would you handle errors without try/catch? It's literally made for that.
I wish it was more functional and allowed you to declare these outaide of the component so that you can easier separate out the view layer without wrappers
The ones mentioned in the article.
You want to read up on the `this` keyword. It is one of the weirder concepts pf JavaScript. https://medium.com/@NinjaJavaScript/javascript-this-keyword-explained-simply-e90762d4945d In your limitSellOrder function, `this` does not refer to the `algo` object but probably to the global object. You can verify this by not calling this.quantity() but logging this to the console or debugging your code and see what `this` is really referring to at the time of your this.quantity() evocation.
Thank you!
This "standard" style looks like a less well-reasoned and less comprehensive version of the [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript#airbnb-javascript-style-guide-)
Yep, I’ll do that! Thank you very much sir!
For what it's worth, this is actually comparing AngularJS and React (at least from what I can tell), and the word "detailed" isn't particularly true either...
+1 for the site name
You have a spelling mistake at chararacter position 278.
lol
They're not side-effects if the effects are explicitly modeled in the language by "effectful values", which can be substituted and used to perform equational reasoning. I recommend [this talk] about it. [this talk]: https://www.youtube.com/watch?v=GZRL5Z40w60
Can someone explain to me why the function that we actually want to run synchronously has to be specified as asynchronous?
Semicolons suffer the same issue as not having trailing commas. For example: ```js object .method() .method2(); ``` Now if I need to chain `method3` I need to remove the semicolon on the last line which increases the diff and makes it more cumbersome to work with. Another thing to consider is that linters like ESLint and Prettier or compilers like TypeScript or Flow will catch all ASI issues.
Because people don't understand classes all of a sudden? 🤔
&gt; I don't know how to debug it since my console is showing nothing Put a breakpoint in, reload the page, and step through the code https://javascript.info/debugging-chrome
Flash is old and deprecated, so there's really no point learning to use it now. You should be able to do everything in JavaScript now
flash is dead, use javascript.
I don't think lazy evaluation can make something referentially transparent if it isn't already.
On Reddit if you can to notify the user it's not @ it's \/u\/&lt;username&gt;, like /u/ajschmidt8. Though top level replies to a thread typically notify the poster.
While your question may be relevant to you, it's not particularly relevant to the rest of the subreddit and honestly belongs much better in /r/LearnJavascript.
But the spelling mistake is still there!
Not sure if it's that sudden, though. Classes in JavaScript are synthetic suger over the traditional prototypal inheritance/chain. They differ from classes in other languages. Whether that's required knowledge for the majority of web developers, I'm not sure, but "understanding classes" could be complex. Also, this tweet was quite interesting (found it on Dan Abramov's latest Medium blog post, "Making Sense of React Hooks"): https://twitter.com/jamiebuilds/status/1056015484364087297 Hooks could impact bundle size in large applications making use of Class and transpiling to a lower ES version, for example. 
Flash is not supported by mobile devices, does not get proper updates by Adobe any more and requires a lot of extra interaction for users to enable in modern browsers. It's a complete waste of time spending time.
Can't say that I understand the problem you described, but as a matter of preference, I just found classes a lot more straightforward, even if I have to do something extra to make them work. Separating logic into effect and using it somewhere else through the weird hooks (not to mention you may have to read state in props in both places) just seems like a step back from the original idea. It's also weird that "bad" code examples in the article are actually bad. Which means they could be refactored without any hooks in the first place.
Seems like a very clunky solution that will also be regretted in a year.
If you want to somehow _"go further"_, instead of Flash -which is a dead path- take a look at some of the [JavaScript gaming frameworks and engines](https://duckduckgo.com/?q=javascript+game+engine). You may or may not end up actually _using_ them; that's up to you. But you should take a look at them. some of the "bigger" ones, such as [Phaser](https://phaser.io/), to mention [but one](https://html5gameengine.com/), can give you a hint about _what_ Flash would provide. [This](https://flashvhtml.com/) may also give you interesting -but rough and slightly outdated- information. (hint: the thing about Flash was mostly the _tool_ -which back then was the _only_ tool-, and performance and compatibility -which nowadays is no longer true-) Other, smaller engines, may give you hints about things you may or may not be missing. but not by using them, but by looking at their code and their functionalities. Working directly with the Canvas API (are you using 2D or 3D?) is _fine_, but most of the work is not about using the canvas, but about everything else you build around in your game.
I believe you mean "syntactic sugar"
Hah -- yes, indeed. Thanks.
Same here, it's a bit too magical / unreadable for my liking.
Yeah they have page counts, but I don't know of a way of looping through 100 - 150 pages of JSON and at the same time collecting it all into one variable so that I can filter through it. Because right now, I could make fetch all the pages separately and then filter through each one individually. I'm trying to use a for loop to a max of 150 times. But the part i'm unfamiliar with is what to do each time it fetches page = x
Flash is dead but JS is not as good as flash of 10 years ago. Fundamentally broken shitty language. 
Look at the .within() query in leaflet api
Yeah it might be ESRI Json notation and in that case just use esri-leaflet.js
Hug of death?
In terms of differences, at this point, it's mostly that Flash games are/were easier to make. It had dedicated tooling and pulling in and using assets was a lot easier than it currently is in JavaScript. But, JavaScript (and DOM) have just about reached feature parity with Flash now, so in terms of capability, there's nothing you can do in Flash that you can't do today with HTML/JS in a modern browser. Ultimately, you're not missing out on anything, and as others have pointed out, Flash is a dead end at this point, Adobe officially announced the [EOL of Flash, stopping support in 2020](https://theblog.adobe.com/adobe-flash-update/). What you may find interesting, though, is that the EOL only applies to the Flash runtime, and not the tooling. The tooling, formerly known as Flash Pro, now lives on as [Adobe Animate](https://www.adobe.com/products/animate.html) which targets both the old Flash format as well as HTML/JS which you may find useful in making your games.
From the [docs](https://jestjs.io/docs/en/api#describeeachtable-name-fn-timeout): ```describe(name, fn)``` creates a block that groups together several related tests in one "test suite". ```it```(or ```test```) is a unit test itself. Usually you name it something like ```should do something```so that it reads as a natural sentence. So you would group multiple ```it```s under one ```describe```. This gives you a bunch of new options, if you want to only run a group of tests, you can write ```describe.only``` or ```it.only``` for a single test. You can add .skip instead of .only to skip a bunch of tests. Finally you can add beforeEach/afterEach hooks to run before or after each test in a describe block. 
Maybe the docs can enlighten you. 1. They [explicitly mention](https://jestjs.io/docs/en/api.html#testname-fn-timeout) that `it` is simply an _alias_ for `test` i.e. `it` and `test` _are_ the same thing, just different ways to write it. 2. [They also explain](https://jestjs.io/docs/en/api#describename-fn) that `describe` "creates a block that groups together several related tests in one "test suite" i.e. it's for organization: when you have several tests that, say, check _different actions_ on the same _thing_, you group them together. None of these things is particular to Jest, but a common way to write tests.
Which one did you chose? How is it going?
... then just do `data =&gt; apiData[i - 1] = data;`? 
What about `apiData.push(data)`? A better way, tho, would be to wrap the array of promises in `Promise.all()`
&gt; Can't say that I understand the problem you described Look at this, you'll immediately understand: https://twitter.com/threepointone/status/1056594421079261185 The only difference is the prior to hooks a component is an object whose lifecycles call your tasks, which will almost always be dispersed. With hooks a component is a function with lifecycles that you're allowed to "hook" into. So your tasks are grouped and can be composed or re-used. If you wanted re-use previously you'd use higher-order-components or, in other frameworks, mixins - which hooks can both replace entirely.
Yes, things named differently have different meanings.
They are completely different things, but can be used to build state management solutions akin to Redux. Sorry you got downvoted for asking an honest question.
I think you may not fully understand how hooks work, because when using hooks, you're explicitly not reading state from props anymore. Any relevant state would be returned by the hook function instead. This makes it very easy to track where the state is coming from, and separates it cleanly from the props which are always passed in by the parent component. To give you an example that builds on the concerns I mentioned in the post above, let's see you're dealing with user idleness and have to fetch some data. You would then need a class with lifecycle methods like this: ```js class Example extends React.Component { constructor(props) { super(props); this.state = { isIdle: ifvisible().now(), someData: null, }; this._onBlur = this._onBlur.bind(this); this._onWakeup = this._onWakeup.bind(this); } } componentDidMount() { ifvisible.on('blur', this._onBlur); ifvisible.on('wakeup', this._onWakeup); this.source = axios.CancelToken.source(); axios.get(SOME_URL, { cancelToken: this.source.token }) .then(response =&gt; this.setState({ someData: response })) .finally(() =&gt; this.source = null); } componentWillUnmount() { ifvisible.off('blur', this._onBlur); ifvisible.off('wakeup', this._onWakeup); if (this.source) { this.source.cancel(); } } render() { // Use this.state.isIdle and this.state.someData here... } _onBlur() { this.setState({ isIdle: true }); } _onWakeup() { this.setState({ isIdle: false }); } } ``` But, the same thing with hooks becomes: ```js function useIdle() { const [isIdle, setIdle] = useState(ifvisible().now()); useEffect(() =&gt; { const onBlur = () =&gt; setIdle(true); const onWakeup = () =&gt; setIdle(false); ifvisible.on('blur', onBlur); ifvisible.on('wakeup', onWakeup); return () =&gt; { ifvisible.off('blur', onBlur); ifvisible.off('wakeup', onWakeup); }; }); return isIdle; } function useSomeData() { const [someData, setData] = useState(null); useEffect(() =&gt; { let source = axios.CancelToken.source(); axios.get(SOME_URL, { cancelToken: source.token }) .then(response =&gt; setData({ someData: response })) .finally(() =&gt; source = null); return () =&gt; { if (source) { source.cancel(); } }; }); return someData; } function Example(props) { const isIdle = useIdle(); const someData = useSomeData(); // Use isIdle and someData here... } ``` As you can see, the version with hooks has the logical concerns of dealing with idleness and fetching data cleanly separated into their own functions, without needing lifecycles that deal with both. Also the hooks are now trivially reusable in other components. And as you see, the incoming props are still clearly separated from the state provided by the hooks.
They are complimentary. It's likely future Redux versions could be used using a `useRedux()` hook.
Having worked in multiple React codebases, there have always been numerous ways to do things. Some teams go hard into HOCs, some into render props, some just manually pass data everywhere needed, some use context (old and new). Some use antipatterns like inheriting from a custom base class, and I'm sure some are still using mixins. This is new, and a new API is a higher investment than a new pattern, but I'm very excited for the new ways solve problems this introduces. Beyond simplifying existing components, being bale to share stateful logic and context is going to be really powerful.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/xk3zeaz.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
Hooks should just be a bit more explicit, like a function with hooks that wraps a react component.
That depends on your project and test sizes, but I would recommend putting it inside a describe. See /u/Charles_Stover example below what that might look like. In my project we even have nested ```describe```s for a more high-level abstraction, e.g. classes vs methods.
Nope. There's some pretty solid game engines/frameworks out there for canvas &amp; webgl. If you want to roll your own thing on top of the canvas API, that's also a fun way to go. This game is html5: http://cross-code.com/en/home and it has a lot of animation and drawing going on. If you find you're having frame drops, be wary of dynamic allocation. Meaning try to re-use objects (update their properties) instead of generating new ones. This also goes for arrays. If you keep an array of 4 points for an enemy path for example, and want to update that path every 30 seconds, change the values inside the array, dont make a new one. From there the drawing can be optimized by using webgl, and doing batching.
OK. Thank you very much.
A huge difference in what? Your tests are verbs. You are testing that _verb_ is happening. You should be describing what is doing that verb. Your describe can be as vague as you want it to be, but you should still have one. `describe('my application', ...)`, if you can't think of an actual noun for your verbs. describe('my application', () =&gt; { test('should not crash', () =&gt; {}); }); Does it really make sense to say "should not crash" by itself? _What_ should not crash? Write a sentence for what you are testing. "[Thing] [does]." Put the noun in the describe, put the rest of the sentence in the test.
Hold your horses, its still fresh give it a chance
Make your own, fam.