Ah yes - sounds like what the Google PWA docs would say!
https://github.com/caldwell/renderjson
I started with Vue because of its gentler learning curve. This gets me familiar with how front-end library works, stuff like component, lifecycle and routing. Once I'm comfortable, I switched to React because I personally loved JSX and Redux. and the ecosystem is way bigger than Vue's you can almost find anything you need for your project.
And these are offered with support back to IE8. OP should please take some time to explore [standard browser document model](https://developer.mozilla.org/en-US/docs/Web/API/Document) before making another complaint about JavaScript. Also OP, please try to keep in mind that `window` and `document` are not JavaScript. You won't find them in Node, for example, just as you won't fine `process` in your browser console. JS is a language, not a platform.
Here's [the annex](https://tc39.github.io/ecma262/#sec-additions-and-changes-that-introduce-incompatibilities-with-prior-editions) that I referred to above. When you read it, you'll find `returnIfAbrupt` is mostly gone, replaced by a short-hand syntax. Make sure to read [clause 5](https://tc39.github.io/ecma262/#sec-notational-conventions) first!
Elon Musk
Yep, Kyle Simpson is great, you started the the right guy. 
absolute classic: https://youmightnotneedjquery.com
Heard of setTimeout(f, 0) ?
Sigh... yea, just wishful thinking, I guess.
The strategies you listed there are all the ways you'd do it with modern javascript and libraries. Tree shaking relies on a modular structure and modern es6 import/export, which you most likely won't have. Service worker can do some cool stuff, but probably in your case their own real purpose would be caching, which you could instead do with...caching. You're in old school land, you most likely want old school simple best practices. 1. Minify/uglify, your js. At this point you could concatenate all your js into a single file, or inline your js into your html depending how page specific and large your code is. Your build process can do this. 2. Make sure you're leveraging caching for your js files. Have a simple build process that appends a unique ID to the filename when you release a new version to bust the cache. 3. See if you can remove any libraries. Can you use native forEach and map methods and remove lodash? Is your jQuery use small enough to just use document.selectElementById? 4. See if you can move your libraries to modern versions that use es6 import/export. If you can do this, you can import only the parts of the library you use, in which case tree-shaking becomes an option for you. 5. For libraries you need, consider including them from a cdn, often times these files will already be cached on your users computer. 6. Eliminate render-blocking JS if possible, if you can do this it won't really matter if your js files take a little bit, as the page will still render fast. https://developers.google.com/speed/docs/insights/BlockingJS
I always felt that recursion without proper pattern matching is weak. That plus the fact JS lacks TCO, lets hope they get it included soon. 
Is it pronounced redux-x or redux-ten? 
Networking. 
ReactJS
Or just use Fetch everywhere. `new XMLHttpRequest` is probably not something that should be taught as the vanilla JS method of choice in 2018.
Daniel Shiffman! He has a YouTube channel called the coding train and he also is a leading developer for processing! He is brilliant!
* /r/learnjavascript * sounds like you need to use .filter and .map a few times
Hey buddy, your 5th comment was an eye opener. I was clicking around that and ended up doing a quick 30 minute course on CPR (critical path rendering). Learned heaps! Also, I cracked up when I read `old school land`. That should be an official js term. ;) Thanks so much! What I've realised is that when a document loads, a lot of things happen in the background: a) Requesting html b) Requesting critical resources (js / css) c) Parsing css files to create a CSSOM. d) Running initial JS for the page e) Merge CSSOM and JS dom changes f) Painting the page for the first time I also read up that onload is not the same as DOMContentLoaded. I guess to put it short, I was after a way for users to load as minimal resources required to load the page. I've also played around with Service Workers for the whole day. That too is interesting because you can return either cached or freshly-fetched resources. rel="preload" to prepare assets that are immediately required... Then there's async... which seems to be a must with script/defer tags these days. I guess I was just confused as Webpack seems to be thrown everywhere on the internet. It is useful for static sites many say, and I've attempted to use it too by lazy-loading bundles using query selectors. But then again, there's rollup for libraries... I'm still continuing my quest. Appreciate your comment!
oh, hey that would be a much better place to have posted this. My bad.
Lin Clark – She does some awesome cartoon explanations of complex concepts. For example, [A Cartoon Intro to Fiber](https://www.youtube.com/watch?v=ZCuYPiUIONs).
Jafar Hussain (of Netflix/tc39 Observable fame) has an async workshop on Frontend Masters which is the best I've seen. It's not a general course, more of a getting started with RxJS course. The dude is an excellent teacher, communicator, and engineer. He's setup an app to iterativly step deeper into the concepts behind reactive javascript development until you build your own naive implementation of an Observable as well as an AJAX fuzzy select with code that reads like perfectly clear &amp; succinct prose. I went through that course 3ish years ago, and I still find it inspiring. 
Depends if you're in ancient Rome😉
I've soured on Eric Elliot. The unit testing react workshop I did of his a few years ago felt like snake oil &amp; his community presence is kinda toxic. Dr. Axe is awesome though. 
Make a new array and then map through all the arrays provided let results = [] Then use an if statement to check if each item in the array is new. If new, it can be inserted in your new with a value of 0. For example, the values A, B and C would be : [ ] Any time you come across a value you've already seen, increment it by 1: {A:1, B:0, C:0} Then once you've been through the values, use Object.keys and reduce to find the item with the highest value, push it into a new object and delete it from the results object, and then repeat the cycle two more times until you have the three most common objects in your results object
However, it is worth noting that the React team have made significant efforts to improve getting started with create-react-app and an overhaul to their docs site. I imagine the learning experience is a lot smoother now.
You definitely have to be careful with recursion. JS won't be getting TCO; they had it in previous version (before 8) then stripped out all the code. 
I could be wrong but looking at http://node.green it appears to be gone. If I remember right, they replaced it with TCS and then dropped that as well. I think I read that they weren't planning on bringing it back; but it's early and I could just be making that up :-). I can't say I've used those languages, but it sounds promising! My next target is Go. 
Well I typically use this in two cases as others have also indicated: a) the function requires more than 3 or 4 arguments and/or b) there are optional parameters. As to this second case, I especially hate interfaces that require you to pass in a bare boolean to indicate some option. Sure it's more verbose, but passing in {myOption: true} makes things so much more clear.
...did you not read their comment at all, or
Have you ever encountered a proper stdlib in your life
I have learned a lot too from Stephen Grider's tutorials, he is great!
[Asim Hussain](https://codecraft.tv/)
Got it. Thanks man! This was eating my brain all day. :D
I keep seeing these nice screenshots of a small window editor with a gray backdrop shadow background. Does anyone know which editor or screenshot tools are used for this?
What else would it be?
`this` a.k.a. the function context is bound dynamically when a function is called, depending on how it is called. [This snippet](https://flems.io/#0=N4IgZglgNgpgziAXAbVAOwIYFsZJAOgAsAXLKEAGhAGMB7NYmBvAHgAcAnGAAggBNuAXgA6IWgFdibSaIB8LAPScYskAF8K6bLkQEAVgip0GTYnjDi01YhHrc2ACgCU3YBKmT8jAB7EAwvSMDNwA1ILcyAC6+HBQENQw+NQYUFAOGBwA5uI4DHBO+Hq0EGgOotyiLiEVIMLCaKJq9Y6imVC0AEYp3HB0bDCV3AoK9s68cNzGcLSw+O2Zzs1lIADuJXy0K0KC4cSEEHCIohTca2gbWzu7+-n1AG4Z3BhC3ACMANxLonsH+M9Xx24Pzgfyc9XqFisNjsYFotDGwHq3FG3xuf22IkoQLRGDBaCaDTQLRAAFoySTKu8USAulxuJDrLY0JMUlBKhC4YtCQ8ONxaC9EcynohuAAmChI+lwkWw2j1AlfUnkynUnB7WgCZKpdloWj4WVjYbA8bYngwbzKOBwJncDowWF0vY8DbEcFE5bkikgJxU4nia1oTKm7hJVljNWEDU62Wh1IOYAYRAAZjUeMVnpVfoDQadIYwbDYUAAnuGYOq+NG4X8C8X44mACypt3EjPe33Lf0lIOyp4TZ5TYgccTWWgcSt6zi0YhTov9dHhACs9TQMC2Bqc6k0IEwODwSStlBogVMeHUkTUQA) demonstrate various ways of binding `this`. Note that in the last case, the context is not `foo.prototype`, but a a freshly created object whose prototype has been set to `foo.prototype`. Since `this.a` can't be found on the new object, the JS engines climbs the prototype chain and finds the `a` property defined on `foo.prototype`.
Suppose you have a big function that does one particular thing, and it does it well. For example, fetch data from a particular website. Then for one particular case, you need that exact thing, but with one minor tweak. For example it needs to execute 1 single statement somewhere in the middle. What will you do? The worst I've seen is copy the whole function and add that one statement. I think it's much better to keep it as one function and add a parameter to flag that this is this particular one special case. Best way to add it is so that no other calls of this function are affected. Thus: a named optional parameter, or an option in an "options" record (called "object" in JavaScript but I wish they hadn't hijacked that name because an "object" is something else), is the best choice IMO. You can do this for any similar situation. I call this "plug in" based programming, which is modular style turned up its head: in modular programming you have your custom code and you invoke parts of a module. That isn't always the best solution. If you need to call a monolithic block of code and you need some special actions in the middle, you better write a plug-in that gets invoked *from* your monolith. As an example: I've had a case where a program parses source code, and needs to do some things when a particular type of statement is parsed . Your approach would be to make the parser into a module, and call that parser from every variation on that program. That is still a huge amount of work. I prefer a parsing program with a plug-in, which is basically an associative array with callbacks, where the appropriate callback is invoked at the proper time. Much easier.
I think it’s [Carbon](https://carbon.now.sh) 
Perfect, thanks!
Perfect, thanks!
Wow, this is by far the best comment I’ve ever got! :) I will analyze it very carefully because there is so much good advice. This is the main reason I write, to create a starting point where we can help each other improve. I’ll come back with a series of updates and if you will be kind, maybe look over them a bit. 
I don't find react difficult, I think they have the same difficulty as libraries. The problem is redux, OP at some point has to use redux and compared to vuex is harder to learn.
Wes Bos is currently my fav. I just finished his ES6 course and found it super easy to follow. He is great at simplifying sometimes tricky topics. Stephen Grider from Udemy is also awesome. He is very thorough with his explanations. 🙂
One edit made :) ArticleUiService will now export just a set of pure functions. We will import them by: import * as articleUiService from "../services/ArticleUiService"; 
Lacking support for Devtools something like Redux Devtools Extension and time travel feature. Which is why I made something similar which supports debugging tools. https://github.com/deamme/laco
I am in no way experienced enough to be able to give you a 'good' recommendation, but this read might help: https://medium.freecodecamp.org/what-exactly-is-client-side-rendering-and-hows-it-different-from-server-side-rendering-bd5c786b340d Overall, I believe that if you require a lot of DOM manipulation or will repeatedly render the same components over and over again, client side rendering (with Javascript) might be a better option than server side. Without repetition, I think I would build everything using HTML...
I see that you have now marked this as solved but i thought i'd have a crack at trying to clarify where you were confused about how the value of `this` is determined by the `call site` (i've not heard it described like that before, and i see why it has thrown you). // foo is a function, inside a function the default (unhelpfull) value of `this` is Window function foo(msg) { console.log("hello", msg, ", *this* is", this) } foo("bob") // &gt; hello bob, *this* is Window // because functions are Objects you can stash data on them, but // to be honest it's a bit of a weird thing to do… foo.a = 42 console.log(foo.a) // &gt; 42 // as usually you would use a plain Object especially for that purpose var data = {a: 11} data.a = 42 console.log(data.a) // &gt; 42 // nothing so far has had any affect on any value of `this`, furthermore… // the constext or location of where foo is called from has no affect either // (you seem pretty confused about this) function bar() { foo("bob") } bar() // &gt; hello bob, *this* is Window // because functions are values… data.stashedFooOnAnObject = foo console.log(data.stashedFooOnAnObject) // &gt; ƒ foo(msg) { console.log("hello", msg, ", *this* is", this) } // It is important to grok that there is now one function, and // two variables that hold a reference to it: `foo` and `stashedFooOnAnObject` // we can call either of these and it will call the exact same function foo("bob") // &gt; hello bob, *this* is Window data.stashedFooOnAnObject("bob") // &gt; hello bob, *this* is {a: 42, stashedFooOnAnObject: f(msg)} // Woo! when we called data.stashedFooOnAnObject(), ie we called `foo` THROUGH `data`, the value // of this inside `foo` was set to `data` // what would you expect to happen if we did this ? data.child1 = {child2: {child3: {anotherReferenceToFoo: foo}}} data.child1.child2.child3.anotherReferenceToFoo("Sarah") 
Don't ask me this question when &gt;50% of devs out there are clapping for a framework and some don't even have an idea of what is going on under the hood. They are all obligate some 'stdlib' users. If TC39 wants to accredidate stdlibs, they absolutely can. We have already a lot of polyfills and some actually do a great job. What is weird is that incorporating new things aggressively into the language creates irreversible entropy that at some point will be the desolation of JS. Then people/companies will come and set the stage for their own language proposal. I don't want that. I won't even give an example from ES6, look at Function.prototype.bind from es5. Did you know that it runs much slower compared to a ad-hoc version? Did you know that it even checks if you are calling the bound function as a constructor or not? Who calls a bound function as a constructor? So would not it be better if we implemented this 'bind' with different flavors as a micro library bundle and TC39 came and said hey guys you can use this, this or this depending on your needs? Promises weren't that bad. Destructuring was ok. I'd love to see for example a fourth microtask queue from TC39 but definitely not some utility function where everyone can write to suit their own need. That does not belong in the core spec.
See: https://www.reddit.com/r/javascript/comments/81clf5/rant_why_is_js_es6_import_syntax_designed_with/
 obj.foo() // this === obj inside of foo() foo() // === window.foo(), so this === window inside of foo() My last comment `foo() === window.foo()` isn't 100% accurate, it's actually more like `context.foo()`, but the point is that `this` resolves to `window` (or global/module in node) if you just call a plain function.
In addition to all the other tips there's also TurboLinks and Pjax which make it so that a link is prefetched when a user mouses over it, effectively giving your multi-page app the same fluid navigation as a SPA
Again, have you ever come across a proper stdlib in your life? The fact that the JS ecosystem (to be fair, frontend web tech in general) is a fragmented mess does not make `Array#flatten` or similar methods not pretty essential to a language's "core".
Oh ! you mean... like https://github.com/kapouer/node-webkitgtk ? The one i've been developing and using in production for years now ?
I explained why adding some stdlib functionality at the core level at this stage of Js will be bad for the language. As for your question of principle, there is no stdlib for js. Because that's not the direction these committees want to go... I f TC39 abandons pushing new core specs aggressively, they will have the time to accredidate libraries that provide utility functions. Then people would stop using github stars as a proxy to judge a project's quality and use them. Then they can opt out of these libraries anytime they want: - risk free - does not break the web - gives the freedom What you guys cannot see is that you are trying to judge things theoretically in an environment that IMO has some significant probability to be corrupt. Nobody can deny the probability that these new specs are pushed so aggressively on purpose to break the language and get people used to the "web can break" idea so that new languages controlled by larger firms can arrive at the stage...Nobody sees that. Even worse, some want that. 
I did indeed. It’s still a WIP but I’m almost done: [Project](ibrahimbutt.github.io/Vanilla-JavaScript-Calculator/dist) I’d appreciate any feedback and as much constructive criticism as you can give.
Hello reader! Before I begin, I would like to mention that this front-end project isn't optimised for mobile viewers (sorry). So you need to be on a larger screen to see this stuff. I was working on this project about 7 months ago. My aim was to provide juniors at my college with a good learning tool. But now I am looking for greater audience. I would like to add new chapters and visualisation on graph theory in this project. Please share your reviews and suggestions whether positive or negative. Thank you.
Calm down, man. No one else is allowed to create similar libraries? Also, SlimeJS is hardly new and has been in active development for years as well. I prefer nightmare.js readable API, although it is electron, thus Chromium based.
Thank you. I'm going to give [this one](https://marketplace.visualstudio.com/items?itemName=NuclleaR.vscode-extension-auto-import) a try.
Frontend has gotten insane
There's nothing really "wrong" with native implementation of Promise, Bluebird's is just better in almost every way.
would have been nice to see some performance metrics, lazy loading vs non lazy loading, page load etc
As an author to a fellow author...congrats for your ever-so-humble ability to accept constructive criticism!!! So many authors would have flipped out regarding the great suggestions you’ve been offered...EXCELLENT Article!!!
Although not primarily JavaScript, I really like Jeffrey Way from [Laracasts](https://laracasts.com/) and he's got some good free courses on ES6 and Vue. 
Thank you so much!!!
Hey all. I'm the writer of this post. This is literally my first blog post ever. I'm looking for feedback and/or corrections!
Why?
agree! I miss so much the nights passed to fix IE8 quirks! /s
Neither of those syntaxes have anything to do with IDE autocompletion though?
Weex really doesn't stand a chance against react native. Librarys and frameworks come down to adoption, and the community has spoken. React is more popular than Vue + Angular combined. If you want a job -- I'd suggest React. Another thing of note, once you learn React, React Native and React VR is within your grasp. 
It is harder to learn for sure and if he builds something big he has to use redux or some other library for to manage state.
I really like the head first series of books for beginning/syntax stuff because theys explains it to mah brains better than just reading a manual.
In comparison to what?
The DOM specification has been evolving to add convenience features like those in jQuery. For example, see recent additions to the ChildNode interface.
Learning typescript will probably be easier for you as learning JavaScript. ;) I can only promote it. Very happy with typescript 
This is wrong. If he is a Backend developer he probably is used to strict typings and patterns like dependency injection. So if the project is Angular, just start with Angular. But probably he doesnt choose the framework himself. ;)
I would say it is a losing battle to memorize any language. It’s better to understand programming concepts and principles. You can always look up the API of your language of choice to see how it applies. That said, you posted this in JavaScript subreddit, and this would be more at home at a Java subreddit
Just curious, have you tried the tutorials on that site? 
Java != JavaScript. But in general, there's no shame in looking stuff up when you need to. That's what documentation is for. If you need to remember how a method is spelled, what a class does, or the exact syntax of some language feature, go right ahead and look that up. If something actually comes up a lot and is important, you'll just memorize it by osmosis. All that said, you should try to gain a grasp of general programming concepts (stuff non-specific to any one language) like common algorithms and data structures. Good luck!
Thx
It's much faster than native and has greater functionality, while also being compatibile with it. The only downside is download size if you are using it in client side code.
Thanks to both of you
If you want to thank someone you should give them an upvote too.
Don’t try to memorize for memorization’s sake. Just use everything you want to learn over and over, and look stuff up as needed, then you will naturally need to look stuff up less as you use it.
Memorize how to effectively use reference material to get done what you need. Also memorize programming patterns and constructs. Use a good IDE that provides autocomplete and function parameter hints. Good luck!
Don’t mix up Java and JavaScript when holding conversation with your peers :-)
Learn to swear, continuously and in a way that would make an Australian blush.
I think the term refers to the fact that there is typically just one html "page" served, so it's a fine description I think. 
I totally dislike the article. It takes a simple example and applies a ton of patterns that are NOT needed. Architecture starts with quality attributes, constraints and functional attributes. Then based on those you figure out what architecture you need. This is just another random idea for architecture without actually explaining why use it.
&gt; Any sane IDE will just notify you about unrecognized symbol, show you the options, and add the import without need to type anything. That is nice and already possible. Nevertheless it is also nice to have meaningful autocompletion on imports, which is currently not possible, because when you write import the IDE can only suggest you all possible things you can import, while when you write from 'somewhere' import the IDE can suggest you the exactly the things you can import from that module. I think there are not many people who start reading a piece of code by reading every single import on the top of the file. That's something you do, when you are interested in the external symbols, or the dependencies within a project, or you just want to understand from where something being used later gets imported. Those are questions an IDE can answer, so you even don't have to read the word `import` when you fear wasting brain cycles by reading. I still think the order is a personal preference and I accept you having your preference. That's why I said it would be nice to try to use babel to allow people to write imports so meaningful autocompletion on imports is possible. You don't have to use it, if you don't like it :) 
To be honest, I could tell Eric Elliott was a snakeoil salesman just from his blogposts, and I often [said so](https://www.reddit.com/r/javascript/comments/6q2lk0/why_composition_is_harder_with_classes/dkum3eg/). He uses all the buzzwords, but he doesn't actually know what any of them mean, and instead he invents his own personal definitions for them to fit whatever argument (or whatever sale) he's trying to make. As [another user put it](https://www.reddit.com/r/javascript/comments/6q2lk0/why_composition_is_harder_with_classes/dku5cpe/), "What [Eric is] doing is like a scam artist talking about 'quantum effects' and 'toxin cleansing'. Scammers ride on the popularity of some accepted terms, but reject their meaning and make up some B.S." cc /u/dantix /u/Hcmichael21
Definetly read about how 'this' works. I also came from Java with a certain understanding of how it is supposed to work. Oh boy, at some points i was doing wizardry until I read this: https://github.com/getify/You-Dont-Know-JS
Oh nice, I didn't know there are head first books for JavaScript. I've really enjoyed the head first Java books.
Thanks for the link. Do you enjoy working in JavaScript now vs Java?
I think its called HTML5 but there is a big emphasis on javascript https://www.amazon.com/Head-First-HTML5-Programming-JavaScript/dp/1449390544
Was going to mention this, as it’s an important distinction. Also, almost every time I hear someone complain about JS, they are actually complaining about the DOM.
I needed to inspect some Buffer instances, so I added a little hex viewer to my node.js REPL: https://github.com/skerit/janeway#hex-viewer Didn't release the new version on NPM yet, though.
Thanks for sharing Laco, another cool tool!
Any must-do lists of projects for beginners? 
You're welcome. I love it. It has required some effort to get to know and understand so many different ways to do something. This flexibility is very refreshing to me though. Hope you enjoy it. 
Welp, I thought I was a half decent dev, up until I actually read through comments and content in this sub. Good info dude.
Honestly, the best response to constructive criticism I've ever seems in Reddit. I agree - I used to be shy about writing because I felt that there's no way my ideas were the best in the industry. But it's not about that, it's about collecting your thoughts and taking snapshots of where you stand at the time of writing. It also helps to be able to reference previously written ideas and code examples in the future. There's just tons of benefits to writing your ideas down and sharing them. If we could all just stop being snarky and mean to people who blog who aren't posting industry-changing articles (which I'll admit, I'm guilty of too) we'd have a great community. 
You wanna be a real front end guy. You better know css. That being said, there are lots of predefined libraries and you can get away without fully knowing it for a while. 
That’s about what I gathered from the article too. I saw “architecture” in the title and was immediately skeptical but gave it a chance. As soon as I saw the word factory I knew it was going to be a post about how everything is completely over-engineered for no gain. 
Thanks for your response. Can you explain why you need to be an expert in it? The reason I ask is I come across a lot of senior frontend devs who don't seem to be experts in CSS. They just get by and lean heavily on a library and if stuck they hit something like Stackoverflow. And looking at style sheets, a lot of devs don't use any standards or best practices. A lot more importance is placed on those things when it comes to JavaScript.
It's written using more optimal algorithms.
I don't think you need to be an expert, but working on projects that use less/css is common. Building your own projects that use it helps you get better and it will become second nature. I started 3 years ago and always forgot values and names and whatnot. And I'd say I'm now at the point where I only look up the most infrequently used attributes when I'm trying to do something funky. It's not always fun, but it's relevant.
When I'm interviewing front end engineers I look for at least a base line competency with CSS - you should be able to look at a simple design and at least be able to make it look 75% there. It's an important skill and I think it makes you way more valuable to most org's.
From my experience a real “expert” in front end dev is an expert in CSS as well. But we don’t need to be an expert front end dev to get hired or ship projects. There is a scarcity of talent so...
I've never seen someone who knew so little act so cocky
I agree it's an important skill. I more wondering just how good you have to be at it. Based on my own experience and working with a lot of other devs I rarely come across someone who is actually really good at it, and understands it deeply enough to be able to easily spot the problem with quirky CSS and fix it. It seems like most frontend devs just deal with CSS the best the can and with learning the minimum they can get away with. Is that your experience as well? Just to give an example, I would expect someone beyond the junior stage to be able to do a lot of the basics like classes, ids, margins, padding, borders, width, maybe flexbox and grids, and perhaps Sass or Less. But I rarely find anyone who claims they are *really good* at CSS. For a lot of projects the CSS is kind of disorganized and feels like an afterthought. Or they just use a library. Compare that to JavaScript where I do find plenty of devs who are familiar with ES6 and who can write solid code, and following coding standards.
uhm.. Yes they are... The index.html` file is the page. you mount your react/angular/vue/whatever app into a node on that page. It is a single page application because the client downloads a single .html page. Not sure what you don't understand here?
VSCode has this functionality by default, if you autocomplete an exported variable from another file it will add the import for you.
Do you use best practices for your CSS? OOCSS, ACSS, BEM, or SMACSS? Do you have a way of identifying and deleting unused CSS? Or does the CSS just grow because you're afraid deleting stuff will break something? If you had to interview someone for a senior position, how much of the interview would be around CSS and how deep does their knowledge need to be? Could you compare it to what you expect for JavaScript? I've had frontend interviews where almost no CSS questions are asked and it's mostly about JavaScript and other stuff. Thanks for your response and your help!
&gt; But being able to see details and translate them to css is different. I get what you mean. Some devs can translate a design mockup into pixel perfect CSS and others have seemingly used some other imaginary mockup that has nothing to do with the actual one. Thanks for your clarification. This is helpful info.
Thank you so much for your appreciation! It terrifies me whenever I write my ideas, this is why I do it rarely and only when I feel I have something to say. IMO crystallineair 's improvements were spot on, and I updated the article on his feedback, leading to a better code which will help me and hopefully others.
&gt; it's a relatively straightforward declarative process. Similar to HTML I've had way more problems debugging CSS than HTML. In fact I don't ever remember having to debug HTML, or at least it was something that was easy to find and fix in a few minutes. On the other hand, I've seen experienced devs struggle for hours or days trying to figure out why they can't get the layout to work right. Isn't that part of the reason libraries like Bootstrap came into existence in the first place? And I've come across a lot of really crap CSS from otherwise good devs. So yeah, I'm definitely not talking about being an expert at the level of Sarah Drasner. Just completely confident you can fix almost any CSS problem and it won't take long to figure it out. And that your CSS is well organized, doesn't have unused styles, and follows some standards. The same as I would expect from your JavaScript. Does that describe most frontend devs that you are aware of?
That's helpful info. I'm guessing that you prioritize the JavaScript skills when you have to make a choice? That you'd hire a great JavaScript dev with below-average CSS skills instead of a CSS expert who struggles with JavaScript?
Because most modern js apps are developed around semantic components rather than pages, and it's irrelevant whether it's delivered through the browser via a web "page" or packaged for the desktop via electron or packaged as a mobile app. The `index.html` "page" part is just a packaging/delivery implementation detail that frequently only contains an initialization call.
Yea, I have, there were some issues with my node on Ubuntu, I reinstalled node and installed latest version and now it works. Will post back how good tutorials are, nonetheless I'd still appreciate if anyone could share some in depth material on this or let me know how they approached learning Dojo 2, anything that would help me learn is welcome. 
Sure, flexbox isn't much different.
Also, too be clear. CSS doesn't equate to being a good front end developer. But it's a consequence of having worked a lot in the web
&gt; Its fast enough for Netflix AFAIK most Netflix UIs are made with React.
&gt; I think debugging a CSS problem shouldn't be that hard. What about debugging a layout problem for a responsive site? I'd expect a CSS expert to be able to figure that out pretty quickly. I mean I've seen that happen. I'm not confident I wouldn't be spinning my wheels for a while on something like that. Along with a lot of other senior frontend devs. &gt; The implementation isn't as different to change between projects as compared to different JavaScript frameworks etc. That's a good point.
Yep! For every project I break things into a few different chunks. First off- I use a few resets to normalize some browser differences of some elements. Then set up a base style- applying the site-specific style guide to base elements. This can be as simple as font styles and base colors to base objects, generally these things are global, but over-rideable in the case it's necessary. The above all fall into the "config" category of styles. They are top-level and easily overridden. Next is "components", which gets more into the OO stuff. Add certain classes to certain divs to make them act in a very generic way, based on what it is. This usually includes things like containers- specifically base sizes and responsive actions. Then goes down to tables, alerts/notifications, form components, etc. At this point, you should be able to build a majority of your pages with HTML alone and without touching any CSS and have the pages immediately fit in with your site theme-wise. However, many pages will need specific handling, and for that, the last section is for "page" specific css. In these cases, you should be using ids on each page that separate it from the rest, and you can apply CSS to that page specifically without affecting the rest of the site. (This is essentially building your own Bootstrap/framework, but with MUCH less overhead.) Using the above methods- it's usually pretty easy to identify unused CSS, as it will almost always be contained within the "page" sections. Some styles can get stale, but it's much easier to stay on top of. All of that said- I would say very little of an interview should be focused around CSS, however. Maybe a few questions like you just asked to gauge whether or not they know what they're doing. (And hopefully they've provided code samples we can look at.) But I wouldn't do something like a whiteboard assignment. Maybe ask them how they'd approach a situation in CSS, but that's it. In my opinion, being capable with CSS should be an after-thought. There shouldn't even be a question if you're good or not with it if you call yourself a senior front-end dev. Because of that, technical questions outside of verifying they at least know their way around CSS should be more JS focused as there is a lot more to learn and keep up with there than the CSS specs.
I haven't had a chance to look closely at flexbox yet. Maybe that makes things a lot easier compared to some of the stuff I've struggled with over the years.
I think the front end has split. Lots of people coming from the backend into JS and frameworks - these people are usually not great at CSS. I’m someone who started with CSS before getting into JS/React/Rails. It’s important to know the basics when Bootstrap won’t cut it. One thing I’ve noticed is that devs with a CSS/jQuery background are a bit stuck in the past and don’t have a great understanding of systems. Maybe I’ve just been unlucky.
Why are single page applications important am I missing something or misunderstanding the concept?
sure. But it's still a page. That's just the lexicon of the web. The semantics you are describing fit the term "views". a SPA is a collection of views, which in themselves are a collection of components. But a view exists on a web page. That's just how the web works. My SPA might have absolutely nothing to do with documents, but that doesn't change the fact that there is a document object model in the browser. 
&gt; Lots of people coming from the backend into JS and frameworks - these people are usually not great at CSS. That's good info. Maybe that's why I bump into a lot of frontend devs who seem to be pretty good at JS but below average in CSS. &gt; It’s important to know the basics when Bootstrap won’t cut it. I can see how that would be important. What do you consider the basics? 
No, I'm not.
I'm not sure why but my guess would be that `import` was already a reserved word in the language but `from` was not. So import statements beginning with `from` might have broken old code. Plus they'd have to reserve yet another keyword (of which there are already too many.)
Welcome to Reddit.
Also very nice. Thank you :)
What is your company using on the front end? If they are primarily using a particular framework (angular, react, vue etc), start learning that framework ASAP at the same time as brushing up on javascript, css and html fundamentals. Eloquent Javascript is a great book--concise, accessible, practical. I love udemy courses for javascript fundamentals (yes, there are such udemy courses), frameworks and styling. 
If you're having trouble debugging css you're gonna have trouble debugging bootstrap. e.g. If you inspect an element in chrome you would still be reading css so you better understand how it works. Bootstrap is just predefined css classes it's not a replacement, it's just something that you can use.
looked it up and no answer 
Can we stop calling for changing long established names based on personal preferences? ES6 has to become ES2015. Isomorphic has to become universal only to become SSR. It all feels like r/iamverysmart'ism. 
CSS is misunderstood and mostly poorly used. A lot of developers are not only bad at CSS, they probably haven't even thought much about what good CSS is. They probably wouldn't think of themselves as bad at it as it's never occurred to them to worry about it. I don't hire anybody but I would definitely look favourably on someone that values CSS and has opinions on how to stop it becoming a complete mess. They're pretty rare though!
Perhaps it's because I'm in mobile but to mee the transitions were way too short to be called "silky smooth" but I guess it's subjective.
You know that libraries are built using plain JavaScript right? So it's impossible for them to be any more optimal or efficient than plain JavaScript.
It totally depends on the application, but I tend to think hardcore CSS knowledge is just wasted brainspace. How much time do you really spend on the nitty gritty CSS? 95% of the CSS problems I've ever encountered are instantly Google-able. Codepen is a fantastic resource, and StackOverflow is a fantastic resource. Having a deep understanding of layout in your working memory at all times might be important for some applications, but I honestly haven't seen it for quite a while. I work on frontend all the time (React, mostly), and I just don't need it. I've used flexbox dozens of times but I still don't remember at all how it works. I just look it up when I need to and promptly forget it.
It depends I suppose. But I am trying to get my own CSS skills up to a modern level and then upgrade my JS. I won’t take forever to do so though ;)
Remember, Java is to JavaScript as Pain is to Painting, or Ham is to Hamster. We don't know Java, and if you're trying to apply your Java knowledge to JavaScript, it probably won't work.
I have a small tip too, when using a fat arrow function that returns an object, you can clean it up a little by not explicitly returning the object immediately, but rather having your return value wrapped in parentheses will automatically do it for you. Fat arrow functions will always immediately return if the first character after the arrow is not a curly brace. e.g. const returnObj = () =&gt; ({ a: 1 }); Its a personal preference thing but I think that it's cleaner and more readable
Ah yes! Flexbox is great and pretty easy 😁
Basic layout will take you a long way. Floats (and all related hacks) for debugging legacy stuff, Flexbox for anything else. Understanding absolute/relative positioning and z-index (and to use them sparingly). Knowing how the cascade works (and not to over rely on it). Knowing how to use media queries and sticking with a consistent approach. Avoiding really bad stuff: I see a lot of ids, deeply nested css, arbitrary use of important, repetition and just no thought about code structure.
I guess part of it comes with having written the CSS myself or debugging someone else's code. Dealing with multiple media queries for the same style isn't terrible... Until their spread across multiple files and have several declarations. Then it comes down to using the inspector and understanding the heirarchy rules for CSS
Ty for the tip! :) I can refactor ArticleServiceFactory with this pattern. I’ll check for other occurrences also. How about returning the ternary operator directly without a return statement and brackets? () =&gt; a ? true : false
Ty for this great tip! I will the ArticleServiceFactory with this pattern. I will also look for other occurences in the code. How about returning a ternary operator directly? () =&gt; a ? true : false ?
Super cool :)
&gt; They're pretty rare though! Exactly what I've seen. Most devs become good enough at CSS to be able to get most basic designs working without major flaws. And they stop there.
 Thanks for your answer. &gt; Ultimately, front-end application engineering and design are entirely different skill sets. That's the divide I've seen at some places too. Folks great at JavaScript and application logic, and if your team is big enough there's someone who works with the design team to write the CSS. In those cases you might find someone who is actually an expert at CSS. But most frontend devs seem to get "just good enough" to be able to get by.
Yep. I used to be really into CSS actually. More animations than layout. That was just college though. Then I had a job that was pretty CSS heavy and realized the real world is messy and stupid. Did you know that click handlers in JS don't get triggered on iOS safari unless you also have a `cursor: pointer;` rule? Totally insane. You can't remember this stuff. Just get good at development and deal with the head scratchers as they come and know someone else has figured it out so you don't have to. 
Put your code on pastebin or jsbin and paste the link here
The implied return without a block is neat but I'm not sure it's a good thing in the language. It is definitely not intuitive. I don't think I have met a developer that has understood it without having to ask for an explanation or read about the behaviour specifically. 
&gt; If you inspect an element in chrome you would still be reading css so you better understand how it works. That's a really good point. Although I've had to debug a lot of bad CSS and I've rarely had to debug a Bootstrap problem. It usually just works. And I'd be inclined to report a problem to the Bootstrap team and get help there. &gt; react fragment is already a big step towards that You don't mean this, do you? https://reactjs.org/docs/fragments.html
It does. One limitation of Flexbox is that it’s one-dimensional but CSS Grid addresses that. I’m very excited about the future of CSS layout - we finally have standardised tools that are suitable for the job. 
https://jsbin.com/habamamabi/edit?html,js,console,output Here it is. Sorry if the code is a little messy. There might be some unnecessary things in the code as well lol. Thank you! The console prints the price server side, but not client side as you can see. =)
Thanks for your books! They are clearly written and give detail where it is needed, without going over the stuff I already knew coming from a java background.
Not a big fan of that name, I don't like have curse words in my projects and file and library names it's really unprofessional.
This is very good. You should x-post it to r/math
Thnx. I will.
Finishing any project is much harder than starting it, since it's done in my spare time, time that's very valuable, I hardly find it worth to finish projects. As long as I have gained something from a pet project I consider it a success. What you might want to do however, is realize that if you haven't worked on a project in the last 6 months it's probably a good idea to let it go, label it experimental/unfinished/whaterver but come to terms with it and do something with it to visualize that, so that you don't keep dragging it with you. You likely already have a new cooler project on your mind, start it but make sure you gain from it. If you always come to a stop at the same roadblocks, do try and get past them and if needed, reach out for help.
Any examples, or screenshots of this in use?
I put a ton of effort into them but I am unfortunate enough to not be a software developer by day :)
Learn front end tooling, and learn how JS's OOP model works. It is almost but not quite entirely unlike Java's OOP model, and thinking "Java" while writing Javascript will probably drive you crazy. They're very different, despite the superficial similarities (which, including the name, only exist for historical marketing reasons).
I think you need to call response.writeHead/write/end with the result in your async function similar to what you're doing for index. Returning from your friction isn't doing anything.
That’s a fucking shame
It's not hard to learn CSS. You can find some books or videos like "learn CSS in an hour" it should be enough for most of the cases, and then you can go deeper as needed and it shouldn't take to much time to learn. It is ok to go to stackoverflow to learn something while you coding.
You need to get the value- not just the element itself. .value / .val() 
Learn to ignore the hype (medium, twitter, reddit, hacker news). Here's a list of some things you don't need: - flux, redux, rx.js, mobx-state-tree, extreme immutability (or any niche idea taken to extreme) - graphql, relay, apollo Basically anything which sounds weird. JavaScript is evolving quickly, focus on things that don't change. Try to avoid writing too much framework-related code. From this point of view, angular and vue are better than react, because they don't make (much) assumptions about the structure of your data.
They're unlikely to mesh much unless you're planning on using C++ in combination with Node backend. There's nothing wrong with learning it in itself, but you'll probably be able to build better integrated projects with something closer to Javascript's domain.
Knowing C/C++ is a huge leg up. 
Why is that?
If youre fond of web development you should look into nodejs and/or google go. I think PHP will be dead some time.
I made a small demo for you till I resolve merge conflicts with master branch: http://selector.samuelillo.com/
I'll try all this right now thanks man!
Too bad I cannot open any of them on my iPhone. If I have time ill look into this :)
C++ will generally be useful in completely different spheres than JavaScript, but it necessitates an in-depth knowledge of system architecture and functionality that will serve you well in any challenge. Knowing that language in which JavaScript engines are often written, for instance, will equip you well for improving how you write for those engines. It's also fantastic in general, and a great career move. C and c++ coding has been needed for more than 40 years.
Word! Just a note: I assumed you were just testing with rectangles right now. If you want that color to apply to all the shapes, set the fill style before the switch statement.
Just another way to skin the cat. I think it's just a little easier to see what it's actually doing at a glance. I might also reverse the order of args and curry the function. const reject_after = ms =&gt; new Promise((y, n) =&gt; setTimeout(n, ms)); const timeout = ms =&gt; p =&gt; Promise.race([reject_after(ms), p]); const timeout600ms = timeout(600); const timeout300ms = timeout(300); // usage Promise.all([ timeout600ms(APIcall1("http://blah")), timeout300ms(APIcall2("http://blah")) ]).then(something).catch(handle); 
BTW is using C++ in combination with node even that common? I don't see it come up much in job advertisements in my area.
I tried something in the form of this and put it right in my async and set data to my result value : response.writeHead(200, {'Content-Type': 'text/html','Content- Length':data.length}); response.write(data); response.end(); is this what you mean? it ran, but did not print my value to the console from the client :(
react is fine but redux makes me sad
Haha, you write cleaner react code than a lot of people I’ve seen starting out at my job. Good job separating out components in a logical manner. I would suggest that many people find it easier to read when you put the entire component inline. So instead of writing const someChild = data.map(() =&gt; &lt;div&gt;Stuff&lt;/div&gt;) return ( &lt;div&gt; {someChild} &lt;/div&gt; ) Put the mapping inline: &lt;div&gt; {data.map(() =&gt; &lt;div&gt;Stuff&lt;/div&gt;)} &lt;/div&gt; If the child seems to big to be inline, it should be split out into its own component. Also I notice you switching between const and let, you can just use const in pretty much every instance I saw in your code. Only use let if it’s absolutely necessary. Maybe look into the library recompose to avoid having to write any components as classes, it’s an excellent react utility belt. Awesome job overall though!
I'm pretty sure it's not, that's the problem.
Definitely something Safari related. Wish I had apple device for testing. In other browsers it works fine.
OP, I'm going to say this in the nicest way possible. You are attempting run before you can walk. The issue with your server, as T4RGE7 pointed out, is that you're not returning a response. You don't seem to under the basics between getting a request and sending a response. You have functions like this: function getCurrency(){ var currency; currency = 'LTC'; return currency; } 
There's nothing wrong with this function. This was a test function to see if my currency values could be called in with the API request. I initialized currency to 'LTC'. The price is also returned, so this function works. I'm not sure exactly what you mean. 
'tis a shame. I guess I'll also check with the folks over at r/Node.
Aaannnddd it stared working. I have no clue why. No errors in the safari on my iPhone either. 
Thank you! I had never heard of recompose. Looks super handy! I'm going to use it in my next project. I just started to getting into react and functional programming so you're suggestions are appreciated! 
NEVER, EVER, EVER, JSP.
Keith Peters and Marijn Haverbeke.
You are right, the function is not broken. It returns a string as intended. But to be blunt, it's bad code and simply unnecessary, and I've already explained why. The anatomy of handling an HTTP request is as such: http.createServer(function (req, res) { res.writeHead(200, {'Content-Type': 'text/plain'}); res.write('Hello World!'); res.end(); }).listen(8080); You get a request, and you return a response. Your code doesn't work because you're not actually returning a response. And let me be a little more blunt. It literally looks like you are copying and pasting code and praying for the best. That's not a great way to learn. So if you're here to learn, keep that in mind.
&gt; It's pretty simple. You don't have to be genius to use this library. Anyone can! Great. Initially I was concerned this may not be the library for me. 
From what I can see, he's found some extremely basic test code and decided to attack it to feel superior. Why? I'm not sure. Your function is totally fine, I would write a very similar 'useless' function, since you will obviously need a similar framework later, for when you expand to other currencies. Just Ignore fusebox 
do an express.js tutorial. 
Fair enough, preciate it bro
This format doesn't work for my case, as I stated in a previous comment. My Ajax is calling an API function. Thanks for the help though! Most of this code is actually mine, and the API Js has been modified by me for more efficiency. The CCXT example online is much more bulky. The separate functions for currency and exchange were made as I will eventually try to pass variables to them from the client so they can be sent with the API request. I was simply testing whether or not the variables returned in those functions would work server side in the request. I am very new to this! This is my first week using NodeJS so much of the actual server code was indeed found online from Stackoverflow. It just helps me understand how this process works :)
Thank you! Yeah lol, I set up those functions as the framework or basis for what is to come. I hope to pass user selected values into those functions from the client so different API calls can be made. I just need to figure out how to correctly send the result back. 
He is wrong. It is the best mix to have full web GUI with unlimited raw power. Take a look at Chromium Embedded Framework, the code is C++ and you will also need a solid base in Javascript to take full advantage of the web based GUI. One of my last jobs involved using CEF to support specific business logic that is not possible using only pure web technologies in the client side. Right now I am opening Steam, and yes, it uses CEF for the GUI. 
pretty basic stuff
Oh shit, I can do that! Wicked I'll do that too!
The things you listed being interesting in C++ for do belong to a lot of other languages as well. I also don't think choosing to learn one language over another is going to hurt your career in any way. Wouldn't you be trying to get a job using the language you _want_ to use? You seem to have a good idea of what you want to do, so I would tell you to shop around for languages because there are a ton that are still high performance like C/C++ but also useful in a web browser ecosystem. Personally, I've learned a lot from Clojure in this respect.
One more note- with canvas context: you can call &lt;context&gt;.save() Then set draw values, paint all your stuff and then call &lt;context&gt;.restore() You will not have to worry about any changes made to the context bleeding into other parts. Like: ctx.save(); ctx.strokeStyle = “#FF0000”; ctx.setLineDash([10,5]); ctx.strokeRect(0,0,100,100); ctx.restore(); Now future draws are not affected by any of those styles. The context is back to the state it was prior to setting those styles.
I took my time to read through some random code and do a code review and here is what I saw. I saw the OP trying to use async functions when they didn't understand basic http requests. I saw functions that were returning hardcoded strings and took the time show the OP a better way, and and even further explained that returning strings from functions is ok as long is there is some sort of logic attached to it. The OP needs to go back to the basics before they can go forward which was point. You can extrapolate that I was trying to "feel superior" but in reality I didn't have to take my time to read through the code. I did it because I'm trying to help the OP. When more complexity is added to this app, writing code like that is going to hurt the OP overall. There is no need to be defensive here because I'm not attacking the OP. If I was my post would go more like this: &gt;&gt;Your code is bad and you should feel bad and I'm not going to tell you why. That would attacking the OP's code to feel superior, which I frankly did not do. So, yeah ignore the guy who took a moment to give a damn when I otherwise didn't have.
C++ has started making inroads into the browser space thanks to asm.js and wasm. Some of the major game engines are taking this route. e.g. https://s3.amazonaws.com/mozilla-games/ZenGarden/EpicZenGarden.html
Alright man, I'm sorry for trying to help. I appreciate that as a student, you are trying to handle more challenging code. That's a great way to grow a developer, that's how I grew as a developer. When I was in school, we were supposed to write basic classes and simple apps that reinforced the fundamentals, but I was eager and attempted to tackle Open GL. That was a mistake. It prevented me from mastering the basics until much later on because I was copying and pasting snippets of code without really understanding what was going on. I had to eventually go back to the basics. Sorry for sounding harsh, but I'm warning to not go down that path and I'm speaking from experience. When you do finally get to a point where you are doing things like code reviews, be prepared for much harsher feedback than what I provided today. If you want a window into what that might look like, read through some pull requests on open source projects. 
I see where you're coming from, but ES6 is simply where the new nomenclature started (which in itself is important as it *^may* be the turning point where vendors start to keep up with changes in the languages, making browsers truly evergreen). If you wish so you can call ES2015 "ES6" of course, but ES2017 is simply ES2017 and generally updates to ECMAScript are incrementally released every year now, so referencing them by the year of release just makes sense. But yes, whether you call something an "isomorphic app" or an "server-side rendered single page application" makes little to no difference and is pretty arbitrary, I agree there.
The code you're arguing about is so blindingly, light-speed simple, plus irrelevant. Any code is 100% fine during development, if it's never going to be seen by anyone but you, and is only temporary. And trust me, you're not a dick, you're an asshole. I'm a dick. 
I'm assuming that the OP is going to want to work in a professional capacity some point. Steering the OP away from bad habits early is not being an asshole. It's preparing them for their future career as a programmer. It's the simple things that are easy to get wrong, and you obviously underestimate that fact. 
I don't deal. is:issue is:open. You're not alone. Much love and best wishes, fellow dev.
Ever since reformatting my laptop a few months ago, I’ve actually kept a plain text file of all the things I’ve installed. This way if I want to start fresh, I can just create a one liner with all the packages I’ve installed. 
[Here ya go](https://www.reddit.com/r/javascript/search?q=interview+questions&amp;restrict_sr=on&amp;sort=relevance&amp;t=all) Good luck!
Eh, I tend to find that C/C++ programmers tend to write horrible JS, although that's probably more the fault of JS than the devs
While other people gave you what you asked for, this person is giving you what you need. This is the best advice.
While other people gave you what you asked for, this person is giving you what you need. This is the best advice.
To do what? Writing iOS apps is all Swift is really good for (yes I know it can run on a server). 
I surely hope that you're not a programmer because you're perspective here is doing the OP no favors. I expect my colleagues to rip my code to shreds because in the end, it forces me to write better code. I'm being nice here. In the real world, the OP will have to deal with coders much douchier than me, so I hope they are prepared for that. You obviously aren't. The first time OP is asked to throw away hours and hours of work away because their senior dev couldn't find anything good about their code, it's going to be a rude awaking. Also, isn't this sub a teaching sub? This might be why this sub is dead because when experienced devs do offer their insight, they get accused of attacking the students so it's simply not worth their time. Again, I didn't have to read through any of the code, or take the time to write anything but I did because I'm happy to teach. If thats not what this sub is for, then we should perhaps ban questions from students and focus solely on JS topics.
Definitely the fault of JS. C++ was my first language an learning JS was a headache for a moment. I hated having my hand held. It still seems like a language that was just thrown together but I like it now. 
I recommend getting into Node.js, it is delicious as a pure javascript back-end. I got into it recently and it is one of the best experiences I've had. Everything fuse box says doesn't ring true with me anyway, there is no 'best' way - considering everyone has different goals. He even used some absolutes. I would focus on your goals and ignore irrelevancies like what he is talking about, I totally see how you're planning for your framework to expand and it seems totally reasonable to me. I say that as someone who just scratch built a massive multiplayer framework in vanilla JS: Pic: http://mantercorp.com/progresspic.png He is correct about the whole 'joy of programming' stuff and the elitism in the industry, but really, who cares - learn what you're trying to learn! 
As someone who has both been an interviewer and interviewie the advice I'd give is to be personable enthusiastic, don't try to bs if you don't know something or a particular library or framework. Just fess up show interest and convey that you can learn. There is always the next big JavaScript framework so it's better to show motivation and interest over just bullshitting. But of course prepare with some common interview questions. Just most people don't realize that half of your job as a developer is learning and keeping up with the changing tools so conveying you can do that is important.
What is your client getting as a result? Does the response ever return to the client? Do you get an error?
I'm mostly a rich/media/games canvas guy - so my socket.IO system is probably quite different from your needs, but I would do what cm9kZW8K recommended and get into some tutorials, at least until you reach 'hello world' stage, then jump deeper into node. Once you have a skeleton working at a basic level you should have no trouble transitioning your skills into the back end 
&gt; Let me say, first of all, that you sure can just drop a script in your page. It's a totally valid solution. &gt; Let's try to walk all the way to a generic solution such as Webpack (or Rollup, or Browserify or others). Notice, though, that I will be writing only about JavaScript, not other types of assets such as CSS or images or any other stuff. &gt; So you have a script for your page. It's about... say... 500 lines of JS. Life's ok, I guess. But then you start adding more functionalities to the page and your bosses hire a couple more devs and you all work on that JavaScript and if you just continued that way, with a single script file, well... I can see that getting out of control to a big 20k LOC file. Life's not so ok any longer. &gt; You and your team start splitting the code into different parts. You have, say, a bunch of functions to deal with DOM manipulation, some other pieces to deal with server requests, some others for data processing, a couple of components you reuse here and there, some utility functions... You quickly break the big file into... let's say about 20 smaller (~1kLOC) files. And how do you manage these? Well, you just insert 20 &lt;script&gt; tags in your page, in a carefully chosen order, because, well, you have to be sure that that utility function is available before you try to use it, right? &gt; Now life is... well, better, yes, but it's not that nice either. Because you have to keep track of where you put your functions, the order in which things are loaded and all that. And files, well, 1kLOC files are still a bit big, you know. But if you split more finely, you'll get many more files and that means more &lt;script&gt; tags and more loading issues and... Ok, life is not really too good, I guess. &gt; Not only that, but you know, all those files define a lot of names. Names of functions, names of variables. And those that get thrown in the global scope... uh, yes, they may collide with other names defined in other files. So adding new stuff gets complicated. &gt; So you reach out to your knowledge (or consult some book, tutorial, ask for help, whatever) and you discover the "Revealing Module Pattern". I won't explain it in detail. Suffice to say that it is a structure like so... let something = (function() { // "so called private" code here // ... // and then... return { publicOne: ..., publicTwo: ... }; })(); &gt; ...which basically provides you, through a closure, with some encapsulation. The thing returned and assigned to something has some visible methods and/or properties, and those methods have access to the local stuff defined inside the function expression which no one else has access to. So, to some extent, it is a structure that allows you to write some encapsulated blocks with "private" visibility. Why this is good for your problem? It avoids name collisions. What you do is each of those 20 or now 50 files you have, you create this structure, engulfing all the content of the file. And at the end you only return the things you really want to be visible. &gt; This is a huge gain, because you can now split the files as small as you want without concern for name collisions. On the other hand you now have 50 &lt;script&gt; tags or a hundred. And that thing with the order, well, life's not so nice in that front. &gt; Let's recap a bit: &gt; - You've successfully solved the problem of having a single huge file. It was a problem, because it was really huge and because you needed to have various people working on it at the same time and that's nasty. But now that's solved because you have separate files and one person can work in some files while another works in others. &gt; - But you now have these problems: 2.1. You have 200 &lt;script&gt; tags in your page. 2.2. They need to be kept in a certain order. &gt; So we're going to try to solve these two new problems. &gt; There's a really simple solution. It won't solve everything, but it is simple: You could have a shell script or some similar tool that simply concatenates all your script files in the correct order. That way, the first problem is clearly solved. Your sources are in 300 files, but the script included in the page is back to being just this one file. So just one &lt;script&gt; tag again. Great! &gt; But the second problem remains. For the shell script to correctly concatenate the JS files, you have to tell it what's the correct order. You can go through many naïve solutions here. Some may even work to some extent. Say you named your files following a certain pattern like 00100-somefile.js, 001300-anotherfile.js... and then just concatenate following the number. It sort of works. Not pretty at all to maintain, but it sort of works. &gt; Anyway, any solution along those lines is still a kludge and doesn't really solve the problem. So instead, you think of a pattern a bit more sophisticated. To the above pattern you try to add some way for a particular file to say what other files it needs to be available before it can run... Its dependencies if you will. &gt; I don't want to write what that could look like in a naïve approach, but you can look into RequireJS for an approach that is somewhat close to what it could look like. &gt; Then again, while you're doing all this, some folks publish NodeJS, it becomes popular and as it precisely includes a mechanism to do exactly this (defining "modules" which can export some public parts and require other modules) then that mechanism, with that particular syntax and all, becomes very popular too. Note, that later, the standard decides on a different syntax and mechanism but that doesn't really matter much; the important bit is that there are some particular syntaxes that become popular, and so you follow that. &gt; But of course, the syntax in NodeJS works well for NodeJS. And while ECMAScript finally standardizes on another syntax, the point is that these systems are designed towards really having multiple independent files... and you don't want to serve your files separately. &gt; The syntax leaves out most of the "weird" boilerplate about closures and simply allows you to write it in a manner such as... // one of these to require dependencies: let a = require('a.js'); import a from 'a.js'; // ...your code... // One of these (or other similar variations) to make things visible out of your module: module.exports = something; export something; &gt; So you revise that shell script you had that simply concatenated all your JS files, and turn it into something a bit more sophisticated. &gt; On the one hand, you make it so that before and after each file's contents a little bit of boilerplate is added. This is, approximately, the same closure boilerplate you had removed in exchange for this new syntax. Not exactly the same, but it is similar. The main difference is that it is putting your code inside a function expression but instead of simply calling it directly, it passes it to a small function that the shell script makes sure is included first thing into your final "bundled" JS file. That function will execute the function that it receives, but it will do so with a bit more control. Because it either manages those require('a.js') calls or transforms those import from 'a.js' into calls it can manage. And it will capture the returned output from the module (i.e. the parts you decide to export) and it will manage those too. In what way? Well, it keeps a registry of modules. That way, the system knows what it has to give your module when it asks for a.js and also what it has to give other modules when they ask for yours. &gt; Not only that, but having such a registry, that keeps track of what is loaded and available also solves the order problem. If it is in the registry, it has already been loaded. If not, the system can delay your requirement or your importing until that file is indeed loaded. &gt; Let's recap again. &gt; - You have a manageable code base, where the sources are split functionally into small modules. This is a very good thing. &gt; - You have a process or tool that: 2.1. Puts all the small files into one big file 2.2. Adds some completely generic utility functions that: 2.2.1. Take care of providing each module with any other modules it asks for 2.2.2. Solves the problem of order. &gt; Note that it's not only this. Really the dependency system can work with your code, whether it is encapsulated and bundled into one single file or whether it is left as separate files and loaded on demand when they are required or imported. As long as the system or the tool provide the mechanisms and understand the same syntax you gain that ability for your code. &gt; Now, this tool is something you can do yourself. But it would be much better it lots of people used similar tools and if those tools worked in the same way. That way, you could treat external libraries in the same way you treat your own code. So, instead of actually building yourself such a tool, you use an existing one. One of those tools is Webpack, though there are others. &gt; A final notice: Some of these tools, as others have mentioned, tend to take advantage of the fact that you are doing all those code transformations and bundling to offer doing other tasks too. Such as minifying your code. You know, compressing it so that it's smaller and is loaded faster. Or maybe they can even avoid including files which are not actually needed. Or the parts of files which are not needed. Or they can also process other assets such as CSS and/or images. Once you've agreed to have that tool or process as step in your workflow, well, why not make the most of it? &gt; So this, in a generic way, with many inaccuracies and over-simplifications, is what these tools (not only Webpack) are about. 
&gt; Thanks everyone for your kind responses. Ah... I don't know if I'd post this in a blog, but feel free anyone to post in your own if you so desire. You don't even need to give credit to some random letters and numbers on reddit xD &gt; But anyway, I had to stop but forgot to add a bit about how it really happens. I'll use Browserify because its simpler. Don't mind much the code itself, it's not a complete example. (Also, the following is not needed to just get a general idea, but it might help in understanding how it is done) &gt; Say one of my files (something called linkLoader.js) looks sort of like this: const xhr = require('../lib/xhr.js'); const dom = require('../lib/domUtils.js'); function loader(container) { const output = dom.printTo(container); xhr.get(href, function(content) { var { content, js } = dom.parse(content); // ... }); } module.exports = loader; &gt; I've removed most of the code. The interesting bits are still there. So, you run browserify on this file and it spits out a bundled file. I won't show all the result of that here because it's too big and noisy. But, this particular part gets transformed into something like: { 1: ..., 2:[ function(require,module,exports){ const xhr = require('../lib/xhr.js'); const dom = require('../lib/domUtils.js'); function loader(container) { const output = dom.printTo(container); xhr.get(href, function(content) { var { content, js } = dom.parse(content); // ... }); } module.exports = loader; }, {"../lib/domUtils.js":4,"../lib/fnbasics.js":5,"../lib/xhr.js":6} ], 3: ... } &gt; So it gets thrown into an object. This object will be passed to the function I mentioned that will execute each of those. As you can see, the transformation is mainly just wrapping the original code and extracting the dependencies that each module requires, for easier management later. &gt; It is interesting to note that your code then gets executed in an environment where you have access to three things: a require function, a module and exports references. This is basically all you need for your code to work and it is interesting that it doesn't really matter much what these are or how they work at a detailed level. Just that they do what you expect. This is what allows what I mentioned earlier: the actual loading can happen like it is done here, in a single bundled file or it could happen in some other way (e.g. by loading it on demand through XHR or from the filesystem or whatever). &gt; If you want to actually see what those things look like or what the general function at the start of the bundle looks like, you can have a look at the browser-pack package. But a general idea might be doing something like this. &gt; I have that object there with all those functions so forEach(key, module) -&gt; { funct = module[0]; dependencies = module[1]; registry[key] = execute(funct, getDeps(dependencies, registry) ); } &gt; This, of course is a very naïve approach. A real solution needs to take into account the availability of dependencies before they are used. It also doesn't really work like this at all in regards to that registry because your code does not return. Instead you add things to the passed module.exports or exports, but that's just a detail. &gt; Now, I've used Browserify because it is much simpler than Webpack. The output Webpack generates is similar in spirit. Webpack builds an array, instead of an object and wraps our modules into something like this: /* 1 */ /***/ (function(module, exports, __webpack_require__) { const xhr = __webpack_require__(0); const dom = __webpack_require__(3); // ... }), &gt; (The comments are there just for human debugging purposes.) As you can see, the main difference is that Webpack applies some transformations to your code while it is generating the bundle. The main transformation is that one you see with __webpack_require__. Not only it does change the name or require to that, which is a superficial change, while it is doing that, it also removes the reference to actual filenames and substitutes them for a simpler index number. In any case, the result is similar: All the benefits explained in the previous message are there. &gt; Also, as already mentioned, Webpack does more than this. This is all in relation to modules. But Webpack also includes other tasks which you might do with other software. Like compressing (minifying) the output file, or managing CSS alongside JS, or running a transpiler... Or a common one. As I mentioned there are mainly 2 different syntaxes for importing and exporting. The CommonJS (what NodeJS uses) and ESM (the ECMAScript standard), i.e. require('bla.js') vs import from 'bla.js'. While Browserify only supports CommonJS, Webpack supports both by transforming "at pack time" those imports into requires. (Note that this isn't correct. Webpack 1 didn't support import either, but Webpack 2 (and 3) does. And also, you can combine Browserify with other tools -Babel- so that they do the transformation and then Browserify does the packing.) &gt; Now, there is just one remaining thing you may be wondering about. It could be something like: "Well, now that there is a standard way to load modules, can't we just use that and forget all this about bundling it all into one file and just let the browsers load what they need?" &gt; The answer to that is not completely straightforward. Let's just say... &gt; - While there is a standard (mostly, some details still being heavily discussed), there has been no available implementation of it in any browser until... well, very recently. The very latest versions of some browsers are just now starting to ship with (some) support for ES modules. (See the warning at the top here). &gt; - So in the future it may be a way or the way, but for now, needing to support current browsers, the solution does seem to inevitably go through a bundled file or some similar solution that offers the functionality browsers don't. &gt; - There are also some other things that affect usage of all this. In particular, performance concerns and HTTP2 support may help or may not help going back to multiple independent files being loaded. This is a bit hard to determine yet, but it may mean that in some scenarios bundling all files into one (or a few) file(s) might still perform better. &gt; So the answer to that is a classic it depends. Or, if you prefer, it could be something like: "For now, bundling is a good idea in many cases. In time, we'll see".
I'd be curious to see the code. I'd love to build something on top of it maybe. Is it on github?
I'd have to disagree with the inline map, that's not more clear
I can tell you the comments in my personal work look like they came from someone with turrets. Other than that it’s about the same. Person stuff always takes longer then I think it will. Distractions happen. 
If your basic premise that "your code X is bad" wasn't based on a function that was temporary and 10000% acceptable as a marker for later framework expansion, I would agree with you 100%. I don't disagree with your ideals, but your method of when determining if they are relevant is way off. Plus, you made is disheartening as a bonus. 2/10 for your teaching style
Not working on mobile Chrome either.
I learned some swift before picking up JavaScript, and think it’s a great second language. It’s not too different syntactically either. You’ll learn a lot about static typing and type casting. I highly recommend the big nerd ranch book on swift, it teaches you a lot of the basics and tooling Swift is a really fun language, because you can quickly prototype apps and run them on your own phone 
&gt;Most of the OO languages inherit from C++ I see what you did there
`npm config prefix` should show you where they get installed. Then you can `ls` that directory or just copy the whole thing.
lol
[Tourettes](https://en.wikipedia.org/wiki/Tourette_syndrome) &gt; It was once considered a rare and bizarre syndrome, most often associated with coprolalia (*the utterance of obscene words* or socially inappropriate and derogatory remarks), but this symptom is present in only a small minority of people with Tourette's.
Whoosh.
As a junior I would want you to understand prototypal inheritance, a bit about the Node ecosystem (how to use webpack or gulp for frontend, how to use Express for the backend), and be competent at debugging some simple code. If you hadn't picked a solid camp to be in (react, angular, Vue) I would expect you to know why and to at least be able to work with older jQuery code. I wouldn't expect you to memorize library apis, but to be able to Google them to figure out what to do, given a simple problem. Will this be backend, frontend or full stack? That would also make the difference. 
What are you, his girlfriend?
Release fewer into the wild, only those you really have a passion to keep up and support. Have a lot of little libraries that are private to you. I wear short and workout pants around the house and when I work remote. When I go for an interview or client meeting, I dress up. Keep it classy.
See now you're assuming too much. This might surprise you, but there are some devs that love reading through code. You mentioned that it's a multiplayer framework, are you using websockets to push live updates, or are you doing something else? It looks like what you're using canvas. I haven't built anything major with canvas because I don't build games, so I'm curious to see what kind of techniques you use. There could be some genius level stuff that I'd love to use for my own apps. Stop being so defensive mate.
Maybe they meant machine guns.
"So build your SPAs, I don’t mind, as long as I don’t have to use them. Just be aware of what it is you’re giving up." Thanks for permission.
Now deploy it to GitHub pages. create-react-app makes it really easy to do, there’s a section in their docs that will show you how 
manually keep a list is too tedious
It's very unlikely you will do anything with C\+\+ as a web developer. That being said, it's not unwise to learn \_any\_ language. Every language you learn helps you understand the fundamentals of programming better, which makes you a better developer. Learn what interests you, as that will help your learning process. All that really matters is that you're learning.
As other people have mentioned, C/C++ are really great languages to learn. This library may be of interest to you. https://www.webtoolkit.eu/wt
Thank you! I actually hadn't considered making the API function a module that could just be called inside the handler but I can see how that would be more functional/modular
are you talking about your global npm packages? if so, you can do `npm list -g --depth=0 &gt; name_of_text_file_you_create.txt` this will output a list of global npm packages without each of their dependencies and put the output in that text file
Not working at all on Firefox for Android.
As someone who has been interviewing a lot recently for junior - senior positions (and we're not a Big N). We don't have 100s of positions to fill, we have 5. So we're looking for personality as well as eagerness to learn; balanced with how much they already know. From the phone screen, we know about where the candidate is. I think it's on the interviewer to tailor their questions to the candidate. Personally, I don't care about react, angularjs, etc. when interviewing (if you know them, great). I'm going to show you JavaScript and ask you to review it with me. I'm going to ask you questions about it and I want you to ask me questions about it. It's okay if you do not know something or understand thing or what something may do. If you don't know something, I'll rephrase and try to ask you something that leads you to answer or asking a more focused question. If you know NPM, grunt / gulp / webpack, and that whole clusterfuck, that's great. But I'm not hiring NPM maintainer, I'm hiring a JavaScript developer. If you want to learn how to deal with NPM and it's insanity on the job, wonderful! You can take some of my responsibilities. If you understand what `this` is, and how `.apply()`, `.bind()` and `.call()` are used, and what closures are, well you're miles ahead of many developers I already work with. /u/Timothyjoh mentioned prototypical inheritance. Not a bad thing to know, but how often it comes up in day-to-day work may be company specific. While I do think it's important, not for a junior dev.
I was trying to draw a parallel for what OP would be thinking of your comment, rather than defend my own work, I love a shitty prototype! I'll definitely post it eventually, it is mostly formed around a robust data structure, almost totally data driven. The only real objects that aren't database related and the socket objects in the server that contain most of possible client events. But it's a turn based game so I don't really have to face critical lag issues like other games 
Funny enough - over the years, my personal projects have become more well-documented than work projects. Mostly because it maybe months between updates and I need to remember where I was and where I was going. My git commit messages have benefitted though. Now if only I could get my coworkers to read them. I have decided that my github contributions and commit messages only be written while on shrooms. Trust me they're better.
I would go back in time, re-write how NPM actually worked and stored packages then go from there. It's like NPM purposely ignored every good lesson from central library management and asked, "how can we fuck this up?" and did it.
Works on a Pixel device just fine.
Seems entirely subjective, looks way better to me
Eloquent JavaScript 
Closures. I liked JavaBrains tutorial on this on YouTube. Prototypes. Google just yield some good results. Asynchronous programming. One of the top things I encounter when working with JS. ES6 + features
I agree with native fetch, it's so easy to use, why add a library
A commonly used test is fizz buzz, look it up or watch this video for an explanation of what it is and why they ask it https://youtu.be/QPZ0pIK_wsc
On the other hand, when a company needs C++ for the backend the front and backend developers are in completely different teams. Full-stack developers are mostly useful at small companies. 
Wow, what? The whole point of functional programming is that they can be replaced easily. You’re nitpicking about developmental code like it’s a pull request on Github. That function might get more complex in the future, but for now he’s testing output from a function to see if the consuming code is working. You are totally not picking your battles here. 
It completely depends on what you want to do: * Write macOS or iOS apps: Swift * Systems programming: Rust, Go * Native-ish mobile apps: JavaScript plus React Native * Functional programming with JS syntax and lots of potential in the future: ReasonML * Etc.
Thanks! They basically chronicle what I learned, coming from Java (and Python, Scheme, Haskell, C++).
https://system-gql.now.sh/ | A graphql interface to query system infromation [WIP]
Seconding this, but I'd like to supplement with some explanations: A Maybe is the set of two types: Just and Nothing (similar to how a Boolean is the set of `true` and `false`), which can both be thought of as "containers" with a `map` method. A Nothing contains, well, nothing, and mapping it will always return the same Nothing, usually representing an error value, while nicely avoiding null reference errors that would occur from the `map` function otherwise. A Just contains an actual value, and mapping over it may return another Just with a new value, or a Nothing. Extracting the value from a Maybe is usually done by providing an alternative value in case it is a Nothing. Consider how `Array#find` returns `undefined` if the predicate function doesn't match. If you try to use the value without checking it you'll likely get errors. You can make a find function that returns a Maybe, and map over the return value, knowing that even if it the value wasn't found, you won't encounter errors. An Either is similar to Maybe, but is the set of two different types, Left and Right. A Left is similar to a Nothing, except it can contain a value, but mapping over it will always return that same value. A Right behaves basically the same as a Just, but will return a Left or Right. An Either is handy when you want to a more descriptive error case rather than just Nothing.
Use either yarn-lock or package-lock.json, not both.
We've just hired a junior at our place, and while I wasn't involved in the interview process, I can vouch for everything you just said. We were looking way more at character, resourcefulness, and eagerness to learn than we were actual development skills. 
Html: id="btn" Js: btn.onclick = function () { Console.log("test") ; }; 
I believe this works https://stackoverflow.com/questions/24025165/simulating-a-mousedown-click-mouseup-sequence-in-tampermonkey/24026594
Is it QA or you forgot to write a function? 
$( "#btn").click(function() { console.log( "something happens" ); });
Looks really impressive, sorry to ask, but what’s shunting yard and postfix? How did you implement them?
Maybe not entirely different spheres with the increasing popularity of web assembly. Rust is also a great choice!
With laravel and wordpress around, php isn't going anywhere.
Okay. Look. If it's too much for you, then just try remapping the `querySelector` and `querySelectorAll` the way shown in /u/CertainPerformance's answer from yesterday and see if you like it. An ES5 version of what he wrote looks like this: var qs = function(s) { return document.querySelector(s); } var qsa = function(s) { document.querySelectorAll(s); } // this will return the first element matching #app var appElement = qs('#app); // this will return a node list of all elements matching .section var sectionElements = qsa('.section'); But putting this aside for a second, what you are asking here is for JS to look and behave exactly like jQuery. If you can't be bothered to take the time to learn the latest browser API standard -- which have been just [waiting there for you to discover](https://developer.mozilla.org/en-US/docs/Web/API/Document) literally for YEARS -- and if you find JS too verbose and counter-intuitive anyways, then the answer here is so simple: import jQuery into every new project and bask in its radiant brilliance. It looks like you're happy living in the Cretaceous Period and no one ever said you have to leave.
Hmm yeah I see that now, not sure how i feel about this though! Not exactly the most readable code. Either way thanks for the explanation!
It might have been good to mention how "this" works differently in arrow functions? I'd give an extra 30 seconds for that ;)
Serious question, but Is Jquery really necessary? I know vanilla JavaScript and now I’m learning react/redux. Every time I try to learn jquery I get hella bored and I don’t ever need for the projects i work on.
It's a convenient shortcut that takes an entire block of code and expresses it in a single expression: a = b &amp;&amp; c versus if(b) { a = c; } That's a very useful shortcut when you're only testing whether `b` is truthy, which we do a lot in JS as we don't have a [safe-navigation operator](https://en.wikipedia.org/wiki/Safe_navigation_operator) and have to check the existence of an object before we can use it.
It's a convenient shortcut that takes an entire block of code and expresses it in a single expression: a = b &amp;&amp; c versus if(b) { a = c; } That's a very useful shortcut when you're only testing whether `b` is truthy, which we do a lot in JS as we don't have a [safe-navigation operator](https://en.wikipedia.org/wiki/Safe_navigation_operator) and have to check the existence of an object before we can use it.
I actually think this is a pretty bad junior dev question because it has no important aspects that I'd want a junior dev to spend their time studying. It's a specific algorithm without CS principles behind it. I'd prefer something like parsing and evaluating hungarian notation expressions. Anything that has a person re-create basic compiler functionality without them knowing will show me if they have basic cs information. 
I have used pjax before with Rails. I personally think that it has its uses and that if it is used correctly, it's a beast! A lot of rails devs in our local meetup wanted to remove it from rails 4.0 when it came out (long time ago lol). Lots of arguments were hurled re: how hard it was to execute against onDOMContentLoaded / $(document).ready() However, I've found that it isn't actually that hard to think the pjax way. You basically assume that JS scripts and listeners are registered on the global scope, with the body HTML the only thing being swapped. With that being said, it is entirely up to the developer to responsibly add and remove listeners in page transitions (or avoid them altogether by using event bubbling) Thanks for your comment!
Just adding what I've learned so far: 1. Using a cdn gist, I loaded the following script before actual page content: ``` for(var x = 0; x &lt; 50000; x++){ console.log(x); } ``` 
The problem lies in the `data-disabled=""` that is set on all the inputs. Even on the ones that are not meant to be disabled. I think think this is a bug. This also causes the dropdowns to be 'disabled' on both Firefox 58.0.2 (mac) and Safari (iPhone and Mac)
I was hoping it was a new form of defensive programming based on Tower Defence games :)
I assume you'r talking about the technical job interview? The state of Javascript interviews is quite sad as interviews seem to target best practices that were used before ES6 / Typescript became popular which makes it really hard for junior developers (who didn't develop in JS at the time). Things you should learn (by heart really) are: 1. Prototypes 2. Closures 3. Immediately Invoked Function They are rarely used these days but come up in more interviews.
Not a big leap if you learn the fundamental properly rather than randomly programming on different swift frameworks. I can say, if you ever touch Swift server side, try to reduce technical debt by using popular web server to do all the traditional web stuff, swift to do all the contents generation. There is no point to write all in one language. You can learn Functional CSS too.
I found [this](https://medium.com/@thejasonfile/fetch-vs-axios-js-for-making-http-requests-2b261cdd3af5) a little while ago. It explains some advantages of using axios(which I've personally fallen in love with) over fetch.
Thank you so much, it work 100%
Works fine for me?!
Yeah I suppose when you put it in those terms - i can see the argument for using it, but I would argue that a ternary is more readable just because `a = b ? c : undefined` isn't much longer and there could be no confusion about the double usage of &amp;&amp; - I guess it comes down to coding standards an just making a decision as a group of devs and sticking to it
I can't think of a perfect solution to this exact problem, but if nobody else can then as plan B you *could* write a babel plugin to collect all the calls to `allocate` and find all the unique keys in the single object arguments to these and convert that to an argument list. Idk maybe someone has even done something similar to this already? I think you'd probably want to use babel 6 for this due to the more flexible way you can operate on multiple files, but it's very possible I'm wrong there - I'm by no means a babel expert and I'll happily be corrected by someone who is.
If all you want is for your IDE to tell you what the parameters are, use jsDoc doc blocks. Don't invent your own thing here. If you've got other reasons... If you want to avoid allocations, you make a pool, right? So can you make a pool for the objects that you're going to pass into the function, and keep re-using them as needed. Of course, that'll have its own messy problems, but it solves *this* problem.
I like the facts that it has a documentation and not only examples and it is written in ES6. But I found it was difficult to me to use it because of .mjs extensions instead of .js (I am a beginner Babel and Webpack user). I wish it could prevent tunneling too.
JQuery is practically syntactic sugar now. Earlier, it was mainly needed for standardized APIs across the browser wars, but now, inconsistencies are few. However, it still reduces a lot of typing overhead with coding. I still prefer vanilla JS for new projects, but convention where jquery is used. It's just another library. It just abstracts out the browser's apis.
&gt; because it has no important aspects that I'd want a junior dev to spend their time studying Except it tells you if that junior _actually_ knows how to program. I mean, I had an interview with someone who was _perfect_ for the job - in theory, because when presented with "FizzBuzz" all it came out was "i don't know how to do it"
I believe it enforces certain principles of programming (including the need to keep types in mind) that can significantly improve the quality of your code in a language such as JavaScript, too.
True, but a wedding out question for me has to test their ability to conjure up and think about solving a real car problem. This would tell me if they ever sat at a computer and learned basic programming language syntax, but I always think it's better to test their ability to put CS theory into practice
The point isn't always the result.
You are assuming they are using Babel, but given performance is an issue that may well not be the case
Lambda functions exist in many languages. In Python this "implied return" is commonly used in list comprehensions `squares = [x**2 for x in range(10)]` or list sorting, filtering, mapping etc `list.sort(key=lambda x: x.someAttr)` .. So this addition in javascript was very welcome for me at least.
... What would you use as a weed out, then? because we're talking about a junior here and... juniors are like John Snow :p
The most "obvious" solution coming to mind is having customized constructors(allocators) for the parameters you either need to repeat, omit, or such. More functions, basically. And that can pave the way to closures acting as partials. Partials can be pooled, as well, so... I guess this could help?
Doesn't actually detail how it works, here's all the points it fails to mention: * How do returns work. * How does 'this' behave. * It fails to mention the parens can be omitted if the function takes one argument.
I was a JavaScript developer first then learned c++, and I wrote a [JavaScript/C++ Rosetta Stone](https://github.com/Jeff-Mott-OR/javascript-cpp-rosetta-stone#javascriptc-rosetta-stone). I liked that c++ was a lower level of abstraction. All the other mainstream web languages -- js, python, ruby, php, and even c# and java -- sit pretty close to the same level of abstraction, so it was fun to discover the machinery underneath. Also the folks I read and learned from such as stroustrup and herb sutter are very knowledgeable, not just in c++ but in programming in general, and I learned a lot from them. The more I learned about c++, the more I liked it. It's multi-paradigm and doesn't try to be religious about one paradigm over another, and it's made a lot of good decisions that have held up over the years. But that being said, C++ indeed is not nearly as useful for daily web development work. Whether you choose to devote a few years to learning C++ very much depends on how satisfied you are with your current job and what you would like to do in your next job. 
The module pattern. http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html
&gt;Of course, that'll have its own messy problems, but it solves this problem Javascript in a sentence. 
Why the down vote? The problem is there
I don't know much about performance of code that Babel produces, but if it was limited to this one transformation it shouldn't have any overhead.
Yup, Typescript type annotation could solve this problem for you.
Nice article. Also found it a bit over engineered, though. Some thoughts ... &gt; Now let’s create the ArticleServiceFactory It seems the obvious choice would be to create an ArticleFactory, so I believe you need to explain your thinking here. Why do we need an ArticleServiceFactory, as opposed to an ArticleFactory? We obviously need multiple Articles, but why do why need multiple ArticleServices? import {ArticleServiceFactory} from "../domain/ArticleServiceFactory"; const articleService = ArticleServiceFactory(); const article = articleService.createArticle({ title: '12 rules for life', author: 'Jordan Peterson' }); const incrementedArticle = article ? articleService.updateLikes(article, 4) : null; A more common way to write this would be: import {articleFactory} from "../domain"; const article = articleFactory.new({ title: '12 rules for life', author: 'Jordan Peterson' }); article.likes += 4; In your article I'm missing a reason why not to write it like this. If I'm not going to write a piece of code in a standard way, I want to know why. Also, don't return null from factory functions. Imagine you're part of a team working on this and your colleague implemented the factory. You write some code creating a bunch of articles, but suddenly you get an error because your article reference is null. Why is it null? I used a function called createArticle, why isn't it creating an Article? At this point I have no choice but to look at my colleagues factory implementation and x mins later I know what's wrong. This is easily avoided if the factory function threw a ValidationError for example ("Article title must be string length &gt; 0"). &gt; The state represents every piece of data that changes in an application. &gt; The state should be immutable. I realise "state should be immutable" is a mantra of sorts in the js community, but the above statements are really contradictory. If your application state is immutable, it cannot change, by definition. IMO, working with immutable objects does not make your state immutable. It's just a matter of *how* it's mutated. But this could just be semantics, I don't know. 
VB.NET writes it as AndAlso while || would be OrElse.
&gt; Obviously, we cannot use this. Have you tried it? With allocation/store sinking optimizations, all those temporary objects aren't actually created.
Have you included the external script file in a &lt;script src="path/to/script.js&gt;&lt;/script&gt; tag?
Can you put the code on jsbin or codepen and give us the link to it? I know it is PHP so if you put just your HTML it'll give us an idea what you're doing. How are you referencing func2 in the other JS file? 
Don't forget to clear your timeout, other wise it will still call the rejection
Thank you for writing this!
To learn after js
Thanks
The point is that it’s such a simple problem, with multiple ways to fix. So you can really see how they break the problem down and attack it
Don’t bother with PHP. I would suggest starting with C++ to learn the fundamental mind set you need to be in to be a good programmer. After you get that, you should move to more friendly languages such as Java.
Currently in school, as well as working p/t as a junior c# dev. I started with js and python, school was my first time touching java, and work was my first time touching c#. I gotta say I love c#, java always feels ugly and clunky to me. But they feel similar, with c# having nicer features in my experience. But both have definitely made me like js a bit Iess. Once you get used to method signatures and strong types it makes reading code way different, tho I do miss var in c# when just trying to create a random temp variable in java
I'm a developer, not a writer. Just tried to make it a little bit more interesting. Is there anything in particular that is over the top? I can edit the post.
I think C++ is a noble, efficient language but If you want to learn OOP you should start with JAVA, it's easier to learn the basics with JAVA. IA and machine learning can be done with JAVA too (Tensorflow has a Java API for instance) it's not a field restricted to C/C++, a lot of IA engineers use python/java.
&gt; Search field is not autofocused. Therefore, users have to take one hand off the keyboard and place it on the mouse to select the search field and then awkwardly start typing search term with the other hand This is pretty normal for sites. pypi (pythons package index) and Go's package repository don't autofocus the search box either. &gt; Autosuggestion algorithm has a strange tendency to favour packages that are no longer receiving updates This definitely is odd (if true). IMO there's not enough data in the post to conclude whether or not this is true. From my experience their autocomplete is pretty relevant. &gt; The final flaw is that you'd only need to hover the wrong suggestion to be taken to its page. It is quite natural to hover as you have one hand on the mouse already. This seems to create a feedback loop for the training algorithm that amplifies the initial erroneous guess. This goes both ways though. If I hovered over your package and hit enter it'd go to yours. While definitely an odd UX choice I don't see how this is relevant. 
Yeah same thing happened to me. Using the HTML onClick function only worked when I typed the code inline &lt;script&gt; within the same HTML file and did not work when linking to a external path to the .js file. Haven't went back to figuring it out so it's sitting inline for the moment.
That's a good one. I didn't even know it's called Module Pattern :).
I don't understand the downvote party. If you bury this it would make sure that it will never be fixed
Which browser(s) have shown this behavior? And yeah gona need full code
I'm doing this because I care about NPM and want it to succeed.
I would think if you are at the level where you are using pooling for optimising, letting Babel transpile your code into a 'shape' you do not control would not sit well. And if it's run on node / modern browsers, it doesn't even need transpilation for most things anyway.
One more thing is that you don't need to hover when you press enter. You move cursor away and the highlight is gone but you you'll still go to the package last highlighted ( typically the top one )
1 + ‘1’ = ‘11’ .......
Release early, release often. Multiple times, I've built a tiny proof of concept of a tiny thing I needed, and then immediately released it and started using it and ignored all the other things I _could_ do. Once you've released it in a minimally useful state though, you'll find that other people eventually find it and starting using it too, and if you're lucky (and you've genuinely built something useful) some of this maintenance and further work will get done for you. I've definitely had people put PRs into tiny projects I haven't touched in months, updating dependencies and fixing small bugs here and there. This isn't useful advice for all cases though. If you're thinking about releasing a little npm package, definitely, but if you're building a larger project it's much harder for other people to get involved. You can embrace that though! If there's a big thing you want to build, create lots of small projects along the way for the components you'll need, release them separately as you go, and build towards a world where your end goal is easy. Or even better, PR them as extra features to existing libraries that _nearly_ do what you want. Hopefully that'll encourage other people in along the way, to help maintain and extend these components en route as part of whatever they're building, but even in the worst case at least you've shared some useful small components &amp; features that can help other people in future.
Contributors welcome!
So true.:-):-):-)
It could have been a caching issue. Glad you got it resolved. 
I suggest Netlify over github pages. It's free and they have a ton of features that make it a no brainer.
Is it giving them an aneurism? My technical interview questions are generally custom built problems similar to fizzbuzz which came up during my normal work days. I’ve still had candidates completely melt down. I wonder how many would melt down who could actually handle most work once they were through the stressful environment of an interview. I want to know if they can write code. Then I’ll have a conversation about design patterns, specific frameworks, tools, CI pipelines, etc. Even if these just heard about these things, just having a chat with them about this stuff gives me a feel about what working with this person would be like. 
These implementations have pretty poor performance, they create a lot of unnecessary waste that has to be cleaned by the GC, you can't pass a comparator function so you can only sort arrays of numbers.
You don't need to learn jQuery anymore. It's good to know what it is and why it exists and you might encounter legacy code written with it but I wouldn't waste my time if I was a junior.
I want to know this as well. Arrow functions are the best, and I'll fight anyone who says otherwise. You should be using them in all modern browsers... and you should be using them anyway in older browsers (with transpiled code).
&gt;so much you can do in C++ that other languages don't allow you to do Often with pretty good reason...
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [facebook/create-react-app/.../**README.md#making-a-progressive-web-app** (master → 0b1d636)](https://github.com/facebook/create-react-app/blob/0b1d6365768ae3bd267b042b74bab249673f1a9f/packages/react-scripts/template/README.md#making-a-progressive-web-app) ---- 
I just came across this the other day and it looks good. Lots of stars, so I would bet at least some interviewers are using it. https://github.com/yangshun/front-end-interview-handbook As someone who interviews people myself, the most important thing you need to learn is how and when to say "I don't know". The number of candidates who try to guess or bullshit me is surprising. I know JS already. Or I at least know the answers to the interview questions. I will probably be your boss. And you're basically showing me that when you don't know something you're going to try to cover it up and trick me. I rarely even finish the interview after that. Which is why I sometimes start with a really hard questions. Here are some great alternatives: "I've never seen that. Is it common and should I learn it? I am a junior programmer so of course I expect I'll have to learn a lot and I will work hard at learning." "I don't know and I'm not even sure how to approach it. Can you help me understand this better and I'll try to answer." "I don't know but I'm willing to try guessing if that's ok, or we can just move on if you want but first I do want you to know I'm willing to learn." Etc. Just be honest and follow your feelings. I don't even care if you say "I have no idea what that means and now I'm feeling like I might not be qualified for this job". Great! I'll reassure you at that point because you just impressed me with your honesty and that you aren't afraid to communicate about emotions. You might be a great teammate. One final thing that has helped me a lot when I'm interviewing for a job is to pretend it's my first day at work instead of being on an interview. It takes off the pressure and makes it more of a cooperative conversation than a test. You can even try to steer it that way (at the appropriate time), which I'll do. "These questions are fun but if you have time I would like to understand more about what I would be doing on a day to day basis so we can figure out how my skills can contribute and where I might need more training. Do you use git? I've been studying up on git a lot and am curious what your git workflow is?" Whatever they answer, it naturally leads to a conversation about your first work days: "Oh, I've never heard of that git work flow. I would be interested in learning that. Do you think it's important for me to learn that before I get into coding assignments or would I be doing more coding at the beginning and someone will just hold my hand with the git workflow?" Now the person is starting to visualize you as an employee on the job and how they are going to train you. You've got a half of a foot in the door already! Good luck on your interview. 
"Done is better than perfect" If you pretend to show your personal project code in interviews, take care to be as much professional as possible. But if you just want to test an idea or something, give yourself a deadline and do your best to deliver on this date (more or less professional).
But you could configure Babel to run just this one transformation, couldn't you? 
&gt; there's no reason not to use a service worker In case of a frequently updated dynamic web app, what is your caching strategy for the service worker file itself? Lets say i want the users of my app to see the latest changes. Do you set a cache policy max-age of 0 for the service worker file so that it keeps fetching the latest version if available? 
This is how I just got hired at my second full time position. Excellent advice
I have the same problem, a graveyard of unfinished apps. What helps for me is having someone else on board, with two people working it's easier to stay driven to do your share.
"Done is better than perfect" If you pretend to show your personal project code in interviews, take care to be as much professional as possible. But if you just want to test an idea or something, give yourself a deadline and do your best to deliver on this date (more or less professional).
I didn’t realize java was something else, i thought it was just short for JavaScript 
Thanks, I'll check it out. Maybe this is why we use it at work! 
Hey, I'm just researching and working on PWA technology. Here is a list of quality resources on the subject: PWA Sources: - [Overview and guide to working with PWA](https://scotch.io/tutorials/the-ultimate-guide-to-progressive-web-applications) (scotch.io/tutorials / 2017) - [First PWA](https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/) (developers.google.com) - [Service worker life cycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle) (developers.google.com / 2017) - [Offline PWA Cookbook](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/) (developers.google.com) - [WPA slide show presentation](https://docs.google.com/presentation/d/1cdSdsHGqE1nGicoeJSO8JItZ_eMIDoaV9PUcy3yOESU/edit#slide=id.g19871a91a0_0_284) (docs.google.com / 2016) - [React build bundle with lot of DRY value - git](https://github.com/facebook/create-react-app) (github.com / 2018) - [React build bundle with lot of DRY value - blog](https://reactjs.org/blog/2017/05/18/whats-new-in-create-react-app.html) (reactjs.org / 2018) Offline Storage Sources: - [Offline storage solutions overview - Cache API, IndexedDB, Web Storage](https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/offline-for-pwa) (developers.google.com / 2017) - [IndexedDB API reference](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) (developer.mozilla.org) - [LocalForage = an offline storage JS library](https://localforage.github.io/localForage/) (github.io)
How do you suggest I go about making it better?
Good to hear. All they did was create a couple of 'meh' production service worker registration functions, which are not all that useful in development, when you kinda need to verify your service worker actually works as intended... I usually replace it first thing.
Check this for all Fron End Interview Questions. https://github.com/yangshun/front-end-interview-handbook And this https://github.com/h5bp/Front-end-Developer-Interview-Questions
I would use Object.assign(). It would seem suboptimal. But remember that it is executed natively. C++ faster than Javascript.
you manage service workers completely different than you would browser cached items as they have their own lifecycle that you use to register/deregister/update them. see [this](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle) for more info
Thank you, I realised I forgot to turn off disabled option when initialising library and somehow it worked in my browser because CDN cached older version without disabled option support. Well, it should be working now as it is supposed to work. Also I replaced CDN link with local to avoid this cache bug.
There are specific methods for determining worker caching, the don't get treated the same as regular web assets.
Should be working now, forgot to remove disabled option from initialization.
Should be working now, forgot to remove disabled option from initialization.
Coding tests out of all of the tests I've given are always the most stressful. I've given very simple questions and still have had nervous messes in the interviews. I don't think we can change that reaction. Also we have multi-panel interviews (for better or worse) so there are many eyes on a person's mannerisms and how they mesh with the team.
Have you measured the performance of your code and found that this is an issue? **Do not optimize anything without hard data.** "I think this might be slow" is a mistake, compilers do things you can't even imagine, so just because something looks like it allocates doesn't mean it does.
I'll take that into consideration, again, I have had very junior developers get through much of the first part of my tests without knowing fundamental CS points but knowing how to do loops, ifs, etc. I've guided someone who's had no experience to a better answer than I think they would have if they sat on their own and did it, so I just don't find that a weeding out question has to take up the time that I can get to know how good a developer they can be, especially mentored. I'm constantly trying to find a way to make the test have "tiers" for this kind of thing. I think for junior levels being in a more pair-like environment helps, but I've seen the more experienced devs fail on the CS part of the test.
For building an offline ready app that has centralized data, have you looked into or found anything for syncing? I've been trying out pouchdb, and am working on a Docker setup for a node app + couch db, but i'd much rather use PostgreSQL with a REST backend vs exposing couch directly.
Yeah... most of my hires were actually 3rd and 4th year coop/interns that we had a fairly large pool to select from. We generally didn’t want to hire folks that require 100% pairing time and hired 2-5 per semester. The quick screen and then just trying to talk to them for a half an hour was pretty much enough to know if they’d be a fit or not. We had a 15 minute written test with a SQL question, some basic HTML/CSS questions a simple fizzbuzz type problem and a “can you tell me the output of this code” which contained an anonymous function. This screen produced probably only one “bad” developer in 25 or so students we had come through the program; and they were the only one we ever interviewed 100% over the phone, so the test was a little awkward. We ended up with some fantastic students that were subsequently hired full time after graduation and are now running teams of their own.
Taking a look at the vast amount of solid implementations of these algorithms and justifying how/why you deviate from the approach they take would be a start. So would looking up not just time complexity, but space complexity as well (and actually benchmarking your functions). A library of algorithms is really not the place to write "pretty" code. Also as has been mentioned, adding comparator functions to the sorts would go a long way in making this actually usable. Most real applications are sorting arrays of strings or objects or complex data structures, not just simple arrays of numbers.
I guess that's the difference, I've never dealt with hiring interns as of yet in this job. So Junior for a fulltime position I would hold in a different regard than an intern. Makes sense.
Where I’m from, the government subsidizes 80% of intern salary, so it’s pretty crazy for us not to hire them.
https://developer.mozilla.org/en-US/docs/Web/API/Console
There's something that's pretty unique to C++ that most non-new (~5 years) languages don't support well: value semantics on complex objects. Java, JavaScript, C#, Python, and others strongly tie the object model to reference semantics. Learning value semantics will teach you to think in a different manner. Likewise learning a mostly-functional language from the lisp, haskell, or ml families would also teach you to think in yet another different manner. Expanding your mind like this will help you tackle more complicated tasks.
I did try console.log(); I doesn't really work as expected.
I added a pastebin link, if I wanted the output/value of this: g = Cryptography.hash("SHA256", g, null, a.iterations); How would I do that? console.log(g); does not really do the job
For pure REST API backend you can easily use whichever stack that suits your skillset/interest. But make sure you enable CORS so the client (browser) can get the data if it's online. Simply call your API endpoints from within frontend code. Security should be implemented using at least HTTPS. Use service workers for updating actual application. I actually had a similar issue. My app relies heavily on third party REST APIs, but most of them do not have CORS enabled. My current experimental architecture includes a static React application (PWA client using service workers) and a proxy server running on node.js that adds CORS headers to encrypted API responses. Those API responses are then formatted and stored for offline usage with IndexedDB offline storage on clients device. But this is not actually syncing, just updating data based on age and connection status. I tried really hard to change my mindset and came up with a bold idea - eliminate third party server and centralised data containers, let the user be sole owner of his data. This mindset heavily correlates with current blockchain/decentralisation hype, but it is also perfectly valid way of development from technical standpoint and security. Why not create users accounts on their devices and make sure they only send needed authentication data? This was really contra-intuitive for me, since I always advocated that backend should do the heavy lifting and client should only be used for rendering templates passed by backend. But this does not need to be necessarily true anymore with tools like React and Angular. This will obviously not work for every application use case. I am still not sure if it will work for mine. But I am sure it's worth investing some thought and time. I think Google is trying really hard to make browsers default platform for running everything, but at this stage hacks are inevitable. Hope this helps.
All your sorting algorithms should be able to take a comparator function just like [array.sort](http://devdocs.io/javascript/global_objects/array/sort). To improve the sorting functions memory performance use in place sorting, taking your quicksort implementation for example: 'use strict'; /** * Performs quick sort. * @param {number[]} array - The array to be sorted. * @param {(a,b) =&gt; number} [compare] - A function that when called with a set of elements determines the order they should go in * @returns {number[]} - The sorted array. */ function quickSort(array, compare) { const result = array.slice(); if (result.length &gt; 1) { quickSortPartition(result, compare, 0, result.length); } return result; } function quickSortPartition(array, compare, low, high) { if (low &lt; high) { let pivotLocation = partition(array, compare, low, high); quickSortPartition(array, compare, low, pivotLocation); quickSortPartition(array, compare, pivotLocation + 1, high); } } function partition(array, compare, low, high) { let pivot = array[low]; let leftWall = low; if (compare) { for (let i = low + 1; i &lt; high; i++) { if (compare(array[i], pivot) &lt; 0) { leftWall++; swap(array, i, leftWall); } } } else { for (let i = low + 1; i &lt; high; i++) { if (array[i] &lt; pivot) { leftWall++; swap(array, i, leftWall); } } } swap(array, low, leftWall); return leftWall; } function swap(array, a, b) { let tmp = array[a]; array[a] = array[b]; array[b] = tmp; } module.exports = quickSort; This implementation only makes one new array in order to not trample the old array, i made this implementation a bit simpler than it ideally should be, in order to make it easier to read, for ideal performance you would want to eliminate the swap function in favor of in-lining its actions.
They could have done import ‘somewhere’ with { something }
Typically I will use a state machine. When the user loads the page, variable navOpen will be false, meaning the nav is not open. In other words, it is closed. When they click the nav button, it will change this variable to !navOpen. This will set the navOpen state to true, meaning the nav is now open. If the user were to click it again, the navOpen variable would now be false, meaning it would be closed. So the function when a user clicks the toggle to open and close the nav would be something like... function toggleNav() { navOpen = !navOpen; } You would then check the state of navOpen and fire your open or close nav functions inside of this new toggleNav function. function toggleNav() { navOpen = !navOpen; if (navOpen) { openNavFn(); } else { closeNavFn(); } }
Not the OP but I have experience interviewing for jr/mid-level JS developers and looked for almost the same thing as OP. My reasoning was that if you can explain to me how those things are used, you actually understand what _closures_ and _scope_ mean inside of JavaScript and have ran into an issue enough to create your own mental model of how it works. I wouldn't force a jr developer to know these things but I would assume any mid-to-senior developer to be able to know this inside and out. I hardly use inheritance directly ( maybe some `extends React.Component` here and there ) but often times mess with third-party OOP code that I want to ensure have what I want as `this`, without needing to care about how the OOP code really works.
And did you put that console log right beneath the line you want to see the output for? I don’t see the console log in the code you posted anywhere. If possible let’s see the code that isn’t working for you.
Of the 1,000 personal projects I’ve started over the years, I’ve probably gotten 2 of them to a place where they’re actually useful. Wouldn’t worry about it too much. 
I was interested in learning sorts a while back, so I implemented a bunch of variations and benchmarked them ([shameless plug](https://github.com/mtraynham/sort.js/tree/master/lib/quicksort)). As /u/filleduchaos mentions, algorithms are not meant to be pretty, but performant. You often result to using a bunch of *tricks* to get things really fast. To get an idea, I ported Android's array sort implementation. It's [a dual-pivot quick sort with a sorting network](https://github.com/mtraynham/sort.js/blob/master/lib/quicksort/sortingNetworkDualPivotQuicksort.js). It does multiple pivot swaps during a single iteration and falls back to insertion sort for partitions less than 32 items (typically insertion sort is the fastest for small arrays). It's not the cleanest code, but it was the fastest. I quickly learned, sure I could write a pretty basic sort implementation given any reading, but writing a *better* sort than what's out there, is almost a full time job :P
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [mtraynham/sort.js/.../**sortingNetworkDualPivotQuicksort.js** (master → 19b7f43)](https://github.com/mtraynham/sort.js/blob/19b7f433f06971c457ef84f184c01f79ad9972ea/lib/quicksort/sortingNetworkDualPivotQuicksort.js) * [mtraynham/sort.js/.../**quicksort** (master → 19b7f43)](https://github.com/mtraynham/sort.js/tree/19b7f433f06971c457ef84f184c01f79ad9972ea/lib/quicksort) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dvj7zp9.)
Yes, indeed we measure a lot, this is the usual disclaimer that applies to all performance-related questions. It turns out that V8 and SpiderMonkey do not optimize all such allocations, which creates noticeable FPS drops. Safari is even worse. We've also experimented with Emscripten, but it's performance varied with environment too much, and in many of them didn't perform as well as hand-written JS. WebAssembly is not supported in older runtimes, so we cannot use it either.
It doesn't prevent an allocation, though.
We are actually open to using Babel, because it would allow us to implement this and also other optimizations and conveniences. It's a pretty big decision, though, especially if we use custom syntax (our team gets bigger and bringing new developers to this code base would become harder). Our app is also programmable by our target users, though their code can be pre-processed as well.
Yeah, we tested it a lot. Unfortunately, these allocations are not always optimized (this varies with environment) and cause freezes noticeable with unaided eye, which is an issue.
Yeah sounds like you and i are on the same page. I was going to cut out HTTPS here since i'm not worried about private data. It's a side project I'm using to learn more tech. I'd add lets encrypt as a sort of a plus once I get everything else working. But is 100% required if I were to suggest the pouchdb as an option for a work project. Not even a question at that point :). The couchdb replication &amp; syncing is the main attractor for me. I'm not too worried about writing an offline store for redux, or even using some other ones out there. But being able to login to the site via your phone or your desktop, and have everything sync up has less options :)
What kind of js have you been writing? Might be more useful to tackle a different problem but still use js to do it. For example, if you've only done frontend stuff, try writing some backend stuff with NodeJs
Just for the record, using inline event handlers is bad practice and results in poorly factored, hard-to-manage code (such as what you experienced). Seriously consider attaching your events with JavaScript, instead, eg: https://developer.mozilla.org/en/DOM/element.addEventListener
We use it for offline-first applications, mostly for providing images stores in IndexedDB.
I prefer explicit control statements (or ternary) too: https://github.com/airbnb/javascript#control-statements--value-selection
You don't *need* any of it. You can use a Turing machine made out of pencil and paper to write any fully functional program possible if you want. But you might want to develop some curiosity around why people think they need these things. If you can name some of the things you have never needed to know, I can tell you what problems they solve and why JS shops might be interested in hiring someone who knows those things. 
[removed]
TypeScript can give you entirely compile-time checks without any changes to the runtime code. There's a bit of boilerplate, but your callsites are very readable and the compiler catches accidental mistakes. Here's a code example in the TypeScript playground: [TypeScript Playground example](http://www.typescriptlang.org/play/index.html#src=%2F%2F%20utils.ts%0D%0Atype%20Brand%3CType%2C%20BrandingProperty%20extends%20string%3E%20%3D%20Type%20%26%20%7B%0D%0A%20%20%5BK%20in%20BrandingProperty%5D%3A%20any%3B%0D%0A%7D%0D%0A%0D%0A%2F%2F%20fooAllocator.ts%0D%0Aimport%20%7B%20Brand%20%7D%20from%20'.%2Futils'%3B%0D%0A%0D%0Aconst%20pool%3A%20Foo%5B%5D%20%3D%20%5B%5D%3B%0D%0A%0D%0A%2F%2F%20Rename%20all%20of%20these%20to%20match%20the%20semantics%20of%20your%20domain%0D%0A%2F%2F%20(I%20intentionally%20used%20meaningless%20generic%20identifiers%20for%20this%20example%29%0D%0A%2F%2F%20In%20your%20code%20these%20would%20be%20named%20things%20like%20%22Name%22%2C%20%22Age%22%2C%20%22Timeout%22%2C%0D%0A%2F%2F%20%22SuppressErrors%22%2C%20%22UseFooState%22%2C%20etc.%20%20(I%20don't%20know%20what%20a%20%22foo%22%20does%29%0D%0Atype%20AllocateOne%20%3D%20Brand%3Cstring%2C%20'__allocateOne'%3E%3B%0D%0Atype%20AllocateTwo%20%3D%20Brand%3Cnumber%2C%20'__allocateTwo'%3E%3B%0D%0Atype%20AllocateThree%20%3D%20Brand%3Cnumber%2C%20'__allocateThree'%3E%3B%0D%0Atype%20AllocateFour%20%3D%20Brand%3Cboolean%2C%20'__allocateFour'%3E%3B%0D%0Atype%20AllocateFive%20%3D%20Brand%3Cboolean%2C%20'__allocateFive'%3E%3B%0D%0Atype%20AllocateSix%20%3D%20Brand%3Cnumber%2C%20'__allocateSix'%3E%3B%0D%0Atype%20AllocateSeven%20%3D%20Brand%3Cboolean%2C%20'__allocateSeven'%3E%3B%0D%0Atype%20AllocateEight%20%3D%20Brand%3Cnumber%2C%20'__allocateEight'%3E%3B%0D%0A%0D%0Aconst%20fooAllocator%20%3D%20%7B%0D%0A%20%20%2F**%20Allocate%20a%20foo%20instance%20from%20the%20pool%20*%2F%0D%0A%20%20allocate(%0D%0A%20%20%20%20one%3A%20AllocateOne%2C%0D%0A%20%20%20%20two%3A%20AllocateTwo%2C%0D%0A%20%20%20%20three%3A%20AllocateThree%2C%0D%0A%20%20%20%20four%3A%20AllocateFour%2C%0D%0A%20%20%20%20five%3A%20AllocateFive%2C%0D%0A%20%20%20%20six%3A%20AllocateSix%2C%0D%0A%20%20%20%20%2F%2F%20mimics%20ES6%20semantics%20for%20optional%20args%2C%20but%20arg%20must%20be%20specified%20at%20call-site%20to%20avoid%0D%0A%20%20%20%20%2F%2F%20changing%20argument%20indices.%0D%0A%20%20%20%20seven%3A%20AllocateSeven%20%7C%20undefined%2C%20%0D%0A%20%20%20%20eight%3A%20AllocateEight%0D%0A%20%20%29%3A%20Foo%20%7B%0D%0A%20%20%20%20%2F%2F%20implementation%20goes%20here%0D%0A%20%20%7D%0D%0A%7D%0D%0A%0D%0A%2F%2F%20Warnings%20will%20remind%20you%20to%20annotate%20each%20argument.%0D%0A%2F%2F%20JSDoc%20tooltips%20will%20show%20you%20the%20correct%20order%20of%20arguments%20if%20you%20forget%0D%0Avar%20foo%20%3D%20fooAllocator.allocate(%0D%0A%20%20%3CAllocateOne%3E'qwerty'%2C%0D%0A%20%20%3CAllocateTwo%3E123%2C%0D%0A%20%20%3CAllocateThree%3E123%2C%0D%0A%20%20%3CAllocateFour%3Etrue%2C%0D%0A%20%20%3CAllocateFive%3Efalse%2C%0D%0A%20%20%3CAllocateSix%3E123%2C%0D%0A%20%20undefined%2C%0D%0A%20%20%3CAllocateEight%3E1%0D%0A%29%3B%0D%0A%0D%0A%2F%2F%20If%20you%20mess%20up%20the%20order%20of%20annotations%2C%20you'll%20be%20reminded%20with%20a%20type%20warning%0D%0Avar%20foo2%20%3D%20fooAllocator.allocate(%0D%0A%20%20%3CAllocateOne%3E'qwerty'%2C%0D%0A%20%20%3CAllocateThree%3E123%2C%20%20%2F%2F%20accidentally%20put%20two%20and%20three%20in%20the%20wrong%20order%0D%0A%20%20%3CAllocateTwo%3E123%2C%0D%0A%20%20%3CAllocateFour%3Etrue%2C%0D%0A%20%20%3CAllocateFive%3Efalse%2C%0D%0A%20%20%3CAllocateSix%3E123%2C%0D%0A%20%20%3CAllocateSeven%3Efalse%2C%0D%0A%20%20%3CAllocateEight%3E1%0D%0A%29%3B%0D%0A%0D%0A) Take a look at the output code on the right so you'll see that there's no runtime overhead. When you accidentally put the args in the wrong order, you'll see a little red squiggle reminding you of the mistake. // utils.ts type Brand&lt;Type, BrandingProperty extends string&gt; = Type &amp; { [K in BrandingProperty]: any; } // fooAllocator.ts import { Brand } from './utils'; const pool: Foo[] = []; // Rename all of these to match the semantics of your domain // (I intentionally used meaningless generic identifiers for this example) // In your code these would be named things like "Name", "Age", "Timeout", // "SuppressErrors", "UseFooState", etc. (I don't know what a "foo" does) type AllocateOne = Brand&lt;string, '__allocateOne'&gt;; type AllocateTwo = Brand&lt;number, '__allocateTwo'&gt;; type AllocateThree = Brand&lt;number, '__allocateThree'&gt;; type AllocateFour = Brand&lt;boolean, '__allocateFour'&gt;; type AllocateFive = Brand&lt;boolean, '__allocateFive'&gt;; type AllocateSix = Brand&lt;number, '__allocateSix'&gt;; type AllocateSeven = Brand&lt;boolean, '__allocateSeven'&gt;; type AllocateEight = Brand&lt;number, '__allocateEight'&gt;; const fooAllocator = { /** Allocate a foo instance from the pool */ allocate( one: AllocateOne, two: AllocateTwo, three: AllocateThree, four: AllocateFour, five: AllocateFive, six: AllocateSix, // mimics ES6 semantics for optional args, but arg must be specified at call-site to avoid // changing argument indices. seven: AllocateSeven | undefined, eight: AllocateEight ): Foo { // implementation goes here } } // Warnings will remind you to annotate each argument. // JSDoc tooltips will show you the correct order of arguments if you forget var foo = fooAllocator.allocate( &lt;AllocateOne&gt;'qwerty', &lt;AllocateTwo&gt;123, &lt;AllocateThree&gt;123, &lt;AllocateFour&gt;true, &lt;AllocateFive&gt;false, &lt;AllocateSix&gt;123, undefined, &lt;AllocateEight&gt;1 ); // If you mess up the order of annotations, you'll be reminded with a type warning var foo2 = fooAllocator.allocate( &lt;AllocateOne&gt;'qwerty', &lt;AllocateThree&gt;123, // accidentally put two and three in the wrong order &lt;AllocateTwo&gt;123, &lt;AllocateFour&gt;true, &lt;AllocateFive&gt;false, &lt;AllocateSix&gt;123, &lt;AllocateSeven&gt;false, &lt;AllocateEight&gt;1 ); 
Doesn't apply here. A lot of well-meaning "code smell" advice doesn't hold up when performance is important. OP already acknowledged that they want to make their code more readable, but performance concerns dictate a few things. OP already explained that, yes, they've done the necessary benchmarks to prove it's necessary.
We actually already use TypeScript, and this looks very close to a sensible solution. Thanks! I'll try to experiment with this approach. For some reason I haven't thought about using branded types for this.
Wow! I'm so happy to hear that. Usually the responses I get are very averse to TypeScript and I have to do some persuading. You probably know this already, but depending on how you want to style things, you might be able to use mapped types or some fancy generics to clean things up. I'm not sure.
Than you very much for your input! :) I have refactored the articleFactoryService into articleService and exported it as a singleton for the whole app. Though I am not a fan of singletons, It makes sense, since, as you said, we only need one instance. I do think that the articleService is the correct name. In my vision of the architecture, the domain service can do all sorts of operations on the object at hand (update, validate, create). Naming it articleFactory makes me think only about creation.
Many have already asked about "actually testing the performance", so I won't. Now, take the following with some precaution. It is not a general solution, nor is it without cost, nor do I know if it is applicable to your situation, as you have presented a very synthetic example instead of the _real_ situation. Anyway, I may be completely off the mark here, but I'm going to guess that at least a number of those initialization parameters are configuration flags. If this is the case, then the approach I was referring to is **bitmasking**: - Define the names of your flags as constants. const WITH_WINGS, WITH_LEGS, WITH_ARMS, ...; - Use a 2^(n) sequence as values for the constants (you can see this as "powers of two" or as "shifting a bit"): const WITH_WINGS = 1; // or 1 &lt;&lt; 0 const WITH_LEGS = 2; // or 1 &lt;&lt; 1 cont WITH_ARMS = 4; // or 1 &lt;&lt; 2 // ... - Make the function take **1** `flags` argument, instead of all the separate flag arguments. // Instead of function allocate( type, parentId, winged, legged, armed), you would do: function allocate( type, parentId, anatomy ) { } - When you _call_ `allocate` you can use the constants (maybe make some rule to check everybody does, if you need to). This makes it highly semantic and avoids **part** of the ordering problem (it doesn't matter in which order you combine the flags): allocate( 'qwerty', 123, WITH_WINGS | WITH_LEGS ); // same as: allocate( 'qwerty', 123, WITH_LEGS | WITH_WINGS ); - Of course, this _complicates_ somewhat the original function. Where you previously checked each boolean value, you'll now have to "extract it" from the _grouped_ argument. Admittedly, it's not super-nice; but it's not _horribly bad_ either: function allocate( type, parentId, anatomy ) { let legged = !!(anatomy &amp; WITH_LEGS); console.log( "Has legs: " + legged); } Now, this technique works best with a _group_ of related flags. If you have various independent groups of related flags (say, `anatomy` with X flags, `personality` with Y flags, etc), this _still_ reduces the complexity of the call greatly, but the truth is you may still have an annoying number of arguments. Also, while I've talked about simple boolean flags, this can also work nicely for any enumerable set of characteristics (types). Say I'm creating characters for an RPG. I may have race, gender, and alignment. Each of them with a number of values to choose from. I can still group them into a bitmasked enumeration and do something like: const TRAITS = { HUMAN: 1, ORC: 2, ELF: 4, DWARF: 8, MALE: 128, FEMALE: 256, ROGUE: 1024, KNIGHT: 2048, WIZARD: 4096, CLERIC: 8192 // ... }; createNPC( TRAITS.HUMAN | TRAITS.MALE | TRAITS.WIZARD ); The most obvious limitation of this is that it doesn't work for all things. In particular it does not apply for things that can't be enumerated easily. So you will still have _some_ remaining arguments (such as the `type` and `parentId` in the example above). But it _does_ reduce the total number of arguments while making the calls much more semantic and readable. (Also, it's more usable when the range of flags/options is smallish.) I'm pretty sure there are much better explanations of this around the web; it's a fairly common and old technique. Search for something like _bitflags_ or _bitmask argument_, if you think this could help you in any way.
The createArticle method returns a “maybe” Article type. Maybe types enforce you to check if an Article object exists before operating on it. If the fields necessary to create an article fail validation, the createArticle method will return null. You may argue that it’s better to throw a user-defined exception, but I’m a bit reluctant to terminate the program if there isn’t a catch block.
Hi /u/sudhar1996, For javascript help, please visit /r/LearnJavascript. Thank you!
You could just toggle a class with: elm.classList.toggle(“show”); Just for demo as inline script: &lt;span onclick=“document.getElementById(“x”).classList.toggle(“s”);”&gt;clickme&lt;/span&gt; &lt;div id=“x”&gt;whatever&lt;/div&gt; &lt;style&gt; #x { display: none; } #x.s { display: block; } &lt;/style&gt; (posted on mobile, so it’s hard to type code...)
It can very easily be done using only CSS's :checked pseudo-class. Components: - An invisible checkbox - A label that you can style to look like a button - The nav menu elements you want to toggle Clicking on the label "button" toggles the state of the invisible checkbox. The :checked pseudo-class then toggles the state of the nav-menu, and can also be used to animate the label "button". [Simple demo](http://www.outofscope.com/css-only-menu-toggle-no-javascript-required/) [My implementation](https://foothillcsclub.github.io/CSModules/) (with simple [hamburger menu animation](https://codepen.io/erikterwan/pen/EVzeRP))
&gt; A lot of well-meaning "code smell" advice doesn't hold up when performance is important. Doesn't apply here. This advice holds up in every situation. If you need 8 params in order to make your code performant, something has gone wrong. As an aside on performance, I imagine a function with 8 params probably has a significantly large enough function body, to get de-optimized by whatever JS engine this is being run on.
With exiftool, and export the output to -j json file -php PHP array exiftool "Patricia Barber-Companion-Use Me.mpc" ExifTool Version Number : 6.93 File Name : Patricia Barber-Companion-Use Me.mpc Directory : . File Size : 10 MB File Modification Date/Time : 2006:04:21 17:00:22 File Type : MPC MIME Type : audio/x-musepack Total Frames : 15035 Sample Rate : 44100 Quality : 6 (Xtreme) Max Band : 31 Replay Gain Track Peak : 32949 Replay Gain Track Gain : 65416 Replay Gain Album Peak : 39239 Replay Gain Album Gain : 65161 Fast Seek : No Gapless : Yes Encoder Version : 1.1.5 Track : 02 Title : Use Me Album : Companion Artist : Patricia Barber Comment : EAC / MusePack 1.15v --quality 6 Genre : Jazz Ratesonic : 5 Sub-genre : Jazz Year : 1999 
It is, lots of polymer projects do this. You get small alert "new version available - refresh" that you can click. So I think that updates are implementation detail to handle.
You're incorrect about performance and specifically about deoptimization. Re-read OP's post to double-check their requirements. Imagining that their function gets deoptimized doesn't make it true or likely. Consider what the body of their allocator function probably looks like. It's an allocator for an object pool. Try writing an example yourself. You'll see that, even with 8 args, it's extremely optimizable by the VM.
What, as compared with autorefreshing the page? See also ergo14's response below.
Isn't the problem that people are naming new packages so similarly to existing packages that it's confusing? Updates or otherwise? Sometimes a project is finished and it doesn't need updates. I would posit that search is not favoring projects that have not updated so much as projects that are 1. well used and 2. stable. I don't think this is a problem with NPM. 
I'll make a quick entry. Something like this could work. &lt;html&gt; &lt;head&gt; &lt;script&gt; //your calculations goes here... result = somethingCalculatedAbove; document.getElementById("demo").text(result); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="demo"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; Something rough like that would work...
&gt;blue switch That's not enough context to figure out what you're talking about
I tried to upload a screenshot but got banned.
&gt;If you benefit from this Repo，Please「Star 」to Support. Don't put this in your documents. It's tacky.
Like this https://www.google.gr/search?client=ms-android-xiaomi&amp;biw=360&amp;bih=315&amp;tbm=isch&amp;sa=1&amp;ei=mJelWty_OcyTsgG_0onQAQ&amp;q=google+blue+switch+on+off&amp;oq=google+blue+switch+on+off&amp;gs_l=mobile-gws-img.3...33523.35434..36081...0....476.2554.2-1j4j2..........1..mobile-gws-wiz-img.v41lNLUjLXs%3D#imgrc=onyMEYLXkr0_BM:
of course, if we wanted to do that, we'd all be using the 'brainfuck' language, rather than JS, C, C++, etc. :-D There's really just an incredible amount of stuff that I've realized I've either never had any reason whatsoever to use, or have absolutely no idea how to explain it to someone (particularly when I know they aren't a programmer, so I have no idea what the actual answer they are looking for is, versus how I would explain it to someone that knows something).. some examples, from different interviews: - what is the difference between bind, call, and apply? ... well, bind returns a function, call and apply call a function. Great. When would you use call? I've never had any reason whatsoever to use call. When would you use apply? When you need to call a variable-argument function with the contents of an array spread out across it's arguments. ... and if you have to do that, IMO, you've already opened a box of nightmares. - Write a function that tells me if any 2 numbers in an array add up to 10. Clearly, he's not looking for the obvious function here, but I don't know specifically how to optimize this to any less than a nested for-loop. I write the obvious function, and explain that I'm not sure how to optimize it any further, but I can research it. He says "You can put this down to one loop, by doing this:" and writes me the code. Which contains 2 loops, using an optimization that literally only can apply to a very similar problem, which I've never in my life needed to perform. I point out that his code uses 2 loops, not one, and he's missing the early-exit condition. I get hung up on. - Explain Big O. - Prove Big O. - Write an A* pathfinding algorithm. (for a company that is building a blog service, I'm guessing they saw "Video Games" in my resume, and figured they'd test my low-level knowledge -- y'know what, i've never had to write a pathfinding algo, because we've basically already solved that problem) ... that's what I can think of right off the top. Only a bit of it had to do with Javascript itself, and all the positions were Javascript oriented, except for the array algorithm guy, which was a C# position that involved entirely communicating with external services, and putting the data returned from them into local databases. I've had 3 actually at a point where they have sent me an offer, and then retracted it, saying that remote devs weren't being taken. (then why did you just do 4 interviews with me in the last 2 weeks?) 
Do you know where to find the console? (It's not visible by default, you have to press some keyboard shortcut to open it, or find it hidden in some menu). Try googling how to open the console for your particular web browser.
You're talking about a toggle. [Here](https://codepen.io/andreasstorm/pen/ZGjNwZ) is an example from codepen.
Thank you!! Toggle right.. is not good at English!
Why are you using the + for concatenation? If you only ever use “+” for addition you won’t run into this problem. Similarly, if you always use triple equality checks, you miss the various truth table problems.
No worries! Happy coding!
That didn’t answer his question. 
You went against their holy grain. Now they must punish you. 
all that said, in the other message, i recognize that i'm not really what a lot of people are going to be looking for, but damn, i just spent the last 8 years writing code professionally, with half a dozen released games for studios, and my code after gaming, being run on millions of devices around the world. you'd think i could find a job. ;-) 
At this point you're looking at the functionality of a radio button styled as a toggle. It can probably be done, but you could also do it with JS. Give all the toggles unique IDs, find them with document.getElementById or something similar and disable all the others when one is toggled.
[removed]
You comment something but I cannot see it..
You know what I forgot to mention? There are a lot of horrible interviewers out there. They have not been trained at interviewing and they are bad at it, and people like you have to suffer from it. Because from what you described, that's pretty much what you're encountering. &gt; I point out that his code uses 2 loops, not one, and he's missing the early-exit condition. I get hung up on. How do you point that out without hurting the guy's feelings? I don't know. That's a really tough one. If he was going to be your boss, you've just showed him that you're better at his job than he is. I don't know maybe if you need to put food on the table you say "cool, thanks for showing me your solution." &gt; I've had 3 actually at a point where they have sent me an offer, and then retracted it, saying that remote devs weren't being taken You know they might be letting you down nicely? For sure they aren't going to say "we decided we don't like your personality and you're not a good fit for the team", even if that's the reason. There's nothing wrong with that. Better to have them say "no" now than to get a job and figure out a month later that you just don't work well with the existing team. I'm sorry you've had so many bad interviews / experiences with the process. You do know it's a numbers game, right? You might need to hear "no" a hundred times before you get the "yes".
Since you can't see my other reply, [here](http://codepen.io/koljakutschera/pen/YGvwGB/) is what you're looking for.
Thanks!!
&gt; Why not create users accounts on their devices and make sure they only send needed authentication data? This is exactly what I do and I love the architecture. I run a thin express app that passes requests to node workers via zeromq. So far, I can barely get the needle to move when I try to load test it. I'm just running on a $5 droplet and it still has more capacity than any other architecture I've worked on.
yeah it is. just lower on my priority list when i want to get couch working :)
I've been working on it on and off for a while, but just put it up on my site (which is in various states of disrepair otherwise). It is a musical synthesizer and chord generator, it arpeggiates the chords at a random rhythm and pitch range. It's sort of something I do a lot in my own music, so I made a web app where you can play around with that idea. I built it in React with styled-components and I built the (very simple) synth from scratch using the WebAudio API. code: https://github.com/MikeSperone/ChordArp_Web web location: http://www.mikesperone.com/chord-arp/
If most or all of your objects share common parameters, and they can be referenced by index, you can try doing away with objects entirely and replacing them with an array for each parameter. For example: type | : 'qwerty' | 'qwertz' | 'qwerua' | parentId | : 123 | 124 | 125 | ...etc. For parameters that are not common to every object, you can either use an array with null entries, or a [sparse matrix](https://en.wikipedia.org/wiki/Sparse_matrix) depending on what percentage of your objects you expect to possess that parameter. The reason for using arrays this way is that fewer arrays with more entries is more memory and lookup efficient than many arrays with few entries. While this solution may seem like a regression, there's no getting around the simple math that arrays are less complex than objects.
It sounds from your other comment that you've gotten close. If I were at your level I would find the interviews you described *super* annoying. I do not interview someone with 8 years experience with the kinds of questions you described. After 8 years you are a colleague and a peer and the interview should be a lot more like a conversation where we talk shop. Especially if you can show me your own code from previous jobs. At that point it becomes my problem to review and understand your code and then we talk about your past code. The stuff you were proud of, the stuff you had doubts about, and the stuff that should have been done better and why. That will tell me WAY more about your level and way of thinking about programming than a bunch of quiz type interview questions. Those questions are meant to be used for junior programmers so you can filter out the folks who really have no clue at all. You're just getting really bad interviewers. Keep at it and I'm sure you'll find something.
Lol I tend to do commits after song titles, just to keep it interesting. 
There are plenty of things about Javascript that I don't know, plenty of things I don't know how to explain. Until this year, I've never actually been quizzed on writing actual code, given algo tests, quizzed on C/S concepts before. Perhaps it wasn't good for me to point out that the interviewer's solution for that problem wasn't as ideal as he said it was, but I'm probably not going to be accepting a position with a guy like that, anyway, and if I do, I'm going to hate it, which is why I wouldn't be. I wasn't trying to be rude, but he did say "Here's a solution with only one loop", and I felt not pointing out that there were two complete loops, one of which should have had an early-exit condition, would be showing that i know even less than I do :-D I figure that places might be letting me down at that point, it just seems bizarre that we get to "ok, here's what we want to give you", followed by "ooh, sorry, we can't actually do that." At least if they sent me "gfy", then I know that something went wrong in the process. :-D Yeah, I really need to buckle down and hammer out a ton of interviews, I guess. I was really assured from 2 of the people, who were people that worked with me at my previous company, that everything was coming up roses, until bam, suddenly it didn't. At one, even had other engineers there emailing me telling me they were looking forward to working with me, and here's some things that we're working with, so you can get familiar with them. I actually just had a pre-screen with one big company that was really interesting, they laid out a bunch of things, and said "here are the things you're going to need to know to get in here". It was a *lot*, a lot of stuff that I know I just don't know, and I 100% was not even interested in the company, because I'm totally outside of what they are looking for. But they insisted that they wanted to talk to me, so I did. That was where a lot of the basic javascript/html questions were at, like "how does prototypical inheritance work", "how do DOM events propagate", then followed by the "explain big O", and "can you do a Big O proof?" .. really? for a client-side 100% Javascript/HTML UI position? yeah, yeah, I get that this is something I should be able to explain . . but is that really something that they need? (ultimately, i would say that if you have Big O problems on UI side, you have Big Problems with your data layout on the server) 
so virtual function table and prototype delegation is ... basically synonymous ???? 
Can you elaborate on what you mean by "doesn't really work as expected." It sounds like it's doing something but you want something else.
The sheer length of a lot of the interview processes is daunting, as well. I've interviewed with 7 different companies so far, and all of them got me to a second interview step, 4 of them we did 3 different interviews, and 2 of them 4. One that was purely a "pre-screen" where the company approached me out of the blue, was the shortest, but also most informative, they informed me up front that after that pre-screen, if I wanted to continue, there would be 6 different interviews, and I would be asked to come onsite (across the country), to demonstrate my code on a whiteboard. 
Strange, it should be fine. I tried it on my iOS on chrome and safari, it seems to be fine, could you please tell me what browser did you try it on?
Chrome 65 on Android 7.0.
Will check, thanks.
... this is something that i've been interested in figuring out, but it seems rather difficult to figure out how to just edit my existing configuration to make it work, versus replacing everything with some other similar option. in that, currently, i have a Docker image running nginx. It is configured nicely to forward requests to several different services that are also running on Docker, and a few to services that are running on the bare machine (no docker). I can't seem to figure out how to configure nginx to serve https, and basically just proxy everything exactly how it is now, but using https. Any tips for someone who's trying to figure that out? I'd like to Let's Encrypt with it, and just have it work, without making huge changes, if possible. 
https://github.com/facebook/react
Webpack based Reveal.js presentation starter https://github.com/PeterPorzuczek/WebpackRevealPresentationStarter
Very good question - we still have an older codebase that, in the end, requires usage of these patterns. If you read in context of my post, it's a bonus, not a requirement. We're hiring Junior devs here. As for inheritance, it is still very useful for polyfills and extending JS in certain ways. Back in the day I was huge fan of prototype.js - for better or for worse when I learned you can run into trouble with this [this idiocy](https://github.com/tc39/proposal-flatMap/pull/56). I write polyfills to match JS functionality with Java functionality and that's becoming less and less necessary. (I was asked to implement the String, Integer classes in JS - that was fun)
We use pouchdb for offline stoage and post the records as a JSON array to a server API that parses and stores them in SQL Server. It's been a pretty painless experience.
Oh interesting. Are you able to do multiple client sync with that?
Nice extension. Does it work with Vuejs component?
the Jasmine library and SuperAgent are 2 libaries I especially love using. For the Jasmine lib I wish someone did a better Koans Road To Enlightenment which would rival Ruby's. I loved the custom reporting in Ruby's Koans which was written as a 1st person story.
Thanks for pointing out :-). Removed!
I understand MVC (have been using Laravel and CodeIgniter before) but for some reason I could not understand Redux. Maybe I've been reading the wrong articles.
Not exactly synonymous, but they're more similar than many JavaScript learning resources would have you believe. The JavaScript object structure would look like this: https://i.imgur.com/FOQA4wo.png And the C++ object structure would look like this: https://i.imgur.com/uLA7e3i.png
I will give it a try and I'll let you know if it worked.
Preact. You can learn a ton from that codebase and it's very tiny. Clean and clever code at its finest . 
Been working on a project that will require some like this so thanks for sharing, will definitely try it out!
On second thought, you wouldn’t need to spread the object overtop of the old state in the reducer, you could simply return the object from local storage and it would become your new state.
anything written by TJ.
So, I was imagining that you’d be capturing a snapshot of the entire store when saving into local storage. Then you’d “restore” the store to this state when refetching it by simply returning it in the reduced as the “new current state”. Does that make any sense?
Backbone. Not at all the best web framework now (honestly I'm a React guy now), but it was definitely a very well-designed library.
Thank you!
I just found https://github.com/btroncone/ngrx-store-localstorage which I think implements my idea :)
* /r/learnjavascript * Don't post code here if you can't format it, use JSFiddle instead * Don't implicitly create global variables, `trialNumber`
They help when architectural decisions meant the single threaded nature of JS just wouldn't allow us process the volume of data, client-side that we needed to. It allowed us push some business logic off the main thread to free it up for rendering. That said, it served a purpose when better architectural decisions would have allowed better ways of doing this. I feel like they're one of those flavor of the day things. Don't look for reasons to use them "just because". 
Lodash
Well, it wasn't in your code, and whatever it was initialized to first, it gets discarded because `trialnumber` gets reassigned before anything else.
ive got a dexie+postgres+postgraql/graphile setup. It seems enough to scale.
It’s not your fault 
I go through phases. Web dev as a hobby is reoccurring for me, usually separated by a chain of various activities revolving around drinking. I made a really cool browser plugin for Craigslist once. Finished it, and everything. All other projects never got far, except the big pipe dream website I ditched a fewy years back as a PHP project, and restarted as a JavaScript site, and am working on currently. This time I am finishing it, damn it. I mean it.
Oh I didn't know that. So that's because it's a global variable? But then how should I change this to make it work.. can I change all trial number into n or something? 
Really bad on mobile, would love to read more on my laptop later. On android galaxy S8+
Redux and Immutable.js
... idk why you got downvoted so much. React is MIT now everyone. It's all good now.
VueJS is in my opinion the best thing since Node itself. Now with support for native script it's even possible to make phone apps
Lots of butt hurt enterprise devs
Downvote them and move on
the sort function worked！ thanks！ But I still don't quite understand why shuffle didn't work... 
Pretty cool. I had a good experience with Android (im using Brave, which is Chrome based i guess).
It worked really well on my Razer Android phone in chrome (64.0) / Android 7.1.1
Exercism, because it's test-driven and you do it in your own dev environment, not some janky web interface.
Could you please try it again? Not sure if it fixed your issue but I pushed some mobile fixes.
More of a side project than a "production" app, but I use one in [Prelude](https://getprelude.net) so that the entire webapp works offline after the first visit. There's also a web app manifest that allows adding it as a home screen icon so it seems like a regular app on mobile. I don't write the SW code myself, but instead use sw-precache: https://github.com/GoogleChromeLabs/sw-precache
lodash or pixijs I love when developers use actual JSDoc to document the libraries. It makes it really easy to follow the examples and the source. Actually, I hate when they don't...😅👍
Truth. I learned backbone after becoming an angular dev and it made me appreciate it. Although, I've only ever seen one implementation in production that I could sign off on. 
ReEEEE
Wish I knew about this a week ago. I was looking for one if these.. I didn't know what to call them so I was searching for tour and walkthrough.
You've seen one!?!? Can I see? ;)
&gt; Exercism Thank you! I haven't heard of this one yet. I'll check it out! CodeWars was okay, but took awhile to load each new problem and I didn't really like the wording for the questions, but maybe it may just be my inexperience reading them. 
Check out python tutor ( JavaScript section) which executes the code and shows each process
Sweet...
“Smaller attention span of this generation”. Pretty much sums up how Webpack is maintained, with no thought to their existing user-base, new folks coming in off the web trying to get their code built by this mystical unicorn, or even ensuring documentation isn’t disjointed, stilted and out of date... and the demographic to which they’re trying to cater. I’ve tried keeping up with Webpack, but if my usage is any pattern indicator... I set my build tools once, forget about Webpack, and focus on my project’s development. If I tweak something 3-6 months down the line, I don’t want to hear how my efforts are now deprecated and replaced with a new version that is completely incompatible with what already took me more time than I care to admit to, to put me in a position where I can focus my efforts on my project. Fusebox did it right, IMO. 
Do you mean execute like on the front end sense? :( I'm just learning how to do things like looping through arrays and removing the smallest numbers right now. :| 
[Mithril.js](http://www.mithril.js.org) I’ve worked with them all but Mithril is absolute poetry. Mithril outperforms React, Vue and Angular in speed and is only 8kb in production. It ships with routing and XHR utilities out of the box and you don’t need JSX (though it supports it). It’s a lesser known framework but the community and contributors behind it actively maintain it and the gitter chat is like a family. I couldn’t recommend it more and hate that it doesn’t get the recognition it deserves because it’s clearly superior than the rest until someone can convince me otherwise. Be warned, Mithril is magic and can cast a spell on you. When I stumbled across it I didn’t go back to React or Vue and I probably won’t. 
Unfortunately, no. It was for an internal application to manage infrastructure events (developed around 2012) and respond to them with Jenkins. It made heavy use of marionette.js for dispatching and require.js for dependency chunks. It really made me appreciate redux and ES6 moving forward
lol i was browsing this .. https://github.com/facebook/react/blob/master/packages/react/src/React.js &gt; __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED wat?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [facebook/react/.../**React.js** (master → fcc4f52)](https://github.com/facebook/react/blob/fcc4f52cdded62e3b8e95d18e3e6adf17b981eed/packages/react/src/React.js) ---- 
I won’t be going back to Webpack. I’m sticking with Rollup.js for now. 
Mercury.js. Small consistent interfaces with minimal dependencies. A good job implementation of elm architecture.
Well said. 
Works perfect now thanks! Another suggestion might be to shrink the font in the code snippets at least on mobile so I don't need to scroll to the side to view them completely. 
Not a library per-se, but [fantasy land](https://github.com/fantasyland/fantasy-land) is an elegant, ambitious piece of work if you're into functional programming. Also, [Fluture](https://github.com/fluture-js/Fluture).
This guy is engie from tf2
Come on, I do like codewars.com Not trying to be rude, maybe you just found task to hard and trying to defend yourself? :) 
Not rude at all! It *IS* hard for me, but it also takes a while for the pages to load. :( */cries
[Koa](https://github.com/koajs/koa/tree/master/lib) is a really thin wrapper around `http` and the codebase is pretty elegant.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/koajs/koa/tree/master/lib) - Previous text "Koa" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20dvk96k1) 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [koajs/koa/.../**lib** (master → 9cef2db)](https://github.com/koajs/koa/tree/9cef2db87e3066759afb9f002790cc24677cc913/lib) ---- 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [koajs/koa/.../**lib** (master → 9cef2db)](https://github.com/koajs/koa/tree/9cef2db87e3066759afb9f002790cc24677cc913/lib) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dvk975c.)
Exactly. This is why I still prefer task runners like gulp.
Some managers call this "Agile".
&gt;1. Selecting Elements &gt;Example — How to find all anchor tags inside a div in the fastest manner? Ditch jQuery and use querySelector / querySelectorAll instead &gt;Selecting elements by tag name is also quite fast. &gt;Selecting elements by class is slow since there can be multiple elements that have the same class Something doesn't add up there... &gt;Developers usually add jQuery link on the page head. &gt;I would tell you to put it before the body end tag. &gt;The problem caused by scripts is that they block parallel downloads. I think information that *describes/uses* a page's content, but isn't content itself, should go in the header, not the body. The solution to blocking scripts is not to put it so that it blocks at the end of the body, where it doesn't belong anyway, but to use `defer` and `async`. &gt;jQuery Grep method is amazing, I really like it because of it marvellous power. When you are dealing with array make use of it to filter out element from it. (filter)[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter]'s been a thing since Firefox 1.5, ya know...
In the future most major languages will have better support for exporting to webassembly from your favorite IDEs. Build tools like bazel aim to be general enough to build for various languages. Google Dart is also nice to work with if you ever get the chance to explore it. Dart's Pub centralizes all dependencies and transformations in one Yaml. Hopefully there will be more webassembly solutions. 
Third for Redux. Also, ReactDnD (another Dan Abramov creation) is likewise very well designed, and does an extremely good job of protecting developers from the shitty native DnD API
Watch your fucking language!
You’re reading the syntax incorrectly. It’s actually: import Something from ‘something’ The curly brackets are standard ES6 destructuring and not specific or particular to the import statement. This is a) natural in English, b) idiomatic, and c) in line with standard assignment order (left = right). The python syntax is none of these things and definitely should not be imported into JavaScript (seriously, we’ve already got enough bad ideas coming in from the java guys). 
Software development is a challenging and complicated field, with extremely complicated problems to solve. We shouldn’t design our tools so they are simple for newcomers. We should design them to solve our problems in the best way possible, even if that solution has some complexity itself. I’m happy that the webpack devs are continuously reevaluating their solution and improving their tool. 
[Here is a cool selection of different text effects and animations](https://animatedtextmaker.tumblr.com) 
Paste your code in python tutor and it will execute the code and shows you each step the JS engine takes. I highly recommend watching JavaScript The Weird Parts (free video for first 3.5 hours). Then I would look into CodeSmith.io/learn and do the CSX stuff
Why can’t it be both? Follow the mantra of “easy to learn, difficult to master”. It takes extra effort, but you can surely design tools such that beginners can pick them up easily, while having enough flexibility and power to satisy the experts. In fact, I think Webpack is getting there quite well. It seems to me that most complaints regarding Webpack come from people in the middle: Not experts, but people who have invested some time and effort in their setup who then see that investment become deprecated when a lot of it works differently in the next version. That’s a tougher problem to tackle because the Webpack devs want to keep making progress and they’re willing to break a few eggs to get there.
They don't manage projects that actually ship useful code.
Props to [Meteor.js](https://meteor.com) for making configuration almost non-existent. Just npm install and import.
Vue has a CLI webpack installer to help you with that https://vuejs.org/v2/guide/installation.html#CLI It's similar to react's `create-react-app`
I just gave a look to the codebase and it's indeed incredibly small. For the clean code, well, it may be efficient but it's not really beautiful imho.
Lodash is the kind of lib that will continue to be useful no matter the framework or most language evolutions.
Great advice! Thank you! 
You don't know what a modal is, then. The *modal* means that everything else in the UI is disabled while the modal dialog/window is up. https://en.wikipedia.org/wiki/Modal_window
No. Managers like realistic estimates and they know experimenting with new stuff can backfire. If anything, they'll prefer that you stick to the tried and known technology.
I have a feeling you're talking about Service Workers but thinking about Web Workers. And even then you'd be wrong as there are numerous processing tasks where Web Workers still make sense and blocking the event loop would be unacceptable.
I believe it might be a build step. Open the csproj with a text editor - believe that's where it calls webpack! 
ramda.js
&gt; A sort() function implementing randomness would probably be more elegant. But will give _heavily biased_ results.
Don't fuck with me, u/everythingcasual, not you!
I thought “easy to learn, difficult to master” was a quote about good game development?
Yeah, I think I got it from the gaming world as well, I just figured it could apply here too :)
They do now, look at Webpack 4's "mode" argument.
WebAssembly will be a game changer.
I often get shit on for having opinions outside the "mainstream", especially in /javascript, but you've touched on some of my opinions of webpack here. I'll add something else that I find difficult to justify about webpack. Hot reloading only seems like a benefit until my browser slows to a crawl or crashes after 30 minutes of dev work, because each time I hit save the hot-reloader brings in 30+ Megabytes of javascript code. Just to update one small code change - it's like performing surgery with a bulldozer. And I'm not always sure if my update didn't hot reload because of an error or because Chrome just can't handle the massive pressure hot reloading is causing. My browser (Chrome) seems to buckle under the weight of these hot-reloads until it doesn't function well and I have to close the browser window and re-open it. And, hot-reloading doesn't even work 1/2 the time, it only works for *some* changes, not all. Is this really the awesome feature that people make it out to be? Am I missing something? TBH, I didn't set up our webpack config, I'm coming into a project that's already a couple of years old and webpack may be an older version, maybe things have improved with later releases? Ah, but we can't update it easily, without updating a million other things, so we seem stuck with what we have. Based on my experience with it so far, I'd never use webpack for a new front-end toolchain. 
CodeFights is pretty good. I would also look up the JavaScript Koans and do that. Really helped me starting out.
I agree, that's why I said they're getting there :)
Best tip: don’t use jquery. 
The article talks endlessly about the pain of upgrading Webpack but doesn't actually offer any specific critiques. Complaints about how Webpack has a lot of plugins and tries to be all things to all people, lots of talk about how painful it is to use but I just don't see it. Updating 2 projects to Webpack 4 was a 30 minute job, the error messages were nearly good enough to get me there alone. Calling the Webpack maintainers careless is a bit much... They're working on a tool that is at the forefront of this field. If you have legitimate criticism to make, then make it, open an issue and propose changes that will improve it. If you can only make vague criticisms and complaints about how updating Webpack "deprecates your efforts" then don't bother updating, nobody is forcing you to. Unless you have a fairy that goes around your office at night updating npm packages I don't see how this can be a problem at all, you were fine on Webpack 2 or 3, so just stay there until you can be bothered to update. Get a senior to help you if it's really too much trouble to reread update docs.
I agree that individual documents, or pieces of data, should have their own entry point, but you then go on to imply people who are building apps should use java applets, native, or flash. Native, I could agree, but running compiled apps in some environments isn't an option (think corporate security policies). Recommending java applets or flash is... misguided. Why use something subpar when I can use standards supported across the world that provide me with all the benefits and none of the downsides of those options? There are many use cases for web apps, and saying that 'most don't qualify' is misguided. State is easier to handle in an SPA as it's possible to negate the need for cookies or session setup. In a restricted or limited environment, such as a standalone apache server or something like OneDrive, where you don't have access to server-side tech, you can use something as simple as a JS object (essentially state management, but it could literally just be a JS object without a library to manage it if needs must). Additionally, you seem to be ignoring the situation that's prevalent in many organizations - workforce which have older systems with extremely limited resources. Systems that can take many seconds to actually load between pages / navigate because of these resources (especially considering situations where many other essential applications are also loaded). SPA's are able to negate this while still displaying the information needed.
I’ve never heard of Rollup. Could you tell me why you prefer it over Webpack? 
Both can easily do what you want, if you know Vue already, use it. Otherwise, React is quite small in scope, think of it as maybe 1/100 of Vues weight in general. It's trivial to learn, and due to its [massive userbase](http://www.npmtrends.com/angular-vs-react-vs-vue-vs-@angular/core) it has more support for pretty much anything (ready made controls or behaviours like drag/drop, animations, visuals, etc.). 
Mithril is absolutely the next thing I'm going to start using for making applications with JS. It sports the kind of clarity-of-purpose (for every part), simplicity, and correctly (IMO) chosen API boundaries that excite me. I basically consider React to be the worst implementation of the component-driven framework (I haven't tried the rewrite that is React Fiber or Preact so I can't comment on those), Vue.JS is an improvement (it's so much clearer, smaller, and simpler), and once I try MithrilJS on a non-trivial project I expect it to sit at the pinnacle, because it's basically vue/react + react/vue-router, in one super small package. What I think mithril desperately needs is a place for people to submit and showcase components that use mithril. The micro frameworks that will win will be the ones with reasonable API boundaries and large amounts of interchangeable components (until someone bridges component frameworks anyway) I don't know how the hype train skipped Mithril.
Thanks. That actually paved a little more of my pathway to the decision. For Design elements I was thinking of going with bootstrap themes and then I can get drag and drop elements from elsewhere and just plug it in. 
I think that it came a little too late and _after_ peer pressure - that smudge won't be leaving anytime soon
1. There's really nothing inherently different about whatever "this" generation is - we're all just humans. The only thing that's changed is the environment, which humans have to adapt to. 2. No need for the ad hominem at Webpack devs. You might not agree with their design choices, but there's nothing at all indicating they do not care. And no, your efforts are not deprecated. I'm still on Webpack 3, which serves me fine. If I really need something in Webpack 4, I'll do the following: 1. Do the work of upgrading them myself - I haven't had to write them in the first place, so I'm still saving time (thanks, developers!). 2. Fork them so I can use them. 3. Submit my changes in a pull request. 4. If it gets accepted, switch to the upstream version again. If the above is not worth it, I have two choices: 1. Remain on Webpack 3. 2. Don't use Webpack. The third option, "complain about the Webpack devs online", really is a no-go to me.
You have lots of component oriented design libs to choose from: https://www.reddit.com/r/javascript/comments/7qrcas/what_is_you_favorite_ui_framework_for_react/ As for drag/n/drop, check out react-dnd, [react-spring](https://codesandbox.io/s/l9zqz0m18z?from-embed) for some animated stuff.
Makefiles are not cross-platforms, and therefore useless IMHO
I don't even see what webasm has to do with it. If anything webpack actively helps the propagation of wasm due to the wasm loader. 
 function shuffle(a) { for (let i = a.length - 1; i &gt;= 1; --i) { let s = Math.random() * (i + 1) | 0; let tmp = a[s]; a[s] = a[i]; a[i] = tmp; } return a; } console.log(shuffle([1, 2, 3, 4])); // [2, 1, 4, 3] or whatever
Don't use sort to shuffle. It's much slower and the result is heavily biased. It's a very crappy hack.
web assembly will be targeted by existing platform build tools to generate embedded code, say from C#, java or python. In the future the npm+babel+webpack stack will no longer be needed.
I'm sure eventually most of it's functionality will be added to JS spec. I've already dropped it from some of my projects that don't need to support legacy browsers
The codebase itself may not be the prettiest but react is definitely the most reliable lib in my stack. The team does a great job of keeping API clean and show deprecations long before something is changed. It's actually surprising how consistent the API has been after what feels like a long time in the JS world 
I agree. People need to go with the best dev experience, rather than the best benchmark scores. If react is fast enough for Facebook's scale it's fast enough for me
The concept of a pipeline in gulp made sense. I could use that okay. Still not a clue about webpack.
It's the current Microsoft kool-aid that WebAssembly will make JavaScript redundant. https://github.com/aspnet/blazor But C# and other languages have been able to be compiled to JS forever with good performance and nobody has used that, so I don't see people jumping ship for this either.
What is happening is that timeOfDay='Afternoon' returns 'Afternoon' so when you call greet(timeOfDay='Afternoon') JS actually evaluates greet('Afternoon') You need that undefined there...
Make smaller chunks. Try understanding how it works before you condemn it forever. 
The parameters are not matched by name but by order. Since you are only passing `timeOfDay`, it is seen by your function as the first param - User.
I guess it worked, at least for me. Just tried it and it worked fine. 
&gt; Updating 2 projects to Webpack 4 was a 30 minute job, the error messages were nearly good enough to get me there alone. I would be interested in seeing your config. Maybe I'm stupid but I spent a long time trying to upgrade my existing config but I couldn't due to various bugs and incompatibilities, particularly with loaders that haven't kept up pace, as this article describes. &gt; As an aside, the sense of entitlement here is too much. Open source maintainers owe you nothing. This is somewhat misleading - Webpack is part of the Open Collective and does have sponsorships, grants, partnerships to help pay maintainers. 
This article sounds like a grown man sighing for 5000 words in which nothing spectacular is covered about the topic of webpack. Must medium let anyone write?
Same here, i find it so tedious to use any other libs!!
C# would be a questionable language for the web, nor would it make anything faster or leaner. Java as well. They'd still be dependent on bundling of some sort, non-js reasource handling, code splitting, etc. unless you want to pump megabytes towards the user for an entry page. Using low level languages in general for application building is quite silly. Wasm won't build user-interfaces, it will probably help as a back-bone (v-dom implementations are already here, for instance yew or csx, jsx in c++).
I'd like to try this out in a vue project, but I can't get the basic setup to work. - npm install --save require("driver.js/dist/driver.min.js"); // in entry point. requiring driver.js wouldn't work pasted in the basic example const driver = new Driver(); // Define the steps for introduction driver.defineSteps([ { element: "#toolbar", popover: { title: "Title on Popover", description: "Body of the popover", position: "left" } } ]); // Start the introduction driver.start(); error: Error in mounted hook: "ReferenceError: Driver is not defined" Am I missing a step?
Make is an over-complicated tool for a simple task. I hope it will be lost in time like tears in rain.
You should upload the code to Github. Thanks!
Not going to offer a rebuttal?
It says could not find a load main class message wonder Java Caused by Java.lang.class not found exception: message 1.Java
Java != Javascript. Wrong subreddit.
Not OP but for NPM packages, rollup is a pretty great tool. Limited configuration API and, last time I checked, smaller build sizes than webpack. I still use Webpack for my applications though. I can't imagine doing everything webpack does via rollup.
Yeah you are confusing js parameter defaults with named parameters from Python, they don’t work the same way 
Lodash is great but I think `ramda` is a much cleaner lib with a better API.
Does the button have an ID? It'd be easier to target it if it did.
document.querySelector('button[value="Sin Señal")[0].removeAttribute('style'); If you run this script in your Chrome Javascript console, the button should appear!
I don't believe it applies quite as well. The first priority of a game is to be fun. That gives designers a lot of flexibility with the rules and dynamics, and ultimately it can't be said that game is "incorrect" or "suboptimal". Developers and engineers face a different challenge, which is to solve real problems. There's a lot more constraints on our solutions, and there's always an ideal solution out there that we are striving to arrive at. Finding that solution should be the first priority of an engineer. 
[freeCodeCamp](https://beta.freecodecamp.org) has an entire section dedicated to JS challenges, along with projects to build at the end. I gave you a link to the beta version of the site because it's pretty close to being finalized and works well.
If Webpack 3 is working for you, why not stick with it? I don't see anybody forcing you to upgrade. 
I tried running it, but didn't work: Uncaught SyntaxError: missing ) after argument list 
Every single millisecond counts and while you may not experience issues someone across the world using your application with slower internet or browsing the web using a proxy may be experiencing a slower than average render time. I don’t want my application having to require transitional entries using CSS so as to avoid flash renders which Vue is known for and I don’t want to have my applications requiring several additional libraries in the build increasing my initial load time and end production file size. Speed matters and any developer that doesn’t consider this aspect as core fundamental is an amateur. 
My mistake. Change the querySelector to this: 'button[value="Sin Señal"]'
When you do greet(timeOfDay='Afternoon'), you're assigning 'Afternoon' to the local variable timeOfDay and passing the return value from that assignment as the first argument to greet()
That's a bit harsh. A professional would look at what the debt is of picking a smaller unknown somewhat framework versus React/Angular. It would likely be amateurish picking the unknown framework based on people you hire and maintainability, compared to a tiny increase in rendering speed. The trade-off in most real world application cases wouldn't be worth it. Of course there are exceptions.
Just a heads up, your link is incorrect. Should be https://mithriljs.org/
&gt; But I have still found new comers to understand gulp faster than webpack That's because it's easier to understand working on one server before you learn about developing a distributed architecture. Gulp is a simple task runner; webpack is a larger, more powerful module bundler.
Thanks for the explanation. Is this something that could be added to the language (via the tc39 process), so that we don't have to keep passing in the undefined?
Get ready to be linked some blog posts, possibly with lots of emojis.
I prefer vuejs over react. I dislike the functional programing BS surrounding react. 
You come across as one of those developers that’s a hype kid. Jumping on the React train is the literal definition of hopping on a hipster framework. Just because a big company backs a framework it doesn’t mean it’s the be all and end all of frameworks. In fact a lot of the engineers working at these big companies are not the sharpest tools in the shed and the code behind frameworks like React can be modified, simplified and configured, hence Preact.js. Mithril isn’t an unknown framework either, it’s been around for quite sometime and as I mentioned in my post has a community of very talented developers that actively maintain it. You’re entire argument is also biased because you’ve never even tried Mithril. A professional wouldn’t run to what they like and prefer, a professional would analyze the projects requirements and choose a framework based on the projects needs and if you’re hiring people based on their knowledge stack focus being one framework they are probably juniors. Mithril can be picked up in an hour due to its programmatic approach and any seasoned developer can work with it. If you understand Vanilla JavaScript then you understand Mithril. Lastly and in closing, you seem to have come across butt hurt by my remarks and your response is a clear indication that you’re yet to even try Mithril. It also indicates that you don’t expose yourself enough to what else is out there and simply just follow the waves. Do you look at the source code behind a lot of these frameworks or do you just take what they ship? I advise you to delve a little deeper and be a little more thorough in your approach. 
Hey! Thanks, it’s actually [https://mithril.js.org/](https://mithril.js.org/) - thanks for the spot though, the domain doesn’t use “www” 
&gt; But there were LOTS of breaking changes, including the plugin/loader system, so you cannot migrate until all the 15 Webpack plugins and loaders you depend on have migrated as well. I like Webpack, but I think most problems stem from using Webpack for something other than JavaScript bundling. DO NOT Webpack ALL THE THINGS. Using Webpack for JS bundling is relatively painless and fast. Using Webpack for anything else feels like a gigantic hack. The entry point Webpack uses (JavaScript) is totally wrong for CSS/HTML/etc. and you end up playing Jenga in a config file and doing batshit crazy things like importing CSS into JavaScript and spitting it back out again to get things to sort-of work the way you want. Parcel has its own problems, but using HTML as an entry point makes much more sense for doing non-JS related build tasks. These days I'm using Webpack just for JS, postcss-cli for CSS, browser-sync, and copying some static assets, all via NPM scripts. It's the sanest and most flexible approach I've found.
&gt; there's always an ideal solution out there that we are striving to arrive at Sorry, but I don't agree with this premise at all. Whatever's the "ideal" solution depends largely on someone's priorities, and is thus very subjective. In other words, I don't think there's something like a universally ideal solution. I do put value to tools being easy to learn, because that means people can get productive with them much faster. So to me the "ideal" solution also takes that constraint into consideration.
You might like this pattern: https://medium.freecodecamp.org/elegant-patterns-in-modern-javascript-roro-be01e7669cbd
jesus christ
there is a babel plugin that allows for this kind of thing https://github.com/rse/babel-plugin-named-params
more emojis the better
Cool! Updated my comment to not confuse people too :)
&gt; As someone else mentioned in the comments, breaking changes can be avoided by simply choosing not to update. Sorry, but I think that's an unreasonable position to take. Breaking changes also introduce incompatibilities with plugins and other parts of the ecosystem. Upgrade too early, and you risk your plugins breaking. Upgrade too late, and you risk being left behind by plugins that won't support your version anymore. A similar situation occurs with documentation. Upgrade too early, and most documentation online will be outdated. Upgrade too late, and it becomes harder to find documentation for your specific version. For projects that are central to the ecosystem of other projects, which Webpack definitely falls under, there's definitely a point to be made for not releasing breaking changes too often.
No problems! Join us on the gitter chat too if you need any help: [https://gitter.im/mithriljs/mithril.js](https://gitter.im/mithriljs/mithril.js) 
&gt; As an aside, the sense of entitlement here is too much. Open source maintainers owe you nothing. Once your project crosses a certain threshold of importance, then you do end up owing your users at the very least, stability. Your attitude would never fly in Apache, Linux kernel development, or any other mature OSS project that has become a critical part of something.
cool! will do that..
&gt; Sorry, but I don't agree with this premise at all. Whatever's the "ideal" solution depends largely on someone's priorities, and is thus very subjective. In other words, I don't think there's something like a universally ideal solution. For a given set of constraints, there is an ideal solution. Some solutions are over engineered. Some solutions fail to handle every use case. Some solutions are overcomplicated or less elegant. There are many dimensions to a possible solution, and it is possible to optimize for all of them and arrive at a solution that is ideal. There could be more than one ideal solution, of course, but all solutions are absolutely no equal. I didn't state that there was a universally ideal solution, but for a given problem with a given set of constraints, there absolutely is an ideal solution. The priorities you mentioned would of course be constraints to the solution. The webpack devs have defined their own priorities, and within those constraints there is an ideal solution. Using that framework, my argument is that "learning curve for beginners" shouldn't be a necessary constraint for all of our tools. Of course, it is fine if someone decides to start a project with that as a priority, however if a team of developers have set out to create a tool that is designed for experts to use, that shouldn't be seen in a negative light. 
Thank you, I'm glad you like it :)
Yeah, I spent two hours on a medium-sized project - the migration guide they link to is for plugin developers, not Webpack users.
I tried them, but still enjoy chart js
What do you think about the criticism of entitlement?
what is going on here!?
&gt; Have you ever ejected a Create React App? Have a look at package.json. Almost 30% of the dependencies are Webpack related. I'm convinced that 99% of JS developers have never, ever, touched a maven-based project in their life times. The amount of complaints I see about npm install downloading half the internet amuses me. In many cases, the lack of a robust stdlib for JS is a nuisance, but modular frameworks and toolchains are not. Go look at a complex maven-managed Java application and see how much bandwidth maven sucks up downloading half the internet. Those JARs are a lot bigger than a bunch of JS files let me tell you! &gt; If it is a standalone library, should it need anything else? Should it ever need a plugin/middleware system? Shouldn't innovation come from within? Again, Maven, a far more mature build and dependency tool, does it this way. Maven provides a workflow, and a dependency manager, and a few other bits. Everything else is provided as plugins. &gt; Sure, the library maintainers could design a better, easier way to introduce breaking changes. But we are the ones asking for all these features. ALL. THE. TIME. So? Doesn't mean they can't be plugins. We ask for features, those features can be exposed as plugins. No worries. I'd rather have ONE build tool and MANY plugins. I don't really care if my devDependencies list is multiple pages long, that's entirely irrelevant. Frankly, it would be awesome if dependency management and build management were merged into a single tool as well, just like maven. Then I can reference a plugin in my build tool, and my build tool will know to download it if it's not available. Less verbosity! 
In the wake of recent noise over the Array.proto.flatten debacle, this will get downvoted into smithereens but still, it was a nice reminder to me... MooTools __was__ At a time, when the alternative approach was jQuery with its terse css-like approach that didn't scale, MooTools was the programmer's choice. It extended native types (which at the time was acceptable) and showed what JavaScript could become. A lot of the methods and solutions that it offered some 8 years ago have now become the defacto ECMA standard. It rendered itself to extensibility and taught people who used it how to become better JavaScript devs and programmers in general. And it had a goal: be useful until it becomes redundant. It is redundant now but it served it's purpose - and many of its core team devs moved on to create and work on react. So, a minute's silence for MooTools 
Cool, I’m actually building a right now, and need to make some graphs. This could be useful information.
While that's certainly true, Linus fortunately has "never break userspace" as one of his most important principles, so you're unlikely to see criticism like the above leveled towards him.
Once the path has been made to using alternatives in the browser other than JavaScript, problems like this are going to kill it. Seriously. 
&gt; If I tweak something 3-6 months down the line, I don’t want to hear how my efforts are now deprecated and replaced with a new version that is completely incompatible You don't like it - but could it be in our interests? I wonder if the general hassle of building JavaScript is driving up prices for JS developers - you can't hire web generalists any more, so there's no a market for highly-knowledgable specialists who can wade through all this crap. Annoying as it is, being a Webpack whisperer is a strong asset as a contractor, as is knowing the jungle of React partner libraries. Long term it cannot be sustainable. This is one of the things I recently wrote about in [The State of JavaScript 2018](http://www.breck-mckye.com/blog/2017/12/The-State-of-JavaScript-in-2018/) - producing JS apps is too hard and more importantly, too expensive, which creates a long-term economic incentive to simplify our buildchain. And so I think that will be the oncoming trend of the next two years.
&gt; Sorry, but I think that's an unreasonable position to take. There are downsides to not upgrading, and yes, it's possible to be left behind. However, it is a completely viable option for a project with an established project with a relatively stable feature set. Of course, at some point it may be necessary to upgrade if the requirements of your project change and cannot be met by the older dependency, but there is no requirement to upgrade to a new version just because it exists. &gt; Breaking changes also introduce incompatibilities with plugins and other parts of the ecosystem. I agree, that is a separate issue that needs to be considered by the development team. Most projects solve this problem by continuing to maintain older versions, and only release breaking changes at major releases. I don't know the entire history of webpack, but I would imagine they confirm to this principle. &gt; Upgrade too early, and you risk your plugins breaking. Upgrade too late, and you risk being left behind by plugins that won't support your version anymore. You can't upgrade "too late", you simply wouldn't upgrade until you run into an issue. That issue may be that your project's scope expands, introducing the need for a plugin that doesn't support your version. Upgrading at that point isn't too late, and while it may be a hassle, as I've mentioned before, I personally would rather have access to better tools at the expense of having to expand my skillset on an occasional basis. &gt; Upgrade too late, and it becomes harder to find documentation for your specific version. How often is that actually a problem in practice? I've never seen a project that didn't retain documentation for older versions. &gt; For projects that are central to the ecosystem of other projects, which Webpack definitely falls under, there's definitely a point to be made for not releasing breaking changes too often. Obviously there are potential issues with releasing breaking changes. Those issues need to be weighed against the benefits. I'm not arguing that there are no consequences, however it is my position that true progress should never be stifled because it may be inconvenient to some developers. 
chart.js is pretty cool but when i want to interact between graphs i find dc.js more userfriendly :)
From Linus himself: &gt; If a change results in user programs breaking, it's a bug in the kernel. We never EVER blame the user programs. How hard can this be to understand? ref: https://lkml.org/lkml/2012/12/23/75 So if a user land program depends on a kernel feature, and that feature changes, then users will be rightfully entitled to treat it as a regression. Calling users who expect stability from their critical toolchains "entitled" is an ironic attitude to have for a language community primarily focused on UI/UX concerns.
I love it! works well. Been searching around for the .EXE for a while. Do you have that file too, by any chance? 
what is a "dynamic"?
Outside perspective: The problem this article describes seems more fundamental than just webpack, and more based on the way the entire Javascript ecosystem is a jungle.
I won't argue with someone who clearly has more experience than me.
To be honest, I really don't see the need for it. One common workaround is to pass in an object to the function. Then you could also set default parameters... parameterObject = {name: 'NAME', timeOfDay:'TIMEOFDAY'}; function greet(parameterObject){ // Use paramterObject.name if it exists, otherwise use 'User' as default var name = parameterObject.name || 'User'; var timeOfDay = parameterObject.timeOfDay || 'Day'; console.log(`Good ${timeOfDay}, ${name}!`); } Maybe this is something you are looking for?
True
Look at this demo: https://dc-js.github.io/dc.js/. A dynamic dashboard is a dashboard where you can click on every graph and your click will filter the data accordingly and update every graph
yeah but your title is "build a dynamic with javascript" ;)
My bad. I meant a dynamic dashboard :). I change it right away 
IMHO Inferno.js codebase is even nicer.
IMHO Inferno.js codebase is even nicer.
while I don't use jquery much anymore now that I've jumped on the Vue bandwagon, it's still far superior to the native DOM APIs. $('p').addClass('error'); is better than document.querySelector('p').forEach((el) =&gt; el.classList.add('error')); as a simple example. &gt; I'd like to leave out documentation quality as a factor. No matter how intuitive your API might be, proper documentation is absolutely a concern when gauging quality of a library/framework so I don't see why you'd want to leave that out. 
Care to link to how to create smaller chunks that work with hot modules? I've only come across guides that suggest on creating one massive bundle.js - I haven't managed to find one that works when creating multiple chunks.
Monkey Wrench. Let’s you run custom css or js on a site every time you visit.
Well you're absolutely right there's a numbers game. So far, I've been trying to keep it to companies that I am interested in. And trying to stay remote, because I'm not in a position to move. I need to get out there more, to really get at it. I also need to improve my skills in the area of things people interview on these days. 6 years ago it was a bit more wild west in JavaScript especially and in gaming.. experience was all that was needed. I've turned down a few game jobs recently because I'm so rusty on game dev that I couldn't be at the level I expect of myself right off the bat. But I'm working it back up. 
Don't let this author fool you: there is nothing wrong with Webpack. Guess what? You don't HAVE to update your Webpack version every time a new version is released. Your project isn't going to suddenly stop working and your config isn't going to blow up. Create a new config that works for the latest version when you start a new project. If the major version hasn't changed since your last project, you can re-use your old config. Otherwise, existing projects stick with the Webpack version they were developed with, and keep their existing config. I only might update Webpack versions and configs in old projects if I'm doing some major new feature for the project or refactoring some janky code. If I'm updating my dependencies, I may also update my Webpack and config. It's not really a huge issue for me. I do understand it can be a bit confusing when starting out, but once you get familiar with it, even major version increments shouldn't bother you that much. And yes, sometimes you might have to wait to adopt a new version because your favorite/vital plugins aren't updated yet. Not a huge deal considering everything that the Webpack ecosystem is giving you for free.
So. Many. Typos. Couldn’t take it more than a few paragraphs. Really adds to the “angry rant” tone and discredited the author’s authority on the subject. Slow down. Be concise. Proofread.
scotch.io is a great resource 
That's fairly cool, they use a lot of JSON i'm trying to make this as minimal config as possible! Just plug n go :) 
LOL that's ok, I was just joking. I actually wrote a book on Backbone and have definitely seen (and in fact have written written) a maintainable Backbone app. But because the framework has such a reputation, I couldn't help teasing a bit.
Fusebox is very enjoyable indeed. Anyone reading this, give it a try. 
That's a great idea, can't wait to test it out on my demo.
Help Try offering assistance and guidance instead of bashing someone without a rebuttal 
&gt; Of course stability is expected, but not when a MAJOR version is released because that is explicitly a release with breaking changes. the problem with that approach is that you feel at liberty to introduce breaking changes without considering those impacts because you hide behind "oh well major release, that's just life folks!" Imagine how upset people would be if their save files didn't work across major releases of the software that generated them. Another scenario is that you depend on a plugin, which now has a bug, which is only fixed in the newer version of the plugin that only supports the next major release of the host application. That's not stability. While you can argue "it's open source, so you can fix it yourself, merge the fix yourself, etc etc etc", that's not really the point. The ecosystem in general should not be forcing end users to do this work. Breaking changes shouldn't be introduced without very careful consideration for the users who would be impacted, regardless of what version number it is. At the very least, you should go through a process of deprecation so that old functionality still behaves as expected, giving you time to adjust. My exception with /u/Mingli91 is the implication that OSS projects owe their end users nothing. That is a horrible, anti-user attitude for projects of major significance such as Webpack, and end users have every right to expect better.
WebAssembly will follow the inevitable path that flash went down, a security nightmare 
There's a difference between a breaking change in a platform and a breaking change in a utility. You can't elect to stay with your current version of Linux, Chrome, Safari, or Firefox forever, you may not even have control over the version being used. Thanks to the stability of those platforms and their "don't break compat" mantras, you can decide to stay with Webpack 3 until you're ready to make the move, if ever.
It's not your fault
We could never do this ... but we have 7+ microsites + component library project + other small internal libs for logging and others, Google analytics, services integration, own nodejs server package for ssr/graphql. Webpack is very complex.. but at the same time, when you get into an ecosystem like ours it's very powerful 
Webpack and Rollup are similar products but have different use cases. Rollup is generally meant for compiling JS libraries and webpack is generally for end-user projects. Rollup's creator, Rich Harris [says as much himself](https://medium.com/webpack/webpack-and-rollup-the-same-but-different-a41ad427058c). Not to mention, he helped implement every killer feature in Rollup into Webpack itself. ...that said, I'd totally recommend Rich's Buble as a lean alternative to Babel and Svelte as a fancier Inferno.
What's wrong with amqp-connection-manager? https://github.com/benbria/node-amqp-connection-manager
[removed]
&gt;Please share, repost, tweet, spread the word about this story so it would get fixed as soon as possible. Or you could just let npm support know directly, rather than hoping they indirectly find out.
Instagram isn't the best to find JS tips and tricks. Twitter and medium post will be much better for that. But if you want to look at pictures of computers that the programmers use then Instagram is the place to go. 
I started out that way back in high school but took two years of computer science and then attended a Front-End coding boot camp.
Which boot camp did you do? I’m trying to get a job by end of this year ... but it seems it may take longer? 
&gt; Seriously, wow life was before hot-reloading? Did we really used to reload the page ourselves? I still manually reload the page, because I've yet to find a hot-reload plugin that actually works.
I attended The Iron Yard in Cincinnati but they have since shut down.
My favorite is Greensock Animation Platform. I started out developing web games using JQuery's .animate method, but after I discovered GSAP, I use it for all DOM-related manipulation and tweening in general. Now I demand it in every project.
Everything that is new to you looks unreadable at first. Ternary operators look like total gibberish if you don’t know how they work. That’s not to say that readability is totally subjective, but using basic, core features of a language should not be a major consideration for readability.
monaco editor documentation quality is a major factor for any lib, why would you exclude?
Reddit doesn’t allow you to edit the post title, but thanks for clarifying!
I’m completely new to JS and in particular functional programming, so after trying to learn as much as I could, I refactored the example application from the awesome book Mostly Adequate Guide to Functional Programming from Brian Lonsdorf, using the old Folktale library, the new Folktale 2.0 and Sanctuary plus Fluture. It’s VERY simple, but I’m so glad I understand the concepts now. It’s all the different versions of app.js, with the different examples. https://github.com/peterstorm/flickrShenanigans/tree/master/src
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [peterstorm/flickrShenanigans/.../**src** (master → 3028006)](https://github.com/peterstorm/flickrShenanigans/tree/30280069c349e04e07b26c957760e6c5cdbf22f3/src) ---- 
That picture is pretty scare
Is this actually using DEFLATE?
I would love to use more ramda, but I get better co worker conversion by making them use lodash, then lodash/fp.
Picking React over something else can be a good choice if you work in a company with thousands of web engineers where you have platform teams to fix webpack insanities after the fact for you. But even then, that choice might still bite you in the ass. It did for m.uber.com, for example, and the engineering cost of fixing perf was not small, even with very smart engineers. The point of the parent is that if perf had been a concern from the very beginning, one could have saved a lot of money when perf did become an important metric. The cost of learning Mithril or Svelte, or even learning enough of a production-ready micro-lib for the unlikely need to submit a PR pales in comparison to the amount of work it takes to fix perf in a moderately complex app. What people don't realize is that Facebook/Google and co are willing to throw a ton of money at their problems (and oh they do), but their problems may not be your problem. When they have perf problems they can put a team of highly paid engineers on it for six months. You probably can't. But everyone can learn a micro-lib just as well as any other if their job depends on it. Just some food for thought. Regarding credibility, I find that entire argument very weird. People often rely heavily on lodash, which doesn't have some major company behind it. Same for D3 and Socket.io. Express was on the same boat for years. There's a large number of heavily used projects sitting all over the funding spectrum. You probably rely on dozens of lone-soldier projects to get anything built at all, but somehow they get a pass? In the last state-of-js survey, Mithril was right behind Meteor, a framework w/ 14 million dollars in funding. We should be careful not to use the credibility argument as a thinly veiled excuse for job security or laziness. One needs to realize that there are such things as things that simply don't need to be maintained (at least not in the sense of having a full time team on it 40 hrs a week). Code doesn't just magically break or rot as soon as you stop committing to it. I remember seeing one C project that had had no commits to it for over 10 years and it was still perfectly usable (and useful!). On the other side of the spectrum, go look at some of the more controversial TC39 proposals. In terms of software quality, I think we should be striving for the former, not the latter.
&gt; I get better co worker conversion I totally agree with this but I am now on a team trying to get them used to `lodash/fp`, moving from `lodash` and they are having the hardest time understanding `map` vs `forEach` and `data-last`. It almost feels like we should have skipped `lodash` all together and either jumped into `ramda` or `lodash/fp` instead. Have you experienced the same pushback?
In my opinion VueJs is the best use of current Javascript, React is trying to advance Javascript. So I like both. For just using it for one project. With Javascript experience I think VueJs is more reliable, less learning curve. If you enjoy learning something new React is really nice. Both can do the job, just personal perferences.
If you implement it incorrectly, then of course (like all things), it won't work well. Obviously, the right thing to do is to implement it correctly instead - it doesn't mean that random sorting itself is impossible, just that you have to not mess up while writing the code.
Man, that's wild. Nice work!
https://github.com/prettier/prettier https://github.com/rollup/rollup https://github.com/MikeMcl/decimal.js https://github.com/josdejong/mathjs https://github.com/propelml/propel https://github.com/caolan/highland https://github.com/Gozala/reducers https://github.com/ramda/ramda
 Array.from(document.querySelectorAll('p')).forEach(el =&gt; el.classList.add('error')); FTFY ;)
Read the actual GitHub thread. https://github.com/tc39/proposal-flatMap/pull/56 It's a good read, and the contributors work towards figuring out how to move forward. Both sides of the argument have issues, and both sides have points. This article, however, just picks one side and paints everyone on the other side as reckless sociopaths. This is not the case. It is a conversation that absolutely needs to be had.
But alternatives like ActionScript killed by their problems
Not at all. It’s just an alternative to JavaScript, provided by the browser, not a shitty plugin provided by a shitty company.
Do you have any tests that show how well this would compress on larger datasets? Say, 50kb of fairly random strings and numbers? Looks very useful under the right conditions.
There is backwards compatibility and there is ridiculous shit like this where people think that we should rename methods because some 8+ year old version of an unmaintained framework will break…
While the approach is similar it does not use deflate directly
Appreciate the feedback! I just so happened to find it last week, I'll pm you!
Thank you!
Thanks Good Will Hunting
My first though was like "great, I could add this between sending raw json and gzipping it by the server!", but after some tests I found out that... it depends. It really works nice in that way if you got a bit *bigger* JSON files, eg. 20kb+, with a lot of similar data "rows". However for smaller it's redundant, results are comparable with gzip (in size of course, and gzipping after zipson will only add some more bytes). But if your server doesn't handle gzip (even possible?), it's really useful library!
Not yet, but the results would be similar since it's the same file on a bit level you're transferring.
Hmm yeah that’s weird, if mobile safari is dropping the data I don’t know. Maybe there is another way to validate the image, like using the camera instead of allowing to pick a file?
I would say it depends on what you are trying to learn, but probably not. Jason is a great developer and has a strong focus on performance, and it shows in his style. All over Preact are (or were) clever golf-style techniques to reduce lib size and V8-specific tricks. If this is what you are interested in learning then Preact is a great resource for that.
Common !== good I'd rather use a modern node-based toolchain rather than having to maintain two versions of my scripts, thank you very much. And even before node, I would use apache ant, which was also cross-platform. But YMMV.
the worst kind of spoiled you can get is at a job whose legacy codebase uses jquery so you just get accustomed to jquery selectors ill take that shit to the grave; i love the jquery selector syntax and no one can convince me otherwise 
counterpoint: PHP
If you're refering to _includes_ instead of _contains_, I agree. It's just weird to call it includes when pretty much every other language calls it contains.
Hey! I am looking at Udemy right now, when you say that the first 3.5 hours are free, did you mean just the 'Previews' that are available on this page at the bottom? https://www.udemy.com/understand-javascript/ Am I missing something? It looks like you actually have to buy the videos :( 
this was really well written. good to see more lower level comparisons like this (as in, not the typical React v Vue v Ember)
The whole point was to cover the rest of the cases :) Sometimes it might get quite messy if something is really deeply nested. Cheers!
&gt; not a shitty plugin provided by a shitty company. Flash deserves credit for what it did for the internet, it enabled video on the web, it enabled easily playable web games and more, something you can only do now using html5 and canvas, keep in mind these things did not exist for the majority of the last decade. I'll ignore the remarks on Adobe as a company because thats an entirely different subject. Flash was not a *shitty plugin*, you clearly don't understand much about the history of flash and flash being in the format of a plugin doesnt make flash itself a plugin. Lastly the security concerns around flash are because you are running binary (non interpreted) executable's downloaded from random sources, there is no way to differentiate between good allowed exe's and bad hacker exe's unless you implement some standardized language like we have with javascript and even javascript has security problems that can crop up, the problem web assembly claims to solve is performance and while it may help there are libraries now that use native javascript to bring similar performance and you can build these same apps with just using vanilla javascript if you invest the effort. The problem is really that you are executing binary data again from random sources on the internet, I don't need to download a blob of C# when I visit a webpage and have it do all kinds of things you shouldn't be allowed to do in a web browser. Its a cool idea and it has its purposes I'm sure of that but mark my words, it's going to be a disaster in the long run. 
I’ve been working on a personal project and saw that I would be rewriting a ton of code so I too made a custom wrapper. If only you had posted this 3 weeks ago and saved me the trouble of writing one for myself *sigh*
I find working on algorithm problems to get really dry after a few hours. To stay motivated, I try to dream up amazing shit to code--it's not that hard, seeing as you can code just about anything in JS. I then alternate between algorithm practice and my projects. You learn much more from coding projects than from algorithms, and after getting stuck into projects for a few weeks, you'll find the algorithm problems much easier. 
I don't have any Apple devices on hand, but maybe the `File.lastModified` property works for my use case.
3. 
drop the requirement for remote cooperation, and you'll find your efforts more fruitful. goto meetups. code bootcamps usually do one or two nights a month for promotion. youll meet people at the same level.
omg. i am trying CodeFights right now. The interface is quite beautiful!~ 
It is and as a bonus they have regular coding challenges and you can go up against company bots.
&gt; No, I’m not a Java developer, but I wish I could write websites in Java. Would’ve be at least twice as fast. PayPal would disagree. Hmm, WalMart too.
It's not uncommon to find that one of those files no longer works because someone couldn't be bothered updating it.
The difference between an OS and a compiler like Webpack is that you are forced to update your OS in order to patch up vulnerabilities. There is no such consideration with Webpack, you are free to keep using old versions as long as you want. Linux’s “don’t break userspace” rule would apply to something like JavaScript, where the user has no choice but to update. Look at the current furore around smoosh/flatten and MooTools. Webpack, and every nearly every npm package, does not have the same limitations simply due to its nature. You, the developer, have complete control over which version goes into your app. With Webpack this is even less of an issue. You would have a legitimate grievance if Webpack 3 was found to have a security flaw and the fix broke current configs. Instead they released a new major version, and major in semver means potentially breaking changes to the API. Also I am curious to know what being primarily a front-end language has to do with entitlement? I’m seeing no connection there.
WeLcOmE tO WeB dEv In 2o18 LoL xD we r srs PrOgrammerz
I had relatively small configurations. I just Google’d my way there, but primarily the improved error messages were the main help. No links sorry.
Are you loading jQuery before this script!
Fuuuuuuuuuuuuuuuuuuuuudge.
Do you have a library card?
Markdown striketh again.
Ahh, I see. Making a reusable wrapper function like that is a pretty cool idea.
IIRC Ruby has `includes`, but squash instead of flatten?
I will be messaging you on [**2018-03-14 00:50:58 UTC**](http://www.wolframalpha.com/input/?i=2018-03-14 00:50:58 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/javascript/comments/83xymw/were_having_chris_coyier_of_codepen_css_tricks/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/javascript/comments/83xymw/were_having_chris_coyier_of_codepen_css_tricks/]%0A%0ARemindMe! 27 Hours) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Yea, but was looking for something that would easily make charts and graphs, not just collapsable tags. Ended up building my own with plot.ly. thx
No, they were small and used to build front ends. The biggest problem we encountered was isomorphic style loader not working, so we instead used extract text plugin to generate CSS files to serve separately from the main bundle. I did not say “if you can’t keep up, stay behind”. I didn’t even allude to it. People don’t like staleness or staying behind... I would argue nobody on Webpack 3 is going stale. Webpack 4 was released Feb 25th... if a couple of weeks is too long for someone to wait to update their friggin compiler, then they are acting entitled. Breaking changes to Webpack don’t come every week. Sure they’ve released a major version fairly quickly, but it’s still not violating semver. On my phone at the moment, but I mean the actual docs. Check the website repo. There have already been updates to the API docs and there is an issue you can track for v4 docs updates.
You likely should not use an id tag for #image if you have more than one on the page. You can do a $(this).find(“.image”) to obtain a child element with an image class. Unsure if this is the issue though.
I’m building a right now too!
I believe this capability is built in to the dev tools of IE and chrome couldn’t say for others 
Honestly, I'm deciding between Node.js and Laravel for a new project. I like Node.js, but at the same time, the speed at which everything changes makes me reluctant. I mean, Laravel has more or less stayed the same for years. With templating alone, I was debating in my head between Handlebars.js, EJS, Pug and some others. The choices are overwhelming.
You said the very least they owe is stability, I said it's already stable since they follow semver. I don't think you're criticising my "worldview", but rather semver. It's not "LOL major update, deal with it kiddo" it's a standard that the community has agreed on and Webpack is not deviating from that. I don't have a "horrible, anti-user attitude". Someone who has already donated spare time to make your life easier really doesn't owe you a thing. Would you mind telling me what it is they owe? God knows they've given up enough of their free time. And that's kind of the whole point of *open* source. Sure, there are often primary maintainers, but it is owned by the community. You, as a member of the community, are able to modify the code however you please. If the owner doesn't like it, you can fork it and there isn't a damn thing they can do about it. Also, with regards to the above (contributing to OSS), you say: "that's not really the point. The ecosystem in general should not be forcing end users to do this work." Well, guess what? You're not the end user. And tell me, what do you use these open source projects for? For your job? For side projects? Quite often, it's something that is valuable to *you*. So, we have a situation where someone has given up a significant chunk of their free time to essentially help you make money. But still you say it's "not really the point" that it's open source and that you should contribute. As someone who has worked on a large open source project (not saying which, this is my shitposting account), I can tell you with certainty there are very entitled people in this community. Their main problem is they've become so accustomed to having everything handed to them on a plate that they don't even realise they're entitled. Not to hammer the nail too much, but it literally is the point of open source software that anyone can contribute to and use the project.
That's actually an easier question to answer than "how many packages". A few notes: 1. Just because a few people are moving at break-neck speeds doesn't mean you have to do so. It's okay to use a simple Express with no bells or whistles. 2. Pick whichever templating engine feels most familiar to you. I prefer nunjucks because I am used to Django's templating engine. 3. If you intend to use React, consider using [Create React App](https://github.com/facebook/create-react-app) which does everything (too much, in my opinion, for you). 4. Don't be afraid to try both! Try building a prototype in both frameworks, and see which one suits you best. It's okay to throw away prototypes. The goal is gain knowledge.
You said the very least they owe is stability, I said it's already stable since they follow semver. I don't think you're criticising my "worldview", but rather semver. It's not "LOL major update, deal with it kiddo" it's a standard that the community has agreed on and Webpack is not deviating from that. Seems I can't emphasise this enough: nobody is holding a gun to your head and forcing you to update. Webpack 4 was released Feb 25th. Hold your horses and chill out. I don't have a "horrible, anti-user attitude". Someone who has already donated spare time to make your life easier really doesn't owe you a thing. Would you mind telling me what it is they owe? God knows they've given up enough of their free time. And that's kind of the whole point of open source. Sure, there are often primary maintainers, but it is owned by the community. You, as a member of the community, are able to modify the code however you please. If the owner doesn't like it, you can fork it and there isn't a damn thing they can do about it. Also, with regards to the above (contributing to OSS), you say: "that's not really the point. The ecosystem in general should not be forcing end users to do this work." Well, guess what? You're not the end user. And tell me, what do you use these open source projects for? For your job? For side projects? Quite often, it's something that is valuable to you. So, we have a situation where someone has given up a significant chunk of their free time to essentially help you make money. But still you say it's "not really the point" that it's open source and that you should contribute. As someone who has worked on a large open source project (not saying which, this is my shitposting account), I can tell you with certainty there are very entitled people in this community. Their main problem is they've become so accustomed to having everything handed to them on a plate that they don't even realise they're entitled. Not to hammer the nail too much, but it literally is the point of open source software that anyone can contribute to and use the project.
&gt; Do you think that it is better to start building things or should I be doing a lot of practice JS problems. You should do both. At the beginning when you try to start building things you'll probably get stuck a lot. So keep doing the practice problems and then when you come across something that looks useful you can try to make progress with what you are building. It keeps you paying close attention to the practice problems and you'll to experiment with what you learn from them. You'll probably try out a lot of ideas that fail, which is great. Knowing everything that won't work is what we call an expert. &gt; do you think I should be learning HTML/CSS the same time? If I were you I would learn the tools in the order that you need them. Why add tools that that you don't need? Here is what you get from each tool: 1. HTML - you can build informational sites that all look the same, and pretty ugly. 2. CSS - you can make sites look better by controlling how HTML elements look, and how they are laid out on the page. 3. JS - You can add behavior to pages. For example you could make a game. It makes a lot of sense to start with HTML and learn the dozen or so most common tags like p, div, h1 - h6, img, a (anchor), ol, ul, and li would be a good start. Then if you are more interested in layout and design you could go to CSS next. If you are more interested in adding behavior, go with JS. But a warning there. A lot the cool stuff that has to do with behavior has to do with changing the appearance of things so that will probably quickly send you back to first learning CSS basics. The above leaves out a lot of important details about what each technology can do, but it's good enough of a mental model to get started.
Having worked on large SPA in both, there are pros and cons with both, but ultimately both are fine.
Orrrrr depending on your organisation just use a monorepo and skip all the third party dependencies?
There are still a bunch of "middle-level javascript developers" earning nice amount of cash who still don't know about prototypal inheritance, closures, eventloop etc. Yes, there are libraries for everything, but you have to know what to implement in your own server app. Btw this lib should be also good with browser env, so probably no node server is required.
Damn this looks awesome! I wish I had the $135 for the course while it's on sale! I'll have to come back and see in a few months. It's tricky being a developer and a new Dad because development courses and books can be so expensive
If you want to consider your kind of data as binary "application/octet-stream" would be enough, but imho good ol "text/plain" does its job.
https://youtu.be/Bv_5Zv5c-Ts 
NodeJS 
You’re comparing two very different things. Node is not a framework, it just runs JavaScript code. Laravel is a framework. You should be comparing Node and PHP or npm and Composer. Even then the comparison in terms of number of libraries is meaningless. You don’t need to learn all of them, you only need to learn the ones you’ll use and have a method of finding libraries to solve your problems.
I understood that and not exactly, maybe just to decode content compressed on the server. However nowadays we've got WebRTC-based apps so using it in p2p connections could make sense also.
I build Dynamics for a living. It helps me 93mb of rar files.
counter to your counterpoint: PHP /s
Yippeeeeeee
&gt; You said the very least they owe is stability, I said it's already stable since they follow semver. I don't think you're criticising my "worldview", but rather semver. It's not "LOL major update, deal with it kiddo" it's a standard that the community has agreed on and Webpack is not deviating from that. It's not semver that is the problem. and maybe it's not webpack. I'm generalizing here. But just because you can justify increasing the major version does not mean you MUST introduce incompatible changes. &gt; I don't have a "horrible, anti-user attitude". Someone who has already donated spare time to make your life easier really doesn't owe you a thing. Would you mind telling me what it is they owe? God knows they've given up enough of their free time. Projects of importance should be cognisant of the impact they have on end users. Again, hiding behind semver to justify breaking changes is not enough for projects as important as webpack. There has to be a bigger rationale to justify the consequences of your actions. &gt; Well, guess what? You're not the end user. And tell me, what do you use these open source projects for? For your job? For side projects? Quite often, it's something that is valuable to you. If I am using said project, then I am the end user. As for the rest of your point, that just because I can change it I shouldn't complain about other changes I may not like, is nonsensical in the real world obviously. Those of us with jobs, and customers, and shareholders, and all those things that demand more than we can give, tend to drain us of the time we'd love to give to these projects. &gt; As someone who has worked on a large open source project (not saying which, this is my shitposting account), I can tell you with certainty there are very entitled people in this community. Their main problem is they've become so accustomed to having everything handed to them on a plate that they don't even realise they're entitled. Maybe in some cases, but there is a fuzzy threshold where something mundane turns into something important/critical. At that point, you now have a responsibility to all these entitled users. 
I vote for smoosh()
Expensive as fuck
Cool but rxjs adds too much complexity.
Thank you! 
Hey! I'm a new Dad too. Shoot me a Twitter DM and we'll see if we can work something out. 
I just started learning JavaScript (along with HMTL/CSS obviously) 2 days ago. If you're interested send me a message and we can link up. This is definitely something that will keep me focused and motivated in my learning process.
It's free for open source and 3 private Scopes
Ah. FP === Functional Programming?
This kind of shit really pisses me off. People get ideological about shit and this zero tolerance mentality sets in. They act like breaking mootools is like burning the library of Alexandria. Give me a fucking break.
Killer
&gt; But just because you can justify increasing the major version does not mean you MUST introduce incompatible changes. I didn't even remotely suggest that. &gt; hiding behind semver to justify breaking changes is not enough for projects as important as webpack. It's not "hiding behind" semver, it's using the versioning system as it was intended. It is designed to enable projects to move forward, part of that means removing old and obsolete APIs. A big part of what makes semver so effective is that **you are not forced to update**. Your projects were building fine a couple of weeks ago before Webpack 4 was released, what's changed that you *need* this update right now? So we have a situation where someone has given you a valuable tool for free, they improve and update it, and now you are free to download the latest update whenever suits you. But you having to make changes to use the update is bad? Should that not be expected? &gt; There has to be a bigger rationale to justify the consequences of your actions. Moving the project forward. Getting rid of outdated ideas and bringing in new ones. &gt; Maybe in some cases, but there is a fuzzy threshold where something mundane turns into something important/critical. At that point, you now have a responsibility to all these entitled users. The responsibility lies with each user of an open source project. If you deem it that valuable and you use it in your projects, it is partially your responsibility. If a community uses an OSS project it is up to that community to update and maintain it.
what the eff
Sometimes you just use completely the wrong word. We're all human. No worries.
I use it for C++ but there is no way I’d use it for JS. Why would you use a build script in one language (that isn’t cross platform mind you) on another scripted language which is cross platform?
I’m at a similar stage, I finished a html course and just started java Script a few days ago I think collaborating would be cool, I’m surprised things like this don’t exist already.
What do you want the logo to look like? I'm guessing you would want to do something like this: function setLogoPosition() { var width = window.innerWidth //you would do something to the logo here based on that width } setLogoPosition() //do this whenever the page loads window.addEventListener("resize", setLogoPosition) //and whenever the page size changes You could also use a [media query](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries), although I'm not sure exactly what Wix lets you do.
I too can vouch for his stuff. I’ve worked at companies with free access to Linda and Udemy and still had them buy Tyler’s stuff for the team.
there's just 1 div with the id image.
Yes, Express is a framework and a very popular one at that.
I didn't know about CSS Paint API until I watched [what's new in chrome 65](https://www.youtube.com/watch?v=_W4GSpoSOZI) video yesterday. I found it very exciting so made this demo.
I know. . .
Yeah. Go fuck yourself. 
Got a link to the update docs?
yes 
&gt; document.getElementById() I'm not advocating for using jQuery over JS. I just think a few of the most common calls are unnecessarily verbose. "document.getElementById" could have been just $(''). Plus, counterintuitive metaphor. If anything, those long-ass call names are the equivalent of pony book covers, lol.
Great! My big question now is, can ngrx store keep a history of the states? So I could back to an old state of the app?
Yeah! Undoing actions is pretty easy. Refer to https://github.com/brechtbilliet/ngrx-undo for an example.
I was just curious, what did you end up deciding? I have been thinking in something similar with the HTML5 games, how did it go with your games?
Yes. Whenever there's a breaking change I'll redo the course. Next big update will include the new context API and all the async features. 
This is very cool! Question, how did you get the plnkr to embed right into the reddit page and be live? I had no idea you could do that!
Good luck! Let me know if I can help. 
That's the advantage over setting "Content-Encoding" and server side gzip?
This means the world to me. Thank you.
no thank you!
Tyler's stuff is great, and I can definitely recommend his courses. If anyone's looking for more learning material, I've got a lot of additional suggestions: - My lists of [suggested resources for learning React](http://blog.isquaredsoftware.com/2017/12/blogged-answers-learn-react/) and [suggested resources for learning Redux](http://blog.isquaredsoftware.com/2017/12/blogged-answers-learn-redux/) - My [React/Redux links list](https://github.com/markerikson/react-redux-links), which links to tons of categorized tutorials and articles on many different React-related concepts - The [Reactiflux chat channels on Discord](https://reactiflux.com), which always has a bunch of people hanging around happy to help. It's a great place to ask questions and learn!
I greatly appreciate the offer of assistance.
Thanks! I didn't mean to embed it (I just posted the editor url) but it seems reddit kindly did it. I was a bit surprised too lol.
"Number of lines of code" has very little correlation with the actual performance of the code. `fetch` is the native request format of the future (for now), which is a notable advantage in my eyes - it's fine to use a library if the native functions don't accomplish exactly what you need, but unless you're dealing with a specific shortcoming fetch has and axios doesn't, I'd stick with fetch.
I am specifically interested in the performance of requesting JSON data. Fetch seems to need an extra step of parsing it from JSON to string and back from string to JSON. Without any philosophical discussion, has there been any kinds of benchmarks on this?
trying to sell that kid? /s
&gt;Fetch seems to need an extra step of parsing it from JSON to string and back from string to JSON For one, that's not what it does - check https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch https://developer.mozilla.org/en-US/docs/Web/API/Response For another, I'm pretty sure *all* browser data gets serialized when it gets sent over the internet. If axios automatically gives you the JSON-parsed result, that doesn't mean axios received the JSON-parsed result, it means that axios did it itself without you explicitly asking it. (If you want to achieve the same thing in vanilla JS it's trivial, just make a fetchJSON function or something) I'm quite doubtful benchmarks would tell you anything worthwhile.
It's a common mistake. The history is that when Javascript was being developed, Netscape (the company the created Javascript) wanted to coast off Java's popularity so they named their language similarly. There's no connection between the two languages.
Generally speaking, you want the names of methods in an api to be clearly and exactly named, not short. If the time it takes to type a couple of extra characters is a concern, use a code editor with autocomplete or snippet completion. When reading code in a familar API, or learning a new API, I'd much rather see methods called `EatFoodUsingCutlery(food, cutlery)` than `EF(f, c)`. One tells you what it's doing and what parameters it expects. The other is devoid of any such insights.
I just skimmed through the article, but I agree that overly defensive programming is a bad thing. Ironically, though, I think the solution is more defensive programming. Being defensive about avoiding the 'bad' kind of defensiveness
Need a guide on how to convince people to use MobX instead of Redux.. Tbh it's one of the only problems with MobX :P 
Do you mean arrays, or do you mean matricies using a particular library? &gt;Should I be worried with this With regards to efficiency, generally it's not something to worry overmuch about until you've run performance tests and have determined that it's truly a problem.
Project is now up on github pages. https://portabletomb.github.io/stock-check/
Interesting, but what about individual styles? https://artjoker.net/blog/ionic-vs-react-native-which-one-is-better/
It's probably best to learn the nicest way to do things as soon as possible. `const` is wonderful, for example. Still, you still need to know how ES5 works even though you (should always be) writing in ES6+. &gt;May 13, 2011 That sounds too old, and it will likely teach you methods of doing things for which there are significantly better ways of doing nowadays. I recommend Eloquent Javascript.
ES6+ most JavaScript frameworks are written in ES6+
They do not owe their end users a damn thing. If they take contributions, then they owe what they promised in return. If not, go enforce your expectations in a court of law, and tell us how that goes. Personally, I think this attitude of "I'm entitled to a good end-user experience because you develop it for me, for nothing" disgusting. 
Nowadays developers give preference to the hybrid and native applications because of their native interface, additional functions, increased economic profit and broader auditory. The top two frameworks for creating hybrid and native programs are Ionic and React Native respectively. Why is it so? Find out the answers in this article. https://artjoker.net/blog/ionic-vs-react-native-which-one-is-better/
Now you create a temporary array, which is more expensive. There are also two additional array accesses. In most languages, doing a swap with a temporary variable is the most optimal way to do it. Anyhow, feel free to benchmark it.
Trying to reason with someone who thinks they're entitled to hundreds of thousands, if not millions, of dollars of development for free in a manner of their choosing, is a total waste of time. 
This is the core focus on my hobby framework [rilti.js](https://github.com/SaulDoesCode/rilti.js). Code ergonomics is important and boosts developer productivity so much. Consider the following in terms of legibility, going the extra step to reduce visual clutter even if it means just adding a line at the top could make code much more maintainable and easy to manage in a large team where everyone needs to be on board. In mithril var view = m("main", [ m("h1", {class: "title"}, "My first app"), m("button", "A button"), ]) m.render(document.body, view) In rilti const {main, h1, button} = rilti.dom main({render: 'body'}, h1({class: 'title', 'My first app'), button('A button') ) 
Not if you use the pre-object-destructuring method in order to support IE: var somefunc = function(params) { var someVar = params(someVar) || 'This is the default for someVar'; } There you can keep your old name as well as newly correct one, assuming the name change is a correction: var somefunc = function(params) { var someVar = params(someVar) || params(somVar) || 'This is the default for somVar'; } Or course this method is much more verbose so if you don't have to support older browsers the object destructuring variant may be preferable but doesn't support this unless I'm missing a trick.
Interesting idea, though I think generating a QR code might be more useful because you could also accept the text encoded in the QR matrix thereby allowing the user to carry a print of the code and use it on devices that they don't control (temporarily logging in to their account on someone else's tablet, for instance).
yikes
Oh, they've also gone all Typescript on us &gt; The result of these years of rewriting and rethinking is something we believe offers a compelling way to build modern applications with TypeScript, leveraging a dizzying array of modern standards and best practices including but not limited to ES2015+, TypeScript, custom elements (web components), Progressive Web Apps (PWA), reactive virtual DOM, Intersection Observers, routing, accessibility (a11y), internationalization (i18n), CSS modules, data stores, and much more. 
Try setting up a minimal hello world example, and show the complete lack of boilerplate when compared to redux. And then hook the store into the redux dev tools so you don't even have to go without those
Damn, I wish I could afford this right now, but the price point is out of my range. Saving this post, in case I can in a few months. His YouTube channel is really helpful (not many videos , but still ..) and lays out things in a very easy to follow way. 
&gt; require("driver.js/dist/driver.min.js"); This line should be `const Driver = require("driver.js/dist/driver.min.js");`
Hi Tyler! Wow, this is very exciting. I've sent you a Reddit DM, I hope that's ok?
From what I can tell the answer seems to be that `Array.slice` + `Array.push` is faster than `Array.concat`. # Simple Version: ### concat According to JSBench: 2 ops/s ±9.57% 73.78% slower function concat (max) { let t = []; for (var i = 0; i &lt; max; i++) { t = t.concat(i); } return t; } let res = concat(10000); ### slice + push According to JSBench: 8 ops/s ±18.94% fastest function concat (max) { let t = []; for (var i = 0; i &lt; max; i++) { let x = t.slice(); x.push(i); t = x; } return t; } let res = concat(10000); So from those two we can see that `Array.concat` is the slower of the two. #With Function Call What I find most interesting is what happens when you introduce a function call within the loop. Let's compare my implementation to the `cN` function in your post. ### My version According to JSBench: 11 ops/s ±20.15% fastest function concat (max) { let t = []; for (let i = 0; i &lt; max; i++) { t = doConcat(t, i); } return t; } function doConcat (t, i) { let x = t.slice(); x.push(i); return x; } let res = concat(10000); ### Your version According to JSBench: 7 ops/s ±20.52% 31.91% slower function cN(max){ let t = []; for (let i = 0; i &lt; max; i++) { t = concatNarrays(t,i); } } function concatNarrays(args) { args = Array.prototype.slice.call(arguments); var newArr = args.reduce( function(prev, next) { let t = prev.slice(); t.push(next) return t ; }); return newArr; } let res = cN(10000); These pieces of code are much closer in performance. And, in fact, they are nearly identical in terms of actions performed. The only reason yours is slower is because it does a (unnecessary) `Array.reduce`. Without that, the code is identical and performs the same (assuming you also lose the `Array.slice(arguments)` bit too which isn't necessary). I haven't done any looking into why a function call makes this faster, but off the top of my head I'd suggest it's the JS engine optimizing the (heavily used) function. 
 function puu (max) { let a = []; for (let i = 0; i &lt; max; i++) a.push(i); } Basically what are you doing wrong in `concat` is: - you are using this method incorrectly - you should use `.push()` since you are not combining two arrays but you're adding new element at the end of it Honestly I do not see what is the point in this kind of benchmark. :(
Why is `concatNarrays` written so _ass-backwardsly_? I mean... no offence meant, but... - The name says it _concats N arrays_, but it doesn't really do that. - you declare the first argument as `args` and then proceed to put a copy of all the arguments into it. - `args` is always of the form `[ [...], n ]` so going with `reduce` on it seems pretty unnecessary and the only effect it achieves is separating back the two arguments received. I mean... function concatNtoarray(arr, n) { let t = arr.slice(); t.push(n); return t; } As for your question... it's hard to say exactly. `concat` does some extra things, though, so it is _reasonable_ that it is slower. I mean, while the final effect in your code is the same, `concat` has to check for the type of the argument as it can take a value but also takes an _array_. In fact, `concat` is more oriented towards this second usage. It's _main_ mission is contatenating *arrays*, so it may very well be that the other case incurs in some penalties.
No. In fact I have barely touched an actual HTML file in years (certainly not in my own projects). We've moved past that. Preprocessers and automated build systems rule the landscape. There were very few reasons to justify it way back when as well. It's fine for learning the ropes but ditch this way of doing things once you have a stronger grip on the technologies. Dynamic content (these days) is made using tools like Angular and React. They're great for SPAs and offer a clean way to build views (DOM) using controllers/models (methods/data).
There is a siren going off in my head when I hear `clever` code - that usually means that only the author is able to understand it/premature optimization/look at my style :-)
Yeah it’s kind of ridiculous. Other languages get breaking changes, could you imagine that guy’s reaction to a breaking change in ECMAScript... Totally agree with all points 
Interesting. I do like that it’s much like an ATM card, where you need the combination of the physical card and your PIN. But like an ATM card, what would be your solution for a lost image? Say I lose my phone that had the only copy and didn’t have it synced with the cloud or I simply accidentally deleted it? How would you then prove your identity to get a replacement?
You are right. Thanks, learned something!
Slight OT but, if you have to spend all that time to understand the concept, maybe it's not worth it and there's a better alternative.
how do you mean?
Why do you need this specific feature of JS? JS is filled with stuff that nobody uses because too complex or with terrible APIs, or just because plain broken conceptually. Focus on what are you trying to achieve, and find a simpler solution to the problem.
The truth is there is no big problem to solve. This is sort of an academic type of question and im just trying to fundamentally deeply understand as many aspects of JS as i can so that im not writing a language i understand little of
?
I only use vanilla when I can, which means when not at work where they enforce a transpiled meta-script language. It has been a long time since I felt any limitation at all.
Your first inheriting example is a little off. Assuming Organism is a constructor, in your sub constructor, you need to call it in the context of the current instance, not passing it in as an argument. Instead of the Organism(this) you want Organism.call(this) This is equivalent to calling `suoer()` in other languages (and in newer JS). Also, with the prototype, if you're assigning `prototype` to a new object, it should be a new object, not the super class's constructor (`Organism`). The idea is that this is an object that represents the API of instances created by this new class. The Organism constructor is not an object that should contain this API; it should only have Organism static members. This is where `Object.create()` comes into play. It creates a new object with a prototype to the object passed in. But again, this object shouldn't be `Organism`, rather it's prototype since that's the object with the API you want instances to inherit from. Human.prototype = Object.create(Organism.prototype) The problem is, this: Human.prototype = Organism Human.prototype.run = function(){ console.log(this.name + "run")} adds run to `Organism` because `Human.prototype` _is_ `Organism`. But we also don't want `Organism` because it doesn't have instance members. It's a constructor so it has static members. We want Human instances to inherit Organism instance members so it should be Human.prototype = Organism.prototype Human.prototype.run = function(){ console.log(this.name + "run")} But this has the same problem of adding run to `Organism.prototype` which shouldn't happen. Human should be it's own thing, hense the `Object.create` use to create a new, separate object for Human to add it's members to. Of course the problem with setting prototype this way also wipes the original`constructor` of `Human.prototype`, so if you want to make sure things are straight, you'll want to [fix constructor](https://www.reddit.com/r/learnjavascript/comments/82amgf/doubt_with_objectprototype/dv9lnzj/). Alternatively, you can use `Object.setPrototypeOf()` (ES6) instead of redefining prototype with `=`. When using the `class` syntax, all of the details of inheritance is handled for you. Not only what was covered so far, but also some additional details such as static inheritance, and constructor call blocking. So (B and C) no, it's not equivalent.
Do you have your ERD for this posted somewhere?
nothing about this seems like a good idea.
I'm pretty sure that try catch being slow is something that V8 has fixed, and is a relic of the past. With the release of async await, and even in previous releases try catch has been optimized to have very little cost, so feel free to use it when necessary.
If you're looking for a *very* in-depth React course, take a look at Maximilian Schwarzmüller's [React 16 - The Complete Guide (incl. React Router 4 &amp; Redux)](https://www.udemy.com/react-the-complete-guide-incl-redux/). I have several of his courses and he is killing it. A Udemy trick for getting low prices on courses is to visit the site in incognito mode where Max's course is [$25](https://imgur.com/a/ARVFk), compared to the normal "public" price of [$95](https://imgur.com/a/ARVFk) I used to just leave courses open in a tab and check them every couple days to see if prices changed, which they do all the time. I picked up the incognito trick from another thread. 
You can shape your `store` however you want. Be it a `number`, a `string`, or even an `object`. If you go with an `object`, you can have multiple `reducers` that act on different parts of the `object` that we are calling state. For instance: const userReducer = (state, action) =&gt; {...} const postReducer = (state, action) =&gt; {...} const reducer = combineReducers({ users: userReducer, posts: postReducer }) Now, whenever an `action` is dispatched, the `userReducer` function gets passed whatever the `users` key is on the state object. Similarly `postReducer` gets given `posts` as its `state` argument. So in our example state = { users: 1, posts: 2 } dispatch({ type, payload }) will cause userReducer(1, { type, payload }) postReducer(2, { type, payload }) And whatever `userReducer` returns will be the value at `users` and `postReducer` at `posts`. So. Using `combineReducers`, you can &gt; have multiple states inside a Store, like a state for categories, one for posts and one for the user Your next question: &gt; can ngrx store keep a history of the states Yes! I usually do this via `middleware` by saying "Each time there is an update to the store that isn't a SAVE_STATE update, save the state". Look into `redux middleware` for how to do this but the overall idea is a function like: const middlewareFunction = store =&gt; next =&gt; action =&gt; next(action) And this sort of function leads us to your last question: &gt; How can I console,log all that is stored inside the store? Since we have access to the `store` inside of our `middleware`, we can call`getState` from it: const logTheStoreMiddleware = store =&gt; { return next =&gt; action =&gt; { console.log(store.getState(), 'this is state during an action call') const state = next(action) console.log('This is state after actions', state) return state } }
Sorry if it's not clear. I wanted to compare the return anArray.concat(...) with let a = anArray.slice(); a.push(...); return a; But, since `.concat` accept multiple args, I tried to do the same. The point is : my bench shows me that `slice + push` is faster than `.concat` ... but do the same job. So, I am trying to understand why. Where is the pitfall ? Why .concat is slower :) I mean, if I use `slice + push` in place of `.concat`, should I expect problems ? 
You right, I got tangled with this. I wrote it too quickly. Sorry. But the result is the same, isnt'it ?
Thx ! So, where is the pitfall ? Why the hell `.concat` not outperform `slice + push` ? I mean, in Python, native methods outperform everything else (without extension of course). Why can I write a better `.concat` than the native one... My trust in the JS engine is bleeding right now :'(
You make software for end users. Why would anyone trust anything you make with that kind of attitude?
NO! thank YOU!
I'm pretty sure it still has more cost than other language constructs ( as it unwinds the stack), but it no longer auto-bailouts, which was the main issue to avoid it in performance-critical functions.
When I see articles like this I’m always reminded of ... https://blog.codinghorror.com/the-sad-tragedy-of-micro-optimization-theater/
Who still uses IE8 actually ?
I've had it silently installed company-wide here so I can use Toast UI Chart. It caused quite a shit storm of emails at first, but people love those donut charts.
Now you know why ES6 and above have the `class` keyword and syntax for the same. If you use an online ES6+ (or TypeScript) playground and define/extend a few classes and then look at the ES5 output you get some cool stuff to ponder.
Hi /u/rdv100, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Yeah... but a minimal hello world example isn't the right use case for redux anyway.
This is for JS developers like myself. I have seen many posts around VS Code editor which is not by itself Javascript. So please allow posting this.
Ask a simple question, get a simple answer. They wouldn't trust me. They (more likely the owner of the code delivered to them) would pay me, thereby gaining the ability to enforce contractual terms against me should I not deliver promised outcomes. You do not pay Webpack. Your own code most likely doesn't live up to the standard that you have for an organization that gives you a tool for free, one that would take you years to re-create by yourself. Your sense of entitlement is everything that's wrong with open source. 
Answering B) The keyword `new` is required to instantiate ES2015 classes: class K {}; K(); // TypeError: Class constructor K cannot be invoked without 'new' This behavior can be emulated with `new.target`: function C() { if (typeof new.target === 'undefined') { throw new TypeError('...'); } } Methods defined inside the class syntax aren't enumerable: function C() {}; C.prototype = { constructor: C, f() { } }; class K { f() {} }; C.prototype.propertyIsEnumerable('f'); // true K.prototype.propertyIsEnumerable('f'); // false
This. Developers nowadays are extremely compelled to update to the newest version, just because "it's new". There's nothing wrong with having established, proven working code that doesn't need updating, because it does exactly what you want.
&gt; Once your project crosses a certain threshold of importance, then you do end up owing your users at the very least, stability. No, they don't. The problem with developers born into this wonderful "everything is free and open-source" world is that they forget what open-source really means. It means you have access to the source code and are free to use it, and that's it. The author has no obligations to maintain that code for you, in any way shape or form. And where did Webpack developers missed out on stability? They used a major version to introduce breaking changes.
Just because Linus takes that stance with Linux, it doesn't mean it applies to open-source software development in general. That's his prerogative as a maintainer.
Just because Linus takes that stance with Linux, it doesn't mean it applies to open-source software development in general. That's his prerogative as a maintainer.
Don't use it then.
Wow, this is amazing! There's so many other live coding editors (jsbin et al), but this is so much closer to a really useful IDE I might actually use, made embeddable and shareable. Very neat.
Convert the array to a JSON string with `JSON.stringify`. Send it as a POST request. https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send#Example_POST
Yes, in that aspect. But the case still remains that `concat` does more things and that you're not using it for its main optimized-for purpose.
thank you muchly for this amazing explanation! now I understand
This is not a true statement 
Just started a subreddit inspired by this post /r/ProgrammingBuddy/ Drop by - I love the idea of a buddy system!
Highcharts can be used on IE6. Seems this is industry standard in the govt space
Some demos: * Interpolation: https://codesandbox.io/embed/oln44nx8xq * Native rendering: https://codesandbox.io/embed/882njxpz29 * Reveals: https://codesandbox.io/embed/yj52v5689 * List transitions: https://codesandbox.io/embed/j150ykxrv * Staggered lists: https://codesandbox.io/embed/vvmv6x01l5 * Animated TodoMVC: https://codesandbox.io/embed/2pk8l7n7kn * Draggable list: https://codesandbox.io/embed/l9zqz0m18z
3 times less typing/boilerplate was what sold me, especially for a large production project. I couldn't ditch Redux fast enough. I see the benefits of both, but for rapid prototyping and deployment, MobX was the clear winner here.
I think it'd be like this: const yourArray = ['string0', 'string1', 'string2']; const xhr = new XMLHttpRequest(); xhr.open("POST", "http://localhost:58573/Service1.svc/ReceiveMessage?receiverID=" + str1, true); //Send the proper header information along with the request xhr.setRequestHeader("Content-type", "application/json"); xhr.onreadystatechange = function() { if (xhr.readyState == XMLHttpRequest.DONE &amp;&amp; xhr.status == 200) { // Request finished. Do processing here. } }; xhr.send(JSON.stringify(yourArray)); 
Yeah it seems very cool. VSCode feels nearly identical to using the electron app. The export option seems incomplete so far - it would be nice to get a webpack config and package.json with scripts.
hm its not working, also i have my service as a WebGet, since i dont need to update data POST isnt needed? SO i added that array, did xhttp.send(JSON.stringify(yourArray)); and did if (xhttp.readyState == 4 &amp;&amp; xhttp.status == 200) { document.sum.form.value = yourArray; } nothing is coming up, console is also reporting no errors as well. 
I really wish there was one decent tutorial out there for it. I had an easier time with Redux than I am understanding ALS
can confirm.
Oh wow! No problem. Seriously, thanks for doing what you do. I’ve become a complete React fanboy, and a bit of a React evangelist at my university after taking your course. 
I'm so very old.
The difference is that `.concat()` always return flattened array. So my guess is that JS engine needs to figure out if an argument is an `array` or just `primitive type`. In case of push, when you push an array it will not be flattened.
Yea highcharts is so nice. but you should pay for commerial use.
That's only junior and intermediate. Once you get to senior, you get prodded in the ass too.
Painful! 
I've never understood the reason why people keep trying to put a square peg in a round hole by insisting on having things-that-appear-to-be-classes-but-actually-arent in JS. 
HAHHA that was hilarious! Whoa next level. Now I have some fart jokes to share with you all...
oh maybe I have been doing it right.
I'm not surprised Coffeescript is at the top of the most dreaded list, because it was last year and possibly before that, but at the same time, I am surprised ... If anyone who "dreads" Coffeescript would like to give their two cents on why they dislike the language (something specific, ideally), I promise I won't debate you too hard :D. I'm just curious.
Why F# pays so well and why Lua pays more than JavaScript lmao
( ͡° ͜ʖ ͡°)
If I remember correctly, the scoping rules were a nightmare. Let me see if I can find the blog post.
A few questions: - What value does this add in comparison to current es6 classes? - Why add a new `-&gt;` operator? - Why class initializers over already implemented constructors, which essentially do the same job? - Why go with `hidden` as the modifier when almost every other OOP language implements the `private` keyword?
Here, I found two blogs on the topic: http://lucumr.pocoo.org/2011/12/22/implicit-scoping-in-coffeescript/ https://donatstudios.com/CoffeeScript-Madness
Flashbacks to my previous job where they wanted to do everything with Cordova, and the nightmare that was adding any new native plug in.
Right now a subscription (whether yearly or monthly) is the only way to get access to the courses and with that subscription you get access to everything. 
Sounds good. Funds are a bit tight at the moment, so will probably pick up the subscription in a few month. Thanks Tyler
All this anti-user attitude saddens me :(
This, as a proposal, looks set to fail, at least in its current form. It adds both a `hidden` keyword and a `-&gt;` operator to the language's syntax; usage of these seems not fully justified. The use of the "hidden" terminology also seems problematic, when _"private"_ should've been more appropriate. It also mixes two unrelated features (private properties/methods and static initializers). It proposes that it can work with `static` to produce _private static methods_ but fails to present if it can work in any way for _private static properties_. All in all, the proposal seems like it needs a lot of work while going against proposals that are already on stages 2 and 3. I'm not particularly fond of any of those current proposals about class features (specially `#`), but I'm not inclined to think that this here is actually any better.
Yup no worries. Just responded. 
Thank you! Means a lot. 
Not right now. Whenever I create a new course it's because I think the current offering can be improved on. Both Ryan Florence and Kent C Dodds have advanced React courses out right now that I'm not sure I can improve on so I'd check theirs out. 
Thanks! Keep up the awesome work
Got npm? `npm install -g cordova cordova-simulate ` `cordova create hello com.example.hello HelloWorld` `simulate` good luck.
Yeah I have NPM. Is it a trap?? I was asking more about overall design or build limitations etc you might have seen, the 101 stuff I can get from documentation.
Have I given you my Python/Ruby spiel yet? You seem to be treating Java-style classes as the one and only definition of a "real" class, and anything different from Java is fake. But in other languages, such as Python or Ruby or Smalltalk, a class is itself an object, and inheritance is implemented with delegation. An instance delegates to a class object, the class object delegates to a superclass object, and so on down a chain of objects -- just like in JavaScript. This means, for example, that we can [monkey patch classes](https://repl.it/repls/DevotedSuspiciousBighornedsheep), and already-existing instances will immediately reflect that patched behavior. JavaScript's classes are just as real/fake as Python's, Ruby's, and Smalltalk's classes are real/fake. Keep in mind that Python pre-dates Java, and Smalltalk pre-dates C++. And while you're stewing on that, also don't forget that JavaScript's [objects](https://github.com/Jeff-Mott-OR/javascript-cpp-rosetta-stone#objects) and [arrays](https://github.com/Jeff-Mott-OR/javascript-cpp-rosetta-stone#arrays) and [functions](https://github.com/Jeff-Mott-OR/javascript-cpp-rosetta-stone#function-objects) are also "fake" -- that is, not implemented like their Java or C++ counterpart. JavaScript's objects, for example, are hash tables. JavaScript's arrays are not really arrays but are actually also hash tables. And JavaScript's functions, callable hash tables. So if you want to remove language features that are "fake", then you'll have to remove the whole language.
thannk you for sharing, I definitely see where the concern is there, but I think if it's possible to remember that closure is as simple as defining a same-named variable in a outer scope, then for me, the chance of accidental naming collisions might just be worth it if I don't have to type `var`.
They have invented backends. 
I think it's mostly because CoffeeScript is considered "legacy" now. Now that we have Babel and TC39 with many of CoffeeScript's great ideas baked into JS itself, the perception is that many of CoffeeScript's other features can be incorporated as libraries.
Please take a few minutes to think about your attitude towards open-source software development. How can you create these unreasonable expectations without giving anything in return? The author isn't asking anything of you, why should you expect anything from the author? Open-source developers give you their work, they actually put hours into writing software, you get that for free. That's it.
It’s easier to add developers later in the project, because every ember project has the same structure.
The pitfall is that all you're comparing is which method can clone an array faster. Between the two, `slice` is faster (at least in Chrome). Because of this, your benchmark isn't actually testing what you think it is. If you wanted to test array concatenation then you should do it properly: # Setup const range = (min, max) =&gt; Array(max).fill(null).map((_, i) =&gt; i + min) const xs = range(0, 10000) const ys = range(0, 10000) # Native 25,590 ops/s ±1.11% fastest const concat = (xs, ys) =&gt; xs.concat(ys) concat(xs, ys) # Custom 7,246 ops/s ±0.74% 71.68% slower const concat = (xs, ys) =&gt; { const zs = [] let longer if (xs.length &gt; ys.length) { longer = xs } else { longer = ys } for (var i = 0; i &lt; longer.length; i++) { if (xs[i]) { zs.push(xs[i]) } if (ys[i]) { zs.push(ys[i]) } } return zs } concat(xs, ys) And then it's clear that the native `Array.concat` method is faster at actually concatenating arrays.
I only ever had one JavaScript OOP interview question and it was to make a music player. Play, rewind, skip, pause, shuffle, and song management. That seems like a good practice one. 
I care about the users of my software, perhaps you should do the same.
Do you have an example of the layout you're working with and the desired output, on JSFiddle maybe?
i got limp wrist from writing javascript
&gt; You seem to be treating Java-style classes as the one and only definition of a "real" class, and anything different from Java is fake. Where did I say or even imply this? There is a cleaner and more modern way of creating objects which already exists in JS and provides 100% of the functionality of the syntactic sugar `class`. We've had it since ES5 with `Object.create`. &gt; And while you're stewing on that, also don't forget that JavaScript's objects and arrays and functions are also "fake" Except that these things don't appear to be, and don't purport to duck-type their counterparts, so they aren't really fake now are they? They're just the JS version of Arrays, Objects, and Functions. The difference here is that classes are syntactic sugar, whereas arrays/objects/functions are not. 
Well thank God I'm not a dude then 
Oh, in case it isn't clear this isn't my proposal, just something I saw on Twitter. Might be worth opening an [issue](https://github.com/zenparsing/js-classes-1.1/issues) if you or anyone would like to ask the creator any questions. I think I prefer `this-&gt;prop` vs `this.#prop`, but I definitely agree about the `hidden` vs `private`.
I'm sure both zenparsing and allenwb have spent an enormous amount of time and energy on this proposal and I hate that I almost only have negative feedback on this but as a regular JS dev I have a lot more issues with this proposal than with the current private/public/static proposals. - You can't declare public fields, unless you decorate them (this is likely not finalized, the decorator part is still being discussed). - This is annoying for tools like Flow Comments and JSDoc. - You can't assign a value to your field or hidden name where it is declared. You have to use a constructor. - No static fields ? :( - You need to remember if your field is private or public and use `.` or `-&gt;` accordingly. This is an issue for autocompletion. The `#` prefix didn't have this issue as it was more or less part of the name of the field and the accessor (visually at least) stayed `.`. - It's going to be annoying to refactor `-&gt;` &lt;=&gt; `.` for most IDEs. - It feels less clear to me that `-&gt;` is used for private field access compared to prefixing with `#` which is similar to what the community is currently doing using `_` - Fields are declared private using `var`, but don't behave like vars at all. - Fields are declared private using `var`, but methods use `hidden`? - A huge amount of people are already using public fields today thanks to babel. Of course we can run a codemod to remove any usage of public fields if this proposal gets dropped but the fact that the babel transform is downloaded 300k times a day shows that there definitely is desire for that feature. On the plus side, `-&gt;` is easier to type.
No
IIRC those languages are used in the Financial sector a lot. And Financial tends to pay well. Also, everyone should learn F#
It's not a trap its just how you set up a new Cordova project. The tool is over all pretty tolerable. If you're developing on windows, trying to get it to work for iOS is infuriating. The packages themselves change often enough that have to version lock them, because you might have a working application one day and now a dead one the next. They also get confusing because the overall tool is called `cordova`, and then there is a version of `cordova` for all the platforms, for their native stuff. The devices themselves are so inconsistent in gathering data that you have plenty of cases to account for in your code. Almost all of the documentation pages have a "quirks" section to explain why they suck. If you're doing this for a client they are going to have the worst hardware possible to test on, then complain about how api features 23 aren't available on a device stuck on api 15, etc. The documentation is overall decent, but the command line tools have more power than I could find documented (at least at the time). All in all, it's a really good experience for a solo/self project. But making something for a client is a walk on hot coals and your feet are jello, your arms are spaghetti noodles, and for some weird reason whenever you try to talk, gasoline just pours from your mouth.
Was hoping for real guide :D
Thank you; your analysis is very helpful. It sounds like it could be a good solution for a relatively simple app that I want to one day perhaps publish to the App Store. Of course by the time I get around to that maybe someone will have written Cordova webpack or something crazy :) 
Scale. Scale, scale, scale. Ember is convention over configuration, and if you're dealing with a monolithic web app, you need to be able to get someone up to speed rapidly. Ember's good for that. You probably won't need Ember for most projects, but it does well in its space. 
So yeah... let's use fetch. And let me know if this is correct... You have a form that gets filled out. The data from the form is used to populate an array. You want to send that array to an api/endpoint/database. Right? You'll just do fetch("YOUR ENDPOINT", { method: "post", headers: { 'content-type': 'application/json' } body: JSON.stringify(YOUR ARRAY) }) .then(resp =&gt; console.log(resp)); That should be all you need. After you fill in your endpoint and array pieces, then you should be able to use that code to post to the database and you should get a response message back in your console. What areas aren't making sense?
Not yet, but I do have two thoughts! 1. I didn't know what an ERD was - [you should add the definition](https://www.hackterms.com/erd) :) 2. A map like this would be _awesome_ - I'm going to look into how these are made.
If you check the language vs experience chart f# is near the top of the experience curve.
Heya Tyler, thanks for the great guide! It was easy to follow along, was just missing some examples at the end: * componentWillUnmount; what and how would you clean up the event listeners? How can you determine if you have any "leaks" in your code? * getDerivedStateFromProps; when does this get invoked? In terms of "good practices"; any way to call setState with just one property being changed? Would you use Object.assign in the case you have numerous state properties?
why do you think this is sexist?
Yeah, I just gave a look and it looks something hard at first sight
&gt;simulates some **basic** functions of jQuery.
That sounds like a good one. I might try to work that into a decent pre-screening test for any mid-level devs in the future.
I really like Coffeescript! And with coffeescript2 producing code that is ES2015 and later compatible (by using babel), it's just javascript! And it can be mixed transparently 
myArrayList = [] class myObject { ... } myArrayList.push(new myObject()); 
Yeah it was pretty fun to do. Everyone knows what a music player is like too so it's super intuitive. 
And to think, this is really because of I.E...
Ah, I thought you were the author. Yeah, I'll open an issue.
0 to... 18?
Please link me to the open-source software you wrote so I can demand support and stability from you, and give nothing in return.
supply and demand
LOL I wasnt expecting to see the abolute truth
I'm no expert, but looking at /src/parts/... `import` should probably be the first lines in a script, since it's hoisted. Better not to mix `var` and ES6 syntax if you can avoid it: I think it's nicest to write completely in ES6+ and Babel later. Strict comparison is generally better than loose. (use === and !==) I don't think it's a good idea to prefix most variables with `$` unless you want to indicate that the variable in question is jQuery-wrapped, or something similar. This isn't PHP, after all - unless there's a point to it, it just seems like syntax noise to me.
nice! :D
Just wanted to say this is an excellent mindset to have; I wish more people thought the same way.
Try it yourself https://developer.mozilla.org/en-US/docs/Web/API/Console/time
Are you excluding Sizzle from that statement? Support for old browsers?
I find it a bit self serving to have SO as the option that people go to learn how to code. People do visit SO when they are stuck. But it’s not a place where you learn to code. The poll does this while excluding an online video platform like YouTube which so many people use for learning. The way the poll is structured, it’s easy for SO to say, “Except for the official documentation, the most sought resource for learning is SO”. But I think it’s important to make a distinction between learning to get better in general and unblocking to solve a specific problem. SO is good only for the latter. 
Come back if you get bootstrap working without jquery, people will be much more open.
&gt; I was looking at Redux, but I know that people at work probably won't make the time to learn it. So I made a library that's a little more "old school" in it's terminology. I'm not trying to reinvent the wheel or anything. Can anyone take a look and provide some notes, please? &gt; Also, I'd love to see what side-projects/libraries you folks have made. Just trying to feel like I'm not just programming at work for nothing. :/ You'll find that state management in general is going through some shifts right now. Redux is great, but in many situations you went from something very simple, like that would be setState in React or just property access in Vue, to reducer patterns. So there's a new batch of state libs right now trying to address that. I'm the author of one of them as well: https://github.com/drcmda/react-contextual There are many others that follow the same ideal: actions were good, let's keep them, complex reducers, let's replace them with a simple merger. mapPropsToState stays, middleware - replaced by transforms, thunks - async by default. So maybe it can serve as an inspiration, not sure how you'd do that in Angular but i imagine that if your colleagues have overslept redux to this day, maybe that means something. 
but ... but Vue is the fastest growing GitHub repo by star count.
That's a good way to put it :) 
So it's a language that should have just been a library? 
Are you referring to cross-file scoping? 
When you need help for vue where do you look? I generally feel less lost and need less help compared to Angular/React. If I do feel lost and need help, I generally refer to the official documentation. Very rarely I find the solution I need on SO. If you like the framework, stay with it.
Just make stuff! Make a really, really good vanilla js/html/sass slideshow, or file uploader, or mobile navigation, or grid layout using only flex box, or x, y, z... It's the only way to learn and retain software engineering knowledge -- and it works great!
No, is this some kind of pun?
I dunno, your submission definitely doesn't paint that picture. The fact you use "document" is to define what you're querying, when using jQuery you're constantly calling to the "document" by the "$" and this is counterproductive. Drop jQuery dude, learn Vanilla. 
This is the second time now I've seen your shitty example of a Framework posted in this sub. You didn't revert on my last request of giving us comparisons with Mithril.js and other frameworks.
The tech pay gap explained: women rank compensation as 4th highest priority behind culture. Men rank compensation as first priority. 
lolz.
Who are all these fucking wierdos using Notepad++? I’m a WebStorm fanboy, but I understand not wanting to pay for it, but I mean VS Code is free! And Sublime is free, if you don’t want to use an IDE.
So the question becomes *why* do women rank compensation so much lower?
I don't have popcorn, but I'll watch anyway haha I'm really not going to be surprised if it's the case though.
Do you just go browse SO randomly looking at solutions to problems you aren’t having at the time? I don’t. I go to the site to look for a solution to a specific problem I have on hand. I’m not going to comment on text versus video format for learning. But whichever you prefer, I think SO is an unstructured knowledge base that will help you only when you know what you are looking for. Add to it their draconian policies about questions being very specific and to-the-point, I don’t think it leaves a lot of room for broader understanding and exploration - two essential elements of any learning. 
Seems like a bad user experience to me... but... https://codepen.io/anon/pen/WzrzzY?editors=1010
Cordova's plugin system is the worst.
Building a calculator in flex is a good exercise. You can add some animation and JS to that too.
Nice try winrar
I don't use WinRAR but if I did I'd pay. If we can't get our peers to pay for software how can we expect anyone else to?
Awesome. Thank you for the notes I think I'll keep the $ methods and variables in case people want to extend or add to the class instance. Almost to indicate a reserve method name. But it makes sense that it's noise as well. I'll consider that for sure. I really appreciate the notes. It's kinda tough at the office being a Jr dev and having no one to give me advice.
Yeah I've noticed a lot of shift too. I'll check your library out. Thanks for giving me some key points to research. I really appreciate it.
Build something. Put it on github. Having a portfolio before the interview is invaluable.
There is nothing wrong with CoffeeScript but I think developers hate having to learn a new language just to rewrite the code into modern JS. There are so many custom Ruby DSLs that have just been completely abandoned since going out of fashion leaving lots of developers having the scrabble through old documentation to make sense of what the F is going on and what these magic DSLs do. I have finally escaped Rails and I am so happy now that I no longer need to worry about future prospects. Nothing is more disheartening than having to learn several abandoned DSLs just to be able to debug the errors they are causing. The whole philosophy of Rails is something I am 100% opposed to. The whole community was driven by pretentious hipster zealots who thought of themselves as more artist/craftsman as opposed to engineer, it emphasized dry to an extreme leading to poor abstractions and a code base that is impossible to read since everything is hidden behind multiple DSLs that would create most of it's methods at run time, and where everything is Global. These practices lead to insanely bloated and debt ridden behemoths that ran at a snails pace.
Because not very many people know F# and Lua so companies have to pay more in order to get them. 
Because women are not valued by how much they make while men are harshly judged and disregarded by society if they don't have "A Good Career". 
If you want to know how to do it: https://developer.mozilla.org/en-US/docs/Web/API/Console/table
ah man. Rails isn't ruby though. I'll leave it at that.
Woman dev here. I would also rank culture above compensation after a certain point. In my mind, once I'm above a comfortable living wage it doesn't really add much to my happiness to make a ton more money, but the people I have to be around for 8 hours a day definitely does.
Bro.. you're gonna have to post that code. And specify that you're doing a React app while developing in a ________ environment.
I use this pretty frequently but most people don’t know about it. Good callout.
No
I think ember and angular more comparable because they come with "batteries included". I used ember in its early days and I don't like how it locks you into their object model. That might be different now, but it really makes working with third party libraries difficult. 
Radi, is that you
And a company culture where working 8 hour days is normal is also quite nice.
That’s a good point, I also refer to the official documentation. Or if I’m on stack overflow I’m looking for help on vanilla JavaScript or ES6.
Do they have something there?
Huh. Didn’t expect to learn that today. Neat!
Man Wallaby is the bane of my fucking existence these days...
What's wrong with it? I don't use Wallaby but Quokka is great so far.
Latest updates have fucked up a battery of tests. Other test runners are totally fine and Wallaby used to be but we are seeing a ton of false positives relative to our Karma tests. 
Hi /u/AlexJSx, For javascript help, please visit /r/LearnJavascript. Thank you!
There's a few console commands other than .log that are helpful. https://developer.mozilla.org/en-US/docs/Web/API/Console
No
I am at EmberConf right now, and the object system will just be ES6 classes with decorators in the near future. If you are using pure "data down, actions up", you shouldn't have to battle it too much, as you can use POJOs for your models.
Personally, while I've dabbled in `yarn` (and sometimes use it instead of `npm install` for speed), I've never made the jump and really committed to `yarn`. I think `yarn` is going to follow the common trajectory of these sort of things: a popular but flawed tool, an alternative springs up with some improvements over the tool, the new ideas get integrated into the original tool, there's no longer a compelling reason to use the less popular tool, the alternative dies a slow death. We saw the same thing happen with `io.js` vs `node` (and, IMO, flowtype is on a similar trajectory with respect to Typescript). So, long-run, yeah, I think `npm` is probably the safe bet. It's the official package manager: which means, all-else-being-equal, it's got the edge over `yarn`. (People will use `npm` unless given a compelling reason to use `yarn` instead) --- That being said, if your setup works for you? There's no hurry to change it. If it ain't broke, don't fix it. Maybe I'm right and you'll want to ditch `yarn` eventually... but why borrow trouble?
&gt;jQuery helps in finishing the Project on Time &gt;jQuery helps in writing codes that are simple and clean so web developers don’t have to spend hours and hours of their precious time in understanding the codes previously written by someone else. By using jQuery, in order for others to understand your code you need them to know not only vanilla JS, but also jQuery as well. That's not a plus. Now a potential coder not only needs to spend hours figuring out how vanilla JS works, but also hours figuring out the separate syntax jQuery has for everything, despite that - most of the time it's used - there's no benefit to using it over vanilla JS. (unless you have to support extremely ancient browsers) &gt;5. Decrease the Hosting charges &amp; Server Loads &gt;jQuery helps in bringing down the Server Loads because the codes are less, the size of web pages are less, the AJAX requests are lightweight too. Completely wrong. Adding a heavyweight library to each of your pages does *not* decrease server load, it does quite the opposite. &gt;the AJAX requests are lightweight too. Guess the author hasn't heard of Fetch jQuery is useful to know for developers working on older scripts that have it already, but it shouldn't be added to new projects by default simply because the programmer doesn't know want to use the vanilla JS function.
If I was considering a position, and they told me they used jQuery, I would immediately ask them if they were hiring me to help modernise their codebase.
Or we're just working with it instead of writing 15 blog posts on it.
Sure. Thanks.
[10 TIPS for Javascript Debugging](https://medium.com/appsflyer/10-tips-for-javascript-debugging-like-a-pro-with-console-7140027eb5f6)
Workspaces and package aliases are the reasons we are currently using yarn where I work. Workspaces are essential for managing locally developed libraries in a painless way inside a monorepo (we used lerna to do this before but it was painfully slow compared to yarn workspaces) and aliases are being used as we gradually introduce material-ui v1 into our codebase without having to totally rewrite everything.
Show them Mobx-state-tree instead, it combines the best of both worlds.
Yarn has pushed npm hard (probably too hard) they are incorporating all the best ideas so there should be no reason to use yarn, I'd prefer to have just one package manager. However every recent npm release has included serious bugs so you'll normally have wait for them to be fixed before getting the latest features.
I'd suggest signing up for jsweekly and other similar weekly newsletters. Also, following prominent developers or js libraries/frameworks on Twitter can be helpful because they often tweet about new things or tutorials they made. @javascriptdaily, @JavaScript, @addyosmani and @dan_abramov are good accounts to start with.
But you can destructure *and* set default parameters in the initial parameter list. No need to go through all that, right...?
We've been trying Yarn lately, because the npm team has proven to be incompetent too many times already. Giving them responsibility of so many projects is just dangerous.
Always read chrome updates, they are adding some powerfull shit each six weeks. We just got the performance dashboard. It's already helped me find really performance intensive components.
Typical bullet-point list of no value whatsoever, possibly generated by a bot
+1 That's the killer feature which pushed me to move from `npm` to `yarn`. It works really well and you don't really need an extra tool like Lerna to get it. My big side-project is TypeScript based and to build it all with workspaces I just added one other tool [wsrun](https://github.com/whoeverest/wsrun). It just lets you run the same script (i.e. `yarn run build`) in each workspace. But it is also smart enough to respect the dependencies between workspaces and build them in the correct order. It is a simple, but effective build system for workspaces. `wsrun` also does parallel builds. 
Unless you actually needs these features of NPM or are experiencing problems with yarn, I wouldn't change a thing. 
&gt; We saw the same thing happen with io.js vs node (and, IMO, flowtype is on a similar trajectory with respect to Typescript). Those aren't good comparisons. io.js had nothing to with code or features and everything to do with politics. As for Flow, the trajectory I see there is one towards irrelevance. TypeScript is crushing it. 
The guys behind io.js were tired of politics with node but at the same time they had traction because they integrated new features and latest v8 versions. Yarn putting pressure on npm to improve is the same result even with a different context.
Never knew that, looks nice. Thanks!
[Done easy](https://b44rd.github.io/jsbug.html)
You probally missed following topic: https://www.reddit.com/r/javascript/comments/81z3et/javascript_debugging_like_a_pro/
I think he does mention that (although not explicitly)
I couldn't find anything about this. But other npm commands use --scope=@scopename to specify the scope, so perhaps that could work, and just specify the rest of the names individually?
i swear I saw this syntaxe somewhere in a NgRx tutorial, but i can find it for the love of it Thanks for the tip
I like this, however there is one thing I would like to add... If you destructure _and_ provide defaults in the function parameter declaration, then you could unexpectedly run into errors if you call this function without _any_ params. For example, this will throw an error: const addEmployee = ({ name = 'John', age = 25 }) =&gt; { console.log(name, age) } addEmployee(); // _TypeError: Cannot match against 'undefined' or 'null'._ This is because it is trying to destructure against an object that doesn't exist! To get around this, we can provide a default value for this object as a whole: const addEmployee = ({ name = 'John', age = 25 } = {}) =&gt; { console.log(name, age) } addEmployee(); // John, 25 addEmployee({ name: 'Steve' }) // Steve, 25 This is setting the value of the Object to destructure to '{}', if no object is provided. It doesn't particularly elegant (5 '=' on a single line?!), but this is the world we live in :)
Yes the only things we use/used lerna for are linking packages and running scripts across all packages (we still use it for running scripts across the workspace). Publishing our internal libraries is not currently something my employer is interested in (despite my attempts to push for this). But I agree that in some cases lerna provides a lot of extra functionality, however if you are only using it for linking then yarn workspaces are much much faster.