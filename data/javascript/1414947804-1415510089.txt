&gt;Your test case is invalid Reread the code. You are only claiming that they are different with no justification. "i" is always equal to array.length in the test. You seem to be confusing it with a number that is less than array.length. It merely shows that keeping track of the number has different results from looking up the length using array.length. Also, I didn't write this article. I merely claimed that in firefox array[ i ] was faster. Then you went full autism on me. Your belligerent nature makes me think you are young or new to programming, and I really hope you learn to chill out in the future.
Hi Tom! OP, While we're on the subject of framework core team members promoting their own frameworks... You should check out Marionette.js. Tons of companies use it for big projects (CloudFlare, Etsy, EventBrite, Disqus, etc.) and there are loads of open source examples and books you can check out (Popcorn Time, Marionette Wires, David Sulc's series of books on Marionette). Marionette will also work easily with the build tools you probably already use without having to mess around with a framework-specific build tool that keeps you from using tools directly! The best part of Marionette is that when we released 2.0 earlier this year people used our Upgrade CLI tool and migrated their applications within minutes! Let me know if you have any questions! PS: &lt;3 Ember Core Team
I gree about the book, is excellent, but very few of their practices are deprecated like the use of #!.
The last thing I watched is this: https://www.youtube.com/watch?v=bo36MrBfTk4
I can't EVER see a need to do this. It seems like complexity for the sake of complexity to me. My question still stands: What's the POINT!??! More simply Why? Javascript is being steered by ancient dead languages throwing in structures just to make it cumbersome. I guess that's good because once ES6 makes it pointless, inefficient and cumbersome to do anything in javascript, we can move on to a better language for the web--not sure which one. ES5 is the correct one now. Soon we'll all be forced to do overly complicated shit like this just so we can say, "Maps are important data structures in programming" when the truth is, No, no they're not.
&gt; Marionette will also work easily with the build tools you probably already use without having to mess around with a framework-specific build tool that keeps you from using tools directly! Just to be clear, Ember CLI is built modularly on top of Broccoli, which is like Gulp or Grunt but more powerful. The `Brocfile` is exposed to you in Ember CLI, so it's easy to get in and hack if you need to.
&gt; React for their rendering pipeline as it takes care of some nasty issues Iike layout management Out of curiosity, what are some layout management issues you found easier to tackle with React?
Well one option is the Flux architecture that Facebook espouses. So far I think it's great thus far for complex apps and fits incredibly well with ideas like cqrs and event sourcing. Here is an interesting approach using postal (two part series that also serves as a great beginner guide to react in general I'd recommend everyone checkout) http://tech.pro/blog/2020/a-thrown-to-the-wolves-hands-on-introduction-to-react for simpler apps(particularly if you have a need to do an SPA for a simpler crud app) this is the approach I'd recommend. Note in the second post the author discusses methods of using mixins to remove the dependencies to postal within the component which is the same method I'd recommend as far as things like keeping Ajax calls out of your view components. With all that being said, the fact that react inherently encourages unidirectional data flow and immutability has led me to see a lot of situations where I simply don't need the mvc architecture any longer and everything becomes simple streams of data with components that know how to render themselves for a given point in time based on the current state of the data. It's a bit of a different way of thinking. However, I think it's worth taking for a test drive if not just for the experience of learning to think in a different way that is based more on immutability than the mvc frameworks (not that I am anti mvc and haven't used these tools for quite a while before react. It's always about the right tool for the job) 
React &amp; Paperclip are pretty similar, and you can solve many of the same problems with both libraries. However, there are a few differences: - React operates on DOM diffs. Paperclip leverages the browser's built-in cloneNode method for generating templates - this is a bit faster. Here's a flame graph for operations in React: https://cloud.githubusercontent.com/assets/757408/4876108/0b559844-62b6-11e4-998e-457cfd1abf55.png Here's one for Paperclip (same todomvc impl): https://cloud.githubusercontent.com/assets/757408/4876020/3da96df6-62b2-11e4-87a5-adc6f5c4a6a3.png Both examples can be viewed here: http://paperclip-todomvc-example.herokuapp.com/, http://swannodette.github.io/todomvc/labs/architecture-examples/om/ - Paperclip supports 1-way, and 2-way data-binding. - React takes on more a view-controller paradigm, whereas paperclip is just the view. Paperclip supports inline javascript, but most of the logic can really only be defined outside of templates within the [context](https://github.com/mojo-js/paperclip.js#templateviewcontextrender). 
I would make one small modification to your padding function. The original looks like this: function pad(n,e){return (n+Math.pow(10,e)+'').slice(1)} I would add the unary + operator to n, like so. function pad(n,e){return (+n+Math.pow(10,e)+'').slice(1)} This prevents the following from happening: pad("99", 4); // yields 910000 And it's not that much more code ;-)
I know, I just couldn't help but take a jab at you :P. Luckily Broccoli works with Marionette too, Yay Open Source! There are plenty of other examples though. A quick look at [emberaddons.com](http://www.emberaddons.com/) reveals: sinon becomes _ember-sinon_, jscs becomes _brocolli-jscs_ and then becomes _ember-cli-jscs_, google maps becomes _ember-google-map_, select2 becomes _ember-select-2_. &gt; PS: to anyone else reading, Angular does the [same thing](http://ngmodules.org/) (angular-bootstrap, highcharts-ng). I'm sure these all make it ever so much easier to use them in the context of ember, but some would argue that's fighting an uphill battle against the nature of the web. That being said, the Ember team has done an excellent job turning internal pieces of ember into their own independent libraries and build tools: Handle/HTMLbars (I use this), RSVP.js (I use this), Broccoli (I like the ideas here), etc.
Angular 1.x gets a lot of flack, but I've been very successful with it. What I really like about Angular is it addresses just about anything a modern webapp will need, but not in a forceful, opinionated way. 
Thanks for the clarification. I know almost nothing about nodejs 
It seems like your negative bias is affecting your ability to read.
I'd go with Angular personally, it's awesome. 2.0 is coming, but probably a year from now, maybe 2 years, and then it'll be months before bugs are gone and stack overflow fills up lots of answers to the top 500 questions and issues people have with it. It's definitely not something happening anytime soon. And while angular 2.0 is sort of very different, it mostly streamlines existing concepts. The notion of controllers, scope etc won't suddenly disappear, they'll just work differently and from what I've seen, you'll learn 2.0 more quickly if you know Angular 1x than not but others may disagree. Can also look into e.g. Backbone + Handlebars.
Perhaps your inability to scrutinize has left you without the ability to ask why or understand "why" others would. It's a pointless "feature" that solves nothing or provides nothing real.
Pretty cool, I learned a bunch about crypto and am now going to look for more crypto videos. Thanks for the share.
&gt; Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type. Why? You pretty much know what is going to be put in a structure. I have no clue when you wouldn't know. 
Not using a framework is not the same as not using *libraries*. Frameworks have various opinions and assumptions about structure which can give some benefits setting initial patterns in place but it's easy to outgrow those assumptions. For example, suppose a framework was designed around request/response but the application needs to be updated for realtime updates. You'll spend a lot of time fighting the framework to make this happen. With libraries, your code calls the relevant abstractions directly, so you provide the architecture and the libraries can focus on doing one thing well. Not using a framework does not mean that you'll be reinventing wheels left and right. I've observed far more wheel reinvention in framework-land because the assumptions of frameworks tend to interfere heavily with the ability to reuse third-party abstractions from [package ecosystems](https://npmjs.org). Individual modules that do one thing well are very easy to swap out or throw away when your requirements change. Frameworks, not so much. There are still huge numbers of websites stuck on rails 2 for example.
That's all well and good, but without numbers it doesn't mean much. How many concurrent users have you seen on a single meteor app? For those numbers, what kind of server architecture is required? I know it's all relative and two experiences will be vastly different depending on the app, but that doesn't mean comparison testing is not useful? 
don't argue with an idiot that doesn't even use anything beyond html/css (quite evident from where and what he posts). What's the term for "armchair expert" that applies to web dev?
Definitely use Ember CLI and do `ember new project-name` to get started.
I understood why without reading MDN or the above comment which clearly explains why. Probably because I already understood the difference between maps and associative arrays.
Good then you know it's pretty much pointless to implement in javascript. See the truth is there is no why other than making things overly complex. There is zero real difference between a map and an associative array other than a layer of fanciness. It's about time we stop implementing things just because they are fancy. You DON'T EVER need to associate an object with an object and you don't EVER need a predefined function to count how many there are of something--it's just bloat.
Why is a post suggesting that someone perform technical due diligence and requirements analysis before making a permanent architectural decision getting voted down? 'Work out what you want from a framework, then evaluate them' should be the topmost answer.
You will here his name only in whispers, for fear of inviting his presence. He is the Bringer of Maintenance Nightmares. 
How in the hell could you not?
Thanks for the recommendations! I've already read the Mikowski &amp; Powell book which was indeed excellent and I just ordered the e-book for Getting MEAN. I've been learning Angular for a while now (so I don't mind the Angular chapter being missing) but I've been having some trouble putting it all together because I'm still not really 'getting' Node/Express outside of simple tutorials and exercises. I bet reading Getting MEAN will help me on my way. Would you say it's worth buying both books instead of just the one? And if so, which one would you recommend reading first? Also, in case anyone else is reading this and on the fence: Manning (the publishers of Getting MEAN) is doing a halloween promotion until November 3rd. The code is 'halloween1445' for 45% off your purchase. Actually, Manning does half price deals pretty regularly, just sign up for the mailing list to get updates.
I'm a beginner, but maybe this book (freely accessible online) might be of help: http://addyosmani.com/resources/essentialjsdesignpatterns/book/ Especially the MV* segments: http://addyosmani.com/resources/essentialjsdesignpatterns/book/#detailmvcmvp This seems to be a wide spread idea of structuring web apps. It's still above my current level understanding of JavaScript (still working my way through [Eloquent JavaScript](http://eloquentjavascript.net/)) but it's on my reading list.
I would just be happy with "Learning with Javascript."
Yeah, so far I've read most of the Definitive guide and the good parts. Great concepts but in no way architectural design books. I have Javascript Patterns on my next to-read list, but I'm also sluggin my way through the Algorithm Design Manual, so I haven't gotten around to it. Maybe I should be dabbling in both at once. I'll check out the chapter you bookmarked first, Thanks!
The elements of the form are in an iframe, which is a container for another HTML document. Because of security reasons, the [same-origin policy](http://en.wikipedia.org/wiki/Same-origin_policy) prevents access to the elements of an iframe unless both the iframe and parent page are from the same domain. For example, `example.com` could access `example.com/test.html`, but not `google.com`. In some cases, subdomains of the same domain might work, such as `f.example.com` and `a.example.com`. If the iframe in your page comes from a different domain, then there's no way that you will be able to automate the submission of the form through JavaScript. You might have to use something like AutoHotkey! That being said, if the two pages are from the same domain, you can add this line to the top of your code: var iframeDoc = document.getElementById("iframe").contentWindow.document; This line will get the inner document of the iframe. Then replace all occurrences of `document` in lines like `document.body.querySelector` with `iframeDoc`, so it looks like `iframeDoc.body.querySelector`.
Thanks for the recommendation! I'll look into that asap. And the Design Manual is great so far. I'm only 140 pages into it (it's a 700+ page book) and so far it's moreso review for me. But it explains concepts quite clearly. I like it's conversational style too. I would recommend it if you need a good grasp of the fundamentals of data structures and algorithms.
Most important part is that browsers will show a native password dialog so that the user's passphrase is never exposed to Javascript: http://youtu.be/yf4m9LdO1zI?t=14m12s That dialog seems uncustomizable right now, and it's still very ugly and user-unfriendly. We really need it to be autocompleteable (think 1Password) and have a commonly trusted design before implementing the WebCrypto API in our apps. It needs to be common, so that third party scripts (think Stripe or PayPal) can easily make use of WebCrypto as well. 
Reactjs + gulp
The core functionality looks good. I don't find the api/template language very aesthetically pleasing. It'd be nice to have something unique. I'd love to see your engine with an api something like this... https://gist.github.com/m1sta/42eb7b6feaf57fd12faf
Here's an extremely simple example: https://gist.github.com/jimschubert/cc68e5fb4a904126357a Not everything in JavaScript has an id. You might assign an id to the person object, but if your application also updates the person object and whatever API you're using (it may not be your own) begins tracking API resources via .id instead of ._id or something silly like this (API design and consumption discussion aside), your assigned id property wouldn't be the same as whatever the API assigned. Not every JavaScript developer works with their own data and granted these changes should be consumed correctly, but that's just not how the real world works. Even *within* your own application, some asynchronous operation could change properties of your own and this can be a bitch to track down problems like I've illustrated above.
haha. lets never use semver major versions ever!
It says "Uncaught DOMException: Blocked a frame with origin [https://site.school.edu] from accessing a cross-origin frame." The sites are very close but their different. It's off by two letters examplenx.school.edu and examplevw.school.edu. I assume it means that I'd need other programs like the AutoHotKey you mentioned in order for it to work.
http://www.lunametrics.com/regex-book/Regular-Expressions-Google-Analytics.pdf
I use http://regex101.com/
Puritanical drivel. Interpolation with {{ curly braces }} is not shit code, in fact I think not only looks better but is much easier to type than some of the &lt;% alternatives %&gt; 
The line should be (and the same for the following else if statements): if(ElectricalConsumption &gt;= 0 &amp;&amp; ElectricalConsumption &lt; 2500) { This is because the "&amp;&amp;" is a boolean operator, it needs a boolean (true/false) on the left and one on the right. Comparing two nombers (with &gt;, &lt;, ==, !=) produces a boolean depending of wether the comparision is true or it isn't. Edit: As zim2411 pointed out, you need to close your ifs like this: if(condition) { //code } else if(condition2) { //code } else { //code }
as you get further along, use debuggex.com to see what your regex is actually doing 
[K fresh scrub, did you even try to google this?](http://lmgtfy.com/?q=multiple+conditions+javascript)
I'm pretty sure this rant was more about templates with lots of logic (hence all the angular code) than the delimiters being used. On a certain level I have to agree that you should limit the logic you put in your templates, although this blog post was just a ton of poorly delivered straw-man arguments.
Honestly I think you should grab a book on programming 101, consindering you don't seem to understand trivial programming paradigms
&gt; More concretely, one thing you'll want to do is get in the habit of namespacing your code. ^this look into encapsulation http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)
There are a number rich JavaScript interactive fiction engines out there. These two well-respected ones are worth checking out: [Twine](http://twinery.org//) and [Undum](http://undum.com/)
Yes, this. Often when people say "I want a single page app framework," what they really mean is "I want the page to not reload when I click stuff." As such, a *shitload* of over engineered Angular et al apps out there could just have just used something like [page.js](http://visionmedia.github.io/page.js/) and called it a day. I wish people would start with small stuff like page.js and ask themselves "what else do I need" rather than just defaulting to huge frameworks.
You didn't even use your map. I have no clue what you're getting at here. I guess I'm just too thick to understand. The example you provided didn't even use the map so I'm just confused. How is it useful if you didn't even use it in your example? I'm not trying to be an ass here by the way. I'm just frustrated because I just don't get it. Can you show a working example of map being useful. Perhaps you were trying to show some area where something is broken without it? I don't know. I'm too much of a newbie to understand that though. Can you show an actual working example? Thanks.
I like to use try/catch in situations where I'm dealing with the DOM or other unfiltered input. If I'm running decodeURIComponent and I'm not 100% certain the input is in fact a properly encoded URI, I'm going to use try/catch.
Enter a number: cat try { int i = Integer.parseInt(input); } catch(NumberFormatException ex){ alert('not a number dumbass'); }
The point of try/catch is not to make it easier for you to debug errors. It's so you can recover from errors. It's not a developer tool for tracking down bugs, it's a way of writing code that doesn't have bugs in the first place. The idea being that instead of your code just crashing, it can recover from something going wrong. This is a much better experience for your end users.
But parseInt never throws errors it will only return NaN if it gets bad input 
you get the point though :) i like u/zoomzoom83's answer best
Heh nice. This can be a common pattern in other languages though.
Hmm?
Eh.. I take flack all the time from people who don't have critical thinking skills, or common sense - and r/javascript (and the world in general) is full of them. Your points are very valid. The Angular team screwed up by letting this cat out of the bag. Angular 1.x was so poorly conceived that it's difficult to accept the amount of momentum it seems to have. It really is no wonder they are throwing it out and rewriting it. 
Yep. We will. 
Can you elaborate on how try/catch does this in a more concrete sense? Perhaps with a small bit of code that demonstrates what you are saying? From my perspective the only thing try does is run a block of code to see if it crashes or not and then passes the crash report as an argument to be used in the catch block...So how does that help me 'recover' from errors? How is this a 'way of writing code that doesn't have bugs in the first place'? I can understand what you are trying to say and clearly I'm missing something but I fail to comprehend what that is...Can someone fill me in with a specific example? I tried the code jeff_purple_wiggle wrote but it just gave me an error in my console and there wasn't much context explaining what that code does. I'm a bit lost here.
Thanks heaps ^_^
uncaught errors will crash your program. This is not a big deal with frontend JS, but on a node/express app, an uncaught error will make your server crash, and your site will go down. 
So, try/catch/throw is a concept that exists in many programming language. You use it when your program needs to run some code that may fail, or may be an error from your perspective. A good example to think about is any time you're accepting user input from a keyboard. Maybe you only want a text area to only accept 4 digit strings that represent years. The user can type anything into a text field, no matter how clearly you label it. So when the user clicks a submit button, your program gets what they typed in the text area. A robust program would have this code in a try block ("try" to run this code using the user input) . If nothing goes wrong, great; run the code in the try block and keep it moving. If something does go wrong, we run the code in the catch block (note that in many online tutorials, people just log something to the console here usually for brevity or simplicity of the example). Now the catch block is executing and we want to try and recover from the error. How do we know which error occurred? From the report that got passed in. How you respond to the error depends on the situation. You're just supposed to figure out that code too. So if the user submitted a blank string in our field, we can detect that that was the error (you can define your own custom errors, btw) and write some code to display an error message on the screen. TL;DR try/catch is a construct you should use when your program is at a point where it has to execute some code that may not work (think user input / writing and reading from a db). The program "tries" the code that might not work and if it doesn't, it "catches" the error in another block where you write if statements to detect the type of error and respond to it somehow.
Ok, say you are trying to load a file, the file doesn't exist where you thought it did at that particular moment, and you get a file not found exception, do you really want your entire program to crash just because it couldn't find the file it was trying to open? 
The real answer is that circumstances can happen where you need to error handle. You can test for as many error conditions as you like (user input as a number is a good example but what if the number is 0 and then you divide by zero), uncaught exceptions will inevitably happen. FOR WHATEVER REASON... Don't even question this, just accept it. You CAN NOT test for every exception... exceptions are thrown at such a low level (think encoding, streams ending unexpectedly etc) having try-catch guarantees that exceptions are dealt with and that they are "exceptions" to how the code should run and therefore be handled differently. Even better it can guarantee that functions or methods are "safe" and have guaranteed behaviour. 
This one is great - http://regexr.com - live tooltips with current formula explanation, cheatsheets etc.
Show them thay http://www.kennethcachia.com/shape-shifter ;)
2.0 try to do something which seems important - work with any HTML component (native or Web Component) out of the box (so that's why that initial strage syntax for binding which will be probably changed). About your comment *looks pretty feature-complete to me* - it reminds me famouse quote about RAM memory - "640K ought to be enough for anybody."
vuejs.org for frontend 
The more JS IO api's become promise based, the less try/catch stuff will you be needing to write. Unexpected behavior occurs on inputs and outputs to your system and these must be caught and handled. Promises are nice for this as they carry a 'fail' branch that can be handled gracefully anywhere up the calling chain (if at all). So in that JS modality, the try-catch is a thing of the past - unless you are writing your own IO library - if so please make it promise based!
This yours?
&gt; it reminds me famouse quote about RAM memory [Random-access memory... memory](http://en.wikipedia.org/wiki/RAS_syndrome). Anyhow, that's a pretty silly comparison. Do you really think more features is always, *unconditionally*, better? Keep in mind that we're talking about JavaScript frameworks here. You know what that reminds me of? "Measuring programming progress by lines of code is like measuring aircraft building progress by weight." -- Bill Gates Also, keep in mind that 1.x is far from being frozen. We are talking about some state a few years into the future. If you think there is some super important stuff missing, now'd be a good time to bring that up.
Here's the thing. Imagine you've trained in the League of Assassins for your entire life. Your entire life uptill now was a mission. All this training and everything for only one kill. You have to kill some guy named A. After you complete your training, you finally leave the underground organization only to find out that he died of a heart attack 2 years ago. Now, there's nothing you can/have to do. Your life's pointless. You were never taught what to do if he already is kill. the flow is something like this. &gt;1. graduate &gt;2. find A &gt;3. kill A &gt;4. return to LoA &gt;5. do more assassin stuff Now you've no idea what to do. You can't go to step 4 without completing step 3. So, let's pretend you did the only logical thing a program(in this case you) could do. that is kill yourself or die of oldage. You had so much things to do but you can't because you couldn't complete step 3. now lets try the same thing with a try catch block #. graduate try{ find A kill A return to LoA }catch (exception A not found, exception A is already dead){ adopt puppies bring puppies to LoA } do more assassin stuff #. Now you know what to do in case of an exception (which in this case is A being already dead) and know exactly what to do after finding such exception (which is bring puppies to LoA). Hope that helped. 
It's only 6 minutes long, so I would just show them the basics, e.g. drawing simple shapes/animations, how a JS object can represent a shape on the screen. Then in the last minute or two show them some amazing stuff people have done with canvas.
Apart from your post, I've never come across anyone saying it's intended to avoid ASI issues. It's certainly a side-effect, but everyone talking about it only refers to the fact that it saves a byte. Do you have any documentation that comments on the ASI aspect?
Take this example: function veryImportant ( thing ){ var outcome = doSomethingThatCanThrow( thing ); // Not reached under exceptional conditions. return superImportant( outcome ); } If `doSomethingThatCanThrow` throws, your program is broken, and you can do nothing to make it working / recover from the exceptional state. Using `try/catch`: function veryImportant ( thing ){ var outcome; try { outcome = doSomethingThatCanThrow( thing ); } catch ( exception ){ outcome = 'Safe default outcome'; } // Executed 100% of the times. return superImportant( outcome ); } Now your program executes correctly in any case.
It's not always about features but also maintainig. Lets imagine e.g. observing/watching stuff. If in few years every browser will have support for Object.observe current mechanizm will be slowing your app. Keeping stuff up to date is not only about features. 
You are Gale Boetticher from Breaking Bad ..
What are you talking about? I showed how setting the value of 'JavaScript' for the person object is still accessible from the map when you change `person.name `, while it isn't with an object. It's not hard to imagine a scenario where this could be problematic. When you use the object as a hash on your known object structure, you're assuming that your object won't change. Sure, this might be true for simple apps. But, for larger apps like maps, graphics, animations, or Facebook news feed, that mutability becomes very difficult to reason about. In fact, Facebook created [immutable.js]( https://github.com/facebook/immutable-js/blob/master/README.md) to go one step further in solving the problem. The library prevents the data structures from changing underneath. To set a map value with their library, you receive a new copy of the map. Immutability is a key tenet of functional programming.
The technical details is as ^ said. From an more philosophical view, Flux is about simplifying the data flow in an application by only allowing the data to flow from "left to right". This makes it easier to keep track of the state of your data and reduces the complexity of your application. Since all your datas are modified only the stores, your views(React) can treat all the data`s as immutables. The side effects of this, in my experience, is easier application model and less bugs. Since your views are reduced to simple "data in -&gt; data-out" components a lots of view synchronize problems just disappear. Compared to angular problems such as $digest-cycles, model-dot, two way binding problems etc. no longer exists. This also makes the client-side architecture look much more familiar to your traditional server side application, which in my opinion is a good thing.
 // leading zeroes - 49 characters var lz=function(n,e){return(eval('1e'+e)+''+n).slice(1)} Obviously do not use in production.
To answer your question exactly: it is not useful at all. There were some examples in other comments like: try { user = getUser(id); return "&lt;b&gt;" + user.name + "&lt;/b&gt;"; } catch(e) { if (e instanceof UserNotFound) { return "&lt;b&gt;User not found&lt;/b&gt;"; } which you could easily rewrite to: user = getUser(id); return user ? ("&lt;b&gt;" + user.name + "&lt;/b&gt;") : "&lt;b&gt;User not found&lt;/b&gt;"; "Modern" languages get that and avoid including try/catch in their syntax. Although null/nil values are yet another source of evil and confusion. Generally speaking, to write a good behaving code, avoid using try/catch as much as possible. Not to mention the performance hit you get from using them. I think zoomzoom83 is pretty concise, especially the last bits.
yep
I think that most of the other answers on this page are failing to explain the whole "What's the point?" or "What problem is try/catch trying to solve?". I'll try to keep it simple. Things go wrong in code. Maybe you tried to read a file and the file wasn't there. Or your function expects a string parameter to contain the name of a user, but your code couldn't find the user requested. When things go wrong, or programs should handle the situation in a graceful way, and not just blow up. Traditionally, if something goes wrong inside a function you might return a special value or error code to indicate that an error occurred. For example, our function getUserInfo(name_string) may return null if there is an error, or it may return an object with fields "info", and "status_code". The status code could indicate if the requested user is missing, or maybe if the caller doesn't have permission etc etc. Someone using our getUserInfo() function should then examine status code first to if the call was successful. result = getUserInfo(someUserName); if (result.status_code !== SUCCESS) { // something went wrong. log(...); // Maybe report the exact error to the user. return; } ... // run normally. If every time that you use a function you also have to check its status code, you can imagine that your code becomes a mess with error handling code mixed in with the code that runs normally (i.e. what you are really trying to do). "Exceptions" are a mechanism which allows you to separate error handling from the normal successful code path. If something in getUserInfo() goes wrong, then it can throw an exception and the caller can then catch it using try/catch. The exception object itself can contain more detailed information about the exact error. try { ... userObj = getUserInfo(someUserName); ... ... // normal execution is here. ... } catch (ex) { // something went wrong. Log it or do something. ... } Your own code can throw exceptions to communicate errors to callers. That is the point. It is a way of handling errors in code in a structured and clear way. Other details: * Often you want one try/catch to cover a series of related function calls which could go wrong, and to handle the errors the same way. * Many functions in the browser and libraries use exceptions already. * When an exception is thrown the JS will exit the function and keep on returning from the functions on the stack until it finds a try/catch which will accept and handle the thrown exception. * People don't use exception very much in the JS code I've seen. 
I have all but replaced the use of try/catch with promises. Since the code often mixes up API calls and purely client-side processing functions, and they need to be run in order, I manually create promises for the latter to fake async behavior. This way, the main function is a clean chain of helpers with a catch at the end, which handles different errors depending on the parameter sent when a promise is rejected.
perfect
Hmm I may use this
+1 for Chrome Beta. Not sure I agree that it's complicated to setup. Plus you get the full extent of chrome developer tools.
Cool! Compared to other languages, there's a massive amount of variability in how these design patterns get implemented in js. It'll be nice to have a more authoritative source to refer to when I go to implement my next project.
I usually use try/catch in cases when I need to access deeply nested properties of an object i.e.: response.data.errors[0].message Instead of writing: if (response &amp;&amp; response.data &amp;&amp; response.data.errors &amp;&amp; response.data.errors[0]) { displayMessage(response.data.errors[0].message); } I can simply write: try { displayMessage(response.data.errors[0].message); } catch (e) { displayMessage(defaultErrrorMessage); // log that something is wrong with response } It's been lots of cases when code crashed because server did not return properties as I expected it to do or code received arguments that did not contain properties that I want to use. It's a simple and I believe elegant solution to these kind of situations.. 
What's the point of autocompletable password dialog? It may be 'user-friendly' but it's not secure.
*face palm*
If you read the comments he is pretty upset about {{ curly braces }} specifically.
twice!
...so basically CoffeeScript? Which actually exists already and is used in production?
Just silly.
i bet
The biggest challenge is ng-model. At least that's what I see when the office puts contractors on Angular projects. They tend to grab elements inside controllers using angular.element rather than $ (so they feel like at least they're not neglecting Angular completely?) and trigger clicks, add classes, loop through children, and all sorts of things you shouldn't do.
&gt; the gist of the spec is being able to create custom DOM elements. These custom elements are isolated from their neighbors (and parents and children), and they encapsulate some small part of the overall application. The canonical example is the &lt;video&gt; element: all you need to do to bring a self-contained video player “mini-application” - complete with a seek bar, playback control buttons, etc - into your main application is to create a &lt;video&gt; element on your page. The internal logic, DOM content, styling and (importantly!) state is neatly packaged away behind a standard DOM element. My go-to quote with this is from Justin Meyer: "The secret to building large apps is never build large apps. Break your applications into small pieces. Then, assemble those testable, bite-sized pieces into your big application". Web Components allows you to do just this: break your large app into a bunch of independent mini-apps, making the complexity of the whole more manageable. You seem to have just described React. Isolated and composable components are a core part of React and not unique to Web Components.
This is a joke, right? &gt; We are going to start a kickstarter campaign or get VC funding to create a javascript replacement Yeah, definitely a joke. &gt; #### Variables/Functions Be Defined Simpler Get Rid of Camel Casing! &gt; It makes things hard to read and should not be the standard. Haha, it's so meta because you can hardly read the argument itself! &gt; #### Ruby Makes The Most Sense &gt; This is the best framework to build website apps! If we could incorporate javascript like functions using Ruby, the world would be a better place! You would see app development take step up from where it is today. Bwhahahahahahahahaha!
&gt; function divide( number, divisor ) { return number / divisor; } Just happened to notice, no offense here... but `number` is technically the "dividend": function divide( dividend, divisor ) { return dividend / divisor; } It also could have been: function divide( numerator, denominator ) { return numerator / denominator; }
sure, what size do you prefer?
no, it doesn't support remote debugging as there are already plenty of tools allowing this. This tool tends to be very small and extremely easy to integrate for a small fix
&gt; "This [MVI example](http://staltz.com/mvi-example/) also performs better than [React](http://binarymuse.github.io/react-primer/build/index.html?6)" If I click "Add Many Items" and then drag the slider, React version is smooth but MVI one is super choppy. Did I miss something?
 function factory(name){ eval('function ' +name+'(test) { console.log(test); }'); return eval(name); } I'm not sure if there is a way to do it without eval (or Function, both of which are generally discouraged, eval even moreso) though. Edit: A little different to make the Function way below work. (might be safer): function factory(name){ return (new Function("return function "+name+"(){}"))(); }
Try half and remove the arrow too, so that the mystery is complete.
What sets this apart from using something like, say, Firebug Lite?
&gt; I'm not sure if there is a way to do it without eval (or Function, both of which are generally discouraged, eval even moreso) though. Yes, the (hidden) requisite was not using eval or Function. I had to write it clearly, sorry :(
It's a complete paradigm shift, and I definitely see the same, programmers comfortable with jQuery try to make Angular work like jQuery rather than learning the Angular way. The thing is when you stop fighting Angular and just do it their way it becomes so much easier and make so much more sense. The smell I usually tell my devs is if you're having a hard time testing your code, you're probably doing something you shouldn't (e.g., that DOM manipulation should be in a directive or that API call should be in a service.)
Reading the comments it appears he's mostly talking about tooling for jsx 
JSON.parse is probably the most common thing you'd wrap in a try/catch block. Generally, this is ran after getting data from somewhere that's not already in memory, thus the developer isn't sure if it's really JSON, thus a try/catch block will catch if you're parsing something that isn't JSON.
You can also run a debugger pretty easily for safari mobile tethered to a computer using safari desktop.
Interesting. However there are things I don't understand. &gt; React turned out to disappoint me in multiple ways, mainly through a poorly designed API ... It would be advantageous to read more details on that. &gt; .. which induces the programmer to create complex state machines and to mix multiple concerns in one component I'd say it's a great benefit, what's wrong with state machines? I'm pretty interested since I find them a neat model. &gt; The benefit of Reactive over Interactive is mainly separation of concerns. In Interactive, if you want to discover what affects X, you need to search for all such calls X.update() in other modules. However, in Reactive, all that it takes is to peek inside X, since it defines everything which affects it. ok but you get the dual problem: in Reactive, if you want to discover what X affects, you need to search all the subscribers. &gt; However, they cannot be JavaScript functions strictly speaking, because that would be a recursive cycle without a starting point This is a problem with events (besides the fact it is easy to lose control). &gt; Renderer is a side-effect and "sink" type of component, consuming events from Views and changing the real world. The benefit of its separation from Views is that Views become more testable since they don't require a browser environment. You can use Views as function-like components: feed in any mockup data, and inspect what Virtual DOM elements (just Javascript objects) come out. I agree. My main complaint is: in React views and renderer are kind of entangled. In conclusion, since we are talking about duality and Reactive seems at first sight more complicated to implement, using (a revised) Occam's razor I'd keep the Interactive version. But I'm eager to learn more about it.
You're right. I just learnt five new things! Thanks :)
It seems a little out-of-season for Internet Pranks, so I'll just suggest keeping [Poe's Law][1] in mind while reading this. Sincere or parody, it's a fun read! [1]: https://en.wikipedia.org/wiki/Poe's_law
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Poe's law**](https://en.wikipedia.org/wiki/Poe's%20law): [](#sfw) --- &gt; &gt;__Poe's law__, named after its author Nathan Poe, is an Internet [adage](https://en.wikipedia.org/wiki/Adage) reflecting the idea that, without a clear indication of the author's intent, it is difficult or impossible to tell the difference between an expression of sincere [extremism](https://en.wikipedia.org/wiki/Extremism) and a parody of extremism. &gt; --- ^Interesting: [^Clarke's ^three ^laws](https://en.wikipedia.org/wiki/Clarke%27s_three_laws) ^| [^Illusion ^of ^transparency](https://en.wikipedia.org/wiki/Illusion_of_transparency) ^| [^Fundie](https://en.wikipedia.org/wiki/Fundie) ^| [^List ^of ^Internet ^phenomena](https://en.wikipedia.org/wiki/List_of_Internet_phenomena) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clrsmbr) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clrsmbr)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
http://xkcd.com/927/
I'm pretty sure these guys are serious.
I'm glad they will finally deliver us from the horror of camel case variable names. Development will become at least 50% faster. 
oh okay so youre talking about two problems here, 1. dom manipulation in controllers 2. not using angular stuff when there is an angular solution
&gt; 256 Signatures Seems about right.
I've always wanted mutable strings! Just think of how fast template engines could be! Everybody knows braceless chained function invocation removes up to 75% of spaghetti code.
Console.table just saved my life... I hadn't found an easy way to display data structures in JavaScript and used to just convert it to JSON and print it...
Gotta give props to weinre - that's a fantastic tool. 
Yep, this is literary the ONLY time I ever use try/catch.
There are alternative tools that do that, if that's what you want. Blackberry http://docs.blackberry.com/en/developers/deliverables/38982/Getting_started_with_Web_Inspector_1695020_11.jsp Android &amp; iOS http://developer.telerik.com/featured/a-concise-guide-to-remote-debugging-on-ios-android-and-windows-phone/
tl;dr- &gt;we like ruby/rails so much we want DOM scripting to be like that instead. Honestly, some of the syntax features they propose are just as unnecessary/confusing, unless, of course, you're familiar with ruby. What I find interesting is that html has, for a long time, supplied a `type` property for script tags, with the intent to possibly support multiple scripting languages, but browsers do not really support anything but javascript. How about just asking browsers to support more scripting languages in a sandboxed way, providing a DOM api for each language? It could look like this on the page: &lt;!-- src as property would be ignored when &lt;source&gt; inside &lt;script&gt;. currently, browsers ignore the contents of a &lt;script&gt; tag when src= is present. given the above, this should be backwards compatible. --&gt; &lt;script src="/path/to/script.js"&gt; &lt;source type="text/python" src="/path/to/script.py"&gt; &lt;source type="text/perl" src="/path/to/script.pl"&gt; &lt;source type="text/ruby" src="/path/to/script.rb"&gt; &lt;!-- provide js last as a fallback --&gt; &lt;source type="text/javascript" src="/path/to/script.js"&gt; &lt;/script&gt; That way you have your choice of DOM manipulation, and can provide multiple sources of different types and the browser can choose the first compatible version. I would much prefer the slight addition of complexity to allow for more choices rather than creating one new language that caters to any niche of the programming world.
Why would you post an anti-Javascript site on /r/javascript? Like it or not Javascript has succeeded at creating a ubiquitous runtime environment. Browsers are operating systems and Javascript is bytecode. Javascript's flaws are overstated and can be remedied with appropriate use of ASI. Scheme. Functional Reactive Web Scale. If anything we should do a Kickstarter to tell Javascript what a good little programming language it is, yes it is, aren't you boy? 
yep, this is what I've been doing as a replacement to try catch in my JS lately
Are you saying Reactjs can be the workflow library? I can kinda-sorta see that, but it's not obvious to me.
Of all of them, console.table and console.time are probably the most useful ones. Thanks!
GAH impossible with a mouse! I maxxed at 6.
If you want a table where you can sort the rows etc. paste the JSON into [json-csv.com](https://json-csv.com) - then you will have a table inside a spreadsheet.
A trick I learned recently: you can use CSS styling in console.log by prepending the text with "%c" and adding the styling as a second param, like so: console.log("%cHello, reddit.", "background-color: #2980b9; color: #ecf0f1; border-radius: 3px; padding: 5px; font-size: 1.5em");
sounds an awful lot like 'get off my lawn' to me... I hate new stuff!
actually It's not even in Beta anymore, it's in normal Chrome (I just noticed this). And yes I guess it's not really that complicated, any developer can easily follow the instructions to set it up and no third party libraries needed. I definitely prefer it over Weinre, but weinre was definitely good before this existed
Which browsers do these work in? Just Chrome?
http://phonegap.com/ https://www.ludei.com/cocoonjs/ We're looking at these for our platform.
No, you should never validate known data conversion problems by if they throw an exception. That's lazy, and uses a lot more resources than defensive coding. Also, this is -javascript-; there are no strongly typed catch signatures.
my life is now better. ty.
http://www.reddit.com/r/ProgrammerHumor/comments/2fpls0/i_dont_know_what_i_expected/
Everyone knows that people are stopping developing websites only because javascript sux. Right guys? 
[It's a tongue-in-cheek post.](http://www.reddit.com/r/javascript/comments/2l64qt/no_more_javascript/clrslpc)
Thanks! If anyone has used either it would be great to know what happens with frame rate or any issues with resolution etc.
&gt; Why would you post an anti-Javascript site on /r/javascript? Whether this is serious (and terribly misguided) or tongue-in-cheek trolling, I believe `/r/javascript` exists to discuss JavaScript. That involves discussing the things we like and those we don't. You can see this when someone posts a "JavaScript WTF" article including fun with type coercion and other "Not The Good Parts" things. If you'd like a more folksy answer: &gt; "Keep your friends close, and your enemies closer."—Sun-Tzu, quoted memorably in "The Godfather."
So, essentially what you are saying is that error handling is designed for the purposes of trying to make functions 'total functions', which in turn means all possible contingencies have been planned for in such a way that a generic javascript error can not occur and whatever possible error would have occurred has been planned for in some specific customized way. I guess it makes sense.
Try, catch and finally are very useful. 1. It allows you to keep good encapsulation, meaning with try/catch you can deal with exceptions in one location gracefully rather than trying to create two separate paths in your control flow (one for errors, one for successes). 2. It solves the semi-predicate problem. There are instances where you could be designing a function that has no way of communicating an error occurred. 3. It can be actually faster to not validate inputs and simple assume their values are correct and pass them on. Then allow an error condition to "bubble" up through a stack of executions until it reaches an abstraction layer whose job it is to deal with exceptions in the software. 4. It's the only way you can have a literal "jump" to another piece of code in javascript.
Maybe, but I'm sick of clueless haters adding .1 and .2 and blaming standard floating point math on Javascript. Is it too much to ask that people embrace the ~~Backbone~~ ~~Angular~~ React way of doing things and commit to building a new mobile web? Why can't we convince people that they don't need classes, anyway? It's not like they can't use TypeScript, CoffeeScript, AtScript, Dart, ClojureScript, or asm.js instead of Javascript. Really, their complaints could be redressed by judicious application of mongodb. If anything I think Javascript's muddled strategy suggests another Sun-Tzu quote: &gt;"Let your plans be dark and impenetrable as night, unless you're precompiling with sourcemaps, in which case when you fail like a thunderbolt you might have some clue where to begin." There, even Javascript's deficiencies now sound like a grand master plan!
If so, it's not very funny. Enough people seriously think like this that they run the risk of being taken seriously when they spout obvious gibberish. 
A bit more context to this code http://obscurejavascript.tumblr.com/post/101608780722/efficient-super-calls-in-javascript
Impressive! Contrary to the horrendous plans for AngularJS 2.0, Ember seems to nail it. This document gives me a very strong impression that the Ember team takes developers seriously, and that they don't live in a fairytale world were you can just 'rewrite all the things'. Certainly motivates me to switch from Angular to Ember for future projects.
This will help you visualize: http://www.regexper.com/
I knew them all. 
Another tip, if you want to make a shortcut to console.log for quick debugging, you can't do: var L = console.log; L('foo','bar'); // Uncaught TypeError: Illegal invocation But you can do: var L = Function.bind.call(console.log, console); L('foo','bar'); // foo, bar (examples in google chrome console)
Console.table looks really nifty. Glad I clicked the click.
Author doesn't know shit about how it all works and comes together. "If a language was like this... then everything would be like...". It's a pipe dream. Factor in 1) Humans and 2) Computational ecosystem (hardware, kernal, OS, browser, languages) -- quickly you realize that shit is not ideal, and it will not be ideal in this field we call programming, and 'web', etc. and ruby doesn't make it better, it's not the gold standard, nor is javascript the problem, or solution for that matter. Nothing we have today comes close. We need a different approach from the bottom up or everyone becomes a tower of babel. We literally cannot go higher or do more at this point in time with the foundation we have. 
i've had good experience with it. performance wasn't perfect, but it also wasn't bad. it worked, and it worked pretty well, and it was cross-platform, and much more reasonable than learning java. just be weary of dom rendering and framerates, and other stuff that you have to check to make it work well for a game.
"they fail to acknowledge that React's less radical approach allows for better interop with many existing codebases and frameworks" haven't tried Mercury, but Ractive components are as easy to integrate into an existing codebase as React components. In fact, I'd say they are easier, if you add Flux (or one of its implementations) into the mix. 
https://wordpress.org/plugins/content-warning-v2/ ? 
That is an example where a side effect is the sole purpose for iteration -- the side effect is to output to the console. It's explained more in Example 5 -- forEach is okay when the point *is* to cause a side effect. The places where side effects can be avoided by using a better iteration function or a more meaningful method is what the article is about.
ok, I get you now. Yeah, don't use foreach if you're trying to map/filter/reduce/some but that's just knowing about those functions and being confident in using them. I'd rather someone iterate an array than make a ballsup of a reduce function because they weren't ready with their understanding of it yet. Maybe your title is a bit too suggestive and sets the tone up wrong for what you're actually trying to convey. 
He probably should've used [Lo Dash's built-in method `_.property()`](https://lodash.com/docs#property) which does the same thing as the author's `dot()` function. Regardless, the author's use of currying is fine and the use case is exactly the kind of thing currying is useful for. **Edit**: I was wrong, I hadn't noticed the `()` at the end invoking the function.
What "currying spaghetti" are you referring to? Do you have an example of a time when currying a function made it hard to maintain? Obviously you don't need to curry every function, but it really shouldn't make much of a difference.
I've been jaded by a codebase filled with unnecessarily curried functions that there are sections where you just have no idea where the code execution path is going or what's going on. It's made me very wary of currying. Yes it's great but use sparingly. I'll see if I can dig out and anonymise a particularly bad example. 
&gt; Maybe your title is a bit too suggestive and sets the tone up wrong for what you're actually trying to convey. Well, it's like they say -- the two hardest problems in programming are cache invalidation and naming things. :) I think the title is fitting. If you have a problem and you reach into your toolkit for `forEach`, then perhaps you need to think about what you're triyng to accomplish -- there are likely better tools.
+1 for lodash's property method! Maybe it's the "dot" function name that I've taken issue with here rather than the actual currying itself, he has mentioned that it's the same as Clojure's dot function but to someone who's not tinkered with Clojure, it's not a particularly intuitive function name at first glance. 
Oh assumed because the subreddit is name r/javascript that it was about javascript
I grew up using for-loops. I have been using them since the second week of CS101. I don't understand how they are so inexpressive. Can someone enlighten me?
A better link http://addyosmani.com/resources/essentialjsdesignpatterns/book/
For-loops tell the compiler *how*, and can only be used to perform side effects. Functors/Mappables tell the compiler *what*, and used properly will never perform side effects. By using a functor, you're simply creating a projection over an Iterable container. The exact method of implementation and order of execution is irrelevant. From a performance perspective, this gives the compiler much more free reign to optimize (Such as by running the operation over multiple threads, or lazily). Javascript VMs currently don't really do much with this, but other languages do (And Javascript probably will at some point). However even in JS it does mean you can swap out data structures without changing your code, letting the 'map' function choose the most efficient underlying algorithm without having to change your code. From a code maintainability perspective, avoiding side effects means your code has less moving parts and is easier to reason about. It's also just simpler. var ys = [1,2,3,4].map( x =&gt; x * 2 ) Is unambiguous about what it's doing, and lets the compiler figure out the optimal way of doing it. Compare to: var xs = [1,2,3,4]; var ys = []; for( x=0; x &lt; xs.length; x++ ){ ys.unshift( xs[x] * 2 ); } This has a lot more moving parts. It performs side effects. It's harder to optimize. It's requires more cognitive effort to reason about what it does, and it's much harder to spot any potential bugs. (Did you notice them?). tl;dr - one of these methods "Has no obvious defects", the other "Obviously has no defects". 
I'm not learning this stuff as it seems silly to me. I'll provide you with some pseudo-code to illustrate what you essentially did if you want to be fair and change the map the same way. map.change(person, person1); Then try it, it'll fail--of course. If you change a key in a key, value pairing of any type, of course you'll get different values. It doesn't matter what the key is. There must be some type of speed component to this because it seems like the most useless thing to me. 
Good catch, thanks.
You're somewhat correct - that example was a pretty bad example of good code, since throwing an exception for a normal failure case is bad design. Not finding a user really falls into flow control, and exceptions should not be used for flow control. In FP languages I'd normally use `Option` types in this case, but in Javascript returning null pretty much fills the same niche, albeit with a bit less safety. This doesn't mean that Exceptions aren't still useful in Javascript - they most certainly are, since they convey a lot more information than simply returning null. But there are better ways of handling error conditions in a lot of cases than throwing an exception. In FP languages my convention is to use Either/Option for error conditions that are a normal/expected part of flow control (i.e. not finding a user), and Exceptions for things that I don't reasonably expect a caller to deal with that will probably bubble up the stack (i.e. network failure)
Be careful doing this - you can potentially swallow exceptions that you weren't anticipating, and it might end up causing more problems than it solves in a complex codebase. Coffeescript has the existential accessor operator (?.) which propagates nulls instead of raising a NullPtr. I believe ES6 implements the same thing, which should solve the issue. Of course using current-generation Javascript you're still between a rock and a hard place, and there's no trivial solution. If you *do* use exception handling as a solution, at the very least make sure to only catch NullPtrs and re-throw if it's not.
Basically a regurgation of https://developer.chrome.com/devtools/docs/tips-and-tricks
Honest question. Is there a reason you didn't do this? var L = console.log.bind(console); 
Also `$0` is the element that you've currently selected in the inspector. Which I've found immensely helpful in getting angular scopes with (`angular.element($0).scope()`) Also if the page doesn't have jQuery then `$("anID") will return the element with the id anID. (Sadly it's not a shortcut for document.querySelectorAll)
Sorry, I was mistaken earlier. Instead you simply should've used [Lo-Dash's built-in `_.invoke()`](https://lodash.com/docs#invoke) and [`_.compact()`](https://lodash.com/docs#compact) methods. this.tooltips = this.tooltips.concat(_(this.values).invoke("getTooltip").compact().value());
I have no idea what your 'pseudocode' is doing. You've just made shit up about a common data structure to prove your point about it being useless. There's no *change* method on the Map prototype. Have you never used a Map data structure before? There's no way to 'change a key' on any implementation I've ever seen. If you wanted to store some data at a different key, you'd retrieve the value and set it on a different key which provides deterministic results then null out the original key. This is exactly how Map is intended to function. This is no different than how you'd currently do this with an object. The biggest difference (as I showed in the gist) is that using an object as a hash is constrained to **known string values**. When the string value changes, you can't retrieve your data. This is commonly resolved by appending some known property to the object. There are inherent problems with modifying objects in an asynchronous environment, especially when you're not the owner of the objects you're modifying because the object can mutate depending on user interaction, ajax, or event propagation. If what your 'pseudocode' was attempting to do was to mutate the person object... I already showed an example of that working *in the gist*. It's overly clear that you don't understand the Map data structure and no amount of linking to documentation or explanation appears to help you. You'll just need to work through some problems on your own until it clicks. ES6 adding Maps and Sets to the language is probably the simplest language addition to understand. If you don't understand Map (or why you'd use it), you'll probably also have issues with block scoping, constants, lambdas, generators, and other features. I'd recommend sitting down and playing with node (version 0.11.2 or higher) with the --harmony switch to become familiar with these things. You won't want to get left behind when ES6 becomes standard. Maybe looking at the Map implementation in v8 would help you understand what's going on? https://code.google.com/p/v8/source/browse/branches/bleeding_edge/src/collection.js?spec=svn21615&amp;r=21615
Dude, I just use this stuff to do system admin type things. I really don't care other than you ass hats are going to change what's working for me to do some dumb shit. It's not that I don't understand what a map is, it's just that it's stupid. Does it make anything faster? No. Does it offer any functionality that can't be done better with existing tools? No. Like I said, you changed the key so the value wasn't there. Do the same thing with this "map" and you'd get the same results. All the map is internally is likely a hash table like everything else but with the option to use things other than strings. Makes no sense to me but people seem to want to make things more and more complicated to do the smallest, simplest of things. &gt; The biggest difference (as I showed in the gist) is that using an object as a hash is constrained to known string values. When the string value changes, you can't retrieve your data. Change the key(regardless of method--new key/delete old) is the same thing thing as changing the string value in an object--maybe the implementation is different but who cares. Making something immutable is just stupid. If you don't want to change data, don't. But no, the cool thing is to make something as complicated as fuck using more and more cpu cycles to accomplish something that use to be done in a much easier fashion. &gt;If what your 'pseudocode' was attempting to do was to mutate the person object... I already showed an example of that working in the gist. You're using the map as a key/value store the same as you were using the object. You changed a key in the object to show that the value couldn't be retrieved. I did the same thing with the pseudo code but for your map. All your map is is a hash table after all whether you have to retrieve the value associated with a key, create a new key, insert the value and delete the old key as you suggested or not. You are treating the map as some holy fucking grail when all it is is a fancy hash table that allows you to use objects as keys. CHANGE THE KEY, THE VALUE LOOKUP WILL FAIL regardless of hash table type.
9 times out of 10 you really want "map"
The Ember core team takes developers very seriously because they're all working as consultants building Ember apps, so they have a lot of motivation to make sure it is developer friendly.
This is a great post, thank you
console.table() is also in Firefox, as are most of the other console methods in Chrome. Don't know about Safari, but I'd imagine it has a rather feature-complete console as well. 
[Very soon.](https://www.mozilla.org/en-US/firefox/34.0beta/releasenotes/) My bad, I'm currently using the beta.
Oh it was very clearly done in response to the angular announcements. However it's still a great announcement.
Many members of the core team indeed do Ember consulting work, but I would say that a bigger part of our motivations comes from our own Ember apps that we work on. For example, I work on Skylight (https://www.skylight.io/) most days, which is an Ember app that started out in the pre-1.0 days and which is now an up-to-date Ember app using Ember CLI. I want Skylight to be using Ember 2.0 (and deity-willing, Ember 3.0, 4.0, etc.), which means an upgrade needs to be something we schedule incrementally over time. We only have a small handful of engineers working on the project, so we simply cannot afford to take months to rewrite everything. At the same time, we don't want to fall behind the state-of-the-art. It's a balance, which led to the transition plan we announced. The majority of the core team is in a similar spot: a mix of a consulting (both greenfield and existing apps) and a long-term app that they work on. It provides a pretty good perspective, I think.
console.table * _ *
It's a tiny instrument doing just 1 thing. You can possibly integrate it into your site so that it can be opened right on production with some query parameters or any other way, because it is small sized and it requires no knowledge of its api/interface. If you are already with Firebug, there is no need to migrate to it.
This is nice... and it seems to also work in Firefox... pitty he didn't check any other browser other than Chrome :|
Nice find! Just curious why would anyone need such a styling feature. 
In my office, console.log is frowned upon. People accidentally push commits with console.log I mostly just use watch expressions. Why would you need so many console logs?
Imperative code vs declarative code. It's just a stylistic difference. A similar discussion can be made about procedural and object oriented programming. If you're proficient with C, why would you ever want to use C++? More to the point, higher order iterative functions are just encapsulations for several common patterns. For example, it's a common requirement to take an array and remove items that don't pass a test. This is very easy to do with a for loop: var array = [1, 10, 5, 6, 3, 8, 2]; var filtered = []; for (var i = 0; i &lt; array.length; i++) { if (array[i] &gt;= 6) { filtered.push(array[i]); } } console.log(filtered); // [10, 6, 8] When you need to filter a lot of arrays, this pattern can quickly become redundant. If you can replace this code with: var array = [1, 10, 5, 6, 3, 8, 2]; var filtered = array.filter(function(v) { return v &gt;= 6; }); console.log(filtered); // [10, 6, 8] It can increase the readability and conciseness of your code (the intent is immediately clear - filter the array based on the condition that each value must be greater than or equal to 6), and doesn't require any unenclosed variables that are only relevant to the filtering logic (the index variable and the working array). Composability of logic is nice, too (using lo-dash): var gte = function(n, v) { return v &gt;= n; }; var gte6 = _.partial(gte, 6); var filterGte6 = _.partialRight(_.filter, gte6, null); var array = [1, 10, 5, 6, 3, 8, 2]; var filtered = filterGte6(array); console.log(filtered); // [10, 6, 8] This is one example of how a functional style of programming can help you create small, reusable, composable components with higher order functions. Notice that in the original, imperative example, the `array` and `filtered` variables are tightly coupled to the filtering logic. In this example, those variables have been completely separated from the logic - we are free to reuse our filtering function on any array without code duplication. I'm not saying there is anything wrong with imperative programming, just trying to give examples of why some people like functional programming. 
Mainly because it uses `eval`.
It's in firebug since forever (Firebug introduced the console object and most of its methods).
I mean... my code doesn't have that eval. I'm not even sure where you got that part from. I assumed you were changing my code somehow. [edit] Were you offering an alternative? Oh man, no I would never throw an eval into production code like that.
No, I'm talking about *my* code that I posted above—a version of the `lz` function that only uses 49 characters. Don't use *my* code in production.
Interesting, although, I believe it would have to be var lz=function(n,e){return(eval('1e'+(e-(n+'').length))+''+n).slice(1)} In order to work correctly, the e should be the final number of characters, not the number of zeros necessarily.
Console.table just blew my mind 
When will we have a good framework that is completely separated to independent components? I think the future of JS frameworks lies in a powerful DiC and heavily tested modules that communicate well with each other based on community agreed standards. Also I believe that HTML style template engines will be abandon in favour of a strong JS abstractions for the view layer. Something in the flavour of React, but without reflecting the HTML structure behind the scenes. This sort of abstraction will allow more modularity in the views. for example, it will make changing a table view to a sortable table view a breeze compared to current solutions. 
Holy fuck! How did I not know this until today? 
Let me explain a little about what's going on if someone is interested. 1. 10 + true //results 11 This is because when JS encounters a plus operator between boolean and a number or boolean and a boolean it performs an implicit coercion and boolean is converted to number. Try true + true. 2. '2' + 10 //results 210 JS encounters a string and goes ahead with concatenating and here a number or boolean get converted to a string. 3. 90 + 9 + 'b' // 99b Now JS goes from left sees and operator, checks the operand and finds a number and hence evaluates the expression and then moves ahead to see an operand that is a string and it now performs concatenation. 4. "100" + 10 + 1 // 100101 Same as 3 but the evaluation starts from left to right and because string is encountered, the result to the first is '10010' + 1 giving away string concatenation again. 5. +"90" + 9 // 99 Js encounters a unary operator + and what JS does similar to parseInt [watch Douglas Crockford mentioning using a shorthand usage for parseInt] and converts the string to a number. 6. 5 + +"5" is equivalent to (5 + (+"5")). 7. JS ignores the number of spaces between operands and operators. 8. Rest of them were wrong/invalid assingments/operation, JS-wise and mathematically too :P
There should be a step in the build process to remove logging. 
 function(n,e){return(eval('1e'+e)+n+'').slice(1)} I think that should work. What I'm going for is the same as your code except for: * `eval('1e'+e)` as a shorthand for `Math.pow(10,e)` * `slice` instead of `substr` * removing the whitespace after `return` since the symbol following it is an open-paren.
I get bored of framework and I am more on the search for the perfect transpiler, and purescript is close to that.
Depending on what i am doing i have a lot console.log's in my code to keep an eye on objects when i change stuff. Usually i pack them with some DEBUG = true; option.
They're helpful to see what is happening in a Dev environment. We commit them as long as they're actually informative, and strip them when we minify.
You can always resolve the distributed system's issues with integration tests that check for collisions in real time while also testing the functionality. I think it's a solvable problem.
Closure Compiler
Since the revelation of Angular 2.0, MEEN stack is looking much more attractive.
Yes, it is used quite a bit. And yes, it is bound to the instance. Otherwise you would have to add it to the prototype. publicB() cannot call publicA() within itself because publicA() is only defined on the object you are returning, { }. If you don't call it on that object, it does not exist - unlike prevA() that is declared outside the object. EDIT: sorry, I misread. Have removed the part you already wrote about.
That's funny, I feel like it's more of a mirror showing the Angular team the giant middle finger they gave to their users.
Any reason why you are rebuilding this ? Have you looked at http://prismjs.com/ https://highlightjs.org/
The main thing I would recommend is to use the Flux pattern for data management. If you're not familiar with it, check out this blog post which goes into all the detail you should need: http://scotch.io/tutorials/javascript/creating-a-simple-shopping-cart-with-react-js-and-flux Make sure to check out "Further Reading" at the bottom of the post for more introductory material (you may want to read that stuff first). Also worth a mention is [react-router](https://github.com/rackt/react-router) to handle routing. It's a great match for React, though it does leave a bit to be desired if your app doesn't fit its idea of how URL schemes should work.
You know... we could technically just skip the eval, and hop straight to the unary. I like it. Only 46 characters. function(n,e){return(+('1e'+e)+n+'').slice(1)}
Really, pretty sure I tried that first by accident? Though that may have been in Safari not chrome. 
&gt; so is "this" wrapped by the return mechanism to that instance? This requires some explanation. In JavaScript, "this" is never guaranteed to be any particular value. For example: // if I invoke "publicB" as a function, then during that invocation, "this" will be the global object var publicB = i.publicB; publicB(); // "this" is global object // if I invoke "publicB" with "new", then during that invocation, "this" will be a brand new object new i.publicB(); // "this" is a new object // if I invoke "publicB" with "call", then during that invocation, "this" will be whatever the heck I please i.publicB.call(RegExp); // "this" is RegExp // and, of course, if I invoke "publicB" as a method of an object, then during that invocation, "this" will be the object i.publicB(); "this" is i Since there are so many ways it can go down, it requires some discipline on our part to use objects and methods as they were intended to be used. In your case, you can reasonably assume that "publicA" and "publicB" will always be called as methods on the object returned by your "single" function, and therefore "this" will refer to that object.
Studying js and techniques as first, i also try some scripts downloaded, most of them are for static texts, i'm trying to color the code when you are typing, do you know some js library for do this in real time? (thx)
If you do not deal with prototypes you can ditch `this` altogether. Just keep the reference to your public api inside your constructor, like so: var single = function () { var a = 10; function privA() { console.log(a); } var api = { publicA: function () { privA(); }, publicB: function () { api.publicA(); } }; return api; } var i = single(); i.publicA(); i.publicB(); 
"This" keeps throwing me for a loop but I'm slowly getting it.
Would this be the same? return api = { } or does it need to be a local var?
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
Regular expressions are a dead end for analysing and converting. What you need is a lexer/tokenizer. You can write your own lexer or use a library. To find one the suits your needs, nodejsmodules.org is always a good start: nodejs: https://nodejsmodules.org/tags/lexer browser: http://bower.io/search/?q=lexer
What an absolutely unnecessary comment. OP isn't trying to sell anything, they are just trying to experiment and need some help. We've all been there.
Thank you for being the first productive reply in this thread.
I guess the ACE Editor is the most fleshed out source code editor: http://ace.c9.io/. E.g. github uses ACE.
For 2D physics check out [p2.js](http://schteppe.github.io/p2.js/), specifically the [concave](http://schteppe.github.io/p2.js/demos/concave.html) demo.
React works well with any router, but the routers designed for React will make your life much easier. You should also check out react-bootstrap, which has already wrapped Bootstrap in React components for you. See react-components.com for a component library. In particular Khan Academy's open-source components are excellent
Surprised I'm the first to point this out, but within any given scope you can do this: myScope['myFunction'] = function () {}; // The following code works: var fName = 'myFunction'; window[fName] = function () {alert("Hello world"); }; // Call it like this: myFunction(); // Or even call it like this: window[fName](); // Or like this: window['myFunction'](); 
See also /r/reactjs (today it had this https://github.com/enaqx/awesome-react listing many resources) Anyway, to piggyback on OP: can anyone explain how a Flux based solution relates to something based on immutable/subscribable data like [morearty](https://github.com/moreartyjs/moreartyjs), Om etc?
thank you, anyway, my little script DONT change nothing on the original text typed but make the coloured mess in a secondary div, so when you select and copy the code, you copy the original one without modify, it is a good idea? p.s.: you are right, i need a tokenizer, it is a mess after the second regex replace :D
What's the language? Also, do you have any suggestions for someone else who might be interested in implementing a language?
I think that todays frameworks are written by fkn geniuses. I love diving into frameworks like angular. Yes, it's damn hard to get my mind around it and sometimes feels like a blackbox. But with tools like spy.js and chrome/firefox/anything debugger you can understand whats going on under the hood. And it really is not magic at all. I am so thankful that all these free, 100% unit tested frameworks reduce my own ugly codebase ten-fold. And I am finally able to unit test because of the concepts that these frameworks apply.
[This stack overflow answer] ( http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454) will make you laugh(note that I know you're not parsing html with regex, it's just a similar situation) 
PhoneGap allows you to interact with native APIs but your game will still render to a WebView (Android) or UIWebView (iOS) using your HTML, CSS and Javascript. Because of this, you'll want your game to have good performance in a mobile browser which depends on how you go about rendering your game content. CSS transforms are suitable for simple games (like [2048](http://gabrielecirulli.github.io/2048/)) but exhibit slowdown with multiple animations and on older devices. HTML5 canvas is generally a better solution but YMMV with HTML5 canvas frameworks like KineticJS or EaselJS. My approach is to use WebGL and fall back to HTML5 canvas on devices that don't support it or stay below a certain frame rate for a specified period of time. Manually writing GLSL shaders can be tedious but there are libraries like [Pixi.js](https://github.com/GoodBoyDigital/pixi.js/) (my personal choice) or [ChesterGL](https://github.com/funkaster/ChesterGL/) that you might look into. Good luck!
Hey there, My app is reasonably large and its written with React. 1. Use flux. 2. Triple-think about using states. It should honestly be props + fluxstores almost everywhere. My state only resides in the top components (and they're in the store) 3. Events in components should only call the flux-actions. Limit the logic in components (don't call ajax directly from the component) 4. It might sound easier to try to plug in a 3rd jQuery plugin... don't. It's ridiculously easy to port it it as a react component. I'm planning to release my select2 and datatables react ports. Even charts are quite easy to do in React, you'd be surprised. Use jQuery as last resort.. most of the time, you don't even need the full jQuery plugin, just a small subset of it. It will help for performance. 5. Don't use RequireJS. It's a pain in the ass to use with nodejs, and at some point, you'll want to render the components on the server side for faster load. You should try to do this in the beginning.. and your app will be crawlable and be a SPA. Pretty nice. 6. JSX seems ugly at first - but it makes the code so much more readable and easy to understand. Please use it, you won't regret it. It's really worth it. 7. Don't forget the keys when you `[].map`. 8. React chrome debugger is your friend. 9. I noticed that when using `ReactCSSTransitionGroup`, and the action triggering it is happening while you're in another tab - the element will not animate (so if you make it fade out, it'll stay there). I have yet to fix this, but it's documented in the github issues.. so I just made it not animate. https://github.com/facebook/react/issues/1326 That's all I can think of now on the top of my head. If you got any more questions, feel free to ask. By the way, if you weren't sure about using Angular or React for you project.... trust me, you've made the right choice. I started my app using plain jQuery, then moved to Angular, then I finally rewrote it with React, and I'm honestly sold 100%. I can't think of a downside. 
I would take a look at how CodeMirror does it. They support many different languages/modes out of the box and its relatively easy to add your own language/mode.
Probably a dumb question, but: Almost every React component I see gets defined and rendered in the same function. I have to assume it is possible to define a component, and then call React.render in a different file/location? However when I try this I am getting: Uncaught SyntaxError: Unexpected token &lt; Where my React.render function is called. What part am I missing? I'm seeing lots of stuff in the documentation about React.createFactory, but I am using JSX (and the documentation says if you implement JSX, you do not need to worry about factories). Thoughts?
I'm not sure what you mean because definition can be blurry/confusing if you're new to react. defined and rendered can mean different things. Paste your code so I can see. But from what I understand, yes, you need to use a module system, then require it where you want to render it. I recommend CJS/Browserify. If you're using JSX, don't forget that you have to transpile it. From your error message, it's probably what's happening here. 
`&lt;BottomBarCell cell={cell} /&gt;` Is not valid javascript. It's JSX. Browser don't understand JSX. You have to convert it to JS. http://facebook.github.io/react/docs/displaying-data.html 
Well, it kinda depends. I'm not sure if you're referring to semantics and the use of .controller() or the concept of a controller. The Angular website itself refers to the framework as an MVW (Model, View, Whatever). While technically there are controllers that you can build with Angular using .controller(), they're kinda just a go-between or a gateway between services and the DOM. Best practices dictate that you're not to do any DOM manipulation in the controller, and all business logic is to be stored in services. Controllers are just a means to access logic stored elsewhere or define methods assigned to $scope. With all that in mind, Angular 2.0 is doing away with 'controllers', so if it's debatable now, it won't be in the very near future.
https://news.ycombinator.com/item?id=8556505
They use EmberJS in my office and every release seems to contain breaking changes.
Have you used Angular and React in the same project?
Thanks!
Yeah, that's how I ported it first. It's alright, but it just doesn't make sense to use both. They're both pretty big library and my `vendor.js` was getting over 400kb, which makes me a bit uncomfortable. As I coded my react components, I just removed it from the page completely once I was done, and proceeded to remove it completely. Since I only needed SPA-like function in one part of the app, it was pretty straightforward to remove it. 
Funny, we do in ours as well and I've experienced none of that.
Looks like the changeType function should set a global variable to true or false so the other function can use it later to decide what to alert. Your "status" variable goes outside the function. That way, both the changeType function and the generate function can use it. The issue with the radio buttons is that they have different names. The browser uses that name to keep track of what's selected and unselect others automatically.
I see my first error was having different names for the radio buttons. I fixed that and it works now! Cheers for the reply
Thanks! Fixed that and made the function work now. Thanks for the advice!
And just for future reference, checkbox inputs should also have the same name. :)
It's totally possible, so long as you run the code in a browser that supports touch events. Here's how to do it with jQuery: // send a zero-touch event, such as touchend: sendTouchEvent(jqElement, "touchend", new TouchList()); // send a single-touch event: var touch = createTouch(jqElement, xCoord, yCoord); sendTouchEvent(jqElement, event, new TouchList(touch)); // send a multi-touch event: var touch1 = createTouch(jqElement, xCoord1, yCoord1); var touch2 = createTouch(jqElement, xCoord2, yCoord2); sendTouchEvent(jqElement, event, new TouchList(touch1, touch2)); function createTouch(jqElement, x, y) { var target = jqElement[0]; // pull out DOM element var identifier = 0; var pageX = x; var pageY = y; var screenX = 0; var screenY = 0; return new Touch(undefined, target, identifier, pageX, pageY, screenX, screenY); } function sendTouchEvent(jqElement, event, touchList) { var touchEvent = document.createEvent("TouchEvent"); touchEvent.initTouchEvent( event, // event type true, // canBubble true, // cancelable window, // DOM window null, // detail (not sure what this is) 0, 0, // screenX/Y 0, 0, // clientX/Y false, false, false, false, // meta keys (shift etc.) touchList, touchList, touchList ); var eventData = new jQuery.Event("event"); eventData.type = event; eventData.originalEvent = touchEvent; jqElement.trigger(eventData); } There may be some typos in there, I manually edited [my actual code](https://github.com/jamesshore/lets_code_javascript/blob/master/src/client/html_element.js). I'm sure you could do it with raw DOM calls, too, I just haven't bothered. I have a whole chapter on triggering touch events in my [Let's Code: Test-Driven JavaScript](http://www.letscodejavascript.com) screencast. It [starts here](http://www.letscodejavascript.com/v3/episodes/live/70). (Disclaimer: costs money)
[react-router](https://github.com/rackt/react-router)
Wow. JS dev here for about 2 years. This is the first time I've heard anyone discuss React, as I haven't looked into it yet. It sounds like you guys are speaking a whole new language.
I don't really see anything about the architecture on the docs that would say / show why or what exactly makes this fast...
Welcome to the resistance :)
yeah but can't you use Angular instead of Flux? i feel like this bloat is from having react+flux+angular, when angular and flux can do the same thing
Can you elaborate? Why does MVC suck?
How can I trigger a click event on some button, or any area within, a swf object?
If you frame your question around "which is more modular?" you might be able to answer your question more simply. It's not about "distributed" vs. "centralized", but about "reusable" vs. "baked in". Consider, for example, a controller that allows you to infinitely scroll through an arbitrary list of items. It may expose a method `getMore` that handles fetching more items of the same type. If you wire up this module with a route, you're effectively limiting the reusability of this module. In other words, by baking in the URL to access this controller, you're limiting its reusability. So if your goal is to have modular controllers that can be injected with an arbitrary data source, provided it implements a specific API, then your best option is to remove routing from the module.
Personally I'd rather refactor small areas of code regularly than completely rewriting an app, as many will need to when angularjs web 2.0 return of the ng-$scope - or whatever it's called - is released.
Thank you for the input. Though, this does not seem to work. This uses the same method as the question in the stackoverflow. In both cases, browser emits the events but does not act upon them. Details explained in the original question.
I would add support to all the calls to use Flux. Also separate out all your superagent calls into services that are easy to mock out for testing purposes. Use JSX even if it takes some getting used to. We have a fairly large scale react app with a django backend that we've been working on here: https://github.com/onefinestay/django-mediacat/ if you want to take a look. We have also started open sourcing some of our react components, you'll find you end up wanting to recreate things that you otherwise would have dropped a jquery plugin for.
Hi! I'm working on a new front end for my company which is written entirely in React/npm/webpack. Off the top of my head.. * Don't use state to store derived data. Instead calculate this data in ``render()`` * Isolate common functionality in mixins * Be very strict about when and where you call ``setState(..)`` and when you read from ``this.state``. This can lead to nightmare scenarios in large components where states are overwritten. * Use flux, but take your time to learn and understand the concepts and make sure your entire team has the same understanding. We skipped over this part a bit too quickly with the result that our datastores now have slightly different behavior depending on who wrote it :) * Every time you feel like doing a ``$(this.getDOMNode())`` you are probably wrong. Almost all problems can be solved much neater through React. Exceptions to this exists, like for instance doing animation. * Be strict about defining ``propTypes`` for all components. This helps other developers understand the expected behavior of your component. * Try for the love of god to use jquery as little as possible, especially jquery ui. If you thought select2 was a pain to work with, then you haven't tried trying to wrap it in a react component :)
&gt; Use flux, but take your time to learn and understand the concepts and make sure your entire team has the same understanding. We skipped over this part a bit too quickly with the result that our datastores now have slightly different behavior depending on who wrote it :) Can you elaborate on that? What are the different interpretations at work there?
Best tl;dr read I've seen in ages!
Well, that's why I removed angular. Doesn't really make sense to use Flux + Angular. It'll still be slow because of ng's dirty checking. Flux emits change when 1 little thing change, that little thing can be part of a very big object. This was my problem. React is made for this - changing 1 big and doing the diff. 
Thats not the question. I understand that window is the global scope and that "addEventListener", "setTimeout", etc. are the direct descendants. The question why there is a convention to write some of these properties with window and some without. My bet is that setTimeout (thats just one example that I chose to illustrate this topic), some time ago was not part of window scope.
There is no historic reason that I can think of. One difference though is that addEventListener() is a method which appears on a whole bunch of other objects besides the window object. I guess we are used to seeing addEventListener() used with an object in front of it. Also, setTimeout() has been around for a very long time from a time when JS was seen as something where you use little snippets of code to do small scripting things. Modern code and style is a bit more disciplined. 
The really "bad" thing is that you cannot reuse all the libraries out there created for the DOM (!). 1. create a component not touched by React in order to render them 2. try to port them. So in case of Highcharts you most likely need to do the 1rst because doing the 2nd means a lot of work which partly destroys the argument of using them to get some functionality out of the box. I have never done the second and I really can't tell how hard would this be. I guess it depends. You can check for component list already created by the community here : https://github.com/enaqx/awesome-react#components. They are not all mature but they are a good starting point (image yourself creating every single bootstrap component from scratch ....) The other thing that might affect you are javascript animations. In short * CSS transitions YES (the good news is that you can go pretty far with them and they are fast) * Javascript animations NO (by using some manual hacks maybe). Thats my point of view. I have been researching and doing sample applications with react.js for about a week, so give the appropriate weight to my words.
I've used both bower and browserify, and I must say I like browserify way more. The fact that you can write your client code using npm syntax and then reuse modules for back and front end is very valuable.
Do you mean why people write this way in articles, or code smell in particular libraries? I think the reason in libraries is that certain methods like 'setTimeout' are seen as utilities as opposed to operating on the window as a DOM object.
Why not? A bookmarklet is only a bit of javascript that is executed on click in your bookmark-list... In fact the problem might be, which image you want to have (e.g. more then one are displayed). And, why should someone click a boomark to save a image when he can do this with right click save as...
 in terms of speed, there's a link to a benchmark on the homepage if I'm not mistaken... In terms of implementation, the project is super-new so I couldn't find a lot. I'm personally planning on playing with it soon. Looks good, though. It can also use localStorage for persistance, which is what I need.
setTimeout, like parseInt, should be treated as a built-in (this way the code also works in Node etc). Things like addEventListener depend on the DOM, so it's clearer to prefix with window. 
Haha! Funny stuff; and informative. Hope to see more writing from you. 
Backwards compatibility can be nice, but it can also stifle innovation. Take the case of Java vs C#. Java was an interesting, game-changing language and C# was, frankly, little more than a copy in the beginning. However, C# ended up leaving Java in the dust because the design-by-committee mentality of the Java community placed backward compatibility above innovation and so Java stagnated. Granted, we're talking about frameworks here and not languages, but it's my opinion that if Company A wants long term stability in a framework, they should stay with the same major version branch.
Pretty cool. It might be faster to select elements by class, rather than iterating through every element and interpolating all text on the page. Also the code is (deliberately?) obfuscated and you didn't really explain what the program does.
[**@kuizinas**](https://twitter.com/kuizinas): &gt;[2014-11-05 14:15:04 UTC](https://twitter.com/kuizinas/status/530000348455665664) &gt;Fuss.js: Extended [#Facebook](https://twitter.com/search?q=%23Facebook) [#JavaScript](https://twitter.com/search?q=%23JavaScript) [#SDK](https://twitter.com/search?q=%23SDK). User auth, batch requests; represents the async ops with promises. [*github.com*](https://github.com/gajus/fuss.js) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2ld8w2%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
It should be "racked my brain", not "wrecked my brain". Even "wracked my brain" would get you a pass since it's colloquially correct but still technically wrong. http://www.dailywritingtips.com/wracking-or-racking-your-brain/
This is the best answer so far. Just calling `addEventListener` only works because "this" automatically resolves to "window" in a function that's not bound. Consider: `addEventListener === document.addEventListener // true` So basically addEventListener is a method, so it expects to operate on an object, which is generally bound by calling `&lt;someobject&gt;.addEventListener`. Functions like setTimeout aren't methods. They operate outside the scope of a specific object, and are only placed on the `window` so that they're globally available.
Damn, 17 years of learning English and I still get that one wrong every single time ...
Awww, looks like EmberJS is jealous of AngularJS. Poor babies ...
Super useful info, thanks.
So it sounds like grunt is the same as [assetic](https://github.com/kriswallsmith/assetic) in PHP.
Literally the whole point of this is that it's not a tradeoff, that you don't have to choose one over the other.
Laziness and inconsistency.
&gt;The first thing I’m compelled to point out is a fairly common false dichotomy. That of “server-rendered apps vs single-page apps”. If we want to optimize for the best possible user experience and performance, giving up one or the other is never a good idea. It would be nice to see more examples, because no app is entirely rendered on the server side or in a browser, then it looks like a point that is always true. &gt; Consider the scenario where the user navigates to http://app.com/orders/ after following a link or typing in the URL. At the time your application receives and processes the request, it already has important information about what’s going to be shown on that page. I would expect that in the case of a desktop browser the page stays the same and only the URL changes. We then just get some JSON for http://app.com/orders/ which we then render on the current page. This way we do not need to load any more JavaScript or HTML, but maybe I am missing the point being made here. A tad bit long, but looks interesting to read otherwise.
The comments note that it *is* technically correct, though. More so than "rack". To rack has multiple meanings that require context. To wrack has just one.
For a simple form, I'd recommend PHP or Ruby on Rails. If you really want JavaScript, you can use node.js as the backend (to make sure that your clients aren't writing directly to the DB)
Which ends up being the same. Browserify let you handle your front end dependency management with npm.
It definitely works, in that it triggers JS code that's listening for events. It doesn't perfectly emulate the user (in terms of hiding chrome) and I doubt that's possible.
By the way, is it possible to stop interval when browser/tab lose focus, and start it up again when the browser/tab gets focus back?
In the second code block, shouldn't this: &gt; socket.emit('cpu', update()); be this: &gt; socket.emit('cpu', update); if you're passing a callback function?
Yes, it probably should.
Yes and no. If you wrap the callback function in requestAnimationFrame, the browser will batch those calls until focus comes back. At least that's what seems to happen in Canary Chrome.
Don't forget [canvasquery](http://canvasquery.com/). Edit: or just make your own engine from scratch: http://vimeo.com/105955605
I didn't go too far with either of them, but I found pixi.js to be much easier to work with than easel
I'd like to add something to the last point about closures, because I feel like it's something very few people seem to realize. The arguments you call the constructor with are also accessible in the scope of any inner methods, without any additional variables. __example:__ function myConstructor(a,b,c){ Object.defineProperty(this,"sum",{ get:function(){ return a+b+c;} }); this.log = function(){ console.log(a,b,c); } } 
React really doesn't have many react-specific terms. component: a parent html element and all it's children (it's children may also be components). This actually comes from the web component idea. Virtual DOM: an abstraction over the real DOM to abstract away real DOM differences and to reduce real DOM manipulation for greater performance. JSX: looks like HTML. The pre-compiler turns it into JS functions because functions and DOM calls (eg. document.createElement('div') are much faster than elem.innerHTML('&lt;div&gt;&lt;/div&gt;') like most string templates use. Flux: a data flow pattern. Datastore --&gt; component --&gt; children. To modify the datastore component --&gt; action(data) --&gt; dispatcher/datastore. Datastore then tells components again. this.state: state local to a component this.props: immutable state from parent component Flux can be used anywhere (including angular) and simply describes one-way data. The virtual DOM idea is being adopted by quite a few non-react projects. Components come from the w3c. The only things that are particularly 'new' to react are their functions and names inside their components. 
Just intercept the window 'blur' and 'focus' events and adjust your timer as needed.
Yes. That is a bit weird. The whole point of a single page application is that you don't unload and load whole new pages all the time, which leads me to: &gt; Server rendered pages are not optional That is nonsense. It doesn't matter too much if the first page takes a few seconds to load as long as the other actions that the user performs are quick. 
Okay, thanks! I'll keep that in mind for next time. 
If you want to do that for performance reasons, Chrome and Firefox throttle setInterval to 1000ms in inactive tabs so you might not need to do anything. If you truly want to completely stop the interval then do what /u/choleropteryx said.
PixiJS
Browsers we'll download multiple files concurrently. Putting everything in one request will lengthen page load times.
Well, for starters it's nice to be able to show a pretty "loading" message while all those giant concatenated files get downloaded. Additionally, depending on the size of the application, it may be preferable to load a subset of your scripts on demand with requirejs or the like (i.e. don't need the products section if all I'm doing is finding the nearest store).
This feels like the sort of thing that should ideally be handled by the browser, rather than the script author.
I've had good experiences with Phaser. It's very feature rich and quite well documented.
Related HN Comments: https://news.ycombinator.com/item?id=8562449
Only if you're using domain sharding.
Yes, caching matters a lot. When you're looking at 50k of content to download before your page renders, you've got a problem. When that's happening on every single refresh, you're going to make your application less usable. And when every script has to be loaded before DOMContentReady emits (which isn't the case with external async script inclusions) you're going to have to either leave the UI unusable until all scripts have been parsed, or run scripts as they load and deal with some potentially tricky dependency management.
Try Phaser!
Kinda odd that the author doesn't address which of those issues will be fixed by 2.x.
He's missed part of the point. Short of very bad design, this is always resolvable by reading the source code: &lt;input type="text" ng-model="obj.prop" /&gt; &lt;div ng-if="true"&gt; &lt;input type="text" ng-model="obj.prop" /&gt; &lt;/div&gt; See the `.` inside that model name? That means unless someone does really dumb things with the dependency injector, the two models will *_always_* refer to the same thing. There is no magic here--this is basic JavaScript prototypal inheritance. You have this exact same "problem" (I use the term loosely) whenever you read JavaScript code. His rant about the "magic" dependency injector is noted, well received, and being fixed. So it's a non-issue. His point about the digest loop, is just plain stupid. How *else* would you build it? Because that's *literally* what every UI framework does currently--including the browser his site is being rendered on. If he has some magic means of changing that, then please, by all means, enlighten the rest of us. That being said, the "magic number" of 2000 was never a magic number, and it was a misinterpretation, and it's also just plain wrong. And it's not relevant to today's Angular, which includes one-time bindings. And more importantly, it won't be necessary in the future with `Object.observe`. His points about the documentation describing things strangely has been an active focus of fixing. But he's missed the point, once again, on some of this: people redefine terms all the time. It's part of being a living language. And for his final point, he's once again missed the fact that this is being fixed. I'll be the first to admit that the fix seems a little clunky (requiring support for something that doesn't exist and won't exist in ES6 at this point), but frankly doing token-based injection *as a concept* is much better than the existing argument-based (ultimately string-based) injection.
Out of curiosity, what happens if you declare interval outside of io.on('connection'... Does overwriting the interval var each time have the same effect as a clearInterval? I'm on my phone, but I'll check this when I get near a computer. 
&gt; See the . inside that model name? That means unless someone does really dumb things with the dependency injector, the two models will always refer to the same thing. The point was: &gt; If you type into the first input field first, the two inputs will share the same model. If you type into the second one first, they will have distinct models. ^ That's a `wtf` moment (and the point). It's explained right here: http://stackoverflow.com/questions/14049480/what-are-the-nuances-of-scope-prototypal-prototypical-inheritance-in-angularjs/14049482#14049482 Like the author of the stackoverflow comment says, "It doesn't work the way most people expect it should work." &gt; Because that's literally what every UI framework does currently That's not really true.. React, Vue, Ractive are the ones that comes to mind that doesn't use a digest loop. I'm sure there's plenty other.. &gt; [...] people redefine terms all the time. It's part of being a living language. But that's the problem, Angular is not a language, it's a framework. But yeah, all those things are "getting" fixed... in 2.0? When is that going to be released? Will it be easy to upgrade? I've think you missed the point of this article. At the **current state** of angular, the author doesn't think Angular is a good framework, and I agree with him. "Being fixed" is not a pros, it's a cons until it's fixed, released and tested.
Wpf or any xaml stack doesn't use digest loop.
I played with phaser recently and would recommend it. It seemed very easy to use and the documentation was okay. The examples page was huge, though a lot of the code behind the examples wouldn't lead you to good coding practices.
just tried it out on the console, the intervals still exist apparently even though you only have reference to the last one. Lesson learned this morning and it's not even 9AM! try it yourself in the console... var interval = null; for (var i = 0; i &lt; 5; i++) { interval = setInterval(function (i) { console.log(i); }, 1000, i); } then do clearInterval(interval); first 4 intervals keep going while the 5th is cleared... So the statement still stands... *Always remember to clear your intervals*
Just to prove a point, here's point #1 thoroughly debunked: http://plnkr.co/edit/fR3CJCIaXE8mf8CvQGHL?p=preview
I would highly recommend ImpactJS. Built in map editor and has been in development since HTML5 first started coming around.
Also, is there a way to delay the javascript until all items have been loaded properly? I am using the AmazonJS Wordpress plugin found at: [https://wordpress.org/plugins/amazonjs/](https://wordpress.org/plugins/amazonjs/)
This isn't a specific thing to learn about JavaScript. It should be as a much larger topic about persistent processes. It's literally one tiny aspect of persistency that front-end developers seem to be lacking in terms of knowledge. Memory management is a much more valuable subject for instance, and you could apply exactly the same principle, data is persistent among sessions. If used incorrectly it could cause leaks. Node may very well reduce the barrier to entry for backend development but that's clearly isn't a good thing.
&gt; I'm sorry, but a framework is supposed to make developing easier. Anything that forces me to understand the underlying technology in depth to understand the reason my magical 2-way binding doesn't work when I edit the second input first, is pretty bad. Javascript is a language with a lot of quirks, a framework should be helping you overcome those quirks - not make you discover new ones. Then JavaScript is not the right language for you. Have you looked into one of the cross-compiled languages? There's an abundance of those these days. Also, did you even look at the plunker link I provided? It works *exactly as expected*. &gt; They don't do it with by dirty checking. Enormous difference. Care to explain how they update the actual rendered layer, if not by enumerating the things that changed and updating the relevant things? Dirty checking doesn't have to involve enumerating all the watched things to find the subset of changed things to be called as such. &gt; If you check http://facebook.github.io/react/, it says "A Javascript library for building user interfaces". It's actually just a UI framework. Maybe you could elaborate what UI means to you. Sorry, that was a half-formed thought that I was in the process of revising when I got distracted. What I was trying to say is that you need some sort of render loop, and some sort of update loop, and the update loop has to--at a minimum--look at the changed things and update their state for the render loop to pick up. The two loops can be the same (and in JavaScript land, they are). All basic rendering frameworks work this way (including Angular, though it has some deficiencies currently due to language constraints). &gt; Not sure what you want to state here. The official documentation state those terms. People define a language. People write using that language. People can change the meaning of the language. That doesn't make what they've said *wrong*, just *incongruous with other people's expectations*. They've taken the time to explain the context even. Whether or not this is a good thing, I make no judgment call. &gt; Why? The point is not if Angular can one day be a great framework. It's if Angular is a great framework now. When I build a project, I don't think "hmmm this is a crappy framework, but they're going to fix it in 2 years, so I'll choose it". Because unless you're building something that will completely disappear and you'll stop maintaining 3 months from now, future support and direction matters.
Care to explain how it updates the UI with the current state of the data model then?
It refreshes the whole page, not even comparable.
&gt; Then JavaScript is not the right language for you. Yes, it is. Angular is just not the correct framework. I've used it, backtracked, and rewrote my app in React. I've also tried Coffeescript, Typescript, and Dart. A framework is ease your life. http://en.wikipedia.org/wiki/Software_framework &gt; The designers of software frameworks aim to facilitate software development by allowing designers and programmers to devote their time to meeting software requirements rather than dealing with the more standard low-level details of providing a working system I think you should read on how angular dirty checking work.. you don't seem to understand it. https://docs.angularjs.org/guide/scope#scope-life-cycle It's a loop that checks if a variable has been modified. If you have 2000 variables in the scope that is being watched, even though you're not modifying the variables, the loop is running and checking for modification. No matter how you look at it, this is a not optimal. In angular, you do $scope.model.name = 'Michael'; And it magically changes it in the frontend. In backbone, you do model.set({ name: 'Michael' }); Backbone does this because Object.observe() is not widespread yet. Doesn't matter what the browser do, cause it has to do it. The framework is another story. &gt; Because unless you're building something that will completely disappear and you'll stop maintaining 3 months from now, future support and direction matters. Google is the worst indication, then. They've dropped so many projects already, and they don't use angular for user-facing projects. 
You can for small pages. Larger applications quickly outgrow this, and obviously it doesn't work when you need the same code on multiple pages.
Love the fragment from article found in the comments: "Google does not use Angular in production for their flag apps like Gmail or Gplus." This sentense perfect completes with opinions from discussion about 2.0, like "If I'm developing application I believe, that framework will be supported for at least 5 year from now". Using open-sourced and very fresh technology with business plan for few years, complain at authors... Come on...
Blech. Hate it.
The really unfortunate thing about 2a is that it is as close as you could get to AMD without using AMD. Imagine all of the libraries that would instantly be available to angular if only it used the AMD syntax 
 &gt;Node may very well reduce the barrier to entry for backend development but that's clearly isn't a good thing. I agree. I don't think anyone should try and help increase knowledge and understanding, everyone should praise the backend elite for their amazing knowledge and skill. I hate it when people share what they've learnt.
Because of speed and cache. CDN is most likely to be faster than your server, and have less downtime. Plus users may have the library already cached. 
The primary CDN that jQuery uses, MaxCDN, is fast, and possible more redundant than what the site otherwise have available. It might also be geo-located for faster download. If a given user happens to have the particular file cached (from another site), jQuery is now a either free or network round trip latency for a 304 response instead of downloading the payload. In practice, there is probably not enough CDN concentration for this actually matter. I read an article a while ago, and it was like ~10% of the top 500 sites using the google cdn at the time for jQuery.
&gt; Edit: or just make your own engine from scratch: http://vimeo.com/105955605 That's a great video, I've watched it a few times. But at the end she suggests using a framework for serious development and that she was only demonstrating how easy it can be. lol
OP did specify "free." Otherwise, I agree that impact is excellent.
There is enchantJs too. Witch was recommended by nintendo is i remember correctly. Good luck ! choosing is hard ! 
 arr.slice(); // is doing a job And your example isn't working because arrays are passed by reference. It's just a pointer to original array, so every change will affect both on them.
why is that odd?
If you absolutely hate some aspects of some language/framework/library, wouldn't you take a look at the roadmap? The author is apparently aware of 2.x, but they just decided to ignore it.
There is also a security stand point. Through CORS you can for example only allow code to be executed that comes from your domain (and thus is deemed safe), by disallowing inline code you can thus be sure that if any of the code you use (whether yours or not) is protected against Clientside Code Injection. 
there is no roadmap to 2.0. 2.0 is a brand new framework. totally irrelevant to an article about 1.x
The title is "AngluarJS: The bad parts" not "AngluarJS 1.x: The bad parts".
I trust your link because it's purple.
Well I would say that's the fault of the deranged developers who for some reason decided to use the same name for two separate frameworks.
Oh noes, they removed some super shitty crap. Boo fucking hoo, dude.
Not true at all. Several months ago we had a data guy, with no programming experience, that was coming to me all the time to help improve his admin interface. We had already moved our main app to angular from backbone and had not started the admin migration. I took a day and setup the base framework for the new admin app, and showed him the full app code to learn from, 3 days later he had 2 of the admin areas done. Sure he made a few mistakes, but it was all there and worked well.
Yeah they flushed one turd down the drain and are about to take a brand new shit. Doesnt mean we have to speak about both turds as if they are one.
In his defense, 2.x isn't going to be released until late 2015, maybe even 2016.
This is just troll bait. It's even written like troll bait. To be fair, the author was probably just ranting about how much he hates angular with no intent to incite a reaction. But submitted to reddit? Troll bait.
You can use innerHTML a number of different ways, each of which can potentially degrade (or enhance) overall performance. For instance, the following is **HORRIBLE AND SHOULD NEVER BE DONE**: document.getElementById("test1").innerHTML = "&lt;option&gt;1&lt;/option&gt;" ; document.getElementById("test1").innerHTML += "&lt;option&gt;2&lt;/option&gt;" ; document.getElementById("test1").innerHTML += "&lt;option&gt;3&lt;/option&gt;" ; document.getElementById("test1").innerHTML += "&lt;option&gt;4&lt;/option&gt;" ; On the other hand, this would be faster for (var i = 1, html= ""; i &lt;= 4; i++) { html += "&lt;option&gt;" + i + "&lt;/option&gt;"; } document.getElementById("test1").innerHTML = html; innerHTML is not super fast. Anytime you interact with the DOM, it's not going to be super fast. On the other hand, all things considered, it's still fast. It's faster than using document.createElement or a document fragment. Why are you being told not to use it?
This is a completely non-existent argument. All those libraries are still available.
Ha, a bit more complicated than that. Those are staying in backbone ... for now.
Huge learning curve? I was building with AngularJs after a couple of hours, don't overblow the difficulty. It's really not very hard.
My prototype was similiar to your example, in this prototype I was just using generic data so it was just a single line of html with 3-6 options, but they start out with "---" values and change based on other dropdown menus. I was told it was against company standards because the html and and javascript need to be separate. I will see if document.createElement will work tomorrow.
I have extensive experience writing backends and I have extensive experience writing frontends. What's your point?
For clarification, what does "html and javascript" need to be separate? Does that mean in-line JavaScript with HTML: &lt;a href="#" onClick="inLineCodeIsUgly()"&gt;Life Cycle Maintenance Does Not Thank You&lt;/a&gt; Or using HTML in the JavaScript? var html = "&lt;div id=blah&gt;&lt;p&gt;&lt;span&gt;&lt;b&gt;meh&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;" ; The first is generally agreed on, though not completely, as being a "bad idea". The second is ugly, and hard to read, but it's not as obtrusive as the first.
&gt; $scope.model.name = 'Michael'; It's even worse than that. You really have to do $timeout(function(){ $scope.$apply(function(){ $scope.model.name = 'Michael'; }); }); The apply is to notify angular that you need to run a new digest. The timeout is because if you try to run $apply while a digest is currently running, you get an error and nothing happens. so the timeout puts the $apply in the event queue for later. Totally hacky.
in addition to what others have said there is also the issue of hosting costs. most hosting services charge you for the amount of data transferred from your site. by loading resources such as jQuery, bootstrap, font awesome, etc from a cdn it will not count against your account.
This is why pagespeed has "Eliminate render-blocking JavaScript and CSS in above-the-fold content". What you're saying will work but you'll still be taking the brunt out the gate. Which can be fine for an desktop application but when it comes to mobile websites every millisecond counts. Even sending a large concated over the pipe. I prefer to deliver the initial. Then after the initial user gets what he needs it's really up to the build process after that. Addy Osmani talks a lot about this: https://github.com/addyosmani/above-the-fold-css-tools
The UI element binds to a property through an interface, when the property gets set, it fires an event, by which the UI gets notified, it then reevaluates the property by its accessor to get the new value. This is the basic idea, implementation detail you can look at dependency object, dependency property and binding classes. 
I like how devs are now turning douche-bro/nerd-alpha these days.
Your point about only loading what's needed is definitely a good one though.
This may not be what you are looking for, but I've always found that for simple, one-off projects like this, creating a form in Google Docs can actually be a godsend. I wasn't aware of this, but you can have the results sent to a MySQL db. https://developers.google.com/apps-script/guides/jdbc *EDIT* I should clarify that their forms do provide all the boilerplate to just copy and paste the form wherever you want to use it.
To clarify what I'm saying, I think you're thinking in a more traditional server side rendered but javascript enhanced application, where a lot of beginners make the mistake of writing javascript distributed across multiple HTML/ERB/PHP files, however I'm only delivering a single HTML file, between one and three JavaScript files and one or two css files. All data is gathered via AJAX. My build process takes the application and concatenates it into a single javascript file, and the HTML files are converted into a single JS file that loads with the application.
That's a "digest loop". And that's also not how it works. From Wikipedia: &gt; Periodically, MIL walks the tree and executes the rendering instructions in each node, thus compositing each element on to a DirectX surface, which is then rendered on screen. &gt; ... &gt; All WPF applications start with two threads: one for managing the UI and another background thread for handling rendering and repainting. http://en.wikipedia.org/wiki/Windows_Presentation_Foundation
You don't need an "else" if you return. If you hit a `return`, you exit that function. So, you can just write: if (...) { return a; } if (...) { return b; } return c; Instead of: if (...) { return a; } else if (...) { return b; } else { return c; } Try [Codecademy](http://www.codecademy.com/).
Well let's say you have a modal, and the positioning of the modal depends on its height. If it's taller than the viewport then you position it 100 px from the top of the window and then scroll. If it's shorter than the viewport the you center it vertically. You need to measure the height of the modal. And you can't measure it until it's actually in the DOM. And if angular is in charge of appending it and populating its content, then it's very hard to tell when that process is complete. edit: why downvotes?
You can find the same results when you inspect the elements (Chromium has that jQuery page at height() at 36px, Firefox at 42px). So it's got nothing to do with Math.max, or jQuery's height(), or JavaScript ... it's simply that the browsers have different rendering (perhaps due to different default CSS, different text renderers, which they're allowed to do). JavaScript isn't involved at all. 
Hahaha, that wouldn't make any sense.
I'm use the occasion to plug [/r/reactjs](http://www.reddit.com/r/reactjs). It's a ghost town over there. But with all the recent attention ReactJS is getting, it's worth mentioning.
With all the anti-Angular posts lately, I feel the resistance it's starting to grow.
No. I am thinking of strictly client side pages with AJAX data as you described. A large single page application can grow to several hundred files and a few megabytes of code. I have written several such. Putting everything in a page is only suitable for very small applications. It is a fine choice though, and easy to understand, if the application stays small. 
Phaser fan here!
the equals sign doesnt copy objects, arrays, functions or dates. only strings, numbers and booleans. I'm sure im missing a few. I think null always equals null and undefined always equals undefined.
Speaking of cheeky references to The Good Parts, anyone know how you can declare new factory objects without calling `new`? [This example](https://docs.angularjs.org/api/ngResource/service/$resource) violates The Good Parts recommendation to not call `new` and Crockford has even now recommended to not use `Object.create` either, instead using syntax along the lines of: function constructor(spec) { let { member } = spec, { other } = other_constructor(spec), method = function() { // member, other, methid, spec }; return Object.freeze({ method, other }); } Any idea how to incorporate these with Angular singletons (e.g. `factory`)?
Thanks. That makes sense. 
I'm pretty sure I made it clear above and it doesn't warrant repetition. Why didn't you write a broader scope article that explained scope within persistent applications? Which may have been somewhat useful, or why writing node apps is different from writing it in the browser. Why is your solution to clear the interval instead of having a global interval which generated the data and have all clients subscribe to that, at least that's transferable to a real world application. Why in your case does it even need socket io since you're obviously not using it in a sane way. This in itself is useless information that doesn't teach anyone about WHY this actually occurs, they'll clear their intervals and still have those memory leaks, race conditions, etc.
Not sure how far along your project is, as this kind of requires an entire framework to use, but Sencha's Ext JS may be an option: http://dev.sencha.com/ext/5.0.1/examples/executive-dashboard/index.html#!profitloss
I disagree with almost everything in this post, but there is an underlying "issue" related to 1) that the author misses. The actual problem is that Angular tries to be helpful instead of blowing up when the user screws up. It seems like Angular does this: try { $scope.obj.prop = value; } catch (e) { // User forgot obj? Lets just create it then. HAH! $scope.obj = { prop: value }; } Of course Angular doesn't actually use try/catch for this, but it has some corresponding logic that unfortunately can mask bugs.
Sounds like you might not be using Browserify in your build process. Try it out, it works with angular pretty well. (Most AMD libraries also support the CommonJS format)
thanks for the input
cool, I'll check out node.js
Great article. AngularJS just goes to show how bad javascript really is, that people are willing to go through all these pains just to organize the code in a large javascript project. I was willing to live with all of these pains, but the breaking point for me came when I was designing a complex app. There was a point when I would need to nest directives within other directives. That view ran so slow, repeated lags and screen freezing for a few seconds every time it came up. That was my final breaking point.
Why is Angular taking so much slack recently? Maybe that's the side effect of popularity. Of the 5 points only the 3rd is a real issue for me, and only for some kinds of applications. You can also check the latest version, it includes 1 way binding, very handy for teh big data tables/lists that usually generate too many bindings. But yeah, I had my fair deal of WTF moments while working with Angular these last few years... I still like it but look forward to better options.
Yeah I'm pretty sure raf works on most modern browsers. And there's shims online you can copy. 
I had about 10-12 nested directives. I was building a form generator, so you gave it a list of the form fields, their validation rules, and it generated the UI for you. It ran fine, but the initial time for rendering the UI and displaying it on screen always caused a lag / freeze. I moved to another framework and the same code runs extremely fast now.
&gt; eigth That's the best bit. It's a bit weird that they haven't uglified the code.
is that easy in any MVVM framework?
Well, firstly, serializing your content is going to negate any gains from stream parallelization. Most browsers these days will open up to six streams to download multiple resources, and for large resources (like scripts in a web application) this is going to justify the extra HTTP request overhead. It also means you can cache certain files with a different lifespan to others (like third party scripts, which you shouldn't be changing), and that you can try utilizing public CDNs for library files. You can get HTML files to cache, although this will create other problems. Like how you get users to redownload resources after an application release. You can workaround this by baking versioning into your URIs and using mod rewrites to strip them on the server. But you will still have users request re-download all content as soon as you make a release, so this is a problem if you're planning on continuous delivery. Oh, it's probably not important, but I guess it would also break any self-inspecting scripts that perform some kind of reflection. There's also a question of size. Applications like this can get big, and you're probably going to want to shard the content at some point. Between an MVC library, a set of helpers, jQuery, a visualisation library and a set of plugins, you could easily reach the 500kb mark in a couple of years if you're not careful.
Does strike me as strange. Could be it's a relatively new service and the frontend team that built it out is pretty junior? (Why a company like Amazon would put junior devs on a public product like this would be another question though)
My eyes can't stop bleeding
Cargo cult.
 var answerChoices = JSON.parse(JSON.stringify(JSON.parse(JSON.stringify(JSON.parse(JSON.stringify(JSON.parse(JSON.stringify(allQuestions)))))))); And how about now ?!
Try nodeschool.io too! You need a basic understanding of JS but the exercises are fun. 
http://www.gwtproject.org/learnmore-sdk.html
"1 obj should be defined somewhere in JS not just HTML, if for no other reason than clarity, if you do this both fields work exactly as expected." And everybody knows just how easy that would make the entire development process in a non-trivial app (you know, the one angular claims it helps develop) "3 I work on an extremely large/complex angular app with 500-2000 active bindings at any one time, and have NEVER run into any issues at all with the digest loop. It is always extremely fast, even on slow computers." The article said it's easy to exceed 2000. I did it too. Also I recommend setting breakpoints in functions and what how many times it is executed during a digest-repaint cycle. Such fun! "4 Dont be a dumbass" Do as the priest says...
In my case the management went one night into an ivory tower, looked at some articles on the internet and decided the MEAN stack is the future. Next day we got notified we should start learning angular.
Yeah, I'd just pay for impact, it's the best from what I've read.
Molecular Modeling Database..? 
I'm gonna take a stab at Ember?
The only stable, or even beta, form of Angular is version 1. You expect them to review and critique unreleased code that could be completely changed or irrelevant in a year's time?
It doesn't matter where or how SCRIPT_ROOT is defined, if it's different than the domain of the current page, it violates the [Same Origin Policy](http://en.m.wikipedia.org/wiki/Same-origin_policy). There are ways around it, which the article discusses, but for your example it's probably best to just have the snippets on the same domain as the page.
There are other issues that you have to contend with as well when relying on a third party provider of javascript (or in general content): * Each new domain will require a DNS lookup. This adds latency to the page that wouldn't be needed if the content was local to the page's domain * Each new domain will require a new http connection, not allowing for connection re-use * You are not in control of cache controls for the browser. Lets say for example you want to bundle a bunch of plugins into a single jquery.min.js (not great practice using that name, but it is feasible)... you can't reliably update this and invalidate caches * You don't have control of GZIP'ing the content. I believe the maxCDN does use GZIP'ing, but you don't control that at all * If you serve https, then you need to get the securely. Guess what, a whole multi round trip to the CDN to set up an SSL connection, and then to fetch that content - not if you serve locally. Unless you have bandwidth cost concerns, bandwidth concerns in general (like your servers can only serve over a 56kbps line), or the majority of your content is smaller than jquery itself, you're likely to be better suited for the end-users to host jquery yourself. Alternatively, as we do, have your entire front end CNAME to a CDN provider of your choice, and have your back end control cache controls to that CDN. You will have benefit of CDN (faster, cached, locally available content) for not just your jquery plugins, and full control as well.
Criticism is great. What's completely worthless is ignorant bullshit. [For example](http://www.reddit.com/r/javascript/comments/2legnd/angularjs_the_bad_parts/clu5act)
Another one which seems to mostly be "I don't agree with their architecture so I'm saying it's bad"... I had a similar idea, but writing about the bad parts that are actually bad in real projects and not because you don't agree with how they chose to do something... The one thing **I do agree with** is the first point... that has bitten me more times than it should, the others aren't much of an issue at all in practice.
Ember is surely not lighter, faster or simpler than angular. Its probably as powerful as Angular. 
I'm getting really tired of all the "why Angular is bad" articles. I've created dozens of applications based on Angular and compared to experiences with other frameworks it was a blast. Yes, Angular has its problems and pitfalls (like any framework tbh). I don't see a reason why everyone has to write their own "bad angular" list... usually making them look dumb in the process.
Wrong attribution. Its not a problem with 2-way binding. Its a problem with prototypical inheritance. 
Don't you mean taking so much "flak"?
The reasoning they gave was html and javascript need to be separate. They see html += "&lt;option&gt;" + i + "&lt;/option&gt;"; as html. The way they want me to do it is document.createElement('option');
I'm using Angular with SQL (I had no choice, anyway). But I'm pretty interested in knowing the answer as well, for future projects. But my guess is that the main killer feature of JS is that it is non-locking. Therefore, using a traditional DB would be locking? Maybe?
I assume you mean MongoDB? When using a document based database (which are fantastic) you eventually come to a point where you have to decide between duplication or reference of data you can read up on stuff like this in [50 tips for mongodb developers](http://shop.oreilly.com/product/0636920019893.do) there are many alternatives here, there is nothing inherently bad about storing some sort of reference, you just have to think in more of a REST based domain model rather than the other way around. you can use something like neo4j to store relationships and references to mongodb in there if you need something fast over larger sets of data. or postgres also has support for JSON type documents which can be used in combination with strong relational data models. so to answer your question, sure you can make a large system with other databases than an RDMS! edit: spelling
I never said it was a bug with setInterval, but a bug with my code. And I understand how it works, how they are persisted and all of that. I just forgot to clear the interval and figuring out what I forgot to do from the symptoms I could see was interesting. And I never said that timer functionality is weird. Just that once it starts messing with you it can be difficult to realise what's going on.
per the [html5boilerplate](https://github.com/h5bp/html5-boilerplate/blob/master/src/index.html), you load jQuery off the cdn first, and if that fails you load a local copy: &lt;script src="//ajax.googleapis.com/ajax/libs/jquery/{{JQUERY_VERSION}}/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt;window.jQuery || document.write('&lt;script src="js/vendor/jquery-{{JQUERY_VERSION}}.min.js"&gt;&lt;\/script&gt;')&lt;/script&gt; which means you actually do store a local copy if the remote fails. in practice, the chances of one of the major CDNs going down is very very low. that is the entire point of a cdn. if they do go down, there are bigger problems that your particular site not loading.
.net uses js and ajax to postback form data already. if you want to roll your own, then yes, you can use ajax to post data to whatever you want, as long as you have a language that can take post data.
Thanks, I wasn't aware of these.
So apparently best practices in web "engineering" for 2014 starts with PHP and WordPress. Blech, no thanks.
I can't get these to run, but I'll keep working on it later today. But to your 2nd point, yes! I would very much like some examples I can grep though. It helps to look through existing codebases or simple examples.
Protractor waits for page to load and then it looks for angular in global variable, it looks like your page wont load or you don't have angular there.
eh, I would take the "performance" section with a grain of salt: - it reeks of premature optimization - jQuery show/hide handles problems that crop up in practice [like this](https://github.com/npm-dom/dom-style/issues/6). Eschewing it in favour of `display = none` will lead to bugs and hair-ripping later down the road - jQuery show/hide might appear slower in a microbenchmark, but changing one to the other will likely make zero measurable impact on the performance of your app. It's a clear case of premature optimization that should not even be mentioned in an article about "good standards". If you are showing/hiding hundreds of thousands of elements per frame you have a much larger problem at play. - avoiding jQuery in favour of vanilla JS is often a bad idea. jQuery handles edge cases for good reason. If you want to avoid the bulk of jQuery, use [a smaller module](https://github.com/npm-dom/) to accomplish the same task without introducing the bloat and cross-browser issues that comes up with vanilla DOM manipulation
Yes, you can build it, but expect debugging to be hell. I've recently had to debug a REDIS database that produced failures interacting with code that expected a different data structure. No migration path, no proper interface to handle the contents (like a mysql manager or phpmyadmin) . Good luck with that.
Exciting demos + "The Google" made it the talk of the town. And when you're trying to figure out which of a new crop of products to use, the one that people most talk about seems the safest. I mean... you don't want to end up being that *one guy* who is sitting alone in a room asking if anyone else uses Whitebeam. 
If it isn't already the modal should be refactored into a directive. Then all of the manipulation can be handled in the [postLink](https://docs.angularjs.org/api/ng/service/$compile#post-linking-function) function on the [directive definition object](https://docs.angularjs.org/api/ng/service/$compile#comprehensive-directive-api) for the modal. Now whenever the modal's open event is triggered you can use the `element` argument which is passed to the postLink function to grab the height of the modal. You could then use the angular services `$document` and `$window` to grab the height of the viewport with h = Math.max($document[0].documentElement.clientHeight, $window.innerHeight || 0); And you could also set up a listener on resize so you can update the modal there as well. This all comes back to your first point of needing to know the tool you're using well. 
I really like Cocos2D. The API is relatively clean and easy to learn, it uses OpenGL on the backend, and can be compiled to run as an Android, iOS, Mac, Windows and Linux app. I considered Phaser but I couldn't find a practical way to guarantee good performance on Android. It needs to run in a webview and these are inconsistent between Android versions.
I've created some examples of how you can use Joola to easily visualize data: http://codepen.io/orweinberger/
Sounds like the concatenated string isn't quite what you expect it to be. Forgive me if I'm wrong, but it sounds to me you haven't discovered the full awesomeness that is the browser console. If you [enable XHR tracking](http://stackoverflow.com/questions/1820927/request-monitoring-in-chrome/3019085#3019085) you'll get lots of detail on your AJAX requests, which might let you compare them better. In terms of scaling, if you use a [load balancer](http://aws.amazon.com/elasticloadbalancing/) in front of your servers, there's no need to use multiple sub/domains.
Hey, you know that one thing that nearly every programming language does and everybody understands? Let's not do that
I think you mean non-*b*locking. If you're using a good MySQL or mongodb library then this is a moot point; both would be non-blocking. 
How could the author make reasonable assumptions about a framework version that does not yet have a clear roadmap and a year and a half to two years out. Angular 2 is vaporware at this point.
redisdesktop.com https://github.com/joeferner/redis-commander https://github.com/sasanrose/phpredmin https://redsmin.com/
Except that JavaScript's constructors and `this` work unlike any other commonly-used programming language in existence, and are the source of pretty much every new JavaScript programmer's confusion about the language and a huge class of bugs. Using closures and lexical scope on the other hand is conceptually very simple, much simpler to understand than prototypes and magical `this` variables, and just as powerful.
Hey, you know that one thing that nearly every strongly typed object oriented programming language does and everybody understands? Let's not do that in a dynamic prototypical langage. (FTFY)
I was being more than a little tongue-in-cheek, however: there is no winning strategy. There are just things corporations do to maximize shareholder value. Sometimes (maybe even most of the time) corporations play nice, sometimes they don't. I wish it wasn't this way but many years of experience has shown me otherwise. 
I see dynamic typing being useful when I'm prototyping something. I may not know the explicit structure of the objects well enough to pull that up into to a type. But outside of that, your criticisms are entirely valid and a good reason you're seeing a lot of big companies pushing their variants of adding typing to js (TypeScript, flow, AtScript, etc)
Inheritance heirarchies in statically typed languages always end up being wrong or limited at some level. One of the main advantages in dynamically typed languages is the ability to use duck typing. It would be ideal to have the compile time checking of a statically typed language and the runtime flexibility of a dynamically typed language.
Why not just use React instead of a library that uses a cumbersome syntax to poorly imitate it without any of the underlying performance or architectural benefits?
http://steve-yegge.blogspot.com/2008/05/dynamic-languages-strike-back.html edit: also, note the '2008'. Some of the things he's mentioning have happened. There is CRAZY AWESOME stuff being done in the background by your friendly neighborhood JavaScript runtime. https://www.webkit.org/blog/3362/introducing-the-webkit-ftl-jit/
[This is a pretty good paper on it](http://www.ics.uci.edu/~lopes/teaching/inf212W12/readings/rdl04meijer.pdf)
Can we PLEASE stop using the old argument, "what if someone forget to use new" to convince people to not use constructor functions. If you forget to use "new" you shouldn't be programming, or you are new enough to programming all of your code should be reviewed anyway.
I would argue for a new JavaScript programmer, understanding lexical scope is just as complicated as prototypes and "this" variables.
This is probably the best answer, in my opinion. Having an API that is decoupled from both the data storage and the front-end makes a lot of sense, especially with an SPA. It makes it easy to completely switch out either of them - or add more of both. It will save you tons of time if you need to make smartphone apps later. And if you need to scale the data storage, you can easily do so.
Excellent work, congrats. Double cheers for the terminal interface!
It kind of is without context. Which is exactly what this is.
And all that cruft is why Angular gets a rep for being overly complex.
It's like the difference between Lego and Play-Doh. Lego is good for structure, especially if you know what you are going to build. You also know that if you tell 4 people to each develop walls, doors, windows and roof for a house, the parts will fit easily in the end. With Play-Doh however, you can do much more than what can be done with Lego. Prototyping is, in my experience, much faster. But you also have to be much more organized about the way I do it or you can create a useless mess pretty quickly. Both have their uses, depending on the project and especially whether it is web-based or not. If it is, there really aren't many alternatives to JS at the moment. I think you should try playing around with Node.js and NPM. The true power of JS at the moment is the speed at which people manage to develop and share modules that abstracts away the hard parts. For instance, how quickly can you set op a webserver that replies with "Hello world"? In Node.js, you can do it in 2 minutes. It is fast for learning and prototying. Also, IDE's like WebStorm/PhpStorm make it more manageable. :)
I hate to be that guy, but a language can be strongly typed and dynamically typed. I think you mean statically typed instead of strongly typed.
thanks for the suggestion :)
I'm not arguing against you, but one annoying thing about using `new` is that it doesn't lend itself to functional programming very well: function Person(info){ this.first = info.first; this.last = info.last; } Person.prototype.fullName = function(){ return this.first + ' ' + this.last; }; var input = [{ first: 'foo', last: 'bar' }, { first: 'baz', last: 'qux' }, { first: 'hello', last: 'world' }]; // Obviously doesn't work var people = input.map(Person); // Throws an error var people = input.map(new Person); // Instead I have to create a new anonymous function var people = input.map(function(thing){ return new Person(thing) });
Because you can just make an object and start doing shit to it, without beforehand drawing a sketch (in code) of what it will look like. I am not saying this is a wise reason to like dynamic typing, necessarily.
Lot's of inheritance is generally seen as a bad thing these days because of a lack of compostability and the fact no one gets it right :) Typeclasses also give you almost the same level of flexibility as duck typing but you still get compile time safety.
Thanks for proving my point?
Use the `options` property of the `SELECT` element object to access the existing `OPTION` elements. var eSelect = document.getElementById("test1"); if (eSelect) { eSelect.options[0].value = 2; //change first option's value eSelect.options[0].textContent = "two"; //change first option's content as text } You can also `add()` or `remove()` an option from the `SELECT` element object method.
It could also be that mainly backend developers threw together a frontend.
https://projecteuler.net/ you can do the solutions in JS, I do them every once and awhile for practice. It won't help with DOM api or JS architecture but it is still fun to do.
I've been programming JavaScript professionally for more than 12 years and `new` is awesome.
This. There is some decent criticism in there (for which there are counter-arguments, of course), but he wrapped it with 'why angular sucks' in order to attract pageviews. Whether his criticisms are correct or not, I disapprove of his strategy/the effect of his writing style, and make sure to downvote it everywhere I see it :D
The idea of delaying instantion/use of new as much as is possible and is not a new idea (the author cites the gof book here where many patterns like DI/IOC, factories, abstract factories are based around this concept and these are prevelant in class based languages as well). You do not want to couple your code to the creation or instantiation of its dependencies. Javascript has first class functions and therefore we can delay the use of new until the end of time: It's not required to create a Javascript object. That's really the crux of the argument, but the argument isn't new or even specific to Javascript, the context is just slightly different. 
Did you respond to the wrong comment? Not sure what selectors and models have to do with this. I said "modal" not "model." And yes I know there is a solution. I've found the solution and it was a pain in the ass which is why I used it as an example.
Ugh. What is it with developers and throwing around the phrase 'cargo cult'? I don't understand all the physiology behind my doctors prescriptions, but I have reason to believe him. Does that mean I'm subscribing to a 'cargo cult'? Based on evidence, and peer reviews, I have reason to believe that the angular devs have made good design decisions---even though I don't understand all of them. Wikipedia on Cargo Cult: The name derives from the belief that various ritualistic acts will lead to a bestowing of material wealth ("cargo"). If devs use ritualistic acts to choose their technology, their lives are going to suck. Some may do that, but their lives are going to suck whether they use backbone, or ember, or jQuery or mootools. However, many people actively research their technology decisions to accomplish their business objectives: don't group those two together. In many cases (not all!) when people use the phrase 'cargo cult', I think use of the term follows ritualistic practices of repurposing experienced language in the hopes of achieving a desired goal of portraying a message. Language is fun! 
 // Instead I have to create a new anonymous function Mm hmm.
What a shitty comment -- this post makes good points that are worthy of consideration. "Troll bait", get the fuck outta here.
Yes, thank you that is the issue thread I was looking for but I couldnt find it. When I first read that, it was the beginning end of angular for me. In particular this quote: &gt;I agree that some jQuery plugins may be hard to integrate, but those are usually the ones that do not have a clear separation of concerns. Those plugins are typically best rewritten anyway, as they are typically not performant nor maintainable in the long run. I've encountered this kind of attitude a few times from angular contributors and it's a big turnoff for me. "Angular cannot fail. It can only be failed."
It's not just that no one gets it right, I'm convinced that it is not possible to get it right with standard object inheritance.
Also plv8 is wonderful in postgres - it lets you use javascript as language in postgres functions.
the horror
What you described is the render loop. What I said is about how ui elements get updated information from their logical representation. To achieve this, angularjs use digest loop, it has nothing to do with Dom rendering. Wpf uses event on the other hand. 
Thanks for those two links - awesome stuff!
[This](http://teropa.info/blog/2014/10/24/how-ive-improved-my-angular-apps-by-banning-ng-controller.html) post actually address the scoping issue, by banning ng-controller. Suddenly controllers is nicely decoupled by using the good parts of angular. What I don't like about angular except for the scoping is the auto magic in the DI system. Name my provider 'greet' but I have to inject 'greetProvider', WTF?!?! And then there's the fact that they had to reinvent modules.
Nothing I hate more than misspelled words in code, especially since all good IDEs tell you when a word is spelled wrong.
This is not even remotely OK
Check out [Ember.js](http://emberjs.com/)
There is no reason to avoid new if you need to create instances of objects that carry their own state and have methods and such. If you only need a simple map (eg. you want to represent coordinates like {x: 1, y: 2} without any methods), just using a literal directly or a factory can be faster, but the difference is unlikely to impact most applications anyway. I wouldn't worry about it.
Glad it worked out. Good luck with your project!
Use `.one()` which has a very similar method signature to `.on()` or any of it's shortcuts (`.keydown()`). It will only trigger an event once, rather than each time. If you need to only unbind the event in specific circumstances, you can do something like: $(".thing").on("keydown", function(){ if( thisMeetsRequirements() ){ $(this).unbind("keydown); ... other logic } })
Not sure what you are doing but you would need to set a flag on keydown and unset it on keyup. If there is something that has to happen multiple times while they key is pressed you prob gotta look at a timeout or interval to check the flag.
I won't be ditching Angular in the immediate future, but I've been [trying](https://www.discovermeteor.com/) out [meteor](https://www.meteor.com/) - it's pretty cool!
I missed this news... can you explain?
no, backbone is lame. Like you said-it starts at the bare minimum and it doesn't help you at all when building any kind of web app.
The idea of "constructors", "instances" and "methods" is more of an analogy in JavaScript, because there are no such things. Instances are objects, where constructors and methods are functions, which in turn are objects too. Note that `this` in JavaScript has no relationship to these classical concepts at all, as it is just one more implicit argument of *any* function, and its value is determined by the caller. Generally I think of `new` as more of a hack to make the language look familiar, but given `Object.create` there is nothing that `new` offers that makes it a better choice in my opinion, as `new Person('Jon', 32)` is no better than `Person.new('Jon', 32)`, because the later has the additional benefit of being composable, and none of the drawbacks. Another argument is that `new` performs too much magic: first it creates a new object inheriting from Object, it sets the [[Prototype]] that points to the `prototype` of the constructor, it calls the constructor with the given arguments, and with `this` set to the newly created object; all of this unless the function returns some other object, like, another function. The semantics of `Object.create` are much simpler, it just creates a new object with the specified prototype. In ES6 they introduce syntax for `class`, which I'm not sure adds anything of real value, but it sure does improve readability and makes the intent much clearer, although the semantics underneath are still the same.
Your `createFoo` example makes the constructor logic non-reusable. The benefit of `new` is that it does the equivalent of creating `foo` behind the scenes, then decides what to give you back based on the return value (if any) from having called `Foo.apply(foo, arguments)` so the constructor function itself doesn't need to know the details of the first and last line of what `createFoo` does. How do you handle reusing constructor logic without `new`, and without just manually doing what `new` would have done for you?
I'm not trying to be difficult here, but I don't get the point of your first example. The end result of `Object.create()` appears exactly the same as that of `new` (`foo` refers to a new instance of the object in question, yes?) only with more limited browser support. I do like the ease of extension, however
Just started using Ractive in my work, but it's not really a whole app framework. Consider not using one of those!
why is there so much hate in regard to 2.0? i've heard some people use python 2.x to 3.x as an analogy but I expected major changes in Angular as it is a major release. 
Can confirm, migrated a large app from backbone to angular recently. Angular is sooo much easier to work with.
I don't think backbone is "lame" at all. Having the ability to pick and choose what you want vs the prescriptive "one true path" approach of a heavier framework like Ember is sometimes ideal. Convention over configuration makes sense if you're building a conventional (read: vanilla Rails-esque CRUD) app, but if you're not, you'll spend more time with it in your way than helping you out. 
False, it's been confirmed that there will be a transition process, it's just too earlier in the 2.0 development to say what that process will be.
Marionette — a perfect, solid framework on top of Backbone that doesn't give you any shit. Backbone might be the least lame framework out there. Lightweight, snappy, flexible, extensible, powerful. It's only lame if you're a developer that can't structure and architect things well, and that comes with experience.
ReactJS + Flux is definitely a good next step from AngularJS. Also, it allows for server-side rendering which is definitely a plus!
I've finished a couple of projects using ractive as well. I kind of like that it's not *-everything including the kitchen sink plus a box of weird bits we just glued on because we can-*. 
http://angularjs.blogspot.com/2014/10/ng-europe-angular-13-and-beyond.html
Just have your module export a "create" function which calls the constructor with new internally, and export the real constructor as a property. Then consumers can get to it if they really need to. Mostly I don't think this should be so controversial. "It doesn't compose!" ok so write a one-line function that does, and give us all a break
Backbone + require + marionette?? Edit: plusses - lots of plusses
Angular 2.0 will be written in AtScript (an ES6 **superset** Google has been working on). This was announced at the AngularJS conference in Europe last month. Check it out: http://youtu.be/lGdnh8QSPPk
What do you mean it doesn't help? It provides structure around your restful APIs and allows you to route to views. If that is all you need then great. If you need more then get a layout manager extension or model/view binding extensions or validation extensions. Backbone is as big or small as you need it to be.
By the way, most of what i've seen is less annoyed by AtScript and more annoyed by the huge architectural changes.
There are a few techniques: * Long polling: The client opens a connection to the server and the server doesn't response (holds the connection open) until it has data. Once data is sent the connection closes, the client then opens another connection and waits for data. * Flash: Uses a flash messaging server for push events. * Websockets: The best way. Provides a duplex connection whereby the server can push events without any voodoo or hacks. [Socket.io](http://socket.io/) is probably the most commonly used server for achieving this. There's also [sockjs](https://github.com/sockjs/sockjs-node), which operates at a lower level compared to socket.io. Finally, there's [primus](https://github.com/primus/primus), which provides an abstraction library so that you can swap out the underlying websocket (socket.io, sockjs, etc) implementation as you desire.
Despite all the hate over the angular 2 announcement, I would still consider angular. They've already said there will be a transition process from 1.x to 2, do don't worry about that. As for the JS, it is really javascript, not some bastardization as most people seem to be claiming. Angular does have a bit of a learning curve, but that's more around the terminology and when to use the different types of objects (provider vs factory vs service), than writing the actual functional code. Once you get past the terminology barrier, you'll be surprised by how fast you can iterate and refactor.
Mostly it comes down to style. Here's some reasons you might want to avoid it: 1. It's an implementation detail that end-users shouldn't *need* to know about to use your API. 2. Optional new makes for cleaner require statements in Node/CommonJS/browserify/etc. 3. At a later point, your modules can safely change into simple functions without drastic code changes being necessary. e.g. var Parser = require('foobar-parser') var p = new Parser({ ... }) versus: var p = require('foobar-parser')({ ... }) For example, [gl-vao](https://github.com/stackgl/gl-vao/blob/05cce0f96ee4c14b40f4a8d497fd3bd4c96744b7/vao.js#L7) uses `new` internally but exports a simple function. You can imagine how enforcing `new` would have broken everybody's code if the module originally started as a constructor, and then changed to a function to support the GL2 optimizations. P.S. One way to produce "new agnostic" constructors: function Foo(opt) { if (!(this instanceof Foo)) return new Foo(opt) //.... opt = opt||{} }
It's possible to run a websocket server using node and have the php app behave as a client and just push messages into the websocket server.
&gt; The idea of "constructors", "instances" and "methods" is more of an analogy in JavaScript This is false and a really confusing viewpoint. All of these are referred to by name in the specification for the language itself. Hard to argue that the specification is drawing "analogies", it's about as concrete as you can get. &gt; but given Object.create there is nothing that new offers that makes it a better choice in my opinion I respect opinions and all that but this one isn't rational. instanceOf operator is one example of a feature that is commonly used and difficult to get working without using the constructor pattern. In ES6, try subclassing an Array or Date and see how far you get with Object.create (hint: not far). &gt; which I'm not sure adds anything of real value, but it sure does improve readability and makes the intent much clearer Ignoring the fact that improving readability and expressiveness are certainly real value, classes do other things too. Static side inheritance. Protocol for subclassing Arrays, DOM Elements, and other builtins. Static super keyword for super calls. Probably more I'm forgetting. Eventually there will be support for annotations, possibly accessibility modifiers, and more.
So if I provide, say, an `add` method in my api, it doesn't really matter?
Saw it coming, try [React](http://facebook.github.io/react/) or [Ember](http://emberjs.com/), maybe [Meteor](https://www.meteor.com/).
&gt; "It doesn't compose!" ok so write a one-line function that does, and give us all a break. This is more important to me than you seem to imply. It affects your whole workflow, because now you are relying on constructors, and `instanceof` which doesn't compose either; and `var self=this`, and `.bind(this)`... You end up with a bunch of these one-liner helpers if you go that route. With the `Object.create` approach you create objects as interfaces, instances as records, and you check with `isPrototypeOf`, which composes. Records only have properties, and interfaces only have functions, and are usually polymorphic, in an ad-hoc manner. Any other transformation is expressed as a function from record to record, or from record to final value, as in a fold for example. Interfaces and records are also analogies, you can represent them however you want, but I think they make for more composable code.
I completely agree. I spent so much time trying to shove an analytics application (time series, graphs, tables, etc) into Ember before giving up and moving on to Backbone/Marionette. Ember, Knockout, and their ilk make a lot of sense for many web applications, but the further you veer from a 'conventional' application, the more trouble you're going to have. Conversely, you may end up getting started slower and/or writing more code with Backbone + Marionette, but I'm having trouble thinking of a situation where they wouldn't be a solid choice.
You're right, the end result is exactly the same, but how it is accomplished is more explicit. You also do not have a weird `Foo` function that is halfway between a constructor and a factory method, and behaves differently whether it is called with `new` or not. Instead you have just a `createFoo` function -- a function like any other. Browser support is becoming a non-issue -- 96% of browsers support ES5 and there are polyfills. 
Yes, meteor. Just launched 1.0, and today is officially meteor day. There may be a meet up near you. http://meteorday.com/ I've been playing with it for about a year now, it's just amazing. Quick, responsive, easy to learn. Yeah, just all around great.
Wow is this becoming the average post on AngularJS on reddit now? "Angular is shit what else is there - Try react/ember/backbone" - Seriously just have a look at all of the frameworks and choose the one that suits your requirements. How can you know if Angular is really that bad if you never tried it yourself and most importantly - how do you know the others are any better? React just had an API change in 0.12 meaning you need to migrate your code. Angular 2 will come out in 2016 and until then there will be a new team *dedicated* to Angular 1.x and there *will* be new features in 1.x and **there will also be a migration path to Angular 2!** Google uses Angular in 1600 of their apps do you think they're gonna break their own products? - Sorry but this mass of rants on Angular is really tiring. JavaScript has shit parts too, so does PHP but they're still successful languages. Amen.
AtScript is a *superset* of TypeScript not a subset of ES6. And you will still be able to write your apps in ES5 though it's not the recommended way.
&gt;the prospect of having to learn and deal with a new JavaScript-but not-actually-JavaScript language is extremely unappealing You can use JavaScript, AtScript, or Dart. You can of course also use TypeScript, CoffeeScript, or any other language which interacts seamlessly with JavaScript. You only have to use AtScript if you want to contribute to the 2.x branch.
This point isn't really about static vs dynamic typing, but nominative vs structural typing. In nominative type systems (e.g. Java, C++, C#, etc.) types are equal if they have the same name (or are subtypes if their names are declared as subtypes of each other). In a structural type system (e.g. most dynamically-typed languages, OCaml's objects, Go's interfaces etc.) types are equal if they have the same structure (or are subtypes if one's structure subsumes the other's). Duck-typing is a name for structural typing in a dynamically-typed language, but structural typing is perfectly possible in a statically-typed language. For example this OCaml function: let area sq = sq#width * sq#width will work on any object that has a `width` method of type `int`, regardless of what class was used to create the object. For more examples, see the [objects chapter](https://realworldocaml.org/v1/en/html/objects.html#object-polymorphism) in Real World OCaml.
&gt; When using a document based database (which are fantastic) Why? I've worked with them on a few projects and they always caused some pain (no joins =&gt; data duplication necessary for decent performance =&gt; easy update logic/data consistency goes right out of the window; you also have to think much harder in order to find a decent schema which doesn't suck for querying). I'm convinced storing data normalized and adding caches (e.g. views) on top of that is the way to go if you want to get things done.
&gt; This is false and a really confusing viewpoint. All of these are referred to by name in the specification for the language itself. Hard to argue that the specification is drawing "analogies", it's about as concrete as you can get. How are those things exclusive? I'd say it is a concrete analogy. &gt; I respect opinions and all that but this one isn't rational. instanceOf operator is one example of a feature that is commonly used and difficult to get working without using the constructor pattern If you're not using the constructor pattern you'd use `isPrototypeOf` &gt; Static side inheritance. Protocol for subclassing Arrays, DOM Elements, and other builtins. [...] I understand you point, and I can see how those can be nice features for some, but I don't think it will be of any use in my projects. I already have DOM abstractions in place, and I wouldn't be extending native objects like Array. In terms of "classical inheritance" we have a bunch of libraries out there with non-optimal APIs, that's why I think the new syntax will help, at least with unification, and best practices in the long run. On your last point, I'd rather have contracts as values, than annotations tied to classes.
All frameworks will have similar pains as they align themselves with ES6.
MithrilJS I've been porting an app from AngularJS to MithrilJS and I've become a better Javascript programmer as a result. Mithril is mostly pure JS and it is wonderful. I was almost going to go try Ember, but I'm really glad I went with Mithril instead. http://lhorie.github.io/mithril/ Even if you don't use Mithril I recommend reading the blog, lots of learning to be had. http://lhorie.github.io/mithril-blog/ Here is a comparison with other frameworks. http://lhorie.github.io/mithril/comparison.html And here is a lessons learned from Angular blog post. http://lhorie.github.io/mithril-blog/lessons-learned-from-angular.html Mithril is also on http://todomvc.com/ which gives you a way to see lots of JS MVC frameworks. 
Hmm not sure what you mean? Adding an add method doesn't really have much to do with new or constructors 
I completely concur. I'm actually really excited for Angular 2.0 since it will be working in a lot more of the new web standards like web components, as well as getting big performance boosts by using native object methods like .observe() mostly I'm interested to see how they solve DI as that's a big of a hairy zone currently (eww hairy zone is not a goo mental picture). Angular is not the super prescriptive thing that so many people make it out to be. There are tons of different ways to build an angular app. It still allows you a ton of flexibility to build what you need. It just makes it easier to design well, and separate concerns in a comprehensible way. I get it and I'm just a graphic designer for fucks sake.
&gt; How those things exclusive? I'd say it is a concrete analogy. You're arguing (English language) semantics. Put it this way: constructors are as much an analogy as variables or scope or anything else mentioned in the spec. Why not just say JS has those things? Clearly it does, they are specified. It doesn't help newbies to obfuscate this fact in a bunch of hand waving about "analogies".
&gt; You expect them to review and critique unreleased code that could be completely changed or irrelevant in a year's time? No, I just expect those things to be mentioned, because that's the kind of thing you do in that kind of article. You criticize some detail and if you're aware that they are trying to address that in the future, you mention that. E.g. if you think that the prongs of some gamepad are somewhat unergonomic, you'd point that out. However, if you're aware that the next iteration, which you tried at some conference, addresses this fault, you'd point that out, too. If you have the information, you share it. That's why your readers read your article. They want the information you have.
I totally misunderstood this so thanks for pointing that out!
Yuu say creating `foo` behind the ecenes is a benefit, I see it as an unnecessary complication. Im from the "explicit is better than implicit" school of thought. If you really did have complicated constructor logic you wanted to reuse, you could define a `constructor` method on your `fooProto`, and then call it right after `Object.create`: var fooProto = { constructor: function (a, b) { this.a = a; this.b = b; } //... } function createFoo(a, b) { var foo = Object.create(fooProto); fooProto.constructor.apply(foo, arguments); return foo; } //... barProto = Object.create(fooProto); barProto.confrobulate = function () { //.. function createBar(a, b) { var bar = Object.create(barProto); fooProto.constructor.apply(bar, arguments); return bar; } But honestly, if I find myself needing to reuse constructor logic it's usually a sign I'm building too complicated of an object model. Just writing the above felt ugly. Using `new` wouldn't make it that much cleaner. I rarely find myself trying to emulate classical enheritance -- more trouble than it is worth. Read [Javascript Spessore](https://leanpub.com/javascript-spessore/read) if you want to know how to create meaningful meta-objects and create useful class-like structures with real encapsulation. It's pretty thick, but provides some solid recipes. Another one of my take-aways from the book was, "holy crap, doing classes right in JS is complicated".
I used this: http://ape-project.org with great success for a Facebook/Adidas application
There is so much stupidity in this article, I have to remind myself that there are some losers in this world that make their living by writing provocative, unintelligent blog posts hoping that they get recognized for a brief instant in time so they can cash in on some Ad Sense money. Philip O'Toole, you are a tool.
god forbid you should design your own architecture to suit your app's functionality
I love ractive and have been using it here and there ever since it was called 'Anglebars'. The way it worked immediately made sense for me and I wish everything was that simple.
jQuery + singletons + (CoffeeScript = easy classes) + good packager (as Rails default setup with Sprockets) is all you really need, for any application. FB React without bullsit templating can be write in few lines on JS, Angular si slow on big projects.
As someone stated below, I had a complete of a misunderstanding in that I thought the use of AtScript was 100% necessary when using Angular but it turns out it's just being developed in AtScript. So I guess I'm totally fine with Angular again? Not sure if that's other people's reasoning.
It effectively shouldn't even be called Angular. It's "Google's Second Web Framework," but they're making enough breaking changes that it's a little disingenuous to still call it Angular.
If you have to ask, you aren't intelligent enough to understand the answer.
Backbone is solid. I've been playing around with adding Marionette to Backbone to get a bit more "batteries included" stuff than Backbone alone provides.
The resistance stack: no monolithic framework but modular components that do one thing well. Npm has all the utilities one needs and with browserify you can use them from the browser. 
To copy an array, all you need to do is call slice, like it's been mentioned. var answerChoices = allQuestions.slice(0); This creates a clone of the original array, remember that it will keep any references if there's objects within the array. If you want to add a native copy function do this: Array.prototype.copy = function() { return this.slice(0); }; to use it var answerChoices = allQuestions.copy();
Good lord, why do people think it is ok to respond to a thoughtfully-written piece like this? Stop this.
Wait when did they announce a transition process from 1.x to 2? Thats the reason I personally have been looking elsewhere (currently knockout)
Like what? Like if you don't understand angular and you [construct a broken model because you don't understand it](http://jsfiddle.net/1op3L9yo/) then angular sucks and doesn't deserve to be used? Because I don't count that as a good point that is worthy of consideration. I sympathize with him. Angular is hard and can be frustrating and *does* have bad parts. Using prototypical inheritance in $scope? Personally, *I think that was a bad idea*. But this post doesn't deserve to be called "AngularJS: the bad parts". It nowhere *near* has the merit that the allusion tries to give it. *He's just complaining*. It's not a rational or careful discussion of the problems of AngularJS 1.x, it's someone who had trouble figuring out how to use a hard framework complaining about getting it wrong. That's my take on it. So what good points that are worthy of consideration are you talking about, _crewcut? I'm happy to consider them. Let's talk about them. Let's consider them. But the style of the post, posting it on reddit.... together, I call that troll bait. 
That's my major issue with Meteor. It looks super cool, I love how you only have to write your biz logic in one place, but I'd have to do a lot more research to write something long-term, large scale, or enterprisey with it. If I ever did, I'd probable employ and adjacent service layer outside of meteor in pure JS that handles the business logic and manages validations. I'd want to be easily able to decouple from my client at any time. Meteor goes Kaputz in 3 years, I don't want to have to reinvent the wheel. 
Came here to say this. Its lack of strong opinions lets me easily add things in like react
heh was wondering the same thing, I've seen a couple of things like this.. Since TJ "the totally real person" went to GO I wondered when/if other people would attack node and follow. 
It hasn't been "officially" announced, just the devs saying the would. They won't announce anything official until 2.0 is farther along and they know what that update process would actually need to do.
I love/hate reading blog posts like this. I love it because it's thought-out, compares NodeJS to other platforms, and is unprovocative. The author praises Node/JavaScript's good points while calmly pointing out the bad stuff. I hate it because it raises difficult questions about the amount of time I spend in JavaScript, a language I have come to love writing so very much. The bit about debugging really gets me, though. I've done plenty of debugging in JavaScript and Node and I have tried quite a few solutions, but it's still an issue. I often end up resorting to console.logs. I guess I should just stick with one of those solutions. Anyway, if after reading his post you are interested in trying Go, it's a good language, pretty easy to pick up the basics and there's a great tour on the Golang site: http://tour.golang.org/#1
Time constraints, especially for startups. If another product allows you to go to market one month faster you do it. 
Any reason why breakpointing in Webstorm or some similar IDE isn't a valid solution for debugging? 
Just when I finally was going to commit to a JS framework (I'm a backend developer) I spend a lot of time making my mind on which one to pick.
Angular is mainstream now so people looking for the next big thing.
&gt; As for the JS, it is really javascript... It's not. AtScript is a superset of TypeScript. But it's optional.
I'd like some help here understanding where some of this is coming from. For example, everything you mentioned can be broken apart as separate pieces of a meteor app, just like any other app. You would just instead of pulling your data from a ruby project, you'd be pulling it from a meteor/node project. Meteor's landing page specifically makes mention to using Firebase and Angular along with meteor. You make it out to be this monolithic thing that it's not. It's essentially Rails for Node, or at least, that's how I process it. /u/foobarbazq had a good comment on scaling the other day. [You can read that here](http://www.reddit.com/r/javascript/comments/2kynlz/i_use_angularjs_im_reading_lately_about_react/clqaiw6). Below your comment is someone asking about how it would handle enterprise, yet the pathway meteor is taking for Galaxy (its hosting platform) is made specifically for enterprise development. How can one thing have so much misinformation? Where is it coming from?
Your thoughts on how you'd do that today are exactly right. In the future, Galaxy will exist specifically for that function. It's a young framework, it'll certainly grow in some good ways.
Oh god yes, they finally redesigned the site. Their old website was so fucking ugly it made the actual framework seem bad.
Maybe he or she is tired of such blog posts. Every day there are at least one or two similar posts with little to no value in them. I think this should stop.
Well, they did officially announce (on the Angular blog) that there would be a migration process, just not what it would involve.
Isn't every language/framework just a stopgap (on the path to skynet)?
Epoxy is useful for those simple two way binding use cases you might run into in your code. http://blog.salsify.com/engineering/data-binding-in-backbone-with-epoxy
If you liked that, I'd also recommend trying browserify(1), component(1) or duojs. I haven't used bower(1) but I hear it's decent too. 
I have had great success with [composer.js](http://lyonbros.github.io/composer.js) (large disclaimer: I built it). It abstracts a lot away that backbone doesn't (filtered collections, list controllers, subcontroller tracking, bare class system, extending controller event appending, etc) while still taking an extremely hands-off approach to letting you build your app how you choose. It was originally designed to be "backbone for mootools" but since v1.0 now works seamlessly with jQuery as well. Most of the concepts are exactly the same as they are in backbone, so anyone familiar can jump right in. 
Thoughtfully written or not, it's posted in /r/javascript and it is bashing javascript and promoting GO. Why shouldn't it be called out? A lot of what the author wrote is disingenuous and anecdotal. undefined = 42? Nobody does that, it's not a real concern. "Why doesn’t 1 empty array plus another empty array equal an empty array? It does in Python." Well no shit, javascript isn't Python, and I'm happy it isn't. These are non-issues. Nobody adds two empty arrays together, the example is an asinine attempt to discredit javascript. Negativity has a place when the alternative is saying nothing at all and letting articles like this get a free pass. I have to upvote discord013 for providing a cynical point of view, because there is way too much dopey positivity going around the webdev echo chamber. Positivity is great when it's warranted, but not everything is deserving of it. Always-positive all-the-time is just annoying and unrealistic. 
has he not heard of node-debug? Its a bit slow. but its a great debugger...imagine using the chrome debugger, only its a website instead. It still does need work, but I'd never use a console.log instead of using that. Also the nodejs ecosystem is HUGE. There is a library for literally everything. The community is really eating it up. On top of that there are people who are looking to port it to java (just like JRuby) http://nodyn.io/ lets not forget others who are trying to imporove its multicore use: http://jxcore.com/home/ its currently in beta. If it is fully compatible with nodejs and goes open source, nodejs will be wiped off the map. 
&gt; TJ "the totally real person" Not being a single/real person would change what exactly? If you want that tabloid-ish bullshit in your life, you should probably look elsewhere.
yup, using bower with grunt
For a more slimmed-down collection: https://github.com/facebook/react/wiki/Complementary-Tools
Why is it that people have forgotten about Dojo? Dojo has been around a long time, before jQuery even. RequireJS came from parts of Dojo. It has DOM manipulation, charting, templating with 2 way data binding, models, controllers, and much more. It's a fantastic toolset that I feel is overlooked by the new kids on the block. Nothing backbone or ember is doing is revolutionary. Dojo did it before them. Please check out the Dojo Toolkit.
Yep, and I mostly work on consumer based applications, no more than 5k users at any one time. Pretty safe for me to experiment. And like I said, I just really really like this framework. Front-end dev time is just almost not existent.
Quick, downvote this guy. He might know something!
I really like Angular 1.3. I've built non-trivial stuff in it and I think it's clever and helps me be productive. I'll keep using it for the foreseeable future. I've looked into the plans and big architecture changes for 2.0, and I think it looks really promising! I'm excited to try out a beta version of it one day.... but I'll be using 1.3 in the meantime. It's still the best Javascript framework for making SPAs, in my opinion. React, Polymer, and web component-y stuff like it look promising as well, but they seem to solve only a subset of the problems that Angular solves. Front-end frameworks are going to be going through a lot of churn over the next couple of years. Nothing is forever - especially in web development. Just use what solves your problem today.
Can you access the site at http://localhost:3000 manually? This setting should match whatever local host and port number tomcat is running your site under.
Are you trying to replace any and all parameters with `?ref=1`? If so, just set the `.search` property of the link to `?ref=1`.
I've got to give some mad props to breeze.js as my model-on-the-client provider of choice. It enables a very clean and dry unit-of-work style generic validation of large node graphs and exposes a single 'saveChanges' to commit it all. It's great to be able to code 'adding' the same way you code 'updating' - no worrying about assigning new primary key ids to the foreign key fields of other objects - it happens transparently. Its also good that it can expose the model properties as knockout or angular observables. Adding knockout validation - and adding rules per property from the breeze model metadata - you get nice granular validation across the whole structure for free practically. Also for free you get 'disconnection' protection. The model changes will be committed to the localStorage by breeze and can be synced when reconnection occurs.
I think you missed the point. The personal life of some developer is entirely irrelevant.
Document databases are great for development but bad for production.
Completely agree.
I think Marionette and Backbone do a lot of things well, but perfect is a bit of a stretch. There are plenty of reasons to use a more modern framework. Two main things come to mind. * models do not natively support nested data structures If I want a simple nested object as a model: { name: { first: 'John', last: 'Doe' }, occupation: 'developer' } I need a Backbone plugin to handle it. The idea that a model can't handle a simple POJSO is pretty ridiculous. And what's worse is most of the plugins handle it with strings. this.model.get('name.first') There goes all of my IDE hints/usages/definition lookup. * displaying a select element with dynamic data takes a lot of boilerplate I have a model with people in it, just a first name and occupation. I want a series of divs with the names to console.log the occupation when I click on it. Easy, just need to: 1. create a model for a person, call it PersonModel. 2. create a view (the div) for the PersonModel, call it PersonView, attach click functionality 3. create a collection to manage the models, call it PeopleCollection 4. create a collection view to render it all, call it PeopleCollectionView 
I really think this is the best answer. There will never be a perfect framework so you can just hack the most relevant features together using npm. I find the documentation of these small components is often really simple. Any problems and there's no waiting for the next release of the entire framework, you simply throw up an issue, the authors fix it, push it and then **bam** it's on npm for everyone else and no other components have been disturbed. If you find you don't like the templating language or error handling, you don't have to rethink the entire project, you just hot-swap the component for another and you're on your way again.
&gt; an ES6 subset Google has been working on Superset or subset? A subset would be like... JS The Good Parts... not really a new language, just a style guide.
I'd just override Model.Parse and add a one-liner to automatically embed a new child model. It's pretty simple: parse: (data) -&gt; data = Backbone.Model::parse.apply @, arguments data.embeddedModel = new EmbeddedModel(data.embeddedModel) return data If you've got a collection of models and you want to render them, I think it makes sense to use a CollectionView and series of ItemViews. If the models change, or you add an item to the collection, Marionette will re-render the list. Keeping everything as an ItemView allows you to plan for the future. Part of me understands your point — you want to do something really simple like iterate through a list and show some content. Great... you can probably do that with template helpers and a loop in your template from a standard ItemView. But here's the thing; at some point in the future the scope of these views more than likely *will* change. A collectionview and itemview is a little verbose, but the verbosity adds a ton of flexibility. You're right. It's probably not perfect, but it's far better and more flexible than other frameworks I've used.
it was originally for cleaning youtube videos of parameters (like list, annotation_id, etc) by replacing them with nothing, I modified it to replace them with &amp;rel=1, but that does not do anything when it is already a "clean" link. I have no idea what I am doing.
Right there with you. Super excited for the future of Angular and JS in general. Definitely an exciting time to be in the industry, despite the hate from those who aren't comfortable with change. 
Fucking hipster programmers.
Ember seems to be the most popular alternative lately, for people switching from Angular. I will say though that I don't think Knockout gets as much attention as it deserves: it's a very solid little framework.
These are non users who are hating. Anyone using Angular now won't be ditching it any time soon. I never knew it was launching 2016. Good on Google for showing the roadmap for Angular.
They say its optional and it is nice with large apps if you get to that point. 
He didn't mention the async library. That one is a godsend for avoiding callback hell. And there's quirks with the language, sure... but the examples he provides can be easily explained, [] + [] === "" there is no plus operator for arrays, so it goes to strings -- [] converts to a comma delimited list of entries or "" in the absence of anything else add two blank strings you get ... a blank string [] + [] * 5 === "0" This one is a bit more complicated, but a blank string casts to 0 when you multiply it by five to get 0 -- then adding it to a string casts it to a string bringing "0". Either way, this sort of stuff is totally avoidable... if you are actually multiplying arrays by numbers you've got bigger problems than javascript not throwing a type cast exception which is what you might expect from other languages.
Sorry, I must not be as intelligent as you. What part of this article comes across to you as "thoughtfully-written"?
Oh look, another "The next version of Angular is coming out sometime next year and I don't fully understand what's happening. Therefore, it's a shitty framework and I have wasted my time learning it. What else is out there?" thread.
It would help if certain libraries didn't overload constructor functions so they also work as regular functions...
It's dumber than that. Some posts say, "zomg I don't want to have to learn a new Angular because effort and scare, so I'm switching to something completely different that I'll have to learn from scratch." People are hysterically reacting without even fact checking. "Now my templates won't be valid HTML!" They'll be as valid as they were before. `[value]` is as valid as `ng-value`. Or, as this OP does, they complain that they don't want to learn AtScript. Then don't learn it! Just because Angular 2 is written in it, that doesn't mean you can't just carry on writing JavaScript. Stop acting like startled puppies!
Every single time I start to approach "callback hell," I take a look at what I'm doing and there's *always* a better approach. Use [async](https://github.com/caolan/async) for heaven's sake. It makes working with callbacks a breeze. If you're in callback hell, you're doing something wrong.
You didn't address his concern about meteor being the entire stack though. Many of us have apps with existing backends in different languages, or even with a greenfield project could not marry ourselves to Mongo, etc. What if my app needs to integrate with multiple java soap endpoints on the backend? It's the same debate we will always have: more productivity and less control or the converse. At the end of the day, as always, it's about using the right tool for the job and having enough of them in the toolbelt. I'd share his opinion exactly in that I'd consider it for new consumer apps but know that with 'enterprise' there almost always come 'integration with legacy systems' which there are already lots of mature platforms centered around. A hosting platform doesn't solve any of the real world issues enterprise apps contend with outside of scalability (and while it may be valuable it cannot solve all of the issues there either).
I have been using MithrilJS for a couple of things - damn it's fast. It's great.
My only problem with this is that it repeatedly calls the function if I hold the key down. I only want it to call it once no matter how long I hold they key down. And when I lift it up, I want it to call the other function, which it seems to do perfectly.
Just an fyi, the guy who created Mithril is now on the Angular core team and is working on migrating over the main Mithril components to Angular now (such as the router).
I agree. All these posts are, "I don't want to switch to Angular 2 because Angular 2 is basically a completely different framework. Can someone please recommend another completely different framework for me instead??"
Finally someone said it! Yea, if we can go so far with PHP, then angular can stick around. So can JS but I guess ES6, ES7 they seem to be moving it closer to a better defined language. However, AngularJS did kinda feel hacky right from the beginning. I have always been reluctant to use it. Meteor FTW!
Javascript, Html and CSS?...
What would you use for templating and data binding in that case? I've been out of the node (event) loop for a while so excuse my ignorance.
If you want the handler to only be called once, you can experiment with `$(this).off('keydown')` in the keydown handler and re-establish it in the keyup handler. However while this will work with one key, it will not work the way you expect with multiple keys. The naiive implementation will simply call a single keydown and then every keyup will fire as you lift your finger from each key. I suppose my question is this: Why do you only want to fire the handler itself once? Your function will only be called once - when the key is first depressed. The overhead from the repeated keydown events are truly minimal - a few tenths of a percent at most.
http://vanilla-js.com/ is nice. In all seriousness, though. Check out "Service-Oriented Architecture" and see whether or not you want to be tied into a particular framework in the first place.
Hi OP, I was wondering how your progress is coming and if there's anything in particular you found helpful for your first foray into JS and programming.
Eh, that's a pretty simplistic way of looking at things. I've done my share of startups and while "move fast and break shit" is indeed the name of the game, "move fast" is relative. Like I've mentioned elsewhere, heavier alternatives like Ember are fine (and honestly in many cases preferable) for CRUD apps, but if you know your app includes some functionality outside of Ember's abilities, or your requirements are a bit fuzzy, you'll get a prototype working quickly but waste time in the actual "get to market" time horizon. 
Could you recommend a good tutorial on the combination of Flux and ReactJS?
There is a [WIP Redis driver](https://github.com/meteor/redis-livedata), and Postgres will probably be next.
It is The AngularJS Team's Second Web Framework. Calling it Google's or referring to its direction as things "Google is doing to us" both erases the identities of the people who started the framework and ignores the contributions of the non-Google contributors.
It's very easy to use backbone models and collections if you so choose. The decoupling by way of actions and the dispatcher really makes it very easy to "bolt on" a data layer.
Sure, I suppose you *could* read it that way. If you wanted. I wouldn't, of course, but *you* could if you wanted to.
Any full-stack framework is not going to be intended for replacement of existing parts of running production apps. However, there's nothing stopping you from using an external REST API with a Meteor app (or even creating a REST API on the Meteor server if you needed one for whatever reason). I'm sure the same can be said of SOAP. The Meteor server primarily serves JSON data only over WebSockets via their protocol called DDP (which specifies JSON structures for pubsub messages as well as RPCs), and all static assets including all HTML templates, client JS, and CSS can be served by a caching layer. There is nothing stopping you from having the Meteor server use a Node.js package like [`soap`](https://www.npmjs.org/package/soap) to handle synchronous SOAP requests as an intermediary. Requests/responses can then easily be handled with RPCs through DDP. The challenge is integrating the external services into the pubsub DDP scheme, and implementing some kind of latency compensation like the client-side minimongo database does in Meteor core. But that challenge is going to be just as challenging with any other framework, if not more. Similarly, there's nothing stopping you from using whatever database you want that has a Node.js driver. The problem isn't using the database in a typical request-driven manner, it's wrapping the database driver with packages that: * Specify how to wrap DB request/responses using DDP pubsub and RPCs. * Propagate changes to all Meteor server instances so they know what published data has changed and can push the changes to subscribed clients. With MongoDB, Meteor does this through oplog-tailing (or poll-and-diff as a last resort). * Implement a client-side local storage wrapper using a simulation of the DB's server-side API, so that isomorphism and latency compensation are the default. None of this is really necessary if you just want to talk to a backend in a typical fashion. It's only needed if you want to fully integrate Meteor's ideal of "full-stack transparent reactivity" (don't call us; we'll call you). But when communicating with existing and external services, implementing this inversion of control may be unwanted, unnecessary, and/or impossible.
I don't disagree with you, but I hope that even a heavy framework makes it easy enough and worthwhile to create custom components and inject outside libraries without too much filthy hackery.
That's the nature of fads. Last week, it was the best thing ever to hit the web. Now it's not cool any more. I suspect that this radical shift in opinion comes from the dramatic changes in 2.0. The web isn't the exclusive purview of hot-shot 20 somethings any more. Older developers understand the value of long-term stability. They've been burned too many times by investing in the "latest and greatest" only to see it abandoned a few years down the road. It's really important, when starting a new project, to pick stable technologies. If Big Company X pulls the rug out from under you, you could find yourself in a pretty uncomfortable position. (Microsoft and Google are both pretty guilty here.) Do you really want to start moving your Angular apps to 2.0? Climb that steep learning curve a second time? Neither does anyone else, but that's not why everyone is so irritated with Angular. They're upset because they guessed wrong. They thought investing in a product with the backing of a company like Google meant that their software was secure for the foreseeable future. They were wrong, and no one likes to be wrong.
I can't agree more with this sentiment. Microsoft invested in VB, then WinForms, then WPF, now WinRT.. Poof, all of the major (older) platforms are now gathering dust and bitrot for some new technology (WinRTX/TypeScript?... sigh.) Apple's been pretty consistent with their API over the years, only changing small things and making incremental enhancements to an interface that was designed in the late 80's. Overall, if its a small 1 page app that's a turn and burn, nothing to really look back to, then yes, fine, angular, pure js, hell -- emscripten with C++ -- or whatever. But if you have a long term maintenance cycle hope, nay, depend on a project or dev tools set that's mature. Also, angular was built for designers, not programmers, so its just simply not meant to be scalable.
Which router and ajax libraries would you recommend?
While I do agree with that, it must be said that criticism against AngularJS existed already before the news about 2.0. The recent wave is of course due to those news and that sentiment, but to be fair it must be mentioned that technical criticism against AngularJS did exist before.
KnockoutJS... It uses directives in a much nicer way. Angular uses the MVC paradigm and knockout uses MVVM. Since everything is typically MVC these days angular be overkill
Redis has an entirely different purpose than mongo. It is impossibly hard/inefficient to make certain queries with redis. Redis is a key/value store, not a database replacement.
If there would be a migration path then it would have been released officially. AFAIK they explicitly said that there will be no migration from 1.x and after a huge shit storm they are now trying to fix that.
Interesting, do you have any idea of how that will affect Mithril's future?
try D3
While the general idea is not too bad, I feel that I can wait the time until those browsers that require these polyfills will go extinct. Since some things cannot be polyfilled (e.g. handling sparse Arrays in IE), I prefer to know the restrictions of the clients I develop for than relying on polyfills. On one hand, using new techniques will help spread their use, on the other hand, being able to write a hefty pricetag on support for obsolete browsers may help in abandoning them faster, thus the latter strategy could help advance our work as much as the former.
So they are developing first and will think of a migration path later? Is that even possible?
PHP has good parts?
&gt; WIP Redis driver Have fun storing all you data in an in-memory KV store lol. &gt; Postgres will probably be next This isn't really compatible with business commitments. See where I'm coming from?
They said there will be no migration path up front, but that they are leaving it open for a migration path once the actually finish 2.0
https://jeena.net/images/2012/php-the-good-parts.jpeg ;-)
I have VB stuff from 1999 still running 365/24 on new machines
I just discovered this, has anyone used it?
I moved from AngularJS to GWT and I've never looked back. Have a read through this page to see all the features before you make up you mind: http://www.gwtproject.org/learnmore-sdk.html
Kind of reminds me of [RequireJS](http://requirejs.org/), but I don't see why this is better. Would not go back to AMD after using [Browserify](http://browserify.org/) for over a year now.
Disagree, used ember for a while and hated almost every second of it.
ES6 = ECMAScript 6. "ECMAScript" is the actual name of what most people call "JavaScript". It's the name of the standard. That "6" is the version number. Browsers went from ES3 to ES5 to ES5.1... and soon they will move to ES6. http://en.wikipedia.org/wiki/JavaScript http://en.wikipedia.org/wiki/ECMAScript
So most of what Ember already has....
Backbone + require.js + handlebars + bower = awesomeness.
&gt;a new JavaScript-but not-actually-JavaScript language What do you mean?
Why?
My issue with Angular has always been that I feel too disconnected from what is actually going on in the background. It throws away much of the simplicity and directness that I love about JavaScript and bolts this crazy abstraction onto it. I'm sure it's great if you're doing massive JS-driven apps, but as someone who does very dense data-driven SPAs it's all kinds of burdensome. 
So what do you do if your SPA needs like 10-20 ui plugins (datepicker, masonry etc), Ext JS + an ExtJS Gantt chart library + a data vizualization library? Just pack everything in one file? 
It just does too many weird things for me. its bogged down to naming conventions and made it really hard to anything remotely outside the intended scope. Ember data and the ember framework were when i was using it also moving in two different speeds. you had to fiddle with making them play nice together and version x of ember didnt work with version y of ember data. Maybe im not smart enough but it took way too much effort to get basic things running. I had previously used backbone and switched to anuglar after. a few more comments here: [here](http://softwaresimply.blogspot.com/2014/01/emberjs-is-driving-me-crazy.html) and [here](http://rob.conery.io/2014/03/22/every-who-tried-to-convince-me-to-use-ember-was-wrong/)
Yes.
I know that it is called EcmaScript, and it is the new standard, but what I am looking for is what are the main differences between ES6 and previous versions. To me, pure JS itself hadn't changed much, there are no new constructs, new syntax sugars, everything remains mostly the same as it was 10 years ago.
I'm surprised by this comment. For me Angular offers simplicity and directness through that abstraction. Especially when data is the focus. To fetch data with an AJAX request, format it, and update the page accordingly is trivial using Angular and a pain using raw javascript. And the more complex the problem, the greater the difference in code complexity is imo. Do you really enjoy manipulating dom nodes?
ReactJS is a UI layer and Flux is for application architecture.
"Also, angular was built for designers, not programmers, so its just simply not meant to be scalable." - Yes, because none of the 1600 apps that Google built with Angular are "scalable."
Angular feels hacky so instead you go for a full-stack framework which is bound up to node on the server and mongo db, good idea..
Don't mistake a vocal minority (which happens to have a lot of articles in this subreddit this week) for the majority. It's still incredibly popular and will continue to be, regardless of the 2.0 changes.
Mac developer here, what are you talking about? The switch from PowerPC to Intel required only a recompile, unless you had some inline assembly (very unlikely), endianness bugs that just weren’t visible before, or did some very low-level manipulation of the runtime (bad idea in any case). The last really big switch for programmers was from Mac OS 9 to X, and they provided a transition path called Carbon that still works today, after 13 years of Mac OS X.
a tv app and an extension, wow I wonder what gmail, g+, google drive, google search etc.. are all using
Been looking into Ember recently and loving it. Coming from do-everything-yourself in angular, having conventions is a MASSIVE productivity booster. Ember CLI is the way forward IMO, take all the time-wasting glue stuff out of building JS frontends and just build + get paid. However, the thing that's attractive to angular is that it has no conventions, so some folks may prefer an alternative with that paradigm. But seriously, after a weekend or two with Ember, it's obvious that it's a framework built by people who do this for a living for people who do this for a living. 
People can amen their own opinions? Amen
Good luck with that... I've been trying but haven't found anything yet.
This code looks is almost identical to manually converting CommonJS modules for use with RequireJS. http://requirejs.org/docs/commonjs.html#manualconversion Other than as a personal project or assignment so that the author can learn more about module loading in JS, I don't see any reason for this to exist alongside RequireJS and Browserify
It would help if you put in the full link... I guess it's https://ello.co/beta-public-profiles I think it's custom made, but maybe with some inspiration from http://isotope.metafizzy.co Looks pretty cool.
yes. that many different http requests is madness.
Well yeah, the output is usually just one bundle containing everything. The source files on the other hand can be separated to modules that require the dependencies they need (datepicker library for example). Of course there can be discussion about using CDN for serving third party libraries and about optimization in general, but this is something that has to be thought about with any module loading system. 
&gt; He didn't mention the async library. That one is a godsend for avoiding callback hell. Promises and generators/yield are the way to do it nowadays. &gt;And there's quirks with the language, sure... but the examples he provides can be easily explained I'd say the point was that type coercion is a rather weird "feature", not that it's hard to explain. &gt; if you are actually multiplying arrays by numbers you've got bigger problems than javascript not throwing a type cast exception If you make a super obvious mistake, it's nice if you're told about it right away. Type coercion conceals this kind of error. Some NaN or whatever surfaces somewhere in the UI and you'll then have to figure out where that came from.
Pedantic, but true. In this case, they're not too dissimilar though, due to the audience and the nature of the tech. 
How would I implement Bower to my existing project? I already have Maven which is managing my back-end (Java) dependencies. Is Bower same thing but for front-end dependencies? 
.NET 1.0, when it bumped up to 2.0(?) almost killed my company. 
If this is a problem with your javascript coding, then you have too many dependencies. You should only depend on yourself. 
Yeah what's that gonna end up in? Everyone suggests their personal framework anyway for their personal reasons. Why? Because they have worked out what works for them. But that doesn't mean it would work for someone else. You get 10 different replies suggesting 10 different frameworks. How's that gonna help going forward? And no don't look at *all* of them. Use Google trends or whatever to sort out which are the most famous ones and then evaluate how each of them fits your requirements studying their specification.
I still love angular and I'm excited about the changes in 2.0.
Yep, it's custom. https://github.com/cacheflowe/html-experiments/blob/master/experiments/ello-image-placer/index.html
the closure compiler: https://developers.google.com/closure/compiler/
http://facebook.github.io/flux has a tutorial, and two different example apps with testing included.
react-router is really the only one worth considering if you're going all in on react. Superagent is a pretty sweet library as well
As I said, your strategy helps promoting new features through the use of polyfills. Mine promotes the extinction of outdated browsers. By all means, go ahead, and good luck.
Bower mostly, the only caveat is that if I want my private/unpublished modules included I can't do this with bower.. been looking into using duo.js , but it's still not quite mature.
If you wanna go node way then Ampersand.js would be a good substitute for Backbone. Ampersand is literally Backbone but nodified. 
whoa I see pixi.js there.. that's pretty neat.
Angular 2.0 will probably be used with [material.angular](https://material.angularjs.org/#/layout/container) and I can't wait to see if any other framework will match that toolset. A lot of hate towards Angular 2.0, but the truth is that it will probably blow away any other framework.
Any good books out there for backbone/marionette? I'm not new to frameworks. I guess I just skipped backbone. Tried knockout and angular but I was looking at couple of tutorials and I really like how it's lean and gets out of your way on doing things. Although, like you said, we'd have to write a little more code.
&gt; I stayed as far away from Front End as possible. That was pretty unwise.. but congratulations in knowing better now! First off since you're really into PHP, I can probably safely say that you're also familiar with the Laravel Framework. This said, you can try your hand first with coding an express app to behave like any of your Laravel Framework (or at least, any RESTful) project(s) before. I believe Laravel's Blade is very similar to angular.. correct me if i'm wrong btw. If you ask me which to use, I can't really recommend one right away. Ember's pretty solid, Angular has gotten popular but is going into a weird phase right now, Meteor (that just got to 1.0) is a really fun framework to use but probably can't teach you a lot of the internal stuff. Also sails.js is pretty fun, you can probably count on your beginners luck better there :) 
Sure? I don't really know, I use angular because I work on a pre-existing codebase.
I’m aware of: * Kangax’ compatibility table contains a list of all ES6 features and where they are supported: http://kangax.github.io/compat-table/es6/ * I’ve written a page that gives an overview of ES6 and links to more comprehensive material: http://www.2ality.com/2014/08/es6-today.html * The ECMAScript 6 specification is the definitive document for what’s in ES6 and what isn’t: https://people.mozilla.org/~jorendorff/es6-draft.html
Not sure why the downvotes. Me too -particularly excited abut 0.11 being released today
If you put your modules in a git repo you can specify the address to that in Bower
We use component(1) for client side. I'm evaluating duojs for some personal projects. 
We build what I would consider very large applications with AngularJS and I wouldn't choose another system. Every few months I look at the landscape and try to re-evaluate but I come back to AngularJS. I'm clearly in the minority but the 2.0 news to me seems wildly sensationalized. If you've ever experimented with AngularDart it looks pretty familiar. IMO it doesn't seem that different.
I'd only add add Marionette to that list.
Just use Meteor. Here is an introduction: Learn Meteor.js Properly http://javascriptissexy.com/learn-meteor-js-properly/?WPACFallback=1&amp;WPACRandom=1415370317511
How about not being a technology hipster and stop using hipster trendy bullshit.
Looks interesting.
&gt; if you don't want to use that framework, couldn't you just simply not use it? I don't think that this argument holds, you might be working on a team, or you might be stuck maintaining someone else's code. 
[Marionette](http://marionettejs.com) is pretty awesome. Solves all of the problems you wind up solving again and again with each new Backbone app, and has a wonderful (small, but passionate) community.
&gt; Everyone suggests their personal framework anyway for their personal reasons. Yes. And? Are you suggesting that he might not recognize some of his own personal reasons and find it helpful and insightful? &gt;Use Google trends or whatever to sort out which are the most famous ones and then evaluate how each of them fits Is that how you got to Angular?
I see your point. Personally I love magic. If a language allowed me to use vernacular English to program, I would use it. Would be wonderful to tell it things like "more of less like that, sort of like the other thing but not as much, you know what I mean". If I may misuse the term directness again, this magic gives me direct access to the problem - rather than to the html element.
me too 
FYI: You can also install threejs(or any other git repo) with npm, while still specifying the Version etc in your package.json just like any other npm package. npm install git://github.com/user/project.git#version @see https://www.npmjs.org/doc/files/package.json.html edit: typo
ugh, my bad. It was the Durandal guy, not Mithril: http://angularjs.blogspot.com/2014/04/angular-and-durandal-converge.html Got my obscure names mixed up, sorry.
Why would I use this when there are literally 3 other solutions I can think of offhand that are miles ahead of this?
Yes, but in a *public* repo though.. I haven't found that bower allows for totally private ones.
&gt; Yes. And? Are you suggesting that he might not recognize some of his own personal reasons and find it helpful and insightful? If there were any. The average post here is "Try flux", "Meteor FTW". That's the tiring thing about it. If people would actually give reasons *why* framework x is better than Angular then it would add a lot of quality but it doesn't. &gt; Is that how you got to Angular? I'm in the fortunate position to have built apps in Backbone, Ember, Dojo, React, Polymer and Angular.
hmm the text seems kind of familiar.. it looks like the main points were ripped off from somewhere else.. I just can't remember where else I've read it from.
I think [TodoMVC](http://todomvc.com/) is exactly what you want. It has 60+ implementations of a simple TODO list app written using several frameworks and compile-to-js dialects. You can directly browse their code on GitHub: https://github.com/tastejs/todomvc/tree/master/examples.
Personally I have a VPS for development and use ssh with PKA to access the repos, bower deals with that fine, but there might be a better way
Well, at every single dev job I have had, we have had Front End Developers .. So, I never HAD to learn it. That being said, everything I have ever had a need to do I have accomplished using jQuery. And yes, I'm familiar with Laravel, but I'm honestly not a fan. I only use it because some clients request it specifically. Also, I'm not looking for a "use this or that". I'm literally looking for a group of projects that I can take a bunch of frameworks to accomplish, so I can familiarize myself with all of them, similar to what /u/jnotarstefano posted.
Nice write-up! ES6 fixes so many broken parts of JS (like manually having to write a variation of Object.assign to merge two dictionaries). - I didn't know Object literal methods were a thing. Glad to see that though, because that's probably the biggest syntax error I make (forgetting to write "function" when defining an anonymous function). It's interesting that they are effectively a fat-arrow lambda, but in this case, the fat-arrow (and colon) are optional. - I forgot default args is in there. They were very useful in ActionScript - I'll have to look into them again. They'd be way more useful if there was proper support for named args though - my functions usually just take a dictionary to make their APIs cleaner (the cheat way of implementing named args), so I don't know if I'd get any use out of default args. FWIW, I've been using [node-jsx](https://github.com/petehunt/node-jsx) and [jsx-loader](https://github.com/petehunt/jsx-loader) to support the new syntaxes in code today's codebase. I didn't see those mentioned in "Using ECMAScript 6 today".
I see a lot of my good friends in the APAC using this like its their job, so I decided to take a look. Unfortunately all the docs are in chinese(presumably).
ThreeJS repo doesn't include a package.json, so Node's require algorithm can't determine its entry point. 
You can still use template libraries, and data-binding libraries like knockout or ractive , they work with browserify
In case you are a type of guy who likes to solve things: Get some pen and paper. Now draw three situations including cursor. 1. Normal size 2. Scaled up 3. Scaled down Observe or calculate what happens to the **x, y** of the view depending on **cursor** position when you scale the thing up or down. Apply what you find using **scale** and **translate** methods.
Show me any language/framework where doing things "the easy way" is not bound to create performance/scalability issues 
I was just reading the [scotch.io series](http://scotch.io/tag/react), good stuff!
no? in angular your controllers, models etc can be named whatever you want, not that they should but they can
Go, Dart... now AtScript? jesus Google people, stop with the NIH syndrome
I've been studying almost every day. Making okay progress. I did all the beginner and intermediate questions in codebyte. Build the quiz app in the jacascript is sexy roadmap. I found that roadmap extremely helpful. I read most of the chapters twice so that it would sink in. I highly recommend the rooad map. 
with backbone already having underscore, I find I could kick out handlebars to keep it a little lighter
As opposed to Angular and other frameworks which are built by hobby programmers for hobby programmers?
For such case the best is to use webpack.
Yeah, I saw someone compare Angular to other frameworks based on Google Trends, and I had to wonder how much that 'popularity' is caused by the relative complexity (i.e. googling for help).
Basically you'll need three things: 1. The model of whatever you are drawing. For example, if you are drawing squares, you'll need a list of all the squares in your system, and their properties, like x/y/width/height or whatever. 2. Another variable that keeps track of the current offset - basically delta-x, delta-y (pan) and delta-zoom. You can think of the default as (0,0,1) for example. 3. A translation method that takes your squares or whatever from #1, and figures out how to draw them on the canvas based on your delta values in #2. The first easiest thing to do would be to implement the (0,0,1) case above, just drawing things as they are to the canvas. Then try updating the dx/dy (panning), and zoom is probably the hardest to implement. That's a pretty high level overview - the big thing to realize is that your model from #1 is totally different and separate from the view (canvas) you are drawing to.
Note: arrow functions pick up `this` from their surroundings (so-called lexical `this`). Syntactically, method definitions are derived from getters and setters in ECMAScript 5: &gt; var obj = { get foo() { return 123 } }; undefined &gt; obj.foo 123 If you use the named parameter pattern (which I think is a great way to write self-documenting JavaScript code), you’ll probably love ES6 support for it (via destructuring): class Entries { // ... selectEntries({ from = 0, to = this.length } = {}) { // Long: { from: from=0, to: to=this.length } // Use `from` and `to` } } let entries = new Entries(); entries.selectEntries({ from: 5, to: 15 }); entries.selectEntries({ from: 5 }); entries.selectEntries({ to: 15 }); entries.selectEntries({}); entries.selectEntries(); Details: http://www.2ality.com/2011/11/keyword-parameters.html 
But browsers have this funny little thing called caching. Sure, you download everything, but you download it once.
The new hate for angular is weird to me. Computer people fearing change it seems like. Ive written quite a few apps with it now and I don't see why it's hated as I enjoyed it and it really helped me crank out a testable client side app.
O'reilly has a good one, looks like it's even free to read [here](http://addyosmani.github.io/backbone-fundamentals/). There's good tutorials on Backbone and Marionette's sites, and fairly extensive documentation on both of them as well (which is another plus with backbone - the sheer number of people using it) - if you're familiar with client-side MVC, I might skim the O'reilly book and just start writing, consulting the docs as you go. It's definitely worth a try. 
Yes and no. You get two things with Bower - you can track your front-end dependencies in a project and Bower can fetch packages for you. It doesn't do any task running like Maven does. If you need task running tools for the front end take a look at Grunt or Gulp to get started or check and see if there a Maven plugin that does what you need. Setting up Bower in a project is pretty easy but it does run on node so you will need to have node installed.
Some people wanted to see it fail and are using the current state of affairs to push that agenda. Others are smart and don't jump on every fad-wagon that rolls around. Then you have the folks who want to work for Google and blindly use Angular to "get there". Finally, you have the handful of seasoned engineers who can fork Angular and support or extend their apps however they see fit, regardless of major revisions that will always happen with major libraries at the core of an architecture.
There are lots of ways :) For what you have already, something like this would work... var object = ""; computerChoice = Math.random(); if (computerChoice &lt;= 0.33) { object = "rock"; } else if computerChoice &lt;= 0.66 { object = "paper; } else { object= "scissors" } ...but a nicer way, to avoid all those nasty decimals, and also to use a nicer construction than "if ... else ... ", would be something like this... var object = ""; switch (Math.floor(Math.random() * 3)) { case 0: object = "rock"; case 1: object = "paper; case 2: // or even "default" object= "scissors" } ... or even just this... var object = ["rock","paper","scissors"][Math.floor(Math.random() * 3)]; Good luck! 
You can run your own [private bower registry](https://www.npmjs.org/package/private-bower) and register your private packages to that. In you project level .bowerrc you point to your private registry: { "registry": { "search": [ "http://your.private.registry.com:5678", "https://bower.herokuapp.com/" ], "register": "http://your.private.registry.com:5678" } } This sets you private registry as the place you register that package and searches your private registry first before defaulting to the public registry. So for packages you want to be able to use with Bower but are private, you register them to your private registry. The registry is really just a list of package names and git endpoints to fetch them from, so as long as the machine you are later doing bower installs on can connect to those git endpoints you will have no problems with bower install of your private packages.
 var answers = ['rock','paper','scissors']; var answer = answers[Math.floor(Math.random()*answers.length)];
I am not at swich yet but omg i cant belive i didnt try &lt;= . I am shamed :/ now i know how to do it. Ty so much. I was thinking i need to use Math.radnom or Math.floor. tnx :)) EDIT: omg i find a error. I didnt print it lol. I need to put console.log(computerChoice); after if/else if/else. :D
&gt;To fetch data with an AJAX request, format it, and update the page accordingly is trivial using Angular and a pain using raw javascript. I wouldn't call that a pain with raw Javascript, it's trivial. You don't need Angular for that anyway, jQuery would be the better choice. Need data-binding or JSON&gt;DOM mapping for dynamic datasets? Alright try jQuery Templates, Angular, Ember, React, Ractive, Derby, Meteor, Hogan, Dust, Transparency, etc.
Or: if(computerAnswer &gt;= 0 &amp;&amp; computerAnswer &lt; 0.33){answer="rock";} else if(computerAnswer &gt;= 0.33 &amp;&amp; computerAnswer &lt; 0.66){answer="paper";} else{answer="scissors";}
&gt; There are lots of ways :) For what you have already, something like this would work... Best solution so far ... at least until someone does that in just one line
&gt; I'd just override Model.Parse Looks like a decent solution - though if I have an object with 6 sub-hashes I now have 7 models for an item that I would like to be a single *thing*. What's more, I can no longer keep my mode *default*s in a single file, to get an idea of the full structure I have to hunt down each *default* setting from each file and assemble it. Here's my main problem though. When people are learning BB/Marionette this is not discussed anywhere. It's "tutorial 1: models, tutorial 2: views, tutorial 3: templates, ta-da you have an app!" Nowhere in any of the learning resources OR the docs is this even acknowledged as an issue. The Marionette channel in Gitter recommends just using plugins. &gt; But here's the thing; at some point in the future the scope of these views more than likely will change This statement is the top reason why I disagree when people tell me Backbone has no opinion like other frameworks. I think it has tons of opinions, this being one of them. You are unable to judge for yourself whether your simple dropdown is going to remain a simple dropdown, so it forces you to create 4 files to create a dropdown and it gets a free pass in doing so because "it's for your own good". That to me is like forcing I'm glad it's helping people write more flexible code, but I disagree in forcing people into it.
I've found there's less "magic" in angular, I hate things that just provide things to you which aren't obvious what they do (there are some ugly corners to angular in this manner, but this happens to most software). Also you can add your own "magic". You look at the HTML and it's pretty obvious when elements are hidden etc. If you want to see how it's done, it's pretty obvious exactly where to look in the javascript.
Probably the *easiest* would be to ship them all to everyone, and have the polyfills check to see if they are needed (think they already do this). If you use UA you'll probably ship the wrong set of polyfills to browsers spoofing their UA, which sorta defeats the idea behind this. It remains to be seen how common or problematic that is, so I am interested to see how this works out.
Now that you know how to do it by random choice, the next step is to add in [prediction](http://blog.wolfram.com/2014/01/20/how-to-win-at-rock-paper-scissors/)!
I dislike it because it feels like it vastly overcomplicates things that should be simple, and leads to poor design patterns (I think non-explicit 2-way binding is generally an awful, unnecessary concept). There's also the fact that it's almost not like even using JavaScript. There's special syntaxes, pretty much zero libraries work with it without being ported, and templates quickly become an ugly mess even if you try to use directives to split things up. Directives are hopelessly over complex for what they actually achieve, too. I and a few other local developers have transitioned from AngularJS to React/Flux and we've not looked back. I don't give a fuck about it being controlled by Google or that it's weird and different, it just feels like a battle to do things, and as soon as an application becomes even moderately complex, you just have to pray that the magic works and doesn't randomly fuck up. I guess it's OK for prototyping. Also, why not just not use it? Well, if you are part of a team or join a company and the decision is out of your hands, it's immensely frustrating. Whereas with React/Flux I've had developers messaging me and being like, holy fuck, this has fuck all learning curve, is clean, fast, modular, reusable, and I really like the workflow!
It's pretty goddamn hard to make React slow, and they helpfully provide the Flux pattern so you've got a ready made way of doing things that works well.
Ditto, it's a million times easier for some reason. Why does require make things so difficult??
yeah, basically everything in javascript is an object. One of the coolest features of javascript is that functions are first class citizens. They can be passed around like variables and you can create them on the fly inside other functions. they're 'closures' and they are different than function pointers because it allows your passed around function to access non-local variables that aren't in the immediate lexical scope. Also check out MDN, they call 'function's' as 'function object': https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function Another way to tell that they are objects is by what methods/properties they have inherited. ex: var fun = function() { //do something } fun.toString(); You see, that your fun 'function' has now inherited some 'tostring()' method from a parent class. 
&gt; I know JavaScript is an Object-Oriented language. Not so fast. But yes, functions are objects. This is something that goes underappreciated. They have certain properties that you can take advantage of (in particular, `length` can be useful when monkey-patching functions that you may not know everything about). &gt; var f = function foo(a, b) {}; &gt; console.log(f.length); // number of arguments it was declared with--note that you do have the freedom to pass in more or fewer. 2 &gt; console.log(f.name); foo &gt; console.log(f.prototype); foo {} &gt; console.log(typeof f.prototype); object &gt; console.log(f); // this won't work with every function function foo(a, b) {} Functions also have methods that you can use to good effect: var g = function bar(a, b) { this[a] = b; }; var obj = {}; g.call(obj, 'prop1', 'val1'); // call g with the value of `this` set to obj console.log(JSON.stringify(obj)); // prints {"prop1":"val1"} g.apply(obj, ['prop2', 'val2']); // like call(), but takes an array of args instead of individual argument slots console.log(JSON.stringify(obj)); // prints {"prop1":"val1","prop2":"val2"} edit: also, `bind`! var obj2 = {}; var gBound = g.bind(obj2); // make the value of `this` always be obj2 when you call gBound gBound.call(obj, 'prop3', 'val3'); console.log(JSON.stringify(obj)); // it's still {"prop1":"val1","prop2":"val2"}... where is prop3: 'val3'? console.log(JSON.stringify(obj2)); // ah, there it is: {prop3: "val3"} 
&gt; functional programming language wrapped in "Object-Oriented Clothing". There's some truth to this. Brendan Eich (the creator of Javascript) wanted it to be like Scheme but was told to make the syntax more like C++ and Java. So basically what ended up happening was LISP with Java/C-style curly braces and semi-colons.
Oh, that's cute.
The team that originally started working on the AngularJS framework was using GWT on their day-to-day projects and felt they weren't productive enough so this is kind of strange evolution :D
&gt; Apple's been pretty consistent with their API over the years, only changing small things and making incremental enhancements to an interface that was designed in the late 80's. I think Apple makes really great products, but... I'm sorry, this is crazy. They are almost comically hostile to their developers at times, even great shops that win tons of awards are pulling their apps off the Mac App Store recently.
I understand your point but with Angular.js it felt like I was running into performance issue rather early in the development process. My application had a list of lists which was locking up the browser if the data grew to large (20 rows with 10 columns). I spent some time trying to fix it with bind-once or just re-designing the application so it was a list + a details view and in the end I got it somewhat working. At the time React.js started to appear on my radar so I tried the same list of lists and it just worked. I was able to finish the application and then spend a day at the end on making it even faster without introducing some extra concepts like I did with Angular.js. That was a year ago though so maybe things are better now. Performance with the other two items I listed were the main reason I stopped using Angular.js.
SPAs are generally meant to be used on an ongoing basis. So the browser loads the resources only the first time visiting or every so often when the app is updated and after that it loads it from cache. After that first load the app is responsive and there is no need to load further resources as you use the application which might make the app appear unresponsive. I've yet to see an example of a page which minifies and packages all the script and where the load time is slow enough to deter users. Do you have any examples of such SPAs?
Very interesting. I knew that functions were considered first-class citizens in JavaScript but these examples help clarify that. &gt; Not so fast. So you are saying it isn't? 
What are the other 3?
yeah, i noticed that too.
&gt; so many other option Which are those? I know only one which can do all of those - [SystemJS](https://github.com/systemjs/systemjs) and [jspm](https://github.com/jspm/jspm-cli)
I don't trust UA at all, it is way to unreliable. If you have a product with features based on UA and users report weird issues then you know what is up. People actually contact and complain they only see mobile version of the site on desktop, turns out they switched to iPhone UA for whatever weird reason. I'm sure Mozilla will do a feature detection based solution very soon. With a bit of luck this move will generate the community power to find a good way to make it work.
There was at talk at Øredev a couple of days ago where the speaker addressed DI among other things. It's on their vimeo page. Roughly 55 minutes.
var answer = ['rock','paper','scissors'][Math.floor(Math.random()*3)]; This doesn't scale.
I see you've been practicing your spells, Gandalf.
use vue.js, I used it many projects, fast and easy and gets the job done
Thanks for sharing!
That's what happens when you have terrible documentation. You get really "popular" on Google. 
Thanks for the brief and helpful article. I'm gonna go try it out right now by cleaning up some of my ES5-style: function (optionA, optionB) { if (optionA.hasOwnProperty("optionA")) { var argumentDict = optionA; optionA = argumentDict["optionA"] || defaultOptionA; // ... declarations.
I'm not talking about specific tools that handle all three simultaneously. I was simply listing the three dominant formats of which numerous runtimes and optimizers exist for.
Webpack is fantastic. Sokra has added so many hours to this project it's ridiculous and it shows. I love the fact that you can require() things synchronously and the code gets de-duped and concatenated into a bundle, but you can also require() things AMD-style (async) and that code will be loaded via ajax at runtime! Not to mention you can also seamlessly load things like Stylus (css) files with require() and have them downloaded and added to your page when needed. So many features it's silly.
I meant that more in regards of some people were complaining that they will be forced to work with it in the near future and will have to change their code every time there is an update, but this framework isn't being forced on anyone.
If you do TodoMVC, please remember to actually store someting in a proper data store. Most TodoMVC implementations completely lack persistence to a database or remote source, and that's just something you need in real-life.
I use it for readability. Functional helps you write code that reads well (if you do it right) without having obtuse symbology and performance hacks built in to your code. It's almost always easier to adapt to changes as well.
It's Object Oriented, but not in the classical inheritance way. (ie: classes, extensions, superClasses, etc.)
Knockout? Ractive?
But can't people just continue using Angular 1 if they don't want to use Angular 2?
yes, for a while. but then you get a fragmented community and you also don't get the benefit of new features or bugfixes, since presumably the angular core team will be developing Angular 2 instead.
It's optional in so far as the standard docs, tuts, etc. exist. Otherwise, we've got to translate their syntax ourselves. It's technically true, but at the same time disingenuous marketing speak if the two paths aren't equally supported. We are really creating a mess with all these niche languages. It's like we've decided all at once to recreate every spoken language in recorded history just cause we're bored or annoyed by what someone else made in the past. It's getting to the point it's hard to talk to each other anymore things are getting so fragmented and specialized. I want a common tongue, a la Node.js unifying front and back ends, not a root tongue with many weak branches.
FP is not purely about throughput and parallel processing. That is a peripheral benefit for compiled functional languages (Erlang is probably the language that takes the most advantage of this.) One of the features of FP that makes it amenable to parallelization is purity and avoiding side effects. If you know sections of your program are pure (that is, given the same input they will produce exactly the same output), and produce no side effects, then the work can be confidently split amongst multiple threads. Javascript, due to its single-threaded nature can't take advantage of this. But purity and avoiding side effects make software development and maintenance so much nicer that trying to attain them is useful in its own right. The definition of "functional programming" is a bit fuzzy -- it could mean just using higher-order functions, or using 100% pure functions and persistent immutable data structures, or anything in between. But that is the beauty of Javascript -- it is flexible enough that you can gradually migrate to more and more functional code. But here are some of the benefits of each of the traits that people might consider "functional". * Higher-order functions This is where people start. Using `[].map()` and its siblings allow you to build higher-level abstractions. Libraries like lodash give you even more tools. You start writing code that is more declarative, and more concise -- you end up writing *what* you are doing, rather than *how* to do it. You can also avoid certain GoF design patterns. The Strategy pattern or the Command pattern are obsolete in languages where functions are first-class values, and the Observer pattern is a hell-of-a-lot easier. * Purity This gets you idempotence and predictability -- knowing a function is pure means frees you from expending the mental energy to figure out what side effects it causes when you use it. It also means that testing it is trivial -- just verify the outputs for a set of given inputs. * Avoiding State State is hard. It fundamentally makes programs hard to reason about. It makes testing hard because you have to build the state you need first and then test the state transitions. You can't 100% avoid state because otherwise you couldn't even update the DOM. Avoiding state is hard, but ignoring state is even harder. * Closures Since JS lacks "real" encapsulation and data-hiding in a classical (think Java) fashion, you have to use closures if you want to have truly private fields. I'm also the opinion that a factory function that returns an map of functions that close over some private variables (the Module pattern) is more powerful and cleaner than `var obj = new MyClass(vars...)`. You get real encapsulation and you don't have to worry about `this` when passing those methods to other functions. But remember that Closures are the poor man's Objects, and Objects are the poor man's Closures. In the end they are containers for state, and state should be avoided. Oftentimes it is better to have functions that just work directly with data. * Immutable Data Structures This is something new that people are exploring in JS. Consider this "pure" function: function addProp(obj, value) { obj.foo = value; return obj; } Seems "pure", right? Only a function of its inputs and outputs, in an object and a value, and out one object? Nope. It is impure since it modifies `obj`. This could lead to unpredictable behavior if you had something like this: var obj = { foo: "foo" }; var newObj = addProp(obj, "bar"); console.log(obj.foo); // prints bar We knew it would print `bar` because we know what `addProp` does. If we didn't know what `addProp` does, what is logged could be a surprise. In this instance, it is not too bad, but if your entire program is built out of functions like this, it can get out of control. The way to make it pure is to do this: function addProp(obj, value) { var newObj = _.clone(obj); newObj.foo = value; return newObj; } But this is a pain, and a bit inefficient. Libraries like mori and Immutable.js give you tools to deal with this. function addProp(hash, value) { return mori.assoc(hash, "foo", value); // returns a completely new collection } The other benefit of immutable collections is that if 2 collections `===` each other, you can be sure they are equal from a data standpoint. This is incredibly useful in React. * SOLID Other's have argued that taking the SOLID principles to their logical extremes, specifically the Single Responsibility Principle and the Interface Segregation Principle, leads to functional programming. Check this out: http://blog.ploeh.dk/2014/03/10/solid-the-next-step-is-functional/
Well, yes, that's true, but their API is much more consistent than Microsofts. Or perhaps I should say invested in. MS seems to come up with a new way of doing the same thing (rather than making the old one better) every 3~5 years.
&gt; Most TodoMVC implementations completely lack persistence to a database or remote source I was unaware that JS could be used to connect to databases.. I need to expand my horizons a bit.
The point is that there is no hard link between Meteor and MongoDB; it's just the only database driver that is production ready. Redis support could be helpful for scaling published data. Postgres is one of the more popular RDBMSs and will likely drive the development of an official multi DBMS ORM for Meteor (probably speeding up the development of further SQL drivers). Really, there's nothing preventing you from using any DBMS with a Node.js driver right now, you just won't get the full stack reactivity and latency compensation. If you need real-time queries provided by DMBS x, Meteor probably won't be the solution for at least a few months. If you just need real-time queries period, Meteor is extremely attractive for new apps. I've never really seen Meteor advertised as a drop in replacement for existing parts of a production application. It's much more useful when writing a new application mostly from scratch.
I admittedly didn't read the books, but from the movies, Gandalf's powers were politics, talking to animals, making light, and breaking bridges... I'm missing a reference somewhere here.
If you want to outsource this you may want to consider using [Pusher](http://www.pusher.com). 
&gt; Then you have the folks who want to work for Google and blindly use Angular to "get there". Ugh, those people. I remember quite a few people in my career who thought learning .NET/VB/Win32/MSSQL/etc. would leverage them for a position at Microsoft and they never investigated or learned anything that deviated from that life plan.
Yep I agree. The only reason you would use Meteor for that is to have an app that is partially real-time, and then partially driven by a non-real-time external data provider. Although personally (call me crazy) I prefer the standalone client version of Meteor's Blaze over Angular. For me it's just much easier to reason about my UI and gives me both cleaner HTML and cleaner JS. So even though my shop exclusively creates new, cross-platform collaborative webapps in Meteor, I could still see us using just Blaze for simpler apps that don't have a collaboration aspect.
But if they hate change why did they adopt Angular in the first place? 
wow it looks amazing. Thanks a lot
another option is to [do something like this](http://9elements.com/io/index.php/external-bundles-with-browserify-and-gulp/) - have one bundle that contains your app code and another that contains all third-party libraries. That way if your app changes, the user only has to reload the app bundle while the vendor bundle will still be cached.
Yeah, I'm way behind the times. My current job is 99% WordPress customizing, and I have fallen behind a lot on what is around.
&gt; developers I meet that do take articles like this as further proof that Javascript is the only language they'll ever need to learn If you bump into any that point to my article to support that perspective, point them to this comment: When I was learning how to code, I learned BASIC, Assembly, Pascal, C, C++, LISP, Perl, and a variety of other languages before I started to specialize in JavaScript, and each new language I learned taught me to look at programming differently. I don't think you can really understand your language of choice well unless you've explored other languages that bring with them different paradigms -- different ways of thinking about the same problem that may trigger breakthroughs in your understanding of how to be a productive programmer. As for your concentration on functional programming: &gt; The venerable master Qc Na was walking with his student, Anton. Hoping to prompt the master into a discussion, Anton said "Master, I have heard that objects are a very good thing—is this true?" Qc Na looked pityingly at his student and replied, "Foolish pupil—objects are merely a poor man's closures." &gt; Chastised, Anton took his leave from his master and returned to his cell, intent on studying closures. He carefully read the entire "Lambda: The Ultimate..." series of papers and its cousins, and implemented a small Scheme interpreter with a closure-based object system. He learned much, and looked forward to informing his master of his progress. &gt; On his next walk with Qc Na, Anton attempted to impress his master by saying "Master, I have diligently studied the matter, and now understand that objects are truly a poor man's closures." Qc Na responded by hitting Anton with his stick, saying "When will you learn? Closures are a poor man's object." At that moment, Anton became enlightened. http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html
The web is too awesome to be doing just wordpress stuff man, good job on leveling up :D 
&gt; WebSockets[1] will do what you're asking, but polling (at this point) is still a better answer. What do you mean by this? Are you referring to the complexity to setup or are they not that great performance wise or something?
Nah, no need for downvotes; you certainly raise a valid point. At the end, I feel it depends on how you understand your site: either you think about it as an application, in which case it makes sense to download the whole application, or as a webpage, in which it would be preferable to download resources on demand. 
It's more fun too!
http://en.wikipedia.org/wiki/Mithril
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Mithril**](https://en.wikipedia.org/wiki/Mithril): [](#sfw) --- &gt; &gt;__Mithril__ is a [metal](https://en.wikipedia.org/wiki/Metal) found in [Middle-earth](https://en.wikipedia.org/wiki/Middle-earth) as described in the fantasy writings of [J.R.R. Tolkien](https://en.wikipedia.org/wiki/J.R.R._Tolkien). It resembles [silver](https://en.wikipedia.org/wiki/Silver) but is stronger than [steel](https://en.wikipedia.org/wiki/Steel), and much lighter in weight than either. The author first wrote of it in *[The Lord of the Rings](https://en.wikipedia.org/wiki/The_Lord_of_the_Rings)*, and it is [retrospectively mentioned](https://en.wikipedia.org/wiki/Retcon) in the third, revised edition of *[The Hobbit](https://en.wikipedia.org/wiki/The_Hobbit)* in 1966. In the first 1937 edition, the [mail](https://en.wikipedia.org/wiki/Mail_(armour\)) shirt given to [Bilbo](https://en.wikipedia.org/wiki/Bilbo_Baggins) is described as being made of "silvered steel". &gt;In *The Lord of the Rings*, Tolkien wrote that mithril is found only in the mountains of [Moria](https://en.wikipedia.org/wiki/Moria_(Middle-earth\)), where it was mined by the [Dwarves](https://en.wikipedia.org/wiki/Dwarf_(Middle-earth\)). *[Unfinished Tales](https://en.wikipedia.org/wiki/Unfinished_Tales)* alleges that it is also found in [Númenor](https://en.wikipedia.org/wiki/N%C3%BAmenor). &gt;The name *mithril* comes from two words in *[Sindarin](https://en.wikipedia.org/wiki/Sindarin)*—*mith*, meaning "grey" or "mist", and *ril* meaning "glitter"." &gt; --- ^Interesting: [^Full ^Metal ^Panic!](https://en.wikipedia.org/wiki/Full_Metal_Panic!) ^| [^Mithril ^\(band)](https://en.wikipedia.org/wiki/Mithril_\(band\)) ^| [^Mithral ^Hall](https://en.wikipedia.org/wiki/Mithral_Hall) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clw2zqq) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clw2zqq)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I just upgraded to ES6 named parameters, and I didn't have to touch a thing except for the function declarations. Awesome! Here's an actual piece of the diff: -function CategoryModel(name, keyName, image, children) { - if (arguments.length == 1 &amp;&amp; name instanceof Object) { - var argumentDict = name; - - name = argumentDict.name; - keyName = argumentDict.keyName; - image = argumentDict.image; - children = argumentDict.children; +function CategoryModel( + { + name, + keyName, + image, + children } - +) { Thanks again for the tip!
If you think angular has less magic, I'd be interested to know what you think has more magic.
I typically avoid inheritance. It creates incredibly tight coupling between your base class and your sub class. What you really want usually are traits you can mix in, or composed objects. Seriously, check out Javascript Spessore.
You're just looking at the knee-jerk reaction to the (most recent) 2.x announcement. You won't be forced to use AtScript. You can use JavaScript, AtScript, Dart, or anything which interacts seamlessly with JavaScript like TypeScript or CoffeeScript. You also won't be forced to port your existing projects to 2.x. Porting your project to 2.x also won't be necessarily that hard. Kinda funny how no one has ever done that yet and yet they already complain about it. If you want to form an educated opinion on that topic, you'll have to wait ~18 months and see for yourself. 2.x will be faster, terser, and nicer to use. I think it's clearly a step in the right direction.
Just to be clear: Angular users will NOT need to use atScript. Right?
&gt;if you don't want to use that framework, couldn't you just simply not use it? It's not always up to you. And if angular becomes the dominant framework, then it will be pretty much impossible to avoid.
This is comparing apples to oranges, or carpentry to lumberjacks. Libraries like jQuery are primarily abstracting away the browser DOM, which is separate from JavaScript and horribly inconsistent between browsers anyway so it saves you a lot of headache and effort. First learn JavaScript (see ES specifications or other non-DOM resources). Then use a library and/or framework. Then, if you need to go deeper, look at the source of the framework to learn what it's doing so you can replicate it. It's not an either/or situation, but a progression of knowledge.
Looks good, how does it stack up against C3.js? 
Yep, they updated the site along with 1.0. They also revamped the docs, but be sure to notice that there is now a Basic Docs and a Full API Documentation. Some important bits seem to be missing from the basic docs, such as how to manipulate the default file load order in applications, without separating an app into packages. Also be sure to check out http://atmosphere.meteor.com , which is their pretty snazzy package indexing app, built with Meteor.
I would learn in this order: Syntax / control structures / datatypes / built in functions OOP / prototypal inheritance What's going on under the bonnet Best practices / patterns / pitfalls Basics of DOM ( or node if server side) Libraries (_, jquery) Frameworks Frameworks and libraries come and go, the language remains. A doctor needs to know about the human body and how it works before he learns one particular form of treatment.
Hm, when I use bower link, it creates a symlink in bower_components to /Users/chad/.local/share/bower/links/v3-ui, and that symlink with that path gets committed to the git repo. This isn't going to work on other dev systems. Maybe I'm missing something?
I wouldn't impose an artificial constraint like that unless I was developing a class curricula. Why? Because the libraries allow you to do fun things, which motivates you. Just keep in mind that the *language* is manipulating the *Document Object Model*. Continually revisiting and analyzing what you are doing will help. Also Google [MDN Object Oriented Javascript](https://www.google.com/search?q=MDN+Object+Oriented+Javascript). Just keep practicing and asking yourself "is there another way to do this?" Edit: *repaired link*
Funny. That explains all the weird decisions in angular. They tried to bring some of the GWT features to it (e.g directives) but did a piss poor job executing it. Also, GWT now has the same 'write, refresh, edit' cycle that javascript does. Likely they didn't feel productive because back then, 2-3 years ago, things were different, you had to run a special dev mode to test gwt which is no longer the case.
Yes, functions are objects. The types in javascript are: - number (not float, int, etc. just number) - boolean - null - undefined - string - object The first 5 are primitives. Everything else is objects. Arrays &amp; functions are objects. Don't listen to `typeof`, it will lie to you.
&gt; learning it gives you new ways to think about programming. The potential for parallel processing, etc, is nice. This point, however, is absolutely true. It's another way of thinking, and may present other benefits at some point in the future. There may be no tangible benefit, but that doesn't mean there's no benefit. A lot like how do, while, for loops are all the same thing. It's possible to express yourself with any, but sometimes one is more natural and so you choose to use it. If you're familiar with functional programming, you know it (the intangible above) you may see places where it's easier to use that style than something else.
My position - use libraries. I consider jQuery (and to some degree Underscore/Lodash) to be akin to the standard libraries offered by other languages. When you want to know how to write to a file in C people use `printf`, they don't talk about how to implement it. When I teach javascript I transition between jQuery and built-in functions seamlessly. I mention that here we are using jQuery and don't dwell on what it does internally. I find it way more important for people to understand how to compose closures than for them to understand the differences in browser DOM implementations. I explain the basic concept of libraries of course but I don't dwell on them too much. Eventually I loop back, explain how everything works in conjunction with javascript, and teach people how to read library code. I'm struggling currently with whether I should include frameworks like Angular early as well. On the one hand, they provide structure that will lead to people being productive earlier - and being productive is fun! On the other hand, Angular piles *so* many concepts on top of the relatively few of Javascript. By the way, unless the student is a complete programming beginner, I don't recommend focusing on syntax. The syntax isn't all that different from any other language and there isn't all that much of it. Learn how to write functions and pass them around well, learn how to compose functions so one returns another, learn how to break your code up into modules (and learn a module system for chrissake!), don't spend your time drilling on when a semi-colon is *really* required. Also, avoid the `this` parameter like the devil, don't bother with OOP and prototypal inheritance. Learn the prototype concept and move on. It's important for reading other people's code but [it's not actually necessary for writing your own](http://togakangaroo.github.io/2014/04/29/on-this-and-new.html). The overwhelming majority of times that people use `new`, there is a much simpler way to achieve what they're going for. 
Absolutely agree about fun being important. I *do* think that you might be unduly putting emphasis on the DOM however. It's 2014, many people are learning programming in a node environment.
Nope, it's perfectly valid of course. There are plenty of ways to do it as I suspect you know. But for some, there's a sense there should be a *standard* way to do it which is well known and well documented.
*was* Very excited about this. Sad that it's not really different from requirejs. Basically I have three options for optimizing the loading of my files in the year 2014. 1. Pre-concatenate the needed scripts on server side by knowing what is going to be needed and use that with a cache. I find this is the best way to do it 2. For smaller sites, all the pages will use the same resources so things like browserify, grunt, gulp or similar work well. 3. Use requirejs, which work well, but tends to load things later into the game sometimes and most certainly doesn't work well to load blocking resources. I'm not really fond of any of those, to be honest. I've been experimenting with loading fonts up high, requirejs async and then seeing if the pages can use it upon dom load.... and I feel like that's the route I'm going - but different pages have different resources. I'd want to concat on fly and use that. My wishlist for AMD and what's going to come in ES6 for requiring resources is to have: 1. A great mapping mechanism to files. Think composer/PSR. 2. Semvar support. Beyond just "jquery" I want to require "jquery/jquery:1.*" for example. 3. Environments. So if I call jquery/jquery it can bring up a different file that's easier to debug but larger in development than if I were in production. Overall, some of this might be moot for the front end when HTML2 (Edit.. HTTP2) comes out and is able to pipeline all this. I imagine even with the size of the average webpage increasing the load-time might be cut in half. Awesome right? So.. maybe that could be a christmas present in 2015? Thanks. 
Well yes it *could* be. That's just kind of restating the dangers of xss, doesn't it? Note the author doesn't claim there's any real networks that function like that. Although I wouldn't be surprised if there are a few minor ones, its too easy to get shut down through a few points of contact to grow too large.
What a stupid question. How old are you Esteban? This is a question I would expect a 14 year old to ask.
I say do a little bit of both
webpack.
check out webpack.
More opinionated than NVD3 and C3.js - less flexible but easier to configure. The idea is to be easily usable with no knowledge of D3 (charts can be created with a single line). 
Learning what JS can offer without the fat of libs is a no-brainer in my book. Of course you don't have to spend 7 years in Tibet to learn every bit of nuance, and there's not much to be gained by not touching libs until you have proven to yourself that you can replicate everything they can offer. A little suffering is good for the soul they say and trying to achieve even simple things that require you to consider browser incompatibility is a very valuable lesson in my opinion. And after that you can appreciate libs that abstract away these headaches. You'll also have the added benefit of actually knowing what's going on and can say you are using say jQuery because it enables you to be more productive, and not because the only thing you know is jQuery. This can be valuable when you're faced with a challenge that you know you could solve with jQuery relatively easy, but with a bit more effort your can avoid including jQuery altogether. I tend to sleep better when I can skim unnecessary overheads.
I loved the idea of mvvm on the client side and picked up knockout immediately. I stopped using it because something as simple as populating/filtering a large table (extremely hard to do incorrectly) was extremely slow. I'm certain it's improved because this was years ago now but these issues almost always stem directly from two way binding and dirty checking so there is inherent risk for framework developers. I agree with /u/haywire you almost have to be trying to make a slow react app.
If you set your browser's language to Dutch, you can hardly complain if you start getting pages in Dutch. By the same logic, if you spoof your user agent, you're asking to be treated as a different browser, so that's what we do. That's a feature, not a bug. There are good reasons why the service cannot simply use feature detection, which are covered in the OP.
Okay, adding either bower_components or bower_components/my-library to .gitignore makes sense. Thanks!
How? As multiple people have pointed out .net 1 apps will still run on brand new machines running modern windows os. Backward compatibility is a major focus of .net and Microsoft in general, it's cote to their survival (see alleged windows 9 skip reasoning and other similar moves in the past that are predicated on not breaking *other* people's code written 15 years ago). Genuinely curous.
And best practices. Their other 1598 are likely in house apps for planning who's getting lunch together. It's funny...I've seen this number a lot lately, as if we aren't all aware of the public facing Google services and can do basic arithmetic. 
use a builder. do your ui library like normal. once your ui library is updated run your builder program to inject the libraries files directly into your other projects. 
I recommend starting with vanilla javascript and DOM. It's not mandatory, but it will increase your confidence and it will help you learn the frameworks/libraries a lot faster.
Let me put it this way: I learned jQuery before I knew a thing about native JS, but you should learn native JS first if you have the choice.
Vanilla JS is fun! Adding knowledge of jQuery and the other extensions/frameworks just adds to the enjoyment.
God I hope this isn't true. I just bought a book for $50 titled "Node.js, MongoDB and Angular.js Web Development". As I read this post I was terrified that I spent the last week wasting my time. 
I haven't tried Browserify, but I have tried Webpack and I'd have a hard time going back to a world without it. From what I've gathered through osmosis, they are fundamentally similar (both traverse `require` trees to build a single JS file to put in your `&lt;script&gt;` tag), but Webpack seems to have an edge (Hot Module Replacement is awesome, as is seamlessly importing any filetype that a loader has been written for). Are you familiar with Webpack? Is there a reason I should be considering Browserify? I see Browserify mentioned way more often, but Hot Module Replacement alone makes it hard for me to imagine working on an app without Webpack.
Both Carbon and 32bit still work fine, you’re just encouraged to not even think about using it for any new code. Even Java apps still work when you know how, even though Apple actively tries to get rid of this legacy.
&gt; webpack not very descriptive web site.
Code school has a free course on chrome dev tools. https://www.codeschool.com/courses/discover-devtools
Do you have a link to a working demo?
Yes if you really want to be good at it.
I'll get the latest pushed out tomorrow but heres the bitbucket link for it. I don't have it published yet though. https://bitbucket.org/Ttiamus/web-character-sheets/src/ba1d82310a6355df5f128031cc67377d7d713b6e/WebCharacterSheets/Views/CharacterSheets/Ed3_5.cshtml?at=master
Yes! I would recommend the book "Javascript, the Good Parts" http://shop.oreilly.com/product/9780596517748.do It's pretty short, you can definitely get through it in a weekend if you have some programming background.
Gotta disagree with the 'stable technologies' argument here. The entire web is changing quickly, and anything that works today will be obsolete in 2 years. New frameworks that work with Web Components and ES6 will come up. Important concepts from Angular 1.3 will carry over to 2.0 - the learning curve won't be 'a whole new framework' steepness.
I like the Google IO talks on devtools: https://developers.google.com/events/io/2013/sessions/325206725 https://www.youtube.com/watch?v=gZH1d2Co1X0 (mobile)
I found it very useful to learn about prototypal inheritance, which is how it's actually done in JavaScript: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain
I would. If you want a good resource, do the free trial at teamtreehouse.com. The javascript courses in their Front End Web Developer track start off with the fundamentals and then introduce jQuery. I really like their program. However, be warned that the courses need to be done in sequence, and some of the initial courses are very basic level and may be tedious if you are already familiar with HTML, CSS, etc.
Oh good lord. HTTP2*. 
Heads up, your link points to MSDN, not MDN, which is an entirely different can of worms. By all means, read the OO JavaScript article, if for nothing else than to get a handle on a very common idiom. But also read [You Don't Know JS - this and Object Prototypes](https://github.com/getify/You-Dont-Know-JS/tree/master/this%20%26%20object%20prototypes), or tl;dr at least [chapter 6](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch6.md) which describes a far cleaner, conceptually simpler method than faking OO through prototypal inheritance. This book ([and the others in the series](https://github.com/getify/You-Dont-Know-JS)) have cleared up **so much confusion** about JavaScript for me. The attempt to bolt on class-oriented style on to a language that does not truly work that way has caused tons of confusion and I think this book is a must read for any JavaScript developer. 
This is great information. It's ridiculous that people are downvoting you.
Not for flux, no. I think they (FB) are priming immutable to be used like a cursor or something (just speculating). Data layers in React are still hard to integrate, no standards.
Is this purely a learning exercise, or do you have to get shit done too?
Actually, those aren't all primitives. true.toString(); // 'true' 'string'.toString(); // 'string' (5).toString(); // '5' The only reason you have to use parenthesis around the number 5 is because the js parser will try to interpret it as a fraction and throw an error.
I work primarily in classic ASP (and the rest in ASP.NET). Can confirm that I've thought about point #2 many, many times. The good thing (and trust me, there is only one) about classic ASP is that you don't have to compile it. I lose 8 minutes every time I want to test a change for a .net page.
Wow, this is very cool. I think the problem right now is you're thinking too much in terms of individual actions e.g. Validate Save, Update Save in DOM. Validate AC, Update AC in DOM. Instead you should be thinking in terms of modular functions which compose together in order to perform some greater functionality. For instance, we can think of the problem in the following way: 1. Grab data from the necessary fields 2. Sum the values in those fields 3. Perform a transformation on that value 4. Update the value in the DOM Let's implement a few of those now. How might we write a single function which grabs data from the fields we need? function fetchValues (className) { return $('.' + className).map(function(index, node){ return node.value; }).toArray(); } Great, we're already on our way. Notice how we're not worried yet about how exactly these functions are going to link together - instead we have a utility function which takes a class name, grabs the values out of the DOM, and returns them as an array. Now let's write a function to sum those values. function sumValues (array) { return array.reduce(function(memo, num){ num = parseInt(num, 10); if(isNaN(num)){ num = 0; } return memo + num; }, 0); } Now with these two functions we can call one function to get the current value of all input fields: function getCurrentValue (className) { return sumValues(fetchValues(className)); } We're already doing way better than we were previously - in order to find the current value for an attribute, all you have to do is call `getCurrentValue(className)` to find it. Neat. But we still need to transform the value. How might we do that? Let's start by writing a function. function getModifiedValue (className) { var currentValue = getCurrentValue(className); // Somehow transform currentValue return currentValue } How can we make this function generic? One approach is to store the transformation functions in a separate object. var transform = { stat: function(value){ value = Math.floor(sum / 2 - 5); if (value &gt;= 0) { value = "+" + value; } return value; }, ac: function(value){ return value + 10; } } Now by adding the property we're looking for in the function, we can make it generic. function getModifiedValue (name, className) { var currentValue = getCurrentValue(className); if(transform[name]){ currentValue = transform[name](currentValue); } return currentValue; } Notice how functions which have rather complex logic (such as getModifiedValue) are actually composed of individual functions which are very simple, reusable, and perform a specific task. This is the essence of functional programming. Pick up where I left off and refactor your code base. Try to make it so each function is named for the one thing it does. I'll check in on your work, just respond to this post. You're off to a good start OP.
&gt; don't bother with OOP and prototypal inheritance. So... don't bother with javascript?
You can have multiple script tags in HTML. Just place another script tag below the jQuery one and have it reference your own JavaScript file. You will then have access to jQuery (and jQueries $ variable) in your own script as they will be defined globally when including jQuery in this way. 
You just need to also reference your own script file after the jquery file. The jquery file will get loaded before your script file, thereby providing you a global jquery object that you can reference and use in your script file. 
Ah right ok, so if I were to reference the google api one, then reference my .js file, and put my jquery code in my file, it should all kinda work? Thanks for your help!
Ah ok thanks, I'll give that a go! How many js files can you reference? is there a limit? Thanks!
I enjoyed Pro Javascript Techniques by John Resig. It helps you understand (a simplified and probably out of date version of) what jQuery is doing behind the scenes. Also Javascript: The Good Parts by Douglas Crockford is a good resource. I don't recommend ignoring jquery et al as you try to learn, as long you make an effort to understand what those libraries are doing for you. It sounds like you're curious and determined, so just keep that attitude and you'll be fine.
 var x = [-0.8234, 0.0952, 1.9594, -0.2831, -0.4147, 1.5859, 0.5326, 0.0925, 0.3293, 1.3635, 0.3396, 0.0677, -0.6739, 0.4084, -1.4487, -0.1101, -0.7521, -1.2118, 1.7191, 0.2020, -0.1573, -0.2298, -0.8230, 1.7924, 0.4511]; var y = [-1.4166, 1.353, -0.6294, 0.0567, 1.4157, 0.32806, 0.2377, -0.2262, -1.0602, -1.8150, 0.1075, -1.3516, 1.0137, 0.0183, -0.5466, 0.6416, -0.6655, 0.6874, -0.4616, -0.2808, 1.3443, -1.0518, -0.1332, -1.0097, 0.3643]; var index = []; x.forEach(function(elem,i){ index.push(i); }) Is this really the preferred method for making an array of an integer range in JS? I feel like it goes against some pretty beginner DSA principles.
That is correct. Browsers will download files in parallel, but he execution order is sequential, and from top to bottom, so jQuery will be defined by the time your own script is executed. Here is a deeper dive into that topic: http://www.html5rocks.com/en/tutorials/speed/script-loading/
That is fantastic, thank you very much for your help!
When that happens I usually create an npm package of it and open an issue on the repo asking if I should transfer ownership of the package to them.
Thank you. :-) I think using it to implement things like a custom spreadsheet could work. Maybe even creating a sort of spreadsheet type development environment. Maybe a new tool developers can use to structure their programs. Maybe help students learn about scoping by providing them with an alternate approach to scoping.
&gt; yeah, basically everything in javascript is an object. Unfortunately, JavaScript also has primitives. https://people.mozilla.org/~jorendorff/es6-draft.html#sec-primitive-value &gt; Undefined, Null, Boolean, Number, Symbol, or String (Note: Function isn't one of them.) Here is an example: &gt; var x = 5 undefined &gt; x.y = 'z' "z" &gt; x.y undefined What actually happens in that x.y = 'z' line: &gt; new Number(x).y = 'z' "z" It's auto-boxed. If you do the same with an actual Number object: &gt; var x = new Number(5) undefined &gt; x.y = 'z' "z" &gt; x.y "z"
You can write: 5..toString() Which is the same as: 5.0.toString() Anyhow, the only reason why you can call "methods" of primitives is because they are auto-boxed. The example above is essentially the same as: new Number(5).toString()
A better method is index.concat (×)
you should definitely eventually learn JQuery and perhaps some other popular JS libs. Whether or not that's the first thing you should learn is up for debate, but don't neglect to learn them. They're extremely important to know.
My recommendation? Learn regular js. Why? Libraries are good and all that, until something breaks. In which case knowing plan js will help u troubleshoot it much better.
Maybe you should consider learning from those libraries instead of prematurely judging them for being too mainstream. There is a lot of good things to learn from things like jQuery: http://www.paulirish.com/2010/10-things-i-learned-from-the-jquery-source/ http://www.paulirish.com/2011/11-more-things-i-learned-from-the-jquery-source/
D3.js data-driven approach to DOM manipulation. 
A year or so ago, I used [Quo JS](http://quojs.tapquo.com/). I was quite happy with it. But, now that [hammer.js 2](http://hammerjs.github.io/) has been released, I might have to reevaluate. [SVG4Everybody](https://github.com/jonathantneal/svg4everybody) is pretty neat as well. In case a client wants a carousel, I use [Slick](http://kenwheeler.github.io/slick/). Yes, carousels are usually a silly idea and it requires jQuery, but in there's still lots of use for it.
He's not judging them, they're just not the point of the thread. 
Hey, try Sly Carousel! You won't go back to Slick. 
That does look pretty neat. ~~How does it handle in IE8?~~ Not bad. Not perfect but not bad at all. Definitely using this next time a client demands a carousel.
It does. I used it here: www.sandicliffe.co.uk/configure/ford/focus 
Wow. That's exactly what I need. Thanks for that.
Definitely [async/await](https://github.com/yortus/asyncawait) for node. Together with [bluebird](https://github.com/petkaantonov/bluebird)'s Promise.promisify() feature. I wish more people knew about this way of handling callbacks, it makes code way nicer. And maybe [rx.js](https://reactive-extensions.github.io/RxJS/) or [bacon.js](https://baconjs.github.io/) or [kefir.js](https://pozadi.github.io/kefir/), or even the whole FRP paradigm. IMO not enough js devs are aware of it. edit: words
Omitjs, www.omitjs.com
I very much agree, it's too bad this isn't used more. The asynchronous and functional capabilities of this can make a huge difference. It can be composed much more elegantly than async imo. Streams can be seen as lazy arrays of buffer. This can be mapped to lazy arrays of strings. This can be splitted on newlines to get a lazy array of lines. This can be filtered on regex. Finally reduced to a data structure that is returned as a promise. I've used this to parse .mbox files that are multiple GB and it only costs me a chain of (lazy) array calls. Very little closures or named functions were needed.
lodash &gt;&gt; _, my 5 C's.
[Vue.js](http://vuejs.org) is like Angular written by reasonable people—really fantastic, fast MVVM implementation that's easy to grok
Raphael is great for cross-browser vector graphics, all the way down to IE6, and provides a great interface for generating SVGs in its own right.
I've been maintaining two for 5 years. [a document store](https://github.com/kristopolous/db.js) and an [event system](https://github.com/kristopolous/EvDa). Although this class of software is relatively common now, i wrote these half a decade ago because there really wasn't anything out there then. Still use (update &amp; maintain) them all the time.
First time posting on Reddit. Please be merciful.
Yeah, I actually use lodash rather than underscore.
I had the most success starting with JQuery and working backwards to the plainest possible javascript for performance. JQuery's learning curve is much lower and less discouraging than starting with OOP like the top-voted answer. Prototypes have been close to worthless in my experience and I've built a ton of shit.
That looks great! Thanks. I don't know why I didn't think of breaking down the updates like that, but putting the functions in an array never would have occurred to me. It'll be a couple days before I get a real chance to work again, but I'll definitely try this out. Thanks again.
Take a look at this reddit thread: “[ES6 any exhaustive list of its features?](http://www.reddit.com/r/javascript/comments/2lka17/es6_any_exhaustive_list_of_its_features/)”. The following three ECMAScript 6 resources are taken from an answer I gave there: * Kangax’ [compatibility table](http://kangax.github.io/compat-table/es6/) contains a list of all ES6 features and where they are supported. * My blog post “[Using ECMAScript 6 today](http://www.2ality.com/2014/08/es6-today.html)” gives an overview of ES6 and links to more comprehensive material. * The [ECMAScript 6 specification](https://people.mozilla.org/~jorendorff/es6-draft.html) is the definitive document for how ES6 works.
Bookshelf.js - http://bookshelfjs.org/ Excellent ORM for Node. IMO the polish and full-featured aspect of the library is what makes it shine. It's built on top of Backbone which is rather odd, but makes sense when you see how it's structured.
I know. For nonsensical hipster reasons and politics (imo) that I have very strong feelings about. There is absolutely *nothing* wrong with Sqlite/WebSQL at all. And the fact that they were able to whip up the IndexDB spec while arguing about this infuriates me (and a lot more people) Still, 4 years later, WebSQL is alive and kicking on millions of devices around the world, and i'm thankful for that.
The author's first language isn't english, thus the docs may not be the best. But it's much, much better now than a year ago ;) Just go here: http://webpack.github.io/docs/ An engineer at Instagram is sorta a proponent of webpack, he made this: https://github.com/petehunt/webpack-howto
How do you define a *standard library*? I love [Knockout](http://knockoutjs.com/) but don't know what category would it fall into?
I'm just getting into javascript seriously. I have a node.js project to contribute to. I come from java and am object oriented to the core. I bought Javascript the good parts to try and get a grasp of that "functional" buzz word. Callbacks are horrible to me right now. I love the looks of theses libs. Do you have some recommended literature on the way of handling callbacks ? 
I really cannot stress this enough. Ramda totally gets the functional approach. Underscore and LoDash are great, but they suffer from argument order issues (they're not curried, so you have to handle it yourself)
lodash seems to have add lazy evaluation, and are reporting better performance than even Lazy.js itself. It's yet to be released (e.g. npm): https://github.com/lodash/lodash/issues/274
Promises + generators with [suspend](https://github.com/jmar777/suspend) too. 
Here's an intro with promises: http://callbackhell.com/ https://blog.domenic.me/youre-missing-the-point-of-promises/ https://www.promisejs.org http://pag.forbeslindesay.co.uk
"Let me do some weird templating diagram because I like to waste my time" made my day XD
I love MomentJS. Dates *suck* in Java, and Javascript modeled its Date and Math objects off Java. MomentJS isn't based off Java and *doesn't* suck. http://momentjs.com
[ware](https://www.npmjs.org/package/ware) is a standalone implementation of the middleware pattern used in Express. It's a spectacular library for setting up reusable asynchronous processing chains. [asyncInterval](https://www.npmjs.org/package/asyncinterval) is useful when you have a slow, repeating action that you need to ensure doesn't overlap itself. The next interval doesn't begin until the previous one calls the done() callback. Finally, I think a lot of people don't know about [the commonjs build of lodash](https://www.npmjs.org/package/lodash-node) and the individual lodash standalone function packages like [lodash.assign](https://www.npmjs.org/package/lodash.assign), [lodash.curry](https://www.npmjs.org/package/lodash.curry) and [lodash.debounce](https://www.npmjs.org/package/lodash.debounce). It's really useful when you only need that one function and don't want to depend on the entire lodash library.
Everything on [this list](http://microjs.com/) because sometimes you just want to do that one thing and go outside.
if you like that humor, you may like my other projects such as [unreadable.website](http://unreadable.website) ... or, and this one is a hush-hush secret, the [frustrometer](http://frust.me). I'll get it fully implemented one day.
These are great :D
Oops. You're right. Then _.range (0, x.length)
I'm in the same boat as you are, and I am trying to learn vanilla as well as I can before moving onto libraries. I would then know what to do in almost all situations without being held back by learning a mismatch of libraries and vanilla.
I don't know what I'd do without Underscore.js and Moment.js.
Checking out asyncInterval now - awesome idea!
No. Javascript is barely an object oriented language. It is far simpler, more powerful, and bug-free when used in a functional manner. (See anything Reginald Brathwaithe has done). It *does* have object oriented features, but most things "OOJS" people do are just calls to global functions with a different syntax A big claim. Let's break it down. I think you'll agree that the following is a very common pattern function Person(name) { this.name = name } Person.prototype.sayHi = function(toWho) { return this.name + " says hi to " + toWho; } var p = new Person("Fred"); console.log( p.sayHi("Barney") ); Compare that to this way of achieving the same thing var p = new Person("Fred"); console.log( Person.prototype.sayHi.call(p, "Barney") ); Because of the way the `this`-parameter is implemented, it's not really attached to the object, its just the language taking guesses at what you want it to be. Since any method invocation in this style can be reduced to a regular function call that part isn't meaningfully different from just writing a regular `sayHi` function in the same scope as `Person`. function sayHi(from, toName) { return from.name + " says hi to " + toName; } console.log( sayHi(p, "Barney") ); The above observation reduces away anything in this example that prototypal inheritance contributes to a global function call. The only thing OOP-ish that remains is the `Person` constructor and the structured objects that this creates. But how is that fundamentally different from just doing the much simpler function getPerson(name) { return { name: name } } var p = getPerson("Fred"); it's not! Substitute this into the `Person.prototype.sayHi.call` or into my `sayHi` function and you get the same results. Simple function calls, and json object construction are something any beginner will learn anyways. So given that prototypal method calls can be reduced to the former and constructors to the later, and given that these are easily the two hardest concepts in javascript, why on earth confuse already overwhelmed students with these? But wait you say, how do you share properties between objects then? How do you make dogs that have the properties of animals? The answer is to use the concepts people already know. Properties can be easily copied between js objects. Every library out there has an `extend` method. I show how to implement one while talking about how objects are extensible. var dog = _.extend ({}, animalPropserties, {sound: "Bark"}); This is so much simpler than trying to explain how proptotype inheritance links things up. In fact, very few people really understand what exactly the `new` keyword does - I've interviewed maybe 70 senior developers in the last 20 months, maybe 2 of them had the full picture. Now that's not to say that there aren't *some* truly OO features in javascript. I believe both overriding methods via intermediate prototypes and `typeof` checks on constructed functions would qualify, but neither one of these is used regularly in day to day coding. They're important to know if you want to read through jquery source or write optimized algorithms, but otherwise you can push them off to the back end of the curriculum. 
I really like backbone-fetch-cache (http://madglory.github.io/backbone-fetch-cache/) for client side backbone model/collection caching. If you're doing a SPA with Backbone.js, you can just drop it in without much effort at all and you get really nice client side data caching. I'm always trying to get my SPA to be just a little more "snappy" :-)
Reference as many as you want. Just remember, less code is always better. Try to achieve your goals as clearly and succinctly as possible. My mantra: "do the simplest thing that could possibly work". 
Well first of all, you're trying to select all "space" tags, which won't work because there is no such thing. 
If you use Java's [Joda-Time](http://www.joda.org/joda-time/), Dates don't suck anymore.
There have been a few times where I have been using moment.js and just decided to try a syntax that "sounded right" in my head and it worked. It's really wonderful to work with.
[Stampit](https://github.com/ericelliott/stampit) - Simplifies the creation of types through composable behaviors. For example, Stampit gives you a simple way of reusing/sharing privileged methods between types, which can be tricky to implement on your own.
Also the Knex library it uses under the hood. Great for handling migrations etc. Those two together were a lifesaver for me - when I first started using Node and a DB I only found Sequelize, which I hated. Bookshelf is so much better.
No problem, once you start thinking functionally, programming in JavaScript really becomes a joy. It's like snapping together legos. Feel free to leave a response when you've gotten a chance to work on the code and I'll drop in for another code review.
[Knex.js](http://www.knexjs.org) -- it's a very well designed sql generation library. It works so well and is so clean and easy to use, I am finding I don't really need an ORM for my Node based apps. Speaking of ORMs, [Bookshelf.js](http://www.bookshelfjs.org) is by the same guy, and uses Knex underneath. My site uses Bookshelf and I like how easily I can gradually move more in the Knex direction. The two work together beautifully.
I think we need some more information such as the context and how the code is being used. I would like to see how the code is being used in the context of the page. Thanks!
[bean](https://www.npmjs.org/package/bean) for events when I'm not using a library/framework that provides event handling or I want an agnostic option [penner](https://www.npmjs.org/package/penner) for easing functions [raf](https://www.npmjs.org/package/raf) for a nice small wrapper/polyfill for requestAnimationFrame [crel](https://www.npmjs.org/package/crel) for DOM element creation [swig](https://www.npmjs.org/package/swig) for templating (similar to Django/Jinja templates) and hat tip [microjs.com](http://microjs.com) for when you are wanting to BYO framework and a shameless plug for [ScrollTable](https://www.npmjs.org/package/scrolltable) for when you need that sort of thing
If you make a sync operation return a promise, it becomes an async operation. My case study makes the assumption that there could be a lot of paths (and not just two) and that some of them are procedural. In that case, wrapping the whole condition is the most readable way I have found to manage things. WinJS already has two asynchronifying methods: WinJS.Promise.wrap which I'm using in the second pattern, and WinJS.Promise.as. The difference is 'as' will check if the value passed is already a promise and will let it untouched if so, and 'wrap' will always wrap the value, whether it's already a promise or not (possibly double wrapping it). I think that's really useful and lacking in jQuery or AngularJS implementations. So actually, you're right in the sense that you could factorize your procedural paths into functions and make them return a promise, but it's not really practical when you have code with just a couple of lines.
At the risk of looking stupid, why would I want to create an immutable data structure? When I'm in class using Java, immutable arrays are like, the reason we have so many hurdles in our assignments. 
var hours = today.getHours(); FTFY
The ES6 promise spec has a part about [Promise.resolve](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise.resolve) which will return a promise that resolves with the passed argument. You can find this already implemented in the [es6-promise](https://www.npmjs.org/package/es6-promise) library.
I came here to say this basically.
I'm thinking it's to remove the inconsistencies that you see in tests like these: (function(){ //==== NUMBER TEST ==== var x = 6, orig = 6; (function(a){ a+=1; })(x); console.log("Number:", (orig===x)?'unchanged':'CHANGED'); })(); (function(){ //==== ARRAY TEST ==== var x = [], orig = []; (function(a){ a.push(1); })(x); console.log("Array: ", (orig===x)?'unchanged':'CHANGED'); })(); (function(){ //==== STRING TEST ==== var x = "", orig = ""; (function(a){ a+="x"; })(x); console.log("String:", (orig===x)?'unchanged':'CHANGED'); })(); (function(){ //==== OBJECT TEST ==== var x = {}, orig = {}; (function(a){ a.x=true; })(x); console.log("Object:", (orig===x)?'unchanged':'CHANGED'); })(); ------------------------ //==== CONSOLE RESULTS ==== Number: unchanged VM295:5 Array: CHANGED VM295:11 String: unchanged VM295:17 Object: CHANGED 
knockout, moment, d3
Q, the promise pattern is very nice to work with, can clear up some messier callback logic in larger async applications. 
&gt;If you make a sync operation return a promise, it becomes an async operation Sync/Async doesn't matter, what matters is what the caller gets back. If the caller always gets back a promise, it is easy to work with and predictable. &gt;it's not really practical when you have code with just a couple of lines I don't understand what that even means. *Nothing* is a couple of lines, except for blog code examples... lol
Lobe love love moment js
Check this out for an explanation of the reasons for using immutable data: http://www.infoq.com/presentations/Value-Values (slides [here](http://gotocon.com/dl/goto-cph-2012/slides/value-of-values.pdf)) Basically, programming with immutable values is conceptually simpler, and once you get used to them, the guarantee of immutability helps a lot. It's much easier to understand code that uses them since you never have to keep track of what code has modified the data you're using. The flow of data is very clear and it's easy to tell what operations are being done on what data. As for ease of use, mori and many other immutable data implementations come with a wide variety of powerful operations that are often easier to use than mutating ones. For example, I can just write `var squares = m.map(function(x) { return x*x; }, myVec);` rather than `var squares = []; for (var i = 0; i &lt; myArr.length; i++) { squares[i] = myArr[i] * myArr[i]; }`. And it would be a pain if `map` used mutation because then you couldn't do things like this: var people = m.vector({name: 'Bob', job: 'Laundry basket'}, {name: 'Alice', job: 'Goldfish herder'}); var names = m.map(function(person) { return person.name; }, people); var jobs = m.map(function(person) { return person.job; }, people); // Not possible if m.map(..) had mutated `people` And that's barely scratching the surface. In particular, you can implement just about any common operation on lists using `reduce` without mutation and generally in a way that's clearer than using a loop. So you don't need mutation in the first place to do the operations you need to do on lists. Some similar functions are available on JS's mutable arrays, but mori's structures have many more supported operations, are more efficient for immutable operations, and have cool features like laziness and fast value equality checks. I can see it being more difficult in Java because of the lack of first class functions, but that's a problem with Java, not with immutable data. In the rare case that something you need to do can't be done with the provided functions, you can always do something like `while (&lt;condition&gt;) { myThing = operationOn(myThing); }`. In languages that support it well, recursion is preferable, since it means that you never reassign variables, which means that you never have to worry about whether the value of a binding has changed since it was created.
[RSVP.js](https://github.com/tildeio/rsvp.js/) Its a good promise library. Its A+ compliant with excellent performance. Its the best compliance/performance promise lib i know.
 var promises = []; items.forEach(function (item) { var promise = callToFunctionAsync(item).then(function(result) { item.someProperty = result; }); promises.push(promise); }); this is a classic instance when you need to use *map* and not *forEach*. 
Hey I haven't tried FRP yet but it looks really useful. Out of the three libraries you mentioned, which would you recommend for use in node.js? Looks like maybe kefir.js is the most node friendly of them? I'm always trying to find the one that's both good and kind of the de facto standard.
Yeah. It keeps callback hell in bay. I use it in every project
Here is yet another reference: http://sitr.us/2013/11/04/functional-data-structures.html Part of the explanation is that immutable data structures in mori, immutable.js, and in functional languages (a.k.a. "functional", or "persistent" data structures) are entirely unlike immutable data structures in Java.
https://github.com/mcantor/protosimple ... Nicer objects.
I use swig for server side templating in node, it's great for that.
As the author of MinJS, I was missing synchronous Javascript in all libraries. Also I was missing MVC the way Ruby does it. I think I did it right, but I'm not expecting it to ever become popular. I hope it will inspire you: https://minjs.org
Learn the async.auto method, never have callback hell issues again.
I think it just comes down to which one you like more. Look at docs and syntax and pick the one you like most. As far as I know, all 3 work perfectly fine both in browser and in node.
True. I use this for node v10.x: https://github.com/TooTallNate/gnode
If I need a simple lightweight EventEmitter on the client-side: https://github.com/primus/EventEmitter3
Does swag consist of a job and some cash? I noticed the companies current charting is from HighCharts. If you're looking for a different solution, I would only recommend d3.js. There are plenty of free libraries built on top of it, but none are best practice (nvd3.js, C3.js, dc.js). That being said, you're not going to get much out of someone just making a simple line chart if you plan to develop others as well. Two cents... All of these frameworks are scripted together and there's not much shared reusability between any of them. If someone actually took advantage of prototype or OOP design, it would be probably be a lot easier... but, yeah d3 is the way to go. Back to my question, you could fund somebody to make a new framework. There are plenty of ideas floating around, but nobodies consolidated any of them.
Hi, thanks for the feedback. I think the message on the page should have been phrased better and I already made a few changes to clarify and will add a few others in a short while. We already developed a cool framework for data analytics that uses Highcharts, D3 (I agree it's the way to go) and other components :) We started the challenge to see how developers treat a very basic challenge, plotting data in a chart on a page with the hope to learn about different techniques they use to store and query data and ensure our framework answers these needs. Our swag currently includes a T-shirt and stickers, no job offer or cash :) but hopefully one day soon we'll be able to have a challenge for a job opening :D
It makes me sad that the article doesn't show the native API calls. // http://caniuse.com/#search=promise Promise.all(promises).done(function() { // Continue... });
I concur with this. I switched from lodash to Ramda and never looked back. 
If you're just considering the 1:1 functions provided by a third party (i.e. map, reduce, filter, forEach...), the only gain you'll see is performance. LoDash in particular is faster because it doesn't care about sparse arrays. Personally, I find it cleaner to use the builtins as it's one less dependency I don't have to worry about. Less dependencies, less issues you'll have in the future. In you're case, you have to use a poly-fill, which is kind of a hack, so that doesn't totally apply... For now, I'd suggest third party is better. You also get a bunch of niceties for free by using them. But these are pretty core concepts of functional programming. So, in the future, it's likely the ES5+ implementations will adopt and outperform these solutions. Given enough people using a particular feature, it only makes sense for the language to support it in the end.
that's one way to use them :) I'd also note that asyncawait is still faster than generators (they have benchmarks in their repo).
If performance is an issue, native methods will never out perform lodash or fast.js because of the way they're spec'd. Further, you may find it's more useful to have map/filter/reduce functions that take a flipped argument signature (callback first, data second), because you can do great stuff with partial application. However, it's not hard to do this without a library: function makeFlippedIterator (fn) { return function (cb, arr) { return fn.call(arr, cb); }; } var filter = makeFlippedIterator([].filter); var filterOdd = filter.bind(null, function (n) { return n % 2; }); filterOdd([1, 2, 3, 4, 5]) // [1, 3, 5]
Momentjs is one of the best date implementations in any language and it's built off what's, easily, the worst core date library. Impresses me every time. They just need to update their site so you can generate the TZ data again (went down when 2.0 came out). 
KISS: keep it simple stupid. 
Personally I have to agree with your coworkers - browsers are getting a lot better about following standards (IE being the laggard, of course), but when the choice is to have the same functionality implemented several different ways, including potentially multiple polyfills, or to have a single library that you can rely on to perform operations the same way every time, the latter is a lot easier to build to and maintain, which is why the approach has become so popular. I'd choose lodash every time, right now, but over time hopefully it will become less necessary.
+1. We use lodash instead of native as most perfs we've looked at show lodash out performing native APIs
Would you add lodash to a solution just for map/reduce/filter? 
Isn't JavaScript just a beautiful language?
I'm a big believer that catching problems and fixing them right away takes only a fraction of the effort as digging through layers of kludges built on top of kludges. That's why I built rtest to allow websites to be easily scanned with a totally open-ended set of rules. For everything from functional testing to SEO, It makes it unbelievably simple to check for things like errors responses, headers for cacheability, and even testing the body using jQuery selectors for proper meta tags, headings, page sections, etc. It can even be used for site scraping and data collection. Adding rtest to your continuous integration process allows you to keep tabs on indicators that there might be issues around the clock. Oftentimes, small details that are difficult to detect visually - like a missing cache header or a SetCookie header coming back from the server on a page that is supposed to get cached - can be indicators of code quality issues. It can be tough to have every line of code reviewed - but, while not a substitute for reviews, rtest can at least help you catch issues early and close the loop by providing feedback to developers in a timely manner that helps them learn to follow best practices.
I've switched from lodash to Ramda.js because curried functions http://ramda.github.io/ramdocs/docs/with proper ordering allows me to work in a more point-free manner when dealing with data. Unlike underscore/lodash, Ramda is made for functional programming. http://ramda.github.io/ramdocs/docs/
https://docs.google.com/document/d/1dZdq2L8EkzimgvU93ypLF9GJpdzD2jjm08Zal6sfxMQ/edit?hl=en&amp;forcehl=1
Native map/reduce/filter methods are actually surprisingly slow compared to libraries like lo-dash and underscore. Try running some of these jsPerf tests to see for yourself: http://jsperf.com/lodash-underscore-and-native-filter http://jsperf.com/lodash-underscore-and-native-reduce http://jsperf.com/lodash-underscore-and-native-map http://jsperf.com/lodash-underscore-and-native-each Performance isn't everything with these things, context matters. But if you're already pulling in underscore/lodash/whatever, it can be nice to get the added performance as well as the niceties of still working in IE8. 
Depends who you ask. I personally would rather polyfill things like requestAnimationFrame, XHR, array map, Object.defineProperty, etc so you can use native builtin methods. The performance is a moot point in almost all cases. In those exceptional cases you might choose to use a library, but it's kind of nuts that you need to bring in 10kb+ of a dependency just for one or two functions. (Thankfully lodash is modularized into small components on npm)
It's a wonderful API, but I've had some performance problems in the past when I've used it before. Wonder if they've done any work to address this lately.
I don't ever think I've seen a developer quote w3schools as their favorite learning resource! 
Wow, I never realized that css is all about globals. Makes me even more excited for custom elements and shadow DOM!
If you want async/await in the browser, you can use traceur --experimental which will make it a language keyword (function modifier), much closer to C# since it seems to be the same compiler transformation. https://github.com/google/traceur-compiler/wiki/LanguageFeatures#async-functions-experimental Side it works in both browser and node, it might be preferable to a node-only solution for some.
is there an video of the talk aswell? looks intersting
+1 for Ramda. Works especially well with [fantasy-land](https://github.com/fantasyland/fantasy-land) based libraries.
I'm building off an experimental test of a suite of different algorithms that found that these quintic splines performed best for analyzing animal locomotion data. The paper I'm using is here for what it's worth: http://jeb.biologists.org/content/201/7/981.full.pdf+html
Create a pollyfill that uses lodash to implement the functionality. The thing I like about native functions is that you can chain them. This is useful if you are performing a set of operations on an array. However just looked at lodash docs and they do have a nice chain function in there which looks like it allows for this.
I made this: http://chineselanguagetools.com/map/index.html
I think everyone used it at the start of their delving into Web Dev purely because of its search results position. There are many better learning resources although I do think they fixed a lot of the mis-information on the site. I still have never heard someone talk about it as a favourite reference for learning. There's a small side of me suspecting some sort of advertising going on, but I don't care that much about it to look into it further. Just thought it was odd that this resource out of all the possible choices was mentioned. 
Previously: http://www.reddit.com/r/javascript/comments/2lb3zh/lokijsbased_inmemory_db_for_node_browser/
I believe that there was a degree of irony or sarcasm in tone which was not translated into the speakerdeck caption. My take was that his point was that not using global variable was *such* a basic and fundamental best practice that even w3schools got it right. I could be very wrong, of course, there's no clear evidence one way or another. But that was how I heard it.
Right, I kind of got that vibe but now I wonder what the speaker's intention was :)