The logic is the same regardless of language.
That is a valid way of handling one-time event. The `onload` handler is executing a function where the `onload` handler itself is being removed so that the function only gets called once.
If this works on a dev build and not on a production site, try doing a development build on the server itself (`NODE_ENV=development npm run build`), and see if the problem still exists. If there is no problem with dev build, then there is an issue with the module bundler you are using for the production build.
Yes it is, but is there any use explaining DLL to a person who already knows how objects works in JS. What has this person learn't?
Yes, because learning how to apply logic to a useful purpose can be abstracted upon.
A JS user would never use a DLL, but a C user will. C has a problem that is fixed by DLL, JS doesn't have this problem (as it is a high level lang and has dynamically extendable objects). So explaining a low level concept in a high level language makes no sense.
It’s practice, man. Just practice. The logic is the same, it doesn’t matter if you’re going to use it. BigN companies still ask DS questions to front end engineers, even though those engineers will never need to make them from scratch. It’s not about practicality.
I don't have any experience programming in Acrobat, so I don't know exactly how that part of it works, but here's an easy way to accomplish this in JavaScript. Set the values of your checkboxes, starting at `1`, to be double that of the previous checkbox value. So `MON = 1`, `TUE = 2`, `WED = 4`. Next, make a dictionary object that maps the various sums to their correct values: const costs = { [1]: 120, // monday [2]: 120, // tuesday [4]: 120, // wednesday [3]: 180, // mon + tue [5]: 180, // mon + wed [6]: 160, // tue + wed } And finally, sum your checkbox values and pull the correct value out of the `costs` dictionary. ``` costs[sumOfCheckboxes] ``` If you want to do some behavior other than receiving `undefined` if the summed value of checkboxes (for whatever reason) doesn't exist in your dictionary, you could wrap this in a function that either returns a default value or throws an error or whatever.
One major new development is Microsoft putting their weight behind React Native with their rewrite of Office 365. This has implications in both the mobile and thick client spaces and proves to be an interesting year ahead for native development.
Battlefield 1 also does this.
Hi /u/theJakester42, For javascript help, please visit /r/LearnJavascript. Thank you!
Try hotjar. Not open source, but there's a free plan for low traffic sites.
&gt; I get 4fps You should not be getting 4fps. What does your app do?
Suggestion to whoever created that site: add an “about” page where you briefly explain who you are (unless you deliberately want to stay anonymous).
If you want to practice DS (like DLL), then do it in C. But they never ask DS questions (like DLL) in JS! Yes its not about practicality, its about understanding the basic working of a computer at the low level.
That's not the way I would solve this problem. If you're leveraging augmented reality, bluetooth, machine learning, etc. in your app consider going Native, but don't rule out React as you have an opportunity to bridge those libraries. If you're building a frontend for API services, which is what most apps are, you should probably go with React Native. If you've building a game go Native.
I mean, if you're using javascript you should probably be familiar with most of the useful prototype functions for Array.
I’ve been to BigN interviews and was asked to implement data structures in any language of my choice. It doesn’t matter about the inner workings, because C still abstracts over ASM which abstracts over binary. You are clueless.
Hi /u/Wondercuddles, For javascript help, please visit /r/LearnJavascript. Thank you!
Regarding the "native components" issue, this looks fairly [covered by Cordova](https://cordova.apache.org/docs/en/latest/guide/overview/#architecture), but I could maybe see some issue with UI elements. But to address the native UI issue, what about [Ace](https://microsoft.github.io/ace/) or [AppGyver Supersonic](http://www.appgyver.io/supersonic) (or something else)? I can't imagine the native bases aren't really covered well enough to negate this issue fairly thoroughly except for perhaps VR/AR components (ie, being in an early stage)...
It must be something you're doing. I've been using React Native for a year and a half and have never had noticeable differences in performance between the two platforms. I will say though, it's always felt like Mac/iOS emulator is generally less buggy when debugging
Performance can definitely be so-so, but 4fps sounds extreme. Under what conditions does it drop that low?
Can’t talk specifically about game library support in RN, but I would be very wary about running anything as potentially intensive as a game inside of a WebView. I’ve built apps in both and without a doubt RN kills Ionic and co when it comes to straight performance. That said, I have heard they’ve got a lot better and can even run at 60fps now.
Is there any production code anywhere that looks particularly good?
Is the game itself also written in react? That would explain the performance...
Will do!
There are a number of game libs coming up for React now and even found a React Native Phaser lib, which was really intriguing. At the end of the day, if Cordova can achieve high enough performance, it might make more sense to just keep it all in a single codebase vs dealing with a React + React Native version of the app.
On average how much does a position like this pay?
I made a rather simple Cordova+Vue app last year. Performance was absolutely terrible, even for simple actions like switching tabs (no animations either). Considering that Vue is more lightweight than React, I would guess that Cordova+React performs even worse. Maybe I did something terribly wrong, maybe Cordova has gotten much better in the last year, but I will probably never touch it again. Switched to React Native and it's been much better. IMHO, the only reason to use Cordova is if you want to make a cross platform app but don't want to learn a cross platform framework (React Native, Flutter). But React is pretty similar to RN so I don't see much of a point to Cordova+React.
Yes. Declarative &amp; functional. At least that is the trend now. (And it’s fucking great)
How do you suppose people come by that familiarity? Certainly they aren't born with it. Perhaps they read documentation and articles.
okay?
JavaScript is an incredibly flexible language that will help you learn programming fundamentals. These skills are universal in basically every language and can easily be ported by learning some (slightly) different syntax. JavaScript does have some shortcomings, especially around type systems, but your CS courses will be sure to round that knowledge out for you. 
Perhaps, but I think jQuery has a lot more overhead; in the few months when I was learning JS and I would include jQuery in most of my projects, I never once used the utility functions, pretty much only the base `$("").*()` methods. Sure you could make a custom build, but then you don't get the benefits of a CDN and it's just... ehh. React, however, has so few base methods/other stuff that you're pretty much gonna use everything in the library. jQuery providing a custom building process is kind of an excuse for having a too-broad, unfocused library.
I have always been curious about the scenario when you are required to have a mobile app and a mobile web site. Would Cordova be a better choice? I am assuming you could share the same codebase, unlike RN and React Dom.
Gio.js is an open source library for web 3D globe data visualization built with Three.js. What makes Gio.js different is that it is simple to use Gio.js to customize a 3D data visualization model in a declarative way, add your own data, and integrate it into your own modern web application. More information: Github Repo: https://github.com/syt123450/giojs Official website: [giojs.org](https://giojs.org) Codepen online demos collection: [https://codepen.io/collection/DkBobG/](https://codepen.io/collection/DkBobG/)
Yes, I understand. I am approaching this from front-end angle only, hence usage of that word that would best describe what I am trying to achieve, although I understand the invalidity of that word within this context. Dynamic code loading - that's exactly what I was looking for. Thanks! 
What kind of scenarios it is the best use case for D3?
Well this has me concerned because I was thinking of going with that same tech for my next app. Currently I have used jQuery Mobile and Cordova and its run butter smooth even on 5 year old tech so maybe its something up with the Cordova and Vue combo? Switching tabs(with animations) has never caused performance problems, I did get some slow css 3d transformations on older devices though. I'l give Vue and Cordova a try but I'm going to be really disappointed if it cant even switch tabs.
&gt; A JS user would never use a DLL, but a C user will. Just because you don't need it, doesn't mean noone does. I've already used DLL in the past to build an LRU cache in JS. It's good to know how various data structures work and JS is a great language to teach them.
So you've been working on ospec lately? Did you follow the recent developments in the Mithril repo?
juicy
Author here: very interested in feedback (positive, negative, etc.) when you try it out!
True, its not that hard but I can imagine that after some hours working on an issue you simply want it to work so you can go home haha.
Agreed, I enjoy working with React much more than I have with other UI libraries.
Very nice. Love the documentation.
When you have data that needs formatting or processing (histograms, maps and more complex data visualizations). No other charting library comes close to the flexibility with data imo. For simple charts that aren't super interactive other libraries like Chart.js are easier to setup (and nicer looking out of the box) but falter when you need to start customizing things and working with more complex data.
Fuck that guy
Yeah, let me rephrase; i just think this should have been taught with the other ones, not just this individually; a lot of people migrating from other languages still don't use these as much as you'd think because they've always only used for/while loops
great docs; for someone experienced with this sort of stuff, how does this library compare to say something like greensock? 
A great exercise: implement all the Array methods using only reduce() 
Cordova + React could yield a cleaner code base in theory than React and React Native, especially when it comes to integration of other JS libs... I'm also shocked with these performance problems. I think we will need to really dig in and see where the issues are coming from if we go down this road with a couple of tests first. From what I can tell both camps here are saying there are performance issues (BOTH Cordova AND React Native), so it seems there's no silver bullet and we need to figure out what really offers the most clean solution while still providing (more than) acceptable performance... 
I had to choose between Anime and GSAP on a project I’m working on right now and in the end I went with GSAP purely because I needed IE9 support. Seems to have the same feature set as GSAP, not sure if it fixes the browser inconsistencies for SVG though.
Then again, they pushed quite heavily for Silverlight (for those old enough to remember).
Nani desu ka? Sugoi!
Not only does the functionality look to be very useful, the documentation in this repo is exemplary.
They must have had some animations on their switch. Running a cordova style app at the moment and there’s been no lag switching tabs.
It makes a big difference to my app, if my app is the one using it, or the OS is the one using it. If my application can make use of the available memory to give you a better experience, then I want to be using it. Being stingy about specific applications using their memory is stupid. Yes, your OS will use it for *something*, but that's not relevant to the application that is using it for a specific purpose. 
Daaaaarrrrrttttt. 
&gt; Yes, your OS will use it for something, but that's not relevant to the application that is using it for a specific purpose. What do you think OSes do with free memory lmao?
.... use it for something that isn't likely particularly relevant to the foreground application. If you're not at memory overload, then don't worry about how much memory your browser is using. 
Name is confusing as hell.
I want to echo the other voices on here about app quality. If you don’t have the time, money or devs, either cordova or react native will do the job. I spent quite a long time researching whether I should move my company’s webview based app to react native, but couldn’t see how it was worth the cost. It tries to be as good as native but doesn’t quite get there. If I was writing a new app today, I can see why people would choose it over webviews though. Here are some of my thoughts of React Native compared to Native Native: * no long term support has been pledged and JS frameworks have a lifespan of a few years (imagine if there had been a backbone-native framework!) * the jank in animations * the loss of speed and threading * the weird CSS thing that will probably have to be changed every time apple or google do a facelift (RN will render native controls - it will not render native *looking* controls) * the hundreds of small, niggly little things you never think about, like the fact that the back button has to be specifically added in * the overall poor quality of community libraries compared to native * the fact that you probably have to write some native code anyway and then hook it up * the bad error messages * the added complexity of using an abstraction layer * fucking javascript 
Fair enough. If you can though, I would always opt for fully native for a game
Because there's no such thing as "zero config" for a big project. Anyone that uses moment.js probably has a config to not ship all its locales, for example. That's just one common customization out there that isn't possible with "zero config". Zero config is about helping people get started. After a while, you end up having to customize your build.
I have a feeling it has to do with this: https://v8docs.nodesource.com/node-0.8/d3/d95/classv8_1_1_handle_scope.html However Im not sure if it's storing a new function object and trash collecting the old one, or it maybe is modified in place, but that probably has to do with the heap, and I dont know heaps because javascript has handled that for me.
Best bet is to go with a linter with built-in fixers, such as eslint. Prettier has configuration options if you want to do anything outside of set a line width or a indentation size, you're out of luck.
By 'major' I did not necessarily mean 'big', I meant libraries that are heavily used by others. Even new projects which are not small projects are base don Webpack 3.0. The rest seem to be struggling with the upgrade to 4.0. This seems unusual to me given that 4.0 was released many months ago. It feels like Webpack is trying to quickly implement what Parcel is offering, and it feels like there is a lack of leadership.
Slightly different, silverlight was developed by Microsoft and closed source. This is a very large open source project.
Would you say D3 is earlier to use or Chartjs?
This is really cool. How much control over the planet contents do you have? Is there any way to use this for a non-earth planet, or to control the contents/continents?
I've been meaning to look through this for ages. Seems incredibly easy to use. 
I disagree, migrating to we pack 4.0 was a snap for me and I had 5 different configs, two of which bundled for ssr on a java stack, I don't imagine things getting much more complex than that. If people haven't migrated, they probably just don't see a need.
The libraries commonly used by major tools were developed in an ecosystem where 0 config wasn't a thing. For example, sass requires a ton of setup and probably always will because it adds new file types. Styled components needs no config and will work out of the box. Old apps can't switch, but I for one would never waste time configuring sass in a new app. Libs like moment, lodash, and rxjs that need config to be reasonable are also slowly becoming less useful as es6+ features arrive. There's even an observable class proposed by tc39 right now. Facebook is working on killing codesplitting config as we speak. The last bastion of config appears to be type systems, and Even that is a shrinking problem as everything is moving to default Babel support. Basically, old tools didn't know to take advantage of 0 conf as a feature, but new ones do. New apps will be the primary beneficiaries of 0 conf settups because they won't invest in tools that require configuration. 
Which is why currying is useful. Curried functions, in the form of const sum = curry((a, b, c) =&gt; a + b + c) Makes all of the following equivalent: sum(1, 2, 3) sum(1)(2)(3) sum(1)(2, 3) sum(1, 2)(3)
This is an interesting remark and thanks for these thoughts. On the long term support point, I think with Microsoft being behind it (this doesn't seem like other MS supported endeavors I've seen since it's a major product being built atop it and represents a considerable long term investment that has a monetization model backing it - not like Silverlight or others) is a really good thing. I hate MS, but I like this signal of good will and long term presence. It seems that we may be seeing some performance benefits in the not-too-distant future with WASM coming in strong. I could see some things in the speed arena being resolved, especially with this new blood of MS. We'll have to run some tests to see where this shakes out. Phaser makes things pretty nice. (pssst - I'll let you in on a little secret that I didn't want to mention at first - we're doing all of this via Ruby: Opal + Hyperloop + opal-phaser. *It's pretty awesome.* Our goal is to have a 100% isomorphic stack in Ruby (Roda for now on the middleware with Sequel and maybe ROM) that allows devs to use JS or Ruby to their heart's content.)
Entirely depends on use case. If you're making a relatively simple chart, go with chart.js. If you're making a more complex chart or data visualization but something that's still a common chart/graph type, go with plotly.js. If you're making something entirely custom to fit and showcase a specific data set and its features, then use d3. It's a fantastic library, but does have a learning curve and requires a fair bit of setup.
Right, if it were **only** a game, that'd make sense, but it's got more going on and requires a very strong UI/UX foundation that goes past pure game requirements. And long term support / maintenance and building out further is super critical vs current game models where you kinda build once and then just fix issues and work towards a next version of the game.
I assume you meant "easier to use". The answer to that is god no. chart.js wins in that case. While I don't think chart.js is built on top of d3, think of it like that. There are libraries for graphs that are built on top of d3 that hide away the complexities and robustness of what it can do, so you can easily get up and running. d3 is used if you need fine grain control of a chart, everything down to the axis locations.
How "useful".
Interesting stack! You like to live outside of the mainstream! I don’t think app developers have any trust in facebook after they dropped Parse - a framework that 600,000 apps were built on. Both Apple and Google update *their* frameworks pretty often, and frankly building a framework on top of these is like building on shifting sands. It will be a huge cost to keep up. If facebook end up giving up, no-one will have the resources to replace them. The fact that Microsoft built a library for it for Windows is pretty cool, but I still doubt that React as a framework will even be mainstream in 5 years. I really think something even better will be around by then, but mainly because I am pretty unimpressed with react when compared to native frameworks. It is better than previous JS frameworks though. They don’t call it javascript fatigue for nothing. WASM will do nothing for react native by the way. That is a tool for avoiding javascript entirely. The performance concerns I mentioned was about the fact that you only get two threads in RN - the main thread and the JS thread. I’ve built apps that have used 16 threads simultaneously that just wouldn’t have worked in RN. It’s pretty standard in native apps to push things to background threads, and async function calls don’t make up for that - especially when half the RN libraries out there use the JS thread to do stuff like animations! Sacrilege!
Yeah found out about the config and it worked pretty well. My only concern was tab size and it is fixed now.
Thanks. We expose different types of API to control Gio.js globe, for example, color, brightness, init country, data line type, callback function, and so on, for more detailed information, you can check out Gio.js API documents: [http://giojs.org/html/docs/index.html](http://giojs.org/html/docs/index.html). Unfortunately, as Gio.js is based on earth, it can not be used to visualize other planets so far. However, visualization continents is an amazing idea, we are interested to add this functionality to Gio.js.
The only valid answer.
Re: WASM, yes, I agree that it won't do anything for JS proper... I'm talking about potential React-WASM which would (in theory) replace React while still giving the old code base new breath. Never heard of such a thing, but I could see something like that happening. The problem we're going to have in this particular use case is that we need the web platform to be as performant as the native platform... Thus if we are taking advantage of 16 threads on the native and cannot do that on the web, then we're pretty much SOL as they say. 
Great answer, helped me a lot. Do you mind to elaborate on or point me towards your point on FB killing code splitting? I’m interest in what alternatives might be 👍👍
I just copy my webpack 3 config between projects because I know how it works and don't have to spend time figuring out how to upgrade.
You also got me thinking here... Could Napa.js be utilized to add multithreading to Cordova? Has anyone looked into what it would take? I don't see any chatter so far, but that doesn't necessarily mean it's impossible...
Webpack 4.0 comes with breaking changes, your config file might use plugins that are not supported by 4.0.
I like this approach. d3's JQuery-like API was always weird to me. I never understood why you \`select\` an element that isn't there to start things off And no matter how many times I've used it, when I go back, I forget what \`enter\`, \`update\` and \`exit\` really mean and I have to go back to the docs.
What is the problem this lib solves? What is the alternative?
Default parameters and variadic functions are considered counter to the functional spirit. But JavaScript doesn't include any static type checking, so failure of the checker to understand curried functions is the fault of the type checker itself, not a fault of the language or how it is used, but iinm last I checked typescript has type defs for the entire ramda lib whose functions are all curried. With regards to type checking, you can, in a way, say that currying enforces functional arity, since a curried function will only return another function until it receives the number of arguments it requires. Please understand, we're talking about *style*. Functional programming is a stylistic choice, and there are trade-offs with it as in everything. If this style isn't for you, that's okay, JavaScript is a multi-paradigm language.
I understand this is about style. But we are engineers, not fashion designers. We should not be a slave to styles, but talk about hard benefits and hard negatives. In this case the benefits seem quite modest in practice.
Webpack 4.0 zero config is a lie. The zero config model applies to only contrived use cases, and 99&amp;#37; of real world ( or even toy use cases ) will demand a custom config. And there's nothing wrong with that. Just accept that webpack is a hideously complex beast, and spend the time to learn it properly.
Pretty sure `vue-cli` v3 is using webpack v4 to bootstrap Vue applications. :)
To be fair, the author is French. "Animé" is French for "animated." "Dessin animé" is closer to cartoon (animated drawing). Although I get what you're saying, because I thought the same thing too.
Good thing you asked- I accidentally combined a couple things I read last week- whoops. The import thing is actually from Google and the chrome team with the new dynamic import native support, which could in turn make dynamic importing easier for webpack, Facebook, Google (angular) etc. In tandem with http2 it could be really cool. I was just looking at how that might impact react development, hence the facebook mixup. Sorry for the confusion.
I did, but it was closed source. Upgraded 2 -&gt; 3, then thought "fuck it" and checked to see if 4 would be too painful. Ended up deleting about half my configuration with the upgrade, AND getting much more effective code splitting out of the box.
A lot of what you describe is provided by a good IDE. The only benefit is catching typos at compile time, but this is also mostly covered by a good IDE. Also, I find this results in my paying closer attention to what I'm coding. FWIW, I would never build an "App" using jQuery. jQuery is a tool for working with the DOM, not for building applications.
Gatsby 2 just got released with Webpack 4. Create React app uses it, so does next js. Those are some of the biggest React based projects in existence so I wouldn’t say adoption is that slow. People have to see how it performs and acts in practice before risking a projects credibility. 
The biggest reason appears to be that Webpack 4 is essentially a completely botched release. There are docs on there that still have not been updated for Webpack 4. A good example is caching is still about Webpack 3 and not about Webpack 4. Another one is that the replacement for extract-text doesn't support HMR, so you have to use something else in dev mode.
it's not *good* zero config. they rushed it, they fucked up. the team has said as much. contribute to the fix, or just be patient, they're working on it.
I really like this, thanks for sharing! I liked it enough I published a \`vue\` plugin to use it properly, the existing one I found only supported a custom element so this version adds a \`v-anime\` directive. Check it out: [https://www.npmjs.com/package/vue-animejs](https://www.npmjs.com/package/vue-animejs)
hi! fyi gatsby v2 isnt released yet. still in beta. but do let them know any issues you find!
Is there any good reason to use moment.js anymore?
Oh no, this was for something unrelated.
Because Moment.js is battle-tested and I have more important things to do then research some new date libraries and hope switching doesn't introduce obscure bugs.
``` Math.floor((Math.random() * maxNumber) + minNumber) ``` this line is wrong, if Math.random() === 1, the value generated is (max + min), it should be ``` Math.floor((Math.random() * (max - min)) + minNumber) ``` how unique are the values you want? as you are generating floats, it is unlikely you get the exact same number in the first place i.e. you can get [5.0001, 5, 4.999, 4.999999] which are technically all unique you need a function to round off the float to a certain precision and compare them
What’s wrong with the built in JavaScript Date object though?
Our dates are stored as strings and our users have control over the format of that string. Moment lets us read and write to different formats, convert timezones, etc. Maybe that's possible with the built in Date class, but it wasn't when I last checked so my previous statement still holds.
Yeah, when I think of zero config I think of Parcel, which first popularized the term for module bundling by literally being zero config, my opinion is that the webpack team seemed to latch on to that idea and IMO co-opted it because it reflected a very valid and true criticism of webpack that Parcel address head on. Webpack’s zero config is barely that in practical execution. It would be much more effective of them to compare a decent webpack config to the equivalent in grunt or gulp so new comers could get a better appreciation for more modern build tooling. I bet people would better understand the role of a webpack then. Don’t waste time going tit-for-tat with every other tool out there: embody your goals and values and just work towards it. Those who see the value will follow along willingly.
It is possible with the built in Date class, but I guess if it's something that you are needing to maintain then it makes sense.
I agree, this does seem possible.
yeah those docs are killing me. still can't get HMR to work. 
It's definitely something I'll keep in the back of my mind. We still do use it for the `fromNow()` function too. Would we have to re-implement that?
JS Porn
I don’t think there is any easy way to implement a isDayLightSavingsTime function without moment or some hack. 
My main job has a product used by a company in Hawaii (GMT - 10) for customers in Guam (GMT + 10). Our test environment is served up from EST5EDT (GMT - 4/5). Presented times need to be in the company profile time, not the device time zone. With Moment Timezone, this works with a *single setting*.
[https://medium.com/@macleos/getting-started-with-typedown-1c2e13165bd3](https://medium.com/@macleos/getting-started-with-typedown-1c2e13165bd3) A new Markdown-esque dialect with... well, read the article to find out more. Anyway, the compiler is fully written in Javascript, as is the text editor mentioned at the end of the article (and when I say written in Javscript, I mean it, it doesn't use any pesky contenteditable apis - or even contenteditable itself - just pure, perfect Javascript)
How about a more practical example of why currying is cool? Imagine you have some chain of array methods: const x = list .filter(f) .map(h) Now imagine you have some other function `h` you need to apply to the entire array in-between `filter` and `map`. The typical approach is often something like: const x = list.filter(f) const y = g('abc', x.map(h)) But if we use curried versions of `filter`, `map`, and `h`, we can: const x = pipe([ filter(f), g('abc'), map(h), ], list) And with the proposed pipeline operator that's currently stage-1, an even less noisy version is possible: const x = list |&gt; filter(f) |&gt; g('abc') |&gt; map(h) Compare how similar this is to the first example above. This style of programming lets you "chain" functions together the same way we do with array and string methods, but with any arbitrary functions, not just those available in the prototype. Currying is pretty crucial in this kind of 'pipeline' programming. 
&gt; Anyone that uses moment.js probably has a config to not ship all its locales, I need this, you have an example?
Honestly Webpack 4 is really great and easy to understand. If you understand at all how your Webpack 3 config works, upgrading to 4 should be a breeze. We moved my company codebase to 4 (it has been through the rounds... require js back in the day, gulp, then Webpack 2 and straight from that to 4) and it only took me about 45 minutes. If you had any questions I wouldn’t mind answering.
Thanks for the offer, but this config is just for the various libraries I create. I don't really need much, my config is about 30 lines. It just builds a ts project, one file in and one file out. If it were for a bigger project I might care more.
The largest breaking change was the CommonChunksPlugin which seized to exist because Webpack 4 has it built in. Another pain was CssTextExtractorPlugin, it has recently been upgraded to work with Webpack 4, I ended up switching to CssMinifier (I am not positive on the exact name since I am on my phone, you get the gist) and it works great. 
Can confirm and it’s incredible, build times are a fraction of what they used to be
Why would you not use it? E.g. for parsing a datetime string in an arbitrary format, printing a datetime in an arbitrary format, conversion between time zones, etc.
For what it's worth, our bundle sizes dropped drastically after upgrading to 4, I assume because of better tree shaking support. Probably a good 33% reduction. https://github.com/jasonraimondi/webpack-4-typescript If it helps, here is a Webpack 4 config with babel + typescript, scss + purgecss with autoprefixer. The CSS compilation could easily be removed and left with the typescript compilation only.
If I wasn't too clear on this, I'd be happy to clarify.
I created a project with vue-cli a couple of weeks back and it's using webpack 4.8.2.
There's no good looking datepicker modules that use anything other than moment.js so you're kinda "forced" into it a lot of times.
Because it's quite big and newer libraries like date-fns cover a lot of its use cases.
That's not a great solution because you have a `while` statement that's going to take longer and longer to complete as your array fills up. What you want to do is create a sequential array of 50 numbers, then shuffle that array. I've needed both of these utilities so here are some helper functions I use: /** Generate a sequential array of numbers */ function range (start, end, step = 1) { const size = Math.ceil((end - start) / step) if (size &lt;= 0) { return [] } const a = new Array(size) for (let i = 0; i &lt; size; ++i) { a[i] = start + step * i } return a } /** Given an input array, return an array containing those same elements shuffled in a random order */ function sample (arr, size) { if (size == null) { size = arr.length } if (!size || size &lt; 1 || arr.length &lt; 1) { return [] } if (size &gt; arr.length) { size = arr.length } const result = new Array(size) const a = arr.slice() for (let i = 0; i &lt; size; ++i) { const r = Math.floor(Math.random() * a.length) result[i] = a[r] a.splice(r, 1) } return result } const randomArrayOf50 = sample(range(0, 50)) Just keep in mind this uses Math.random and floor so the "randomness" isn't great. Good enough for casual randomness, not good enough for pro gambling software.
Make sure to accept HMR in your Root component or in all your entrypoints if you have multiple :) if(module.hot) { module.hot.accept(); }
 Built in JavaScript date class is good
I like codefights. I’m not familiar with many others though. Hopefully this question will get more attention
You've never tried writing software that works in more than one time zone and country before, have you...
@thelarkin
Github link 404s
Try them all. Other good ones include Project Euler and r/dailyprogrammer.
Thanks on it.
[https://www.youtube.com/watch?v=-5wpm-gesOY](https://www.youtube.com/watch?v=-5wpm-gesOY)
That’s from 2013, there have been updates
I’ve been working with anime.js for a project and it was amazing! It also works really well with React Refs. What i liked about anime.js is the fact that you can separate your animation module from your components in an elegant way so the animation logic does not infer on your presentation logic. Super easy to use and understand! Big thumbs up!
I work on software that works with other time zones almost exclusively
Try using a relative path like ./phaser.js
bingo. every-single-project I add babel-polyfill, babel-loader, html-webpack-plugin. So that makes my webpack.config.js non-empty ```js module.exports = { mode: 'development', entry: [ 'babel-polyfill', './src/index.js' ], // plus more } ```
Hi /u/fferreira020, For javascript help, please visit /r/LearnJavascript. Thank you!
Thank you very much for your replies /u/jonvisc /u/mrahh 
You could try the problems from competitive programming 3, in UVa Online Judge (you can access them from uHunt to check your progress and classification of problems too). Also, CodeForces but if it's explicitly for interviews then give CodeFights a try, it's good from what a friend told me.
I don't understand why you're getting downvotes for asking a question. I personally still use it because it makes things a bit easier, but I feel like it's very close to being unnecessary.
damn I wish reddit had language highlighting for code blocks.
Learning Webpack in depth is more than worth it. It's a ridiculously useful tool and seeing everything come together automatically in the end after doing it manually in the past is a beautiful thing. 
The people who actually use Webpack know this is the real answer. Finding the relevant docs for can sometimes be like playing a game of '*Where in the World is Carmen Sandiego?',* and no one wants to put up with that. Personally, I configure my projects. I build my projects. I ship my projects (JK, maybe one day 😢). It's seemingly not hard for me, especially as a front-end focused dev, to run a couple google searches and figure out when I'm using the wrong plugin for this or loader for that. However, that stuff adds up in a team setting. No one wants to have to answer for it. Worse, imagine being the backend guy who has to "make a few changes", then update the build config. It's a frustrating pile. Moreover, Webpack has a reputation at this point. This is completely conjecture, but I wouldn't be surprised if some teams have developed a "just don't look at it the wrong way and it won't break" mentality about it. 
I wonder if it is also because things like create-react-app have yet to adopted it. That tool is a great way to learn webpack. There is a PR for webpack 4 which hasn’t progressed (haven’t checked in a while).
&gt; seized ceased 
A lot of people do not want to actively learn how to properly use it either. I'd say the whole 0 config thing stems partially from ignorance &amp; laziness in lots of cases than it being ultra hard. Webpack 3 finally garnered proper documentation across the slew of configuration options. Why would you leave this something that works after fighting with it? I recently did the upgrade to Webpack 4 and it mostly works with some wonkiness due to the HMR not working 100% the same as it used to. Honestly, I should have just tried to use another tool like Rollup at this point as I find Webpack dreadfully slow although babel is probably more a culprit at this point.
Do you know where I can learn more about this, and HMR in general? I didn't know we had to add code to get HMR to work. In webpack 2 HMR was mostly working for me, but ever since I moved to webpack 3, certain changes are always triggering a full page reload.
Vue cli is using webpack 4
Should I be using vue-cli or [vue-webpack-boilerplate](https://github.com/vuejs-templates/webpack)? What's the purpose of the latter anymore? 
Sad fact: Webpack depends on "is-odd". 
Is anyone here with experience with Nativescript? How does that compare to the frameworks mentioned by OP? 
Good fix!
You could make a chrome extension that injects a prismjs theme
[https://github.com/iamakulov/moment-locales-webpack-plugin](https://github.com/iamakulov/moment-locales-webpack-plugin) here. while on it i recommend using duplicate-package-checker-webpack-plugin and webpack-bundle-analyzer. you're probably already using it since you know you have to many momentjs locales compiled in
Best js animation library out there.
It's using [WebGL with three.js](https://threejs.org/) three.js used to be the Jquery for 3d in the browser, but it's become so much more
So... webpack v5? /s Interested to see what kind of API they've come up with, though.
If you are deeply masochistic, but you want to make tons of money, here are three fields to specialize in: timezones, i18n without unicode, and Cobol. You have been warned.
&gt; Microsoft putting their weight behind React Native with their rewrite of Office 365. Fake news. https://www.reddit.com/r/programming/comments/8s2mvs/no_we_are_not_rewriting_office_in_javascript_and/
JS Hentai*
Dude, where's my zero-config reddit and browser?
This is kick-ass!
There are really cool open source projects for TypeScript \[1, 2, 3\], but perhaps they won't be exact match for a normal web app, still good to read! \[1\] - [https://github.com/reactivex/rxjs](https://github.com/reactivex/rxjs) \[2\] - [https://github.com/angular/angular](https://github.com/angular/angular) \[3\] - [https://github.com/Microsoft/vscode](https://github.com/Microsoft/vscode)
No, it's really not. It does not support formatting unless you do it manually, working with timezones is a pain - a lot of things you need to do very low level. That's why libraries like `date-fns` or `moment` exist and have a lot of usecases.
&gt; The biggest reason appears to be that Webpack 4 is essentially a completely botched release. There are docs on there that still have not been updated for Webpack 4. Ain't that the truth. I decided to try and take a very, very old, legacy application and convert it to using Webpack 4. I kept running into errors where the documentation example showed it was fine until I did some Googling and found that the documentation was just flat out wrong. Very frustrating experience. Unfortunately I see this with a lot of JavaScript projects.
Hello! I'm afraid this article is a bit off. - there is no such thing like javascript event loop. Normally event loop is outside js engine and only uses it. - General idea is ok but like with everithing is not like things are working. If you are interested this is high level view of node.js event loop: https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/ Browsers may use similar approach but implementation will be different. cheers!
Because webpack isn't as popular as it used to be?
vue-cli is maintained by the Vue team and regularly offer new features and bug fixes. It's also updated to the latest vue version to ensure you always get the latest cool things from vue without risking to break your project. The most recent and biggest feature in vue-cli is the vue ui command, which starts a localhost dashboard to manage all your vue projects. In other words, you can get rid of the cli by using the UI where you can do anything (start scripts, analyze build, view logs, create a project and setup it with different modules, ...)
There is a lot of discussion around whether to use d3 or react or both and how. As a starter overview [see this](http://nick.balestra.ch/2015/sankey-d3-faux-DOM-react/) (also checkout links below the post). Personally I think both D3 and React are doing the same thing different ways. They create a view based on data (state). They do this differently - both use own virtual DOM which makes it difficult to work together just out of the box. So there is this [Faux DOM](https://medium.com/@tibotiber/react-d3-js-balancing-performance-developer-experience-4da35f912484) concept which works nicely. The strong side of D3 is lots of utilities you get to manipulate your data before passing it to 'render' selection also animating (transition) and interaction with elements is easy, on the other side React embeds visualisation in context of your app so it can easily use external controls (like user inputs etc).
You may also want to check out \[Codility\]([https://app.codility.com/programmers/lessons/1-iterations/](https://app.codility.com/programmers/lessons/1-iterations/)) they have quite nice challenges :)
&gt;is essentially a completely botched release that's too harsh. Sure, the docs could be greatly improved, but so far it has been working very well for us on a medium sized app. It's actually a strange frankenstein of angular and react so considering all the weird config we use to make it all work together it's quite awesome it even works. We've seen huge memory leaks with version 3, crashes and veeery slow hot reload times. All of that was fixed in version 4. So no, not a botched release by any measure.
https://github.com/anish000kumar/Voyager-vscode
Github: https://github.com/anish000kumar/Voyager-vscode
Yep, that's very true. Thanks for improving the answer.
As far as I understand JS modules coupled with HTTP2 could potentially make the wepack's "bundle stuff together" role unnecessary. Of course the tree-shaking will be still relevant, and maybe lazy-loading of source files will be kind of the default behaviour. Fix me if I'm wrong! :)
Are you still using Dexie? I'm only just getting started with using any type of local storage (aside from cookies)... the pouchdb/couchdb syncing thing sounded cool, but I use postgres on my servers rather than couchdb. So what you're doing sounds in line with what I might want to do. I'm also looking at using postgraphile, and not sure if/how that might tie into any of this. Pouchdb and Dexie kind of look similar from my initial reading... is there a reason you picked Dexie over PouchDB? Any other tips related to this stuff?
composition over inheritance
Webpack docs aren't that bad. https://webpack.js.org/guides/hot-module-replacement/ Look into some example projects on github as well. Good luck! Feel free to reach out if you need more help.
Just wondering what you ended up using for your local db package? Did you stick with PouchDB, or use something else? And are you syncing it with postgres? Any other tips related to any of it? I'm just starting to look into using indexeddb in some form. Never used anything beside cookies up until now. I'm also using postgres on my servers.
I've switched a few projects over to Parcel over the last couple of months. Parcel does 90% of what Webpack does with 100% less frustration. The only reason I would even consider starting a new project with Webpack was if I had an important dependacy that required it. 
CRA 2.0 alpha release actually migrated to Webpack 4 just yesterday ([Issue](https://github.com/facebook/create-react-app/issues/3815#issuecomment-397922864)). Still long time till they release the final 2.0 and people start using it.
It's not ignorance and laziness. It's that most developers would rather spend their time on things that actually add value to a project. Troubleshooting a build tool typically isn't one of them. 
The create-react-app repo had an issue with hundreds of comments and dozens of commits to upgrade to Webpack 4. Teams that maintain their own config might have less resources or expertise in performing the upgrade.
I believe other competitors have gotten better "up and going" experience, such as [NextJS](https://nextjs.org/).
I don't care about the zero config thing. I've tried to upgrade our app from v3, and I've met some blockers – mainly with the hot loader and the way we load CSS in production vs. development. Maybe it's not Webpack 4 per se: the plugins ecosystem seems it is not ready for this version. After spending some days, I've just given up. I'll wait the documentation to be updated and the plugins to be more solid. However I have not the energy to try the upgrade again, with the chance to meet the same frustration, so I'm currently hoping for parcel.js... Too bad because I was an early adopter of this project: I used it to replace require.js... beside the frustrations to make it working, I loved it at first sight. It seems now being affected by bad management... on the other side I understand the project was already a mess so I'm not sure I could have done it better myself.
[Self-promotion](https://www.reddit.com/wiki/selfpromotion)
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
LOL spotted the non-JS developer 
You add this code so you don't have to do full page reloads =&gt; things like webpack-dev-server will still trigger the page refreshes for you when it needs to do a full reload (which is default scenario if you don't build out the next stubble module in the hot reload: [https://github.com/webpack/webpack-dev-server/blob/master/client-src/default/index.js#L208](https://github.com/webpack/webpack-dev-server/blob/master/client-src/default/index.js#L208)).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [webpack/webpack-dev-server/.../**index.js#L208** (master → 3c1ff11)](https://github.com/webpack/webpack-dev-server/blob/3c1ff11c1ce4ec8d990ca0b9dc1460cd906f986f/client-src/default/index.js#L208) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e0x41ii.)
So why this over the more established Numeral, or the built in Number().toLocaleString?
Do you mind sharing your configuration with me?
It is ignorance and laziness. Webpack adds tremendous value to a project. - tap into Babel easily so I can write modern code that runs in ie10 - run the same javascript on the server without repeating boilerplate for each page. - transpiles/bundles my sass - Removes duplicate and unneeded code - gives me hmr so deving is quick - lets me use dynamic imports painlessly - switches between dev/prod effortlessly which changed minification, dev mode code, sourcemaps, etc - gives me stats about my bundle sizes ... and more, without the need for many disjoint utilities cobbled together with grunt/gulp/npm scripts. If that's not value, I don't know what is. 
Made IO game myself, from zero to this: [http://owom.io/](http://owom.io/)
Parcel does literally all of those features too, but you don't have to spend 3 days configuring it.
Done :)
That part is called a Regular Expression pattern. In this case it means space. Essentially the result will be an array of individual words of the initial string.
i dont think it matters, just pick one and practice. i found this site super helpful for both practicing and recognizing problems in interviews: http://blog.gainlo.co/index.php/category/coding-interview-questions/
You're totally right. But the frustrating thing is that Webpack 4 finally fixed tree shaking. It was a hot new heavily blogged about feature for webpack 2, then it was really coming this time with Webpack 3, and now it's here. I've been lucky that my solo projects are simple enough that I've been able to get to webpack 4. The drop in total build size was massive and it pays off so much. That should have been a much bigger priority than, well, whatever botched this release.
Personally. I don't want zero config. The trend towards encapsulating the processes and configs behind closed doors is worrying to me, I've never been a fan of black-box programming.
Who said anything about rewriting all of office in JavaScript? React Native is for writing a native UI in React. Last week it was stated they were using the react native windows branch to write their UI. It makes total sense to write the UI portion in JavaScript to use your existing web dev talent, and the existing native UI components in C or whatever and have React Native be the bridge between the two. The original question was which framework should they look into Cordova or React Native. This is some major news in React Natives camp.
I thought about using parcel js, but in the end I went with webpack 4 recently and kept the config because I *want* a config and I didn't want to learn a new one.
I like to use some tools that just do some complex thing under the hood. For example: [poi](https://github.com/egoist/poi) is a really good wrapper of webpack, you only need a little bit of config to customize. And you can also update them without pain instead of boilerplates.
I think we'll simply see a performance gain from bundles split up into chunks loaded in parallel. Nothing more. I can't see a use case for lazy loading modules when we can simply reduce their footprint and load them fast up front.
It does, it uses 4 spaces
Tbh if you have to look at how other projects did it, it means that the docs are not good enough
yeah for some odd reason that is in my src/stores/index.js file so maybe i need to make that my entrypoint instead of src/index.js? if (module.hot) { // Enable Webpack hot module replacement for reducers module.hot.accept('../reducers', () =&gt; { const nextReducer = require('../reducers'); store.replaceReducer(nextReducer); }) }
\`this\` works differently in arrow functions.
So object "limit" passed in the argument doesn't bind to the arrow function? 
That's not completely true. It doesn't only split by a space. It has a + character after the \s means it matches one or more \s'. \s isn't only a whitespace, it can also be a linebreak, example: let str = "This\nis a\ntest .".split(/\s+/); str; // ["This", "is", "a", "test", "."]
Thanks for correcting me. You are right.
I chose dexie because after looking at other options, including pouchdb/couchdb, dexie looked like it made more sense. Not really sure why, tbh. My focus was on a PWA with offline functionality. I created a dexie plugin for Vuejs that lets me run Dexie in a webworker, and pass message handlers, so concievably, if I wanted to use something like graphql to store data, I'd just identify the backend during initiation and the plugin would handle the backend calls. Not sure how successful I could switch out the backend, but it is nice that dexie works in a webworker.
Did you just copy/paste this from some blog? It barely answers the question. AFAIK 'vue-cli' is the newest version of Vue's CLI. It takes advantage of webpack's new zero-config feature. For this reason vue-webpack-boilerlate is no longer required, unless you are still using the old CLI. 
Cool, thanks for the info.
The stakeholders who pay the bills don't give a shit about any of this and wonder why we're not implementing features and fixing bugs instead of fucking about with our tools.
Also webpack-repacker-split-chunk-bundle-wrapper-plugin and unfuck-webpack-split-chunk and chunk-flip-minify-annotations.
BTW, you can't use triple backticks in Reddit. You need to indent each line by 4 spaces. 
[Exercism](https://exercism.io) is a great site for practicing algorithms. You get to use your own dev environment to do the code, so you're not confined to the insanity of online editors. As a side note: I would avoid hackerrank. They're okay, but a lot of the algorithm challenges either have bad explanations or bad examples. Also, it seems to be much more for people that do python, java, and c or c++, rather than people that do JS.
The whole point of prettier is so developers don't have that much control over the style, and just accept what prettier enforces. Depending on the person/team, there can be lengthy, silly debates on spacing and style, so prettier's goal is to reduce what is configurable so developers can just start coding and trust their code isn't going to look stylistically awful at the end. I'd recommend if you want to spend the time setting up the perfect formatting, just use eslint - there is a lot of configuration available in it to enforce your three-space braces a line after the call, etc. :D
This is something too many devs forget. It's not about us, not about using cool and new tools, not about building the "bestest toolchain ever". It is all about delivering on time, on budget and on spec. That's it. If you can do some or all of the above while doing that, kudos to you. Most clients aren't going to pay for that.
Correct. Arrow functions always use a lexical this (the same this value as the location in which they were defined). They can't be rebound to something else, neither in callbacks, nor call, apply, or bind.
I ended up using pouchdb &amp; syncing with couch. The key was to secure couchdb down so it can't be exploited, which can be a challenge. I'm not 100% certain i've covered all the bases.
 console.log(arr2.every((curr) =&gt; curr &gt; this.lower, limit)) this code is a prime example of why having syntax shortcuts can be bad. particularly: (curr) =&gt; curr &gt; this.lower is ambiguous. is this a comparison expression or a function expression? Anyway, the issue is that the arrow anonymous function you create in the second example has `this` bound to the function, not to `limit` console.log( arr2.every( (curr) =&gt; curr &gt; this.lower, limit // this anonymous function has `this` bound to the function, not `arr2` ) ) I strongly suggest taking the time to structure your code with braces and semicolons. it makes debugging and reasoning about code a lot easier. (arr2.every((curr) =&gt; curr &gt; this.lower, limit) particularly that line. That function should be wrapped in `{` and `}`, because in isolation, it looks like it's using the comma operator (curr) =&gt; curr &gt; this.lower, limit If you surround it with braces, it becomes much easier to read: (arr2.every((curr) =&gt; { return curr &gt; this.lower; }, limit)
This looks awesome! Great work. I've got two suggestions if you're open to them: 1. Let me hit ENTER to submit. 2. Clear the text field when I submit a note. At the moment the old text stays there and I have to manually remove it when I want to add a new note.
Seems like virtually everyone who's used Aurelia for a real world app has loved it. I've been evaluating it for a new web app and have been extremely impressed by its elegance, performance, intuitiveness, and focus on ES6/TS among other things. It makes me sad that more folks aren't using this awesome franework. There are a number of solid, larger apps built with it of course, but nothing so prominent as to have gained the attention of its competitors. It's a real chicken-and-egg problem; people avoid it because the community is smaller, thus the community doesn't grow as quickly. I'm going to be taking the risk and developing this next project on Aurelia, because it seems like the best framework for the job.
I think all the complaints are from people that don't remember the grunt/gulp era of JavaScript build tools.
That's interesting, is there any reason you didn't want to use webpack or parcel? I'm just about to switch over to parcel
Too meta 😂
never seen blog before, thanks! it looks pretty helpful
So basically this is a JSON memory store?
Bad way to use API with JavaScript, now we can use fetch, is more simple. 
I can't help you with what APIs V8 is using, but the behavior as I understand it is basically this: When a scope is created, for example from a function call, and there are nested functions in that scope, a persistent version of that scope is created that will contain all variables in the scope which get referenced in any of the nested functions. This could be 0 variables, some of the variables, or all of them. Then the nested functions, when defined, get access to this scope, and through it all of the related parent scopes, also defined based on what properties are being referenced. These scopes represent the closure variables the nested functions will access and use when executed. I believe as far as the spec goes, functions are created with a single, current environment record which is also a linked list connecting parent environments. I'm assuming for it's representation of `[[Scopes]]` seen in the debugger, this is converted into an array for convenience. I'm also not sure if unused scopes are simply omitted from this list or, like with unused variables, gone entirely. I suspect the latter to save on memory unless there's some other benefit to keeping them around. Again, I'm not really familiar with what V8 is actually doing, but my understanding goes something like this: [[global]] = new Scope([...&amp;globalApi]) // class Scope(...variables) const closure = () =&gt; { [[closure]] = new Scope([&amp;tick]) // `unused` variable not included since not in closures [[closure]].parent = [[global]] let tick = 0 let unused = 0 // added another variable { // added another scope [[block-scope]] = new Scope([]) // `internal` in scope but not referenced in closures [[block-scope]].parent = [[closure]] // since this scope has 1 or more closures, create the scopes array they'd reference [[Scopes]] = (scope =&gt; { let scopes = [] while (scope) { if (scope.variables.length) { // ignore scopes with no variables ([[block-scope]]) scopes.push(scope) } scope = scope.parent } return scopes })([[block-scope]]) const internal = () =&gt; { console.log(tick) tick++ } internal.[[Scopes]] = [[Scopes]] //-&gt; [ [[closure]], [[global]] ] return internal } }
Public write in a global namespace.. what could go wrong?
Public write in a global namespace.. what could go wrong?
I have a bit different view. 99% of projects require customization that has *already been done* in boilerplates, create-react-app, etc. I don't think build tools are something that one should spend a lot of time on.
you mean a week configuring it.
Don’t seem to have a source
Updated docs is MVP2... err... 
We think our problem is with addHTML not sure tho
I used to do this one a lot: https://www.codewars.com/?language=javascript Euler is always a good choice. I've actually been asked an Euler challenge derivative in an interview before.
Utterly useless spam. Also poor English. 
*JSPDF
You can pass as many args as you want before calling which makes it is possible to use the spread operator. You also don't need to call the fun immediately, even with all necessary arguments. I like that there is a little less magic too.
Thanks for the explanation! So vue-webpack-boilerplate will eventually be deprecated? I didn't see any relevant discussions in their issue list. Also if I bootstrap a project with vue-cli today, and then webpack 5 gets related, will vue-cli be able to do the migration for me (minus any custom configurations I made)?
Check out the complete JavaScript course 2018 on Udemy by Jonas Schmedtmann. I have bought it but haven't completed it yet. I recommend it as I have completed his advanced CSS course and found it brilliant. 
Webpack 4.0 breaks hmr for webworkers. 
I have internet at work so I google it :D
Lol it’s definitely not for production but helpful for quick prototyping.
Not exactly. The data is stored persistently in a dB as long as you want it to be there. Granted it’s not very secure.
When you first learn something you have to look it up all the time but repetition engrains it in your memory. The things that I use everyday I remember, the things that I use not so often I still need to look up. That's just how it goes - we can't remember everything!
Murphy’s law applies. It’s just waiting for abuse...
I don't think that immutable adds much benefit, if anything at all. Where did you see the benefits initially? We had immutable running for a short while, but stress-testing it against plain javascript redux, shallow copies and ref equality, we didn't perceive any gains, worse - it meant so much more overhead as it affects the rest of the codebase that just for reading turns to immutable lingo.
I recommend interviewcake.com
My understanding is that Circle is planning on shipping this exact feature prior to ending support for 1.0 at the end of August. All the same, good work because I was looking to build this myself and now I won’t need to.
I always recommend front end masters, I found it very useful when I was starting out. You could try their [JS path](https://frontendmasters.com/learn/javascript/)
Yeah that would be more in the spirit of FP.
I would think that this is common sense, but that doesn't seem to be the case among Vue's fans. Personally, I star projects that I want to keep an eye on, not projects I use every day. I don't even use Vue, but I've got it starred because I think it's interesting and I want to watch it's growth. I don't have React starred, though, because it's a foregone conclusion that I'm going to stay up to date with it, as I'm pretty heavily invested in it at this point. 
dynamic imports painlessly? slow down. shit needs comments inside em for the build tool to know what to do with its ‘chunks’. 
It doesn't matter, people will chase trends and biases. People will make choices and will possibly use both (or something else), it’s not like picking Vue will kill React or vice versa.
I use Bing.
is it a click or a mousedown that it looks for? Dispatching a mousedown event won't simulate a click, it only triggers listeners listening specifically for the mousedown event.
Mostly just for core understanding of the new JavaScript stuff like import - I've set up bare-bones React and Vue spa's since then to get a feel for each framework, and I plan to build the app in vanilla then convert it to Vue
Yeah, I tend to treat stars more as bookmarks than as a vote. I don't know know that I have any of my favorite or most-used starred, but I have plenty of "I need to come back and check this when it's matured a bit more" or "that's a nice style guide, I'll star it so I can refer to it later" stars.
Because webpack is a band-aid on a much bigger problem. And no, I don't have a silver bullet solution. 
&gt; with their rewrite of Office 365. 
It's kind of sad that we always come to the same point : Trying to explain that OUR language, OUR framework, OUR library is better. Of course the ton of posts "Which framework should I use" or "Is JavaScript a good language to start" are not helping. But could we avoid saying that X language or X framework is better without specifying a use case. And could we stop judging technologies we never really used (no a side project is not enough to conclude that React &gt; Vue or Angular &gt; 13" Peperoni Pizza). Maybe I'm just being utopist :/
I wrote this in markdown, so I followed the basic syntaxes.
The first thing I force myself to do is never copy/past Even if I re-write line by line the example, I will remember it a lot better than if I just hit Ctrl C + Ctrl V
Thanks, I have no idea how things are working for me right now since I didn't add any module.hot.accept calls. Do you know of any good projects that I can look at?
In this comment I posted a link to my starter. https://reddit.com/r/javascript/comments/8s3fmy/_/e0wq6w1/?context=1
Spaced repetition is the way to go! The problem is that it's kinda hard to use it with coding. The way I do it is by using anki and adding questions found on my textbooks because they are specifically designed to help us remember and understand what we're learning
I like Angular, but there's no way that it's better than a 13" Pepperoni Pizza. Pizza is the correct call in nearly 100% of it's use cases, hundreds of years have gone into engineering pizza, it has a very easy to use testing suite, you get the exact same result with loose or static typing it doesn't ever need additional dependencies or libraries. 
I posted something similar over in the React sub but I don't think anyone really thought the star thing did mean Vue has more users. Certainly no-one with half a brain thought this was the case, Evan even tweeted something to that effect. Dan was just congratulating the Vue team on what they'd built. Yet, even in the comments here, more library tribalism: &gt; I would think that this is common sense, but that doesn't seem to be the case among Vue's fans. Apparently a few people who don't know what they're talking about overreacting to Vue's star count means that Vue fans don't have common sense and think stars === usage. We've created this weird situation in front-end dev where you have to be in a library/framework camp and once you go in that is what you will forever be associated with. Gary Bernhardt has spoke in the past about emotional/ moral attachment to tools in software, and he's so right its not even funny. For a discipline defined by (and that constantly goes on about) logic and critical thinking it's alarming how little developers show when it comes to their tooling or challenging dogma. Can we not just build cool stuff.
I use Anki and its amazing because I get those good grades, but once I learn something 'new', i forget the 'past'. Another problem is that I can't figure out a way to randomize the cards (do you?), mine just appears in the same order that I created them.
Lol
Great tip
I have used RN extensively as well. It has its quirks for sure, people who misunderstood what was said on Twitter have a misunderstanding of what RN is. Of course you CAN write the entire app in RN, but why would you rewrite the entire application stack. I’m guessing they’re using it for presentation, and porting what functionality they can into JS, not rewriting everything from scratch, that’d be quite an undertaking.
👌
That was unfair comparison, there are only a few things better than a pizza.
Until you make a typo and lose hour of your time wondering why this "copied" solution with so many upvotes does not work.
It's a risk I willing to take. I never copy an entire example of 50 lines so most of the time it's quite simple to find my mistake. Maybe one day I will regret :p
Myself and many other developers I know look up some rather basic stuff almost daily. Like others have mentioned if you don't use it everyday then it slips behind the content you do use everyday. I wouldn't get down about it. 
I'm sorry you work for such a shit company.
Comments aren't compulsary. Only if you want the chunk to have a certain name
Javascript is amazing. Gulp and Grunt were so commonly used just 3 years ago (and obviously still is for apps built during that time). It's so feelsbad to know that in 2 or so years everything you are currently doing will be looked up as ancient stupid technology by the general consensus of javascripters. It must be nice for the people that actually are able to keep up with the Javascript meta at this point, which now comically changes faster than the meta for e-sports. I wish I could blow up and completely refactor all my apps every 6 months.
Who cares tho? This preoccupation with using popular tools has always baffled me. I can understand the perception that popularity might be a proxy for support, but these discussions always lean sorta religious. 
While this is true, I'm not a fan of this whole React vs Vue, us vs them kind of conversation. Just having the option for either of these amazing frameworks is what matters. Cheers to both React &amp; Vue teams.
Honestly I hate articles like this that discuss features that have been around for quite a while now. Like if the author really cared enough about async/await to write an article on it, why didn't they write it when it was just a proposal or when it became part of the standard. It just feels like these people write articles for the sake of writing articles. This article also has nothing to do with TypeScript lol... 
Right on. I 100&amp;#37; agree. React &amp; Vue are both amazing and we as devs should be happy to have either of them.
I found the following book useful. It explains what helps w.r.t. recall. &gt; “Small Teaching: Everyday Lessons from the Science of Learning” by James M. Lang 
&gt;but that doesn't seem to be the case among Vue's fans. Why you gotta bash a huge group of people because of a few loudmouths?
If you're working with passing tables to a pdf, you can use the "autoTableHtmlToJson" class inside jsPDF, like this: var pdf = new jsPDF({ orientation: 'l' }); var res = pdf.autoTableHtmlToJson(document.getElementById('tableID')); var config = { 0: { //&lt;-- position of each column (0 based). this allows u to set width of each column. columnWidth: 16 }, } pdf.autoTable(res.columns, res.data, { margin: { top: 65 }, styles: { overflow: 'linebreak' }, columnStyles: config, showHeader: 'everyPage', addPageContent: pageContent }); If you're working with images, you're going to have a bit of a struggle, because if you dont set their height/width, they'll get cut when paginating. Hope this helps you a little with what you want to do
I'm sorry you are playing with yourself and use your webpack config as your only friend,
I don't think anyone actually said that this is the case, I mean NPM alone is not the way to show which one is being used more but I think that React still has the edge here obviously. But there is something else that is interesting for me. React who has Facebook and millions of dollars behind them for development, marketing etc vs. Vue and one guy (in the beginning) with limited budget. Also, Vue exists shorter but nevertheless here we are. This is what fascinates me, the growth that Vue has.
And another week troubleshooting it. 
Hundreds of years of engineering and user testing. Still pushes pineapple module. Classic.
Why you gotta be so sensitive over something that has approximately zero impact on your day-to-day life?
Thank you for the reply we are not sure where to put it though...
Thank you for the reply we are not sure where to put it though...
 f.text = "function printThis() { var pdf = new jsPDF('p', 'in', [11,8.5]), margins = {top: 40, bottom: 60, left: 40, width: 522};" + "var printArea = document.getElementById('PrintableTag');" + "pdf.addHTML(printArea,function(){pdf.save('Customer.pdf');});" &lt;%-- + "pdf.addHTML(printArea, 10, 10, {pagesplit: true, margin: {top: 10, right: 10, bottom: 10, left: 10, useFor: 'page'}},"--%&gt; &lt;%-- + "function () {pdf.save('Customer.pdf');});"--%&gt; 
This is what we have... the margins are not working excuse the comments please
Angular is such a fucking shitshow now. They should be on Angular 2.6 now instead they think companies can hire someone to exclusively focus on keeping track of their constant version breaking changes. As soon as I can be I'm done with it.
Anchovies got deprecated though, so there has been some amount of progress. 
Yeah -- I'll give this a shot. I didn't think to reproduce this locally. :facepalm: Thanks so much for the response!
I'm not, just feel like theres no need for this "us vs them" mentality. I guess no point in trying to talk sense to a React user... /s
&gt; doesn't seem to be the case among Vue's fans. Maybe some of them. I'm all-in on Vue, have never written a thing in React, and I'm well aware that React is dominant in real-world usage despite the Github stars. I think most users agree.
(Github stars !== Usage) === (React from Facebook !== open source). Both are correct. 
ok sure try one more time how about [101null.com](https://101null.com) ?
Sure it's the other side of the coin - it's not like copying instead of retyping is risk-free.
But it is from Facebook, a dirty evil company made up of shady developers who also happen to be bad at what they do.
Play around with this code: `function printThis() {` `var pdf = new jsPDF('p', 'in', [11,8.5]),` `margins = {top: 40, bottom: 60, left: 40, width: 522};` `var printArea = document.getElementById('dataTables-releases');` `pdf.addHTML(printArea, margins, function(){` [`pdf.save`](https://pdf.save)`('Customer.pdf');` `});` `}` Try looking at this PR: [https://github.com/MrRio/jsPDF/pull/1450](https://github.com/MrRio/jsPDF/pull/1450) It might help
The "oh gross, why would you eat that" warning doesn't work when you can use the --ignore flag in the linter.
I wish these *tredy==technically good* articles would be kept to /r/webdev. Or else, I wish there was a sub where you could discuss building things instead thousands of framework popularity contest articles.
I don't feel that way at all. I've got nothing against Vue, I just think some of it's users have been getting a little carried away with the fact that Vue has more stars than React.
I personally [recommend against using Immutable.js, for several reasons](https://www.reddit.com/r/javascript/comments/4rcqpx/dan_abramov_redux_is_not_an_architecture_or/d51g4k4?context=3), but your mileage may vary. As an alternative, you might want to look at https://github.com/mweststrate/immer/ . 
If you want to do any amount of customization to your editor, don't use Quill.
The insecurity of some engineers is hilarious to have to write this shit.
Lasagne?
No, but Japanese girls.
A well-argued point. Now, if you'll just step over here onto the bonfire, we can begin the burning.
In the angular graph they’re using the angularjs 1.x package. Angular 2+ is ‘@angular/core’
There is no event handler for the nl3 element? So clicking it won't do anything
But the reaction is normal. If you are proficient in framework A, probably you are not as proficient in framework B. If A is stablished as the dominant framework, you will be ahead in the job market race. If B becomes the standard, you will be a bit behind in that race. Your bread and butter is directly related to that, so for the people that is not a top-tier programmer it make sense to cheer on A and boo on B.
No kidding, it's one thing to get these generalizations about 'fanbases' on sports and entertainment subs, but do we really need to do that here? I use Vue for some projects and React for others depending on who I'm working with and what the project needs, does that mean I'm a Vue fan or a React fan? Why would you even *want* to choose a side when these libraries change so often? It's such a weird need for people to be 'us vs. them' that it bleeds into things like this where it really shouldn't apply at all. 
Reddit uses a slightly different dialect of Markdown. 
I'm not playing with myself, I'm drastically reducing painpoints for dozens of developers, reducing dev time, and reducing build times. Any good employer will recognize the value this brings.
&gt; It's kind of sad that we always come to the same point : Trying to explain that OUR language, OUR framework, OUR library is better. OP's post doesn't make any claim about which library is better. It's addressing another post about GitHub stars being used to measure Vue's adoption rate when in fact GitHub stars do not correlate with usage. NPM install rates are a better measure for that. On a side note, it's not that case that all libraries are equally as good as each other. It's popular to say that the quality of a tool or library is a matter of personal opinion. While there is plenty of room for subjectivity, there are often libraries which are simply better than others. For example, you might happen to like Grunt as a build runner and be able to state a "use case" for it. But you would absolutely be doing someone a disservice by recommending it over webpack.
&gt;edit: Uh-oh, I think I might have offended some Vue users! Better downvote me, that will really put me in my place ;) These edits are always hilarious, you're giving yourself too much credit. You didn't 'offend' anybody you're just one of those weird 'pick a side' people that attaches the framework they use to their self-identity so you say things like "Vue's fans" and "offended Vue users". It's strange because it's like you're trying to create conflict where there is none. I think most people just use the best tool for the job instead of sticking to something because you're a 'fan'.
Yes, you shouldn't unless you wish to understand how your code works. And yes, create react app and others will get the job done, but once you push this to production and start to have issues with your build system ( which is 100&amp;#37; inevitable ), you are going to wish you knew what the fuck you were doing.
I think the community is slowly going back to basics like jQuery and vue.js because of how unnecessary complex it is to configure these frameworks from scratch. Why the fuck do JavaScript frameworks have more configurations than my web.config.
Well, if there’s a userbase willing to pay for it ¯\_(ツ)_/¯
I really don't give a shit what people use. Vue is great, it's just not my preference. I'm not trying to "create conflict", I'm just poking a little fun at people like you who take this stuff waaaay too seriously. 
You dropped this \ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¯\\\_(ツ)_/¯`&amp;#32;or&amp;#32;`¯\\\_(ツ)\_/¯` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
I’ve never met someone who’s worked on a production level project in all mainstream is frameworks and come to a conclusion about which is best, because it’s simply an impossible question to answer. It’s the wrong question to ask
Well to be fair. The star count is not meaningless. It's a good framework.
BY THE WAY https://www.edx.org/course/cs50s-mobile-app-development-with-react-native 
It's a pure function that can change the state of the entire app.
&gt; Maybe I'm just being utopist :/ I think so. Humans are like water, we seek the path of least resistance. Who wants to dig into first principles, and truly understand a problem domain when you can just ask what everyone else is doing? Human nature.
http://i0.kym-cdn.com/photos/images/newsfeed/000/166/876/chuck-norris-thumbs-up.jpg
The explanation you already have. I will give you a tip. Run away from "this" as possible, because the side effects that occurs. You can use closure to get what you want and is very flexible. const checkTreshold = limit =&gt; curr =&gt; curr &gt; limit.lower [13, 4, 5, 6, 7, 8, 9].every(checkTreshold({upper: 50, lower: 1})) or you can partial apply and create a new function to your context const oneCheck = checkTreshold({ upper: 50, lower: 1 }) const otherCheck = checkTreshold({ upper: 30, lower: 10 }) const arr = [13,4,5,6,7,8,9] console.log(arr.every(oneCheck)) console.log(arr.every(otherCheck))
No they don't, stop your autistic tool fetishism and get some work done instead. 
Here's an example of AR.js applied on business cards: [www.identific.info](https://www.identific.info/)
Start with the newest standard, and then work backwards. I recommend [Let's Learn ES6](https://bubblin.io/cover/let-s-learn-es6-by-ryan-christiani) by Ryan Christiani, it's easy to follow and FREE. After you've done that explore YDKJS by Kyle Simpson. That is paid if you prefer book like experience, but the manuscript is free on Github. 
No need to learn new tools when you already learned the best ones. \s
I vote for codewars. I've had a few interview questions that were 5th Kyu.
How can there be anything better than pizza?
I have a great joke: "You should RxJs everything"
You know, two pizzas are better then one, right?
we must cease the means of web production
I'm surprised by how gorgeous this is. I wish I could use it to draw borders around divs without having to result to hideous DOM structure, but nonetheless I hope I find a use for this.
easy: add pinneaple to pizza
you might find http://wiredjs.com/ interesting. It has a 'card' component that you can use as a div. 
PINEAPPLE IS DELICIOUS AND YOU KNOW IT
We agile now bby!
It's blocked by my work firewall, unfortunately.
Pepperoni and pineapple is definitely the best pizza.
Ha! try the github: https://github.com/wiredjs/wired-elements
Nice. It's made by the same guy, of course. I'll see if I can use these in an art portfolio sometime.
I really liked it, will definitely use. Keep up the good work mate! Cheers!
“tasting suite”
You're right, all frameworks can do everything and the all have pros and cons, choose wisely and be a master of something.
I use prettier because of auto updating when saving files, when doing CI/CD etc. ESlint is used for more functional stuff such as variable not found, unused vars etc.
&gt; stars !== usage We know. The star tracking was a fun little event to watch. Sometimes it's okay to have a little bit of fun and not take everything so seriously. Yes react is more popular, yes Vue is rising in popularity, yes it still has a long way to go before matching react. I can't help but feel that articles like these are a waste of time considering they only reiterate what everyone already knows.
Did you hear about the ghostbusters operator? It crosses 2 streams.
its hard to recommend because learning programming is such a big undertaking.
I don't think it will be a massive shift, but I've already seen folks revert back to server-side templating instead of intrusive UI frameworks. 
If you can’t find one, make one. 
This is, in fact, the plan.
looks like most are recommending codewars, i'll try that. what is a Kyu? 
NPM !== usage either. There are plenty of CI/CD environments out there running thousands of times a day and downloading packages from NPM. That being said, it is normal that React has more downloads since it has been popular for a longer time than Vue and Vue recently got some traction. I, as someone having approximately 20 years of web development background, find that Vue has a shorter learning curve than React. Apart from that they are almost one and the same. Neither one is better or worse. Vue is just simpler and lighter. 
If anything, npm downloads are only valid to know which framework has more CI...
May help you https://www.npmjs.com/package/algebra.js
It's interesting to know which frameworks are popular enough to get good support, and which are losing steam to see if support is going to fade after a few years. At this point I think those big 3 are all popular enough to be safe bets in term of support.
And I agree at 100&amp;#37; with everything you say. I have nothing against this article, it's quite interesting and not at all what I am talking about here. And of course not all libraries are eqully good. That's why I was only talking about global judgment without a use case. React is not better or worse than Vue, but yes there are enough points to differentiate them and to have a winner in certain scenario (Vue for HTML templates if your designers modify them directly a lot for instance).
I like how OP took the bat.
Looks like [https://github.com/scottschafer/cypressautomocker](https://github.com/scottschafer/cypressautomocker) does the fixtures recording. I'm trying to ditch protractor for cypress and then so about PollyJS. @kylemh What's your experience with Cypress?
NPM install rates aren’t even a good metric. I use Vue just by including a script tag on a couple sites at work. Chinese people don’t even use NPM. Everyone knows React is more used. Having more GitHub stars only means you have more GitHub stars, just a fun metric without much real world implication after a certain point. 
We use it for all our products at my company. It makes e2e testing and integration testing a snap. It also makes testing features that are normally difficult to reach easier (ie the end of some pipeline that you’d normally have to navigate to multiple times to see differences). Entirely positive experience. 
Here's a use case to help support your claim: describe('Pizza', () =&gt; { it('should be the first choice to throw on a roof in anger', () =&gt; { const pizza = new Pizza('Venezia'); const person = new Person('Walter', 'White'); person.hands.push(pizza); person.experience({ emotion: 'rejection', from: 'spouse' }); person.hands.should.be.empty; pizza.location.should.equal('roof'); }); }); [source](https://i.imgur.com/AYOjeip.gif)
I could be wrong because I don’t keep up with angular anymore, but aren’t their major versions on a schedule? 
NPM !== usage either. There are plenty of CI/CD environments out there running thousands of times a day and downloading packages from NPM. That being said, it is normal that React has more downloads since it has been popular for a longer time than Vue and Vue recently got some traction. I, as someone having approximately 20 years of web development background, find that Vue has a shorter learning curve than React. Apart from that they are almost one and the same. Neither one is better or worse. Vue is just simpler and lighter. 
&gt; a typo and lose hour of your time wondering why this "copied" solution with so many upvotes does not work. this will only speed up the learning process ;)
Then after writing it they have to downvote anyone pointing it out. Here is +1 to compensate.
More that people started using SPAs for EVERYTHING without regard of the project requirements. - GMail === SPA good choice - Wikipedia === SPA bad choice Hopefully we will see a normalization where SPAs are used where appropriate. Which can often be a hybrid approach (browsable pages == traditional, admin center === SPA)
&gt; Github Stars !== Usage https://i.imgur.com/Z5S4C8B.png
They finally realized react is garbage too, huh?
im using it now, I am always looking for a better bookmarking solution
Exactamundo. I inherited an app that persists to Mongo where a relational would be far more applicable. Fun fun. 
Tried it at work and complex animations weren't as smooth. For smaller, simple animations it was fine though.
I see what you're saying. I guess that moment.js is like jQuery - old and large but does what it does really well and a ton of people are used to it ;-)
&gt; it's not that case that all libraries are equally as good as each other. It's popular to say that the quality of a tool or library is a matter of personal opinion. While there is plenty of room for subjectivity, there are often libraries which are simply better than others. I don't think anyone suggested that all libraries are equal. That's obviously not true. However, when you compare many of the giant frameworks or building tools against each other they more or less have a way to get similar work done in their own ways. Someone using Angular over React isn't really a big deal. &gt; For example, you might happen to like Grunt as a build runner and be able to state a "use case" for it. But you would absolutely be doing someone a disservice by recommending it over webpack. I think you're too tied into the tooling to look at it objectively. At its core grunt, gulp, webpack and others call other npm dependencies to do most of their work minus orchestration. You can replace all of them with a fairly simple script that just calls the dependencies instead. Now there is great comfort and support when using a common pattern, which is what these build tools do and I'm not saying don't use them but I think you're looking at them from the wrong height because there is nothing _inherently_ bad about recommending grunt over webpack. It's really going to depend on the environment and use case.
[http://practity.com/582-2/](http://practity.com/582-2/)
fish pizza fan for life. I wish places kept carrying them
Vue and React have almost the same age, they're just a month apart. The rules that apply to npm apply to both of course. The same CI environments that work with React do so with Vue. Environments that don't rest on build tools script-import Vue as well as React. You can see the same proportion that you see on npm reflected everywhere, npm dependents (libs that include Vue/React in package.json), github dependents, job market, and so on. The impression i have is that Vue's spread is often gorilla type marketing, or "hype", and some of it quite artificial in that opinions sometimes seem uninformed bordering false (small learning curve, easier, ...). It just didn't translate into growth, and i would assume that is because after all the frameworks that we had no one is that gullible anymore. React, from the get go, shot through the roof by innovation and a clear cut vision of where it wanted to be, and they've followed it through. I'm obviously biased, though i do know both by heart and use both at work, but to me there's about no surprise as to how the marked's panned out.
Here's the full code for the Form + JS: &lt;div id="guess"&gt; &lt;form&gt;&lt;br&gt; Enter First Name:&lt;br&gt; &lt;input type="text" name="Fname" id="Fname" value=""&gt;&lt;br&gt;&lt;br&gt; Enter Last Name:&lt;br&gt; &lt;input type="text" name="Lname" id="Lname" value=""&gt;&lt;br&gt;&lt;br&gt; Enter Email Address:&lt;br&gt; &lt;input type="text" name="Email" id="Email" value=""&gt;&lt;br&gt;&lt;br&gt; Enter Phone Number:&lt;br&gt; &lt;input type="text" name="Phone" id="Phone" value=""&gt;&lt;br&gt;&lt;br&gt; Age: &lt;br&gt; &lt;input type="text" name="age" id="age" value=""&gt;&lt;br&gt;&lt;br&gt; Address?&lt;br&gt; &lt;input type="text" name="location" id="location" value=""&gt;&lt;br&gt;&lt;br&gt; Create User ID:&lt;br&gt; &lt;input type="text" name="UID" id="UID" value=""&gt;&lt;br&gt;&lt;br&gt; Create Password:&lt;br&gt; &lt;input type="text" name="PW" id="PW" value=""&gt;&lt;br&gt;&lt;br&gt; &lt;/form&gt; &lt;button onclick="myFormSubmit() , myFunctionSubmit()"&gt;Submit&lt;/button&gt; &lt;!--&lt;input type="submit" id="click" value="Submit" target=""&gt;&lt;br&gt;&lt;br&gt;--&gt; &lt;div id="results"&gt;&lt;/div&gt; &lt;br&gt; &lt;div id="Proceed"&gt;&lt;a href="Order.html"&gt; &lt;img src= "Proceed.png" &gt;&lt;/img&gt;&lt;/a&gt; &lt;/div&gt; &lt;!-- JAVASCRIPT --&gt; &lt;script&gt; document.getElementById("click").onclick = function() { myFormSubmit() }; function myFormSubmit() { var greeting; var Fname\_entered = document.getElementById("Fname").value; var Lname\_entered = document.getElementById("Lname").value; var Email\_entered = document.getElementById("Email").value; var Phone\_entered = document.getElementById("Phone").value; var age\_entered = document.getElementById("age").value; var location\_entered = document.getElementById("location").value; var UID\_entered = document.getElementById("UID").value; var PW\_entered = document.getElementById("PW").value; greeting = Fname\_entered + "," + " " + "thank you for registering!" + "&lt;/br&gt;" + "The following information has been emailed to:" \+ " "+ Email\_entered + "&lt;/br&gt;" + "Please check your inbox/spam for these records" + "." + "&lt;/br&gt;" + "First Name:" +" "+ Fname\_entered + "&lt;/br&gt;" + "Last Name:" +" " + Lname\_entered + "&lt;/br&gt;" + "Email Entered:" +" " + Email\_entered+ "&lt;/br&gt;" \+"Phone Entered:" +" " +Phone\_entered + "&lt;/br&gt;" + "Age Entered:" +" " + age\_entered+ "&lt;/br&gt;" +"Location Entered:" +" " + location\_entered+ "&lt;/br&gt;" + "User Name Entered:" +" " + UID\_entered+ "&lt;/br&gt;" + "Password Entered:" +" " + PW\_entered; document.getElementById("results").innerHTML = greeting; } /\* Hide Proceed IMG Button Until You Click "Submit" Button \*/ /\*document.getElementByID("Proceed").onload = function() { myFunctionSubmit() };\*/ function myFunctionSubmit() { var x = document.getElementById("Proceed"); if (x.style.display === "none") { x.style.display = "block"; } else { x.style.display = "none"; }} &lt;/script&gt;
Pros: Ultra simple, easy, and fast. Cons: No security, no privacy, no guarantees of any kind. Ultra simple: npm install freekey fk = require("freekey"); fk.put( key, value, callback ); // store something fk.get( key, callback ); // fetch something fk.del( key, callback ); // delete something No accounts or access keys to set up, just use it. More info: https://www.npmjs.com/package/freekey 
The first double quote looks funny, try replacing it with a normal double quote and removing the space 
I've had spicy fish sauce instead of marinara and it was awesome
I'm confused, are you going for power or for the ability to use different environments? A VM will ultimately be as powerful as the hardware it's running on, so you can't really go wrong with a decked out PC.
Lol, nice
&gt;In contrast here’s the same thing for [Marko](https://markojs.com/) which is way cleaner: *completely minor change that doesn't affect readability at all*
A 'kyu' is the ranking of difficulty and each coding challenege is called a 'kata'. They really draw from martial arts metaphors, you can think of the kyus like belts (white = beginner = 8th kyu)
Then we're on the same page. I wasn't sure if you were saying you like prettier, but want to configure it vs you want prettier to also lint.
Answering your question, I guess both are important with the latter being more important but I'm a bit of a noobie so I really am not concrete on that. 
A delicious polyfill
You might not be considering a complete component.
Thanks for making the internet a better place.
&gt; You can replace all of them with a fairly simple script that just calls the dependencies instead. This might be true if you're developing a library but it's absolutely false when developing an app. Webpack can automatically chunk and code split your code in locations that are unknowable a priori, import file types differently based on context, etc. These are not things that can be easily done with npm scripts. If you manage to get it working with scripts then you'll end up reinventing a bad version of webpack. &gt; but I think you're looking at them from the wrong height because there is nothing inherently bad about recommending grunt over webpack. I can't stress enough how much I disagree with this. In fact, the entire point of my previous post was to reject exactly what you're claiming. I think that view is really quite harmful to new developers. I don't think I lack perspective. I've used all of the tools that you mentioned and understand the problems they solve. I'm also familiar with their deficiencies. I wouldn't recommend using grunt over webpack/npm scripts in a new project.
Thanks! Great Suggestions!
&gt; Chinese people don’t even use NPM. Could you elaborate on this. How do they package and distribute modules?
To be honest, Prettier defaults are nice but I think they should add extensibility. This is because every project that I have (I am sure others have the same initial approach) starts with defaults (e.g Airbnb). Then, over time, you or your team starts to get annoyed about a certain default; so, you change that default for better performance. But that’s just my opinion. They might never change defaults besides the limited config.
The VM will add to the load on your PC so you’ll benefit from a faster machine regardless. I’ve learned over the years to embrace Docker, and make containers for my different projects. This gives portability and isolation, huge wins IMHO.
&gt; But the frustrating thing is that Webpack 4 finally fixed tree shaking Not quite, in my experience. It works for your own source, but for libraries from npm it still didn't work for me. I had to resort to directly importing functions, like `import parse from 'date-fns/parse'`.
I think you need a lot more info if you want a meaningful answer.
I have! At least of React, vue, ng. Which is my favourite to work with? React by far. Which is "best"? It really depends who's asking, and what you value on that particular project. I like React because it's just a vdom and a handful of lifecycle methods, and doesn't bog you down with a bunch of `v-` or `ng-` prefixed attribute microlanguage. You barely even need to "learn React", really; if you can write good presentation logic compositionally, you can write good React. It's `Array` methods instead of `v-for`, and an actual `if` instead of `ng-if`. That said, there are lots of devs who like that kind of thing, and if you're moving a team that's had plenty of experience on some late-binding jQuery app over, React may be too big a jump for them to do well, but vue a good fit.
&gt; gorilla type marketing That's how they promoted Donkey Kong!
Arrays
I haven't paid attention. Does react get hate in this subreddit? And if so, is it react and react native that get hate or just one or the other?
Are you under the assumption that a VM will speed up a modest PC? I don't see why you wouldn't get the fastest thing you could get regardless of what you're going to run on it!
so 8th kyu is easy and you had some interviews that were 5th kyu, so even easier? sounds good to me lol
for a beginner you don't need to really use several environments, running on windows and maybe a linux VM would suffice. I personally use ec2 on AWS to test and deploy in different environments, and they offer free tier servers. As for power, what's most important is that your pc has alot of RAM (I recommend at least 16gb), and alot of storage to manage the ever-growing list of dependencies modern day web development frameworks require. 
This is great advice. Thank you ✊🏾 
If React is Summit1g, Vue is Ninja.
You mean "find and replace"? Most editors that I've encountered have RegExp support for find and replace.
It might !== but does it == ?
From the article, it looks more like they hit the following issues: * Two existing, well-resourced native hardware teams * Web engineers using React-Native to push simultaneous mobile features (undercutting the mobile teams) * Resulting friction / lack of communication getting blamed on React-Native If you have kick-ass IOS and Android developers, React-Native is probably overkill. The use-case from what I understand is to give early movers a 90% solution without requiring native developers. 
What I mean is [this functionality](https://raw.githubusercontent.com/ziolko/intellij-javascript-symbols/master/images/refactor.png). It's more like renaming a variable than "find &amp; replace".
&gt; Webpack can automatically chunk and code split your code in locations that are unknowable a priori, import file types differently based on context, etc. These are not things that can be easily done with npm scripts. If you manage to get it working with scripts then you'll end up reinventing a bad version of webpack. You seem to be thinking that I'm suggesting reinventing the wheel. But there are babel plugins and requirejs plugins and plenty of other scripts that do these things for you. I've had to do this in old, legacy projects that couldn't be moved to webpack very easily. It's super, super easy. Webpack just forces convention and provides a community, just like grunt and gulp and others. That's not to down play how good that aspect is but that also doesn't mean anything else isn't useful or possibly even ideal in different situations. &gt; I can't stress enough how much I disagree with this. In fact, the entire point of my previous post was to reject exactly what you're claiming. I think that view is really quite harmful to new developers. JavaScript developers were fine before webpack and grunt and gulp. It's seriously not nearly as big of a deal as you make it out to be. Let's not forget the documentation for Webpack 4 is still pretty terrible. It's a great tool but let's not be dogmatic about it 👍 &gt; I wouldn't recommend using grunt over webpack/npm scripts in a new project. *New* is the context you didn't have before in your statement. So I'm guessing you understand webpack isn't always the best recommendation? 🙂
From [their list of technical issues](https://medium.com/airbnb-engineering/react-native-at-airbnb-the-technology-dafd0b43838) it also seems like React Native just isn't as mature as they'd like it to be. FWIW they seemed fine with React itself, but it wasn't worth the effort to merge their mobile codebases.
The great firewall of china means that your access to a western CDN, or NPM might go down. On one project that I worked on I was told to use an approved Chinese CDN, or ship the project with all of the NPM packages in the repo. 
"Sunsetting" - I hate corporate speak. Why not say "ending"?
\&gt; Is it like this for you guys or how do you deal with it? Most of my day is spent going to google, typing in the first three letters to some search, looking for the first purple result, and then copy/pasting from that resource, like I have 1k times before. There is nothing wrong with copy/pasting from Google/StackOverflow if you are using it as a snippet manager. I would assume everyone that is producing does so.
Only time no date... Eg "03:00" only
your button is not set to be hidden by default. add 'display: none' to your div &lt;div id="Proceed" style="display: none"&gt; obligatory "don't put styles inline. use a stylesheet" but this will get it working. also open your browser's developer tools and watch for errors. no capital d in getElementById document.getElementByID("Proceed")
Sorry I wasnt clear, 8th Kyu is beginner and 1st kyu+ is expert.
ahh gotcha. i was wondering how i already made it to 8th level. i'm over here like "man i'm good, i didn't even write any code and i'm an 8th level!"
WOW! I had seen a tutorial that said use display: hidden display: none ... Turns out I was putting it in the &lt;a href=...&gt; because they were butted up together. Thank you so much. I spent hours battling this and not being able to figure it out. I can't thank you enough. 
npm downloads are not a good indicator of usage since a significant amount of vue users don't use npm to pull the framework. One of the nice things about vue is that you can just edit your html file to include vue from a cdn and get to work instantly without additional tools. I've seen projects on GitHub that import vue like this and then use npm for other smaller libraries. You can't really do this with React since you need to run babel and webpack on node to compile JSX. 
&gt;Also if I bootstrap a project with vue-cli today, and then webpack 5 gets related, will vue-cli be able to do the migration for me (minus any custom configurations I made)? Yes. While `vue-cli v2` (and 90&amp;#37; of boilerplate out there) rely on custom one-time webpack configuration that's dropped into a folder and then you're on your own, `vue-cli v3` (`@vue/cli` on npm) hides the webpack setup in its `vue-cli-service` package so the Vue team can easily update the internal webpack implementation later. Sort of similar to `react-scripts` from `create-react-app` if you're familiar with that. But you can still adjust the webpack config to your liking by either supplying a webpack configuration object that will be merged into the base configuration Vue has set up or using [webpack-chain](https://github.com/mozilla-neutrino/webpack-chain) which is pretty cool. So if vue-cli updates its webpack version that would be the only part you'd (potentially) have to adjust. `vue-cli` already changed from webpack v3 to v4 like that and recently added "modern mode", so you have to do nothing (but enable it) and Vue will automatically create both a small bundle meant for modern browsers (supporting modules) plus a bigger bundle with all the polyfills included to support old browsers. Magic! Also you can use the CLI's plugin system to easily add features/integrations like testing, eslint/prettier, PWA support, GraphQL and many more anytime you want simply by running `vue add ...`, even if your project isn't in a 'virgin' state anymore. It's all just super nifty. :D
I've had a similar experience with React-Native: * Cryptic platform-specific errors and bugs * Immature and largely outdated ecosystem * Repo issues that get closed and/or ignored for months * Buggy tooling. You can't trust `react-native link/unlink` to not break your app. * Upgrading is horrible. Get ready to spend a day or two manually re-installing and debugging your native dependencies if you need to upgrade. Sometimes it's faster to just re-run `create-react-native-app` and copy your code over. * Flex works but yoga isn't CSS and it's going to cause you problems. As a long-time user of React, I'm hopeful that React-Native improves and becomes more usable as it matures, but for not I'll stick with native and [Cordova](https://cordova.apache.org/). 
I hate both of them. React is pure garbage developed by a fucking nimrod.
Absolutely this. When getting started it's nice to have a big, active community to help with the learning process. More users = more guides, articles, cheatsheets etc...
I have tried those three js framework react, angu and vue all of them are great. But, I still prefer Vue due to three simple things like easy implementation, lighter size and very fast. Learning curve is much shorter especially to those coming from native js or jquery as an example.
Does it search the AST?
yea, my thinking was if the size of the project is decent it wouldn't be too bad. Unless you're just trying to learn then a small one is fine too.
Noted, I guess before agreeing to something with a client it would be help to know the limits of the framework.
yea, I'm just going to learn react unless something happens where I really need to learn something else.
I definitely agree with what you're saying here
I don't know about the specifics of using firebase but //get the npm library, with the libraries name. var jwt **=** require('jsonwebtoken'); //sign the credentials var token **=** jwt.sign({ foo**:** 'bar' }, { algorithm**:** 'RS256'}); Send the token back in response or somewhere via some method, .. maybe a post idk. On the other end its a case of decoding it var decoded = jwt.decode(token, {complete: true});
And less caching.
I used to enjoy Vue, but once you realise how JSX works and the goal of a VDOM, you'll come to prefer React instead. The view is "just JavaScript" (function calls) disguised as XML tags. This means you can just use regular JavaScript logic to construct views rather than proprietary attributes: `.map` instead of `v-for`, conditional expressions instead of `v-if`, etc. Also, Vue has many [caveats](https://vuejs.org/v2/guide/reactivity.html) because of its mutation detection. This can leave you wondering what's going on when updating the data of a component, since it embraces mutation instead of purity. Even Dan Abramov said in a tweet this is the biggest downside of Vue's architecture. Rather, you should call something like `this.updateData()` that does a partial merge with the current data and enforce you to keep the data pure to prevent strange cases like this. I had so many issues with this when learning Vue. Vue is really accessible and has the appeal of separating HTML, JS and CSS, but I think it encourages bad practices. React seems really foreign and strange, but I believe its architecture is the best we have currently to develop reactive apps. (Or Hyperapp, a lightweight version of React that is even better imo).
You haven't included an 'else' in your ternary statement. This should work: `let giveLargest = (current) =&gt; (current &gt; largest) ? largest = current : undefined;` 
more stackoverflow questions and answers is big for me. always helpful to see an answer with a high vote count and comment discussion to acknowledge that 'this is the best way of using X tool'
Please format code correct. Example of code youcan post to [gist.github.com](https://gist.github.com) or [codepen.io](https://codepen.io). Also use Chrome DevTools (Networking tab) and past "console.log()" debug lines to code.
You need two expressions for a ternary operator. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator The traditional if(condition){do something;} syntax is probably more appropriate in this case
Alright dude. Stow the hate. I personally prefer Vue but the most widely used JS framework out there (react) is hardly garbage.
If you don't understand the ternary operator why don't you use a classic if-statement? It's more readable and more straight-forward. Anyways, without checking your functionality, a ternary operator NEEDS the "false"-part with the colon: condition ? true : false Your problem could be solved very easily with ES6: function findLargestNum(arr) { return Math.max(...arr); } I know, it's probably about learning algorithms etc. so this might be a more classroom conform version: function findLargestNum(arr) { let largest = arr[0]; for (i=0; i&lt;arr.length; i++) { if (arr[i] &gt; largest) largest = arr[i]; } return largest; }
React is cancer just like facebook and all the fuckers who use it and work on it. Pure evil.
Yeah, it's all situational.
Lol like infographic- oh you mean diagram professor? Lol
Try some udemy courses. Maximilian Schwarzmueller makes excellent courses in them. The biggest challenge you'll face is that there is a radically different paradigm of how to write your code with these frameworks. It's better IMO but you need to think differently to work with them.
Yeah, the "fix" required that npm libraries mark themselves as side effect free in package.json. The major ones like React have, but you don't have to look far to pick up a library that hasn't dealt with this yet. It gets back to webpack never really "fixing" this, because they've shifted a burden onto people shipping packages. &gt; I had to resort to directly importing functions I've still had that blow up, when said function itself does full imports of its own dependencies. I remember importing one small function from a package and bringing in the whole of lodash for example, because that function used one lodash function and imported the whole damned thing.
Just for completeness; it's easily solved without ES6 by using the apply() method of the function prototype aswell: Math.max.apply(null, arr)
React !== The whole JavaScript community. For me, React has too much "baggage" of tools that do this and that just doesn't work for me. Though I'm often coming from a standpoint of updating and maintaining legacy applications, persuing libraries that are built more closely on top of Web standards makes more sense for long standing applications with a long shelf life.
shit is rough in the mobile world. glad I left that shithole. if you go pure native, apple has you by the balls in terms of swift - every version it breaks. don't know if they've ABI stability yet. Android dev setup probably a mess, setting up android studio alone can be hellish, maybe things have improved. don't get me started on React Native. plus if you're a small time guy like me, you're dealing with shitty clients who think their app is going to be the next Facebook. 
shit is rough in the mobile world. glad I left that shithole. if you go pure native, apple has you by the balls in terms of swift - every version it breaks. don't know if they've ABI stability yet. Android dev setup probably a mess, setting up android studio alone can be hellish, maybe things have improved. don't get me started on React Native. plus if you're a small time guy like me, you're dealing with shitty clients who think their app is going to be the next Facebook. 
Not too long ago the web community would've killed to get just one of today's amazing frameworks. Now we have fights over which amazing framework is the amazing-est. 
just out of curiosity...what do you use? 😂
React, Angular and Vue.
Yes, just not on pizza.
You seem to imply React does not encourage bad practices, in my experience it encourages the worst of the three.
You'd be better off learning React and Vue as they're similar. Biggest difference in a nutshell is probably JSX. I can also second [Maximilian Schwarzmueller's courses on Udemy](https://www.udemy.com/user/maximilian-schwarzmuller/), they're excellent. He has courses on Angular, React and Vue so whichever way you go, you should definitely check his courses out.
I appreciative because Airbnb help react native grow. I will say a lot of their problems came from integration rn with native. React native serves a place in the ecosystem. Hopefully with Facebook's upcoming plans they will make things better. At the same time React Native is still a great option, but I wouldn't integrate into an existing native app. Starting from scratch there is a lot it can do and while still using one codebase for IOS and Android Platform.
Who says you have to use a framework at all? They slow down a site a lot, and are almost always used for what could be done with a very small amount of Javascript and a couple small modules.
It really is terrible
😂
Hah, glad to see no one has learned anything from the great left-pad outage :P
You, sir, clearly have never made a single pizza on your own.
Why reinvent the wheel when there are so many turnkey solutions available ?
Okay, but an explanation of why would be nice?
"Ending" has too much finality to it doesn't it?
1 medium sized project
Try “complete react and redux” course by Andrew Meade. If you learn, you won’t become a stronger programmer as you could be with react. 
Do you have a good working knowledge of other programming languages at this point? If not, your time would be better spent learning another, different language than learning the arcane parts of JS.
Very interesting perspective. What do you mean mobile world? Are people moving away from pure native mobile development? 
I know a bit of Swift, Java, and PHP. I’m working as a front end developer right now which mainly consists of using HTML, CSS, and PHP but I’d like to improve my JavaScript so I’m better at my job.
It's like calling a fat person 'big'
I may be showing my age but I learned prior to these resources so I have a different perspective on what's good or bad to use. I learned thru books and school, where longevity was measured in years. It's so easy to flood the sites and search results with answers so maybe that is why everything can move so fast; so many resources to help those completely new. 
Thanks! I ended up finding what I needed here: [https://kbpdfstudio.qoppa.com/sending-email-with-pdf-form-data-file-and-customize-email-subject/](https://kbpdfstudio.qoppa.com/sending-email-with-pdf-form-data-file-and-customize-email-subject/) I applied a JavaScript action to my submit button and used a code like this: &gt;var customSubject = this.getField("fieldName1").value + ' ' + this.getField("fieldName2").value + ' ' + this.getField("fieldName3").value &gt; &gt;var mailtoUrl = "mailto:[e](mailto:marketing@firstaztitle.com)mail@address.com?subject=" + customSubject; this.submitForm({ cURL: mailtoUrl, cSubmitAs: "PDF" }); Thanks for your time! :) 
An odd reference, but ok.
Then I'd say avoid "Understanding the weird parts" just on the title alone. Understanding the weird parts of Javascript probably doesn't align with your goal of getting better at your job. The weird parts, and there are many, are best avoided.
Native development sucks. Developing for Apple is a nightmare with the worst dev tools about which the only kind thing you can say is at least Swift is better than Objective-C. But then again stabbing your eyes out with a rusty fork is better than Obj-C. And Apple dev is expensive. Android is still stuck with Java, hundreds of MB's of sdk's and poor debugging. The tooling doesn't even being to compare to webdev. Flutter is a real contender but Google tools aren't considered cool, unlike FB, so it'll never catch on. Xamarin/C# is also much better.
There’s a serious lack of angular mentioned in your comment...I dig it.
All things equal, CI / CD pulling from NPM would still be a decent gut check since downloads would be high, yes, but normalized out, it’d still say that React is used in more projects overall. That or vue devs build less than react devs, or are just better coders...or both!
Right, you just gotta npm install the pizza.js package with its 1,000 other dependencies.
So you think the Complete 2018 JavaScript course would be better then?
yarn add pizza-to-my-mouth
I smell insecurity on that kind of titles.
Ngrx sucks
It's actually very helpful. So, the backend of my site does not provide a key, rather, it only verifies it?
Found my team by going to from meetup.com
you should learn https://github.com/axios/axios
I think it's more that people would ditch having three different native apps, (web, Android, and ios) for one even if it ment they were a few limitations and wouldn't be as good or use the unique features. witch was the promise of react native, it would be perfect for apps that are just glorified web pages, (not that they are bad things) but it sounds like there were a few to many hoops.
learning axios would not solve his problem
update: When I use the error method with a function of console.log("hello") I get back "Hello". So this tells me that an error is happening but it is not being displayed. 
Immerse yourself in it completely - I suggest: Javascript: Understanding the weird parts by Anthony Alice on Udemy Reading YDKJS https://watchandcode.com by Gordon Zhu Don’t give up - it’s hard work 
We're not fans of it either. 🙂 React and Vue (and Svelte and Angular and others) are collaborating more than we're competing. We share the same basic goals (and a lot of overlapping community as well).
Care to elaborate? 😊
Also I bet that Vue is very popular in China and they probably have their own npm since downloading shit outside the firewall is a pain. But I don't think Vue is super popular in the states, I haven't really met many companies that use it. The ones that did switch the Vue were using angular1 
Parcel isn’t zero config for cdn hosted libraries so....
React is the best! Just npm i create-react-app and look how the boilerplate works. 
Totally makes sense when put like that. RN has its place but if you have the talent, why not use it.
Would help if you tell us where you got the API. I tried it myself and I'm getting weird errors. Add an error callback so you can see the problem $.ajax({ url: "https://api.fortnitetracker.com/v1/profile/{pc}/{unspeaking}", method: "GET", headers:{ "TRN-Api-Key":"100c1fd5-6e82-4b14-b78c-e28ff05c8fa3" }, dataType: "json", success: function(data){ console.log(data); }, error: function(err){ console.log(err); } });
I think you have a typo in your header you have an extra colon in your header request. &gt; headers:{ "TRN-Api-Key:":"100c1fd5-6e82-4b14-b78c-e28ff05c8fa3" }, your header should be something like: headers: { "TRN-Api-Key": "100c1fd5-6e82-4b14-b78c-e28ff05c8fa3" },
I'm more of a sails.js guy (although working more in python this year), but I would approach testing the same way if I were to use the stack you describe. &gt; 1. End-to-end testing — yes or no? Yes. It isn't necessarily testing the third-party stuff so much as your implementation of the third-party stuff (and whatever custom code you have on each endpoint). This is a real boon when you have a lot of updates to apply and you don't want to check the change logs for every lib. Just apply the updates, run the tests, and then check the change logs for the parts that are broken. &gt; 2. Mongoose: use real database or use mocks? Use a real DB. There can be minute differences between the real thing and a generic in-memory datastore. Using mongoose (and mockgoose) this may not be as big a deal as it can be with an ORM that supports multiple DBs, but I would still run it on a real DB: The closer the test environment matches the production environment, the more reliable the tests are (and, depending on the situation, it's nice to be able to query the datastore if a test fails, rather than using logging... although a debugger would be better, if that's up your alley).
Excuse my ignorance, but does vue have a way of cleanly handling side effects, i.e. redux thunk or saga? The API thing would be handled better that way.
&gt;I apologize. I got the API from [https://fortnitetracker.com/site-api](https://fortnitetracker.com/site-api)
This book is from a few years back (but so is jQuery) and really helped me, very easy to read: [https://www.amazon.com/JavaScript-JQuery-Interactive-Front-End-Development/dp/1118531647/ref=sr\_1\_3](https://www.amazon.com/JavaScript-JQuery-Interactive-Front-End-Development/dp/1118531647/ref=sr_1_3) Also it's a great idea to listen to beginner-friendly podcasts like Shop Talk Show and Syntax. They are great for getting you comfortable with the terms and technologies around. Best advice is to just keep tinkering and making sites!!! Make little games in [www.CodePen.io](https://www.CodePen.io) and also make a CodePen for when you want to get better at some Javascript function. Then you add that to what you know and it feels great! I'm making a little battling game where little Street Fighter character avatars "fight" each other. I recently added sound and it was fun! [https://codepen.io/spaceninja151/pen/eKGyJX](https://codepen.io/spaceninja151/pen/eKGyJX) Good luck and have fun!
Thank you, I believe you're correct. There was an extra colon in there. 
Do some research yourself on the differences between the two classes before asking for this guys opinion again. He has already implied he has no knowledge of them and is currently making YOUR decision for you based on that.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Wanted to code this as an experiment. Please bear with my bad late night code.
Sure thing no problem, glad to be of help just be mindful of those pesky typos sometimes a single colon or semi-colon would ruin everything.
Are you familiar with TypeScript's string literal types or its string enumerations?
I'm of the opinion that every single statement is completely bunk without a side-by-side comparison of relevant code. I don't give a shit how well your library "scales" unless you can show a concrete example from a large project.
lol, author panicked
This is true. I’ve already done a fair bit of research but the main point of the post was finding people who have taken either courses and seeing what they thought. Right now they both look almost equal with maybe the Jonas taught course looking a bit better as it is more up to date. 
Dude you need a beefy PC when running VMs. So there really isn't much of a choice. VMs aren't alternatives to better PCs. VMs are alternatives to multiple PCs. You got that concept mixed up.
Ahh good to know. Thanks for clearing that up ☝🏾
You don't need to learn Typescript with React. So I would say after one month you should be able to create a medium complexity app. Getting proficient in Angular will definitely take longer. Depends how good you are at learning new languages. If you know any language with classes it is going to help.
While I've been doing the views with xml-ish syntax since even before react (in xhp), I've recently moved away from JSX and see it as superfluous. Ecma is a plenty good declarative language on its own. Implied prop names and trailing function args make it very clean. Especially as we get more stateless in our child components, I find we're more frequently passing down the same prop name over and over. We can spread our jsx props, but that's basically extra syntax just to use vanilla ecma. &lt;Foo bar={bar} baz={baz} /&gt; Doesn't feel any cleaner than h(Foo, { bar, baz }), I think I mostly just liked jsx because it felt familiar, but when I really challenged my beliefs there's nothing objectively more clear about it. 
I think a reducer can also be a solution. `arr.reduce( (acc, cur) =&gt; acc &gt; cur ? acc : cur );`
Use docker to run a test db and dockerize your e2e testing as well. 
They're tools, and all tools should be used for different cases. It's impossible, as you say, to make a judgement of its general usage in any situation. Use the right tool for the right job, you don't judge a hammer on its ability to saw wood.
Thanks for the super detailed reply! I still have to go through the cli docs, but I'm curious if you've had any customization issues? The part about vue-cli hiding some webpack setup has me a bit worried because I'm not sure exactly how configurable vue-cli makes it if I need to add, overwrite, or even remove certain parts of the internal webpack config.
🤣
Whoa. React isn't my first choice either, but I can see its value in keeping lots of moving parts organized, and in making the code readable/reasonable for people who didn't write it. I also get the impression that it's a "safe space" for people with strong OOP backgrounds who are moving into web development... but I'm just a novice hobbyist, so I might not have the full story there.
I could never even get the enviorment up and running for RN. I do like react, though. I'm looking to start building apps with Ionic. What's the consensus here about Ionic?
I have learned both in a short period of time. React is much more intuitive when first getting started imo. So it takes a couple weeks. I started with angular 5, took me about a couple months to create the same exact app. I like React way more than Angular. 
Angular has traditionally been the safe space for OOPers. It’s loaded with OOP patterns. 
This is the correct answer.
Try it on tacos. 
Not really; it fails inexplicably on the vegetarian pipeline when I replace the mock pepperoni libraries with the actual components.
Yes, this plugin works on AST. I wrote it by following [this documentation](https://www.jetbrains.org/intellij/sdk/docs/welcome.html).
Understood; sorry for being a bit of an ass. Hopefully others have some input for you.
Didn't thought about this one!
That also sounds terrible
I am not familiar with Typescript. Looking at [documentation](http://www.typescriptlang.org/docs/handbook/advanced-types.html#string-literal-types) I'd expect that IDE support renaming those literals (e.g. if I want to change "ease-in" to "css-ease-in" I can do it using IDE "refactor" function). If this is the case then it's similar indeed.
I’m also worried about dumb older browsers and location as an id clobbering window.location
Sunsetting implies phasing out rather than hard-stopping. I'm no fan of corporate speak but I'd probably use this phrase in this case. 
Hi, I suggest you reading this really good post about union-types, which includes a comparison between the most popular libs in js. We are starting to use union-type in production, although I haven't created a custom type yet :) [better js cases with sum types](https://medium.com/fullstack-academy/better-js-cases-with-sum-types-92876e48fd9f)
Here is a ranking based on the number of websites using Angular, React or Vue: 1. AngularJS (\~192,000 results): [https://www.shodan.io/search?query=http.component&amp;#37;3Aangularjs](https://www.shodan.io/search?query=http.component%3Aangularjs) 2. React(\~122,000 results): [https://www.shodan.io/search?query=http.component&amp;#37;3Areact](https://www.shodan.io/search?query=http.component%3Areact) 3. Vue (\~35,000 results): [https://www.shodan.io/search?query=http.component&amp;#37;3Avue.js](https://www.shodan.io/search?query=http.component%3Avue.js) This doesn't take into account projects that use React Native, vhosts etc but it still shows the usage difference between the various JS frameworks. Personally, I'm surprised how many websites still use Angular - looks like it is a lot more popular/ common than one would imagine from Github stars/ npm downloads.
Especially on pizza, you monster!
Are you calling me a monster? I agreed with you about it being horrible on pizza!
Pineapple module is my go to module.
Its not so much React but more the people who use it are fuck nuts.
Also I don't think you should be using this client side and putting your api key where anyone can get it.
For now I don't think I need any automatic syncing, and not using couchdb at all. Do you think PouchDB is worth using over the alternatives thing like Dexie? Does it have any benefits aside from the couchdb syncing stuff?
Have you considered splitting the pizza component into "left" and "right" components and only importing the pepperoni library to the "left" component and then testing the "right" component with the vegetarian parameters ?
can you be a bit more descriptive other than just cleaning up? What specifically do you want help with?
If you put it in a github gist, people can suggest edits for you to review.
&gt; Component boilerplate What you are showing as boilerplate is actually a good practice. You can of course do it this way: ``` @click="someVariable += 1" ``` But just like in React with `setState` in `render`, it's a good practice to move such logic out of `&lt;template&gt;`/`render` into separate methods.
One programmers best practice is another programmers WTF. I don't disagree with you, because everyone has their own opinions about what something a "best practice". Time also erases those best practices almost without exception.
Pineapple Salsa is the stuff of dreams
The article says is talking about react native specifically. Airbnb still uses react for it's website.
I needed months to fully understand the old Angular, and i mean the basics only, the current one is much better and i was up and running quickly, but i still think you're in at least for weeks to understand the basics deeply. React is different in that regard. To give you some perspective, in the beginning you'll use one api function (render), 4 class life-cylces (componentDidMount, componentWillunmount, componentDidUpdate, render), setState and some minor JSX semantics (class -&gt; className, for -&gt; htmlFor, style is an object). This is what they'll teach you in online courses, for instance [egghead](https://egghead.io/courses/start-learning-react) and it doesn't take longer than an hour. Now you can run and create simple apps without looking into docs, because Reacts api surface is small. The real challenge will be es6 and up if you don't know it already, most examples you will find will make heavy use of es-next. And as with all frameworks, if you have the basics down you go deeper, state, routing, ssr, static-sites, animations, and so on.
Prepack
Normal: * Script concatenation (or the opposite, code splitting, where it makes sense) * Gzipping (or brotli/zopfli) * Tree shaking. * Good caching headers. Experimental: * Preprocessing: https://prepack.io/ * Implement in WASM binary to avoid much of the parsing and optimization runtime costs. Probably a bad idea: * Code golfing * Code golfing for gzip: https://github.com/dwighthouse/onfontready/blob/master/docs/compressionTechniques.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [dwighthouse/onfontready/.../**compressionTechniques.md** (master → aea0e5f)](https://github.com/dwighthouse/onfontready/blob/aea0e5fa6374ae99bf44d2d8ce9c6d93e9edd68d/docs/compressionTechniques.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e0z78xd.)
I recently learned about the 'soured cream' package. It's really popular in a remote corner of northern Germany. 
Ive done the course by Jonas. Great course, you'll learn everything about js, I really enjoyed it. Had many ahhh moments. I, aswell, did it with existing skills in js. Can't say anything about the other course tho.
😅👍...
Can someone eli5 the difference between react redux, react, and react native? Is this a sign that I shouldn't learn react?
They all suck equally.
This one is funny, why the down vote??
Try to set CSS dynamically. As a designer, not programmer. "This" binding on every event listeners. I thought we were over that kind of stuff already. Conditionally render a simple text: {1 &gt; 0 &amp;&amp; &lt;p&gt;You &amp;&amp; an element!&lt;/p&gt; } Silly React.
React is just React.js the javascript library for the frontend platform. Redux is sort of a state management system you can use within react as an addon (IMO its got some weird quirks that I don't think help much of anything there are easier ways to do what it does). React native is the same type of Component based development as the javascript library that compiles to real native code for both iOS and Android apps. I would definitely still learn normal React.js, its pretty much the king right now vs Angular and Vue as far as job listings go anyway. Revisit react native if you really want to learn mobile dev using it. IMO I didn't have any issues making some basic apps but a company like AirBNB may be doing some super complex low-level stuff behind the scenes that React Native can't handle(i.e. hidden user tracking and analytics type stuff). For your run of the mill app that just has its features and does those things you'll be fine.
I built and maintained a fairly substantial iOS/Android app in Ionic a few years ago (back when it was Angular 1). Things might have improved since I used it, but I would strongly recommend avoiding it. The performance was just not good enough. Your app will run like shit on mid-level phones.
[React](https://reactjs.org/) is a library to create web apps. You'd use it to create single-page apps or UI which needs to change/update based on user input. It's strong points are that it's declarative (so the data is seperated from the view, you don't need to manually change the html/text of dom elements) and uses JSX, so looks a lot like HTML so is nice and familiar. [React Native](https://facebook.github.io/react-native/) is a entire toolchain to create native Android and iOS apps. The apps are written in Javascript and use React for layout. You'd use it to create cross-platform apps rather than learning to use the tools provided by Apple or Google for phone app development. [Redux](https://redux.js.org/introduction) is a data store. You'd use it in a single-page app to save data between page changes, or to fetch things from a database or to share data between different components. It's key points are that it's an event bus, so you pass it an object describing the event and some data, and the store updates; only one event can happen at once so it's easier to know exactly what's happening to your data at any point (ie nothing's going to change the data without you realising). It's a stand-alone library so can be used without React; if you want to use it with React then `react-redux` is a library which makes it easy to use the two together. (Note: This is a very brief overview so I missed loads of details out!) React is quite a nice library, and I found it much easier to use than Angular, so you may as well give it a go
React manages view for web apps (think browsers); react-redux is a pattern and library to help you manage state inside a large application; react-native adopts the component approach from react to help you build for iOS and Android without having to necessarily learn Objective-C/Swift and Java/Kotlin just to get started, respectively. React is its own beast and well adopted/respected for the job it does. Just two cents in case it applies, get strong at JS first, then go for React, Angular, Vue or whatever you desire. They're fancy tools that abstract away a lot of ideas taken to be givens; you want to learn to handle a good ol' hammer before you use a concrete jackhammer.
I’m not in a camp. I’d love to use any which is something i always bring up on interviews. In the end they’re not that different anymore and i put more weight on what the project tries to solve.
What is x?
Speaking of not judging technologies that haven't be used, looks like this recently posted blog article is trying to address that a bit [https://twitter.com/nullvoxpopuli/status/1009120627939307522](https://twitter.com/nullvoxpopuli/status/1009120627939307522) There is a crazy amount of tribalism in the javascript world... and I think that part of that has to be due to just how long it takes to learn and get good at a particular ecosystem. People who learn React may look at how Angular structures things and immediately write it off as weird, on un-ergonomic, when in reality, dependency injection is the best developer experience missing from React at the moment. :-\\ idk
I also got frustrated with RN and moved to Flutter. I was dubious because dart, but so far I like it. Our first app should be released in a couple of months if all goes according to plan.
Take the course by Jonas for sure. While understanding the weird parts does go pretty in depth it's very boring and not very practical. 
You're defining X as a boolean in the first 2 (or rather that's what you're casting it as), but in the last one, you're passing it an undefined variable and asking it for a property which obviously won't exist (unless x is defined before this, but there's no context for it so we can only go on what's present). Assuming it is defined, then it's not something with a .length or the length property is undefined (nothing immediately springs to mind).
Android also has Kotlin now.
Agreed, haven't had a great experience with Ionic, react native hasn't been to bad.
Arrays of objects often make sense, it all depends on what you are trying to do. Also you don't need to assign them variables for access, we can do: students[1].intro(); Good use case for the array: students.forEach(s =&gt; s.intro()); 
Imagine you wanted to render a list of students in HTML. Having student objects in an array would allow you to express that. Pseudocode for example: for student in students create list item html for student append generated html to list in document That way your code responsible for rendering the list doesn't need to be aware of how many students exist. In your case imagine that you wanted the user to enter their name and then call the appropriate intro function. function greet(name) { var student = students.find(student =&gt; student.name === name) if (student) { student.intro() } else { alert(`No one by name ${name} found.`) } }
You could probably get away with inlining your code (enclosing that one line in backticks \`\`): `$( "#place_btn" ).click(function() { if($('#payment').is(':checked')) { var x = 1; $.ajax({ method: "POST", url: "/payment", data: { var_x: x } }) .done(function() { alert("aaa"); }); }; });` But a more eyes-friendly version would be: $("#place_btn").click(function () { if($('#payment').is(':checked')) { var x = 1; $.ajax({ method: "POST", url: "/payment", data: { var_x: x } }).done(function() { alert("aaa"); }); }; });
An array, but why that matters?
Why do you think it's undefined? Imagine the three log statements are consecutives. It's printing `true` so they're singolarly thruthly, but falsy when comined woth `&amp;&amp;`. Why?
Imagine your list of students wasn't defined in Javascript but came from a database, you would need to know exactly how many students you had for things to work effectively, then what if you need to iterate over them to perform the same action on each? It would be a pain. There are other solutions to this problem but using an array is one of them. With arrays, we can just grab the data from a database of some description and store them in an array. Since they're already in a list and therefore associated with one another we can treat them as a collection. Array sizes are arbitrary, we can make them as big or as small as we like and they're easy to create programatically. Arrays have [lots of useful methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) that you can call on any array, they make performing operations on all or some of these items both simple and fast. Perhaps most importantly, your code doesn't need to know too much about your data, which is generally a good thing, if your code is tied too tightly to a specific set of data then it becomes fragile, difficult to reuse and difficult to maintain.
yes, Just verify token
If i execute your code with \`const x = \[1, 2, 3\]\`, the third line log "3" as it should. (() =&gt; { const x = [1, 2, 3] console.log(Boolean(x)) console.log(Boolean(x.length)) console.log(x &amp;&amp; x.length) })() true true 3 Which environment did you use to execute this ?
AWS Lambda on Node 8.10
That's strange... Are you 100&amp;#37; sure x is an Array and not on Object (no length method) ? If you log x.length you get a number ?
Why wouldn't you just write the intro function once and call it like intro(students[I])...
It's printing true, right? So can't be undefined. Furthermore I'm printing is value and yes, it's a number: 13.
You got a point :/ Well I don't know, this doesn't make sense... The "&amp;&amp;" should return the 2nd argument.
[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical\_Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators)
ty. clear explanation.
Read as: "If, as an investment, I only learn one, should I learn React or Vue?" The article says "React, because usage is higher." Whether this is a good investment in the long run is hard to say. There is going to be lots of React to support in the future. There *might* be lots of new React projects in the future. My personal recommendation to someone thinking about it this way: * You will be able to very quickly pick up Vue on the job when you encounter it. * React will take longer. Learn React at home in case you need it. Also, it's fun. * Pick Vue for new projects.
Thank you, I'm gonna read it!
No, this goes totally wrong. If you think you have to mock your dependency because it does not work as expected, you should better make a pull-request to the dependency where you add a test to ensure it works. By your logic you should also mock node-internals and not even trust the javascript programming language itself. Mocking things in TDD is a workaround which should only be used when there is really no other way to write a useful test.
Solved. Removing "library" key resulted correct build. 
You sure are. It's human nature to compare and make oneself feel better by belittling and bullying inferior frameworks such as Vue and React... ;)
`mounted() {` `window.addEventListener("load", function() {` `var inputs = document.getElementsByTagName("input");` `for (var i = 0; i &lt; inputs.length; i++) {` `inputs[i].value = "";` `}` `});` `}` fixed my issue.
Yep, different use cases. Vue is better for somewhat static stuff, React is better for logic driven apps. Are we all writing the same thing? No!
This depends on the environment to a degree, will it be running in a node environment or in the browser?
I have to disagree with the claim that you "get the benefits of string constants". You don't. String constants give you, among other things, a _single source of truth_ for that name and value (which in turn gives you a place where you keep the responsibility and authority over them). Your tool may _mitigate writing the name correctly_, but little more. Don't get me wrong. Your tool _does_ help for the situation where you're using string values directly. But that help is just mitigating the problem, not solving it.
Tagmeme is a good one https://github.com/andrejewski/tagmeme/blob/master/README.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [andrejewski/tagmeme/.../**README.md** (master → c8d2b29)](https://github.com/andrejewski/tagmeme/blob/c8d2b29d3d544c2cd83b473d6a66a81275dee1d4/README.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e0zf14c.)
Interesting future but Facebook haven't even got it working with React yet.
Well if you're willing to use Array.prototype then you could also use Array.prototype.sort()
&gt; Immature and largely outdated ecosystem Woah, both at the same time. Impressive. 
You know your shit. 
Tacos al pasto with pinneaple is a really tasty meal 
Sunsetting means a gradual wind down with a defined ending point. It can also be used to imply that while something is slated to end, it may be revisited again at some future point in time. 
You should DULLY VERIFY DOUBLE CHECK your question before asking. It's look like a troll... const x = []; console.log(Boolean(x)); console.log(Boolean(x.length)); console.log(x &amp;&amp; x.length); &gt; true false 0 const x = [0]; console.log(Boolean(x)); console.log(Boolean(x.length)); console.log(x &amp;&amp; x.length); &gt; true true 1 
Probably should provide a full code snippet or nobody can give you a good answer 
Who are the sociopaths who put a star on her favorite framework? I put stars on things that I can contribute to, or I don't want to forget where the repository is, like a bookmarks system. Are these people really read the frameworks source code before going to sleep? Are they re tripping looking at the code? Star a repository with many stars does look cool in your github profile? So many questions.
If you use a framework for the databinding, remove it. The performance differences between a minimal version and a framework version will show you astronomical numbers. Not something like 25% but more like 50000% the website obesity is a real issue...
Its basically JSON. JSON objects are objects and arrays of objects, all in one parent, so you can pass it around. It is somewhat atypical to put functions in JSON, but you totally can. If its a made up exercise, then its probably weird on pupose, to mess with your head a bit.
I haven't read the post. But the Vuex equivalent of Redux sagas would be Vuex actions. They're built right into Vuex, no extra library or anything. (And Vuex is to Vue what Redux is to e.g. React)
Ending a post that says having defined component structure a la “methods” “computed” etc is just too much boilerplate with “Webpack isn’t hard” is kind of weird 
lol nobody thought this but thanks for highlighting your insecurities 
What is it unclear?
Is this the full code snippet, if not what is “x” and is there anything else between these lines of code, where are you running this code, what do you expect “x” to be, what justifies this expectation, 
\&gt; When do you personally use an array with multiple objects. When I have a list of *things* that I want to treat as a list. For instance, let's say that instead of me wanting to call \`sus.intro()\`, I wanted to say "call the intro method for all of the students". Now, I can simple do: students.forEach(student =&gt; student.intro()) Or if I want all of their names students.map(({ name }) =&gt; name) Basically, I can create a generic function of \`student -&gt; whatever\` and instead of manually asking for \`susan\` then \`ava\` then \`nick\`, I can have them all inside of a list and *iterate* over that list.
Ionic is fantastic. Performance isn't really an issue anymore since angular 2 and it's great to have a codebase to deploy to web, desktop and mobile. Disclaimer: I pretty much make a living doing ionic dev.
Why do you like flutter better?
"dumpstering"
Got it, the complaint in the post was where to put API calls, in vuex or somewhere else, he concluded somewhere else which mad me raise an eyebrow.
Feel like I've seen this before... https://www.reddit.com/r/javascript/comments/7r0i00/can_a_1_a_2_a3_ever_evaluate_to_true/
might need to remove those listener on destroy lifecycle
More code would make that change even more insignificant compared to the whole.
That time when someone deleted the pepperoni module and broke the pizza bake system worldwide.
Along with all the other fruits we put on pizza and... OH WAIT
two issues: first, your ternary syntax is incorrect, need to replace = with : like so: ```javascript (current &gt; largest) ? largest : current ``` second, once you do that, there are a couple other mistakes and it still won't actually return the largest number. Here's an alternative: ```javascript function findLargestNum(arr) { return arr.reduce((largest, current) =&gt; current &gt; largest ? current : largest ) } ```
OMG 😱🤯 But think about my case. How would that be possible? \`\`\` console.log(Boolean(x)) // prints true console.log(Boolean(x.length)) // prints true console.log(Boolean(x &amp;&amp; x.length)) // prints false \`\`\`
and don't forget textareas
What!? This is the first time I have heard of this ie11 bug.
 const values = [true, {length: true}, true, {length: false}] values.index = 0 Object.defineProperty(this, 'x', { get() { return values[values.index++]; } }) console.log(Boolean(x)) console.log(Boolean(x.length)) console.log(x &amp;&amp; x.length)
What about select, radios and checkboxes?
Look like you are not like mocking, or not quite confident about use cases. That is ok - most of the people never mock anything, and able to test anything without using mocks. Anyway - please review the video embed in the article, which explains "the right mocking" - https://vimeo.com/257056050 Mocking has nothing with TDD, and you have to mock node-internals(fs/networking) to test how do you use them. A lot of tasks are undoable without mocking.
I’m curious why you think it *doesnt* matter?
Umm.. are you sure you got 'true' for the 2nd statement? I'm getting 'true false false' using node 10.1.0 So for Boolean(x) you get true because x is defined as an array, it's empty but it exists, so true Boolean(x.length) is false because 0 evaluates to false So of course then the first &amp;&amp; the 2nd statement are false since '&amp;&amp;' operator needs 2 trues to evaluate to true https://en.wikipedia.org/wiki/Truth_table
You’re not casting them in the last statement. 
I find that Android studio is actually now an incredible idea and very easy to setup (I used to hate it, too). Programming for Android is a breeze relative to web/ios IMO 
PouchDB falls back to WebSQL and localstorage if indexeddb isnt supported, so there is that. But otherwise, probably not.
React showed the community a fundamentally better way of doing things and practically overnight made everything else feel archaic, including Ember and Angular. Vue is the only competing lib that has cloned enough of React's magic to make it still relevant. So no, I won't ever be touching Ember again
They simply are different tools for different uses and situations. They can cohexists without any problem and we should all probably be able to use both of them :-)
If you just want a working quick-start, [expo](https://expo.io/) is a great option.
Putting API calls in Vuex actions gives you very clean components because you then just dispatch those actions from your component. You obviously don't have to do this, it's more a pattern than anything else, IMO.
I would probably avoid using ember or investing time on it right now. I would keep using React and VueJS depending from the situation/app to build :-)
For a moment I was like, Rust the language uses HTML? 
And here I am cursing the lack of full framework support in React, wishing I could be in Emberland again. The modern Ember component layer is very similar to React/Vue, but you get a full application framework to back it up, making complex applications easier to reason about.
Understanding the weird part is mainly theoric, but it is explaining to you how everything works under the hood and at the same point you should learn that :) The other course is more hands on. It depends which you prefer between the two approaches
&gt; "React, but not from FB" i think, its more likely "React, but kind of angularish". I recently discovered, that things i hate about angular (proprietary ng-* attributes, ....) are loved by many people, and they want them. 
React advertises itself as the view layer, but I'm curious what you're missing that isn't fulfilled by the ecosystem? Or is it just that it's not an all-in-one package and you do have to go hunting for (and learn about) multiple different ways of doing things?
I (obviously) disagree. When working with Vue 99% of the time is spent working with components, not configuring Webpack.
The latter, team debates the best way of doing things, does exploration on libraries, etc. We could be more focused on delivering an application that our users want and leave lower level decisions to the open source community. (Which could be the same people, my previous team had Ember Core members on it, and they took our needs to the community)
Yess Try it. You will see.
I was simply making a point and there is a link in the article to Marko's website where you can see a complete component. https://markojs.com/ To make my point even more obvious, [here is a slide from a presentation that compares Marko and Vue](https://imgur.com/KAxvHxk). [Source](https://www.slideshare.net/PatrickSteeleIdem/building-the-ui-a-comparison-of-react-vue-and-marko)
Tell me, what IDE can recognize what an object contains in a pure function in a file, without typing? If you are going to instantiate four different components in a smarter component, you're saying it's easier keeping all the props of each component in your head, instead of TS helping you recognizing every prop and what it should contain? What about when using a function from a vendor lib? Instead of guessing or looking through an entire documentation, you simply get help with all the functions and parameters usable from that lib.
I feel like the fundamental answer to this is some variation of "just pick one", however that works for your particular team. Our React ecosystem hasn't changed much at all in the last 2 years, largely because although there may be some router or data layer or whatnot that is "better", it's not worth overhauling our codebase and training engineers to support it. I believe that mindset of "it's good enough, and doesn't have to be the absolute best thing in the world" is a requirement not only with React but with the JS ecosystem as a whole these days. Otherwise you're going to be throwing out half of your project every 5 weeks!
Perhaps that's why I don't like Vue, as someone that never even came to tolerate Angular.
this is not an ie bug one of your pieces of javascript is trying way too hard
You're saying you're experienced with it, yet you still claim there's no benefit using TS. Have you even noticed type hinting? I mean, sure you can have an opinion preferring vanilla JS, I'm just curious to find out why, cause it seems you've missed all the glorious effects of TS. If you type something wrong, TS will instantly warns you, instead of having to recompile and test the function to notice the error, is this not a positive effect? Changing an argument of a function call somewhere deep inside your code can cause your app to break in places you forgotten about, TS instantly warns you of this as well, not good either? When instantiating components, you get help knowing exactly what props and their respective types are necessary for it to work, instead of going to a separate file to find it out. Either this is a really bad troll, or you haven't realized how much time and energy you can save when using it correctly. That's my opinion.
It was some time ago I coded but one thing I noticed is the split of the array is stored in the variable named "array" and not "splitname". Maybe that?
Right, that is exactly why I prefer Ember. This is the second team I have worked with that has abandoned Backbone in favor of React. While Ember apps I wrote in in 2012 are still on the same code base and most SproutCore apps I worked on before that had a clean migration path to Ember. The older, less sexy frameworks have prove that they can deliver stability without stagnation while newer frameworks and libraries are trying to reinvent established CS patterns. I am all for the rethinking of patterns, but against the yet another framework approach that the larger JS community seems to prefer. Any library that is more than a few years old and uses ESNext conventions automatically gets my vote, doubly so if they work on/with standards bodies to obsolete as much of the library as reasonable. (sorry Underscore fans)
This is it! Thank u, that was mighty simple!
Split name is a string. Split returns an array leaving the original string intact. Inside say hello you want array[0]. Oh and rename it. Using array as a variable name is very confusing. 
This isn’t a fix. The issue is that you don’t understand what your code is doing. The only thing this accomplishes is to have your own code fighting itself. 
The keyword here is SAFE
So it works if you connect to only one of these databases using the same code? What about two of them? It doesn't look like there is a problem with provided code. 
This does not explain why it evaluates to `false` and not to `13` or whatever number `x.length` is.
&gt; Either this is a really bad troll, or you haven't realized how much time and energy you can save when using it correctly. That's my opinion. I invite you to consider another possibilty: i have a lot of experience and am right. &gt; Changing an argument of a function call somewhere deep inside your code can cause your app to break in places you forgotten about, That is called spaghetti code. You dont do it. Try to avoid using include/requite/import as much as possible - each one of those destroys modularity. If you design your code to be as independent as possible, you can communicate between module with messages and/or interfaces. This type of design allows you to not refactor nearly so much as spaghetti, and when you change a module you *know* for a fact you wont be breaking a hundred other things all over the code base. This also allows you to write very good unit tests without constantly maintaining them as you work on unrelated things. If you are saving anything by using TS, then you are producing poor code in the first place. Types are a crutch which only help make poor programming practices easier, but actively gets in the way of good programming practices. Types are like shoes for your hands. Nice when you walk around upside down a lot, but not nearly as nice as walking on your feet. 
Yeah but that's now how we're getting `x`. Image it is a return value of a function.
That's exactly my point here. It shouldn't behave like that.
Cheers for this, I didn’t think this had what I needed but after digging through the docs it turns out it does. Thanks!
Okay, I looked at the article that talks about this to get the context. Well... the example the author points to just extracts the API logic into a separate function. But that function is still called inside the action. I mean, if you access an API endpoint from three different actions it's just common sense and DRY to create a separate function so you don't have to repeat your HTTP request three times. So this is really just an implementation detail, not a completely different solution. And about doing API requests inside components: If your application is very small and adding Vuex would just add too much complexity it's totally fine to do API calls in your components. It's just not a good idea to do that in big applications.
I see, I guess I misunderstood what the javascript developer console was capable of doing. I knew it could fill in input forms and 'click' on submit buttons, but I guess it can't simulate a click on a drop down list if the elements in the list do not have any listeners? There's probably a more complicated way around this I'll probably find it as I'm learning more javascript
No there isn't. It looks like I need to inspect a little harder what's going on from the console and try to simulate that, rather than try to click on an element with no event handler. Thanks for your help
and hidden form elements too!
Just let him do his thing. Devs like him are the reason why we make a lot of money. 
&gt; I would probably avoid using ember or investing time on it right now What are your reasons?
React native/react didn’t promise write once run anywhere. More like learn once write for multiple platforms. 
Hi /u/NameOfCode, For javascript help, please visit /r/LearnJavascript. Thank you!
I had this idea of building a puzzle game that you import as a module and play inside the Node REPL. I hope that you enjoy playing it as much as I enjoyed creating it! 
https://www.reddit.com/r/javascript/comments/8nlxff/clients_always_ask_for_csv_exports_on_everything/?st=JIN9TO4H&amp;sh=eb3d00a2 Does this help?
Yes. Tomato.
Because the Ember's horrible logo :)
I cannot take this sub seriously.
What you say makes sense. Also, apparently creating and managing string constants isn't painful enought to need additional tools. Thanks for sharing your opinion.
React and ember cannot be compared. Ember is a web app framework and react is just an alternate api to the DOM. Ember has controllers and application state management and React does not. Ember could theoretically swap out handlebars for react in a major refactoring. The real question is by react is more popular than mustache/handlebars. But that answer is obvious to anyone who’s used both. 
I compared it with Vue.
It's one of the main reasons for me not to use Vue. I personally think, no idea if I'm right, that people who had the same 'evolution' of client libraries (pre-angular -&gt; angular(ish) -&gt; react(ish)), all dislike the magic (DOM) stuff. 
Depends if it's a [botanist making your pizza](https://www.goodhousekeeping.com/home/gardening/a20705757/are-tomatoes-legally-a-vegetable/)
[https://developer.mozilla.org/en-US/docs/Web/Security/Securing\_your\_site/Turning\_off\_form\_autocompletion](https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion)
[I tried it](https://codepen.io/trondeh80/pen/mKxybg) and you are wrong, it does not happen. You mentioned you had erased localstorage, do you have any logic in your vue app that fills in form values from localstorage?
I think that because Ember is a web application framework, it has a steeper learning curve than React or Vue. Very loosely, it's probably equivalent to learn Ember as to learn React + one of the state management libs + a routing lib.
&gt;Now I'm wondering, what was the array of objects for if I stored the objects in variables in the end? When do you personally use an array with multiple objects. an array of objects is a very common data structure in many programming languages. javascript's power is letting you implicitly create objects like { name: 'Susan Child', age: 21, subject: Nutrition, intro: () =&gt; {} } this quickly documents the shape of the data for anyone reading over this code (the array of objects represents a list of people, more specifically students, with a common function called `intro`). adding it to an array indicates it's a collection of pieces of data of the above shape. collections of data are bread and butter data structures in programming.
Ember is great if you're building large applications and need a well defined structure. React is just for components, to make it anything like Ember you need to start plugging in test libraries, methods of storing and accessing data across components. You can find yourself in a real mess with React if you try to build something too large.
Why do you say this? Ember is a well developed framework that isn't going anywhere. It may not be the best tool for every job, but it definitely has its advantages.
When it comes to plants, I would trust a botanist over the US government any day. Since Obama wanted to make school lunches healthier, and [congress retaliated by defining pizza as a vegetable.](http://www.nbcnews.com/id/45306416/ns/health-diet_and_nutrition/t/pizza-vegetable-congress-says-yes/#.Wyp2pKf-iUk)
Doesn't matter if x has already been defined that way. const values = [true, {length: true}, true, {length: false}] values.index = 0 Object.defineProperty(this, 'x', { get() { return values[values.index++] } }) function someFunction() { return null } x = someFunction() console.log(Boolean(x)) // prints true console.log(Boolean(x.length)) // prints true console.log(x &amp;&amp; x.length) // prints false Besides. It doesn't have to be as complicated as that. function someFunction() { return { _length: false, get length() { return this._length = !this._length } } } x = someFunction() console.log(Boolean(x)) // prints true console.log(Boolean(x.length)) // prints true console.log(x &amp;&amp; x.length) // prints false
I've tried this before with poor results. Only truly cross-platform effective way of dealing with autocomplete was guaranteeing unique form control names (in my experience).
My point is though that this is an issue of planning more than a downside of Thebes libraries. You could update to a new car/tv/phone/whatever every few months but most people eventually come to a nice stable cycle in their lives. The community here is all about “new new new!!!”, but that doesn’t mean you can’t drive your 2004 Toyota Corolla into the ground (e.g. implement react today and just leave the core as is for a decade)
There are a couple of reasons why I think Vue is doing better then Ember. 1. It's much easier to use in side projects while also being able to scale. 2. Ember is incredibly convention over configuration, where I believe Vue walks that line a bit more reasonably. 3. Vue has the hype behind it. Momentum is important. 
My job paid for a extensive course on Ember. . Although, soon as I nearly finished the course, the guy who made the site left to write fantasy novels so support for the course materials were dropped. I kept with Ember for about a day after that, not even. I noticed the React community was way more active and moved on. 
It doesn't do much, at least not the console itself. If you're writing code in there, its pretty much the same code you'd be writing in the page along with a few bells and whistles like `$_` variables and a few helper functions (see more: https://developers.google.com/web/tools/chrome-devtools/console/command-line-reference ).
Every time someone asks why I like Vue over React, I just point to this comment because it sums up my feelings perfectly and eloquently. https://www.reddit.com/r/javascript/comments/8o781t/vuejs_or_react_which_you_would_chose_and_why/e01qn55/
It really is. React Native managed to hit that *sweet* spot of getting very popular with, frankly, hobbyist and/or not very experienced devs when it was still far from production ready. As a result, the ecosystem is - really fragmented due to people having to implement things the framework didn't yet have (and eventually decided not to have) - full of bugs because a lot of the people writing libraries and plugins only have experience with one or even none of the platforms React Native targets, so sometimes you have stuff that works really well on one platform but has weird little issues on others - full of outdated libraries because React Native is not yet stable and has a lot of breaking changes released every year, and library authors have either moved on completely or don't have the time, energy or ability to keep their projects up to date Coupled with the issues with the framework itself, it was way too frustrating for me and I ended up bailing on React Native after a few months. 
Let me start off by saying about a year ago I was all about Ember, very strongly disliked the JSX syntax of React, and only heard about Vue from the occasional blog here and there. Things are... very different now. Let me also say that no single statement is going to fully answer this question, the javascript ecosystem is complicated, large, and changes at a very fast pace. For me *personally*, I stopped using Ember because while the convention over configuration approach got me where I wanted to be relatively quickly and provided a way for other Ember engineers to understand what I had done relatively quickly these pros where not worth the cons. The three biggest cons in my mind where... 1. The learning curve of the framework was too high, onboarding new hires was no fun. 2. Made decisions for what the proper conventions were in area that are still very grey (If getting your backend engineers to follow REST to a T feels like pulling teeth to you, then getting them to follow Ember Datas JSONAPI spec is going to be torture). 3. The "kitchen sink" approach of Ember is the right approach about 50% of the time. But the "use what you need" approach of Vue or React is right about 90% of the time. You also don't necessarily know what you'll need and won't need in realistic web development workflows. Vue, on the other hand, has nice benefits for these weaknesses. 1. Easy to learn. Every junior engineer learns FrontEnd technology with an `index.html`, `style.css`, and `index.js`. The Vue component follows this same approach but taking how people normally learn web development and porting that idea into a Vue component. 2. Has opinions to offer you (such as Vuex, Nuxt.js, etc), but isn't going to force you into any of them. Often times this leads inexperienced developers into bad areas, but you don't gain experience from never making mistakes IMPO. 3. The component artitecture Vue has, which it took from React, starts off small. And becomes larger as it needs too. This is, I've come to realize, a good thing. It makes your app start to feel more like assembling legos (e.g. you take smaller pieces and assemble them gradually) than it does customizing your car (e.g. you started off with set parts of a vehicle, and now start building/altering what is already there to create something different). 
Ember also uses observers and lots of magical event listeners, which can make your code a magical event spaghetti mess - or a event issue.
&gt; Why Ember never got to where Vue is today? React wasn't part of this discussion, probably because your first sentence is correct, though fundamentally irrelevant to the conversation.
I'm sorry but it needs to be said. Vue is simply not a good framework. React already existed and solved the front end problem gracefully. There was no reason to create Vue other than to pad the creators' resumes and cront the front end space with more irrelevant libraries.
imho, react floats by because of it's early adoption by facebook, nothing more.
&gt; I don't see the point in Vue since it doesn't improve on React and IMHO is a couple steps backwards in some ways Amen.
Thanks! This is thorough and well thought out. I don't agree with much of it, but that can lead to a rather length discussion ;) (actually I feel like the first 70% of this is just about how Vue is easier to use out of the box, which I don't feel is a valid argument)
if you want react but not from fb, there's preact and inferno, each of which are ridiculously faster and smaller to boot
Vue is "what angular should have been". Its has most of the same core problems as angular, and is quite verbose in the way it makes you structure things.
I feel that comment is wrong about the build step. No browser natively supports the .vue file. you absolutely need a build step.
Adoption? You mean birth, right?
That's fantastic. It could actually be the think happening here. Thank you man!
i guess, if you believe life begins at conception.
Immature because there isn't much of a selection when it comes to React-Native modules. Usually I'd google the problem, and find one result (and maybe a fork of the same result) and five medium articles telling me how to solve X in React-Native using the same module. Outdated because that one module has one maintainer who hasn't committed to it since they finished/dropped the project they used it in. The ground is moving under your feet as a React-Native developer. Your code breaks if there are any breaking changes in React-Native, Android, or iOS.
Or any other stage at which you'd like to argue. You realize that FB wrote React, right? And used it for ~2 years internally before open sourcing it? And that they're still the primary consumer?
yes
I haven't thoroughly looked into preact et al but I know they're not complete implementations and are missing things like numerous lifecycle hooks &amp; fiber's split rendering. &gt; each of which are ridiculously faster and smaller to boot I really dislike one-sided comparisons like this, it's like comparing a motorcycle to a bicycle and saying "see how much simpler it is??" while ignoring everything else and the fact that each of them has perfectly valid use cases
\&gt; used in big projects like Discourse forum platform can you name any other big project? \&gt; Ember has decent performance. every framework/lib today has a decent performance. You're not going to hit perf issues in 99&amp;#37; of usecases. IMHO ember is dead. I am from a small job market-Czech republic, but last time I saw an Ember job ad was last year. I don't expect to see any in the future. Only a fool would pick it over React-Vue-Angular
I always use [xlsx](https://www.npmjs.com/package/xlsx) for all exports to excel / CSV .. it doesn't have the best documentation and it's kind of a large library but if you running it server side it doesn't matter.
How does React make Angular look archaic?
My reason are simple. Didn't know very before and learnt react and vuejs. I have not need to use ember at all. But of course it just my opinion :-)
If you're going to use it for SharePoint development, get the most powerful PC you can find with reasonable costs. 
Ember's framework provides a really great way of making applications in JavaScript, and unlike libraries like React or Vue, doesn't require the usage of external tools in order to do pretty much everything. Ember-CLI paved the way for the JS tooling that we know and love today, but at one point that was really the best the community had to offer. I also still feel that Ember-Data is the most understandable means of getting data from an API into your client-side application, especially for greenfield applications. The ability to change where your data is coming from depending on the model is very useful, and such a task is quite hard to do in other libraries. All that said, Ember has a really high learning curve. If you want to learn how to do things in the Ember world, you first have to understand how Ember builds on top of the existing features in JavaScript to achieve its goals. Keep in mind that when Ember was originally released, there was no such thing as ES6 classes or any kind of "future" for JavaScript syntax. We were stuck with ES5 and that's all we had. So Ember built its own object model on top of that, called `Ember.Object`, that essentially lays the groundwork for the whole framework. On top of that, it provided a number of useful tools for String manipulation and other stuff, as well as a whole template syntax called Handlebars that you have to learn. It's a tall order for most people who are used to jQuery and regular old functional JS. When React came along, I think the reason it was able to affect so many so quickly was due to how easy it seems to learn the basics. Especially nowadays, you can get going rather quickly with React, and even back when it was first released you could get started without setting up a whole build pipeline to use JSX. The learning curve of React itself mostly consists of how it handles state and the syntax gotchas of JSX. Other than that, React, and the ecosystem that surrounds it, generally follow the way JavaScript does things internally, or uses syntax sugar to present a concept that is translated into "ugly" JS with a build system (which is just a `yarn create` away these days). For those who aren't comfortable with writing their markup in JavaScript, or would like to render some (or most) of their markup with a server-side application, there's Vue. Vue has also skyrocketed in popularity because of its learning curve, or rather the lack thereof. Writing Vue code looks similar to how your classic JS/jQuery developers were doing things in the past, and the separation of markup, styles, and logic feels like you're "doing things right". But other than that, it's really just reimplementing the concepts from React without necessitating the use of JSX or, really, a build system at all. Vue works just fine being loaded by itself, with the rest of the app loaded globally in a `&lt;script&gt;` tag. The evolution of these JS frameworks is impressive, and the Ember team have really been trying to combine their ideas with the ways that Ember works, but I think, because of how long-lived of a framework it is, the Ember community has become somewhat disconnected with the rest of the JS community, which now seems to be moving in a similar direction (this is in stark contrast to when Ember was developed...there were many different strategies being employed, like two-way data binding). Perhaps, with the upcoming discussion on "module unification" and updating the build pipeline to work with NPM out-of-box, we'll see a new future for Ember as it continues to evolve.
&gt; can you name any other big project? LinkedIn
&gt; Vue is the only competing lib that has cloned enough of React's magic to make it still relevant Reactive programming was already a thing before react. Win.js had it, YUI3 had it. Vue.js did not cloned React's magic. It uses already known pattern in a different way and was more inspired by stuff like Angular than react. It brings back the single file component and events from YUI3 and the two way binding of win.js and angular (what you call reactive). Vue.js does not use an immutable state like React for example (one of the main point of React from what I've heard). What vue.js provides is a way to build components and an API around these components. Most of the embedded stuff is only syntactic sugar that can be removed.
**Just so you understand**: _You_ want to be helped. And to be helped you pretend that people should: - go to a site labelled as "deceptive", but ignore the warning - actually sign up for something So you seem to assume that this is somehow reasonable, that not only people would be willing to help you but they would be willing to go through _that_ to do so.
No it does not. I'm saying that your premise of "this should be equal" is incorrect because you're running different code in the first 2 statements. If you ran `Boolean(x) &amp;&amp; Boolean(x.length)` you would get `true`, as you expect. As you have it written, it should evaluate to `3` (verified in Chrome console just now). I don't know of any JS runtime that actually gives you the result you got.
I'm a React dev and what I love about Vue is that it's opinionated and there tends to be one way to do anything. One state management library, one tool to bootstrap projects (vue-cli), etc. The React ecosystem is a bit of a mess with too many options.
Right... I was asking about the subreddit. My question was prompted by the statement that react(no specificity) was garbage.
eheh no really I can’t stand that hipster pet.
Are his novels any good?
Right, the difference between that and redux is thunk puts all the side effect actions into a single dispatch
Asking the important questions
Simply because Ember is antiquated.
Using ember with ember data specifically was one of the worst decisions I ever made. I mean that with all due respect because if used correctly it is an awesome concept! There were so many times when we had to bend our api's to fit what it wanted, and the documentation for this is very opaque in my opinion. It's an amazing idea, but just grabbing json from a server and refreshing it (or using Vuex) has made things easier to reason about. Also the route -&gt; controller hierarchy of ember doesn't work as well as the vue-router -&gt; component style of structuring things. Having single file components has also been massive, not having to hop around to different directories (although if you have a lot of components this is still an issue); Also, it has been a breeze to implement view into pages that are legacy server side apps. Ember did not really address this use case very well, although I believe they have a library now that is easy to embed components (glimmer?). I think if ember could remove some of the abstractions it would be a little easier to regain some popularity. The vue API and entire experience has been really great for the past year.
Here's a list: [https://emberjs.com/ember-users/](https://emberjs.com/ember-users/)
If you're in a small job market you probably wouldn't see jobs for it- you'd need to go to an enterprise level to see more options. 
I've been meaning to give ember a revisit. A few years ago when I was evaluating SPA frameworks - (this was 5-6+ years ago), I did give Ember a try, along with Angular, Knockout, and a few others at the time. While Ember did seem promising at the time, the documentation wasn't quite there - and there was a very opinionated "Ember Way" of doing things. If you were willing/able to fall into the Ember conventions - great, if not - wasn't the best. With Ember, it felt like I'd "code myself into a corner" - and would need to scrap stuff, and restart. In the end, ended up going with AngularJS for the project I was evaluating things for. Does seem like Ember has matured quite a bit since then, and is still a powerful / useful framework. It has more of a niche / cult following - I know a few people that work with it, and really love working with it. They also enjoy the "Ember Conventions" - and has a similar appeal to them that Ruby on Rails has. Having strong opinions / conventions that you need to follow has it's pro's and con's - and I think many devs prefer a slightly less opinionated framework to work with. It isn't to say that one is right or wrong - just different. 
Three years ago another senior developer and I evaluated frameworks for a 2.0 of our enterprise app - Vue didn't exist then but it was between ember, knockout, angular, or maybe backbone and some other tools. I passed on ember for these exact reasons, primarily #1. At that time, the docs weren't great, most didn't match the latest version, and ember was not working the way tutorials explained. After two days neither of us had a working a demo and we were extremely frustrated. The community was a bit toxic too - everyone vocal in the help channels had a "holier-than-thou" attitude. 
I picked Vue over React because I don't like JSX. Vue's component syntax feels much more natural. Beyond that, they are very very similar.
Wish I had the motivation to look into it so I can at least say, “Well he found his thing, I can’t be mad at him for that.” Was pretty deflated from that announcement given I was at 96% completion of the course. 
I'm going to dive into a great example. Let's pretend that we've only gotten into manual/jquery UIs, and we want to dive into Vue or React 15+ right now. Let's look at a counter example in jQuery: &lt;div class="counter" data-initialValue="0"&gt; &lt;button type="button" class="counter-minus"&gt;-&lt;/button&gt; &lt;span class="counter-value"&gt;&lt;/span&gt; &lt;button type="button" class="counter-plus"&gt;+&lt;/button&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; $(".counter").each(function(root) { var value = parseInt($(root).attr('data-initialValue'), 10); $('.counter-minus', root).on('click', function() { value = value - 1; $('.counter-value', root).html(value); }); $('.counter-plus', root).on('click', function() { value = value + 1; $('.counter-value', root).html(value); }); $('.counter-value', root).html(value); }); &lt;/script&gt; Maybe a little prettier than some jQuery widgets (where are those custom events, amirite?), but this isn't that crazy or far off. What does it look like in Vue? &lt;template&gt; &lt;div&gt; &lt;button type="button" @click="value -= 1"&gt;-&lt;/button&gt; &lt;span&gt;{{ value }}&lt;/span&gt; &lt;button type="button" @click="value += 1"&gt;+&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = { props: ['initialValue'], data: function () { return { value: this.initialValue, }; }, }; &lt;/script&gt; This looks simpler than jQuery. Data is scoped, and you can update values and it _just works_. So what does this look like in react? class Counter extends React.Component { constructor(props) { super(props); this.state = { value: this.props.initialValue, }; } onMinus() { this.setState({ value: this.state.value - 1 }); } onPlus() { this.setState({ value: this.state.value + 1 }); } render() { return ( &lt;div&gt; &lt;button type="button" onClick={this.onMinus.bind(this)}&gt;-&lt;/button&gt; &lt;span&gt;{this.state.value}&lt;/span&gt; &lt;button type="button" onClick={this.onPlus.bind(this)}&gt;+&lt;/button&gt; &lt;/div&gt; ); } } // Usage &lt;Counter initialValue={0} /&gt; This looks more complex. My jQuery global variable intuition tells me I should be able to do `this.state.value += 1`, and that will sometimes maybe do the thing I think it should, but it's obviously wrong from the perspective of a React developer. Although functional/reactive programming (frp) has had a come back, it's still a scary thing to a lot of people. Vue might be mostly frp behind the scenes, but it completely hides that from the developer, and behaves a lot more like magic global variables. To circle back to Vue, I don't have to care about whether or not something is frp, how it works, or anything about the behind the scenes implementation. I don't need setState, I don't need a class that `extends React.Component`, I don't need a render function. That said, I don't use Vue, I'm a React guy, but React is for people that want a lot of control of their data, and Vue is for people that just want it to work they way their intuition tells them.
i don't want fiber async rendering, and as soon as you stop trying to keep application state inside your ui widgets, neither will you. a nondeterministic ui is a nightmare to debug. as far as lifecycle hooks, preact has all of them. inferno discards the entire facility called "state," which i think is smart, so it's missing those . &gt; I really dislike one-sided comparisons like this, it's like comparing a motorcycle to a bicycle and saying "see how much simpler it is??" preact does literally everything react does as a drop in replacement inferno chooses to discard one of react's 29 facilities . &gt; while ignoring everything else such as? . &gt; the fact that each of them has perfectly valid use cases er, what? the parent poster said "i want react without facebook," and pointed to vue i said "you know, there's non-facebook things that are much closer to react, and you get a speed and a size benefit in the process" i didn't say anything about the validity of use cases
It works well in financial services. Consider these constraints: \- globally distributed teams all working on the same product \- need to be able to switch teams and jump right into a codebase and know what's going on \- standard way to solve internationalization \- federal/global requirements for accessibility (a11y) \- doesn't matter what the backend is for the data \- teams should be able to develop different parts of the product in isolation \- need stability Ember fits these things really well. \- conventions that mean all teams are doing the same things \- easy to switch teams or help troubleshoot another part of the project because you already know where things will be \- addon ecosystem solves i18n and a lot more \- Ember provides clear methods to write accessible applications \- you can use any backend thanks to serializers and adapters \- teams can develop different parts of the product in isolation because of ember-engines \- backwards compatibility sometimes seems like a con in Ember(to developers), but for business, it's a huge pro. It also helps a lot that I can create a UI addon that any team can use, and these components area already accessible, have the right branding, etc. 
didn't bother to read past "and neither will you". I hate arrogant arguments
yeah you could do `arr.sort()[arr.length - 1]` It's probably one of the slower suggestions here, but if speed isn't an issue I think it's probably the clearest method.
Your vue vs React example is mostly just best practices being common in React. There's no reason you couldn't write: render() { ... onclick={this.setState({value: this.state.value - 1})} which makes the examples almost identical. This is part of the reason I prefer react though -- It encourages better practices. It might be more verbose at times but you *shouldn't be* randomly changing state from anywhere in your component, and there *should be* choke points
I solved it by writing my own Plugin: class MyFilePlugin { apply (compiler) { // first hook gets called when webpack is about to emit the files compiler.hook.emit.tap("MyFilePlugin", (compilation) =&gt; { const assets = compilation.modules // modules that are used as assets have a property 'buildInfo.assets' .filter(({ buildInfo }) =&gt; buildInfo.assets) .reduce((obj, { resource, buildInfo } ) =&gt; { // 'resource' is the original path of the asset // 'buildInfo.assets' is an object with 1 entry, which key is the target path const emitPath = Object.keys(buildInfo.assets)[0]; obj[asset] = resource; return obj; }, {}); this.assets = assets; // prevent webpack to actually emit these assets for (const asset of Object.keys(assets)) { delete compilation.assets[asset]; } }); // 2nd hook to add the extracted assets to the stats compiler.hooks.done.tap("MyFilePlugin", (stats) =&gt; { stats.myAssets = this.assets; }); } } 
Vue does not require .vue files nor does it require a build step. My company spent about six months using Vue before ever having a build step or creating a .vue file. The .vue files are really more of a way to structure components in a consistent way - they're not even particularly more convenient than just doing everything in HTML/JS. 
well, that's unfortunate
Several years ago, my team evaluated the available options for modernizing our company's javascript. At the time, the popular options were Backbone, Ember, and Angular. I'll skip the reviews of Backbone and Angular because they don't apply to this conversation, and just leave you with why we chose _not_ to use Ember. The codebase for Ember was far too large to be used for anything other than a large-scale javascript app. The overhead of that is not just in page speed or compiled file size, but also in the implications that go with _grepping_ a codebase, or even just the size of the diffs generated by upgrading version. If you don't need all that code, it's painful in many ways just to have it. It's also terribly verbose. The amount of code you have to write to get something done is painful. Boilerplate causes fatigue, and makes actual code reviews less thorough because more lines committed means less attention paid to each line. Unit testing wasn't entirely clear at the time either, and a big reason for wanting to evaluate these libraries was to make a cleaner way to get front-end devs to start writing testable code. This hurdle was simply higher with Ember than it was with the other alternatives. And less objectively, most of us really just didn't care much for the syntax.
&gt; With React Native, you don't build a "mobile web app", an "HTML5 app", or a "hybrid app". You build a real mobile app that's indistinguishable from an app built using Objective-C or Java. React Native uses the same fundamental UI building blocks as regular iOS and Android apps. You just put those building blocks together using JavaScript and React That's for the web site saying almost as much as I did, I get that there are a few things you need to do differently for each platform but from my understanding the bulk of the code base is reusable.
Yes, but I'm heavily biased as I was on React core until a few months ago and helped write fiber
Yes. This introduces obvious bias, but I was at FB until a few months ago
I think there's also the important point that if you are using vanilla/jQuery and you want to get into React or Vue, you can do the above Vue code in HTML/JS very easily - you don't need .vue files or a build step. So far as I know (and I'll up-front admit that I know very little about React), attempting to do the same with React would result in a lot less readable code.
I think saying Ember is dead is a bit unfair, I'm a contract developer and I see Ember jobs all the time. I actually think the number of jobs has been increasing steadily over the years. It's not as hot as React and Vue but many companies are using it. I know lot's of people making a living as Ember developers ;) 
I think the comment is talking about using .js files and putting templates for components into the markup inside &lt;script type="template"&gt; tags. There is no syntactic tradeoff in doing so, you still get all the features of vue's DSL. Comparatively, as far as I know, there is no way to write JSX without using a build step, you have to write React.createElement calls and in doing so, lose what I would consider the killer feature of react. In vue, referencing a DOM element in your component definition instead of having a &lt;template&gt; tag in a single-file-component can be super useful - a couple examples that I have personally experienced in the last couple weeks: * prototyping a vue app and not having a good handle on how complex the build process will need to be. Later transferring it to .vue single-file-components is pretty much trivial. * progressively enhancing a page with vue components where the templates are rendered server-side * in legacy build systems where you will not be creating a full-blown single-page-app and don't want to add build complexity
At the time of its original release it had horrible, wildly-inaccurate documentation, so a lot of the devs I worked with at the time wouldn't touch it with a ten foot pole.
Okay. It's unfortunate that you don't want to hear a differing opinion. I really like the product. Have a nice day
Who is this person, I must read these novels.
It's not at all about a differing opinion. I'm more than happy to hear those as I love having my own challenged. It's about an argument built on arrogance. Usually just not worth responding to on reddit.
I suppose you could use vue that way, but its certainly swimming upsteam. Vue's philosophy is very much opposed to served templates, and they intentionally try not to support that well. And any third party bits you want to include will be in .vue files. I dont think its realistic to pretend any modern toolkit can be easily used without a build step. Modern web pages are really just single page apps, and single page apps require a build step to not be terrible. The days of building a web page first with a little optional supporting logic are gone. I honestly preferred when I could disable JS and most of the web would still work. If I were king of the web, thats what I would change: enhance html5 with some declarative REST and eliminate client side scripting entirely. But I think the ship hath sailed. 
The best application I ever built was in Ember. I think one of the reasons I'm so good at SPAs and PWAs is because I started with Ember so I got to learn how to build a very well architected app from the beginning. Ember is the birthplace of some of the best ideas in front-end development today. AngularCLI is a fork of EmberCLI. Create React App tries to give React devs the experience of Ember scaffolding. the list goes on and on. 
I think you'd see a very different Ember if you visited it today.
I'm not that person, but Flutter spent a *lot* of time in alpha at the cost of immediate popularity and it shows. There's good support for a lot of stuff out of the box or via first-party plugins, meaning that although the ecosystem is still very small it has almost everything most apps would need (and since those plugins are maintained by the team, there's a decent guarantee that they'll remain up-to-date with SDK changes). For example, it has solid built-in navigation that's easily extendable if you want to do more complex stuff. Speaking of which, I'm not a fan of Facebook's whole "let the community decide on/come up with solutions and best practices for these basic things!" schtick (call me cynical or ungrateful or whatever, but it looks a lot like a multi-billion dollar company sitting back and getting a lot of work done for free). With Flutter there's usually one clear documented way to do something *and also* a lot of room to do it in other ways, which I feel is more accessible for beginners (less room to shoot yourself in the foot by making poor choices early on) without sacrificing freedom for more advanced devs. The documentation is also top-notch, although good tutorials/guides are still a work in progress. 
With Ember you get both. You upgrade every 6 weeks in the most painless way imaginable and it's just maintenance on your codebase. So, you get the new shiny without rewriting any code.
Modern ember's event handling is the same patterns as popularized in React. Data down, actions up, recompute things that have changed. Observers have been strongly discouraged for a long time.
You get bug fixes and performance improvements, which you also get via React &amp; its ecosystem. The conversation though is about an entirely new pattern, e.g. replacing one router with another, one data layer with another, etc. I haven't followed Ember in quite a while, but that would necessarily be a breaking change.
I get speak is not defined straight away 
Oh, it's a property on the module that you import, not a global function. I.e you should call `pz100.speak()`, assuming that you imported the module with `const pz100 = require('pz-100')`. 
Ah yes of course lol, I actually set pz100 to something wrong then set the correct one to pz101 and forgot lol 
I'm going to try write this in an objective way and put it how I see Ember and the community at large. Ember was never geared to take over anything in the first place. Ember isn't a 'fun' framework. It's a business framework. That's why it was hard be picked up by someone trying to do something fun over the weekend. It's almost a theme now that any frontend framework needs to be 'simple' and 'fun'. Ember is neither. It's hard to learn - but for a reason. Ember is meant to get you to deploy things quickly - once you've learnt it. I picked up Ember in my current work 2 years ago. I had had experience with react and angular 1 for several years before that. I wasted so much time with both of those frameworks trying to do things that I would consider trivial with Ember. Sidenote: one of my favourite questions to ask with a new library/framework is how would they structure communication between two independent components. This question is almost trivial with Ember while /r/angularjs spent days discussing the best way to go about it. But communication btn two components is the most common thing you'll do with any large app. If you can't do it in an easy way - you will have a nightmare working with the framework in production. But I digress. When you start learning Ember, you learn nothing about developing apps/for the web. The first weeks is spent on Ember's Object model. This is unheard off. With React - you learn how to create a component. Same thing with Vue - and probably how to structure data in the components. Ember doesn't even touch components - and when it finally does, it's almost trivial. This doesn't bode well with how the JS community likes to learn. It wants a simple `&lt;HelloWord /&gt;` tutorial which, in my opinion, doesn't translate well when you want to build large apps. TL;DR: React -&gt; had a lot of hype. Vue -&gt; made it easy for a lot of non-FE guys to write simple FE code. Ember -&gt; no hype, hard to learn but meant to deploy things quickly. Pick your poison wisely
&gt; because JSX requires a build step. if you need the ability to drop some script files into a project without a build step then React is not really an option Well, actually: [React with RequireJS: no build step, no Webpack, not even Node.js... monstrosity, blasphemy!](https://redd.it/84fryp) ... However, it's not something I would recommend.
Take a look at PapaParse. 
Yeap. That's just for components tho...
&gt; The community was a bit toxic too - everyone vocal in the help channels had a "holier-than-thou" attitude. Well ember was the preferred SPA framework for Ruby on Rails developers...
Regarding no build step in React: [React with RequireJS: no build step, no Webpack, not even Node.js... monstrosity, blasphemy!](https://redd.it/84fryp)
&gt; it was between ember, knockout, angular, or maybe backbone and some other tools What did you pick? What would you pick today? 
I have no doubt that's true. Over a period of years, a lot of things change. And the pressure from newer players like React and Vue would surely have forced Ember to evolve in order to stay relevant.
You get entirely new patterns and they are backwards compatible. The Glimmer render engine is the best example I know of for this. When Ember first came out it used string interpolation because that was the most performant for IE8. After React came out, people realized fuck IE8 and make things work well. So, they completely rewrote the render engine and copied the idea from React of direct DOM manipulation and only updating nodes which have changed. So, you've got a game changing render engine for the cost of your expected 6 week maintenance. 
The appending part. I know how to synthasize the needed div class, and where I need to put it. Just not how to append it. It's right before the second for loop if you're wondering.
Vue also is just a component system. While the broader ecosystem has grown to do much more and there is 1st party support for things like Vuex and Vue-CLI, this was not the case at the start.
&gt; "React, but not from FB" More like "React, but not a pain in the ass".
Use an online IDE like repl.it to run and live test your code snippet instead of linking a sign up site. Generally, you'd always want an MWE (Minimal Working Example) on which you can experiment.
I decided to try Ember as my first web app framework. I spent a week trying to build a single component the way I wanted it. I was unable to do so. I abandoned Ember.
From what I know from Vue, Ember has these cons: - It's an opinionated framework. The core is big and e.g. it's not like you can easily use Ember Data for another project. - Ergo, it's not that much modular. - You can not use it with grunt, with flux...etc - It has an opinionated plugins system. Which lacks of some features. e.g. routes - You can not do something like require 'package/component' - It uses Broccoli, and just Broccoli. - It uses bower. No npm. - It's hardly based on observables and computed properties...etc Yes, you can follow the "React" system of data down actions up flow...but that's just for components. - It has a learning curve you can't skip because of the it does it all. - Imo - the test system could be better...😅 no bdd and the phantom js system is deprecated - It takes 1s for the browser to compile the bundled Ember app. ...Yes, there are ways to avoid those minuses...but the majority are not official. Imo, Ember is better than AngularJS, but not better than or as dynamic as Vue/React. It's stable tho, and I hope the team changes things. Ember is a big fella. It's a big opinionated framework. I've worked with Ember for the last ~3 years for apps with thousands of views per day.
Yes
I've been thinking about that quite a bit lately. I hope that you (and others) would at least be willing to recognize that things change, people learn and grow, etc. I liken it to judging a video game based on how much the lower levels are instead of how the end game plays. For some games it's night and day difference. Ember has leveled up. :) 
Almost 4 years Ember dev here. I agree with a lot of what people say about the learning curve. But IMO, how the docs are organized is what's causing it not the convention over configuration. The core team has already acknowledged this and there are already plans to refactor it. I'd say that React, Vue, etc. also have high learning curve when you want to go advance. It's just that their docs are super nice which makes the learning curve seem "easy".
Another point for that adoption of Vue is the possibility to gradually migrate your legacy frontend to it. You can migrate while you learn or even using just on is need.
What properties are you animating exactly? You might have to elaborate a bit. For starters you can animate using rem instead of pixels.
Have you checked out [Next.js](https://nextjs.org/learn)? It's a lightweight framework for React.
Great library, works with so many different formats to get to/from csv. 
&gt; It's about an argument built on arrogance. Usually just not worth responding to you'll never know, if you didn't read it. i might have made my case. have a nice day
I have loathed template languages since the days of PHP/smarty and Java/JSP. (Java kind of needs them though because the language is so bad.)
You're completely missing the point
Where is a link to NPM install rates?
Would it help if I prefixed my statement with "Fun fact:"? 
Hype is definitely true, but is also a somewhat abstract observation. If you look closely, you can see that Evan (the creator of Vue) is very community-centric and has background in design really shows in the official website and documentation. I don't know about other people, but for me the website is extremely inviting to check this framework out. Everything seems very easy and low-barrier while at the same time being very powerful. It's just very developer friendly.
We chose angular, but today I guarantee we'd have gone with React. Angular was a huge step up for the company, don't get me wrong, but I feel like there are two gigantic problems that only hindsight lets us truly see: 1. Before long, Angular just seemed DOA. Angular2 was entirely different and was soon in beta. React came along and really stole the show. But with webpack and other bundlers, ES6 and module systems, Angular was just massively out of place and didn't play well out of the box. 2. Two-way binding is amazing for basic forms or simple sites, but when you get into enterprise level stuff the digest cycle quickly became our enemy. Watching data and waiting/triggering digests fast turned into a shit show. One-way data flow requires more effort to know when data changes but it's vastly easier to work with. React's "setState" and child components took what we hoped to get from angular, and did it right. Reflux and new context APIs just make it better. 
Not knowing Ember, I can't jump into a project and figure out how to fix a minor bug or make a minor change. I've tried. I never had a problem doing this before learning Vue or React.
Twitch and Discourse are built in Ember.
Twitch
My experience with Ember/Ember Data was very similar. In isolation, things worked decently well. Trying to bring it together into a cohesive application was an entirely different story. So many things that I knew were dead simple in other frameworks were either extremely painful or impossible. For example, having multiple components on screen that were each driven by a separate API. Granted, this was \~3 years ago; maybe they've improved things since then.
This is exactly right. I've done a TON of AngularJS (Angular 1.x). Looking at Vue makes my eyes bleed. Give me plain JavaScript anytime (which JSX is).
This has been my experience as well. * I wouldn't dream of using Ember for a small, personal project. * I wouldn't want to use anything but Ember for an enterprise-y project. Being opinionated (read: not being able to easily color outside the lines) sucks when you just want to bang out some code, and don't care about generating consensus across teams about best-practices, idiomatic coding standards, etc. However, it's awesome if you need to maximize time implementing features instead of persistent, pedantic bike-shedding and constant FotM lib chasing.
If you’re on a MAC, this feature partially exists with Automator
Hi! EmberSchool creator here. I still answer questions and comments on the course, I just don't make new content or re-record videos.
No, pineapple is *especially* delicious on a pizza!
Because reducing the number of parameters to a function reduces ambiguity. Ideally intro would be defined on a prototype.
Pretty good, but there are some clear weaknesses that I'm working on fixing in future novels.
The "Fun Fun Function" youtube channel. [https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q](https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q)
Generator syntax is great, although it is frustrating that it doesn't quite cover all Monads. I've used it to implement a monadic style of UI composition in my library [imperative](https://github.com/jhp/imperative). The downside is that the syntax can be a little ugly and tricky at times. If you miss a `yield *` then you get unexpected errors. And there's no arrow-notation for generators, even though there is for async.
I'm not sure about your point on best practices, what do you mean? That aside, your inlined setState needs a wrapping function (unless setState works differently from what I understand), and the arrows in classes is es7 so I wanted to stick with es6. Anyway, I agree with you, I prefer choke points and unidirectional data flow, but I'm not everyone.
&gt; Angular2 was entirely different and was soon in beta. Gah what a kick in the butt that is. When I got to sit in on product meetings for a networking company when engineering would come up with "Man we'd like to redo this thing and it would be AWESOME... but it would have to be different." A CEO I grew to really respect always threw down "Nope, I've seen it done before and you'll just kill our sales on first thing and the redone thing, it happens every time." There is a fine line between introducing the next great thing and cannibalizing your own products and ... undermining confidence and introducing your own FUD. 
Are you sure its a string? If you `typeof this.props.events[i].date` does it say "string"?
JSX is NOT plain old javascript. If you ever onboard people into react there will be a learning curve for JSX. Stop repeating this utter nonsense.
I haven't, but those look great. The 'for React' part is way better than our current situation. (Backbone)
&gt; typeof this.props.events[i].date console.log(typeof this.props.events[i].date, typeof todayDate) Outputs "string string" I feel like I'm taking crazy pills. The json it pulls from looks like this: { "id": 100000, "name": "This Bar", "description": "Neighborhood pub features local &amp; craft beers plus meals such as burgers, pizza &amp; club sandwiches.", "date":"2018-06-20", "location": 103, "type": "pubmain" } 
&gt;phasing out Sorted
Although I've come to prefer React, the ability to use any templating language in Vue (e.g. Pug) remains very appealing to me.
[removed]
Maybe there are some similar but different characters being used. Try: var map = [].map; var code = function (str) { return str.charCodeAt(0) } console.log(map.call(this.props.events[i].date, code), map.call(todayDate, code))
Not just loved, there are legitimate business reasons for choosing templates over HTML in code. It's not practical for many businesses to limit those who can edit layout and styling to just their internal programmers.
Ok, an "extension" of JavaScript. What I meant is you have access to all of JS... &gt; It is called JSX, and it is a syntax extension to JavaScript. JSX may remind you of a template language, but it comes with the full power of JavaScript [from the docs](https://reactjs.org/docs/introducing-jsx.html)
As I've grown as a developer, I've become more and more anti "framework" I've just seen it happen time and time again where a framework you buy into eventually decides "hey, we need 2.0" which would cause you to need to rewrite everything you've ever written with that framework. Sure, they have nice lofty goals "Lets make everything fast and easy to setup! Hey, look at how quickly I made a blog!" but those often start to crumble with even the slightest level of customization. You are punished for using anything outside of the framework and even some things inside of the framework with absolutely no warning beforehand. I think Vue and React are the Javascript community coming to the same conclusion I have. Libraries are better than frameworks. As an aside, I think the "next level" build systems (Parcel, JSPM) haven't learned that lesion. They are so focused on making things as zero config as possible that they haven't stopped to consider that some configuration is really OK, especially for a system that you will rarely change after it is setup.
yeah, you're right I need a `() =&gt;` before it &gt; I'm not sure about your point on best practices, what do you mean? Mutating state in a template is bad as it leads to spaghetti code very quickly, not to mention endless refactoring the moment you want to change something.
Ok so you should create a class with the method required and instantiate instances of that class in your array. You just should be copy pasting the same method throughout...
Of course. I don't think OP has gotten that far yet though... One thing at a time.
Preface: I've been working with Ember for almost 7 years. Basically since the beginning. &lt;rant&gt; Ember never recovered from it's "hard to learn" reputation, it's not made to build toy apps and couldn't compete on marketing. Regarding the "hard to learn" bit. I blame this on the core devs. Yehuda is brilliant and probably a genius but also seems to overlook the fact that we're not all at the same level. In the beginning, the ember team completely failed to communicate how simple things should have been done, presumably because it was obvious for them. As a dummy, comparatively, it seemed like the attitude was "Dummies shouldn't use our brilliant framework". News flash. Most of us are dummies. There were no examples or cookbooks/recipes until it was way too late. Regarding the "toy apps" bit: Everyone wants to be productive on day 1. That's easy to do if the framework you choose is extremely simple, doesn't easily scale and you get to choose from infinity ways of doing things. Thus, all the "I built an app in Vue/React in a day!!!" comments. ( Yeah, sure, and how does it look 2 or 3 years later after a team of devs works on it?) Ember is none of those. It's built to have "right ways" to do things and, in my experience, those ways eventually turn out to be correct. Also, Ember's aim is to give you everything you need from day 1. Testing? It's baked in. Production builds? Yep, it's already there. Routing? Of course! etc... Comparing React/Vue with Ember is inherently unfair. You should be comparing Ember with React + Redux + someTestingFramework + allTheOtherShitYouTackOnToMakeItDeployable. It's a complete solution you can use to build Enterprise level apps without a shit-ton of in-house frameworky crap that no one but two guys in your company knows or fully understands. The drawbacks to "You can do "X" in any one of Infinity+ ways that you want" is severely underestimated. Ask yourself this: "Can a new dev come in on day one and fully implement a new page following the conventions currently implemented in your app?" If you're using React/Vue/Angluar, I seriously doubt the answer is "Yes" and even then you're probably fooling yourself. To put the nail in the coffin, Ember lost the marketing war. It didn't have the backing of FB or Google and couldn't compete on mindshare. With all that said, I love working with Ember but it's impossible to hire anyone to work on it. I've given up on defending it and my company is choosing the worst possible path. A complete rewrite in React. This is the dumbest fucking thing we could do, especially considering we don't need a single page app at all and should have used server side rendering tech from the beginning, which would be lighting fast comparatively and our back-end devs would suddenly become full-stack devs, but I digress. I'll play along since they wouldn't need me as a javascript "expert" if we did what I'm proposing. For hiring alone, which is already really fucking difficult in the Bay area, it's the wrong choice. Finding someone excited about working with Ember is like finding a unicorn that shits winning lottery tickets. Trying to train new devs on Ember is an interesting challenge, especially when they can't be bothered to read the fucking guides or search the API. Maybe we just hire shit devs, but I'm considering having "Read the guides" tattooed on my forehead. Why devs expect to just be able to magically understand a codebase after reading a few lines of code, I'll never understand. Understanding the "big picture" is critical to contributing to a large, existing code base. Theoretically Ember makes that a much simpler task with it's convention over configuration attitude but that assumes you have the patience and will to learn the conventions. &lt;/rant&gt; I realize that came off as unnecessarily bitter so I'll just go ahead and pre-apologize as I'm too lazy or busy to edit it. tldr; I love Ember but sometimes love isn't enough.
It sounds like most other people didn't have performance problems, so maybe it was an issue with my code. You could try making a little demo and seeing if runs nicely, maybe? 
It doesn't. Angular made some bad technical choices that had to be remedied in later versions, but the interface was phenomenal and many people in the industry felt that react was a step backward despite the great performance. This is pretty much the reason Vue came along.
&gt; At that time, the docs weren't great, most didn't match the latest version, and ember was not working the way tutorials explained. After two days neither of us had a working a demo and we were extremely frustrated. The documentation is much better now, but if you're looking for something not described there, you're pretty much SOL. The stuff you find on Google/SO is completely outdated, and on the official Slack the support is rather hit or miss (I've had nobody respond to my questions, I've received two different answers that contradicted each other, etc). I've resorted to reading the source to answer the hard questions.
And dropdowns
I would guess its something to do with UTC timezone difference.
Dropdowns == selects... but yeah i getcha.
Didn't read the top comment carefully. Ok, what about date pickers!
Technically date pickers are still an `&lt;input /&gt;` but sure! &gt; button &gt; checkbox &gt; color &gt; date &gt; datetime-local &gt; email &gt; file &gt; hidden &gt; image &gt; month &gt; number &gt; password &gt; radio &gt; range &gt; reset &gt; search &gt; submit &gt; tel &gt; text &gt; time &gt; url &gt; week
You must be fun at parties
I think that's more a problem of the lackluster documentation of ember-data, this stuff was easy to do even five years ago. You can define a separate adapter per model, which each can provide the data from a different API or even method of communication (like WebSocket).
Everything should be in components these days.
Great job on the course dude!! I had a bunch of fun with that, and was very sad to see no new content would be added along with tell-tale signs elsewhere. That email was kind of a wake up sign for me when I was constantly browsing forums/communities for ember content, and saw nothing really being maintained by other ember devs or moving to React/Angular. It’s a shame especially for someone like me who works with Ruby on Rails and the structure kept it similar to a rails tree and I fell in love with that. Felt some heartache after all the sleepless nights of just having that much fun with Ember to see it kinda take a dive all at once (for me in my experience at least). 
As a JavaScript developer it took me much less time to learn JSX than to learn anglurisms. Also want to debug some of that template logic in angular (not sure if Vue does the same, haven't touched it)? react/jsx is literally JavaScript at run time, very close to what you wrote in your editor, just debug it! Template languages, good luck.
That's not the target market for ember at all.
&gt; I've just seen it happen time and time again where a framework you buy into eventually decides "hey, we need 2.0" which would cause you to need to rewrite everything you've ever written with that framework. Ember is already through that phase (and it was a horrible phase). What you see today won't change that much any more.
Both of the strings in the logs end up looking like this, maybe it has something to do with the dashes or something along those lines? "2018-06-20" "2018-6-20"
Angular2+ is, in almost every measurable way, a different framework. Angular 1 is now pretty much in "long term support" and a growing number of projects are dead or dying. Things we chose three years ago are already EOL. There was no way to foresee how quickly the javascript world would be taken over by commonjs/es6 import modules, transpilers, bundlers, typescript, React-like libraries, etc. Angular 1 is from an era where none of those things existed (or could be used the way they are today). 
There are services, models, routes...etc I didn't mean controllers or views 😅 I have quite a lot of services in the app. Things I can't do without them. And I don't confuse observers with computed properties (which are also observers at some point). I use them when it's really necessary. In any case, the docs already say it. Developers tend to over-use observers. And you work with other people and addons 😅
06 vs. 6
Holy shit I can't believe I missed that
&gt;Ember has these cons: &gt; &gt; It's an opinionated framework. That's not a con, that's just a preference. &gt; You can not do something like require 'package/component' What do you mean? I'm using external components (like ember-material-lite) all of the time. &gt; It uses bower. No npm. That changed about two years ago. These days it's only npm, no bower any more (it used to be both side-by-side before that). &gt; It's hardly based on observables and computed properties...etc Yes, you can follow the "React" system of data down actions up flow...but that's just for components. Components should be around 90% of your code. &gt; It takes 1s for the browser to compile the bundled Ember app. Not my experience at all, but then again I'm not running it on a 486 machine.
Look at your strings very closely — they are indeed not the same: both date and month returned by `Date#getUTCDate()` and `Date#getUTCMonth()` are not padded by zeros: const date = new Date(Date.UTC(2018, 0, 1)); // Jan 1st, 2018 date.getUTCDate(); //=&gt; 1 date.getUTCMonth() + 1; //=&gt; 1 For the easiest solution to this, check if you can use [`String#padStart()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart): const date = new Date(Date.UTC(2018, 0, 1)); // Jan 1st, 2018 String(date.getUTCDate()).padStart(2, "0"); //=&gt; "01"
I created a [poll on Twitter](https://twitter.com/stas/status/1009156491981590528) asking the same question because I was intrigued by the actual behavior. The output is: {value: undefined, done: true} It was counter-intuitive to me at first because I assumed breaking out of the loop will keep the iterator in a _pending_ state. After all, it has only produced one value so far, which was assigned to _num_ in the first iteration of the loop, right? It turns out that any abrupt termination of the loop will _close_ the iterator, [as per the MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of#Closing_iterators): &gt; In for...of loops, abrupt iteration termination can be caused by break, continue, throw or return. In these cases, the iterator is closed. 
Look forward to following this series !
Can you provide a minimal working example of a nondeterministic UI in react?
Really? I felt like I saw way more Angular apps paired with Ruby on Rails. Ember was always niche even amongst the Ruby community.
It's what Angular 2 should have been. I think many Vue users are refugees from the Angular ecosystem that saw it had been declared DOA while Angular 2 was going off the deep end.
you can override return if you don't want this behavior let generator = numbers(); generator.return = null;
No doubt. Hard to know what would happen, still hits the user base hard when they're looking at adopting something that is already pending being replaced.
There's is no reason that only programmer's can edit react. You can create very designer friendly components. 
Wow thank you
&gt; As a JavaScript developer it took me much less time to learn JSX than to learn anglurisms. The whole react component system with JSX has so much less surface to learn than vue. 
wow I'm so confused by this code. I'd really appreciate if someone could explain whats happening in detail. Like where does the properties "done" and "value" come from?
&gt;&gt;It's an opinionated framework. &gt; That's not a con, that's just a preference. That's true...altho I think some people will agree that's a bit dangerous some times. It can be like...Meteor...😅 &gt;&gt;You can not do something like require 'package/component' &gt; What do you mean? I'm using external components (like ember-material-lite) all of the time. You have to add the JS assets through app.import('node_modules/moment/moment.js') in ember-cli-build. Or ember install... It's not like the typical import...or require.js. That's what I meant. &gt;&gt;It's hardly based on observables and computed properties...etc Yes, you can follow the "React" system of data down actions up flow...but that's just for components. &gt;Components should be around 90% of your code. Still, you have services, models... &gt;&gt;It uses bower. No npm. &gt;That changed about two years ago. These days it's only npm, no bower any more (it used to be both side-by-side before that). Sorry, I silly-ly missed that... It became also a pain to update the version of Ember. Hot reload is something nice to have too, and not having it gives the feeling that you are slower coding... We eventually decided to write all the new projects with React + "whatever we need". It also has cons, but in general it seems to be faster and easier. In any case, Vue seems to be the correct "Ember" approach, as it has everything, but it's optional and dynamic.
I haven't worked on that project (or for that company) for nearly 3 years, so my interest is mainly academic, and I don't even have the source code to reference... But how? Even with what you're saying, near as I can tell, each Route has one Model. Yes, I know that I can have different models and populate them with different data through adapters. But given that what I'm looking at in an application is a Route, which displays a Controller that is bound to the Model... I want more than one of those on screen, and this is dead simple to do in other frameworks like Angular or React. Each component has its own models, controller, adapter, etc.
I've spent the last couple of weeks rewriting some core services of an app to not rely on Ember data. For all of its benefits, it's just too much trouble and really doesn't handle concurrency well at all
The hamsters are mascots. The logo is basically just text. 
The man himself 
Can we just petition for IE to not exist anymore as a popular browser? 
Its part of the iterator protocol: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols Generators are functions that create iterators. Iterators contain a next function which return objects with done and value properties. If you iterate through an iterator manually calling its next method, you'll see these objects (that's what the console shows in OP's code). But they can also be hidden away if you iterate over the iterator using a for-of loop or spread (`...`). Generators aren't the only way to make iterators. They just need to have next methods that return those objects, but generators are convenient and allow the use of `yield` which has its own benefits. The link above shows a non-generator example with its `makeIterator` function.
&gt; wow I had no idea about iterators. Thanks for explaining, I really appreciate it.
If you use a for in loop, this won’t happen. If you’re using a for of loop, you really shouldn’t assume anything about the implementation. You can look for the browsers implementation of Symbol.iterator property to see what the “for of” loop will do. I wouldn’t have guessed this result but I’m not too surprised either. You can override this with your own implementation of the functions symbol.iterator
It should be more like *What we decided to use to build web-based RSS Reader*...
Well the code works now, ya jerk
This is actually a good feature that means that if you iterate over a collection and exit the loop the iterator is automatically cleaned up. e.g. Consider this file reader: function readFileChunks(filename, chunkSize=1024) { return { * [Symbol.iterator]() { const fd = fs.openSync(filename) try { while (true) { const buffer = new Uint8Array(chunkSize) const bytesRead = fs.readSync(fd, buffer, 0, chunkSize) if (bytesRead === 0) { break } else if (bytesRead &lt; chunkSize) { yield buffer.slice(0, bytesRead) } else { yield buffer } } } finally { // This closes the file leaving the program in a // non-leaky state fs.closeSync(fd) } } } } const chunks = fileReaderChunks('./foo.bin') for (const chunk of chunks) { if (chunk.includes(27)) { break // Also closes the file as we're done iterating } } Notice that in this case I'm returning an iterable (an object with a `[Symbol.iterator]` method) rather than using a generator function directly, this means a new generator will be created each time I loop over it. Using a generator as an iterable itself is actually a bit weird because most iterables (arrays, strings, sets, etc) can be consumed many times. Normally when doing such iteration you don't even get access to the iterator, in the `for (const chunk of chunks)` you never even get access to the generator at all as it's created inside of the `for-of` loop so naturally the `for-of` loop needs to cleanup the iterator it created at the end of iteration (regardless of method of exit).
I've definitely made this exact mistake before if it makes you feel any better. I've always felt the Date documentation is a bit of a shit show
I don’t think it’s necessarily about how Vue is easier to use out of the box, but more about the strength of its cohesive ecosystem, and dispelling some facts about JSX being easy because it’s “just JavaScript”. 
if you want help with code its best to make things easiest for those helping you. using something like jsfiddle or any sort of sandbox where we can actually see the dom elements you are trying to manipulate would help a lot. right now i can't be bothered to figure out exactly whats wrong with your script, and you haven't provided any reason why your current append isn't working. Is there an error in the dev tools? Is the text node not showing up at all? 
Thanks for your kinds words on the course :) There's still work to be found in Ember if you love it, and will be for quite some time, but you're right that there's more momentum behind other frameworks now. The good news is that I've talked to many devs who've switched and they said their Ember experience helped them when architecting their React/Vue app, and that Angular 2 has borrowed many of Ember's best ideas.
&gt;What I meant is you have access to all of JS... Of course. However that is definitely a double edged sword.
Material Components Vue is wrapping up official mdc-web (material design components) for VueJs https://github.com/matsp/material-components-vue
If Ember is not aimed for professional web developers, then who?
It has been my experience that JSX isn't as easy to pick up as most people claim. A lot of my junior engineers introduce performance bugs because they don't understand how JSX and the behind the scenes code interacts, for example this [gotcha](http://johnnyji.me/react/2016/06/27/why-arrow-functions-murder-react-performance.html) Is something I've even had senior engineers struggle with. Templating languages are hard the first time, but after that there isn't much difference.
I see a lot of mentions about Ember's "convention over configuration". What do they proscribe?
I was actually referring to white label software, but I'd also like to point out writing designer friendly components mostly nullifies the benefits of JSX anyway.
&gt; If you use a for in loop, this won’t happen. It's a bit of an apples to oranges comparison. The behavior shown is basically the same behavior as a for-in loop, only with for-in you're entirely subject to the browser implementation without modification. Iterators with for-of are what allow you to control that implementation, as seen with the `numbers` generator in OP's example. What's confusing about this is the behavior resulting from the break. In python, for example, if you break out of an iterator loop, you can continue that iterator from where it left off. def numbers(): yield 1 yield 2 generator = numbers() for num in generator: break print generator.next() #-&gt; 2 In JavaScript, as /u/stasm described in an earlier comment, the iterator is closed when a loop is broken meaning the iterator is completed. This, however, assumes that the iterator implements a `return()` and that it does in fact properly close the iterator. And this is the case for generators. But you could implement your own iterable that doesn't include a return and get the "expected", or non-closing behavior function numbers() { let values = [1, 2]; let iterator = { next () { let done = values.length === 0; return done ? { done } : { value: values.shift(), done }; }, [Symbol.iterator]() { return iterator; } }; return iterator; } let generator = numbers(); for (let num of generator) { break; } // What's the output? console.log(generator.next()); //-&gt; {value: 2, done: false}
What you've described in short seems to me like the difference between a library and a framework. I can agree with this though a lot. Coming from angular to react was very refreshing for me when I got to make the switch.
React Native allows you to have one codebase for both iOS and Android, but not for web. It’s impossible to have one codebase for all 3 platforms. 
You're right just the two, my bad
Do you prefer vue over react?
It's not aimed at single developers playing around with their first web app.
JSX is not at all hard to learn, and is much simpler than learning all the weird ng-tags and other stuff in Angulars templating
Not necessarily... If you look at a connected redux component, they are not very complicated. A number of named props to get data from and a number of other props to call to change things. If you want you can even split the whole thing into two files and separate the connect() call. Or you leave it in because it documents the naming conventions. 
You can implement a model function in your route that returns a promise to whatever data you want. In my project, I usually collect an object of everything needed for that route (various records, the title of the document returned by the server by other means, the id of the document I got from the URL, etc). Returning a model with the same name is only the default fallback when you don't implement the model function.
&gt;You have to add the JS assets through app.import('node_modules/moment/moment.js') in ember-cli-build. Yes, it's one additional line in the build script… &gt; It became also a pain to update the version of Ember. That was until about two years ago. These days it's completely painless to update, since the framework isn't 50% deprecations on every minor update any more. &gt; Hot reload is something nice to have too, and not having it gives the feeling that you are slower coding... I usually embed the whole state in query parameters and the route, so a reload of the page (which happens automatically when something changes on `ember serve`) doesn't lose anything. As an additional bonus, the users can also use this feature for bookmarking or deep linking.
Typo: Should say 'Self signed certificate' in title
Professional web developer but building a first ever web app?? You don’t build stuff in highly conventional framework “your way”, you build it the way that thousands of developers over almost a decade agreed on the best way. If you don’t want to follow conventions, you just pick a tool without conventions and do it whichever way you want.
Thank you
Completely rewritten in React now.
Time and time again? I bet you did Angular before. Sorry, but Ember specifically focuses on this problem. Stability without stagnation. Strict semver. LTS releases. Go back 5 years ago, out of all frameworks, the safest bet you would be is on Ember. How can you say you’re anti “frameworks” because they force you to rewrite stuff (which Ember specifically focuses that you don’t) when there’s a React router breaking changes/fork every 6 months because maintainer didn’t reply to an issue for a week? 
I'm not arguing against that; I'm simply saying that static typing is a concept not used by all languages, and bringing static typing to a dynamically-typed language shows, imo, a lack of understanding of the target language.
I'm pretty sure that's what I ended up doing. My point is, I don't want to put them all into one model. Because that's dumb, and other frameworks don't make me do that. Why should my dashboard widgets, which are completely unrelated to one another, have to get their data from a model that's artificially mashed together? In this architecture, the route/model is the bottleneck because it has to retrieve all of the data into a single location, and then emit that data back out to all of the locations that depend on it, when the only relationship between the different sets of data is that they are used on the same screen. The asynchronous components I mentioned above sound the closest to what I would want, but they weren't available at the time.
If you’re fine with your component being on screen while loading the data (which is a good idea anyways), you can just inject the store into every component and fetch the data directly. The model is just a convenience for collecting the data, not a requirement.
literally the entire purpose of fiber is nondeterminism. every single thing in fiber is an answer to this question. react fiber will change its rendering behavior based on, among other things: 1) whether an element is offscreen, and therefore by example the screen size your test rig is set to 2) whether data is coming in too fast for the render cycle, and therefore by example how the cohoused behavior of other customers on your VE is set up 3) what priority a given component is set to, which is potentially heritable, potentially random, and potentially set to different values according to defaults or tree depth 4) whether data arrives faster than the frame rate, introducing dozens of sources of jitter, from browser duties to network latency 5) whether the work "comes from user interactions," meaning it'll vary based on which selenium driver you're using, which selenium wrapper you're using, whether you're in electron, etc 6) whether react perceives your thing to be about animation *and* whether it's under a garbage collected count threshhold you can neither investigate nor manage 7) current dom tree estimated dead node density, which is about your browser's allocator 8) which dom shim babel has loaded, which is about your compile environment, and changes with things as trivial as ejecting a CRA app 9) how many other things are delayed, meaning mailbox queue backup faults are possible in what react calls the stack frame buffer, which are already a serious problem for react native and a big part of why airbnb bailed 10) fiber is fundamentally a scheduler, and people insist on keeping application state in their ui widgets, meaning that every react scheduler change is a potential data and control flow race condition 11) much of the scheduling is internally done around the concepts of `&lt;Child/&gt;` and `&lt;Sibling/&gt;`, which are also now race conditions 12) These are being offloaded into webworkers, where they change from delays into outright errors 13) `memoizedProps` is already a logical thicket trying to get around update-of-updated problems, and it'll get worse, mark my words. this is currently a huge source of bugs 14) `pendingWorkPriority` is also an example of data race conditions ready to come down the pipe 15) they're already writing a coroutine system to manage contexts, which really should just be passing data down the tree. the performance and complexity impact of this should not be underestimated 16) priority propogation! your great grandparent can render your delay, and you have to know about that to change it. aka strong coupling across modules. good thinking 17) an entire new work location algorithm based around rank order scanning all this so that you don't just use props also, honestly, this should be obvious. i feel like people "ask questions" as a not so subtle fake-polite way to call bullshit, instead of just trying to think about what someone meant
Data retrieval should be handled in a routes and/or services. Your components shouldn't be hitting the store. Thinking about this question more, Ember suffers from having sub-par documentation. It's really not that hard to learn - I picked it up pretty quickly as a very junior Dev (my first JS framework). But it confounds people when common patterns aren't well documented.
Do we really need so many articles on how to pass a component as a prop...
Right that was kinda what I meant by the iterator implementation of generators. But I didn’t know specifically about the returns. Thanks
if that's the desired effect, it'd be better to do normal mapping
Mocking absolutely is a part of TDD, it allows you test integration points without relying on the integration point to be running. The basis of TDD is testing the smallest unit of work possible, refactoring it and retesting. If you had to call out to some service or database over and over you’d lose speed and reliability in your test suite.
I have nothing against render props, I think they have their uses. But I would like to point out that the render prop version of \`Consumer\` is now strongly coupled to \`Producer\` and is much harder to test and reuse. The HoC approach had a consumer which was simply "props in, dom out", which is always nice.
1. Ember was massive, code size-wise. 2. Ember’s templating system was really rigid and inflexible compared to contemporaries like React and Angular. 3. Ember was slower. 4. Ember went the convention-over-configuration route, which seems to not be popular in front end for some reason. 
What else can it do?
Vanilla: document.querySelector('#slider-wrapper').innerHTML += y; jQuery: $('#slider-wrapper').append( y ); 
Yeah, me too. Can then take this info and use it in other programs... like a block chain based game. Thanks to Op.
A better way to put it would perhaps be “JSX is just syntactic sugar over Javascript”, or if you wanna get really technical, “JSX expressions are homomorphic to Javascript expressions”. The fact that _every_ well-formed JSX expression has a corresponding well-formed JS expression means you don’t have to learn two sets of semantics to understand what your code _means_. I think you’re getting JSX mixed up with the semantics of React itself- and sure, that can be difficult to grok for a newbie. But templating languages suffer from the fact that you have to fully understand the template language grammar as well as how its parser turns it into JS objects (or what its interpreter does.)
Chill out dude, I just wanted to see an example to play with to try to get a better understanding of the problem you're describing. It's still not clear to me that there is any real problem here, though. If this is as obvious as you say it is, I would think it would be easy enough to demonstrate.
Thank you
Those graphics are only for temporary, I am working on the better light effect graphics
We had to make almost the same decision 2 years ago and I am so glad I stuck to my gun and went for React even though Angular was clearly winning the vote among some of our colleagues. I will however say that getting the right architecture in React can be a bit challenging at first especially if you're trying to do universal app. But once you have everything setup then it's pretty straight forward from then on. 
https://www.google.com/search?q=node+fetch+ignore+certificate
Yes this would make it easier when you're getting started programming and want to type less. However it makes debugging much much harder, and makes it much more likely that you'll have things silently failing in production. Basically the longer you do programming, the more you appreciate the mantra of "fail early, fail often". Especially on larger projects, and projects you need to maintain for a long time.
Why use a mixture of fetch, axios promise then/catch and also async/await. Wouldn’t you prefer to stick with one methodology throughout? Like just axios and async await for example. 
You can use library if you want. I’ve used json2csv before. But (as linked in the video) it’s not much code to just form the CSV yourself. Kind of fun if you ask me. 
&gt;Ruby on Rails developers Preach! Rails had some of the most obnoxious/pretentious bloggers and advocates I have ever seen. I generally like to think of software development as something more grounded engineering where designs are built around how to most efficiently do a thing. But the Rails community it was all about the artistic value, the "best" rails devs would write code the read like Haikus. Ember was built around that philosophy which is why I avoid any company that uses it since I prefer not to work with those who consider themselves "Artisans" or "Craftsmen". This unrelated video illustrates the kind of person that comes to mind when I hear \[Ember Developer\]([https://www.youtube.com/watch?v=TBb9O-aW4zI](https://www.youtube.com/watch?v=TBb9O-aW4zI))
&gt; have to get their data from a model that's artificially mashed together? This strikes pretty closely to what React does with props... 
Wait while you’re here, where do you stand on this? If you were starting a new project (for work, so scalability is a factor) would you still go with Ember?
&gt; Chill out dude it's reactions like this which make me rarely want to answer people
[https://npm-stat.com/charts.html?package=ember&amp;package=vue](https://npm-stat.com/charts.html?package=ember&amp;package=vue)
Check your clock.
&gt; The community was a bit toxic too - everyone vocal in the help channels had a "holier-than-thou" attitude. Jesus, I thought it was just me. The Ember help slack channel is occasionally helpful but often just obnoxious to the point where I dread having to go there for questions. Plenty of the devs who hang around there are super nice, but other active participants treat you like you're a moron for not understanding the intricacies of a complicated framework as well as they, the people who *literally wrote it* do. There's nothing demoralizing quite like going to a help channel and have an Ember dev lecture you about how elementary your problem is, or chastise you for not finding the answer in the inconsistent, non-SEO'd docs split across multiple domains with buggy search options.
I love D3 just like I love riding a bike. My trouble with D3 is, I forget how to ride it after more than a month away from it.
Not sure how it is today, but it was very Rails-y. If you pluralized a name it made it a collection, etc. Lots of magic. 
I was getting upset until I saw 'satire' in the title.
I think a summary would be: Ember is a hefty, more encompassing framework that is more geared towards enterprise(-y) applications. It has a higher learning curve making it unsuitable for hobbyists and startups who want to move quickly. It also had a bit of a rough start because there weren't established/documented ways to do a lot of things, leaving people confused and frustrated. React introduced a novel way to write apps declaratively, is more minimal and relatively easy to get started with, and has the clout of Facebook behind it. Vue takes a very ergonomic approach that kinda combines the best of both worlds from React and Angular, driving strong interest from hobbyists. The docs are translated to/written in Chinese, making it accessible to and driving strong interest from China. The creator is a Chinese-American (born and raised in China) which also helps through kinship/loyalty/nationalism or whatever you want to call it.
Drop the link fam
I hate that it is so hard to find some specification for closing iterators... That page you linked only enumerates next() as part of an iterator, but there is also the optional return() method, that will be called on closing. In a generator this is replaced by try... finally This is the only article I found that mentions this: http://raganwald.com/2017/07/22/closing-iterables-is-a-leaky-abstraction.html 
I’m learning JS too and wanted to put in another way of doing it in case you’re interested as well. `document.getElementById(‘slider-wrapper’).innerHTML += y;` You can also store the reference to the element in a variable and get at it at any time: `const slider_wrapper = document.getElementById(‘slider_wrapper’); slider_wrapper.innerHTML += y;`
Actually no, didn't work but still thank you.
1. Lots of people saying ember has document is great but i personally found it shitty 2. Two way data binding is a blessing and a curse 3. Too many magical observations and events etc 4. Ember data works only when everyone plays nicely and carefully. 5. Dont have a easy way to use millions of npm packages out there. 6. Somewhat over designed router and controllers. Now they switching to components based solutions with one way data flow. Well, that sounds familiar
I believe, if I’m reading this correctly, you’re looking for what’s called server side rendering; often abbreviated as SSR. I haven’t worked with Angular but I’m sure there’s a billion articles about SSR and Angular. 
Word on the street is that Google crawlers look through JavaScript nowadays. Not sure how well they do it or to what extent.
I heard that. I don't wanna take a risk though.
Believe it or not, not all web developers even use js, save sparingly here and there on an otherwise static page. Everyone starts learning js frameworks somewhere. If you are saying that Ember requires an engineer to have already mastered one or more other frameworks first, yeah, I think I’ve figured out why so few people use it. If they already mastered another, easier framework, why switch? &gt; You don’t build stuff in highly conventional framework “your way” Tell me about it! It is for this reason that I have always preferred configuration over convention. &gt; you build it the way that thousands of developers over almost a decade agreed on the best way When I was learning Ember, it had only been out for 1.5 years. It’s still not even 6 years old yet. Obviously not that many engineers agree it’s the best way, because Ember has this adoption problem. &gt; If you don’t want to follow conventions, you just pick a tool without conventions and do it whichever way you want. I don’t disagree with conventions in principle, through I deprioritize them relative to very small, general parts that can be reasonably rearranged in any logical way. However, at the time I was learning Ember, it seemed that people who already mastered Ruby on Rails and liked those specific conventions were the developers that were catered to. Anyone else was ignored by the documentation and tutorials. I believe the component I was trying to build was a component that could receive text typed in, save it as a list, and allow the list to contain nested lists of itself for replies to replies. That’s what I spent a week trying to do. I was unable to get components of the same type to nest infinitely, so I gave up, and learned Angular 1 in a day. I would go on to learn it well enough to teach a class on it, and then switched to React. Quite happy with it.
How about single developers assigned to pick a new web framework at a company with only three employees, of which there is only one front end engineer?
I don't like the explicit double level syntax myself. Not a unique opinion considering react has chosen to use hackery but the single level approach for their async embedding. Cool embedding for UI though, I plan to experiment with something like that using my transpiler for effects embedding, I think there are many cool things may be done using delimited continuations, e.g., some hole in UI to be filled later, or adaptive programming - re-run only a part of control flow requiring changing etc.
When you don't want to take a risk, why don't you research? This was the first link I found in Google: https://medium.com/@l.mugnaini/spa-and-seo-is-googlebot-able-to-render-a-single-page-application-1f74e706ab11
Make sure your app renders super fast or look in to server side rendering of your application. Now. In order to get Google to crawl various examples you will need links to these examples on your page. Create a sitemap and upload to Google search console.
Did you get overwhelmed by the budget app project? I'm doing that course right now and everything was going well until I hit that project. I'm still getting through it okay, but I feel like it went from 0-100 at that point.. I was more familiar with the concepts in the earlier projects so maybe that's why I feel like a complete beginner again. 
Ember is used in some of Apple's product like the web version of App Store and Apple Music.
Never an ember user but I think it was just a little ahead of its time kind of like backbone and so when angular and react came out they were able to learn from the lessons of backbone/ember. Plus react and angular have serious corporate backing so there is a lot more resources that can be put into rewrites, etc 
Ember: Hard to learn, lots of "Ember-way" things. Too much work to get simple things done, and for the more complex matters it doesn't do better than alternatives (even at its time: Backbone was better IMO). Vue: It's... confused, it looks like Handlebars, JSX, Angular, and web components all at the same time. There is no accepted way of doing it right, every time you say "but in React you can..." they say: "We can, too!" It's a mess, to me anyway. React: I was opposed to JSX at first but I'm in love now. It's not a framework, it's a mere library. You plug &amp; play whatever you need for your project. It can be very simple, or it can be very complex. --- I like the freedom to choose. React, to me, is 95% vanilla JS and 5% boilerplate. Vue is 80% boilerplate. Ember is 50% boilerplate. I'd prefer Ember over Vue for its codebase alone, but unfortunately it seems that Ember is a dying framework. So it makes no business sense to choose it over anything more popular. And popular frameworks also get you more developers. So recruitment is so much easier. That's the problem any older framework faces: If it's no longer considered sexy people will stop adopting it. Ember was at that point 3 years ago.
Because it’s clearly not the future so why would you put time into becoming a better ember dev when other projects are so good 
I figured it out somehow.
Dude. Grammar. 
Oh man :( 
Ember always seemed bloated to me. No doubt it will has it’s page in the history books but the web is a complicated beast now a days and putting time and effort into a declining project when there are so many other promising solutions seems silly to me. Hats off to the team but IMO angular and react are too solid right now 
Haha what, so if you secure the arguments in a pure function, making sure users can only input a number, and making sure the return type is always a boolean, making sure none can do wrong; this is poor code? This is a sign of a poor programmer? So if a new programmer comes into your code, isn't it easier for him to understand how certain parts of the app work, if they're strictly typed? Or you're probably one of those who never does anything wrong, no typos, every piece of code is perfect, nothing you do has fault, and it's been like that for 30 years even though web programming has been revolutionized so many times the last 5 years. You're probably using notepad, because modern IDE's like Visual Code aren't needed when you write perfect code, why have help when you're perfect? Are you even using a framework, or are you building web apps without package managers, without frameworks, without libs what so ever? I'd like to see how a typical ideal app structure of yours look. You're one funny guy.
So because JS was created without types, adding types on compiler-level is wrong? That makes no sense, having types only prevents errors, only makes things easier. I thought the main problem was setup time and when TS gives you problems, I simply can't understand what's wrong with adding type security, more type hinting, more help.
https://www.amazon.com/Mages-Must-Fall-Jeffrey-Biles-ebook/dp/B075JY9QKX
I'd still go with Ember. Scalability actually works in Ember's favor; clear, documented patterns that the community (mostly) agrees on, lots of addons to solve common use cases, and enough performance for all but the most demanding applications (aka, don't build a videogame on top of Ember).
Dude, try opening an index.html not CODEPEN.
I have over 70 years of programming experience and dedicated 40 of those to JavaScript and you are wrong because I’ve done everything on any software level ever possibly imagined. With that out of the way... I think your biggest miss are types as a social construct. You’re part of the less than 1% of the developer community who actively pretends that types are something negative. There’s no big codebase that wouldn’t benefit from being typed if not just for the clarity of sharing information between multiple programmers and those yet to come. Programming is social, unless you only sit on your own?
&gt;Yes, it's one additional line in the build script… True, but that does something different than the rest of the environments. I don't like extra steps 😅 &gt;That was until about two years ago. That could be too...and that's nice to hear. Still, we didn't have that many deprecated things, and we didn't have a good experience with it. &gt;I usually embed the whole state in query parameters and the route, so a reload... Yeah, I was also using local storage to save a big part of the app state (user/app conf) :) Still, it's not the same 😅 Again, I'm talking about big apps that had many functionalities and state changes. Not a simple forms or admin app. I'm sure things could have done different, but that was our experience with it.
Please try opening an index.html in ie11.
It feels _very_ weird to claim that debounce/throttle introduce _non-deterministic behaviour_ and that this causes "race conditions". I mean, sure, you had some trouble and you were using throttle, but I can hardly see that the conclusion is non-deterministic behaviour. I'd rather think that you got a behaviour that you had not thought of in advance. To be more precise, you applied throttling to a situation where it was _ill-fitted_. I mean, you first mention that throttling... &gt; is useful when the frequency of triggering events spikes and the work done for the early events would be thrown away or repeated But then, later explain that you used it to... &gt; buffer events and process them in batches at some given max frequency ...which is slightly but different enough to question the applicability. I mean, you also mention you want _consistency_, so you want all your files to be (eventually) processed. You just need that processing to occur at a rate that is _independent from the rate at which requests arrive_. This, _clearly_, means a queue is the solution. Not throttling _per se_ but an explicit queue. In your final solution you do introduce a queue, and that is in fact what solves your problem. You still keep the _throttling_, which is not wrong but also not strictly necessary. Instead, what you _actually_ need is keeping the processing of the queue independent, separate from the requests. The queue should be managed separately, at its own pace, with its own directives. An independent process.
I really recommend Ember for beginners. It gives you a good knowledge of how to structure the code and it gives you everything you need. It's a good start. Following the main topic, I don't know how easy is to start compared to Vue tho...
 $(function() { var client = ZAFClient.init(); //Initalises ZAF for API client.invoke('resize', { width: '100%', height: '120px' }); client.get('ticket.requester.id').then( function(data) { var user_id = data['ticket.requester.id']; requestUserInfo(client, user_id); } ); }); ^ When the page loads, call some unknown `ZAFClient` thing to obtain the `ticket.requester.id`. This is then used to call `requestUserInfo`... function requestUserInfo(client, id) { var settings = { url: '/api/v2/users/' + id + '.json', type:'GET', dataType: 'json', }; client.request(settings).then( function(data) { showInfo(data); }, function(response) { showError(response); } ); } ^ This, as the name suggests calls an external URL to retrieve the user information (which is at `/api/v2/users/USER_ID_HERE.json`. This can result in success (i.e. info is retrieved) or in some error. If successful, the `showInfo` function will be called: function showInfo(data) { var requester_data = { 'name': data.user.name, }; var source = $("#requester-template").html(); var template = Handlebars.compile(source); var html = template(requester_data); $("#content").html(html); } ^ The mentioned `showInfo` function _shows the info_. It uses a Handlebars template that exists in the page (in an element called `#requester-template` and passes the `name` of the user to the template to fill it. The result is printed into some `#content` element in the page. In case the call above was **not** successful, the below `showError` function is called: function showError() { var error_data = { 'status': 404, 'statusText': 'Not found' }; var source = $("#error-template").html(); var template = Handlebars.compile(source); var html = template(error_data); $("#content").html(html); } It does something very similar (load a template, fill it with data, print it into `#content`) but in this case it does so with an error message (`Not found`). ---- So, I guess the place you might obtain some _different_ data, is the part in `showInfo` where it just reads the `data.user.name` from the JSON file retrieved. To be able to show some different data, you'll need: a. to know the contents of the `/api/v2/users/USER_ID_HERE.json` file b. to modify the `"#requester-template"` (or use a _different_ template) Btw, next time, this type of question is probably more appropriate in /r/LearnJavascript than here.
That's awesome!
Data retrieval is being handled in routers and services. My components are not hitting the store, nops.
How does this project compare to SocketCluster/ (https://github.com/socketcluster/socketcluster/)
For me, there arent any good reasons to use templates in dynamic apps. Templates are good for PDF or documents, i give you that. But what is the point, even from business perspective, to try to develop our template syntax, when whole power of your programming langujage you are using (js) is there? But sure, its about personal preferences. Its not my preference, or preference of my team or business. (We are developing very custom apps, so maybe from that?) JSX is just syntax sugar, i would happy to write React without it (kind of https://github.com/hyperhype/hyperscript)
Sure, React (ecosystem) is more like Lego bricks. It depends on your preference, team and needs.
In our case, the discussion and exploration done marvelous things to team members, so they were much more experienced on the next project. From long-term perspective, backing down from asking important question and just use whatever tool solved them solemow, could hinder you. But again, it depends on people and enviroment.
It depends what variable y is?