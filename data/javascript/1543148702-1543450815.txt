In the talk I am not trying to send the message that we need a new role in our team. I actually stated the opposite. I answered here on the why I felt the need to make a talk on FrontendOps. [https://www.reddit.com/r/javascript/comments/9zytxz/frontendops\_how\_are\_you\_handling\_frontend/eafbnjj](https://www.reddit.com/r/javascript/comments/9zytxz/frontendops_how_are_you_handling_frontend/eafbnjj) It's mainly to address a culture problem I often see in cross functional teams.
That's a bit of an anti-advertisement for TDD, isn't it... "Hey TDD makes writing code so cumbersome, you'll be forced to write only the code you need!"
[https://www.reddit.com/r/javascript/comments/8mlm1c/best\_book\_for\_learning\_js/](https://www.reddit.com/r/javascript/comments/8mlm1c/best_book_for_learning_js/) [https://www.reddit.com/r/javascript/comments/9b01f1/new\_and\_noteworthy\_javascript\_books/](https://www.reddit.com/r/javascript/comments/9b01f1/new_and_noteworthy_javascript_books/) [https://www.reddit.com/r/javascript/comments/9l8bgl/newb\_best\_books\_for\_selfteaching/](https://www.reddit.com/r/javascript/comments/9l8bgl/newb_best_books_for_selfteaching/) there are some links might be useful
The only problem is that there are going to be more than one input because im printing friends from the database
Not positive about Angular as it's been quite a while since I've used it, but React and Vue allow you to create components without going full-on SPA. In fact, Facebook, the creator of React, doesn't use it as a single page app, but instead uses it as various components (or at least that was the case a year or so ago.) So you could still do your typical server-rendered views in your MVC approach, and have components that are React/Vue/Angular. This would allow for items to be updated without a page reload. The same thing has been possible for a long time using normal AJAX calls, but these libraries make those calls easier to manage. 
Ouch. Java patterns for a dynamic language with prototypes? The GoF patterns exist for Java because the language is inflexible and in-extensible. In JavaScript, these patterns aren't needed and they add unnecessary complexity.
So weird seeing OO design patterns being used in JS. It feels like a bit of square peg situation when JS lends itself so nicely to functional programming.
In a nutshell, whenever I think of REST, I think of apps that return json, and whenever I think of MVC, I think of apps that return HTML.
If you server-render your views, won't you be always returning full HTML pages, not just some components?
This article is just another explanation of the TDD process as applied to an idealised programming problem. The inputs are simple and well defined, the output is also simple and well defined. There are no other pieces of complex software involved and everything is well behaved. Unfortunately this is a programming problem we rarely encounter in the real world. Problems almost always have vaguely defined inputs and outputs, and have to interact with other complex systems whose real behaviour is complex and never quite as well defined and documented as we would like. Also, solutions have to fit into an existing system which brings its own nasty constraints. TDD works in the idealised world of Medium articles but not the real one. A pragmatic real world approach is to explore the problem space with code, explore the constraints your solution has to conform to, and get something that kind of works first. Use logging, asserts, manual testing, debuggers, quick and dirty integration tests or unit tests, whatever you have at hand to quickly understand what the problem and solution need to look like. Once you have that understanding can you move on to adding automated tests, and rewriting/refactoring code to improve its quality. 
You'd return HTML that includes scripts and those scripts can contain your components
That's completely wrong. My MVC apps still use REST to return json objects. I think you mean SSR (server-side rendering) instead of REST.
Ohhhh, that sort of starts to make sense.
Nice app. How do you configure the questions in this application?
By looking at your comments, what you actually want to know is why use a Single-Page Application instead of a Server-Side Rendered site. The answer to that is easy: horsepower. Using a server to load every single page is fine when your site is small. But when your site is huge, imagine the millions or billions of requests it has for its REST calls including the rendering of sites. You're adding stress to your server. With SPAs you can leverage the power of a person's computer/browser/internet to build everything for you, so your server doesn't have to do it. It leads to MUCH less stress on your server, and depending on how you code your site, could potentially be much faster. Think of it this way: if you're going to cook a dinner, and you need 10 ingredients, but you don't know what those ingredients are until you already have one, would you rather go to the store 10 times? Or would you rather just grab it from your pantry? 
Thanks. There's no configuring questions here. It's for tracking your progress while solving questions from a book or set of questions where you might have to put some extra efforts for diligently solving and calculating marks at the same time (maybe write question numbers on a sheet of paper and writing answers you mark against them then matching with answer key to see how many you got right) 
[removed]
Everyone always forgets it. You’re good. 
WOW, THANK YOU. OK, so basically I only want the Mouse Enter event to trigger ONCE. Not ten times just because I have ten children inside. So that would mean to use ..... pointerover pointerout or pointerenter pointerleave 
Angular is perfect for MVC designs. You can also consume REST services. It just makes life easier?
Alright, I managed to understand that you can make a REST API inside your MVC APP, and therefore return HTML that contains components. But is this practice a good thing? Shouldn't these architectures not be mixed? 
No clue. This is just the idea that came to be about how to build it. I haven't looked at other implementations.
Yeah certainly when demanding things come up that makes sense. Mine was pretty much a 20 hour straight shot highway drive across the plains so I almost could just put cruise control on and drive a straight line for an hour. 
So you would never use a Facade in JavaScript? What would you use instead?
If you just want to download the video as mp4 you can use [https://www.onlinevideoconverter.com/youtube-converter](https://www.onlinevideoconverter.com/youtube-converter)
too real, man.
No. They don't require any API. You could have local todo app that doesn't communicate with server at all. 
First advantage of this approach is that you can write a post about it. 
I have [replicated](https://jsperf.com/clone-vs-mutate/1) an example where we received misformatted GeoJSON from the server and had to manually convert the coordinates to numbers. In the clone case, we have regular GC pauses of around 15-25ms, while the second runs in static memory. Here's [another one](https://jsperf.com/victor-2), using a vector math library, Victor.js. While 1ms of GC does not seem like a lot, it only leaves you 15 ms if you're aiming for a 60FPS animation. For a more dramatic result, try this in Firefox. I'll be the first to admit that my perspective spans from working with front-end number crunching and visualization, which are very specialized use cases. However, I don't see a reason to rely on obscure runtime tricks when you can achieve the same result explicitly without compromising anything. Also remember that not all browsers use V8 — there are, for example, plenty of mobile Safaris stuck several years behind.
If you're serious about learning Javascript you should check out [https://wakata.io](https://wakata.io) (disclaimer: I made it)
So REST is a type of architecture to interact with API's, never anything graphical. Basically when you use put, get or whatever that is a REST API you are buildling/using. MVC stands for Model, View and Controller in a web application. Model - The way the information is stored. This is almost exclusively the schema for your database/storage location. It shows what a single row in your database contains (there can be multiple models for a single application). View - What the user will end up seeing/interacting with. The view is simply the text, buttons and all that shit that shows up on the webpage. This can be generated through HTML files, through javascript/jquery or summoned by Chutulu but whichever way it is written, if it shows the user something it is a view. Controller - All the logic of the code that passes information around and/or transforms it. I could be wrong about this one but I believe this usually refers to backend logic that interacts with the database but Web Dev is a pretty loosey goosey kinda world so you don't need exact definitions :P Hope this helps, you nerd! 
Looks great! I think I ran into [a small bug though](https://i.imgur.com/BkejcSe.jpg)
Way to draw some serious conclusions from only a couple sentences. Your insults and insinuations are not welcome behavior. And no, I'm not a bootcamp kid. I'm coming from the perspective of: "If you are to learn a language, you should learn its idioms, not bring the idioms of your most favorite language to it." So with that said, let's maybe respond to a few of your quips: &gt;&gt; because the language is inflexible and in-extensible. &gt; Is this something you learned at a bootcamp or something? Literally what are you talking about? Java objects are *closed*. Thus, inflexible. You need patterns to work around this fact. JavaScript objects are just property maps. You can directly add and remove functions as you please from both the prototype and the "instance". You can even have methods replace themselves at runtime with great ease: const SchrodingersCat = { get status() { delete this.status; this.status = Math.random() &gt;= 0.5 ? 'Alive' : 'Dead'; return this.status; } }; My point being is that JavaScript's object system is clearly more flexible than Java's. And while there may be ways to possibly do some Reflection voodoo to implement this or similar behavior, it is far from idiomatic, hence the reliance on design patterns and code generation tooling. &gt; Addy Osmani senior google software engineer disagrees Mr. Osmani is not the programming police. He's not an authority figure over me. I don't know what your literal Appeal to Authority is supposed add here, but it's quite well understood that Google is a Java shop, so their bias shows in most of their work, especially in their attempt to replace JavaScript with the Java-fied Dart. And I see where you're coming from. You see my off-the-cuff, few-sentence, response-and-dismissal, and assume I'm ignorant, but I don't usually take the time to even bother commenting on Reddit when rude people will just *attack*. Your post is a great example of the toxic behavior of bros in tech, and why many newbies fear even asking questions online or seeking help. Please learn to discuss and debate concepts and ideas without attacking individuals. It would suit you to learn to socialize appropriately.
Not to mention the problems that you are solving typically are based on requirements given to you by some non-technical person, which then change about 100 times while you are developing/testing your current solution . Your answer is spot on
With a REST API you can argue the V of MVC is the Json output. So many APIs just still use the MVC paradigm (e.g. Rails and Django when used as API servers) but render Json instead of HTML. 
If I understand that right, it’s applied to bytes uploaded and downloaded to server. But request could be simple, light, that takes a little time. Then server executes something and it’s the longest part of progress. I mean exactly that progress thing, that able to be computed and displayed using previous time parameters of request.
&gt; This comment right here is why software engineers implicitly lack respect for js devs. Insinuate I'm a bad representation of a "js dev". &gt; Gang of four patterns do not exist for Java, though they may have been taught to you that way in cs102. Insinuate I'm a fresh college student that doesn't know better. &gt; Is this something you learned at a bootcamp or something? Insinuate I am poorly educated and working from limited experience or education. (Reality: bootcamps are a *summary*, so this isn't an insult to bootcampers.) &gt; But just know that when you say the things you just said out loud to people who take their craft seriously Once again, insinuate I'm a bad representation of a programmer, and that I am an insult to the craft. Or did you think I wouldn't spot these underhanded comments? 
They don't require one, but you can have one.
disable it and enable it when text field is filled in. 
You could bind the [change](https://developer.mozilla.org/en-US/docs/Web/Events/change) event on your input, check whether it is empty or not and disable/enable the button based on that
The v in mvc doesn't have to be html. It can be a single page app using react/vue and it receives the model serialized to json. I remember for a while react was called the v in mvc. These technologies exist to make better views. Also you might want to look into the benefits of these technologies like not having to refresh the whole page on every change.
How likely are the triggers to execute? Also what type of phone are you guys planning to support. This is going to be an expensive operation regardless. 
Pseudocode: if (el.value == ‘’ ) el.addAttribute(‘disabled’)
Something like this... function isempty { return state.input.length ? false : true // handles undefined || 0 || null } return ( &lt;div&gt; &lt;input value={state.input} onChange={handleInput...} ... /&gt; &lt;button disabled={isempty()}.../&gt; &lt;/div&gt; )
Use an onChange event listener on the input value, check for empty value and use that to toggle your button. 
[Here you go](http://jsfiddle.net/v4kx18a7/)
Thank you a lot!
This. 100 x this. I’m a fan of writing some loose BDD acceptance tests for larger features, but TDD units always need to be rewritten multiple times in frontend land. 
&gt;You seem to be a very angry individual. 😂😂 oh please, now you're really floundering. &gt;Insinuating I'm a bad representation of a "js dev". &gt;Insinuating I'm a fresh college student that doesn't know better. &gt;insinuat[ing] I'm a bad representation of a programmer, and that I am an insult to the craft, and not someone who takes my craft seriously. &gt;Or did you think I wouldn't spot these underhanded comments? In response to: &gt;The GoF patterns exist for Java because the language is inflexible and in-extensible. I dont need to insinuate anything This idea is indicative of inexperience, however much you'd like to unpack and revise it. I'm truly sorry if you don't like that.
Nice read! I always pray that iterables will someday be used everywhere in js... We need a proper standard lib with iterable functions like map, filter etc. That way, we don't have to reimplement these methods for different collection types. 
I understand. I was talking generally about the GoF patterns, but Facade is useful because it's just a general abstraction layer which can allow you to decouple the underlying classes from other implementations. (As any intermediary can.) The thing about GoF patterns is they ultimately address a shortcoming of a strictly static system that enforces noun-oriented programming. My complaint is with bringing that unnecessary baggage to the world of JavaScript, which is free to implement things with mostly Functional patterns. It's never bad to learn more concepts, though!
&gt;This comment right here is why software engineers implicitly lack respect for js devs. Stuff that arrogant drivel where it came from.
true, isolation of concerns is the real benefit there and i'm sure there are other approaches that fit the bill. tbh everything else you said kind of went over my head so that's all i've got :)
This is why I lean more toward "test accompanied development" than TDD per se
All I'm saying is, Java is strictly statically typed, so it enforces interaction between objects via type hierarchies and interfaces. It's also a language that prevents you from modifying existing classes or objects outside of their defined interfaces. So a lot of these design patterns arose to overcome these limitations, while still being idiomatically written Java. The reality is, a lot of these patterns, while useful to know, are not relevant if you approach programming with idiomatic JavaScript, which heavily leans towards Functional Programming style, due to its roots in the Scheme programming language, and now solidified by the popularity of React and Redux. In practical terms this means if you have a class, and you want to decorate it with methods, you don't need to use the [Decorator][D] pattern... just directly take `theObject` and just `theObject.newMethod = function() { ... }` to inject the function you want to add! Boom, an entire pattern: *negated*. Unnecessary. Along with that, being able to leverage JavaScript's [prototypal inheritance][PI], you can avoid Java's [fragile base class problem][FBC]. So to reiterate: Yeah, it's useful to learn Java design patterns so you're aware of them, but JavaScript is not bound by the same limitations as Java. (On the other hand, one will argue it has different problems, in that it's dynamically typed, and therefor harder to avoid compile-time errors. These are trade-offs.) [D]: https://en.wikipedia.org/wiki/Decorator_pattern [PI]: https://en.wikipedia.org/wiki/Prototype-based_programming [FBC]: https://en.wikipedia.org/wiki/Fragile_base_class
``` people.prototype.isOlderThan = function (age) { return this.age &gt; age } bob.isOlderThan(10) ``` Note that I assign to the prototype. You declared a function. That function wasn't registered with bob. You could also do this, but it would now only apply to bob. (and not other people) ``` bob. isOlderThan = function (age) { return this. age &gt; age } ```
I have developed a notation for specifying state machines and how to implement them I call Frame Machine Notation. Frame can help define how to create state machines in any OO language, not just JavaScript. Here's an article on how to do it: [https://medium.com/me/stats/post/9c5b02ba270c](https://medium.com/me/stats/post/9c5b02ba270c). Here's a codepen showing working code: [https://codepen.io/frame-lang/pen/xQRBPN?editors=1111](https://codepen.io/frame-lang/pen/xQRBPN?editors=1111)
To continue, realize that this is on a mobile device, so optimizing is really necessary in order to provide usable application. Here are some suggestions to ponder about. - Is 200hz really necessary? Do you really need that fast sample rate? - Consider applying every-n sampling plus interpolation. For example sample every 5 event acceleration points and have the backend accept that and interpolate if needed. - Whats the estimated highest acceleration your device can realistically operate at? If you can find a reasonable clamp value(based on whatever units you're operating on), you can use a clam-and-counting mechanism. Say the highest acceleration speed a user can reach is 100 m/s^2, that means you can just create a array of size 100 where index 0 is acceleration value 0 m/s2, index 100 is acceleration value 100 m/s2, and whenever you receive a acceleration, you can clamp it to a value between 0-100, then just increase the array count for that index, `array[clampedAcceleration]++;` - Consider using using (javascript typed arrays)[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays?redirectlocale=en-US&amp;redirectslug=JavaScript%2FTyped_arrays] to store data. - Consider ditching the object and using arrays to store data the xyz data. So instead of ````javascript dataPoint = { x: 0, y: 0, z: 0} ```` use ````javascript dataPoint = [0,0,0] ```` Where index 0 is x, index 1 in y, index 2 is z. Thats less data to store and transmit. - You can also send the typed array as binary data using webworkers for efficient transfer without locking the screen. See (this article)[https://medium.com/samsung-internet-dev/being-fast-and-light-using-binary-data-to-optimise-libraries-on-the-client-and-the-server-5709f06ef105] that popped up as tutorial
Because JS... always install a full stack framework to solve a simple problem :-)
damn, i was afraid you were gonna go and explan it. but actually that didn't hurt my brain too much. thanks!
You don’t have to refresh the whole page using MVC and passing html back.
TDD works best for logic heavy parts of your application. For example, I was writing a UI with 1. a grid of 'items', 2. a way to create folders on the grid and put items in them, 3. tabs to switch between grids. Then, the user had to be able to 1. create folders 2. move items in and out of folders 3. move items and folders to different locations on the grid 4. move items and folders to different tabs. Once the data model was defined the actual logic for manipulating the data was isolated to its own module and would've been prime for TDD because it was at that point, as you described, an idealized programming problem: the inputs and outputs are well-defined (albeit not simple).
Just wanted to chime in here as an objective third party, you both sound like smug tech-douches that are becoming way too common in our industry. I suggest you both learn how to communicate with people in an effective manner. As it stands you would both be liabilities to team cohesion and healthy work environment in any tech company.
MVC is just an architechture, so you can do whatever you want with it, but using technologies like react/vue let's you offload the logic of only updating the parts that actually changed to a library. Also building views with those technologies allows much more dynamic views than receiving a newly rendered html all the time.
[W3schools](https://www.w3schools.com/js/default.asp) is a go for a beginner and [Mozilla developer](https://developer.mozilla.org/en-US/docs/Learn/JavaScript) is a very well explained site to help you out if you have any misunderstanding. Keep on coding and if you want to try something new every week, try [codepen challenges](https://codepen.io/challenges/)
Try out https://www.codecademy.com. They are pretty good at gamifying lessons for beginners so it’s not too dry. 
Maybe check out freecodecamp.org, a great open source platform with a very helpful community.
I don't understand the advantage of using a generator function over simply firing an async server request which then appends the new data to the DOM. Basically my question is, what does a generator function do better then a standard function? 
Just saying it's a little redundant to say it's asynchronous, "promise based" is enough (and even then that's pretty much expected these days).
Okay xD, shall change that
Highly recommend [https://warriorjs.com/](https://warriorjs.com/) \- it'll teach you lots of important JS concepts without trying explain abstract concepts to you. And it's fun!
I would suggest going through [https://javascript.info](https://javascript.info/) to get familiar with the language syntax, afterward, you can practice how the syntax is used to solve problems with this website [https://edabit.com](https://edabit.com) As u/bruggekiller said, [Mozilla developer](https://developer.mozilla.org/en-US/docs/Learn/JavaScript) is useful, take it as your bible. Also, you can pick one of these books: [Eloquent JavaScript](https://eloquentjavascript.net/) (free book) and [JavaScript: The Definitive Guide](http://shop.oreilly.com/product/9780596805531.do) &amp;#x200B; Good luck!
https://watchandcode.com/p/practical-javascript is a really good and relatively short video tutorial on JavaScript. This would be a good good resource to start with. I'm gonna go against the grain and say I'm not really a fan of how freecodecamp and codecademy go about teaching JavaScript, but outside of the actual learning track Free Code Camp has a ton of videos and articles that are pretty useful. I'm more of a fan of https://www.theodinproject.com as a learning track because they cover tooling and use multiple resources to get you used to having to look up documentation. You could also check out video tutorials on YouTube, I really like The Net Ninja and Traversy media. There are a bunch of video courses on Udemy for learning JavaScript, IMHO the best ones are from Andrew Mead and Brad Traversy. 
It makes sense in a component-based architecture because React/Vue/Angular have everything to do with what happens 'after' data is passed from the API to the client that consumes the data. For this to work, you need a controller that controls the data and therefore, controls the state. Imagine it this way, there are 3 layers: 1) Application logic layer 2) Business logic layer 3) Presentation logic layer These 3 layers fit together to handle everything you need. The application logic is React/Vue/Angular and it's job is to give you everything you need (like structure to work with) but also to stay out of your way. The business logic is your proprietary logic, like what happens if a user presses a button. This layer should be unique to each app and unrestrictive towards your business needs. The final presentation logic layer is basically just the HTML/CSS and JavaScript components that are concerned with only how things look on the page. The power comes in due to the modularity. You can leave your application logic and business logic 100% untouched and simply swap out some markup to achieve a totally different look. This is incredibly powerful in scaled up apps. MVC is the right way to look at it, but I don't think it's what's important. making components that are stateless and deterministic are what is important. They should work in accordance to what data you supply them. React/Vue/Angular are powerful because they allow you to decouple things in the most powerful way. You could easily swap out your database and API for a different one as times change, but as long as the correct data is still supplied in the same data structures, your app still works the same. Imagine a component that renders a tag with the label you give it, like: &lt;ArticleTag label="Books" /&gt; That thing is immune to problems as long as you stil have a way to call it and you supply a label. You can unit test the component and you can add a11y support over time, making it more and more valuable, but it always remains fully composable because data always flows 1-way through it (it is immutable and deterministic). As you learn more, you will come to understand how composability is among the most important aspects. If you components have strange mixes of pushing and pulling data, relying on implicit dependencies, you will have a really hard time avoiding bugs as surrounding parts of your API or app change. When things move unidirectionally, you can read them start to finish like a book. React in particular is about composing components to achieve declarative markup that describes what a component is doing. You aren't bogged down by stuff like CSS and mountains of HTML that is brutal to untangle. You will see stuff instead like: {this.state.articleTags.map(tag =&gt; &lt;ArticleTag label={tag.label} /&gt;} or &lt;article-tag v-for="tag in articleTags"&gt;{{ tag.label }}&lt;/article-tag&gt; You shouldn't have to care how article-tag works. You should be able to just use it and know it works as long as you supply a label. React and Vue allow you to make components that compose together and your app remains easy to reason about. This is why they are eating the world.
&gt; The world of web development is pretty massive. There's tons of different tools, and resources out there, and they are CONSTANTLY being updated. This is true, but learning the basics of JS is a good start nonetheless. I think all the details about learning arrow functions and editors and deploying code is only going to be confusing for someone new to the language. I'd suggest OP to just start with codecademy to be honest.
freecodecamp and udemy are my favorites. W3schools is good if you want to look up specific things on the fly. Mozilla MDN is basically a more in-depth version of W3schools and more respected.
Thanks!
Probably a case of "because it's cool" or "I just found out about/learnt how to use them so must use them for everything."
Or the non-technical person asks you to implement Feature A, you implement Feature A, post-release you then get a bug report _fully and accurately describing the behaviour of Feature A_.
Building a SPA over a server-side rendered site to lower server resources is a silly idea. Poster above is giving bad advice. No one does that. It's very easy in any capable web framework to cache rendered output. You don't go building a SPA instead. Nonsense. You build a SPA when it suits the type of functionality you need. It's also quite common to use a framework like Vue, React, or even Angular to build more complex components that are used within what is primarily a server-side rendered, often MVC, site. There may be other lighter-weight frameworks where the aforementioned 3 might be overkill, but for practical reasons we might choose a framework our team already knows well rather than some one-off, or one that we can trust to continue being relevant for many years.
Well done man! 
There is some stuff at the end of this article that really pisses me off. &gt; Many say Test-Driven Development doesn't work. It's too slow, and there's no value in doing it. Those words usually come from people who are either writing code for an "obvious" domain or don't know they're writing more code than what they need. &gt; Jack didn't merely choose anybody to solve his problem. &gt; He chose a professional programmer. yep, it's this bit of arrogant bullshit which the TDD community likes indulge it. The idea that professional programmers use TDD and thus any programmer who doesn't is therefore not being professional. I've tried working with a group of relatively junior devs who had this attitude. It turned them into TDD fanatics who fought against anything which didn't conform to their TDD world view and prevented them from learning anything from their more experienced colleagues. It did damage to their careers IMHO. 
Great you made it open source. If i get time this week, ill try to check out your code.
I have... I don't know how to make it work with my page/code... Looking for some external help... 
Here is an example of it working with your codepen: [https://codepen.io/anon/pen/wQXdQZ?editors=0010](https://codepen.io/anon/pen/wQXdQZ?editors=0010)
Thank you
Thank you
Great intro IMO https://youtu.be/Bv_5Zv5c-Ts
had an idea of doing this decades ago, so it's nice some one did it, not so looking at the paths people wrote in... well, maybe there is a way to improve it
Yes most people are right, focus on better and after a while, a really long while, your mind will have a great bank of already solved problems you can go into. You will then be able to create good code faster because you won't spent all that time thinking. I personnaly found that learning an architecture and sticking a bit to it makes it go fast and also easier to go back to previous project. I believe that is why Redux is so popular. Its a way. Once you learn that way you just reproduce that way for feature or entire new apps. Go back to a feature and you know how its done. I personally use mobx but its mostly the same. Now my apps look alike and i can do them fast. If only i wasn't a CSS retard now :P
I agree. Most of our tests on app codes are not “designed” with the codes, but added and updated many months or years into production. Beside tests for library modules and apps also have very different mindsets. In library tests we showcase our own functional correctness like the article mentioned (or like many open source projects) but in app codes we spend many times just to validate inputs or even vendor libraries.
Reading these comments brings a tear to my eye. . . we've come so far! I feel so proud! Soon we can break free of terrible ideas! 
Thanks :)
Just to add onto the awesome list already given, [A smarter way to learn JavaScript ](https://www.amazon.com/Smarter-Way-Learn-JavaScript-technology-ebook/dp/B00H1W9I6C) is also great 👍🏾 
I'm mainly a Rails devs, but I'm thinking about transitioning fully into a React.js because it seems to be way more relevant these days.
The thing about TDD is that it can be done in any code base, but you can only test the code you write, and it becomes tougher to test for the unknowns. You can't be expected to begin testing the entire application. If the app doesn't have enough tests to have as close to 80% of logical and functional code coverage tests then the thought of applying TDD as a directional step becomes more complex. If the app is extendable, then it can be possible to rewrite enough of the code as smaller modules to implement TDD more gracefully. And of course other factors come into play, especially concerning deadlines. Rewriting code is never on the top of anyone's priority list.
I recently handed this by storing the value of the Y offset in a variable on scroll event and comparing the new value on the event to the stored one, thus knowing if you're going down or up. After that you can set up a ternary operator and toggle some clases to make elements appear and dissappear.
I went into this thinking that you'd explain the `ytdl` lib, where all of the work is actually done
Thanks for open-sourcing! &gt; and adding some basic documentation Just glancing it over, that's some pretty phenomenal documentation -- nice work!
Hi /u/multigrainnut, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
sure function createCircularArray(len = 60) { const handler= { get: (obj, key) =&gt; obj[key % len], set: (obj, key, val) =&gt; { obj[key % len] = val return true } } const orig = new Array(60).fill(0).map((_, i) =&gt; i) return new Proxy(orig, handler) } &amp;#x200B;
[intersection observer](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver) can be useful for this. At times it’s overkill but it works well and is supported outside of IE11.
Very cool!
You could probably achieve this with an event listener and oneventchange
The title should more accurately be: "How I imported the YouTube Downloader into my webpage"
You don't know the code until you do steps 2 and 3, you believe you know after you did due to a bias called the [Curse Of Knowledge](https://en.wikipedia.org/wiki/Curse_of_knowledge). Let me elaborate. If you already know the best solution for a problem, then the second option works fine. However, in the real world, you rarely know the solution to every problem upfront unless you have learned the solution written by somebody else in a paper or whatever. TDD is a discipline that helps you to exercise the understanding of a problem without the need for you to know the solution. Smart is not the one who knows everything, but the one you can know the tools to figure it out.
Amen. 
Go with codecademy or freecodecamp, they aren't too boring like other websites and lend more towards beginners :)
\&gt; \[...\] prevented them from learning anything from their more experienced colleagues If that did happen then they probably didn't do TDD, just used the name. There's nothing in TDD that prevents a Junior developer from learning from their more experienced colleagues, unless their more "experienced" colleagues are juniors with the title of seniors. That's more common than you think.
Made a Spin Art painting device that's controlled remotely via JS [https://www.youtube.com/watch?v=Db\_RZD6KlB4](https://www.youtube.com/watch?v=Db_RZD6KlB4)
&gt;Unfortunately this is a programming problem we rarely encounter in the real world. Problems almost always have vaguely defined inputs and outputs, and have to interact with other complex systems whose real behaviour is complex and never quite as well defined and documented as we would like. Also, solutions have to fit into an existing system which brings its own nasty constraints. A wrong requirement is exactly what the post shows in the [first part](https://itnext.io/the-missing-practical-step-by-step-test-driven-development-a7140ca4b71) where Jack, by mistake, believes that there should be a rule with the loan amount of $0. Quote from the post: &gt;*A Loan of zero? Come on, that's ridiculous!* &gt; &gt;*Oh, wait, I did send you zero dollars in the specification… ok.* &gt; &gt;*Glad to see you've uncovered a flaw in my logic. I didn't know you were capable of doing that!* You manage to figure this out earlier because you were exploring the problem space. And speaking of the problem space, you said: &gt;A pragmatic real world approach is to explore the problem space with code, explore the constraints your solution has to conform to, and get something that kind of works first. That's exactly what TDD is about, it's a tool to give you early feedback and explore the problem without having to waste most of your time debugging. Instead, you spend your time developing working software. That doesn't mean, by any chance, that TDD replaces design. It's a very common anti-pattern to avoid design and start writing code with tests first in hope that a good design will come to life. Sorry to kill your dreams, it won't. You develop a design as far as your design skills go and you can explore the problem space in a board or as pseudo-code before you actually start to write production code. Nothing prevents you from "just enough upfront design", which is different from "big upfront design".
[React Headroom](https://github.com/KyleAMathews/react-headroom) does a great job of this behavior if you are building a React application. If you aren't, you might be able to compare implementations to find potential improvements with your current attempt.
[removed]
Run: Array.prototype.reduce.call(document.getElementsByTagName('ytd-item-section-renderer'), function(agg, e) { var user = e.querySelector('#title').innerText; return (agg[user] = agg[user] || []).push({user: user, videoTitle: e.querySelector('#video-title').innerText, descriptionText: e.querySelector('#description-text').innerText, meta: Array.prototype.map.call(e.querySelectorAll('span.ytd-video-meta-block'), function (e) { return e.innerText; })}), agg; }, {}); At [https://www.youtube.com/feed/subscriptions?flow=2](https://www.youtube.com/feed/subscriptions?flow=2)
This is the real reason TDD I'd rarely done. Writing a test suite and implementation over and over is harder than writing an implementation over and over again, using tests to cement behavior.
im asking about programing side - which dont require additional API.
im asking about programing side - which dont require additional API.
State management, encapsulation, separation of concerns are some of the things Generators provide in this case. I agree these concepts are useful once you start building larger scale projects. If you disagree, please post a corresponding code sample and we will talk :)
Well there's still relations right? A post still has comments, a post still belongs to a user? These things can change and that requires breaking changes in the schema, no?
I already mentioned "Async/await is a simpler construct to make async code look sync". Why generators ? A few points to note specific to the problem in article(Infinite scroll): 1. The `items` generator encapsulates the `offset` state, which we otherwise would have been a global. 2. The `events` generator is more of a generic reusable conditional stream, it could be reused on any DOM element, any event, any condition. 3. The `for await` in the `init` method takes care of synchronization of inflight requests by not making a new request if the previous one was not yet appended. Again, this would otherwise be done using a `isLoading` boolean global flag. Thus, we avoid Global state, encapsulate state/logic within concerned methods, create reusable constructs. This is a win in my book. Albeit, in the long run.
``` // map - modify each element of array numbers.map(arr =&gt; // reduce - reduce array elements into single value arr.reduce((result, num) =&gt; (result + num), 0) ) ```
Use [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) and [reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) 
Keep in mind that onscroll events are really expensive. The event will be fired hundreds even thousands of times (on most devices). It's cheaper to set an interval and compare the offset, even if you're doing it every 100 ms. Also, special case: iOS devices address the issue by only firing a scroll event when releasing the finger (because of the overhead cost), so you'll not necessarily have the behaviour you want with just onscroll.
yeah but I have to stay with what the lessons have taught so far, and this is in the for and while loops section
If you’re not aware of the array prototype I recommend you check out some the functionality it provides. For this problem you could probably use map and reduce so.. arr.map( nestedArr =&gt; nestedArr.reduce(sum, current) =&gt; sum + current);
For (Var i =0; i&lt; (array name).length; i++) will iterate once per array item. Try and find something like it in your textbook to get more details but you could nest it once and solve it
 Beginner solution: ``` const arraySum = arr =&gt; { // collection for all of our sums const sums = []; // iterate over the collections of arrays for(let i = 0; i &lt; arr.length; i++){ // reference to the array at index i const array = arr[i]; // keep track of the current sum of an array let runningSum = 0; // iterate over each value in the array at index i for(let j = 0; j &lt; array.length; j++){ // reference value at index j of array i const val = array[j]; runningSum += val; } // once we have iterated over all the values in array i, // we have gotten the sum of the array // push runningSum into sums array sums.push( runningSum ); } return sums; } ``` Bit more advanced solution (a bit more readable too!) ``` const arraySum = array.reduce( (result, arr) =&gt; { result.push( arr.reduce( (sum, val) =&gt; sum += val ) ); return result; }, []); ``` Programming can be hard, but much like practicing an instrument, you will improve with time and practice! Best of luck to you on your programming journey! 
You don't need to use an explicit incremental for loop - in the newer versions of JS, you can just use `for (const item of items)`. The solution is as easy as a nested iteration - one outer one to get each array of numbers, and one inner one to calculate the sum of each number array. function arraySum(array) { const results = []; for (const nums of array) { let sum = 0; for (const num of nums) { sum += num; } results.push(num); } return results; } A functional, declarative alternative would be this: const add = (x, y) =&gt; x + y; const sum = (...nums) =&gt; nums.reduce(add, 0); const arraySum = arrayOfNums =&gt; arrayOfNums.map(nums =&gt; sum(...nums)); &amp;#x200B;
If you're going with this. I suggest throttling the event to prevent expensive firing
It was interesting listening to that talk. Here are the parts I found enlightening. ---- **The infamous quote, "I did not have C++ in mind,"... but also not Smalltalk?** 10:05 it's interesting to again to look at 10:09 what's actually being done out in the 10:10 world under the name of OOP and I've 10:15 been shown some very very strange 10:18 looking pieces of code over the years by 10:23 various people including people in 10:25 universities that they have said is code 10:30 and written in an OOP language and 10:33 actually I made up the term 10:35 object-oriented and I can tell you I did 10:38 not have C++ in mind 10:41 [Applause] 10:49 so the important thing here is I have 10:54 many of the same feelings about small 10:57 talk **The problem we're trying to solve: Scaling** 13:32 there we go so an analogy to these 13:36 programs of the 60s is a dog house you 13:42 take any random boards nail and hammer 13:46 pound them together and you've got a 13:48 structure that will stay up you don't 13:50 have to know anything except how to 13:52 pound a nail to do that now somebody 13:57 could come along and look at this 13:58 doghouse and say wow if we could just 14:01 expand that by a factor of 100 we could 14:04 make ourselves a cathedral it's about 14:06 three feet high that would give us 14:07 something 30 stories high and that would 14:11 be really impressive we could get a lot 14:13 of people in there and so the Carpenters 14:17 would set to work 14:18 blowing this thing up by a factor of 100 14:21 now we all know being engineers in 14:25 scientists that when you blow something 14:27 up by a factor of a hundred its mass 14:29 goes up by a factor of a million and 14:32 it's strength which is mostly due to 14:34 cross-sections of things only goes up by 14:37 a factor of 10,000 so when you blow 14:41 something up by a factor of 100 it gets 14:44 about a factor of 100 weaker in its 14:47 ability and in fact what will happen to 14:49 this doghouse it will just collapse into 14:51 a pile of rubble and then there are two **Inspiration from biology** 30:02 different now but one of the things that 30:05 Watson did in this book was to make an 30:08 assay first assay of an entire living 30:14 creature and that was the e.coli 30:16 bacteria next slide please 30:27 so if you look inside one of these the 30:31 complexity is staggering those popcorn 30:35 things are protein molecules that have 30:39 about 5000 atoms in them and as you can 30:43 see on the slide when you get rid of the 30:47 small molecules like water and calcium 30:51 ions and potassium ions and so forth 30:53 constitute about 70% of the mass of this 30:59 thing 31:00 the 30% that remains has about 120 31:03 million components that interact with 31:06 each other in an informational way and 31:09 each one of these components have as 31:13 carries quite a bit of information and 31:16 you can think of it you know the simple 31:20 simple minded way of thinking of these 31:21 things is it works kind of like ops five 31:25 there's a pattern matcher and then there 31:29 are things that happen if patterns are 31:31 matched successfully so the state that's ... 36:02 the shift in point of view here is from 36:06 mechanic's oh there's this problem if 36:08 you take things like dog houses they 36:10 don't scale by a factor of 100 very well 36:12 you take things like clocks they don't 36:15 scale by a factor of 100 very well take 36:20 things like cells they not under scale 36:23 by factors of 100 but by factors of a 36:26 trillion and the question is how do they 36:29 do it and how might we adapt this idea 36:34 for building complex systems okay this **Every object should have a URL** 43:00 more for instance one of the most 43:02 amazing things to me of people who have 43:04 been trying to put up on the Internet is 43:06 that I do not and I'm hoping somebody 43:09 will come up afterwards and tell me of 43:11 an exception to this but I do not know 43:13 of anybody yet who has realized that at 43:17 the very least every object should have 43:20 a URL because what the heck are they if 43:26 they aren't these things and I believe 43:29 that every object on the Internet should 43:31 have an IP because that represents much 43:36 better what the actual abstractions are 43:39 of physical hardware to to to the bits 43:45 so this is an early insight that objects 43:49 basically are like servers and this 43:54 notion of polymorphism which used to be 43:56 called generic procedures is a way of 44:01 thinking about classes of these servers 44:03 everybody knows about that **Pointers to any object in the world** 52:29 you think of what an HTTP message 52:32 actually is you can think of what an 52:34 object actually is and if you think of 52:37 what an object-oriented pointer actually 52:39 is I think it should be pretty clear 52:42 that any object-oriented language can 52:47 internalize its own local pointers to 52:50 any object in the world regardless of 52:52 where it was made that's the whole point 52:54 of not being able to see inside and so a ---- OK, now some of my personal analysis and interpretation. As I was listening to this talk, at one point I couldn't help but think that what he was describing is what we now call REST APIs and endpoints. * An object, according to Alan Kay, is supposed to be fully encapsulated, and not just its data, but the programming language the object was made with should be encapsulated, and the hardware the object lives on. An endpoint, similarly, doesn't expose the programming language or the hardware behind the implementation of that endpoint. * Every object should have a URL, according to Alan Kay, and any object should be able to point to any other object, regardless of how it was made. An endpoint, similarly, is identified by a URL, and every endpoint can point to and use any other endpoint through a language-independent and machine-independent identifier. * An object receives messages, according to Alan Kay, by pattern matching messages. In networking, similarly, messages are broadcast to many different machines at once, and each machine may respond to the message or ignore it by pattern matching against the destination address. 
You add relations via populate and reference other collections in MongoDB. Problem solved.
```numbers.map( numArray =&gt; numArray.reduce((acc, next) =&gt; acc + next, 0) )```
Basic as fuck, but no spammy shit. 
They say to use it in production based on their dummy test. Then in the conclusion: The only thing to keep in mind, that overuse of Profiler will inevitably lead to slower performance. Then why use it in production? I must’ve missed something. 
i'm thinking you'll get more answers if you go into some detail about what you're trying to accomplish. where does javascript come in? do you want randomly generated maps, a little dude who walks around the map, facebook integration? or do you mean something like google maps but for a fantasy place?
This is good stuff! Well done! &amp;#x200B; Lol'd @ baby being food.
First of all you got model and controller wrong. Controllers handle request response, that's it. Your business / code logic is the model part. The way you store and query DB is part of it. Front end frameworks are the View part. All three parts are separated which makes it mvc. I think you couple abstract concepts to implemention detail too much in your head. 
I will add a section explaining ytdl. Thank you letting me know.
Java !== JavaScript
I swear I didn’t mean to make it clickbaity. I will change it after I come back from school. Thank you for letting me know
https://github.com/mxgmn/WaveFunctionCollapse/blob/master/README.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [mxgmn/WaveFunctionCollapse/.../**README.md** (master → 87ad48a)](https://github.com/mxgmn/WaveFunctionCollapse/blob/87ad48afb87530c5ec479e859c0ebb95bb5f1ca2/README.md) ---- 
Toptal, triplebyte and other companies can find you work I'm sure
Ah okay thanks for the correction :)
Thanks! I'll check it out soon! By the way, I actually had free $10 credits from the Udemy black Friday offer. So I need to buy a course anyway so made this post. 
What about relocation from another contries?
I wrote a little "hack" that makes two input ranges act like a single slider with dual controls: [http://www.simple.gy/blog/range-slider-two-handles/](http://www.simple.gy/blog/range-slider-two-handles/)
I don’t think any of these things you mentioned are super helpful without any code, except for number 1. You’ve mentioned a few things that help to determine how things behave, but it doesn’t sound to me like you have much experience in any language, especially because your only ide is on your phone. I doubt very much you have context for these concepts without getting hands on with JavaScript. (This is not meant to be an insult by the way, I was where you are at one point too) You really need access to a desktop browser with a JavaScript console. You can start writing JavaScript there. Write some functions and some if statements and loops to learn about scope and recursion. Learn about prototypal inheritance and what JavaScript classes actually do. Learn about modules. Definitely learn about the dom. I don’t have any specific resources in mind. Google stuff. I have no idea what number 6 means. 
haven’t taken this course by colt (but I bought it a couple days ago), but i’ve taken both his web dev courses &amp; they’re really good, so i trust this one will be too. he comes from a boot camp / “get people career ready” background so I feel like it’s a good bet. But to be fair I haven’t checked out the other course!
You're right, I don't. I've written a few "programs", but mostly has been reading code, and books/watching YouTube/sololearn. 
i really wish I could post that 300 meme, but this is reddit, so let me paraphrase: "Java?!" "THIS IS JAVASCRIPT!!"
Thanks a lot for your input! I've taken one course from each of them and they were both really good and that's why I'm confused lol. Mostly I'll go with Andrei's though because he uses a lot of drawings/diagrams/slides and animations (with good examples) to explain stuff (which I can just screenshot and save for a quick revision later) while I haven't seen it that much in Colt's course.
Small error in your first listing, you push `num` instead of `sum`.
You can check out scroll out - https://scroll-out.github.io
Oh wow, I like this idea a lot! Using user submissions is such a cool idea!
Thanks for spotting that - I've fixed it.
Why you need Express here?
Express is totally overkill for your needs. [Anatomy of an HTTP Transaction](https://nodejs.org/uk/docs/guides/anatomy-of-an-http-transaction/)
How is it going?
What I mean is just randomly generate a 2D map. It's not being used for anything. Like imagine a map made in paint. That's how it'd look like.
Lol. 
Naming - There are multiple JavaScript style guidelines that you can follow. I like Google JS and AirBNB guidelines. Your other questions in bullet points are too broad. It all depends. 
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Thanks! I try to pay it forward when I can! I read your comment about not doing it often because people take it the wrong way, I really do hope this doesn't stop you. I'm not exaggerating when I say that comment got me over one of the biggest plateus in my learning so far. Good luck with your future as well. You're an awesome person.
After about 5 steps the whole thing becomes utter nonsense and after a couple of more steps there are pepes and red pills in the story. You should bury this wherever Microsoft got rid of Tay. Sorry for you loss.
Any computer science student that went to a real university or college and not an online or storefront "school" though using javascript to do this is weird.
[https://www.educative.io/collection/5642554087309312/5679846214598656](https://www.educative.io/collection/5642554087309312/5679846214598656)
You'll have to change it on a htaccess level by changing some rewrite settings, just do a simple google search for 'remove .html htaccess' and you should find it but i'd really suggest not to. When accessing other links you're referencing an actual file, so for example when you access www.example.com/image does this refer to a page called image or does this refer to a subdirectory of the domain, or does it refer to a HTML file?
&gt; Learning JavaScript Data Structures from oreilly I just looked up this book out of curiosity and see that the books are published by Packt Publishing, which are supposedly notorious for publishing shitty books?
 setDestinatario(luismi) will pass in an object called 'luismi' which isn't defined I think you actually want setDestinatario("luismi")
Not really, it is total chaos and anarchy! The key thing to understand is that JS has seen a huge amount of big updates recently and a lot of things are obsolete, but still there for you to use. You will get a lot of guides showing you the old ways, and also a lot of 'language purists' that will tell you a way to do something that is just their 'ocd' best practice. Best to use the latest features and not worry too much. If I were you I would definitely use: \- ES6 modules to organise the code (this also means you are in 'strict mode', check out what that means) \- Classes and the class keyword (always capitalize the class name) \- All the new async stuff OO vs functional... LOL, depends on what you like doing, there are no rules in JS land.
or declare both var luismi = "luismi"; var carmen = "carmen"; 
People with CS degrees? There are dozens of us! Dozens!
Since you're using Firebase already anyhow, can't you just store info there about the match and if they disconnect, update their rating when they connect again? If they never connect again, then it doesn't matter. (If they haven't reconnected yet, you could also update their rating while calculating the weekly winners, if that's a feature, etc.) For a turn-based game, I'm pretty sure you could do everything with Firebase anyhow, storing the information in the realtime database so that if anyone disconnects, the game doesn't end and the others can continue while waiting for the missing player to reconnect. You could also implement mechanisms for the others to continue playing without the missing player, or to kick them and then continue. In short, Firebase *is* your dedicated server. And I'm betting it's a lot more reliable and scaleable than something you'd host yourself.
I would try the dedicated server approach with websockets and see where it gets you. You seem to understand socket.io and it probably won't be difficult to get a prototype running. You might run into scaling issues down the road, but imo it's better to have a working prototype first and worry about scaling when you get there.
Thanks! I hadn't seen the #2 example before, that really clever for shorter nested objects! Will definitely check out lodash get, thanks!
That's really cool, thanks!
Wow thank you for the very detailed response! I will definitely check out optional chaining babel plugin, hadn't heard of that before and seems like the best solution, let's hope it makes it through proposal
Thanks, the only problem with truthiness for my case is that the value might be an empty string, e.g. falsy but we still need it to validate as true :(
I wrote this post with frontend and backend software engineers in mind (particularly coworkers and my wife, who started programming professionally two years ago). But it may have turned out more like what you said: a quick, minimal refresher for people who have seen bits of compilers before. That said I think that a professional programmer can and should come to a decent understanding of compilers and interpreters. It may take time but the lessons are worth it! It's accomplishable even if you didn't earn a degree (neither my wife nor I earned CS degrees or attended a bootcamp).
You can use a client-side router for this. 
Sure, but you will need a server which serves the client-side routing code on "any" URL. No amount of front-end-only configuration will fix this. 
TDD definitely works in the real world, I have had projects before where we have used it and it has been useful in a lot of situations. It is definitely not possible in a lot of situations though, but just due to the nature of how business works and having deadlines for things. When I have used it, I was working for a company where everyone needed to get well thought out specifications to us weeks before we started working on it, and if we, as a team, thought the specs weren't complete enough then we could just refuse to do the work and delay it until it was. This is definitely not the situation most developers find themselves in (and I am not any more) and it is a lot harder to do when you are given 2 weeks worth of work and no-one has put more than 1 minutes thought into giving you a 3 line specification for it but you better do it anyway because the client has already paid for it and sales promised it to them by the 5th of December so get on with it.
To be fair, compiler 'basics' are still a pretty advanced topic. :) That said, people with a CS degree from a traditional college/university, anyone with assembler experience, or anyone with compiler experience wouldn't have too much trouble with this. Another thing that makes it less approachable are the languages involved. Assembler is great for speed but daunting to read without a lot of experience; Lisp is... not the most common language anymore.
Nice, I'm bookmarking this!
Well the problem with using Firebase for this is that I also need the server/host to handle some game logic. For instance when a player clicks something to perform an action, it issues the server to perform some sort of action that might need the serverside to calculate stuff or something, and then after that notify all players of the updated state. So I need server logic and not just a database, which is why I started thinking about having a dedicated server. Or is this achievable with Firebase? I am not very experienced with using Firebase, I have only used it for realtime database and authentication.
No, there's apparently no way to do serverside logic with just Firebase. You can run your own server that connects to it, but that's still running your own server. Instead, what I'd do is still have one of the players be the "server" and run all the logic. If that player disconnects, then I'd have logic that allows the next player in the room's player list to take over as the server. It's probably slightly more complicated than just having a server, but I think the reliability that you'd gain would be worth it.
Allright thank you! I was thinking something like that as well. &amp;#x200B; Do you have any tips though as how to handle several simultaneous gaming sessions? I'm thinking about maybe having an array of gaming sessions (serverside), each with its own unique ID. So that when a user creates a new game lobby, a new "game object" is added to the list with a new generated unique ID. And everytime someone does something in that game that needs to be notified to other players (like sending a chat message) the server can then notify the players in the same game lobby only. &amp;#x200B; When you talk about scaling issues, are you referring to a max number of simultaneous server connections with socket io?
I believe Codecademy has a certificate program with the exact same name you've mentioned. I'll confirm this when I can get in PC, but either way it's also a great course. 
&gt;Package management wasn’t a thing because git hadn’t been invented yet. ???
Cool man
Here. Have a donut. It's your donut. Enjoy your donut. Wait, you're not actually meant to eat the donut. Don't eat the donut. I said don't eat the donut!
I think if you just put there `{}` as package.json it should start to work. You know you should probably just use git submodules: https://git-scm.com/book/en/v2/Git-Tools-Submodules instead of npm.
Have you tried back-end with Node.js? Perhaps add TypeScript to learn something new (if you aren't already using it). Also, if you use a particular front-end framework, try using a different one (I always recommend to try Vue.js to anyone who hasn't yet). If you don't use any framework, then start using one (again, Vue or React).
Very Nice. Bookmarked ;)
Good boy
thanks! do you reccomend Node over Vue first? Honestly, my goal is to be hired by a web firm as jr. front end web dev. I've been feeling like Node would maybe distract me from more useful front end technologies. Is that bad thinking? thanks again.
Exactly what this guy said. It’s all a preference. Find one you like and use it.
Java is not the same programming language as JavaScript. Please refer to /r/java. Oh, and that being said, WE'RE ALSO NOT A JOB BOARD.
Line 28 needs to be an else if, not just an if.
I wrote down a basic network cli - [https://github.com/anubhavsrivastava/blame-my-network](https://github.com/anubhavsrivastava/blame-my-network) which can be used to detect whether a site is available from external network or is not + available from internal network or not. \- Need feedback and opinion
vscode has much better autocompletion for javascript out of the box (no need to install TernJs or something like that)
Ok, what's happening is that your update() function is getting called many times per second So when you set curscr to something, you're running the specified function over and over and over again, until your settimeout call triggers and switches to the next screen This means while "lvl1" is the active screen, *each frame* will add an additional settimeout to call lvl10 (the one with the randomness in) - so you get 200 milliseconds where it's calling that randomiser function over and over and over. The simple fix, is to set curscr to undefined after your settimeout calls, and check that it's not undefined in the update function - this will ensure that your functions each only get called once.
That is a big fat "it depends". What does your current environment do for you? What sort of workflow do you follow? What might you want to see in it or elsewhere? Do you need integration with any particular tools or processes? Many are happy with nothing more than a good text processor with reasonable syntax highlighting and similar aids like block folding - in which case most good text editors will do the trick (Notepad++ is my usual, IIRC Atom which you currently use does also though is likely much more of a resource hog as NP++ is reasonably lean). Some, particularly those working on larger or more complex projects, are likely to want more integration, automation, and other assistance, than simpler environments offer. No point taking the effort to switch without good reason. A better question is "what IDE do you use any why?". From good answers to that you can decide if the "why"s are things that would actually be relevant and useful to you.
Hi, can you please report any offensive paths on the discord? [https://discord.gg/DzMBEj5](https://discord.gg/DzMBEj5)
well these days, node is really popular in a lot of startups because firms can hire people who know javascript and they can write code for both backend and frontend. &amp;#x200B; IN larger companies you might be able to specialize in just frontend, but in many startups/smaller companies you'll probably be asked to do both. &amp;#x200B; Nodejs is still javascript, so all of the syntax and functionality is the same. There are some important differences though like the module system, and the standard library has things that you can do in nodejs that you obviously cannot do in the browser (like open files, and such). &amp;#x200B; So I'd say give it a try. It's not going to be too much of a jump from clientside javascript. Instead, the biggest challenge is probably learning how to set up and install your node environment. And an even bigger challenge if you want to learn how to actually deploy your code to a server somewhere, instead of just running it locally. &amp;#x200B; Let me know if you have any questions
VS Code is the best atm
I'm not the one who commented, but yes I think that's what they mean. &amp;#x200B; when running an application using [socket.io](https://socket.io) you are probably only going to run it on one process/one server. This way everything is in memory in that one thread, and you can send all the data you need from one place. If you have too many concurrent connections then a single server won't be able to handle them all, and will be very slow/potentially crash. &amp;#x200B; One solution is to use socketio redis adapter (if you know how to set up a redis server) where you have a single endpoint to store data in memory, and then you can have many servers running socketio which just pass along the data from and to the redis server. &amp;#x200B; It's a bit more complicated than that, but honestly if you are just making a prototype I wouldn't worry about scaling at first. Just get something to work :)
looks awesome OP
Yeah it always depends on your focus, there's not a wrong or right answer. If you wanna understand back-end and databases, go with Node. If you wanna enhance your front-end skills, go with Vue (or React). If you wanna work on your JS, anything JS-new that you haven't worked with will widen your horizons. So in your case I'd say go for Vue.js.
I can't ever leave Sublime at this point. 2 fast 2 lightweight
Webstorm is the most powerful js IDE but too expensive. Atom is similar to VS Code, but runs slower and use more memory &amp;#x200B; &amp;#x200B;
We covered assembly in second year undergrad. Learnt to build a tree structure (interpreter pattern) to compute infix notation similar to the notation used in the article in first year as a part of software modelling. So I’d guess most second or third year undergrads could probably make sense of what’s happening here but perhaps not implement it themselves.
Doing this means server player will have an incredible advantage as they can control the flow of data to the other players. You cannot manage cheating without a separate server. Also you need to obfuscate the ip addresses or you’re introducing a giant security risk. 
The problem is what /u/benjymous have already mention. Without changing the code too much, my suggestion is to add another variable to indicate that the `setTimeout()` function is already been called. i.e. to indicate that a timer has been setup, or to indicate that the screen has been set up to be switched. http://koda.nu/labbet/31523468 I've changed the placement of the functions in code so that they're ordered by the program's flow. It won't have any effect to the program's functionality. It's done simply to ease maintenance. Small changes are also done for this purpose. I've also changed the URL of the image which is from `encrypted-tbn0.gstatic.com`, because the URL uses URL variable(s). This forces the browser to always check the image from the server, thus causing a delay when showing the image - instead of simply load it from the browser cache (if already exist). I've copied the image and uploaded it into `imgur.com` so that its URL is static and doesn't have any URL variable.
In this day and age that's pretty much true, but remember that jQuery's heyday was years ago when there were different browser incompatibilities and things like `document.querySelector` wasn't able to be used in most browsers. jQuery abstracted all of those differences away and made your code actually work in older browsers (think IE8, 9, etc) and the API it gave us was way easier to use than trying to work around every browser's specific version of their DOM api.
To be honest, I think you can use _any_ course on data structures and algorithms. The concepts are the same, regardless of language. I only know JavaScript, but I've been learning both data structures and algorithms with Java tutorials. It's not hard to understand what code is doing, especially when a tutorial covers the logic behind it.
So it's pretty much over right ? 
For most new projects, you likely won't include jQuery unless you're using some library that requires it (e.g. bootstrap's Javascript). Now that everyone has moved onto Single Page Apps (SPAs) you won't see jQuery getting included unless the above criteria is met, and in those instances it's pretty much only going to be to serve as a dependency (e.g. you won't actually use it). That being said if you're still building a multi-page site that has to work on older versions of IE, you might be stuck using it still.
Wow, what great accuracy choosing where to post this! Clearly not unrelated to this sub! =|
Very cool! Although you should maybe change the hover effect on your site - right now the icons suddenly get small and then slowly turn larger. It would be nicer if they just turned larger.
If anyone is wondering, I went with Andrei's course as it also had an interview preparation section and a huge discord community to get help. I cannot give any reviews just yet as I'm busy with another course and some projects and will be starting this one probably in January.
If you have the option, sure. It's also worth considering that practising reading other languages makes you more employable, even if you never apply to write them. Converting a Java back end over to NodeJS would be a common requirement, for example. Even any other language, showing that you can learn a new language as needed makes you stand out over others who haven't. If you're paying for courses, go for the one in your language. Better safe than sorry, unless you've heard outstanding things about a non-JS course. Alternatively, the book Cracking the Coding Interview covers data structures and algorithms using Java as examples.
It's MIT licensed. There's no hijacking going on here; this is a thing that can happen and if you're a popular project with an MIT license, it's bound to happen eventually.
Thanks! \&gt; Converting a Java back end over to NodeJS Yes, makes sense. I'll try the things you suggested. And thanks for mentioning that book. Looks good!
Laravel is a magic filled framework for PHP, where NodeJS is a script interpreter for JS.... Not sure how you connected the two.
Just write a function that takes a nodelist and a callback and executes the callback on each node, then reuse it everywhere 
Huh, I don’t really see a problem with the project idea. It seems like they’re making a proprietary tool on top of open source software which happens all the time. The copyright change is a bit of a problem, but can be rolled back and have those chroma employees removed from commit access. Maybe I’m misunderstanding?
Node is a barebones, fairly low-level runtime without any opinions. Laravel is a full, heavily opionated framework. I don't see how you connect them. Do you understand what Deno is? It's a barebones runtime (like Node) for Typescript, not ordinary Javascript. Unless your codebase is written in Typescript, you can't use Deno. With regular JS you are "stuck" with Node. But it sounds like you haven't given it enough chance, anyway. Have you tried it with Express or some other lightweight library/framework?
I was just looking for some icons for a Vue project and couldn't find what I was looking for, and there are icons in here that'll work! Thanks so much for sharing!
If your host leaves, you could set up a way to handoff the host responsibilities to another player. Perhaps if everyone loses the heartbeat message from the host after a certain length of time, give up on the host and send messages/data player-to-player transferring the host role to another machine. &amp;#x200B; The standalone server does give you a lot of anti-cheat capabilities, which is important if you are managing rank. People WILL cheat. I promise you that. But if the standalone server is running the game, and the browsers are just clients sending keystrokes and receiving UI update instructions, they can't cheat at the game as easily because your server is the referee. It also allows you to store rank and do leaderboards from a central authorized data location. Don't store that kind of data in a player client, they'll just hack it. &amp;#x200B; The downside to having a game server that referees/manages all communication is that it introduces lag, because instead of Player 1 sending a message to Player 2, Player 1 has to send a message to the server, then the server sends it to Player 2. &amp;#x200B;
&gt;Do you understand what Deno is? It's a barebones runtime (like Node) for Typescript, not ordinary Javascript. Unless your codebase is written in Typescript, you presumably can't use Deno. That's a strange presumption to make considering JavaScript can be used with TypeScript. You can reference any bit of JavaScript, it just will not have type information, and thus no type checking for the JavaScript parts. 
The whole point of MIT license is to allow commercial stuff to be built on top of it. Keep doing what you're doing and make an open alternative to storybook loop or whatever if you want.
Thanks so much!
https://teachyourselfcs.com/
Chears :)
I did not make additional animations. Animations come with Eva icons library.
The article states that "Storybook’s community-built identity and brand are at risk of, and are in the process of being hijacked". Storybook used to be a purely OSS effort. The maintainers changed and now they work for a commercial entity. This was never the intention of the original author as can be seen here: [storybook/issues/1126](https://github.com/storybooks/storybook/issues/1126) where he says "I think it's better to move this to some other party which has no financial or other bad agendas in mind". I think it's a fair ask to make sure that Storybook is governed by an entity that is not biased towards financial gain, hence the ask to move this project to [js.foundation](https://js.foundation/) &amp;#x200B;
I don’t see why that matters, the commits themselves are still open source. Also, the only commit thing I saw was the copyright change which should be reverted, unless I missed something which is possible.
tell this to the last 3 javascript engineering positions i applied to. none of them seemed thrilled my knowledge of algos / data structures was pretty limited.
I mean don’t learn algorithms and data structures in JavaScript. Like it would be easier to learn java and then algo and data structures
Try out [https://github.com/search?l=JSON&amp;q=org%3A\[YOUR ORG NAME HERE\]+event-stream&amp;type=Code](https://github.com/search?l=JSON&amp;q=org%3A[YOUR ORG NAME HERE]+event-stream&amp;type=Code) :)
Unfortunately this will be a big mess to sort out with every line of code needing legal accountability of the copyright owner, including evolutions of the line over time. Anyone who refused to sign would need to have all of their code rewritten without inspiration of the original code or tests (deriving an implementation off someone else's is legally shaky enough for them to maintain copyright). The copyright can't just be changed retroactively; the law doesn't work like that. I'm genuinely curious how this will work out. I'd recommend that the neutral third party be in charge of who has commit access and removes people who they deem bad faith, with a community involvement somehow, and change the copyright to something better reflecting reality (like all contributors).
The hover effect is in the code of your docs page. Are you saying you didn't write that?
I think the issue here is that Storybook is not just a codebase that you can fork. It's also a community and eco-system that are not really forkable. There are a ton of add-ons, and companies like [Percy.io](https://Percy.io) (the authors of this open letter) will be very affected by this. Like who gets to decide what the Storybook twitter account can be used for, especially when the original author who created the MIT license said he would like a new maintainer that will not have a commercial interests (see here [storybook/issues/1126](https://github.com/storybooks/storybook/issues/1126)), but now the author has been changed in the license from Kadira (Aurnoda's company) to Norbort (an employee of Chroma).
Turns out the glimmer implementation was never even rendering (during the actual measurements). https://twitter.com/vaier/status/1067129210647527425?s=21 Good thing I found tons of performance improvements for Imba in the few days I thought glimmer had it beat :D
Yeah the copyright change just seems to be an innocent mistake which has already been reverted, and they have a plan to give the copyright to the Linux foundation... so all is well there it seems. &amp;#x200B; It sounds basically like some people who work on Storybook have been hired to continue working on Storybook. No big drama.
The author’s intentions are, unfortunately, secondary to his actions. By licensing Storybook under the MIT he probably made this possible. 
&gt;The hover effect is in the code of your docs page. Are you saying you didn't write that? I meant the animation when you hover on the icons, the animation of which can be changed at the beginning of the list of icons
Sorry, now I understand what you mean!
I don't think there is "one true solution" to a problem - even if I did I'm not arrogant enough to believe I could just pluck it out of thin air. However, with experience I do believe that I can write a reasonable implementation, and then refactor it to be good. I don't believe I need to write throwaway code first just to satisfy minimalist dogma. I'm not against test-first development, but I still haven't heard a good argument against writing all the tests up front, writing an implementation that makes them pass, then refactoring. The multiple red/green/refactor stages seem like timewasting cruft to me.
Chroma forking the code and doing whatever they want with it would be entirely fair game. Hijacking the primary Storybook identity for their own commercial interests is not. The Storybook brand, blog, and twitter account are being used in inappropriate ways. Closed-source work under the Storybook identity is not something anyone wants to see happen. 
we have the glimmer VM folks talking about performance improvements as well :)
Of course it can be done with plain js, jQuery was obviously written with js, that means that any functionality you wanted to use, you could code without jQuery, just not that easily and programmer friendly. You could say this about any js library/framework as in the end they're always built with js. Foe example I can code any moment library functionality manually, but that would be kind of painful and unproductive. The thing is they're supposed to make your work easier - and they did back in the day (jQuery) if they were used correctly. jQuery was good for animations and scrolling, but once people tried to make a SPA with it, it became painful, because that wasn't its purpose.
I wouldn't worry about this since packages are audited regularly. Now I need to get back to work and wrap up a simple landing page before lunch...npm install 27 terabytes.
Please format your code. This is so hard to read.
Yes, yes everyone, lets downvote this so nobody sees it.
Hi bro, I can not format the code right ... So I'm putting the image with the formatted code
&amp;#x200B;
Hey guys, sorry for the late update. Here are my thoughts: I think Mead is a great instructor and very hands on, but he sometimes rushes through things quite fast without really explaining what's happening under the hood so to speak. For example, when creating a server, he jumps right into Express without even mentioning the built in core module 'Http', which Max does. I'm taking both courses at the same time actually to get a better understanding, and I think Max goes into details more and also elaborates on the "why" a bit more. I can't stop myself from laughing at the way he speaks every once in a while (don't get me wrong, I'm a Swede and I have by no means perfect English myself). I took Andrews course for JavaScript, which was great with more "think-by-yourself" kind of challenges, whereas the Node challenges he provides are pretty much "do what I just did". Max's course is newer and therefore more up-to date, as well as more comprehensive. If you pick one, go for Max. Even so, the next course I'll take will be Meads new React course, I just don't think the Node course is as good as his newer courses are, such as the JavaScript course, and hopefully the React course as well. Good luck guys! 
I moved on to mootools and haven't looked $$('.back').
Done.
POsted
Hi /u/codersdiaries, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Read a book
As I commented on github, auditing would not have helped, as the backdoor was not in the source but only the minified version published on npm. 
https://developer.mozilla.org/en-US/docs/Web/API/History_API Then you check window.location.pathname on page load. When you use pushState you have to manually setup the new route as well. You could create a function that clears the root node and renders the layout you want. But beware that you need to listen to the popstate event, so that you can catch next/back button clicks.
Welcome to why I rarely add external dependencies. Just this Friday , I looked at a package that would’ve solved most of my particular problem. Rather than to forever have to trust a stranger, I just reimplemented the functionality myself. Zero external trust or tech debt issues, all for the cost of a few hours of work. It’s not that I think all external dependence s are bad, it’s just that you should be extremely discriminated when/if adding them. 
Can anyone tell me why NPM even needs a registry like they have? What’s wrong with just using GitHub repositories (or any git repo) like a lot of other package managers do? Dependencies would just be links to git repositories or even just “username/repo” for defaulting to GitHub. Are there reasons for not doing it this way? Recently been doing some Swift and this is how Carthage does it.
It's not hard. ``` const root = document.querySelector('#root') function render() { root.innerHTML = '' switch (location.pathname) { case '/': return renderHome() ... } } render() addEventListener('popstate', render) document.addEventListener('click', event =&gt; { if (event.target.tagName === 'A') { location.history.pushState({}, '', event.target.href) event.preventDefault() } }) ``` Might need some testing though. And it will not handle the enter key for links.
Yes I'm also using Express
I'd say a 4 or 5. You know a lot of the keywords, but judging by the way you've explained how JavaScript works, you haven't quite got them slotted in together correctly quite yet. Here's my explanation of the topics discussed in your post: Not everything is an object. The key difference between objects and other values is that objects are passed by reference. This means: var o1 = { a: 1 }; var o2 = o1; o2.a = 5; o1.a === 5; // returns true Whereas values are passed by their actual value. Such that: var s1 = "string"; var s2 = s1; s2 += "10"; s1 === "string"; // returns true The only link values have to their object counterparts is that they use the object's prototype, giving you access to methods, etc. So: var n1 = new Number(5.4); var n2 = 5.4; n1.toFixed(2) === "5.40"; // returns true n2.toFixed(2) === "5.40"; // returns true Keywords are not objects. I'm guessing you meant something else by that. Care to expand? An object is not a function. A function runs some code. It can be passed arguments, which can be used to influence what the function does. Using the keyword \`new\` on a function will create a new object with the prototype set to the function's special \`.prototype\` object. When accessing a property that does not exist on an object, the system will try to access that object's direct prototype for the same property. It will repeat this until it finds the property, or will return \`undefined\` if none was found. I don't know what you meant by "or produces a result, via an algorithm, that's instantiated by invoking a new instance of itself, by performing a Callback." Something to do with prototypal inheritance, perhaps? Scope for locally declared variables is restricted to a certain scope. \`var\` is restricted to the function. \`let\` and \`const\` is restricted to the code block (including things like \`if\` statements. A \`const\` variable's value cannot be set after declaration. Functions are objects. When a function is created and it references variables outside of itself, it creates a "closure" to allow access to variables within the scope it was created in. "Callbacks" are a way of using functions--passing a function to another function, to be called later. Scope has nothing to do with callbacks. "Recursion" is a way of using functions--calling a function from itself. Recursion has nothing to do with scope. Inheritance comes from the way prototypes are checked for missing properties.
You should use `button` elements in your Button component instead of divs. If it acts as a button, use a button. It makes for a way better experience on mobile and on accessible hardware.
With Nginx ``` root /var/www/your_site; location / { try_files $uri /index.html; } ``` A bit naive, but it works.
If you don't throw away code that means you know the solution to the problem upfront. If you write the whole implementation upfront, you speculate on the problem boundaries you need to test. With TDD you to ask questions and the change of your understanding of the problem throughout the programming process reflects on the code. Requirements are never clear, you need to write throwaway code. That's Programming.
Right now you can get the complete Javascript course on Udemy for like $10. However, if you're solely leaning Javascript for Unity and you don't have plans for web development. I would suggest learning C# instead as that is the primary language used with Unity.
/r/iamverysmart
e.g. Git force-push
&gt; npm install 27 terabytes. lol. This is so true. Why are these simple scripts so massive in dependencies
thanks!
Why reinvent the wheel when you can import the entire fleet?
https://www.reddit.com/r/programming/comments/a0kxmw/i_dont_know_what_to_say_backdoor_in_popular/
What do you mean? Which object is potentially an empty string? If `obj` is an empty string, it won't have a `prop1` field unless you're doing something undesirable, like modifying `String.prototoype`. Likewise for `prop1` and `prop2`. If `prop3` is the intended empty string, you just use change to: if (obj &amp;&amp; obj.prop1 &amp;&amp; obj.prop1.prop2 &amp;&amp; obj.prop1.prop2.prop3 === '') { // good to go } I can't see a problem. Could you elaborate?
Nope thx, i figured it out.
For clarity, a specific release was available that mined crypto. It should be fine again now, but still be wary. Likely a bunch of repos unknowingly installed this anyway.
Oh. Okay. 😅
That's why you specify versions in your package.json.
Yes they do, it's to steal bitcoin wallets. &amp;#x200B; [https://github.com/dominictarr/event-stream/issues/116#issuecomment-441745900](https://github.com/dominictarr/event-stream/issues/116#issuecomment-441745900)
Sounds like Percy.io should fork this immediately. I also don't think MIT licensing gives a shit about it's community or eco-system and unless foul play is afoot, the acquisition of the twitter account is likely legal. The moral is that I don't think the community's opinion matters here. Sure it would be nice if they listened but they certainly aren't in the wrong for not listening.
Haha! 🤣
Wanted to have a script to generate library folder for publishing. Research I did at the time didn't yield any results so decided to take a stab at it and came up with this. &amp;#x200B; Most libraries I've checked have their own publish script, this is an attempt to simplify it
How would that help with preventing malicious npm packages?
I don't understand this reasoning. By making it open source the creators explicitly told the world: Our work is free to take and modify as you see fit. If they're not okay with that, they shouldn't have made it open source...
 —save-exact
Hi /u/EnvironmentalHouse0, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/yungsushi531, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/SpamFilterHatesMe, I didn't think I'd ever have to warn someone about being misogynistic in /r/javascript, but here were are. Please don't do it again. 
there where no mining, it where trying to steal bitcoin wallets.
https://www.w3schools.com/js/ its free!
Well the problem is that you need _everyone_ to specify versions. When you include a package, they include other packages, and those include other packages, and so on. All of those packages need to be explicit. It's a very fragile web.
&gt; I wouldn't worry about this since packages are audited regularly. &gt; &gt; by whom? 
Yes. There are so many jobs. 
From being proficient at javascript solely? Because I wanted to practice in it a LOT
Doesn't NPM5 do this with a \`package-lock.json\`?
Why not use .gitignore as a source of what to exclude when publishing, as NPM/Yarn/etc do? Does it follow Git hooks, especially for pre- &amp; post-publish? What's the benefits of using this rather than the standard of package.json + an existing publish method from NPM, Yarn, or etc, and possibly a custom publishing script? Just curious; not even a hobbyist programmer at this point, so IDK why I'm even hanging around this sub.
I wouldn’t suggest testing your real data with unit tests. Just mock out your data structure and test to make sure your function returns what you expect with the mock data.
Yes
You could literally be a full time node dev where you only write JS for 50 hours a week, 50 weeks a year
Isn't this what package-lock.json is for? Can you explain why anyone would use --save-exact when package-lock.json is created and used by default?
Isn't this what package-lock.json is for? If you have package-lock.json in your repo and use it for installs, you won't pull newer versions by default, unless you issue a specific npm command to upgrade a package or install a new one.
That's the joke.
Open source means anyone can audit it at any time! What do you mean? Why would *I* audit it?
There are 730000 modules and how many instances of this? 1? Say there were 5 ( I think it's actually closer to 1).5/730000 means we have proven that 99.999% of packages are trustworthy. If you want it to be easy to publish and consume packages, I doubt there is going to be a better system. But people are free to use their own tools. As far as blaming dominictarr or whoever, I think that's bullshit. How is he supposed to know whether he can trust someone who asks to maintain a package? Is he supposed to do a criminal background check? Is he supposed to spend a half an hour trying to prove they are a good programmer? Should he reject people who offer that he doesn't know? No. People like him who have put out a crapload of free libraries do not have time and should not be expected to make an investigation into people who offer to take over repos. When he can get help he needs to take it. What no one is saying that I will say. We need to find out who this fucker was, track him down in real life and get him in jail if at all possible. If not, whatever repercussions we can manage. I think the guy that did it is the one you blame. If there were really a bunch of incidents like this that would be different. But there is not a structural problem. The thing is that there are a lot of people who are insecure and have made a hobby of shitting on JS and JS devs. So these types of things make their day. I just want to say that I have been programming for 33 years and JS is a good language that actually requires strong skills because it is dynamic and the massive npm system is actually a software engineering triumph in realizing strong code reuse.
Yes but the hardest job is the first one. There are a lot of terrible developers, so a lot of companies aren't willing to take a risk on anyone with less than 3 years experience.
The guy he handed the project off to had no commit history. Not even looking at his github is pure laziness imo
I think this is ultimately the result of the early npm culture to have millions of tiny packages that do one thing. It makes sense on paper, but neglects what happens over time after the enthusiasm for all these tiny projects wears off but they aren’t big enough to have bigger projects or teams form around them. Java has things like Apache commons which doesn’t do one thing well, but you also don’t have to worry it’s going to be handed off to a random hacker in the night.
That's basically what the repo owner did. Just turned it over to some random dude.
I would recommend learning at least a second skill set in addition to JavaScript. If you're interested in the back-end, I'd get familiar with databases, security, and setting up/administering servers. If you're interested in front-end, I'd learn CSS and HTML as well as design tools like Photoshop/Sketch/etc.
Good stuff 
And people get mad at me when I choose to implement my own solutions
It's **far** more feasible to audit the unminified version. I think the correct way of dealing with this is changing the tooling to make minification something that is done as part of a deployment, rather than the way package sources are distributed.
Who are you saying this to? I don't think it's possible to mistake your original comment for non-sarcasm.
And I don't see how tracking down malicious publishers is the best solution. Do you try to track down malicious users of your apps or do you build security features? 
I wouldn't personally call it "tech debt" but it is certainly "security debt" (otherwise known as "risk"). How much risk you take on is your liability (similar to a debt liability), so it's up to you to balance how much risk you take on vs how much third-party code you use. I'd say the two concepts are not dissimilar.
I agree: when programming in Java I rarely use any library that's not from huge entities like Apache Foundation, Spring, Eclipse etc. I know I can trust them blindly. When I need something for JavaScript il just grab the library with the most stars in GitHub, (and even very popular libraries have huge bugs)
I'm sure there are. But the job of maintaining a library that is hosted on github requires experience with github at the least. I can't think of an easier way of doing minimal due diligence than checking their github
How much experience does GitHub really require? You actually just need to know git and find the origin url on GitHub. I think people are trying pretty hard to blame dominictarr when the person who actually is to blame is the one who did it.
Nice! Corporate data centers finally using their horsepower
I think I'm interested in the back-end!! Can you explain a little bit more about it to me? I found memorizing Internet protocols for the networking section at school boring : ( does it have anything to do with stuff like that?
How dare I not use an ltrim library. :|
What's to prevent this from happening again? How do you know this is the only instance of this? There's long been discussion about using cryptographic assigning to address this issue but I don't know enough to comment. https://github.com/node-forward/discussions/issues/29
Thats not how open source works 
I'm waving this off as nothing to see because there is nothing to see. The community is not a relevant factor here. It's not apparent that anything wrong was actually done. Just because the community doesn't like what they're doing doesn't mean they aren't allowed to do it.
I’m not super familiar with EJS, but a standard encapsulation of components and lifecycle come to mind. 
yes
The CEO of NPM needs to be replaced. He's a constant embarrassment.
Yes, that is what I am implying.
Wow, just read the PR from node-cross-spawn. I immediately made sure I didn’t use any dependencies from that author.
You mean cryptographic signing. The issue you reference says to do it at the require but that doesn't make any sense. Anyway having all packages signed doesn't prevent this problem it just adds a lot of overhead and a false sense of security. What you can do is use things like whitelists or blacklists and some people are doing that but I think for most projects it doesn't make sense at this point when we only have like one incident.
This doesn’t help at all if you specify a version of a library that depends on the vulnerable package, which considering it was up for weeks is quite likely.
Finger always seems to point outward. People are pissed at the attacker, the old maintainer, NPM, Node, the people depending on the compromised packages, and even a few comments about how it's GitHub's fault. But what about the developers who included the dependencies in their own end-user applications? Obviously other people fucked up and deserve the shame and pitchforks currently at their door. However there's an interesting line included in the event-stream repository that many seem to overlook: &gt; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED ... I know it's the standard practice, but by depending on and executing arbitrary code from untrusted sources you, as a developer, take on the risks associated with that. I'm not admonishing any of the upset individuals who are shocked and furious about a supply-chain attack and the obvious malpractice of the former maintainer. I'm pointing a finger right at the face of a sacred cow: blind trust and reuse of third party libraries. We as a community, profession, and individuals need to do our own due diligence to review the content of dependencies, minimize our exposure to supply chain attacks, pin the versions (both source and binary) that we pull for dependencies, and run automation to detect anomalies, vulnerabilities, and known compromises. We need to reduce the number of individual packages we pull in and in so doing reduce the number of strangers on the internet we have to trust with the security of our users. I know that's a monumental task and will probably take a decade or more to really ingrain in the minds of developers as a mode of work, but you can start today.
Replacing npm, Inc. with a sane organization that cares about platform engineering and stability would solve half of the problems in the JavaScript ecosystem. npm is cancer, both as a tool and as a company. Not even PHP has these issues.
Yes, a ridiculous number of jobs. So many, in fact, that the real pain is for those of us trying to *hire* developers. I have openings on my team that I’ve been trying to fill for over a year, but apparently the &gt;100 year old company I work for isn’t “hip” enough to compete with all the startups..
I do the lazier version: prefer dependencies that *themselves* have no dependencies, or at the very least, dependencies i trust. 
This is exactly why I'll stick to the .NET environment. NPM seems like a good idea, but it's a security nightmare. I would spend all my time vetting packages instead of writing code.
The other side of the coin is that these vulnerabilities are fixed within hours instead of weeks now. 
There are some really good free resources out there, here are some of the best in my opinion: http://javascript.info/ https://github.com/getify/You-Dont-Know-JS https://watchandcode.com/p/practical-javascript https://developer.mozilla.org/en-US/docs/Learn/JavaScript Just pick your poison and good luck!
Yes, that is what I am implying. I gave him a Zenbook last year I guess though.
Doesn't nuget have third party libraries? How is that different. I'm not super familiar with that world so genuinely curious
What exactly could any other entity done in this situation exactly? 
I’m not trying to debate you homie. I understand there’s reasons to use certain things. I appreciate your insight, I’ll use what I’ve learned to help inform my decisions going forward.
take the F, it's better than being expelled.
Well, I mean.. https://www.reddit.com/r/PHP/comments/4bsu3b/are_composer_and_packagist_also_vulnerable_to/ FWIW there are npm proxies as well, and keeping your node_modules around is just as useful a solution as keeping composer's vendor directory. 
Considering this is a transitive dependency of many packages not something normal development will `npm install`, how easy it is to bring in updated dependencies with the version notation of npm, and the callous nature of which the maintainer responded to a rather large vulnerability that he caused by turning over maintenance to some random person, I think the anger towards him is justified. If you spent your development time carefully evaluating all PRs and code commits to every transitive dependency update in NPM, you’d never get any actual work done. There is a certain level of trust between maintainer and consumer of a package that the maintainer is acting in good faith, and considering this package is used so ubiquitously, this is only exacerbated. So stay up there on your high horse waggling a finger if you want to, but if NPM itself continues its trajectory of small consumable pieces of code with maintainers that are so flippant to their responsibility to act in good faith, this problem will continue to come up. What you’re proposing is both unrealistic, and unproductive to a normal development cycle.
Even still, how can you trust your compiler, your operating system, the websites you visit, your router? I'm sure the giants have some measures against attacks from all of these vectors, but the entire world of programming is built on trust.
It’s not this situation specifically — it’s them continuing to enable and tolerate this kind of behavior from rogue devs. There’s dozens of cases of this occurring. left-pad and is-number are probably the two most famous. They make really bad technical decisions in general to boot. For an isolated example, npm was the only package manager worth using with node for like five years. People were asking for automatic lockfiles for years — and not just small time devs; Facebook wanted this feature. But npm continued to be idiotic. So Facebook made yarn. A couple months after yarn releases, npm implements automatic lockfiles. It took a competitor for them to realize their mistake. npm has made good decisions from time to time, like keeping up the uws module a few months ago even when the dev wanted to take it down. But for the most part, they’ve enabled developers to make dumb decisions that impact the entire platform, and they’re obviously continuing to do so.
Also, what are you going to learn if we do it for you? Man-up or woman-up and do whatever you can on the exercises. Something is better than nothing. Getting A’s isn’t going to matter once they hand you the diploma, so do the best you can and focus on learning the material. My 400 level programming teacher was a guy with a THICK Indian accent. It happens to all of us. I learned to study my ass off just to pass, use Stack Overflow, and get together with my classmates to knock assignments out together. 
If you hold this belief why not just copy paste the source code in to your version control and code review it? Surely that’s easier than rewriting everything you need. 
So what's the solution to that? Big companies are writing a lot of software, but not nearly enough to rely solely on them. 
This wouldn't be an issue if people shrink wrapped their code. You shouldn't be accepting a different version of something on every install. I only use exact types and regularly shrink wrap my code because if I install it on a thousand machines I want all of them to have the exact same versions of every library for consistency. Plus I only want new code added to my projects when I say so and manually update.
Or you just shrinkwrap your code after every update. It locks down all versions of all dependencies. It's a very simple command and one that can apparently save you a lot of money. 
You can't compare PHP to this. NodeJS and its current ecosystem is the only such where importing a 3rd party library to check if a number is even, odd or is zero is considered a best-practice.
Didn't the post in /r/programming say it was a backdoor?
This just isn't an option. I do my very best to avoid dependencies. I only use `babel`, `jest`, and `eslint`, some of the most popular JavaScript packages in the world, and basically required for modern development. But I can't control what subdependencies _they_ use. https://github.com/moxystudio/node-cross-spawn/pull/102 This bullshit? In the subdependencies for eslint. Stuff like `is-number` is in the subdependencies for Babel and Jest. There's just no escape.
Honesty is a better policy. Talk to your prof about the difficulties you are having.
One solution to this is what many of us are already doing: using private NPM servers that fail over to the public registry. That way, you can save all your company's private work and share internally, but with the benefit of being able to filter out problem libraries like the one referred to here. You simply lock the version of the library at the last known good iteration in your own registry, and forbid future access for any internal reference. That will restrict all references, primary or secondary. 
Maybe I should, but I came into this initially planning on using submodules, and everything I read and heard suggested I should be using NPM instead. But it's turning into frankly a nightmare.
If you bother to read that thread, it’s dedicated to showing why composer is better as a platform in basically every way when compared to npm. 
guys, I've made some fixes based on some feedbacks and finally put some autoupdate, so you can get the future (and better) versions of the app. If you want, you can download it here [https://github.com/davicorreiajr/spotify-now-playing/releases/tag/v0.2.0](https://github.com/davicorreiajr/spotify-now-playing/releases/tag/v0.2.0)
We must protect the almighty Express
No it is his fault. He handed the project over to some random stranger without due diligence. This is just irresponsible. And if you read his posts on github following the incident he just sounds like an asshole. 
...but nuget lets packages run arbitrary powershell at install time.
That’s pretty much impossible in node
Just post the exercise :=) 
I guess sooner or later the ecosystem will need per-package sandboxing or it will collapse under its own fundamental flaws.
It’s not considered best practice. It’s just that a random developer created a useful package like nanomatch that is in some big project like Webpack or Babel, and that same developer created another package that does trivial stuff like is-number, and then uses the trivial package in the useful package. Which means it gets lots of downloads, even though nobody actually uses it. It’s not considered best practice. It’s just that a single developer decided to do something unbelievably stupid and now everyone has to pay the technical debt. That’s exactly the kind of behavior that npm enables.
We had our build systems fail last week that WAS shrink wrapped, but it failed anyway due to some code change in some dependency somewhere. If the original source location isn’t there (left-pad), or if the dependency is modified without triggering a new version or a change to the identifier data, and it has a breaking change, your code will still break next time you try to install the dependencies.
Well that’s just it. A good package manager wouldn’t give someone the option to be a fucking dumbass, or at least, they’d try to mitigate it. Such as, not running arbitrary code to be run on postinstall using scripts in package.json. Or requiring that frequently-downloaded packages be verified on owner change. Yanno, basic shit.
I think you missed the point. You _need_ to check dependencies in order to be safe; that's on you and that's how trust works. If that's not feasible, then there is something wrong with the ecosystem. The developer is the last to blame. (Their response, for what it's worth, came before the full extent of the exploit was known). An analogy: when the bank hands you a stack of cash, you don't need to count it - you trust them. When you sell your car to a stranger and they hand you a stack of cash, you count it. If you don't, and you get screwed later, you can yell and holler as much as you want, but at the end of the day it is your fault for not doing your due diligence. In a professional setting, the blame lies on you. All of us developing that use NPM are accepting an inherent risk when we don't vet our packages. Most of the time it is fine, but if something goes wrong it can be catastrophic and it is on us. 
I suppose we both can agree that the current state of the Node/NPM ecosystem is really fucked up. I mean, the developer of Node did apologize for allowing NPM to establish such a foothold in Node.
I've published packages to NuGet several times, and a couple times handed over maintainer-ship to others. It's no different, really. There's no review process on NuGet and anyone can install your package without first reviewing it.
Yeah, it searched for a particular npm module that uses `copay` and checks for a particular description string. It will then go through the affected host looking for bitcoin wallet private keys in hopes of stealing bitcoin.
The affected software had a package-lock.
Cool cool. Sorry if I seem agitated. It's important that the web gets better and this is an easy win if all developers understand it.
This guy open sources. 
I think a better bank analogy is you count the money (I mean, I do! Some tellers encourage it), but I don’t verify that the bills are legitimate, I trust and assume they are. Same from getting change from a store (usually these days I get change FROM US$20, and its been cost prohibitive to counterfeit small bills, so I can only get counterfeit from a teller or ATM)
Then you didn't do your due diligence in investigating that dependency
It is not any different.
I didn't miss your point, I agree with you, to an extent, but what you're asking is not feasible due to how the node ecosystem works. You're right, it's broke, do an \`npx create-react-app hello-world\` and pop open \`node\_modules\`, you're going to tell me as a developer I'm suppose to carefully evaluate each and every one of those dependencies (1012 at the time of this writing)? This is an asinine ask not only for the sheer amount of time it'd need, but incredibly unrealistic due to both developer skill level, and needing to have an expert level ability to analyze many different forms of coding style. What are people who are just starting to code supposed to do? I feel terrible for anyone who happened to pull this dependency and get their bitcoin wallet stolen just because they wanted to learn some NodeJS. &amp;#x200B; Your analogy is also wrong in this case. It wouldn't be like going to the bank, and not counting your money, it'd be like going to the bank, getting your money, counting it, then finding out some of the bills are counterfeit because the bank didn't have proper controls in place. &amp;#x200B; There's a reason why companies like Red Hat exist, they \_do\_ carefully evaluate each and every change that goes into their Linux distribution, what you're suggesting is akin to doing what they do, but for normal everyday development.
 Can you honestly say that you have investigated every single **minimized** line of code you’re including in your project?
If you just have some JSON files it really doesn't matter if you use one or the other.
The only way to escape it is to move your own projects to dependencies with less dependencies themselves. But at this point there are pretty much no options for frameworks and other important dependencies. Even small modules for connecting to different types of databases typically take a lot of dependencies. Honestly some sort of system / badge that shows you have zero downstream dependencies could be really interesting. Yeah, it'll be some rework but a lot of these small modules are worthless anyway. But I dunno that it would ever fly in the JS community.
&gt; how would using .NET be better? So far it seems like nuget is working more similar to Java; dependencies are coming from trusted sources with lots of functionality versus the current way npm is used with tons of small packages from varying sources. Nuget can certainly hit this same issue but so far it seems far less likely to me.
I misspoke. npm should manually ensure that the transfer of the package from previous owner to new owner is in the best interest of the ecosystem as a whole, for sufficiently popular packages. npm should not run arbitrary postinstall scripts. Period. It’s bad and insecure by definition, speed of the ecosystem be damned. It’s one more command for the developer to run manually, perhaps not even that if packages don’t depend on node-gyp. It’s not negotiable. People use postinstall scripts to scrape lots of things off of machines, not the least of which is environment variables. There’s plenty of other stuff that can be scraped too. It’s insecure and should not happen.
Bahaha, I used the exact same argument in my reply to this post.
The malware was in the compiled version, I am guessing in the npm registry. 
Absolutely not, but that doesn't make it *not* my fault were something to go wrong. It's still my responsibility. If we want to shift that responsibility towards maintainers, we're likely going to see less open sourced libraries made available.
Well I’ve learned some things, it’s not that I can’t do it, it’s more so I want it done well but yes you are right I guess. I think programing is more of a just do and learn to understand . So far we have only done like 2 things. Now if we had done 100’s of example this would be fair I suppose. They’re pretty someone exercises I suppose. I talked to my professor and he showed me how to use the debugger in chrome a bit. Very helpful. Ima just attempt to do em and when I get stuck post of the learnJavaScript for help.
holy fuck that's way worst.
Search npm with "zero dep". You'd be surprised. 
Oh hey, just wanted to check in with you because you posted on r/the_donald about how 2018 was going to be an even bigger devastation for the left...I just wanted to check in to see if you survived the crushing blue tsunami okay? Do you have enough tissues?
By that logic, it's just as much your own fault for irresponsibly using software made by a stranger.
I don't think so. I think you need a different development culture entirely in the JavaScript ecosystem if you want to avoid things like this. Rely on bigger, more trusted modules and less on tiny ones that get toss into projects that end up being a dependency 15 modules down that no one notices. It's not a simple fix.
It’s mostly that npm clearly has no fucking idea what they’re doing, and really never did to begin with. They were just in the right place at the right time and momentum carried them from there. I’d prefer to have an open-source foundation a la Apache running the central registry, but if Facebook could run a registry better than npm has, I’d be all for it.
Same with pretty much any non-controlled package manager. pip, gem, composer, etc..
are you insane? have you ever opened your node\_modules folder? there's thousands (if not hundred of thousands) lines of obfuscated code in your average project. what you're proposing is beyond ridiculous. 
It's a spectrum of risk, not a binary trust or distrust. &amp;#x200B; npm is such a brilliant attack vector. People often run it with elevated privileges. You can furthermore get that code to not only run on a developer's machine, but users machines. It's an incredibly low effort way to get what is essentially voluntary remote code execution. &amp;#x200B; You're not wrong that there certainly exist vulnerabilities, ranging from unknown and undiscovered, to known and nefarious, in all layers down to and even within the silicon. At some point you have to trust third parties. &amp;#x200B; What it's not right to do is shirk any responsibility because it's not a perfect system from top to bottom. You can't say "well my router might be backdoored by a nation state so I'll run anything on npm" as these two things aren't in the same realm. &amp;#x200B; You need to take responsibility for your own code, your bosses, your clients, and the users. Making judgement calls on external dependencies is one of these things.
Dunno why you're getting downvoted, it is simply ridiculous to imply that a startup development team of three bros right out of code camp are going to usefully vet hundreds of thousands of lines of dependency code. Guess the only solution is to reduce the amount of dependency code and make it easier to vet.
They're all `devDependencies`. But `babel`
Which is another reason why replacing npm, Inc. is a good idea -- they're the ones who wanted tiny modules from the beginning.
Makes sense, do you plan on removing Babel?
TS is a superset of JS, so all valid JS is valid TS. It won't throw any errors or warnings, unless you enable strict checking options. 
&gt; maintainers that are so flippant to their responsibility to act in good faith they have no responsibility whatsoever. the license that everyone who usies this software agreed to states this. the people using this software assumed the risk of using it when they cloned it. regardless, releasing a piece of software does not bind anyone to any kind of responsibility you think they should have. the level of entitlement of some people. it's mind boggling how much some people think they're owed.
If Node had more in its stdlib, OR there were one widely accepted as the standard, I doubt these things would happen. I know people here probably aren’t big fans of Dart, but I’m going to use it as an example. It has a packed stdlib, along with dozens of core packages directly maintained by the Dart team, so it’s less likely to depend on a random third party lib, which may or may not have a backdoor. Obviously it’s possible, but JS projects usually have dozens more dependencies, and a backdoor is possible in any of those dependencies. Same goes for Java - it’s got a lot in its standard library, and many widely accepted libraries (i.e. Apache Commons, Spring, etc.), so this doesn’t happen as often.
[https://github.com/aditya-r-m/twisty-polyhedra/pull/2/files](https://github.com/aditya-r-m/twisty-polyhedra/pull/2/files) Finally I've got started with the dodecahedral puzzles. Will update you once it's finished. It sure is a really beautiful shape!
Legal responsibility no, that’s what the license protects them from. Social responsibility, tons, and last I checked the guy has a very popular library that the community uses. He owes the community some gratitude for using his library, because you can be damn sure he has used the popularity of the library for personal gain. This whole argument that he owes the community nothing is tiresome and played out. The guy screwed up by handing off the repository to a nefarious party, yet somehow we should be thankful for what he has done and just take it? I don’t think so, that helps no one.
If you can be sure that you'll only have one space between words, this should work: // Regex: /\s(?!\w+")/ 'this is a "test string" for "testing reddit" hello'.split(/\s(?!\w+")/); // ["this", "is", "a", ""test string"", "for", ""testing reddit"", "hello"]
yeah, that’s the point, to reduce work input to get the same or better output
Someone recently asked that question here: https://www.reddit.com/r/learnjavascript/comments/a0c5ue/learn_javascript_with_prior_programming_experience/
I feel like we're saying the same thing - it's infeasible to check every package, the system is broke. But my firm is developing software using npm for our clients. If something goes wrong, who's fault is it? Ours. That's the point I'm making. If people are paying you to develop software (I assume many of us are here in a professional sense) you are responsible for the output.
This.
I've said this dozens of times: NPM encourages sloppy coding. The mindset of "I can code a fully-featured XYZ in three lines! ... if I only include 200+ dependencies that I know practically nothing about" only guarantees the growth of this sort of stuff into the foreseeable future. It's also a symptom of the Big Problem™ facing JavaScript coding these days...
Hey! Thanks for the encouragement! I learn a lot from Brad Traversy's tutorials and he's been a big advocate for learning &amp; building with Vanilla Js before using libraries, so I suppose I have to thank him for that.
We can be angry, it's just not productive. 
Thank you ! I didn't know about the courses on udemy, I bought a full JavaScript course and a C# Unity Game development course. I plan on learning JS even if I won't immediately use it for web development, learning is never bad I guess.
CAN WE HAVE AUDITED SECURE PACKAGES, AND ONLY ONE FOR EACH FUNCTIONALITY?
Where on earth do you eork where senior developers are learning how promises work and one line of code a sprint is successful? The good senior developers I know write a lot of good code. The idea that you barely produce code and that’s somehow a goid thing is crazy.
Among other things, makes it easier to do isolated UI testing (e.g. screenshot diffs). Which is exactly what Chroma's [main product](https://www.chromaticqa.com/) uses Storybook for. [OP's product](https://percy.io) can also integrate with Storybook and does the same thing.
We need a "Chain of Trust" mechanism in NPM (and other package managers). This way you could configure NodeJS to only run packages with a certain trust rating (Cryptographically signed, of course). 
This is a much more efficient way of mining.
And leaves you invulnerable when a later patch introduces a bug or malicious intent. You are already reinstalling packages to get updates with the semvar, so if that's what you're doing, exact packages won't stop you.
How do you build an npm proxy? (Don’t say ‘node + npm + couchdb’...)
Yes, but only if you use `npm ci` instead of `npm install` to install your app. Otherwise, npm install blindly updates your lock file. When first implemented, package-lock.json did nothing to actually help produce reproducible builds. 
I'm not sure what this means
but why?
You buy one. We use artifactory. On another note..... I'm not sure this approach described works. The reason is due to the inherent dependency tree most popular packages have. Locking a version might work for your libraries, but the result is that you then cannot use the latest version of angular or something else as they depend on a newer version of the locked package
Did you read the article? Here's the TLDR - Serverless Deployment (single file, ~x35 smaller distribution) - Faster Distribution - Faster Bootup - + more
That's reliant on every package you use doing the same thing. If a sub sub dependency is flaky this won't guard you.
dafuq is this "serverless" bullshit I keep hearing about.
a literal is an object you literally write, as in `{a: "b"}`. a literal is not a variable or a return value.
I think a problem is that npm updates are built with hotfix in mind. Dependencies are immediately updated. Instead, whatever the version bump, there should be a buffer between release and widespread use. Something based on time and community vetting, maybe. But something that is unavoidable would mean a lot.
Damn. We use that in some repos.
This is akin to the US housing crisis, where consumer home buyers are part to blame. Tough crowd, good luck getting an ear.
A silly dev parody (about the joys of using 3rd party stuff that I’d written a while back) for 'Judith' (APC) :p You're such an inspiration to my boss After your sales pitch last week Oh how I wish s/he'd read the terms of service Before contracting us to you... Fuck your cloud Your file size Limited Took what code we had and Spent a whole day Still we pay, anyway Never pushed our app through Never thought to question why It's not like you have someone It's not like you can get admin to put it back online We paid for one that shuts our servers down at the peak times (dropping packets like it’s hot) There's nothing you can do Oh so many days I've spent to try to tell you...how to fix the exact same issue... For a price, upgraded cloud Still not getting through Never takes, always breaks Even though I I'm still on the Support line with you You can’t even tell me why It's not like an in-house one It's not like we can reset with hard reboot to fix this time We got it all set up and then they changed the API There's nothing you can do
senior developers spending all day reading about promises? lol.. I'm the most senior dev at my job besides the IT director himself and I dont doubt I would be fired if I only wrote one line a day. there are exceptions.. today I spent most of the day curating data for a project. still wrote a few dozen lines to test it though.
Writing a few code and suddenly shitting out a big corporate-level web app is beyond crazy. While it is true that experienced programmers will write shorter code to perform the same task compared to juniors; shorter code isn't representative of skill level. I'd prefer a longer readable code than a painful one liners that looks like ancient Egyptian writing.
Sure. That goes for carpenters too. I'm not being sarcastic here. But there quite a few people who imagine programming being this easy money gig, spoiler alert: it isn't. 
Sounds like their senior devs are slacking off by the sound of it haha
We use Verdaccio at work, it is pretty easy to set up. https://github.com/verdaccio/verdaccio
Yes sadly it is. I know there is no way we can inspect all of the node modules we download but that's the sad truth. It is our fault. We willingly downloaded a package without checking for it's content. 
That's because jQuery is outdated and irrelevant. Your wasting your time on it. Not joking. And it was made irrelevant not by vue or React, but by es6. You have the right gut instinct.
No, it doesn't. The top responses to the question suggest that one uses Satis/Toran to prevent unpublishing/hijacking, which is essentially the same as creating managing your own NPM registry. Package managers are inherently insecure. 
Are you willing to share more about your company? I mean if they need full time JavaScript then they must be adaptable enough to use it vs legacy apps in java or .net as an enterprise.
&gt;This wouldn't be an issue if people shrink wrapped their code. Yes it would. It's just as easy to shrink wrap a but/vulnerability/crypto miner/nefarious bs.
Yes, the universe works in black and white, and complexity is an illusion. Of course, it's *somebody's fault*, always, because you can expect a little bit of godly perfection! Note to parent: It's not about this or that problem. Yes, for single issues you can expect perfection and assign fault. The issue is: THERE ARE MILLIONS OF THOSE. A human has to juggle an unmanageable amount of all kinds of issues. The problem is not that any one issue could not be solved, the problem is the never ending stream of issues and that they are connected. The difference between "complicated" and "complex". No it is not too complicated to check dependencies. And yet is is completely unfeasible except for few individuals. If everybody actually did that we would see **big** consequences elsewhere!
This is the best solution, honestly. Packages needn't be completely dependency free but there ought to be a depth limit to it. 
I believe Ghost CMS is written in Javascript 
who is this penguingspe asshole who keeps shit talking without research?
It is open software, so you can install it on your own server at no cost. You're only paying if you use their hosted version. 
It's not just about inserting evil code into a production app; devDependencies can run code on developer machines, e.g. to steal the keys to crypto wallets on your system
That thread absolutely shows that Composer is better than npm in every way, shape, and form. I honestly don't know you can read through that thread and come out having any other opinion. Top comment: &gt; Deleting popular repositories is intentionally disabled - see this comment from 2014: https://github.com/composer/packagist/issues/115#issuecomment-37274264 &gt; It is possible to delete a package when it has only a few downloads (I don't remember the threshold). For packages with a lot of downloads, there is no button to delete it to avoid mistakes affecting lots of people &gt; Instead, maintainers would use the "abandon" button to mark the package as deprecated. &gt; Now it could be possible for the maintainer to delete their repository from Github, but the Composer cache and Toran Proxy can mitigate that damage. &gt; Because repositories cannot be deleted, they therefore cannot be hijacked in the same way. &gt; Additionally, Packagist will reserve namespaces, preventing other people from releasing packages under a name/organization they really aren't. Packagist stopped big packages from being yanked from the registry as far back as 2014 (Composer wasn't released until 2013 and didn't get a stable 1.0 release until 2016). So the left-pad incident simply never could have happened on Packagist, because Composer's devs actually had the foresight that maybe, one day, a developer would get pissed off for one reason or another and yank a big package from Packagist. Of course, packages can be deleted if they have fewer than 100 downloads, but it's better than nothing. npm didn't implement any such thing until after left-pad had already happened, in like their v4.0 release. If you bother to take a few minutes to read the second-top comment, you'll see that the recommendation to implement Satis/Toran follows about three layers of redundancies: 1. Big packages can't be yanked (big one) 2. If the GitHub repo for a package is nuked, the source files are cached and can still be downloded 3. `composer.json` can point to other registries as well The commenter adds that, if you want to feel completely safe, you can set up Satis/Toran yourself, but he implies that it's probably not necessary unless you want to be sure. Of course, npm offers all of that protection *now*, but it didn't offer it when it was needed, and it's always been reluctant to add features that developers need while enabling rogue developers to harm the platform. They've demonstrated time and again that they lack the expertise to serve the JS ecosystem. So no, composer isn't perfect, but I never claimed that it was. I simply claimed that it was better, and it clearly is.
Why pander to a shitposter?
cool i suppose i could see the upload in the devtools, and see that it appears encrypted -- however, i wouldn't be able to see whether or not you've compromised the clientside encryption mechanism by tampering with cryptojs in the minified bundle to feel safe, i suppose we'd need the frontend project on github, so we could run our own build and ensure cryptojs is being used properly, and then could compare the javascript bundle with what's on your server as a side note, you might be interested to look into the browser's web crypto api, i wonder if it might have better performance than cryptojs i started writing a little instant text encryptor app some years ago but abandoned it --- https://pastesafe.github.io/
&gt; The same concept is valid for infrastructure. In the moment an organisation move away from having an infrastructure team, a DevOps culture is needed in teams to take care of infrastructure operations on their own. ^ this quote of yours really helped me understand what you mean — i dig it!
404
The TypeScript compiler has no runtime dependencies. A fresh install shows this: λ yarn add typescript yarn add v1.12.3 info No lockfile found. [1/4] Resolving packages... [2/4] Fetching packages... [3/4] Linking dependencies... [4/4] Building fresh packages... success Saved lockfile. success Saved 1 new dependency. info Direct dependencies └─ typescript@3.1.6 info All dependencies └─ typescript@3.1.6 Done in 0.57s.
Agree totally. As for your car example, not only are you trusting other road users, you are trusting the manufacturer, their contractors and likely entire layers of sub contractors, the companies that actully made the raw materials and even miners, smelters and transporters as well as the garages you use and the previous owners, and then you have to trust that someone from outside the direct trust chain hasn't interfered at some stage by jumping over the factory fence or something. You put your faith in tens of thousands of people any time you go anywhere near a vehicle. And checking any of it is virtually impossible even for the owner.
Yes recently I also use Jest, but I figure this is one of the few blogs which didn't outdate over time and technological evolution. This tells me Jasmine and mocha are both pretty well designed. Same as Jest which follows many of the same concepts.
I admit it, that does sound much better than npm. At least in the case of unpublishing and republishing. Not sure if it would've helped in this case (handing over package rights to someone else), which is a lot more harmful, imo. But yes, you are right. Composer is better designed.
Gotta live misinformation in these subs
Not a Bitcoin miner, it just steals the keys to wallets with coins in them already. Even criminals are too lazy to mine coins. 
Classic...
Right but that would be mean writing out all the different expected result from that data. 
Ah. I've worked on a project with someone else's paid version. Didn't realize it was open. Thanks for clarification.
You need some more npm packages to inject backdoors in or give to other maintainers to include crypto mining and key stealing. #toosoon? 
Ah--that's not what I mean. Those are useful tools for trying out JavaScript and so on. But they don't teach you anything in themselves (unless there's some new feature to jsbin I'm unfamiliar with). I was referring to actual tutorials that walk you through how JavaScript works, while asking you to to write real JS code to solve simple problems. This helps with comprehension, and shows the system you understand the current part before moving on to the next. I'd recommend looking into [Codecademy.com's JS course](https://www.codecademy.com/learn/introduction-to-javascript), for example.
Unless you shrinkwrap the malicious code. Still not sure how this is useful advice that gets repeated in this thread.
You _might_ want to post your code on a gist or pastebin, or even on CodePen, JSFiddle, etc. I mean, one can read the problem on Codewars without even registering, but reading your solution requires registering **and** either solving the code first or discarding the chance to solve it for points. Which, I know, doesn't sound like a terrible problem. But, well, if you want people to look at your code, you might try to at least make it as easy as possible :) 
&gt;1).5/730000 means we have proven that 99.999% of packages are trustworthy. Terrible math. This dependency, by proxy, made it into nodemon, which gets a million downloads every week. Millions of projects could run malicious code (at least if the exploit wasn't found so quickly).
For instance, when you deploy electron applications there's no easy way to bundle the backend-process, usually you'll just include node_modules as is, which can easily blow up your binary's weight. Electron is big enough, but it makes a difference if the application you ship is 100mb or 150.
Sure, but how can you make any assumptions about the security of your system if you don't even know what's ***in*** your system? Did you validate all the packages in your `node_modules` folder? Can you trust any of them? How can you be sure? How can you be sure a quick `npm update` won't install a crypto miner, or install a backdoor, or ..., or ...? In the end, you're running untrusted, unvetted code from the internet. I'm doing it too. In fact, it's an industry standard to do so. I think the only way forward is to either always run any code that depends on npm in some sort of `chroot` / container environment with strict limits on computation power and hardware / network access - that would be the technical solution - or to introduce a security vetting process at npm, so that you have a separate class of "trusted" packages, and each minor and major update would be marked "unsafe" until it is signed off - that would be the social / procedural solution. Choose your poison. I think the ball is in npm's court as it's clear that the current ecosystem is basically completely untrustworthy. There's no safety or security guarantees - at all.
Legally you can't sue the maintainer. It's in license. Also, when you buy a car and its faulty you don't go suing the engineer. You sue the corporation that sold you the car. No one sells you a node package. If you bootstrap a product with foss code and go profit, and later it turns out to be vulnerable, it is your fault. 
Hey kids! Stop blaming the dev! If your car turns out defective who do you sue? You can't sue the engineer or the security guard at the factory. You hold the manufacturer responsible. Even if the security guard was asleep, it is still the responsibility of the company who made the product. Blaming foss devs is weak sauce when we all build our careers on their work. If we lived in a world where they were responsible every time a server got hacked there would be no foss. You noobs make me cranky.
The solution to end developers is to realise that they're trading on hidden risk when they subsume X many different open-source projects without minute consideration of their sources and composition. As the number of 3rd party packages contained in your `node_modules` folder increases, so does a correlation with the risk that any one of those could be ill maintained, cause huge bugs, or even go rogue as in this case. The days of "everything open-source must be pure-of-heart and beautiful by definition" are slowly coming to an end. Of course, it would be nice if library developers sucking in dollops of helper modules would also learn the same lesson, but we all know how good humanity is at pre-emptively learning lessons.
Believe it or not, it's the only dumpster fire most of thevs here know how to cook with.
In many cases you can create a solution to your specific problem in a much easier way.
Seriously... That dude is the problem.
Would this work with conditional or inline require() calls? E.g.: async get_view(view) { const ViewClass = require("../../view/" + view); let vc = new ViewClass(); ... 
Thanks for the response! I'll get Max's. &amp;#x200B; I'm doing React Mead's at the moment. It's very good but super super thorough.
r/KenM
Are you aware of a similar event that happened with other dependency managers of other programming languages?
[https://github.com/malithmcr/react-php-contact-form](https://github.com/malithmcr/react-php-contact-form)
Do not use webstorm when there is useful alternatives (vs code, atom) idk why but people in Intellij doesn't know how to optimize things. You give it 8gb ram and i7-6700k,type one word and %600 cpu very nice.
&gt; Well, honestly, it's the original maintainer's fault. He just handed over the keys to the kingdom, Not even remotely. It seems like a lot of people who have never maintained a popular library keep saying this. When you don't want to maintain a library anymore but someone else does what exactly are you supposed to do??
I didn't know this library and I think is very good! Thank you for sharing!
You can do the same in node though... there are plenty of frameworks sponsored by big orgs that will be just as secure and provide you 99.99% of what you need. My last org used spring + mvn and the security controls we had there are the same as what we are using for node.
&gt; That's what figured op is referring to. Correct. 
No. Here's my own personal optimized™ webscale™ RFC 1149 compliant™ 100% coverage™ version of `lpad` that completes two operations per second more than the reigning™ standard™. Oh, that string in the source code that looks like a Bitcoin wallet address? Reserves more memory for more raw processing power. Don't worry about it.
Javascript desperately needs a standard library.
Every single line of code in any project is tech debt. What I said was _external_ tech debt.
&gt;Didn't realize it was open. An easy mistake to make for that direction: many open projects with paid hosted services attached don't shout about the self-hosting option on their main pages for obvious commercial reasons. I don't have a problem with this as long as the other option is not deliberately hidden elsewhere. The Ghost docs have what looks like a fairly complete install/build guide, if you want to give it a shot: [https://docs.ghost.org/setup/](https://docs.ghost.org/setup/)
Pretty much every language I can think of has a standard lib maintained by a core team (except JS of course)
Pass it over to someone you can trust? If not, put a message in the readme and archive the repo. Possibly link to the a newer package, otherwise if consumers want a newer version they have to go and find it. &amp;#x200B; What you don't do is hand the module over (with all the people who depend on it) to someone you don't trust.
There are many free and great resources, where you can learn JavaScript. To websites mentioned earlier I would add [http://www.javascriptinstitute.org/javascript-tutorial/](http://www.javascriptinstitute.org/javascript-tutorial/) You will find there info about many JavaScript topics.
OK first of all the attacker was contributing for months with legit pull requests. That's why he got access first, so who could predict such behavior afterwards? Second of all you should realize that this is OSS. Yes it is easy to point at someone but don't expect first-class support or maintenance for free software. Read the thread of André Staltz on Twitter, I mean the guy was maintaining 700+ packages 
The next Wordpress won't be Wordpress written in a different language - Wordpress didn't start out as exactly what it has grown to become. The next big thing in that space will be a project that offers something different to Wordpress that enough end-users want - something than answers the "but why not Wordpress?" question with something other than "it isn't written in PHP". Ghost is definitely an option here: it started out with a deliberate aim of providing something specific rather than just replicating WP, the key benefits over WP being that it was to be much lighter for specific jobs at the defecit of not being able to do everything that WP does. See [https://www.kickstarter.com/projects/johnonolan/ghost-just-a-blogging-platform](https://www.kickstarter.com/projects/johnonolan/ghost-just-a-blogging-platform). It hasn't taken over the world though, partly because of inertia: for most people WP does the job, they are in at least some small way familiar with it, and is well known enough that they feel they'll be able to get support easily if something goes wrong. There are a few others out there too. I suggest being warey of any project that sells itself primarily on being written in a specific language (unless your intent it to tinker with the internals and that is your language of choice, of course), \*not\* being written in a specific language (not that nasty PHP!), or not being WP (though comparisons to WP and other products are fine if written well, as they can give good context, as long as that isn't the main thrust). Look for projects that give a good answer to "who would/should want to use this and why?" rather than concentrating on "hey, it isn't something else".
Well someone didn’t read your whole post...... :)
I like tape
You're describing a world where open source could never thrive. Projects simply die when the maintainers get tired. Not everyone has a large network of developers they trust and even if they did who's to say that developer has the same standards of trust. 
There are some packages that are de-facto standard. For example, lodash for collection utils, moment.js for dates or express as a web server. But sometimes you can’t really define big chunks of functionality that should be distributed together. Then you end up having small modules that their authors found worth enough to publish.
They’ll probably assign a week long sprint for the refactor because, “it’s not a feature”
how about podcast? [syntax.fm](https://syntax.fm) is fun and learn 
B&amp;E is just Prospecting
oh fuck off I mistyped who cares
A. You can do this and have this still happen to you, if a trusted dependency uses `^1.x.x`, for versioning a transitive dependency, and you do a fresh install, it’ll pull that dependency that might have a problem with this attack vector. You’d need to be hyper vigilant about looking over `package-lock.json` for any new projects and make sure they match the known state you are hoping for. Doable, yes, annoying, yes, automate-able, absolutely...will everyone do it? Highly doubt it. B. This is a bit of a straw man argument, of course you don’t trust everything out there. At the same time you need to be productive and can’t reinvent the wheel for everything.
Post exercise, Tell what you dont understand
You have an inherent responsibility if you have created a product used by thousands.
You can use an Axios request with a cancellation token in `componentWillUnmount`. https://github.com/axios/axios#cancellation
Bro just grab the npm package for it
Thought you have to cast it to an array first 🤔
* An object literal is syntax (e.g. `{foo: 123}`). It produces objects at runtime. * An object is an ordered (by insertion time) set of key-value pairs. * The ECMAScript spec has the internal property `[[Prototype]]` for the prototype chain. `__proto__` is a getter/setter for changing this internal property.
This one if the reasons I live typescript. JavaScript for grown ups.
If you need to support older browsers you have to, but otherwise the Nodelist class implements a forEach() method itself. https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach
Drop the idea of dependency trees from NPM, or allow running NPM in a mode that will attempt to flatten the tree. Granted, 99% of NPM packages won’t work in this mode but maybe that’s what it takes. A dependency tree is very convenient, but it also allows devs to ignore or forget the hidden costs of dependencies. A lot of node devs seem to have the idea that dependencies are a no-cost solution to a problem and thus use packages for the most trivial of problems (see the “left-pad” debacle, for example). A dependency list makes it harder to introduce dependencies since the versions of all transitive dependencies need to match. However, this might actually be a desirable property because the current model of easily being able to add dependencies is obviously broken.
Ah that’s right but not map (which makes sense because you’d get a different structure on the other side than you started with)
Shopify. And your question is why people don’t respect JavaScript. So get your lazy, no coding ass the fuck outta here. 
I’m ashamed to say it took me way to long to realize this was fictional.
Why so mad
how do you know which are the last known good versions ahead of time?
You don’t work with me do you? Lol
Agreed, especially considering that many of those apps are still interfaces to an API. Sort of desktop based web apps.
Haha, I had a few edits to it, might have been added while you were posting. /shrug
It's very easy to sit in an ivory tower and look down on people, but many people are faced with implementing stuff that they simply don't have the time to do or learn how to do and possibly no support from their workplace to develop own libraries.
I’ve worked for large companies that are very concerned about security. What would end up happening in practice is that you’re forced by corporate mandate to stick with that old version of (to use your example) angular until it, too, has a vulnerability exposed. At that point, angular becomes Not Approved, and you have to wholesale switch to something else.
the senior guys like to research technology and integrate it into their lines of code, while the jr guys rely more on for loops and if statements to make their logic work 
Yes, to the extent that you need/want test conditions. There are tools/techniques you can use to easily capture that data to help creating mock data. The benefit to using mock data is that you are able test your business logic in isolation and your test doesn’t break if the data changes.
Yep.
I feel that the Node Foundation should provide its own package manager and registry. At this point, NPM is essentially a core component of the Node ecosystem. However, it's a commercial private endeavour, and that feels inappropriate. Parts of the service will likely be designed with profit in mind, rather than simply trying to provide as much functionality and usefulness to the community as possible. In the worst case scenarios, there could be significant disruptions to service, or even a complete shutdown. It's pretty problematic.
So... Basically something even worse than mining.
Good point; that also usually works well.
Or this. var s = 'this is a "test string" for reddit'; var res = s.split(/\s+"?|"\s*/); console.log(res);
There aren't perfect solutions, there are only trade offs. You've pointed to one shortcoming of small modules as proof that it is the worse of two evils. I could rattle off a list of issues with large monotholic packages just as well; however, I'm sure you get the point. Moreover, it was never my impression that the "early npm" culture didn't understand the pros/cons of small modules. They chose to go that route because it was in the spirit of node's small core. Moreover, the size of the package is only correlationally related to how unsafe it is. In principle, it should be easier to spot vulnerabilities in small modules. The actual issue is that the package only had one maintainer. Packages maintained by multiple people are less susceptible to bad actors.
I love how we all mindlessly install software written by random people without paying them or contributing in any way whatsoever and then complain when things go wrong. Open source maintainers don’t owe you shit. It’s *your* responsibility to be mindful of what you install. It’s the least you can do. If you don’t want that kind of responsibility write the code yourself or pay someone to do it. 
When Babel is used during development it still uses their production build. Devdependencies means a dependency used to develop Babel itself, not to use Babel. 
I would, but would you trust my competence and conclusions ? :)
Or you could just hire someone you trust to write secure code? Or pay the maintainers? Or maintain the project yourself? Auditing packages is actually a pretty good idea, but there are less-invasive ways to ensure you have good software. Sadly you’d have to pay up with money or work. Expecting free open source software to be secure without giving something in return is kind of a bad idea. 
And your site's header can be done just as smoothly, with a small $3,000 licensing fee 0\_0
It means that it can "compile" itself using itself and also uses webpack in its internals. The whole thing is basically webpack wrapper.
Is a tl;dr version of this thread NODE IS DEAD?
...so to repeat, why not webpack?
&gt; you can be damn sure he has used the popularity of the library for personal gain. In your mind: i) What is the total value do you think they gained from having a popular library? ii) What form does this 'value' take?
There isn't a culture of thousands of transitive dependencies, so vetting them is possible though. .NET itself has a large stable pool of trusted code, and people don't pull in packages for one-liners.
Manually ensure that an ownership transfer of a package with two million weekly downloads is in the best interest of the JavaScript ecosystem.
People say that, but I don't see how it in any way prevents the kinds of security issues people are running into. I also have to wonder, why doesn't package-lock.json lock versions of transitive dependencies? What is the point of it if it doesn't?
What a joke.
Yeah... the downvotes ... I wish it was fixed. But indeed it is the dumpster fire you know sort of thing ;)
If I ran codewars I totally would, but I don't know their policy on cheating. If your eager to review some code, [I cloned minesweeper](http://www.darksweeper.com/) in my quest to learn react. The Github link is at the bottom of the page, I'd appreciate any feedback on the game or the code. If you could even try to hack/break it somehow that'd be cool lol. There's a hiscore leaderboard that is probably very hackable.
Resume builder, easy talking point in interviews, pull and influence within the node community itself. Any of these can easily lead to speaking engagements for money, better paying jobs, etc.
The one I heard (before node was even a thing AFAIK) is: Pick a random word from the dictionary. Google &lt;word&gt;.js. If it's a JS library, take a shot. Last one to the hospital with alcohol poisoning wins. 
Ahh gotcha, that’s an impressive amount of time saved installing 
So you added tests, code cov...? How long it took you to do that? In a new project, you will just copy paste again? If there is a bug in one version, you need to remember to fix all of the copy paste code. 
The more dangerous game would be that you need to add it to your project and see what happens.
If build tools had a reliable way to do dead code elimination then a standard library could be developed.
Sorry, that’s nonsense, it’s a simple case of economics. He benefitted in some way, it may not be cash, it may not be prestige, it could be just personal satisfaction. But does he owe users gratitude? Did they give him charity by using his library? No! They obtained a benefit from using the library he wrote. The transaction had benefits on both sides, that’s why all the parties entered into it. Now what about obligations going forward? By default, obligations going forward are very messy, expectations can vary. So what do we do? We put those obligations in writing in the form of a license agreement. If it’s not in the license agreement that he will take responsibility for the library in perpetuity, including responsibility for anyone assuming control of the library, *there is no forward obligation*. If you think there is some moral obligation above and beyond whatks in the license, it is incumbent upon you to demand a change to the license agreement. Itks literally in black and white. We are not talking about multinational corporations using lawers to screw ignorant consumers here, we are talking about individuals engaging in transactions governed by a clearly written agreement that has been discussed in public at length for literally decades.
Boom. It seems like most people don’t want to admit it, but it’s actually the package consumer’s fault. We are responsible for the dependencies we install. 
Nope. Read the license: &gt; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED There’s no such thing as “inherent responsibility”. It’s explicitly stated in the license. 
He literally maintains hundreds of modules. Lots of them with 1M+ daily installs. I have never maintained a single popular project but I imagine it gets pretty fucking stressful when you have dozens of them.
React and to a certain extent vue has won the Silicon Valley and Shenzhen cutting edge dev class. The people who have experience doing spas from the backbone and knockout days and have seen it all have anointed those two as the better way. But that doesn’t mean angular isn’t still massive among the general populace, a legion of developers whose framework choices are determined by brand name and business managers. They create huge amounts of code that is maintained by an even greater mass of third world outsourced workers. Angular is still popular for that demo.
I use greensock for animation.
&gt; Resume builder, easy talking point in interviews, pull and influence within the node community itself. Those are things that are rewards from doing the work, not from having people use it. &gt; Any of these can easily lead to speaking engagements for money Do you have experience of that? Or are you making an assumption. Because I don't know of any conferences that actually give a crap about what people have programmed in the past, they are only interested in what you can talk about. 
Um, I haven’t said he owes me anything I said he owes the community the respect of owning the problem he caused. We can talk in hypotheticals all we want about what I gained versus he gained, whatever, the fact of the matter is he messed up, and he has an utter disregard for the problems he has caused. I think you are downplaying the owner of a repository that has 2 million downloads a week. A simple google of Dominic Tarr talks shows you how active he is on the JS talk syndicate.
So Angular is the next PHP. Gotcha.
Lol, brave thing to say in r/javascript; but yeah, it has lots of flaws. Most of them can be solved by adjusting expectations.
Your not obligated for damages that’s the point of a license, your obligation as an open source maintainer (albeit one that is not enforced, obviously) is to report vulnerabilities in your code base with honesty and openness through the proper channels (see: CVE reports) If you don’t want to maintain the codebase anymore, fine, but communicate that to the people using your library, don’t flip ownership on a whim through a random email.
http://lmgtfy.com/?q=Dominic+Tarr+talks
Oh, wait... You made _the challenge itself_; not that you wrote a solution. The different usernames threw me off. Sorry. The challenge is ok, I guess. It looks entertaining. I'm not much into that sort of thing, though.
Nodemon wasn't using the specific part of the package that was affected if I understand correctly so it should be ok (someone correct me if I am wrong).
ah come on you're being harsh... I think you meant to say $2,975
You can also use it for free.
&gt; Every single line of code in any project is tech debt. That's absolutely incorrect. Tech debt is literally any solution which was an "easy" fix, but will require additional rework later. 
I know nothing about this lib, and I haven't even looked at your site. But I'm wondering if `columns` is actually the number of columns *in* the QR code.
Legally, no, but ethically you most definitely do
That sounds like mining, but with fewer steps.
The malicious code was activated once used with Copay lib so 99.5% of users are completely unharmed.
i feel mozilla is secure, it's open source?
that's a different problem. People relying on external packages for even smallest things are sure to get burnt in long run. this problem is you having no idea what is secure big or small.
I’m new to JavaScript and I am currently trying to do a project for an intro level class. My code and it’s output is the picture. Right now we are learning loops and are having a project that is due today. The project is to create a tiny program that has the user input two numbers, a height and a width, this will generate text that will show up like this on the webpage if the user were to put in a random numbers such as “10” and “10”: xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx It is supposed to be able to take any numbers the use puts in and format the x’s based on the number they chose for height and width. My problem is that I have no idea how to get the text to break like that / have it stop putting individual x’s and start at the number the user inputted. Sorry if the code is a mess but I have no idea how to do this. Any advise would be greatly appreciated. I tried looking for help on line but I had no idea how to describe this or if this is even the right place to post this. 
Honestly I think it's more about internal team audit (did any of us ever install this problem package?), but you can also do things like forced delays, so that there is time for problems to be (hopefully) caught before some gungho developer immediately installs the newest version of a package.
Global packages are always available.
[d3.js](https://d3js.org/) is free for anything.
It is. And it's awesome. But remember, Mozilla (+ Mozilla Foundation) is a well-funded non-profit organization. They pay salaries to their developers and contribute to other initiatives https://foundation.mozilla.org/en/initiatives/ Also, donate.mozilla.org, it's a good cause :)
Sounds like a good fit for me then. Have you tried any other React course, such as Grider's or Max's? 
It's really impressive and so close to being really useful but the charts are just so frustrating to interact with on mobile.
Did you read the article? It says directly at the bottom why they opted to create the tool. &gt; How Is This Different from Webpack, Rollup, Parcel? &gt;We wanted to focus on a development experience that maximizes productivity, followed the semantics of the Node.js platform out of the box and mirrored the conventions of other well-designed and battle-tested languages. This means that it should do the right thing out of the box, with no extra configuration.
I got to talk to one of the people working at Zeit at a meet-up a little while ago and he talked about some of the issues they had with deploying Webpack (long build time). They managed to figure out a solution quickly!
I did read it. That paragraph is buzzword city. Does webpack specifically *not* do this? I mean in my opinion it does do this, just depends on your definition of "extra" configuration.
`function Dog(name){` [`this.name`](https://this.name) `= name;` `this.bark = function() {console.log ("woof!") }` `}` `var dog = new Dog("baxter");` &amp;#x200B; a better place for this would be r/learnjavascript but i hope this helps you out
I kept waiting for the header to do something, but the hero section looked nice.
I have worked with those charts for 6 months now .. r/AmA
It lags on a OnePlus3T, you can't reliably interact with it on mobile, and it cost $180 to use ON A SINGE WEBSITE. How about no. 
Up and downsides in comparison to Highcharts and/or chartJS? 
So what should I do instead?
No you can't, according to the license. You can use it on 1 website or any number of subdomains, but not with dynamic content that varies from one user to another. You can't use it in mobile or native apps. Apparently you can modify the software for your personal needs though, so that's interesting. You get software updates, but only for 3 months from the purchase date, and only minor updates, not major version changes. You get tech support for 12 months, but only through email, so that's ok I guess.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [amcharts/amcharts4/.../**LICENSE** (master → 084a3cc)](https://github.com/amcharts/amcharts4/blob/084a3ccf5e59035e56f6fab6f710d1341350a2b1/dist/script/LICENSE) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply eakxytr.)
I had a really smooth experience on Android Chrome. That bar to pie with a slider was pretty impressive!
`&lt;script&gt;` `const greetings = ["hello", "ciao", "welcome", "howdy", "greetings", "salut", "hallo", "hola", "Gday", "Hey" ]` `const randomIndex = (arr) =&gt; arr[Math.round(Math.random() * arr.length -1)];` `document.title = randomIndex(greetings)` `&lt;/script&gt;` this is all just plain JS and will run in a normal script tag; the part you made a mistake on is that you are not setting the html of the title as the title is just a property of the document
Reading the github issue tread is giving me heart palpitations 
I kinda hate working with d3. I've only messed with it a bit but the enter exit and grabbing nodes before they exist stuff was pretty odd imo. I would welcome a more developer friendly experience.
I would personally go with NextJs of Gatsby. Gatsby is a static site generator and is perfect for informational/portfolio type sites and though you can absolutely use dynamic data, in this situation you may be better off using a server side renders application which NextJs will give you. 
Thank you for that. I will add that code to my page to see how it goes. I know some coding but not really javascript.
This is really uncalled for. Also, Shopify is a terrible option if you want to learn how to build an e-commerce site front to back and not just use an API. Maybe take it down a notch there chief. 
&gt; but not with dynamic content that varies from one user to another wut
I’m a huge fan of Gatsby+Netlify CMS Currently redoing my personal site in this
You are talking about single site license, not the one which allows free usage.
...I'm not sure you understand what a dev dependency is. Yes, they're not installed on my machine. They're simply used to build the TypeScript compiler, which is installed on my machine. "Don't worry, no hackers get access to your computer, we only let them write the software that we put on your computer" is 0% reassuring.
hey there! this woud be an index.html file \`\`\` &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;My file&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a class="random-link" href=""&gt;Anchor text&lt;/a&gt; &lt;/body&gt; &lt;script src="script.js"&gt;&lt;/script&gt; &lt;/html&gt; &amp;#x200B; \`\`\` &amp;#x200B; and this would be some Javascript &amp;#x200B; \`\`\` let array = \['[google.com](https://google.com)','[facebook.com](https://facebook.com)', '[reddit.com](https://reddit.com)'\]; let randomWebsite; &amp;#x200B; const randomNr = () =&gt; { randomWebsite = Math.floor(Math.random() \* 3); } &amp;#x200B; randomNr(); &amp;#x200B; const link = document.querySelector('.random-link'); link.setAttribute("href", array\[randomWebsite\]); &amp;#x200B; \`\`
Can confirm, also on a OnePlus 3T
I'm not talking about either of those things. I'm talking of limiting product usage not because of bandwidth of resources, but just because they can... There are LOADS of decent graphing libraries... What makes this one so special that it warrants such a large load of cash to use it?
They don’t want to learn. 
You clearly have no idea wtf you’re talking about. 
Look at his post history. The answer to your question is: Yes, he works for amCharts. [Example post](https://www.reddit.com/r/howyoudoin/comments/91tw8n/oc_who_kissed_who_in_friends/e34bo7p/) &gt; We at amCharts would like to make this chart interactive, any chance you could share data? Thanks a lot!
That explains their ENTIRE reddit history being marketing and justifying it... pffft.... 
&gt;Otherwise, npm install blindly updates your lock file. Only if the lock file doesn't match the package.json. In other words, if you change package.json and then run npm install, package-lock gets rebuilt. Your flexible semver declarations in package.json will not spuriously bring in new versions with "npm install" unless the package.json file itself has changed, either manually or via something like "npm install &lt;package name&gt;" or "npm update &lt;package name&gt;"
&gt; Devdependencies means a dependency used to develop Babel itself, not to use Babel. That's only if the dev dependency is trustworthy. We're talking about dev dependencies that aren't. Such a dev dependency could easily build itself into a production build without anyone noticing.
 &lt;a href="https://www.google.com" target="_blank" rel="nofollow" id="myID"&gt;&lt;/a&gt; &lt;script&gt; const myArray = [ ["google", "https://www.google.com"], ["bing", "https://www.bing.com"], ["yahoo", "https://www.yahoo.com"] ]; let num = Math.floor(Math.random() * myArray.length); console.log(num + myArray.length); document.getElementById("myID").innerHTML = myArray[num][0]; document.getElementById("myID").href = myArray[num][1]; &lt;/script&gt;
* Array index starts at 0. So your array \`greeting\` is, in the end, \`\[null, "hello", "ciao", ..., "Hey"\]\` which is not good (but thanks to your random function, not a problem here); * The Web API's \`Element\` class doesn't have any \`html\` property. So \`document.getElementById("title").html = "greeting\[randomCount\]";\` will add one with the associated value, ie, the static string \`"greeting\[randomCount\]"\` and won't do much with it (no \`set\` function associated). You are looking for \`innerHTML\`. More: [https://developer.mozilla.org/en-US/docs/Web/API/Element](https://developer.mozilla.org/en-US/docs/Web/API/Element) * \`"greeting\[randomCount\]"\` is a simple (static) string and won't be replaced by the picked greeting; * No html node has \`title\` for \`id\` so \`document.getElementById("title")\` will return \`null\`. You want to add the attribute-value \`id="title"\` to your anchor tag; * Do not use \`var\` keyword unless it is necessary (ie, \`const\` and \`let\` don't apply). Here, all your \`var\` could be \`const\`. * Avoid using \`new Array()\`. More: [https://stackoverflow.com/questions/931872/what-s-the-difference-between-array-and-while-declaring-a-javascript-ar](https://stackoverflow.com/questions/931872/what-s-the-difference-between-array-and-while-declaring-a-javascript-ar) * Access your array length property by using \`greetings .length\` instead of declaring a variable; * Do you really know what you are doing by putting a comma at the end of your assignments? More: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma\_Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator); Surprisingly enough your maths is ok. [👍](https://emojipedia.org/thumbs-up-sign/) A piece of advice: use your aforementioned interweb ressource no more. &amp;#x200B; Playground for your convenience: [https://flems.io/#0=N4IgzgpgNhDGAuEAmIBcIB0ALeBbKIANCLAPYB2YpMaJ1UAhgA6QrEBmAljGGgNqhyDXBFrY8BYmXKIZtADxhYAJ05N4APgA65AG4NlAAngAPeAHFlECPE7kA5oYC8hgIwAGANw79R5Q3IkUlwAYVIAVxlnQwBZBngsDGUIwIAKOISkgKDcVIBKQwAqQ1TTCysbO0cAWjc8goBqN289A0N7CtsHaPIIAHdDAEFlfwBPfJaO6y77PlcAXWitECxoKFJlwh0pyoc+ACZFl2XYTgYNom3Oqr4AZiPDZb7oMhFNq+mbgBYH5axSPpIUbvBzXPYAVl+IB2MzAIJhNwAbFCwAwoOF4PCwbMAOxQrBo9ZYz57AAc+OoDGJu1mAE4oeYkAxgZdQSTZh4oQAJCAsrbkHRBWDhEQyDD2GwAURgovgACFRgBJJCpZa2eAwZZ5DB2XrKLkAFRiABkltDsXx-IFgmFIvB5ssWvIAPRKVTqbQC8jyBiGLBWdhOP7weAsVDO524UZgTiIDCvZaGQycJBBkDqzUgYwGCXwNMAfQARoxyABrRNWKBp8ikdj0AHLDSDciwf5GRBmF0MDREcDQOC2Ci8dCuHGodwgAC+82IQhEtAAStlgpwY90O-BDFA7KXeJOgA](https://flems.io/#0=N4IgzgpgNhDGAuEAmIBcIB0ALeBbKIANCLAPYB2YpMaJ1UAhgA6QrEBmAljGGgNqhyDXBFrY8BYmXKIZtADxhYAJ05N4APgA65AG4NlAAngAPeAHFlECPE7kA5oYC8hgIwAGANw79R5Q3IkUlwAYVIAVxlnQwBZBngsDGUIwIAKOISkgKDcVIBKQwAqQ1TTCysbO0cAWjc8goBqN289A0N7CtsHaPIIAHdDAEFlfwBPfJaO6y77PlcAXWitECxoKFJlwh0pyoc+ACZFl2XYTgYNom3Oqr4AZiPDZb7oMhFNq+mbgBYH5axSPpIUbvBzXPYAVl+IB2MzAIJhNwAbFCwAwoOF4PCwbMAOxQrBo9ZYz57AAc+OoDGJu1mAE4oeYkAxgZdQSTZh4oQAJCAsrbkHRBWDhEQyDD2GwAURgovgACFRgBJJCpZa2eAwZZ5DB2XrKLkAFRiABkltDsXx-IFgmFIvB5ssWvIAPRKVTqbQC8jyBiGLBWdhOP7weAsVDO524UZgTiIDCvZaGQycJBBkDqzUgYwGCXwNMAfQARoxyABrRNWKBp8ikdj0AHLDSDciwf5GRBmF0MDREcDQOC2Ci8dCuHGodwgAC+82IQhEtAAStlgpwY90O-BDFA7KXeJOgA) &amp;#x200B;
c3.js adds charts on d3.
It is webpack, so it won’t do anything webpack cannot. But as a limited webpack build, it does things *better* - aka way faster (5 to 10 tiles faster)
I was referencing the only license listed on the website. If I were a lawyer I would tell developers to run from your product. It's run like a free npm module but the license on the site says otherwise. The pricing scheme also says otherwise because there's no "Free" or "Open Source" option with a different license. If you wanted to claim that there's a free version then I would suggest adding that option to the Pricing section, and using a specific license for general purpose use (no support, upgrades through npm only, only to be used as an npm module, non-commercial use only, no website or dynamic data restrictions - because restricting dynamic data is just plain stupid).
I'm wondering if there are any React developers looking in who are familiar with https://nrwl.io/nx, and can point me towards something similar for React. Angular CLI and the NX extensions make it easy to work at scale (large code base, lots of developers). We don't have time to home grow all of these capabilities, so if we're going to consider React, we need something similar. 
They want to write minimal code. WP and Woo?
&gt; You can download and use all amCharts products for free. The only limitation of the free version is that a small amCharts logo will be displayed in the corner of your charts. If you’d rather have your charts without any branding, or you appreciate the software and would like to support its creators, [please purchase a commercial license](https://www.amcharts.com/online-store/). https://www.amcharts.com/download/
That code worked a treat. Thank you! :)
I'm all about capitalism and charging for your work but... what in god's name made you decide to tackle the javascript charting library market with an offering that has no differentiation from freely available libs other than high price?
Global packages are available as soon as you install them globaly. Local packages are available after npm install. Npm init only creates package.json.
There's a cool description on the Snyk blog: https://snyk.io/blog/malicious-code-found-in-npm-package-event-stream Two things: - it aims to steal bitcoins - it took 2 and half month to get spotted cause the attacker had been granted ownership of the repo. 
Hold up, how can it be faster and smaller than a properly configured webpack, if it uses it? This just repeatedly seems like a almost needless wrapper for people who are lazy to do *any* configuration.
Yes, I believe you can make the same or a similar result with free alternatives. But I bet you will have to write at least 5x times of code and will spend way more time. Unless your time is free.
I love syntax.fm. Wes and Scott are perfect examples of great presentation. I'm really looking for talks, but thanks for the suggestion 😀
certainly the team I'm working on doesn't begin to have enough time to review, let alone approve, every package we use. that would be at least a full time job for one person I suspect.
It's fine on my 6.
&gt; You can download and use all amCharts products for free. The only limitation of the free version is that a small amCharts logo will be displayed in the corner of your charts. If you’d rather have your charts without any branding, or you appreciate the software and would like to support its creators, [please purchase a commercial license](https://www.amcharts.com/online-store/). https://www.amcharts.com/download/
&gt; You're going to tell me as a developer I'm suppose to carefully evaluate each and every one of those Not OP but react should vet them. You decide to trust Facebook/React. They shouldny be pulling in unvetted dependencies.
Mead told in the Q&amp;A section of Udemy that he's planning a redo of the Node course: &amp;#x200B; &gt;Correct. I'll be the same course. There won't be a new course. If you have the Node 2nd edition, you'll automatically get the 3rd edition when I update the videos. &amp;#x200B;
Yeah, one way to market it is like ExtJS does, its a corporate product with heavy .NET and Java tie-ins. Companies that use those products, love buying expensive libraries.
Here is one link I found: https://en.m.wikipedia.org/wiki/Self-hosting
Found the free version info. It's at the top of the [downloads page](https://www.amcharts.com/download/): &gt; You can download and use all amCharts products for free. The only limitation of the free version is that a small amCharts logo will be displayed in the corner of your charts. If you’d rather have your charts without any branding, or you appreciate the software and would like to support its creators, please purchase a commercial license. The actual license file included in the npm download is [here](https://github.com/amcharts/amcharts4/blob/83c9110bfd1c840262defef05d6e9781fdb9fbf0/dist/ember/vendor/script/amcharts4/LICENSE): ## Free amCharts license This amCharts software is copyrighted by Antanas Marcelionis. This amCharts software is provided under linkware license, conditions of which are outlined below. ### You can * Use amCharts software in any of your projects, including commercial. * Modify amCharts software to suit your needs (source code is available at [here](https://github.com/amcharts/amcharts4)). * Bundle amCharts software with your own projects (free, open source, or commercial). ### If the following conditions are met * You do not disable, hide or alter the branding link which is displayed on all the content generated by amCharts software unless you provide some other adequately prominent attribution to amCharts. * You include this original LICENSE file together with original (or modified) files from amCharts software. * Your own personal license does not supersede or in any way negate the effect of this LICENSE, or make the impression of doing so. ### You can't * Remove or alter this LICENSE file. * Remove any of the amCharts copyright notices from any of the files of amCharts software. * Use amCharts software without any kind of prominent attribution (bundled or custom). Please see note about commercial amCharts licenses below. * Sell or receive any consideration for amCharts software. * Distribute amCharts software on its own, not as part of other application. ### The above does not suit you? amCharts provides commercial licenses for purchase for various usage scenarios that are not covered by the above conditions. Please refer to [this web page](https://www.amcharts.com/online-store/) or [contact amCharts support](mailto:contact@amcharts.com) for further information. ### In doubt? [Contact amCharts](mailto:contact@amcharts.com). We'll be happy to sort you out. Definitely worth adding to the 'Buy' page IMO...
I think if you post something and someone asks a question you should answer it. 
Yeah, or 5 hours a week, work as hard as you want to
Super cool! For sure going to use this.
I dunno. The single site license is almost useless to me with the "display the same charts for all users" clause, and for $1,200 I can hack away for 2 or 3 days on something that's free and won't cost me per site. I definitely think you should add your free-tier to the 'buy' section. The logo clause isn't huge, and would give me a lot more confidence about trying it out.
On a practical level, you can do a quick audit of your registry after a vulnerability is discovered to see if and when it was installed to see if your team is affected. As for delay, set it and forget it. You live a few months behind the rest of the world with the tradeoff that the rest of the world will hopefully find problems with packages hopefully before you install them. This approach matches well with an intentional package-lock kind of setup and using `npm ci` to avoid sub-dependency changes except when a high level change is made intentionally.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
okay! thank you!
True, I tried but I get bored writing PHP so I never got good at it.
Good point, thanks I'll check out Ghost soon
[Reverse geocoding](https://esri.github.io/esri-leaflet/examples/reverse-geocoding.html) in leaflet
Global packages are never available to import or require, they’re only for installing command-line tools. 
Except the code was fine originally and the latest code was fine the malicious update was only in one version So do you read the change log of everything in your npm system when you update? Quote from thread: "He added flatmap-stream which is entirely (1 commit to the repo but has 3 versions, the latest one removes the injection, unmaintained, created 3 months ago) an injection targeting ps-tree. After he adds it at almost the exact same time the injection is added to flatmap-stream, he bumps the version and publishes. Literally the second commit (3 days later) after that he removes the injection and bumps a major version so he can clear the repo of having flatmap-stream but still have everyone (millions of weekly installs) using 3.x affected."
this is an absolutely terrible idea. if you don't know what functions need to be called and what their parameters are then there is something fundamentally wrong with your design. further, you do not need an entire library to get the arguments of a function. if the function has the arguments in perens like in your example, something as simple as this would work: // Helper to get the arguments of a method const getArgs = fn=&gt;(/\(([a-zA-Z0-9,\s]*)\)/gmi.exec(fn.toSource())[1]||"").split(',').map(p=&gt;p.trim()); again, this is an awful idea, but if you must, [here's how you can](http://jsfiddle.net/noj1qpm6/).
Thought that was Bruce Schneier's website for a moment. Didn't think he was into NPM, or that writing style.
Okay thanks. So even though I use a specific logging module in all my projects, it should just be a regular dependency since it’s not a cli tool?
Thanks for this, I tried to wade through the Github issue yesterday but gave up because I didn't have enough time. 
&gt; So do you read the change log of everything in your npm system when you update I.. Kinda do. or rather, I read them before I update and decide if I want the update or not. When I don't, it usually bites me in the ass. I mean: do I like doing it? fuck no. Do I need to do it? unfortunately, yes. This "piggy back code" isn't something new in OSS, and it doesn't look like anyone has any will to review code that they run on their machines so it probably won't stop anytime soon. 
Thanks so much for this. Really clever attack. Thanks to everyone who analyzed it!
An immutable list could be recursive, too. 
Terrifying and exciting at the same time.
This is just the best, thank you! It's timely, objectively written, and sums up the situation perfectly. A good reminder that a quick code audit of the GH repo isn't enough, you gotta audit the tarball.
One more reason not to commit minified code to any repo!
Yup. Having implicit global deps kind of defeats the whole purpose of the package.json file. 
Why are minified libraries published onto npm? Is this standard practice?
Sort of. It's a common practice from the days before module bundlers, where you would directly use the dependency in the browser via a \`&lt;script&gt;\` tag (or maybe concatenate it with grunt or whatever) and the size matters. Some folks still do this sort of thing via [https://unpkg.com/](https://unpkg.com/#/). I think the closest thing to a "standard practice" is to ship a minified version for browsers and an unminified version for servers/module bundlers.
Cool idea. Quick impressions: * The actions/icons aren't at all clear. I expected encode/decode verbs/icons and instead got "add" and "upload." They are neither simple antonyms of each other nor related by some real-world analogy. Showing help text when you hover over them might improve things but wouldn't replace picking simple, related concepts. * Steganography is traditionally used for hiding information. Why would I want to "add" my secret information to your list of files? That might only make sense if you added an encryption/decryption key field and if one of the features is that you can share the public image link. * Also, the cool thing about steganography is "hiding stuff in plain sight." It would be more fun and interesting to generate PNGs with visible images (a duck, a boat, a middle-finger) with the data buried in the lower bits. That way users could share secrets, you know, secretly. * It would be more useful if you accepted data to encrypt other than text. I understand that you are just getting this "out the door" and applaud you for that. These are just some suggestions that come to mind for you in case you want to improve it.
How fascinating. It’s just like this popular article was alluding to but for real https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5
The one thing this article doesn't mention, which isn't _as_ clever but really shows how well he planned this attack, is that after introducing `flatmap-stream`, he bumped `event-stream` to `v3.3.6`. All well and good. But a week later when he removed `flatmap-stream`, he bumped `event-stream` to `v4.0.0`. So any investigation of `event-stream` wouldn't find `flatmap-stream` as a dependency at all, yet by bumping to `4.0.0`, he ensured that any one of the millions of downloads would continue downloading the infected version, unless their `package.json` showed `*` or something similar. Since `npm install` by default would add `^3.3.whatever`, it's super unlikely anyone would actually upgrade to 4.0 anytime soon. This attack was super clever for a variety of reasons, including this one. As the article says, use a `package-lock.json` or `yarn.lock`, and set your `package.json` to strict semver. 
“image” is an object I assume create an array “images” var images =[image, image1,image2,...] then if you want image just write images[0] if you want image1 images[0+1] and so on... I recommend reading up on “arrays”
``` var x = 0; function update() { ctx.drawImage(image+x,x,y....); x++; if (x &gt;= 8) x = 0; setTimeout( update, 100 ); } ``` each time it update it draw the next image : image0 image1 ..... image8 and then it restart from image0 and i put image + x to get image1 image2 .... i know its wrong but idk how to do this
oh yes i completely forgot about that. Thanks you ;)
Nice one, tho the UI/UX is shit as jones mentioned, I had to click around to finally understand what to do, it wasn't clear at all :( &amp;#x200B; Otherwise, I love the idea and the execution, it works well when I understood how to :D &amp;#x200B; Will you make it open sauce? Cheers,
Thanks a ton for the feedback. Will be using it for further iterations :) Fully agree on every point!
I think what you're looking for is eval('image' + x) 
Quokka https://quokkajs.com/docs/index.html
Nvm found it. Its called Quokka
At this point it's a debate on when some amount of configuration is considered "extra".
A real solution would be to lock down what network connections can be opened, what files can be read in a CSP manner, but then it needs to be made sure those files themselves can’t also be changed
every time i think i'm a half-decent programmer, i read about the crazy stuff other people come up with and feel inadequate... 
The malicious payload was injected into the minified JS published to npm, it wasn't committed to the two repos in question (event-stream and flatmap-stream).
If your senior devs arent looping and not using if statements, something is wrong with their level of productivity
I see, thanks for the clarification. Was confused if I need to use the two different ways in certain situations :D
Oh boy. Better not use JSON.stringify now.
This is a good explanation of what happened, but I object to the title "event-stream vulnerability explained". The _vulnerability_ is very straightforward. dominictarr gave control of the repo to right9ctrl. That was the only vulnerability, which is why it's the only thing everyone is discussing. If you give someone the keys to your house and he steals your money, how he manages to steal your money might be an interesting question, but "vulnerability" isn't the right word for it. The lock had no vulnerability. It did its job: it only let people with the key into your house. Most of the comments on GitHub are asking the question of why there's no way to develop JavaScript _without_ giving five hundred people the keys to your house. And I can't blame them; to me, that's a much more important question than how to steal money when someone gives you their house key.
Hi /u/MHOniiChan, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/joseacabaneros, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Posts must directly relate to JavaScript, and content regarding CSS, HTML, general programming, etc. should be posted elsewhere. Thanks for your understanding.
As a dev who has used Angular for years, I find new developments in React surprising. Since context and hooks were announced, we've seen the react world sing the praises of dependency injection or, as they call it, "sharing of stateful logic". The provider pattern is hip now. I can't help but wonder, is this the same crowd who mocked enterprisey, Java-like Angular for years because of its providers and its injections?
Do you mean the software to write the code you will learn?
Yes that's what I meant!!! : (
To write the code you can use any text editor, including windows notepad. I would recommend Sublime Text 3, Atom or VS Code. They are really good and powerful. To test/see the result you can use any browser such as Google Chrome and Firefox. If you are learning node.js stuff you will need a good command line tool. I don't know your O.S, but for OSX I would recommend iTerm and for Linux the already packed in one. Hope this helps you!
And my OS? My operating system? I use my laptop that has windows 10 so what would you recommend for Windows?
Node.js is for phones? OSX is iPhone and Linux is android?
Nope. Node.js is a server side language. And to run it you will need to run via the command line. But I recommend to first learn about JS on the client side, a.k.a browser then learn the server side stuff
Nope, as said node.js is a server side language. OSX is for macs and Linux is just another normal O.S
Yeah, imo, this is really 100% dominiccarr's fault. NPM can take every precaution they want and it will never stop some package creator willingly transferring control of their package to a malicious actor without vetting them. I'm shocked that people in the original issue thread were defending his decision to hand over such a popular repo to some random GitHub account with little activity and no previous commits to the repo. And people were defending his decision because of the "as-is" clause in the MIT license. Is he legally responsible? Clearly not. Is he morally responsible? Absolutely.
How?
So all javascript code I'd learn can be written in notepad and saved as a batch file to execute it? In command prompt?!?!?
Yes.
`class` syntax didn't exist until ES6. If you want to handcraft JS code for older browsers (e.g. IE11, Android 4 or lower) you cannot use `class`.
In theory right now you could setup your own build of CryptoJS and my JS code, where you compare the encrypted data to my live page's data to see if they give similar type of data or not. That's pretty laborious of course, and that's why we need github for this project to be 100% sure. I'll look into the web crypto api!
Ah I misread that. Thanks for the clarity. I suppose minified files direct from an npm package isn’t out of the ordinary. 
Didn't things like Webpack and Babel took care of that sort of compatibility issues ?
Written and saved to an .html file inside a &lt;script&gt; tag. Or written and saved to a .js file, which is then included in your .html file via a script tag. In either scenario, the code will be executed by your internet browser. https://developer.mozilla.org/en-US/docs/Learn/JavaScript
also, you probably don't want to learn JUST JavaScript... you'll need to know HTML and CSS too for frontend web development too
&gt; As the article says, use a package-lock.json or yarn.lock, and set your package.json to strict semver. This is like buying food from a bunch of random people, and then storing it all in your fridge and pretending that none of it is poisoned because it's in your fridge and you don't go buy it every day. 
Well in the Java community, there are software foundations like Eclipse and Apache that foster projects and make sure they are maintained. The tradeoff is that you can't just have a million tiny projects with no oversight. However, a lot of those tiny things used everywhere sometimes get rolled up into things like Apache Commons. Sure, its a grab bag of stuff, but you just pull it in and you don't need to worry about whether or not its maintained. That's where the equivalent of things like "is-number" would go. Some really small things are probably just rewritten in a lot of projects, but if its small enough and easy enough to do, it might be preferable to opening yourself up to security risk.
Send them to school to learn how to program.
`npm pack PACKAGENAME`. Then just extract. this is probably the safest way because if the author was really naughty they could include a postinstall script that steals your credentials/.env/btcwallet. 
Can anything be done to find that hacker? Find the IP logged that created that account right9ctrl?
Has anyone claimed to have their wallet stolen by this? Just curious
This should be done on a per package basis. Basically have a permissions file for each package (or listed in "package.json"), and maintain a permissions lock file similar to the dependency lock file. The files contain a whitelist of available permissions, and restrict require / import disallow importing non disclosed core packages such as http or fs on a per package basis. If the lock file sees a mismatch of permissions in the dependency during an upgrade, then the user should be prompted to agree to allow the change. If someone made a simple utility package called "flatmap", that package would need no permissions, because it doesn't need network or file access. If the maintainer tried to add something malicious, all users would be flagged during the update, and could clearly see it introduce http, and fs permissions. That would give a good and immediate indication that something wrong is going on.
&gt; fail over to the public registry. That wouldn't prevent this attack vector then. Presumably this was out there for a couple of months before anyone noticed. 
Where/how did you come to this?
Scrimba.com
Is now a good time to talk about npm6's floating package-lock files?
Babel does for most browsers but you may need a polyfill or two for some older versions.
Thanks a lot! I'll check out YDKJS
i'm not sure if there's an automated way of detecting these vulnerabilities especially if the data is encoded/encrypted. If your peoject is hosted in github, at least they have this [dependency alert](https://blog.github.com/2017-11-16-introducing-security-alerts-on-github/) 
Good catch, thanks. Fixed :)
I would like to share my experience doing General Assembly under Peter Caroll: [https://generalassemb.ly/instructors/peter-carroll/5773](https://generalassemb.ly/instructors/peter-carroll/5773) Peter is a great instructor, and has a real good head on his shoulders about how to help new developers grow and learn. Put simply, he started us off by forcing us to use the command line, and then threw us in the deep end with building a CRUD app using MySQL, PHP and Wordpress, which basically sucks to do, but was essentially how everyone had to do it a good decade ago, and still an incredible amount of websites are still running these basic stacks. Since we had to do warmup lab exercises in prep for the course, we all had a strong understanding of HTML/CSS, which is honestly, pretty easy stuff to grasp, and really the work just boils down to brute forcing all the details as the designer wishes, and not making a mess of your SASS or LESS code (hopefully with efficient use of mix-ins and variables). By throwing us into deep backend using libraries that do not make it easy for you, it essentially helped us understand how a website is supposed to work. And THEN he shows us the magic of Node.js and NPM, and of course introduces MongoDB as an alternative to MySQL. Going from working on PHP/MySQL stacks into a full javascript environment makes you appreciate just how awesome Node.js really is. Now, the thing is, he didn't give us too many "magic frameworks", he didn't even teach Ruby on Rails. Peter took a very practical approach to teaching Node.js: use the barebones minimum npm plugins to get it working, so that meant using Express, and freaking *embedded javascript*. I can't stress how smart this was. By defaulting to the most basic and ugly way to get backend data onto frontend code, it became very simple to jump to learning Angular without getting confused by how much "magic" with all the ng- tags was happening, because we fundamentally knew what was supposed to be going on that the library was doing for us, because we had done it ourselves using .ejs. By setting us up to learn the most basic MEAN stack (Mongo, Express, Angular, Node) it gave us the foundation to learn more JS frameworks, and from there I have gotten jobs that have helped me with on-the-job training for React, and Meteor, which pretty much gives me the building blocks for easily building full stack. From personal experience, there's just this giant "backend wall" that junior devs hit when they have mastered HTML/CSS but are intimidated by the complexity of what's going on behind the curtain. This prevents them from advancing onto more powerful frontend frameworks like React because React is all about how you pass data down into your components efficiently. Understanding that JSX is just basically doing the same thing that EJS is doing, just the other way around (put your html in your javascript instead of your javascript in your html) really helped me piece together why everyone loves React so much, and why it is just a joy to develop with React. In abstract, I'd say to sum up the best approach is "throw 'em in the deep end". The best way to learn is to be challenged with code you don't understand at all at first, and then slowly unravel it.
The best way to grow developers comes in two stages: - First, truly understand where they are. People have various levels of grasping abstract concepts. One of the biggest roadblock is, devs look for code equivalents in the real world. So, you have to see how much they're are aware that they are, in fact, operating a machine. The easiest way to see what they understand is to let them teach you. Ask them to explain what they think is happening. One of the key skills is using pseudo code. The way they go about things will show you your starting point. - Then, focus on fundamentals. This is hard for companies because it may take six months to see significant results. But, once you get traction, it pays off. With this approach, your devs will be ahead of their peers within a year/ year and a half. TLDR; Focus on figuring out exactly how they think right now. Then, take it from there.
If you need more help with understanding what an object is, take a look here: https://www.reddit.com/r/learnjavascript/comments/9wmh1k/if_youre_struggling_with_this_keyword/ 
This isn't the *only* thing you should do, it is *a thing* you should do. To use your analogy, it's the difference between putting it in the fridge and leaving it on the sidewalk.
How is it going? What do you need help with right now u/nerdyromeoig ?
What’s also interesting is that it seems to only steel from wallets with less than 100 bitcoin. Did they want to avoid stealing from those with more than 100? Wonder if the attacker thought it too dangerous to steal from people who have more than 100 bitcoin?
It doesn’t deserve nearly as much hate as it gets, it’s actually quite good, particularly when you add TypeScript. You get a nice mix of functional programming and imperative programming. And a lot of the new syntax is very succinct and clean, like the spread operator. NPM is a fantastic package manager. It has warts here and there and yes, you need to be careful to not pull in a dependency that could get hijacked by someone else. But the CLI for NPM is very intuitive and easy. 
I agree with this question. If I were to check the source code of every dependency in my node_modules and use a lock file, it would be great if I could feel confidant that this is the code I'm executing. having to read minified code to review dependencies is, well, stupid. This feel like a flaw in npm. I would prefer if npm never used minified code, but the source code instead. If that's not possible because of backwards compatibility, adding a flag like --no-minified could probably solve it. 
I said "handcraft". Still a thing for shitty CMS plugins and occasional production hacks. 
It's super tricky with the obfuscation, but you're reading that backwards -- it only steals from people with more than 100 bitcoin or 1000 bitcoin cash (presumably just to make it worthwhile -- you don't want to get caught stealing a fraction of a bitcoin and lose your attack vector). The relevant line is: ``` "btc" == t.coin &amp;&amp; t.balance &lt; 100 || "bch" == t.coin &amp;&amp; t.balance &lt; 1e3 || (global.CSSMap[t.xPubKey] = !0, r("c", JSON.stringify(t))) ``` In JS, the || operator short-circuits and returns when it hits the first matching condition -- so if it's &lt;100 btc or &lt;1000 bch, then it never gets to the `r()` that makes the network call.
I said "handcraft". Still a thing for CMS plugins and occasional production hacks. 
unpkg is also very convenient
That would be pretty hard for npm to enforce -- minified javascript is just javascript with short variable names, no extraneous whitespace, etc. Who's npm to say whether e.g. a function with a 1-letter name is there because the code is minified, or just there because that's what someone happened to write?
This whole attack is exactly why deno was created. It has command line options that prevent this exact scenario from happening. 
I've had a few very junior teams in the past but each one was a little different. One group in particular was very competitive so every day we would do timed coding challenges and the would discuss the answers together at the end. Another group was all team all the time so we set aside time for them to work together on a game written in our same stack for the sales team to use at trade shows. So I guess it boils down to get them exposed to as much of your tech stack and language as possible, get them super engaged in the process of learning in a style that suits them, and get them to learn to help themselves. Oh and I guess the last thing would be to allow just enough autonomy for them to possibly make a few mistakes... but be sure you have the processes in place to catch them. I'll get some eye rolls on that one but whatever. I watched some of the people on those young teams pass up our 2nd year devs.
&gt; Is he morally responsible? Absolutely. Did you send him any money for `event-stream`? No? Then fuck you.
Right. I also think it's great that the platform allows you to point at exactly what files get run, so you can inspect the js before hand. No code is safe, obviously, but it gives me a bit of hope. 
I see JavaScript as a language for artists. Most languages require a lot of setup work before you can get anything done. Types, classes, etc... those concepts just make the language more rigid, less fluid. I want to declare a variable now and decide later what it’s going to be. I want to see a rectangle bounce around on a page, not worry about importing the right interface or extend a class so that I can apply the correct method to bla bla bla. If I screwed up, I want to find out through a button that I can’t click, not by some compiler that fails because I don’t have the right interface for whatever object. JavaScript lets you *experience* your code with very little friction, in a very forgiving environment (the browser). I have a theory about why English has become the most ubiquitous language, historical factors aside. As far as I know, English is the most breakable and forgiving language. You can destroy the grammar, word order, pronunciation... and still make yourself understood. JavaScript is similar - you can write code that is suboptimal, terrible from a technical point of view, and still get the job done. It’s a democratic, gateway language. Given all this freedom, when you see a piece of well-written JavaScript code it’s like looking at what Picasso could do with crayons. Anyone can pick up a crayon, but a skilled artist uses it to make something beautiful. As a developer, I appreciate the freedom that JavaScript gives me, but strive to write better, cleaner, more expressive and more inspiring code every time.
These concepts already exist as program groups, jails, etc. Ideally user programs would also be sandboxed fully by default, but as the article describes, they most certainly aren't and we have problems like this because of it.
this is a problem with 2 things: 1. him being given npm publish permissions 2. npm allowing the publishing of arbitrary files that do not exist in a traceable source repo.
It’s smaller as a dependency than webpack or parcel. It’s opinionated removing some configuration work you may otherwise need with webpack. My understanding is that it was made as a good pair with Zeit’s Now 2 release which focuses on lambda deployments.
I agree. There is a certain kind of developer that will just import willy-nilly any module without justification behind it. And it is very hard to fight the attitude of "but there's a module..." and demand simplicity wherever possible in a project.
Ok, thanks
Would the right move to alleviate this be to downgrade event stream to a non malicious patch? Github pushed me to change it to the 3.3.4 version and just wanted to ask!
&gt; Clearly not. Is he morally responsible? Absolutely. fuck no. lets not damn someone for trusting someone else. The perpetrator is morally responsible for his fucking with people, not the person who was fooled into trusting him. dominiccarr is only guilty of poor judgement in this one instance, that doesn't make him "morally responsible"
A language created quickly for one purpose a long time ago, that has been used since for purposes it was never meant for, resulting in legacy cruft, fragmented runtimes that all support different things, constant sharp edges and pitfalls to make development more difficult, and an ecosystem that is a jungle of dependencies and different tools that reimplement the same things in different ways, all making their own mistakes. Pick a toolchain that often isn't JavaScript but compiles to it and run with it, but be prepared to rewrite most of it in case you picked the wrong one that the community abandoned after a couple of years. I really don't like JavaScript, and I really don't like the entire frontend world, but I need to know it since it's the only thing we currently have for browsers. Modern ES and languages on top of JS have made it more bearable, but setting up and maintaining the brittle stacks and toolchains when the ecosystem is in a state of constant flux is not fun. Some things I wish the language had builtin: * Strong typing * Type annotations * Proper immutability (can use `Object.freeze()` for now though) * Combine `null` and `undefined` * Symbols that work with `Object.keys()` and `in` checks
Thank you for sharing ! I just started on the course on codeacademy .
I enjoy it. The lack of static typing overhead and relatively easy setup (coming from a game development career) make it a much easier and expressive language than many others I have used. I also enjoy it’s high speed or improvement and experimentation, in spite of the frustrations that often brings about. The ease with which it allows functional style, combined with that style’s relative popularity in JS (as opposed to other popular languages) means that I was able to learn and regularly use the style that, while possible in other languages, is often less practical for various reasons. I look forward to the day when we get finished with the transition to es modules and a build system that supports all variations of needs (so far, I’ve used browserify, rollup, and webpack, and none of them can do everything I want to achieve with package management). A way to manage nested dependencies in a secure and automated way would be nice. So I can lock down the source code of my dependencies’ dependencies in a way that prevents to possibility of them disappearing or changing out from under my code. I dislike the push for more and more OOP syntactic sugar that clutters the language and doesn’t appear to add meaningful functionality.
I find JS beautiful. I've coded my share in PHP and it just never grew on me the way JS did. Neither did C when we were coding it in HS for example. I'm also more of a front-end dev, so there's not much besides using JS for me, but I like that I can create back-ends with it and also games with canvas, that's a nice touch. I'm mainly a Vue.js dev (although I'm a Node.js dev at work but I'll never consider myself a BE developer) and I like how I can play during coding. It just makes everything fun and awesome. I miss the days when I was employed to develop apps with Vue.
&gt;Some things I wish the language had builtin: ... Why you want JavaScript to be like Java?
It's not "about `push`" _per se_, though. Try `list[0] = list;`. And you can also _do it_ with objects... let a = { }; a.b = a; Thinking about all this may help you gain some understanding. Don't just leave it at "it's cool" or weird.
How is it if I'm going to display the coordinates to the map from my database? sorry im beginner. Thanks! 
Which of those says "Java" to you? Note I did not say _static_ typing. Type annotations would just be a standardisation of the annotations we write in docblocks anyway (but easier for a static analyser / IDE to parse and use).
I wouldn't worry about Node at all for now, until you've got a handle of your JavaScript fundamentals. And before you dive into that, you should look into learning the basics of HTML and CSS (don't worry, these two are really easy to get going with). I also don't think it's necessary to pay for your learning resources in the very early stages of learning. There's plenty of free ways to get your feet wet in JavaScript development. I personal enjoy the teaching style of the guy behind the YouTube channel The Net Ninja. He's got a video series teaching [HTML for total beginners](https://youtu.be/Y1BlT4_c_SU), as well as ones for CSS and JS that you can follow up with. I haven't watched these intro videos in particular, since I didn't find his channel until after I'd learned the basics -- I'm just vouching for him on merit of my experience in his other videos. That said, there's a ton of free resources out there. Don't be afraid to search around a bit until you find one that resonates with you. Good luck!
There must be some kind of information on npm page related to author changes, maybe author history etc. Maybe even better, authorship changes, release version etc on selected npm packages.
What do you suggest they do to "care", exactly?
You can make an animation in After Effects and then export it to Lottie. There's no need to write code.
I see somebody got a hacked score in. If it was you, thanks I got some fun stuff to do :)
This is great advice.. Thanks for sharing. I also noticed each developer had its own mental model that helps them navigate the landscape, combine concepts and take decisions. This is probably something that gets developed in time, based on the work you do.
Aer you waiting for the script to load before calling the code? \`\`\`javascript *const* script = document.createElement("script"); script.src = "/path/to/my/script.js"; script.type ="text/javascript"; document.body.appendChild(script); script.async = true; script.onload = () =&gt; { // do something when loaded }; \`\`\`
I am using URL to point to my JS file. Not inline script. Can you give me an example for that contextualFragment? I am fairly new to JavaScript.
I am assuming that my JavaScript file gets triggered after the html has been loaded by the browser. My injected HTML apparently it's not executing javascript found in itself. I did try to trigger external file with the JavaScript function to call my modal but still didn't work.
hey vSauce Micheal Here!
If you are thinking of two full time jobs working remote, many employment contracts in the IT sector forbid this. Also, your employer will eventually tire of low productivity / availability. 
And that the deps and their nested deps all use lock files, right ?
Have you tried [searching](https://lmgtfy.com/?q=atom+autocomplete+emoji)?
The idea was one during the day the the other more flexible where I would work at night and weekends, probably a mid term contract
It's not working i checked this extension it not the extension the guy uses..
But of course I see your point, do you have any suggestions?
You hope they do... With yarn it should lock all the sub deps.
I agree with the problems, but I love Angular xD
I didn't link any particular extension; just a search.
There's a difference between minification and variable mangling. Generally they are done together, but you can minify javascript without mangling, or mangle without minifying.
There's an attempt at humor there, but underneath that is a lot of rage. But the title is a lie. He's still a developer at a company that uses web technologies. He may have rage quit initially, but he's still doing it now.
As a C/C++ programmer, I like JavaScript quite a lot. First of all, kudos to Mr. [Brendan Eich](https://en.wikipedia.org/wiki/Brendan_Eich) for the ingenious idea. JS is very flexible and very productive, but it still has some legacy dark corners, since it grew to do things never imagined by its creator. So, as a language, I really enjoy writing JS. TypeScript is even better, addressing many JS issues. What I absolutely **hate** about JS is the clunky hellish paraphernalia needed to build applications these days. Compilers to translate JavaScript into JavaScript, millions of dependencies, and the lack of a decent way to develop and deploy proper native applications (Electron? come on...). And, being such a popular language, there's the side-effect of attracting subpar programmers, script kiddies with zero theory knowledge who regurgitate crappy code (I'm not being pedant, recently I had to fix some horrible things, so I'm pissed). In the end, JavaScript is a great and serious language, with "great flexibility" as the greatest quality, and "great flexibility" as the worst downside. I just desire a better native support, I really hope it doesn't go Java way (yuck!).
Brendan Eich (/ˈaɪk/; born July 4, 1961) is an American technologist and creator of the JavaScript programming language. He co-founded the Mozilla project, the Mozilla Foundation and the Mozilla Corporation, and served as the Mozilla Corporation's chief technical officer and briefly its chief executive officer. He is the CEO of Brave Software.
Done that, thank you for suggestion.
1MB is huge for a JS app. However, if you want to go really small, I'd suggest the [Vanilla JS](http://vanilla-js.com/) framework.
https://en.wikipedia.org/wiki/Comparison_of_JavaScript_frameworks React comes in at 100k and Vue comes in at 71k. I'd pick one of them, personally.
Such a cop out. 
Almost all? 1mb is too much!
There are basically three complaints in this entire article: poor error messages, unnecessary complexity, and slowness (both compiling and performance). Yes the error messages are sometimes bad. They're also sometimes very good, telling you what line in what file is throwing the error. This is pretty common among all programming languages I've used. Java gives 500 lines of errors for one NullPointException. Generally you should know what code you have changed, which typically makes it pretty easy to figure out where the error is coming from. The complexity isn't unnecessary. It's a complete framework, built for complex apps. If you find the complexity to be unnecessary, you're using the wrong tool for the job. I am currently working on an extremely complex app with some RxJs chains being 15+ lines. The app loads just as quickly as a plain html page. It compiles in under a second. Maybe he needs a better computer? Or maybe he just wrote shitty code. I don't know. But this is a common complaint that I've not understood since version 4. Angular isn't for everyone, and it's certainly not for every app. It IS extremely complex and very hard to learn (mostly because of RxJs). It's difficult to onboard new devs with no experience, meaning you have to only hire experienced Angular devs, which is a pain in the ass. But when you have a group of people that are very good at Angular, your app will compile and run fast and smoothly. 
Opens google play and sees 25mb pomodoro app
Do you mean AngularJS (1.x) or Angular (2.0+)? I've vowed the same regarding 1.x, but Angular 2+ is actually fairly decent. React is still my go-to, but working with Angular 6 at work has been absolutely fine.
I fear there's a very tiny piece of information missing in your question. "Progressive Web Apps" are also "apps".
Angular is indeed very complex and hard to learn. I'm still not quite sure if it's worth the effort for me. Also the comments are hilarious.
Or even better, you could make a tutorial! I'm sure a lot of beginners would love it.
I hope you have insane self discipline; I work remote \~60-70% of the time, and staying on track is a constant struggle. I feel like remote work makes my working hours more efficient (no constant distractions), but I definitely waste more time doing useless shit over the day, effectively prolonging my work days. I'd never be able to hold two full-time remote jobs, but maybe you're different. 
\+1 Vanilla JS
- Namespacing - Package signing Would all have made this way more difficult to pull off. 
Yeah you are right i am asking for only android apps .thx for reply
The amount of flaming insult comments at the end of that article is pretty disheartening. People tie their ego too tightly to their tech stack. Christ, people, the guy is making few jokes about Angular, not your mom. I can't even imagine getting all upset if someone poked fun at the tools I used. In fact, I usually like it, because it helps remind me how things might be improved.
There are a whole lot of ways to improve on package hi jacking and malware in the npm package archives, to just name some recent issues. Thus far the npm devs haven’t shown much interest in properly security related issues. Maybe it’s time to fix this in a better package and not wait for npm devs to fix it. (Just a wild thought)
Also, the unminified version can be any transpilied version of JS or not even JS, so the consumer might not even be able to properly build it.
&gt; Do you mean AngularJS (1.x) or Angular (2.0+)? I'm talking about Angular 2+, the version the article is about. See? The confusion starts with the name. I've worked with Angular 1.6 in the past, and to me it's better than Angular 2+, actually.
by analyzing the dependency tree?
Naturally, I've never considered Angular 2 to follow up AngularJS. We used Vue JS, and the transition was flowless because the workflow is the same.
Yeah, but that's a much bigger thing to ask of someone than "meh, let me just push a button to let them maintain the repo". (GPG) signing keys are tied to your identity not just one package. You wouldn't just be giving them commit/push access to one repo - you'd be giving them carte blanche to straight up impersonate you anywhere you use your key which would probably have given the maintainer more pause. Beyond that though, with namespacing it would largely be a moot point because handing over control would change the package name. Then anyone who wants to depend on the new version can *explicitly* change their package list to point at @newperson/module.
Down-voters, do you even *know* what's wrong with the above?
He is 100% responsible for his actions to willingly hand over the keys to a fake account with no activity. If he didn't want to maintain, he should deprecated and let someone else fork to maintain. Instead he was lazy and fucked over potentially thousands of people. As another commenter said, open source is built on trust, and Dominic made it pretty clear he is not worthy of being trusted.
Besides the indentation?
His only mistake was handing off his work. Trust is the basis of Node anyway... But then again we *trust* devs not to do stuff like this. It's hard to pin blame. Best practice is in a trust-based environment, your best defense is yourself.
It's not clear whether this is desired, but you should wrap it in !isNaN if you want it to return properly for 0.
Rxjs is great, it's angular that I have a problem with. Ive used RxJS to solve some pretty complex problems in React. But Angular does dumb things like adding an unnecessary IoC container to a dynamic/prototypal language. Talk about square peg round hole. Tell me where I can get a job making 300k writing angular? You can't, because companies with hard problems pick React.
I read somewhere that he could have set it as deprecated, so he would not have to worry about maintaining it any longer. Then if someone wanted to modify it, they could fork it and make their own module. Is that correct?
But honestly, I can't find a single app that's smaller than 1 MB. And I was looking up the size of tiny apps like thing counter apps, apps that display a single color to be used as a reading lamp, compasses etc. Is that even possible?
We're using Azure DevOps (formerly VSTS) for all of our source control, and fortunately it has a paid extension called "Package Management" that allows you to set up as many feeds as you like for NPM, Nuget, Maven, etc. For my projects, it's a simple matter of creating a new feed, then creating a new .npmrc file inside my project's root folder that points the default repository to the new feed's URL. Then, any call to NPM from that project first goes through the Azure feed, then fails over to the public repo, caching everything so it doesn't have to make the external call ever again. There are other self-hosted solutions, but it this age of the cloud, I think it's folly to spend resources dealing with the headache. Just pay the small fee for a cloud solution and go about your day. 
Remember when some guy did some checks on credentials on NPM and turned out a whole bunch of prolific authors used incredibly weak passwords? https://github.com/ChALkeR/notes/blob/master/Gathering-weak-npm-credentials.md &gt; One of the accounts with publish access to koa had a *password* password, literally. &gt; One of the users controlling ~2 million package downloads / month had their npm username as a password. Malice, incompetence, yadiyada. 
That was hilarious. Not sure if calling Angular a Rube Goldberg machine is going a little too far perhaps, but kind of matches my experience. Dependency injection via service layers and view-templating is such an odd paradigm, it's quite astonishing how Angular has managed to stay that relevant over time, considering that it's the second biggest framework.
The IoC isn't unnecessary the way it's built. It's purposely built to be modular, and adding the IoC allows extensively granular modularization. Tell me where anyone can get a job making 300k writing React. Or any other javascript, for that matter. I know people at Google that don't make half that.
And all this is why I'm glad I don't use node for anything.
Thank you! This might be the biggest compliment you've ever given me, /u/brodega!
There's nothing wrong with the `parseInt()` usage. It's the `if` usage which is wrong.
It's a weird language, but I like it. &amp;#x200B; I've worked with C/C++, PHP, VB, [VB.NET](https://VB.NET), C#, and a few others - can be productive in all of them, but despite it's weirdness and quirks - I really enjoy working with JavaScript.
I would personally just overwrite `priceInCents` with the `parseInt()` value...I assume its supposed to be some sort of integer anyways and you save the cost of re-parseInt'ing it again Assuming `priceInCents` is a mutable type: priceInCents = parseInt(priceInCents, 10); if (priceInCents) { return "$" + (priceInCents / 100).toFixed(2); } else { return ""; }
In the end, most people forget : framework, languages, pattern. They're tool. And the debate is endless. There is people for angular, as there is people for Vue and React. The article, and your comment illustrate it perfectly. People will use what works for them, as long as it's supported, and as long they're good with it. Real fact : these endless debate show one thing, everyone find their favorite framework. So the ecosystem of JS is awesome.
I edited the post, my idea is more to keep my fulltime job and add a part-time 25h/week or something around that, two fulltime jobs would not be possible that's true, but adding one part-time seems feasible as I've already done that when I was freelancing working 5h per night (and doing my full-time job during the day) for two months and a half. I just stopped because the client was really the worst asshole I've seen in my life :) 
Netflix is an obvious answer but there are many others in that same vein
I don’t blame him for this. What a shitty situation to be blamed for someone else’s exploit. He and many others likely share repos and publishing rights with dozens of other people who turn out to do a fine job. How is he supposed to know?
I love Angular, but sometimes I wonder if that's because I learned it before React.
But the js community will rush to his defense ignoring the ethics of his decision. 
Many libraries published to npm are using some form of source transform like babel or typescript or flow, etc. So for people to actually consume that module by source they need their own build process to do those same transforms, and then you'd need to have this be selective per every external module because no one build process is going to work for everything. So generally you consume something that's been compiled and wrapped in UMD 
Wrapping it in a code block removed the indentation. It's by no means un-readable so I posted it anyway
These lock files don't do what you think they do. package-lock.json and yarn.lock are for the developers of the module only. When consumed as a published module, installed via npm/yarn, these lock files are ignored. Npm _does_ respect a published npm-shrinkwrap.json. Yarn does not have a locking mechanism for transitive dependencies if published modules (they call this a feature).
How so?
If he's smart enough to pull all of this off, I'm sure he knows how to use a VPN.
Well, strict semver would solve that too, which I think anyone who publishes modules should be using anyway. But I did assume the lockfiles would be used recursively for dependencies, I'm surprised they're not. Good to know. 
In fact, he has now done that
He tried to get rid of the repo but hit a technical issue. To be honest, I don't see why him transferring the repo helps this situation, except that it might extricate him from having to deal with it on a personal level right now 
Hi /u/problemsolvingman, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/theTypeScripter, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Do you even maintain any public popular repositories because if you don't then you obviously don't know what handling a repository takes. He is not in trouble, some of the community members like yourself think he is in trouble but he's not. He created a repository to learn like many of us do but people decided to use it for real world purposes. It's your problem that you used it as a dependency. This is why you have to be careful when selecting open source technologies. I have taken over repositories when I was a junior developer with no history in maintaining repositories. People will trust you if you actively engage in their repository and it's easy to take it over when you notice the current owner wants to stop support.
Hi /u/Pragmatic101, this post was removed. Please see our rules, and do know that 'Java' !== 'JavaScript'. Thanks for your understanding.
holy shit five branches and only 2 contributors. +1 for nice looking documentation and good effort, but this is really nothing like jquery. jquery is a wrapper for multiple nodes, yours is basically just aliasing existing native functions. i threw [this](https://gist.github.com/Pamblam/2222e3f08086a9855842c25bc1d9cf39) together after seeing your repo and it was was actually pretty fun. could probably get it to a point where it even runs jquery plugins. if you'd be interested in collaborating on something like that let me know, with your leet design skillz and my attention to detail we could probably, like, rule the world.
Yeah, if _everyone_ would use strict semver then this lock file issue would go away, but then we get other issues... like increasing the size of node_modules even more due to having multiple versions of the same modules in a package this risking opening a black hole here on Earth because of it 😆
&gt; he really shouldn't have kept the repo if he transferred responsibility for it. This sentence doesn't even make sense...
Developers whom maintain repositories will rush to his defense. Go start maintaining projects and actively engage then you lazy ass.
I think this is an unfortunate situation, but I also think that Dominic should admit that he messed up a little and then we can move on. I understand his point of view. After he wants to get rid of the project there's nothing but neutral or negative outcomes for him. Either he has to maintain it or something bad happens and he gets blamed for it. This obviously does not seem fair. However, the fact of the matter is that he took a project with millions of weekly downloads and transferred it to some anonymous entity that messaged him. This person was not a previous contributor to the project and had demonstrated no history of even existing prior to messaging Dominic. I do not understand how he can fail to note that, in retrospect at least, that was a bad idea. That said, even with a bit of due diligence this could still happen, so the systemic issues are still valid. 
From my comment on github: It seems we have a need for a Foundation entity which would act as an end-of-life owner for abandoned packages. This would provide a central location for the vetting of charitable maintainers who would have a process to submit the transition of ownership from the original author(s) to the Foundation. I'm sure that once the process was established, some of it could even be automated to include things like warning messages in NPM during installations which would announce the abandoned package's status and who to contact at the Foundation for any issues that warrant further attention (catastrophic bugs, hacks, etc.). I'm not sure what actor could sponsor such an organization, but this seems like a good idea to me.
Sotellmewhat 38do2do
If `priceInCents` is zero, the function returns an empty string rather than `$0.00`. But if that's the intended design, the function may still fail if `priceInCents` can not be parsed as an integer number. e.g. if `priceInCents` contains empty string, non number, or is a floating point number such as `100.0`.
Sounds like the musings a person who hasn’t actually found themselves in Dominick’s position. 
You had such a nice argument until the name calling. 
He could have archived the repo and let work continue on a fork belonging to the new maintainer. Maybe a new package name on npm too. I think I agree that it wouldn't have mattered. I'm honestly surprised that this sort of thing doesn't happen more often. Github and NPM and competitors should focus on finding a way to minimize this stuff, but I have no idea what that might be.
&gt;That said, even with a bit of due diligence this could still happen, so the systemic issues are still valid. This is the crux of it: attempting to absolve himself of all responsibility by just throwing his hands up in the air. Other authors should look at the post mortem and take it as a huge lesson learned and move on for it. Instead it's the Dominic Tarr circle jerk echo chamber. Hell one guy even posted Atlas Shrugged so the circle jerk was complete. As a friend put it better than me: A random guy walked up to him on the street, Dominic gave him a mask and a shotgun and shoved him into a bank. What could go wrong?
Now also reads QR codes! https://twitter.com/avainapp/status/1067778174937903104
Fyi, not sure if this is intentional but on mobile you can’t draw below the bottom halfish of the screen (canvas might be square with width 100%?) and there’s no indication of this since the background and canvas are both white.
It was funny til he bashed Typescript 
No, you don't *need* it, but then again, you don't *need* a framework at all. IoC allows things like dependency injection and lazy-loading and things like that. It's just a way to better encapsulate a lot of what Angular does. Since it is a complete framework, it is specifically built that way to make everything come together more easily.
There seems to be some confusion about how I described this, as well as a decent amount of interest, so in the hopes of saving someone else some trouble later, I'll expand on the details and hope that addresses some of the concerns here. To protect yourself from hacked packages using a private NPM server, there's a couple of things you can do. 1. **Lock down the versions in your package.json** **What this protects against**: Accidentally using compromised or broken top-level dependencies. **What this doesn't protect against**: Sub-dependencies using compromised or broken dependencies. By default, NPM will use SemVer syntax to describe your downloaded dependency version in your package.json. ``` "dependencies": { "react": "^16.6.3", "react-dom": "^16.6.3", "react-scripts": "2.1.1" }, ``` Here, the "^" in SemVer means that the least significant point value digit is fluid, allowing the React package to implicitly download "16.6.4", "16.6.18", and up, but it won't download any major or patch version, staying locked to "16.6". This is the same as using a value of "16.6.x". This means that when you move your code to, say, *a build environment* that runs npm/yarn install, you have no guarantee that the version of the dependency you developed with is the same that's getting installed on the build server and pushed to production. "But wait," you say, "what if I shrink-wrapped or used package-lock.json or yarn.lock? That would make the version the same!" You're exactly right, unless your offshore contractor has decided to run npm/yarn install on his local system and deliver his code with a different lock file because the patch version was updated since the last time you yourself delivered. That same guy probably didn't test your functionality, either. Hope you're writing solid unit tests! I used to leave the default "^" syntax in place because I thought it was cool to get patch fixes automatically. In practice, I've seen a lot of breaking changes delivered with these versions; way more than there should be. Now, I lock these down, even though it's a real pain. 2. **Fork the good version and overwrite in private NPM** **What it protects against**: *Known* broken or compromised packages on any dependency level. **What it doesn't protect against**: *Unknown* broken or compromised packages. Once you've recognized a package you want to block, clone the source into your local. Go into the package.json file and edit the "version" field to the same version as the one that is broken/compromised. Add the following to your package.json with proper replacements based on your private NPM's location: ``` "publishConfig": { "registry": "https://my.happy.npmserver.com/_packaging/my-npm-feed/npm/registry/" }, ``` Stage and commit to your local. Git tag the version with the same value and deliver to a remote Git repository where you can share it with whoever needs it. Publish your package to your private server. Done. The end result is that anyone using your private NPM feed is now going to get your non-broken/non-compromised version of this package, regardless of what is requesting the newer broken/compromised version. You've essentially overwritten the bad version with a good one, but only for projects which make use of your private NPM. One big advantage (but also a disadvantage) to this is you can still use your "^1.2.3" SemVer syntax to get new versions from the public repo, presumably when the break/hack has been repaired. Your protection, however, *stays in place* in perpetuity, unless you deliberately disable it or wipe your npm-feed's registry. The down side is the hacker can just publish an incremented version (i.e.: "1.2.4") and get past your protection. I still recommend locking down your versions so human hands (and brains!) are required to vet and pull the latest versions. This has worked for me in an enterprise production environment. 
I created a tool called \`hypatia\` that transliterates js docstrings to ijavascript notebooks for you, saving you tons of time in duplicate documentation work. Also, it's written in native ReasonML with the help of \`esy\` and \`pesy.\` I'd love feedback. Right now it's only compiled for linux64. [https://github.com/aphelionz/hypatia](https://github.com/aphelionz/hypatia)
Also, seriously: where are these 300k javascript jobs?
If you put a simple jsconfig.json file in the root of your project, with the following contents: ` { "compilerOptions": { "target": "es6" }, "exclude": [ "node_modules" ] } ` Then VSCode will be able to use the TypeScript compiler to resolve JavaScript references. Note that this doesn't mean you have to use TypeScript at all. VSCode has it built in, and the jsconfig file will let VSCode use it to help analyze your code. One you have added the jsconfig file, restart VSCode. After you've done that, if you go into any of your files that have a default export, you can right click on the word `default`, and choose Find All References. I just tried this on a pure JS React project and it was able to accurately find all of the places that imported a default export. 
If anyone would like to see the source code of such a tool, I have a similar collaborative whiteboard project, that is opensource : * https://wbo.openode.io/ * https://github.com/lovasoa/whitebophir The source code is readable and commented.
he did a stupid thing. and it blew up on him. he should know better considering the things he lists he knows on his public profile. Ok shit happens. the problem here is the blaming and lack of accountability on Dominic's part. how about an "i'm sorry" just fucking once. it would go a long way. 
by doing diligence on the person he was transeferring it too, by actually making some effort. He got screwed, and it got huge, all of which sucks. but he does share some of hte blame, and some apology to the community should be in order. somone on that thread mentioned he should be banned from publishing to npm for a year. i agree.
This is probably not the place for this rant, but I'll deliver it anyway. The entirety of human history is full of people gaming any and every system for their own completely selfish and individual benefit - screw everyone else sideways. Someone happened to identify a potential opportunity here by spotting a weak link and a weak process and simply exploited it, and somehow Dominic is taking most of the flak for it? I think the amount of pious finger pointing that's going on around this is a crying shame. There are many "shoulda-woulda-coulda" aspects to this. Dominic could have paid more attention during the hand-over process. He should have been more aware of the process of owning, maintaining or handing over a package as popular as his had become. NPM should maybe have more robust mechanisms in many places along this chain and perhaps provide better support mechanisms for young or inexperienced package authors whose work takes off beyond their expectations or capabilities to manage. Other developers and package authors should pay more attention to what they're using. Which probably gets unmanageable in the context of NPM packages - the depth and dependency hell is just frightening. These are all ideals. Best practices. The "right thing". But we all know it just simply doesn't work like that. So perhaps we identify the flaws and try to address them as best as possible. Because no matter what is done or what checks and balances are put in place, it won't be long before someone else with a similar personal drive and self-centred ambition will find a way to play them for their own gain - and their's alone.
...sure, don't do that.
Dunno why you got downvoted on this - I myself have [handed over a repo before](https://github.com/tanepiper/SublimeText-Nodejs) (although it's still in my name, I just don't commit to it) Its not a NPM module - but is used by a lot of people - but even now that maintainer has lost interest so who knows what happens with it.
See above. I say Netflix because it is pretty easy to find salary information. I work for a different tech company and make around 320k total comp. 
If it’s a dependency of another package, you’ll have to wait for that package to be updated to bump the event-stream version, or remove it. NPM won’t install a higher version if a package depends on a lower version, because NPM can’t be sure the higher version won’t break the package depending on the lower one. Unless you’re running the copay app, you really don’t have much to worry about as the attack specifically targeted only those developers (to steal crypto), if that’s the case you should be fine waiting for the package to be updated, which will hopefully be soon if it’s maintained. From the [NPM blog post about it:](https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident) &gt; The event-stream package is widely used, but the malicious code targeted developers at a company that had a very specific development environment setup: running the payload in any other environment has no effect. This specific targeting means that, ultimately, most developers would not be affected even if they had mistakenly installed the malicious module. &gt; The injected code targets the Copay application. When a developer at Copay runs one of their release build scripts, the resulting code is modified before being bundled into the application
i'm not gonna dig through transitive dependency hell.. but if i need a package and he's the author i'm gonna look elsewhere. that's not difficult and is quite easy to do - its the dependencies of dependencies.. but ok you trust someone that screwed the community. good luck in your career of development.
I'd even go as far as to say that he knew full well what would happen and he possibly even profited from it. He's too smart and he understands the landscape too well for this to be an honest mistake IMO.
Thanks for the tip! This is really helpful. I noticed this now works on some, but it fails in the case of something like: import {connect} from 'react-redux' export default connect(...) Still it's a step in the right direction. Thank you for sharing!
By patching nodes module resolver. Every time something is imported or required the resolver needs to find the actual code to run. So patch the resolver to first look at permissions before allowing an import of a core library.
&gt; Do you even maintain any public popular repositories If that is a requirement for participation in the discussion, do *you*?
&gt; have taken over repositories when I was a junior developer with no history in maintaining repositories I think that should answer your question...
Next time you get robbed on the street because you stopped to help a stranger be sure to blame yourself, you're morally responsible for that, if that's what you believe. 
Hmm, that's weird. In the case of wrapping a component like that, for me it's still able to find all imports of the default export. Realistically, it *should* be able to, because all it needs to do is resolve all of the places where a file's default export is being imported, and this doesn't really depend on what is being exported. But I know that saying it should work when it isn't working for you isn't very helpful. :) Are you running the latest version of VSCode? As an alternative, you could try installing the 30 day trial of WebStorm. It should be able to chase down EcmaScript imports too, and in some cases will do a better job than the TS compiler will. 
Reminds me of Artosis' love for StarCraft: https://youtu.be/ykvlpUbGy6w 
Ha! You have that bug where when you resize window everything disapear, plus it seems previous writting did not appear on my new user. It would also be nice if you'd use a router of some kind and have the room in the title. https://drawthings.fun/roomName when you can just copy and paste it for people to join 
When I check Netflix, I see $200 as senior dev. $300 is what the directors get paid. I've never seen a $300k js job ever. What does "total comp" mean? And do you live in San Francisco? That's the only place that I could imagine that level of pay exists. Like I said, I know people at Google (2 senior devs), and one make $180, and the other makes $145.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. **IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.** (emphasis mine)
&gt; NPM should maybe have more robust mechanisms in many places along this chain That's like saying a car should maybe have functioning brakes just in case it gets pointed at something you don't want run over. At the end of day, we can point fingers at anyone we want, but it doesn't change the fact that NPM is totally broken.
thank you battle
thank you L10
thank you scalco
Just because you publish it with a license doesn't make it ethical. 
\&gt; \`92% chunk asset optimization\`. I hope you like podcasts! That sound author is using webpack production mode for development... &amp;#x200B; &amp;#x200B;
I actually feel like the answers to these questions are a bit more nuanced. &gt; is javascript object oriented? There are multiple ways to answer this and they would technically be right depending on your definition of OOP because there apparently there isn't a standard definition. Kyle Simpson likes to say that JavaScript is only of the only true OOP languages because almost everything you interact with is an object. Other people [like this person](https://stackoverflow.com/questions/107464/is-javascript-object-oriented/108773#108773) have the opposite opinion. In the end, whether or not someone says JavaScript is OOP based depends on what the person's definition of OOP is. The definition of "Prototype based programming" [according to Wikipedia](https://en.wikipedia.org/wiki/Prototype-based_programming) is: &gt; Prototype-based programming is a style of object-oriented programming in which behaviour reuse (known as inheritance) is performed via a process of reusing existing objects **via delegation** that serve as prototypes. JavaScript definitely fits the bill here since objects will **delegate** property access to another object when they themselves don't have the property. In JS, the delegate objects are called a "prototype". JavaScript is a language that allows you to implement and use paradigms of functional programming (RamdaJS and lodash/fp are examples of this), but, I'm not totally sure whether or not it's considered a "functional language" because I don't know what that means exactly. Looking it up, apparently ["there's no accepted definition of functional programming language."](https://stackoverflow.com/questions/3962604/is-javascript-a-functional-programming-language) 
Or hunter2.
Lets start paying these maintainers!! And have a good system for scoring the reliability of a module.
Total comp is salary and stocks (which can be sold so it really comes out the same). Check out levels.fyi, Glassdoor is wrong.
&gt; A random guy walked up to him on the street, Dominic gave him a mask and a shotgun and shoved him into a bank. What could go wrong? I think thats a bit unfair; its more like a random person wearing a mask asked him for the bank vault keys, and he tossed them over because he was tired of carrying them around. He didnt know the guy was a a bank robber, and didnt bother to notice he was wearing a mask. Dominic should have either opened a patreon style request for support, or else marked his project as deprecated and started shutting it down. What he did instead was irresponsible, and he will pay for that with his reputation. I'm sure plenty of people would have jumped to fork it and make a new version or else dumped the repo and used node builtins instead. There is even a chance that he might have gotten funding for a while. Now those options are gone, and so is any chance of him being trusted. 
I agree, I let my personal feeling write that comment.
&gt; But that's not going to be fixed overnight. It may be mitigated to some point via technical measures, but it's never going to be fixed until JS devs wake up to the reality that libraries with loosely coupled upstream dependencies should be regarded as poorly engineered and unsuitable for serious use. 
We can't see it if you just put *******.
I learned Angular before React, but I knew something was wrong even as I learned it: a certain unnecessary complexity and set of limitations that shouldn’t have been there. Two weeks later, React was released, and I knew immediately that React’s model was superior in many different dimensions, but it would be a few years before management allowed me to switch. I don’t think I ever loved Angular.
AngularJs is surprisingly complex compared to most other frameworks. I started with React, and then worked with React-Redux (highlighting different front end paradigms, not that they are different tech stacks). It took me a long time to get the hang of Angular, especially when it came to scoping and providers. I ended up working with Angular for ~1.5 years, and really started liking it after a while, but the learning curve is extraordinarily steep compared to React and Vue, especially when it comes to the digest cycle. I just started working with RxJS/Reactive programming, which I am enjoying, so that wouldn’t be a downside to me trying Angular 2-6, but given my experience with Angular 1.4-1.7, I have no interest in learning Angular 2-6 if it is anywhere near as complex as 1, especially when there are so many more elegant solutions out there
Hyperapp :))
Well.. &gt; One of the users directly controlling more than 20 million downloads/month chose to improve their previously revoked leaked password by adding a ! to it at the end. &gt; One of those 4 users from the top-20 list set their password back to the leaked one shortly after it was reset (so it got reset again).
When you use an npm package, do you vet the author in any way whatsoever? Do you do a background check? Do you look at their twitter feed? GitHub history? Or do you just install the thing and not think twice? Dominic did what he thought would best suit his users. He handed over the project to another maintainer, which was two seconds of work more than deprecating the repo and npm project. When people used Dominic’s package did they have a system in place to make sure he wasn’t a malicious author? Of course not, no one does that. If anyone does they’re in a rounding error of users. And people who don’t have such a system in place absolutely can’t complain about what Dominic did because for all they know the hacker could have been the original author and they wouldn’t have known any better. Dominic has zero blame for operating exactly how absolutely everyone in the npm ecosystem operates all the time by perpetuating high risk code sharing. It *IS* the npm ecosystem.
Coming from an Ember background, I had to work with Angular for a year and a half. All I can say is that it was the worst experience I ever had in programming. The documentation was indeed a mess, the way props would be passed along components or other controllers was horrible, and scopes were so prone to bugs. I had the unfortunate luck of working with big projects written by entry level programmers, I don't necessarily blame them for my bad experience, I just think Angular couldn't notch them in the right direction with the right design patterns right from the docs, not to mention the amount of patches and changes Angular went through only contributed to a whole mess of deprecated methods and code structures within projects. Almost the entire time I was there working i spend the majority of the time fixing bugs and updating and rewriting projects.
Wow ridiculous. Everyone knows if "password1" is compromised you change it to "password3" to throw off hackers
Yo Angular is so ugly that people go as it for Halloween. Yo Angular is so fat that I ran around it twice and got lost. Yo Angular is so stupid that it tried to drown a fish. Etc. etc.
&gt; If that is a requirement for participation in the discussion, do you? Not OP, but I do. And it sucks when it's software a LOT of people are using and you *aren't*. The biggest issue with open source is few want to contribute, even fewer want to pay but you bet your ass if you don't immediately respond to every issue or pull request those same people will bitch endlessly about the lack of communication. And your attitude here is only going to hurt open source more and more because it becomes less and less worth it. I still contribute, I still own packages but now, instead of trying to carefully hand off packages to someone in the community, I just deprecate them and autolock issues. That is *not* in the spirit of open source, unfortunately choosy beggars who want everything and to give nothing have ultimately made open source fun only if your module remains unpopular.
So many people like the person you replied to that are upset because they got made to look dumb by being impacted by this and don’t want to take responsibility.
And it's completely secure. If that password is discovered, either the operating system is from the NSA or his partner/children/parents sold him out for money
Thanks for your feedback! I'll fix this stuff today. I'm going to call the resizing bug a feature till it's fixed to make myself feel better lol! Thanks again, these kind of comments are very helpful!
he gave away a repo to an account that was like a day old without any checks into who he was handing it off too... for someone with "security" on their profile - this is bad.
And NPM will prominently display the same notice on the NPM package's page -- that it is no longer maintained. For example: &gt; This package has been deprecated &gt; Author message: &gt; fetch types are now provided by '--lib dom' https://www.npmjs.com/package/@types/whatwg-fetch
Angular is terrible and if i wasn't being paid to write in it, id never have learned it. Paycheck &gt; Framework.
Computers cannot read right to left so I always use drowssap
Wordpress = elementary school, React = High School, Angular = College. Sure Angular is intimidating, complex, and not for everyone, but making fun of it sounds kinda ignorant.
I'm still torn on zero responsibility. I like to think of myself as an ethical developer and just can't get around that Tarr just threw the keys to some random with one hand and with the other hand wrote a post asking for money for his continued work on 300+ npm modules he's created. It's more the entitled attitude Tarr exudes not so much what happened. If Tarr had given a solid mea culpa and said it should be a lesson to both authors and consumers of OSS, we wouldn't be talking about it two days later. Instead he acted like a child.
It is a full framework that uses advanced programming concepts. React is really more of a library. I assure you the creators of Angular were not confused dummies.
I'm surprised this kind of data doesn't come up more. Load times and parsing times is something I've been harping on about for ages[1] but these days it feels like no one cares. [1] https://mithril.js.org/framework-comparison.html 
Even that is unfair. The guy wasn’t wearing the mask, he just had it in his pocket. Dominic didn’t know if the new maintainer had malice in his heart or not. He didn’t really check either, obviously in hindsight that was a mistake. But nowhere along he line did Dominic ever do anything malicious or reckless, just careless. Actually careless vs reckless driving is a good example. He just changed lanes without looking, he didn’t serve back and forth trying to ram people.
I’m old enough to remember when that clause meant “I am doing my best here but if there are bugs, I’m sorry” and not “I’m tired of this so I’ll sell it to a crypto hacker”
In my experience, nobody that runs a serious business would be interested in _hiring_ a part-time employee who only works outside of regular office hours. I'd say you have four options: 1 - continue to do freelance on the side. Note that's probably going against your FTE contract, but people often get away with doing it anyways 2 - run a consulting business full time. Note: you'll likely need at least a LLC, and you'll probably need to find an accountant to help with taxes 3 - find a job that pays more 4 - uber and save like a madman Option 1 is low effort, but also not steady. Option 2 is hard (been there, done that). Option 3 is easy if you're in a high demand area, otherwise hard. Option 4 is not glamorous, but if you really really need that extra cash, doing early morning/late night airport runs is a thing...
This whole episode makes the javascript community look like shit. Like a bunch of fucking noobs. At the end of the day its on the dev to review the code they ship. Anyone who would rather bitch and try and blame anyone but themselves is a child.
That's the problem with community/open source projects - everyone can contribute, but sometimes nobody wants to. In large companies like Microsoft there is a lot of people who can work on single project, teams change over time, people come and go, but project is maintained. 
Nice, thanks.
Disable button 3 by default and add an event lister on button 2 which enables button 3. 
HTML &lt;div class="buttons"&gt; &lt;button id="button1"&gt;Button 1&lt;/button&gt; &lt;button id="button2"&gt;Button 2&lt;/button&gt; &lt;button id="button3" disabled="true"&gt;Button 3&lt;/button&gt; &lt;/div&gt; JS (function() { const button2 = document.querySelector('#button2'); const button3 = document.querySelector('#button3'); button2.addEventListener('click', () =&gt; { button3.disabled = false; }); })(); **Disclamer** This code was written in Reddit, and not tested. It may or may not work, however the logic of what needs to be done is expressed.
&gt;good luck in your career of development. So, your intention is to waste time digging through the dependency hell that is NPM because you have a personal vendetta against a member of the community who made a mistake? If I were your employer, or your client, and found out that is what the money I was paying you was being spent on rather than developing the application or feature I am paying for, you'd be on the street looking for a new job.
So someone took over his project? That's not uncommon. So maybe he could've been more careful about who he gave publish rights too? It could just as easily been a very prominent person who had their account hijacked. Even if it was his account that published the code (it wasn't) he could've been hacked/social engineered by someone and they published the malicious code in his name. He did a thing, he published it, we used it. He has no responsibility. A thank you is in order if anything. The issue here is; how do we as a community stop relying on these widely used projects but owned by a single person? How do we check our decency trees for malicious code? Better whitelisting in our apps. Awareness. Information. I don't know where I'm going with this but who cares what he did. If he got hacked, would we've blamed him this hard? Seems just a likely to happen. Somehow we got the bad code in our projects, how can we avoid this in the future? 
i guess i wasn't clear. no i will not do that. but if i need a direct dep from him, i'll look elsewhere. shit i use that depends on his stuff i can't control bc as i said. i am not gonna look through transitive dep hell. good thing i don't work for you bc you can't comprehend written statements.
Vue FTW, best parts of angular and best parts of React, plus more, IMO
I just looked up the quote and realized I entirely misquoted him. The actual quote and link to the quote is in the edit. **oop**s
Interesting that people treat this as a completely black or white situation, although perhaps some people are misunderstanding. I see that one commenter here even pulled up an OSS license. The issue here isn't a legal one, it's a moral one - the OSS license has 0 bearing on the discussion (I don't think anyone is threatening legal action against him). Imagine you're a toy maker next door to a preschool, but then one day you get bored and close down your factory. Instead of disposing of all the small parts that a child could potentially choke on, you just leave them sitting there. You close, but don't lock the gates, and the divider between the preschool is shoddy and easily scalable. 5 years later a kid sneaks in, chokes on a toy part and dies. Legally, you're probably not at fault, it really is an unfortunate accident. But, you could have removed a potential dangerous situation - if you had put in the correct level effort. Obviously, this is just an analogy, so I'm sure there are holes. But the point is, while it may make some developers uncomfortable that they have to take responsibility for things they put out in the the world (no matter how well intentioned), we do have a moral responsibility to make sure the code we write doesn't cause harm to others through negligence. On a scale of 0-10 of how much he is at fault, it's probably a 2. He's slightly at fault, and now has correctly retracted the package. I think his lack of apology (and lack of realization of his negligence) is what's getting people hung up.
It's weird - there was a clear moment when there was opportunity to make the correct decision or the wrong decision, and obviously the wrong decision was made. Instead of saying so (and I think most everyone would understand the unfortunate reality of the situation as a whole) - he deflects and blames the entirety of the results on something else. It just comes off as... not responsible to me.
Charge more so that you don't require supplemental income.
Agreed.
That's the real issue here, you can't just implictly put random people in charge of the well being of hundreds of projects
Although I totally agree, it’s not as easy as “vet package before upgrading” unless you took a security conscious approach to your setup in the first place (which is not the npm default). Even if you did not upgrade any root level packages, and even if you have package-lock enabled, a sub-package could be upgrade by npm install. It requires discipline around initial package vetting AND using npm ci for guaranteed AND EVEN THEN there’s still not really time to vet all the sub packages of say, create-react-app. At the same time, obviously this all needs to be vetted. At each level of the ecosystem. I’m not going to expect a brand new developer to know how to do that, however.
It's slightly better, I suppose, but even still, Python classes and Ruby classes, for example, are implemented as objects linked to other objects (aka delegation) just like in JavaScript.
I've used [https://stimulusjs.org/](https://stimulusjs.org/) (from the Basecamp team) for minimal, additional functionality to a relatively static site. It's not opinionated about markup, uses data-attributes for DOM access. 
[https://svelte.technology/](https://svelte.technology/)
I will push it to my gitlab and post a link when I get home from work
&gt; everything to do with the fact that they couldn't solve the same problem in vanilla JavaScript without a framework People need to understand what the code they're writing is doing. I once saw someone blame the state management library when the problem was he was `await`ing the axios promise in a callback sent to a `forEach`. He lacked knowledge of how asynchronous programming works and didn't even know where to begin identifying the problem. I guess it could be a minimal requirement before they start coding inside a framework that one should be able to code the dreaded TODO list app or something similar in vanilla JS. Simply because they will have to demonstrate ability in mastering several important concepts (like callbacks, working with the DOM, etc.). They will also appreciate what React does to help them. My go-to example whenever I become familiar with a new framework or a new feature (I did it for React hooks and will do it for Vue when I will have a look at it) is a one-row spreadsheet where you can add a new cell and remove random ones, and the sum of the numbers is computed on each change.
I was thinking about adding it to my example list, but failed to formulate *the* user case in one sentence — would you try?
Wow, this one is amazing! I was looking for something like this about 2 years ago, went with jQuery. Many thanks!
I should have crossed out the entire sentence because it was entirely wrong. He wasn't saying that JS is the only true OOP language because it uses OLOO, he was saying that OLOO itself is true OOP, which I'm sure people will debate him on for years to come.
Do they have to be DOM based frameworks? [Babylonjs](https://www.babylonjs.com/) is pretty cool. Its a framework for 3D applications, so really specific about its use case. Maybe some people would call it a library, but it is very opinionated about how you organize 3d objects so it meets my definition of a framework. Either way its an underrated project. 
He could have simply marked it as deprecated and abandoned it wholesale. 
[removed]
No one gives a shit about law here numb nuts. Dude has a reputation to protect as well as any legal obligations he may or may not have. His name was on it. He owned it and he blew it. Irresponsible behavior should be shunned legal or otherwise. 
He says somewhere in that thread he had "hundreds" of packages he wanted to stop maintaining, and there was no way to do it in bulk without writing a script.
The JS community is earning it's reputation as a bunch of YOLO noobs throughout this whole ordeal.
I actually have evaluated Babylon when building a 3D visualization library! At that time only Three.js was in any production-ready state, though. I had UI frameworks in mind, but thanks for giving me a heads-up on how it's doing.
Cycle.js - write your frontend using FRP HyperApp - write your frontend in The Elm Architecture 
You should be tracing the dependencies of your project regardless. Especially if It's a large project with a lot of users. It's a huge security vulnerability. Why this community seemingly doesn't give a shit about potentially malicious code being installed in their projects is baffling to me. You own the result of ANY code run by your codebase. It's YOUR responsibility to vet it before exposing your users to it.
It can be both the node community's fault for shitty practices and his for playing into it. They aren't mutually exclusive
OK, then [hoplon](https://github.com/hoplon/hoplon), [om](https://github.com/omcljs/om), [rum](https://github.com/tonsky/rum), too — write your app in Clojure. I'm not sure this qualifies as a *use case*, though.
I’m a Vue guy 😁
Would have been interesting to see vanilla JS / static HTML stats for *baseline*.
I think Marko was developed as a client-side library with high-speed server-side rendering.
Why learning prototype ? &amp;#x200B; Just to know more about JS ? It's fine if you learn it just fo curiosity or you are using it for a little library. &amp;#x200B; You want to do a complex ES5 only application based on prototype ? You are doing Object Oriented JS, and it's unmaintanable. I'm working on a project for a big company using this pattern and it's so hard to maintain. Their argument: performance. But recently, we found something better. If you want better performance and better maintainability, just use the famous Module Pattern. (I have a JSPerf proof but can't find it atm. I will update this comment soon) When prototype is better ? You can use it for a little library which needs to be ES5 and classes. Prototype are used to create classes. &amp;#x200B; For an ES6+ application ? There are many patterns out there for performance. Prototype is more performant than ES6 classes but please avoid Object Oriented JS (pain). Much better than OO JS ? Composition pattern: [https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea](https://medium.com/javascript-scene/composing-software-an-introduction-27b72500d6ea)
Streaming, nice. I don't think they explicitly mention this on their website, but fast SSR sounds useful for some cases.
I've seen so many weird analogies to this situation that don't make sense to me, and this is one of them, I'm struggling here.
Generally here is how we work. We have UX, PM, and Engineering orgs. The SCRUM team is fully contained within the Engineering org. UX/PM are external stakeholders to the SCRUM team. 1. PM/UX will come up with conceptual thing they want to do. 2. Engineering will be involved to see what sort of effort is required to deliver what PM/UX are talking about at a very high level (does the data needed exist in the systems, do the services exists, etc). 3. PM/UX will do some research and come up with some initial wire frames or lo-fi mocks. 4. Engineering will review them to ensure they make sense from a technical stand point. 5. PM/UX will do some user validation and continue to refine the mocks. 6. Engineering will start to lay some of the ground work for the feature and will start building toward the mocks from UX/PM. 7. Standard Agile stuff happens, UX/PM/Engineering continue to work in tight feedback loops until the feature's MVP is ready
Hello!!!! Just subscribed to r/javascript now and I think it's great! I am a intermediate programmer, and I really like to learn while building awesome things. I have been studying and practicing my skills, but I don't feel I have done enough for open source. Now I want to share what I learn with others. Anyway, after a lot of verbose, I am implementing a Spotify Web API in Typescript. Please [review my repo](https://www.npmjs.com/package/easy-spotify-ts), I do not plan to stop developing it, thanks!!!
I never did upwork myself; I usually found work via networking / word-of-mouth. Early in my career, I literally went through the yellow pages cold calling people. In my experience, in Canada (you're in Toronto, I assume?), the easiest way to get a significant pay bump is to change jobs. My wife got over 20k pay increase from just a few job changes over a couple of years. Get your resume on recruiting databases to get on recruiters radars. Jobspring is one that often approached me with some high pay leads (i.e. in the 120k+ range). Re: permanent residence + remote work for US companies: so here's the thing, with a PR, you are indeed free from having to have a canadian employer (for the work visa), but you may still run into issues with payments if you're working w/ a US employer. Ignoring the fact that most employers are hostile to remote work, some will not hire non-americans due to visa concerns and some due to taxation concerns. This is why I incorporated a consulting business. This way the US employer paid my company, and my company paid me. Again, good to get an accountant, because there's quite a bit more bureaucracy than just getting T4s at year-end from a canadian employer. Yet another option is to apply for a non-remote job in the US and try to go for a TN visa. Bay area employers often pay for relocation and immigration stuff. I'm doing my green card process right now through Uber. Judging from your current situation, it's probably a bit too early for this option, but just something else to keep in mind if your end goal is to get US-level salaries.
Youre a Towel
*Confused*
YOLO is the perfect way to describe the JS community. The JS community does have specs of gold .... those specs are just hiding mountains of shit underneath it.
i finished bootcamp this year. And along this journey I had to learn angular and react. I can confirm your statement. Learning angular was like pulling teeth and i am not a bad learner. I felt so lost at times. React documentation was way better.
It's a neat solution to a non-problem IMHO... it doesn't come up often enough in my work to warrant extending the language for it. But if the majority of devs find it useful, go for it.
Tribalism is an interesting beast. Happens in almost every industry.
Sorry, no, it isn't the 'npm ecosystem' to hand over your project used in millions of other projects to a complete stranger with absolutely no clue if they are malicious. That leads to the pain we have witnessed here. It could have been much worse, too. If someone can't handle the responsibility of maintaining a popular repo, then they probably shouldn't be publishing it. But that's the problem with the entire programming world - there are far more amateurs masquerading as professionals, and the result is ridiculous shit happening like this case. It wasn't the first time, and it certainly won't be the last time. 
Nope. What he did absolutely was *reckless*: reck·less /ˈrekləs/Submit adjective (of a person or their actions) without thinking or caring about the consequences of an action. 
Do you look into the background of authors of packages you install? If not, the original author of the package could have been the malicious actor. You would not have known any better. Domenic handing the package off to a stranger was no dumber than you installing a package from a stranger. That’s the npm ecosystem. There is no reason to trust any packages or authors. There is nothing built into the system to encourage or account for or track that trust anyway.
&gt; UX/PM are external stakeholders to the SCRUM team Interesting that the UX get to say what gets build. How much lead time does the PM+UX team get ahead of implementation ? How do you test your design/concept hypothesis? Does this also mean you have a long time between Idea to Engineering Completion ? Thanks for sharing !
hunter2hunter2hunter2 Does that look funny to you?
Sc2 player, front end dev here. Couldn't be happier seeing your comment, have an upvote. 
&gt;Domenic handing the package off to a stranger was no dumber than you installing a package from a stranger. Wrong. When he did it, it affected millions of other people. When I install an untested package, it often only affects me or maybe the company I work for if there is a significant breech as a result of using malicious code. It doesn't usually affect you if I decide to install any random NPM package. &gt;Do you look into the background of authors of packages you install? The problem with your argument is not that I have to test a package I install, but also every dependency that a package itself has, and the dependencies those packages have, and so on, and so on.. so it's really pointless to even go down the road of NPM and reviewing code, because that's all I'd be doing. And yes, I have reviewed every line of code of every dependency at some jobs, because that was in the job description, and necessary for compliance and the lawyers made sure we did certify the code we used. We had to write a lot of our own code, too, instead of using npm for everything. The few projects we did use, we also contributed to and knew the code well. But this is not the vast majority of uses cases. When I first encountered Nodejs and NPM at a job long ago, I told my boss he was fucking crazy if he thought this was a good idea. I still think it's fucking crazy, but that doesn't matter when working at start-ups - traction is the only thing that matters. It really depends on where someone works and how smart the management is if they allow using random NPM packages. 
I think that repeating `this` for each parameter can quickly become annoying. But we have not to use `.`, only something easy and fast to write but not misunderstoodable.
It's happening all over this thread. People see their own incompetence in the whole situation and are downing anything that isn't praise or dismissal. 
use something like https://github.com/MikeMcl/big.js/
I think angular holds up well in the enterprise world, with some of the bigger applications. The bigger your app gets, the more you benefit from using typescript and doing things the angular way. Not to say you can't do this in react as well with the right setup, but out of the box you get more with angular. I think one reason react is so popular is that most web apps are fairly light weight so angular feels more frustrating than helpful. I have been both frustrated and pleased. I
Seconding big.js it's great! So just keep all numbers as strings or Big.js instances and it should be fine
Thanks for the suggestion. I was hoping there was an accepted solution that wasn't a library but I'm seeing now that there is not one.
You gave me and idea, I've updated the readme :P
:-) I heard there was something like that in C#, too?
&gt; Furthermore, I don't like reassign this like that. You should remove this part. You **cannot** assign to `this`. It is an error trying to do so. ("ReferenceError: invalid assignment left-hand side")
ty. Too much time spent on pc. I've replaced it with object assign.
Not my industry.
The documentation is terrible. It's the same issue I have with microsoft's documentation. It's all here's all the arguments and none of the why or what
My favorite is Vue, but I think it's more closely related to AngularJS, which would make sense as I think that's Evan's background. The Vue instance is an improved form of an Angular controller; the latter is a gigantic kitchen sink where you can add anything anywhere, whereas Vue provides separation between `data` and `methods`, etc.
The way props are passed being a pain is solved with NgRx (Redux for Angular basically), but it just adds to the list of things to learn is is pretty complex (I still haven't gotten around to it).
&gt; Interesting that the UX get to say what gets build They don't really get a say in _what_ get built but they are partners in the process to ensure that what is getting built meets our internal standards. PM is really the driving force of what gets built. &gt; How much lead time does the PM+UX team get ahead of implementation ? How do you test your design/concept hypothesis? This can vary. UX/PM have to get on the same page about _what_ they want first before engineering can give any sort of input really. The concepts/designs are tested by UX during their research which gets incorporated into the mocks as they iterate on them. They usually have identified a subset of customers that they think would be interested and work with them to refine these things. &gt; Does this also mean you have a long time between Idea to Engineering Completion? It can be because like all other teams there are competing priorities and we have more work than we could possibly do. So if an idea comes up that has a lot of promise/traction during the initial discussions between UX/PM and customers then it gets prioritized and could be completed within a few months time. We attempt to spend time up front to ensure we build the right thing instead of what we're being asked for. 
https://www.youtube.com/watch?v=OLmVTr9hq8Q
Hell, the author of Manning's latest book on Vue.js released last month, doesn't even know how `parseInt` works
30+ years in the software development biz. I've used cobol, fortran, perl, C, C++, python, php, sql, various dialects of shell scripting, java, yada, yada, yada. Javascript is like anything else—once you grok its idiosyncrasies, it's fine. Every language has something to whine about. 
Why put something out for other people to use if you don’t want to take some responsibility for it? If it is really ok for people to turn their projects into malware then we might as well give up on open source right now.
This is one of the funniest tech articles I've ever come across. Brilliant.
I only use prod mode in prod and staging. Before deploy, staging is tested, develop is for quick feature checks and does not use prod mode Things do come up, but pretty rarely I would say
Not just on the package page, but in the terminal when you install/upgrade it too.
Agreed, having made numerous things in all 3, I feel that Vue is the most intuitive to me.
He's not using SSR which is wrong in 2018. Vue's startup performance will also supposedly double in the next version. Looking forward to that. But with SSR there is essentially no cost to UX.
That's an interesting tidbit, I hadn't thought about that. Thank you.
I had no problems with this. The whole screen worked for me. But when the screen rotated the screen got cleared. 
first I'm glad you came to answer in my post, you're saying a ton of good stuff here thank you So I had a nice little network in my country of Origin but I didn't build anything in Canada yet (I'm actually in Nova Scotia) I just completed my first year here, I guess I have to go to the events and try to interact with the community. I totally agree that changing jobs is a way to get a better salary, I got offers that would pay me around extra 30k \~ 35k but unless I get my PR I can't change jobs because I am kinda bound to my employer in my work visa, I'm planning to change jobs as soon as I get my PR because I know my current employer doesn't give considerable raises, I have two co-workers who changed jobs mainly because of the salary, and a few months back they got an offer with the salary they have asked for + a little bump because the company needed them here and they accepted, I just feel like it's stupid for an employer to have his best devs go away because of that. re: incorporated a consulting business - does it mean you have your own company name etc and you alone act as a consultant, or you joined a someone else's consultant business? My concerns about this subject are related to getting new clients/maintaining clients, having to deal with a ton more stuff that only coding/project-managing/releasing etc which usually causes a huge amount of stress/work-life balance, so that's what I have in mind but I'd like to have your output on that as you're currently doing it I didn't know about this US issues with payments, about moving to US and bay area I've given that some thought in the past few months and it feels like you can get 120k salaries at some point but your expenses will be so damn high it doesn't worth it, also my country of origin is Brazil and now in Canada I feel a good life quality improvement, seems like going down to the US would increase my salaries but would bring back all the issues I'm avoiding from Brazil (security, expensive healthcare, basically a lot of shit) so because of that I am still uncertain if my next steps will lead me to move to the US but you know my vision can always change with time :P do you any thoughts about this US stuff? Also, I am self-taught and I was reading that US-visa sponsorship requires a diploma, would you know if that is really true as you're doing your green card process? &amp;#x200B;