&gt; which is false No, it's not. If they were optional you could omit them in every case. That's what "optional" means. You could say: "They are optional in most cases". That statement would be true, for example.
Alright, how about this: "They are optional if you want to create applications using JavaScript." Does that work for you?
This is a valid point. This code is more pragmatic than the contrived example of starting a line with an array literal. If you write good code, you should never run into an issue with no semis.
Honest question, have you used any of the new stuff or do you refer to traditional web apps, jQuery and fumbling around with div-soups and the dom? If you look at modern apps like Atom, VSCode, Discord, Hyperterm and dozens of others, they have made things possible that old tools couldn't produce if you sat a horde of programmers on it giving them all the time they wanted. Pretty sure many of todays most used, highest ranking apps are web driven. I have written applications using c++/# in several frameworks (win32, gtk, qt, flex, xaml, sl, ...), i wouldn't consider it today with tools like node around, react(-native), vue, angular, electron, etc. Making powerful applications, desktop and otherwise, in my opinion, is so much easier compared to how it used to be.
Exactly. I'm betting people are only downvoting it because of the language I used, and that's fair. Another fair point: code like that does exist in some forms in actual codebases, e.g. `[].forEach.call(someNonArrayObject)`, but again, there are better ways to write that.
Cool. For some reasons the download didn't start after I clicked Download (Firefox on Linux), but I saw it returned download-able URL from the API. 
You are of course free to misuse words of the English language. That's not a crime.
Webkit bug filed: https://bugs.webkit.org/show_bug.cgi?id=173141
I really hope that this will make it into browsers. The Date object is so broken, that it isn't even funny!
while your statement is true i don't see how not using semicolons reduces verbosity and readability
That best thing is also the worst thing. Distribution. 
Hi /u/deepsyx, the link for the github repo got cut off it looks like.
Not sure if it addresses all your concerns, but they do explain here why they chose to fork C3: https://github.com/naver/billboard.js/wiki/Why-we-decided-to-start-billboard.js%3F Seems like C3 isn't being actively maintained anymore. 
Ha! its a formatter, so its going nowere. Standard has been a thing before it existed. Same with prettier. Its just some peoples opinions, nothing more. The thing people dont seem to realize is you must go all in, because consistent up to 75% is non-consistent. As of now gofmt is a standard, same with elms elmfmt. Im sure theres more. My point is standard HAS an opinion, that you cant alter. Prettier is a good idea, but its still backed by the same ideology. This all will lead to forks, (elms format is a good example, simply because the indentation got people mad) How code "looks visually" is personal, like cars or golf clubs, we all have opinions. So why push this on others because techically its irrelevant. The way forward is two fold, all in or fold. Make all things non cofigurable (and force some standards someone likes) or have a config that make code only consistent in small groups, or individuals. 
Array.prototype.forEach was handy back in the ES5 days, because having that function expression there created a scope and it also let you capture the "loop counter". Now that we got let/const and for-iteration scope, we don't need that workaround anymore. The lifetime of temporary variables is restricted to that loop and you can also capture that loop counter without things getting weird. Nowadays, forEach only makes sense at the end of a chain (e.g. filter -&gt; map -&gt; forEach) or if that function you want to call already exists for some reason. Also, for-of is shorter and it reads quite nicely: for(let thing of things) { ... } You could even use const there if you wanted to. Bonus: for-of works with any iterable (e.g. strings work too).
Have you ever written code in languages like python? No semicolons and perfectly readable, no debate at all if they should be added or anything. Never have heard of a single complaint that someone had problems finding the end of a line/statement. Those are all arbitrary made up statements. If you use semis: fine. If you don't: also fine. Just stop pretending that there is so much more to it. Its 2017 now, we have better things to do than to argue over semicolons. These wont make or break the language or the code...
I just use semistandard. it's standard but with semicolons. no complaints
&gt;Honest question, have you used any of the new stuff or do you refer to traditional web apps, jQuery and fumbling around with div-soups and the dom? If you look at modern apps like Atom, VSCode, Discord, Hyperterm and dozens of others, they have made things possible that old tools couldn't produce if you sat a horde of programmers on it giving them all the time they wanted. Pretty sure many of todays most used, highest ranking apps are web driven. I have written applications using c++/# in several frameworks (win32, gtk, qt, flex, xaml, sl, ...), i wouldn't consider it today with tools like node around, react(-native), vue, angular, electron, etc. Making powerful applications, desktop and otherwise, in my opinion, is so much easier compared to how it used to be. The problem with newer frameworks is that they require modern versions of browsers; in area such as government offices, we still have to deal with internet explorer 9 (or worse, 6 *shudder*). With desktop applications, you only need a compatible version of Windows; the app does the rest. But having to support different browser versions is a maintenance nightmare, let alone having to deal with legacy code. Even worse is having to use server frameworks like JavaServer faces, which don't always get along with pure JavaScript. But to answer your question directly, no, I haven't had the pleasure to use a modern MVC single page framework here. Then again, we find things like forward incompatibility between different versions of a framework. Also, I still find myself scared by this nodeJS dependency stuff. I mean, having to download a JavaScript server just so i can get my dependencies right? I still don't know if it's really worth it. And finally, in a large company there's the issue of code maintainability, not everyone can afford to try out a new js MV** framework when the next guy to maintain the code is still learning how to use jQuery. Edit: autocorrect.
Absolutely true! I'm just saying that it's important to demonstrate that you didn't just fork, add a half dozen commits and then abandoned your fork as well if you expect to get people excited.
Yay! Rest/spread for objects. Also, you’d think they would be able to track down a higher res image for their article. 
Right on! I love Bulma and am now just getting started with React. I’ll definitely check this out. 
cheers!
Because, in JavaScript, whitespace (or lack thereof) does not always make the intention clear.
If I'm reading someone else's code and it has semicolons, it becomes pretty annoying. Preferences are preferences, ladies and gentlemen.
what about line breaks then? 
That is up to you, I am not saying JS is always unreadable without semis, only that it is always more readable with them.
Well, I don't believe you.
lol
It's a GET request. Unfortunately, the documentation is very bare bones and is clearly not meant for someone who's just learning how to interact with APIs. I know the link where I'm supposed to send the JSON object, what I need is to essentially know how to craft the message(i.e. how to implement it in Node.JS) and how to send it(what command does it).
We might be able to help you more if you give us more information about what specific API you are trying to use. A link to documentation or something would be helpful.
for-of loops don't give you the index by default, you have to do something annoying like: for (const [i, thing] of things.entries()) I'm pretty sure `forEach` is faster in those cases too. I seem to remember at least a couple of other cases where `forEach` felt more suitable in my code, but I can't remember what they were specifically.
How does it scale? Anti pattern is sometimes useful &amp; obvious, but going with anti patterns for everything is a stupid decision IMO. Frameworks are for greater good. If you don't need it, don't use any of them. But when "No framework" is listed as a key Mantra for yet another js library, I simply find it as dumb &amp; full of madness. :-/
So, in other words, I'd like to know the modules (or maybe in-built functions if there are any) that I could use to send these requests
The commonly accepted definition of TypeScript is that is it a superset. The things it doesn't do are generally forward looking, not approved by the spec yet or things that are technically very difficult to transpile. You'd have to provide a few examples of what (approved through TC39) specifications/features you feel TypeScript is missing. And it should be noted that Typescript doesn't generally start implementing spec as soon as Babel, for example, but it is up to date with the latest standards.
https://github.com/prettier/prettier &gt; Prettier is an opinionated code formatter. Basically it formats your code to give it one consistent style.
Sure, I'm just giving another example where you might prefer `forEach` - it's not necessarily as clear-cut as you think it is.
Perhaps because I'm using Duckduckgo I got slightly suboptimal responses.
I started programming with python actually and love it. I also have lots of JS projects written with no-semi, but most are with semi. I'm not arguing whether you should or not, I'm just arguing his points against it. I agree, neither is better.
I don't understand the desire to abuse a badly designed parser correction system, meant as a last resort, just to avoid a single character. It'd be like insisting on using try-catch statements instead of if statements, because you don't want the code to have code path branches.
Great post by Peggy Rayzis. There was also a good discussion thread about [Apollo and Redux over in /r/reactjs](https://www.reddit.com/r/reactjs/comments/6ec4dz/i_made_a_diagram_of_the_design_of_my_first_react/) recently.
That's just obnoxious
Not sure how popular it is, but my team and the entire project we are on uses the Java style guide from Google. That uses 2 spaces. 
&gt; We do Well technically, they are not _really_ required: let foo = 'asdf' void [1, 2, 3].forEach(v =&gt; console.log(v)) But yes, semicolon is a much more obvious alternative.
No they aren't really. I've never used Standard as a formatter, only as a linter.
The only problem with no-semis for me is that 100% of the javascript code-bases I've touched professionally used semis throughout and it's honestly annoying have to switch back and forth between that and some of my personal projects using standard.
I’ll give it a try and show you the results, thanks!
I can bet that it's impossible to translate some very complex app to CellJS. Actually, okey, it _may_ be possible, but that's not my point. It would be pretty hard to read, maintain and scale.
A ["pretty printer"](https://en.wikipedia.org/wiki/Prettyprint) for JavaScript.
ITT: code style preference. But what the fuck happened on 03-19?
Expanding on what CreativeTechGuyGames said. You can play with APIs using a tool call Postman. Its a pretty popular tool.
Stuff like that happ
Then why not just use a map?
Fair enough. I got used to considering "ES" what is stage-2, stage-3 proposals.
&gt; Do I have to use webpack? How would I link all of the gui images without including them each in the main js file. How do I know what images are even there without opening the node_modules folder? 1. list the dependency in package.json (note they dont have to be NPM you can use git repos too). 2. Use NPM install / postinstall script event hooks https://docs.npmjs.com/misc/scripts#description to trigger a script after the install cmd has been run. 3. The script should either create a symlink to the required directory within node_modules in your main project directory, or directly copy/move the files out of it to a folder of your choice. &gt; Can this be done if using browserify or roll up? the task API whether you use webpack, grunt or gulp is irrelevant, i'd recommend watchify over browserify though. &gt; Is there another way without using the above tools? Nope, npm/yarn has well and truly replaced bower and it has been that way for a few years now.
&gt; That is up to you so you pref semicolon to line breaks? are you saying that if you encounter an line break with out a semicolon? it's just unreadable? IMHO if you follow what ever the coding styleguide says about line length (whith's normaly ranges from 80-100 chars) it's easy to see when the statement ends, semicolon or no semicolon 
Because there are so many articles "introduction to ES6 features", "ES6 overview". There were at least 5 of them in last three months.
There seems to be some authority ("wo don't need that workaround anymore") behind your reasoning. Is there a documentation of idiomatic JavaScript as it is meant by the standard committee?
Check out previous threads in r/digitalnomad, lots of devs over there talking about working remote/freelance. Less relevant if you're looking for an in-house job in another country.
Oh, you mean like https://twitter.com/juanjovazquez/status/810174227202605056 , https://twitter.com/DanielaSfregola/status/809043490382446592 , https://twitter.com/andy1138/status/807669162797568000 , https://twitter.com/li_haoyi/status/807475285344010240 (comments on the previous iteration of the same talk at Scala eXchange 2016) :)
He's an idiot, HTML, CSS and JS is the holy trinity of web design, it's useless to learn one of them without the other.
Idealogically, i get what you're saying, but in practice, people who are used to looking at it one way (end of line) are going to think the other way looks weird. It's also somewhat obtuse - if you started every line with a semicolon it would be one thing, but if you only do the lines it is required for then it just seems strange/surprising when it is there.
Unless you're writing JS exclusively for Node, you'll probably want to at least have a basic understanding of HTML and CSS. 
I also use DuckDuckGo. There isn't that much difference when it comes to searching on stackoverflow. Tutorials and such articles are a different matter though. Your instinct to pick the right results and making the right queries builds over time.
What the fuck is the value of learning JavaScript without knowing HTML/CSS?!?!. Its a fucking Web language! Your friend is a fucking idiot.
Don't use map for side-effects. Map is for turning a list of things into a list of other things.
There should be a library in JS to parse xls files directly. If the browser can have write access to the share you can pretty much run an app on that. Though that ain't going to be easy ..
`void` is probably the only feature of Javascript I essentially know nothing about and really don't care to understand. 
What are examples of practical applications of this?
This is cool, can you please add a select all button to select all the videos! also the zip that would be downloaded rename it to the name of the playlist or to the first video Keep up :D
You can write servers with js. I'd call that useful. That being said, learning html and css is so easy it doesn't make sense not to since it doubles your areas in the stack where you are effective.
To learn JavaScript I'd recommend "The Principles of Object-Oriented JavaScript". https://www.amazon.com/Principles-Object-Oriented-JavaScript-Nicholas-Zakas/dp/1593275404/ref=la_B001IGUTOC_1_2?s=books&amp;ie=UTF8&amp;qid=1497101229&amp;sr=1-2 Zakas is a good writer and he knows JavaScript.
Interesting, the network inputs in the demo are just based on the bird's y position relative to the closest pipe's y to the right. 
Try RE:DOM, works with all browsers you can imagine! 😉 https://redom.js.org
Which is bad style.
I struggled with JavaScript while mixed with DOM manipulation. When I switched to pure server side JavaScript, using NODE, I picked up JavaScript a lot easier. Once I had a solid foundation, I went back to manipulating the DOM, and it was much easier. I still struggle with CSS though. So, your friend is right, but as others have said, long term you will want to learn HTML and CSS as well.
Maybe try using firebase?
If you are not financially dependent on your job- try to convince someone. If that fails, leave the job and try to get one as junior dev :D
What are those servers gonna serve to the users? More pure JS? :D I guess it's technically possible to get some useful work done without knowing HTML or CSS, but it's skills you generally need to get actual work done.
"standard" is just a predefined configuration for lining that some guy really liked. He decided to call it standard for some horrible reason. I don't think he cares too much about its adoption rate. 
These static web build tools will even watch a directory and rebuild the entire website anytime you update a file in that directory. The output directory can even be configured to any destination you have write access to.
Well, if OP manages to become a REST service developer who never ever has to write any front-end code (not even for testing his own REST services) then I'll eat my hat.
Just strings for the keys and an integer for the value that I can increment.
Give me an example of a row of your key and stings/ints
{area: "Chicago", value: 67} But when an event happens I want to be able to find this row and increment the value. Or if a an event happens in a city that does not yet have a row, I want it to be created with a value of 1.
You should be able to select all the cells in your excel, copy, and paste on a JS application. You'd have to parse it, but it should be easy. This JS application could save data to localStorage (in your browser) or to a cloud database such as Firebase (the free tier is more than enough for your needs). What are you trying to accomplish in JS that Excel can't?
Look neat Expand my resume.
If your data is in an array just use `array.sort()`. If your data is in an object you can get an array with: `Objects.keys(dataObject).map(key =&gt; dataObject[key])` `map()` returns an array from the elements you return. `key =&gt; dataObject[key]` is equivalent to `key =&gt; {return dataObject[key]}`
Lolwut?
https://spiritapp.io/
On a small scale, not much more than watching computer-biology evolve. On an unimaginable large scale? Self driving cars, intelligent AI.
Sure, anyone else at all posting the link and saying it's hilarious looks great. Posting your own link and complimenting yourself has a certain self-important pretentious to it. Not saying it's not funny, just leave it to 3rd parties. 
So you want to parse it as GMT and format in local timezone? moment.tz("12/14/2015 12:56:59", 'M/DD/YYYY HH:mm:ss', 'GMT').local() Or: moment.tz("12/14/2015 12:56:59", 'M/DD/YYYY HH:mm:ss', 'GMT').tz(moment.tz.guess()) If you actually want to convert the timezone (`local` only changes how the date is formatted, it doesn't modify the offset). In general: moment.tz(date, format, from).tz(to)
In single page apps I've seen a lot of "createElement" and whatnot, which is still under the purview of JS, though the end goal is to manipulate the dom. And the only html is basically a src tag. So you still need to know about html and css, but you don't need html and css files. 
I would use Google Sheets. You can import your spreadsheet or simply use Sheets instead. Then, use the [Sheets API](https://developers.google.com/sheets/api/v3/) to pull information directly from your Google spreadsheet. 
So that means JavaScript is multithreaded now. When will Node upgrade to V8 6 I wonder.
I think the point being made is that nobody is going to be able to get a job by saying "I'm a back end developer, here's my work, you can test it with postman because nobody ever made a front end for it"
Any Frontend developer who doesn't take HTML and CSS seriously is not a good developer. The converse is true as well. The more you understand about these things and the way they work together the better you will be overall.
Maybe you can check the repo and make improvements, PR, discussion, I've spent like 1 month doing this to be similar than using Bulma (that's why it's stateless, similar than Bulma is Javascriptless).
Yea, probably. That's what i'm talking about. But yea, cool research and try. :)
Any temporary remote work available? As in, working remotely temporarily, not like a short term, contractor position. 
Anyone else wondering why Saving in the old pokemon games takes that long - even inside an emulator? Is saving fixed to the emulator's cpu clock rate?
I am already using CSS transitions and animations in this project. I am just wondering if there is a way using those, or somehow else, to sort of have an element just not suddenly pop into existence when a button is clicked. I am looking for a smoother appearance into the DOM, if that makes sense.
Came here to say this exact thing. Google Drive can convert CSV and excel files into a Google Sheet. Then you have the option of using the Sheets API or creating your own API via scripts. I found the latter method to be way simpler because you don't have to deal with all of the authentication stuff for data that doesn't need to be secured.
&gt; is there a way with vanilla JS to make that element transition into view somehow Yes. Just add a transition style to it. &gt; is there a way to trigger CSS animations or transitions to do so using JS as the control? CSS transitions will be triggered when the specified style changes, so just changing the style (or class) in JS will trigger the style. Also, CSS animations trigger when an element is displayed. https://jsfiddle.net/t2qevw9u/
Yea look into opacity property for appearance. Basically, use CSS transitions to set a speed for opacity and then change opacity from 0 to 1 (0% to 100%) and that would slowly reveal your element.
As a weird alternative, are you allowed to install Excel Add-Ins or run Visual Basic scripts/macros within Excel? Then maybe you could do something like this to generate JSON data: https://codingislove.com/excel-json/ What are you planning to do with your webpage? Maybe building a Visual Basic application within Excel might be a better alternative than a full-fledged webpage. Edit: Also OP, if you're only looking for a static webpage, then Excel has a built-in "Save As Web Page" feature to make simple static web pages: https://support.office.com/en-us/article/Save-all-or-part-of-a-workbook-to-a-static-Web-page-5AD26DEE-8739-4D80-B9D9-CF0530AB1968#bmlearn_more_about_saving_excel_data_to
Makes it harder to test.
Oh thanks! 
`Reducing` .... eh heh heh. I see what you did there.
 Not even sure if I will be allowed to. Just seems like something neat to do, add to the resume, and show my son(trying to get him interested in coding)
[Comment thread for this article from two days ago](https://www.reddit.com/r/javascript/comments/6g0k7z/adopting_flow_typescript/)
you can use imacros, and get your work done using some macro tags and js
using imacros you can automate your work and you can add js to your macro script to make things easier and it has support to extract data from and into any soreadsheet
you just need to use some tags and you can automate your work easily, just read the stuff here http://wiki.imacros.net/Tutorials its a great tool and will save a lots of your time
if you have any issue making the script just ping me I can make a try
I'm not sure, but maybe the size of the save requires multiple RAM bank switches.
If someone here plans to write a JS emulator, I've published some time ago [Virtjs](https://github.com/arcanis/virtjs), a library that gives you standardized devices that you can plug to your emulators so that you don't have to implement the tricky and boring parts (mainly input / output). Just implement a few functions, and you're ready to go :) I also worked on [Archjs](https://github.com/start9/archjs), which ports RetroArch cores to Javascript using emscripten.
Author's article got savaged in the comments at the previous thread two days ago (https://www.reddit.com/r/javascript/comments/6g0k7z/adopting_flow_typescript/) so they're probably feeling salty and are trying to block out the world right now.
Thank you so much!
It uses the javascript ternary operator. Basically, the following: const a = condition ? ifTrue : ifFalse; In this case, the variable `a` will be `ifFalse` if `condition` is false, and `ifTrue` if condition is true. So if we take your example and refactor it a bit, we get this: const ifTrue = ( &lt;Component {...props} /&gt; ); const ifFalse = ( &lt;Redirect to={{ pathname: '/login', state: { from: props.location }}} /&gt; ); return fakeAuth.isAuthenticated ? ifTrue : ifFalse;
You could simplify more `obj[key] = (obj[key] + 1) || 1;`
I just finished writing a long response and my phone ate it, so I'll take it as a sign and keep this short. Writing concepts in your own words is a great way to learn them better. Definitely keep it up! For more about object orientation, you should take a look at the purely object oriented language Io (capital i letter o). It's another prototypal language. Also, check out talks by Alan Kay, the father of object orientation. He has a lot of really enlightening things to say. Anyway, keep blogging. It can only keep making you better. ☺️
Wow... You Can't format titles good 2 know...
Thank you, much appreaciated! I will deffinitely have a look!
You would call Promise.all in the first then block for the new promises you are creating. In any case this seems like a bad pattern. What are you trying to do?
If that were the case, then it would be faster just to save the emulator state rather than save the game through their fancy UI.
Thank you so much for taking the time to answer my questions. I really appreciate it. So assuming this kind of structure └── build └── style.css └── bundle.js └── index.html └── src ├── css │ └── scss │ │ └── style.scss ├── js │ └── entry.js └── index.html └── node_modules ├── front-end-dependency-1 │ ├── dependency-1.js │ ├── images │ │ └── arrow.png │ │ └── button.png │ └── css │ └── dependency-1.css └── front-end-dependency-2 └── dist ├── button.min.js └── button-styles.min.scss └── arrow.png Note that the two dependencies have different folder structures. One uses a dist directory the other is just the files. They both have an image with the same name. dependency-1 includes images in the css, looks something like this: .dependency-1 { background-image: url(images/arrow.png) } the other dependency loads the `dist/arrow.png` from the `button.min.js`. Since the image calls are hardcoded into the css/javascript how would I move them without breaking the links? Also note that two of the images have the same name... I'm definitely missing something here. Again I really appreciate the help.
Yes and no. There are differences, but if you need to ask then they probably won't matter to you. I think you can safely start using npm again. Then (1) you get nvm back, and (2) you have one dependency fewer
nvm only specifies the Node version, not npm, so that's not really a good argument. While node versions do bundle npm from what I've heard from npm people is that you can use any* version of npm with any version of node. \* within reason, I'm sure npm5 has a minimum compatible version
No, not really, by default each node version is associated with an npm version, and when you change one the other changes too. When you do nvm install xxx it also installs the corresponding npm version Which is what you usually want. Normally if you need, say, node 4 on your dev machine it's because you will be deploying to a system where they haven't upgraded since node 4 - which means it will have npm 2 on it. It'd be very odd if someone kept node 4 and but upgraded to, say, npm 5 (assuming it is even possible). But if you need to, I think you can tell nvm to use some crazy combination of node and npm
There are also a lot of "introduction to array.reduce" articles all the time - should we make a separate es5 sub too?
Really cool 
my apologies, forgot to add it
https://pastebin.com/GpSN0aSF
Rewrote my mobile Reddit reader [Freddy](https://freddy.spacejack.ca/). Originally written in vanilla JS, the rewrite uses [Mithril.js](https://mithril.js.org/) and Typescript. If you're curious, you can compare the old, naively-written [vanilla JS branch](https://github.com/spacejack/freddy/tree/vanilla) against the [current rewrite](https://github.com/spacejack/freddy). Still respectably small IMHO, all baked into a single 77k HTML file.
Spamming a server with many requests knowing full well most of them will fail is usually considered impolite behavior. Steam would be well within their rights to take steps against you, your IP address or your account in some fashion. But that's not what you asked about. What you're really doing in that loop is asking your browser to fire 200,000 requests at the same time to a single host. Fortunately, browsers have some safeguards against doing harmful things, and will usually limit the number of concurrent connections that actually go out (not sure what that number looks like nowadays. It used to be 2 or 4 concurrent requests per host. It may have gone a bit higher.) Most likely, the memory overhead of allocating the 200,000 javascript data structures associated with a jquery post operation is sufficient to eat up all your RAM. Potential fixes include: - make the requests synchronous. ie, make the javascript engine stop altogether until the request returns. It's simple, but I'm not sure jQuery exposes that [functionality ](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open), so you may have to use XMLHttpRequest directly. Also, your browser would freeze while your code run. And your code would run for a long long time. - don't use a for(;;) loop. Instead wrap your jquery.post() call in a function, and add a callback to your post that will check if loaded&lt;total and call that function again or not. That's probably a better way to do this. My humble recommendation here would be to figure out how to craft a search query that would return free game ids, parse the results and iterate over them to grab their licenses. That'd be nicer all around, and faster as well. 
ah, that makes sense...JS is quite fun to learn while also being a marketable skill :) 
Does the office run on Windows? You can make an [HTML Application](https://en.wikipedia.org/wiki/HTML_Application) (`.hta` file) which you can store on the shared drive and it will run on the user's computer with applicaiton privileges, allowing you to access filesystems and create ActiveX objects so you can script Office apps on the host computer (e.g. here's the API for the [Worksheet object](https://msdn.microsoft.com/en-us/library/office/ff194464.aspx). It's the original Electron! I did this at work to make an app for HR which sits on the shared drive and allows them to generate interview documents, using a React + Bootstrap app to select from categoried questions based on the role being interviewed for. Word automation is then used to read a template for questions, generate a chunk of word doc for each question and stitch the whole thing into a master template. It even uses some VBScript functions from the JavaScript, as VBScript has some handy utility functions (open this document with whatever the correct program is) which are no longer available in JScript :-D Biggest downside: you have to use the IE9 engine, debugging is old-school hell.
/u/our_best_friend sums it up, but to add to it I would stay away from Node 8 and npm 5 for now. There's been quite a few issues popping up since it's release (expected). Give it a couple months.
I was wondering the same thing. I once did something similar but for tic tac toe and I never could get it to converge. Is flappy bird that much simpler than tic tac toe?
Most of this article is perfectly good and accurate, but talking about what a "real" class is or isn't, or what "real" inheritance is or isn't could use some illumination. There is no single correct implementation of classes and inheritance. Different languages implement the concepts in different ways. In Python and Ruby, for example, a class is itself an object (a building, not a blueprint), and inheritance is done by delegating down a chain of objects, from instance to class object to superclass object and so on. Just like in JavaScript. So if JavaScript's classes and inheritance are "fake", then so too are Python's and Ruby's classes and inheritance "fake". It turns out, real vs fake isn't a useful distinction. It's more useful to talk about specific similarities and differences with specific languages. C++ and Java's classes and inheritance, for example, are partly similar because their classes exist only at compile time, and the inheritance process is also done at compile time. But they're also partly different because Java supports only single and only public inheritance, while C++ supports multiple and public/private inheritance. Meanwhile, Python and Ruby's classes and inheritance are partly similar because their classes are objects that exist at runtime, and their inheritance process is also done at runtime through delegation. But they're also partly different because Ruby supports private members and only single inheritance, while Python relies on private-by-convention and supports multiple inheritance. None of these is the one and only "real" implementation, and likewise none of them are fake. So where does JavaScript fit in? JavaScript's classes are objects that exist at runtime and its inheritance is done at runtime, like Python and Ruby. JavaScript supports only single inheritance, like Ruby and Java. And JavaScript relies on private-by-convention, like Python.
Did a video on using google sheets as a backend. Its pretty easy using sheetrock.js (https://github.com/chriszarate/sheetrock) https://www.youtube.com/watch?v=EdQpoZVboWU&amp;index=3&amp;list=PUzXDsT5JhLNeZpC3DjB4rpw
They are not executed in series -- they are executed in parallel. You'll have to use some sort of throttling algorithm or a library like asyncjs that has `eachLimit()`
Holy crap! You need to understand two things: 1. Those requests are not firing one after the other, they are firing simultaneously. You are running out of memory because it's trying to hold all those requests in memory in order to fire them all. I forget what the upper limit on async requests is in Chrome but probably something like 20 of those requests are going through at a time and the browser has to hang onto all the request in memory until they are complete. 2. Even if those calls *were* executing one after another rather than in parallel you would still be completely hammering their site with requests for no reason. If all you're doing is checking for deals then what you need is one tiny request to fire every ten minutes or something. You need to utilize `setInterval`. setInterval(function () { // ajax request code }, 36000); // 36000 milliseconds is 10 minutes What it actually looks like you're doing is probing to see if the site has some sort of deal with each number increment or something. I don't really know but the point is they clearly don't want you to have this information this way or they would provide you an API you could query to get the info you're after. 
`Promise.all([promise1, promise2, promise3]).then(doSomethingWhenAllAreDone);` It's `Promise.all`, not `Promise.prototype.all`. You don't call it as a member function.
Complaining about sexism yet you use "panties in a bunch" as an insult, literally an insult derived from women getting upset. 
Awesome. That makes perfect sense now. Thanks!
In short, yes
Would you really need both?
https://logojoy.com/ Logos created with ML, styles a re a little repetitive but otherwise it's actually quite well done.
no need for manual removing for the internal nodes. Just one thing: be careful not to save your `el` variable in this case (it will not be saved, unless you made some links/closures to it)
The link to the Retroarch one needs updating: https://buildbot.libretro.com/web/ Plus it has way more than just 7 different systems.
Thank you for the feedback and the given clarity on the subject. I understand that "real" and "fake" are probably not the best words to describe the different implementations of inheritance and will look further into the topic. What I wanted to achieve is describe what the term inheritance actually means in the context of JavaScript and how proper understanding of it can help you avoid certain errors. Even if you use modern abstractions such as the ES6 classes, the processes that are happening under the hood are the same. The distinction that I wanted to point out is how in other languages objects are instantiated using copies, while in JS they maintain the "live" link between them using the prototype chain. I am not familiar with how classes work in Python and Ruby but the things you've mentioned have sparked my interest to dig deeper into the subject.
o hell no.
[Repo Read Me file with instructions](https://github.com/Pyro979/searchNdestroy/blob/master/README.md) [Chrome Extension](https://chrome.google.com/webstore/detail/search-destroy-for-amazon/nddigkbhmfbmjcobjbdkljjdoajejdfn) [Firefox Extension](https://addons.mozilla.org/en-US/firefox/addon/search-destroy-for-amazon/?src=cb-dl-recentlyadded) 
They probably don't test every combination of node and npm... personally I tend to stick to the standard, and if for some reason I want more modern functionality I'd rather use yarn
I imagine that's for a CI usage, you have to do that. I really did not thought about that use case. I don't recall anything about that on changelog for npm 5 so I would think that did not change. If you have a quick setup that allow you to try I would like to know :)
Maybe try https://checkio.org/ 
Get VS Code and Quokka
Since ES6 there are a couple of storage options: * arrays - iterable and keys must be 0 based incrementing integers * objects (Hash maps) - Not iterable and keys must be strings * Maps - iterable and keys may be of any data type * Sets - iterable it is essentially a list of keys without values, as in each item must be unique and each item may be of any data type * WeakMaps - not iterable and keys must be object data types. The intention is that the relationship between key and value does not prevent garbage collection * WeakSets - the values must be unique and objects. access to the values does not block garbage collection. When it comes to sorting your best bet to keep your data in an object and access its contents in a sorted fashion. You can create an array of keys with `Object.keys(myObject)`. This array can be sorted by reference back to the original object: let sortFunction = function(a, b) { if (myObject[a] &gt; myObject[b]) { return 1; } return -1; }; let keys = Object.keys(myObject); keys.sort(sortFunction); Now the keys array will be sorted by their corresponding values in myObject. myObject remains unsorted, it is a hash map, but your primary means of access, the keys array, is sorted. Bearing in mind if you are going to write a sort function never return the value `0`, because it will generate different sort criteria cross browser.
* jsbin.com * prettydiff.com * jslint.com 
I had not heard of Quokka so I had to look it up: https://quokkajs.com/ It appears to be a simple REPL that runs in vscode that executes on key up. This is uber handy. I want to build something like this for the language I am creating, but I need to create a basic interpreter first.
Javascript30.com (30 free tutorials by wes bos) Codefights.com (daily challenges and algorithm exercises) 
Yup :)
Use VS Code for editing. Freecodecamp to learn the full stack start to finish. That should keep you busy for at least a year. (No, FCC isn't perfect. It is however free and comprehensive enough to guide one past the beginner tutorial wasteland and on to junior development and there is a huge community if you get stuck anywhere.)
I just saved this. This is really Good. I really pray this bot grows. Like see food App 
&gt; while in JS they maintain the "live" link between them using the prototype chain. I am not familiar with how classes work in Python and Ruby but the things you've mentioned have sparked my interest to dig deeper into the subject. Here's a couple code samples in Python and Ruby that demonstrate they too maintain a "live" link. [Ruby monkey patch](https://repl.it/CmeX/0) [Python monkey patch](https://repl.it/CmeW/0) 
 asyncFunc() .then((asyncResult) =&gt; Promise.all([ promiseA, promiseB, // ... ])) .then((resultArray) =&gt; { const resultA = resultArray[0]; const resultB = resultArray[1]; // ... });
.....motherfuck!
Silicon Valley comment.
Pretty awesome! I had a quick glance at the code and it's looking pretty good though they are some small mistakes that a linter could probably catch easily. Did you try to use eslint?
That's really hard to measure. For one - the vast majority of telemetry is collected using purely javascript, so that gets thrown out of the window. And tracking users by other means is pretty hard. Now how you tell whether they don't have JS enabled? I'd suggest using some tracking image inside a &lt;noscript&gt; tag, but not all JS blocking even takes that into question. For similar reasons you can't just count hits and not-hits to your JS files. And when you do manage to gather data then how do you tell apart robots that just scrape you and don't load JS because they don't need it? So in the end you get data that are hard to draw any conclusions from. I'd expect that number to be anywhere between 0.05 to 1.5% of all internet users.
Yup, that should work fine. Here's a working example: function asyncFunc() { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { console.log('asyncFunc done'); resolve([1, 2, 3]); }, 500); }); } function otherAsyncFunc(n) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { console.log(`otherAsyncFunc(${n}) done`); resolve(n * n); }, Math.floor(Math.random() * 5000)); }); } asyncFunc() .then((asyncResultArray) =&gt; Promise.all( asyncResultArray.map((item) =&gt; { return otherAsyncFunc(item); }) )) .then((resultArray) =&gt; { resultArray.map((newItem) =&gt; { console.log(newItem); }); });
&gt; And we would like to see statistics showing this. &gt; Till then, we dismiss your claim due to no or anecdotal evidence. Then why did you bother with your own anecdotal drivel? The person I was responding didn't cite statistics and tried to draw conclusions from their anecdotes. You did the same thing. I simply stated my personal experiences.
I didn't realize I was doing that. I'll fix it. It should not need any info from GitHub other than a unique ID. 
OP here. I really want to know what features you would like. 
So it's like Shazam, but for food?
I would expect modules which need to pass a lot of data from/to native land to eventually be slower than WASM, as passing data from js to native context is the biggest bottleneck regarding native modules. but currently WASM is only barely more performant than JS as the engine hasn't implemented enough optimisations in WASM to dramatically outpace JS. But the potential is there.
also fyi if you are using vanillajs, tying the chrome browser to your file system gives you pretty good code completion at the breakpoints. Assuming you are just writing/learning and not worried about sharing just yet.
I use Webstorm also. The only issue is it isn't free for non-students, making it a high paywall to get behind. I am new to Webstorm, so I don't fully understand its power yet. (Granted I work with React and Meteor.)
That's my thinking too. I remember in early days of Node how some libraries ported as native addons proved to be slower than their js implementations due to these transfer costs, the mysql driver was one case, IIRC. 
no, sadly
It looks like you have the for loop mixed up a bit, assuming you want to start at one; num = 1, then it's up the number 'n': num &amp;lt;= n, and finally by intervals of m: num+= m It was only giving one array because you were incrementing by n, the final result, which was probably greater than your interval So for (10,2"UP") it would have started at 0, then add 10 (num += n --&gt; 0 += 10) which is greater than 2, thus breaking the loop and returning 
Not sure why I got downvoted for talking about something that helped me understand the language much better. Not sure if that was you or someone else. I understand the concern of paying for it. There was a time I couldn't afford to buy it myself. Here is how I got around it: 1. keep an eye out for sales. Jetbrains tends to do some pretty discounted sales. 2. Use the Early Access Programs. They all are good for at least 30 days each, and they constantly have them. 3. Each released official version comes with at least 30 days of use. By this time, the EAP release is most likely available. 4. I've never used them, but they have the community edition which is open source. At one point, I went a full year without paying. When I finally had the funds to do so, I did. It's a quality product, and I honestly think it's the best IDE out there for JS. There are definitely some shortcomings. But it definitely is worth it.
I didn't paraphrase you at all, never mind overly. You didn't give any statistics. The "90%" and "95%", which are the only numbers you mentioned and are conveniently simple, are also anecdotal.
Not hot dog.
Typescript is a superset of javascript, so anything that is valid javascript is valid typescript.
[Silicon Valley reference]
Unless you want to get into doing acrobatics with chains of nested `then()` and `Promise.all()` your best bet is moving to `async` and `await`. This will make your life much simpler and your code much cleaner. Compare this: const result = await asyncMethod(); const anotherResult = await anotherAsyncMethod(result); To this: asyncMethod().then(result =&gt; { return anotherAsyncMethod(result) }).then(anotherResult =&gt; { // etc })
See-Food
Thanks 
I prefer [jsbin](https://jsbin.com) over jsfiddle, but lately am using [codesandbox](https://codesandbox.io/s/new) and [webpackbin](https://www.webpackbin.com/) more than either. 
The `npm-check` and `npm-check-updates` packages have been around for longer than yarn.
After the user has logged in you can write a very short middleware function to check if the user is allowed to access specific routes. You can check the `req` object with `req.isAuthenticated()` (provided by passport) which returns a boolean value. // Example restricted route router.get('/account', ensureAuthenticated, function(req, res, next) { // Render account page if middleware allows }); // At the bottom of my route file function ensureAuthenticated(req, res, next) { if (req.isAuthenticated()) { return next(); // proceed into the route } else { res.redirect('/login'); } }
 &gt;It's reasonable to look at the reasons why the pool was skewed in favor of white men though, and change that. Change the way we raise children so we don't pigeonhole them. Exactly. And it's much, much harder when children have no role models in the field to look up to. Which is why some argue that enforcing equal representation is worth it in the long run, even if it's bit unfair or you have to lower standards by few percentage. Having a say 95% skilled programmer instead of 100% is worth the trade off in the long run of attracting new talent from that group. 
Huh, it's like everyone is on the lookout after what's best for themselves, or something.. If you want to change social norms, why start at bottom? 
Silicon valley right?
 .mjs
The title caught my eye "Immutable data structures for functional JS". A woman speaker. My first thought? Conference filling their quotas. Not worth watching. Shut up brain. Don't let these thoughts take over. Conference starts. "I am [..] not a web developer" – back to thought #1. But lets keep watching. "Outreach Program [..] getting more women and underrepresented folks involved in Open-Source [.. via] paid internships" (1) More reaffirming #1 thought. (2) How about focusing on supporting the existing community instead of getting more people in a completely underfunded field. ... watching the entire video ... Fuck. * Nothing specific to JS. * Nothing specific to FP. * Nothing beyond 101-immutability. Summary of the talk: * 0:00 to 4:00 talking about stones and poetry * 4:00 to 8:00 talking about "what is immutability" * 8:00 to 20:00 talking about data indexing (B-tree data structures) * 20:00 to 25:00 shows "Hello, World" (push, set) example of immutable structures using "Mori" and Immutable.js ... Summary: #1
See this section in the Axios documentation: [Using application/x-www-form-urlencoded format] (https://github.com/mzabriskie/axios#using-applicationx-www-form-urlencoded-format) You can use URLSearchParams or the qs library. While I only need to support browsers that have support for URLSearchParams, I personally use the qs library because it's easier to unit test.
What's the benefit of quokka over running the vs code debugger? I'm building elementary node apps right now so I don't have a broad view on tools but I like vs code and it's debugger
This is a big deal and it mostly got ignored.
"ShaHam"
I suppose this may interest you: https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Creating_JavaScript_tests (this is from MDN about creating JavaScript test in SpiderMonkey - at least it looks like this. I didn't read it, just glanced).
When you are concatenating in your console.logs ("logic:" + ...) you might be implicitly converting the data types of those object props -- I have experienced some strange errors because of this sort of thing in my own code. Note that you can separate things in console.log with commas like this: console.log("my things:", thing1, thing2); it avoids concatenation and just displays everything anyway -- a bit cleaner and possibly will eliminate errors i would also explicitly test error if (error === true) nothing else obvious really stood out to me, this are pretty nit picky things, but give it a try 
Without trying the code, I'm going to guess that it is moving a tiny bit, waiting, then moving a lot. This is the same behavior that you'd see if you held a key down in a text editor. It adds the character you pressed, waits, then starts to add a lot more. onkeydown behaves the same way if I remember right. Instead of moving the ship when you press the key, have on key down mark the key that was pressed. So if the player presses up and you want the ship to move up when that key is pressed, you set movingUp to true. On the key up event when the key is released, turn movingUp back to false. This way, movingUp will be true when the key is pressed, and false when the key is not pressed. In your game loop, just check the variable movingUp. If it is true, move the ship up a little bit. If you don't know what a game loop is, which is something I assume because I don't see one in your code, I would HIGHLY recommend you look it up and add one. It's basically just a block of code that is repeated many times per second.
Good points, I don't remember in Haskell if it was necessary for all functions or just exported ones. At the end of the day, it is pretty handy to be able to not type things that are "obvious" to humans. That said, it's abusable, and typing doesn't take all that long. I think that a lot of the pain I have felt doing a more functional style in Typescript may be fixed in 2.4, so I'm quite excited to give that a go.
Can I use this without first installing Bower+Node+NPM+Docker+Reddis+Webpack+Gulp+Grunt+Browserify+Angular v683+React+Vue+Yarn+Mocha+Jasmine+Cordova+Jenkins+Nexus+Git+93,812 supporting micro-libraries? 'Cause if not then it just doesn't feel right. EDIT: Haha, as expected, didn't take long to get my first downvote. The JS community REALLY doesn't like having its own ridiculousness pointed out, does it? 
Thank you a ton. That did work
JS community embraced micro libraries. If installing Lodash keeps you from writing your own functions for findLast or unique or union then use it. Why write it yourself and maintain it yourself? So yes, lots of projects pull lots of libraries. Why does that matter? It allows small chunks of codes to be loaded as needed while offloading the work of maintaining it to someone else (or a community of people typically).
If you or anyone else didn't understand that I was being hyperbolic to make a point, which appears to be the case given your response, then there's really nothing to say. It's just a sad state of affairs on multiple levels. 
http://i3.kym-cdn.com/photos/images/newsfeed/000/738/025/db0.jpg
You didn't get downvoted for pointing out the current state of the JavaScript ecosystem, which by the way, just about everyone knows about. And no, mocking it without reason doesn't automatically make you funny. You got downvoted for going overboard with your comment and ending up sounding like a smartass. You only need 1 of your listed technologies to run ES Lint even on big projects. Id have laughed at your comment if you needed at least 4-5 libraries to get ESLint to work (because that's sadly the state of JS development), but that's clearly not the case and you just ended up sounding like a try-hard "Look at me guys, it's still cool to mock JS, riiiight?"
Not OP, but also not too familiar with async/await yet. How would emulate `Promise.all()` using async/await? From my understanding doing something like this: const itemArray = await asyncFunc(); const resultArray = []; itemArray.forEach((item) =&gt; { const result = await otherAsyncFunc(item); resultArray.push(result); }); will run each call to `otherAsyncFunc` in series, rather than firing them all off at once. Do you just go ahead and use `Promise.all` like this? const itemArray = await asyncFunc(); const resultArray = await Promise.all(itemArray.map((item) =&gt; otherAsyncFunc(item))); 
If you use await the JS engine will wait (d'oh) for the promise to resolve. So this line `const itemArray = await asyncFunc();` will actually wait for that. If you want to execute a number of promises in parallel (all at once) and wait for the result you would construct your array of promises as usual without await and then simply: `const result = await Promise.all(arrayOfPromises)`;
A better title would have been 'Immutable data structures for people who never heard before what immutable data structures are, or JavaScript, or programming, or computers'
I used npm-check-updates before yarn but, I don't generally want to upgrade all dependencies. So while it is vastly superior to looking up every package version, it's still inferior to being able to select which of the updates I actually want to apply.
My sister does a lot of knitting and made me a sweater recently.
JIAN YANG!
Sweet! Gonna upgrade as soon as I get into work. Thanks for the heads up.
What is your point? That fewer tools should exist? I use about half that list but I wouldn't like to see the ones I don't use wink out of existence as other people find them useful. 
It's telling me that adblock browser will not interpret a file unless the entire file is valid as I've been splitting my JS file into two separate files and narrowing down where it breaks by the lack of an alert being shown. 
Are you able to provide your code via jsfiddle or codepen?
I just found the problem adblock browser does not support 'let' so I had to replace with 'var' very frustrating 
all good... You should take a look a Babel https://babeljs.io/ That way you can keep your ES6 format and just compile the ES5 equivalent for automatic browser compatibility :) 
This is the perfect example of why you want to give meaningful names to variables! If you had used goal and increment (or even inc) instead of m and n, the error would have been obvious.
Looks cool, nice first step :)
Apples and oranges.
xo has a great set of code related linting rules. prettier is really good at formatting code. all eslint-config-prettier does is turn off the aesthetic formatting rules
Feature-wise, here are a few advantages I can see with WebAssembly over native modules. Most of them are related to the developer experience rather than the actual perfs: - Native modules have a lot of weird edge cases. For example, if you fail to compile your module with the right flags, your module symbols might collide with other modules and lots of weird shit can happen. - Native modules require a build chain, WebAssembly does not (or rather, the burden is put on you, the library author, rather than your users). By using it, you would decrease by a large factor the number of dependencies you'd need to pull in (no more `node-gyp`, for example). - WebAssembly modules have the potential to be ran from inside browsers. It means that you could imagine being able to run webpack on those module and it would Just Work, something which is just impossible to achieve with Native Modules. - Finally, because the WebAssembly bytecode is not dependent on any browser implementation, you'd not have to recompile your modules after each Node upgrade. On the other side, Native Module perfs might be better, since you could then have a deeper integration with the internals. I'm not convinced it would be a very good enough reason, tho, since correctly leveraging those internals is a pretty complex task. Another issue, as noted by /u/segphault, is that there's no GC hook yet that WebAssembly could use, so you will always have to keep track of your objects and manually free them - something you rarely have to do in more common applications. Native Modules, however, automatically call object destructors, so it's much easier and idiomatic in this regard. I think this will eventually get fixed (it *must* be fixed for WebAssembly to gain traction), but maybe not before a year or two.
Just noticed that you've misspelled the title of your spell book, "Morden Web Dev..."
Hey that worked! I don't understand the reasoning behind what was broken, Javascript can be so strange. Thanks!
http://i3.kym-cdn.com/photos/images/newsfeed/000/738/025/db0.jpg
Love this package
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [jamesseanwright/glitch-hunt/.../**keyboard.js** (master → 3f8ee14)](https://github.com/jamesseanwright/glitch-hunt/blob/3f8ee145047572dd8c3d63912171314949d14f79/src/keyboard.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dishi7w.)^.
Aah, this is a good shout actually. Thanks little guy!
Obvious java troll
&gt; You only need 1 of your listed technologies to run ES Lint even on big projects. What a great example of weasel words! The moment I read that I thought, I bet it has a ton of dependencies and they just aren't the ones he listed. Sure enough, it has 123. It weighs 12 MB, and it takes 30 seconds to download and install. 99% of that 12 MB is dead code, and install time could be 3 seconds not 30. But, instead of working to address literal 10,000% inefficiencies, you're here, slinging insults at whomever dares insult your precious status quo.
After playing around with it for quite a while that is what I was missing. The actual parsing as GMT. I didn't think I needed to do it because I thought it was converting this to GMT by default (not sure why I would think that). My resulting code is: moment.tz("12/14/2015 12:56:59", 'GMT').tz(moment.tz.guess()).format() Pretty much exactly what you stated :)
&gt; `.then((resultArray) =&gt; {` `.then(([resultA, resultB]) =&gt; {`
WebAssembly will not kill JavaScript, at least for the foreseeable future. Being a programmer will require to constantly learn new stuff, specially if you get into web development. If you are not that kind of type I would advise you to not get into this industry.
well as long as that has been sourced in then you can interact with it from the console/source view also (ctrl space)
I am fully aware of who she is. That doesn't change the fact that this particular presentation is garbage in the context of the rest of the conference, i.e. odds are that someone with a lot better talk was turned down because he does not identify as a female.
Also, I forgot to mention above that I am in the US on a visa and things are getting quite difficult in terms of people hiring people requiring visas in the US. So the choice was to stick with my current job for a long long time or cut my losses and move somewhere else.
Hi there.
&gt; TLDR Indeed, var is deprecated and I personally only use const and let now. However, you might want to checkout the article to understand: - Why not use var? - How exactly let and const work? - And most importantly how does scope work. 
&gt; I bet it has a ton of dependencies Like anything else. &gt; install time could be 3 seconds not 30 If you do tree-shaking, minification, and bundling, updates will be much larger. I'm not sure if you'd actually save anything on average. Also, who cares? This is something you do once in a blue moon, not daily or even several times a day. You'll spend way more time reading the documentation and configuring it.
You know what? You're right, and you aren't the first person to say something along these lines so I'll take this opportunity to offer a very limited apology for one specific thing: my comment wasn't really about ESLint at all and I picked a bad post to make my more general comment on. I want to make clear that I actually like ESLint a lot and use it myself and have a ton of respect for the people that work on it, as I do for anyone who works on OSS projects (as I do BTW) whether I like/use a specific project myself or not. I was never trying to make a commentary on ESLint itself and so especially to anyone who works on it I apologize if anything I said came off like that to you or that I was being negative towards ESLint. That most definitely was NOT my intention. &gt;JS' ecosystem is fragmented and super annoying in general ... is exactly the point I was making, but I didn't pick a good post to make it on, and so I'll apologize for JUST that and especially if anyone on the ESLint team was offended. I stand by everything else 100% though and apologize for none of it. And thank you for a non-attack reply inu-no-policemen. I didn't think my original post or edit warranted such scorn and malice as some other replies have shown (a fact which I think proves my original point frankly), but yours was perfectly reasonable and I appreciate it.
Regarding 1. We have our spec files in a different directory than the source files. This directory contains its own .eslintrc. That effectively let's us define different rule sets.
Very impressive The UX is as good as codepen's but allows multiple-files like jsbin/plunkr and the ability to require npm modules like runkit in addition to external cdn scripts Only thing I see that's missing is a way to monetize. Hope it stays around :)
Just a few points: - "I can't remember the last time I used var". Maybe you can't recall, but I can tell that we all have to face working on older projects full of 'var'. We can also face the same issue while collaborating with other developers (because most of the time it's not just your code). If you don't understand scope fully, it would be extremely painful to migrate to ES6 or just to debug any issues. - The fact that ES6 introduced new good practices with let and const does not mean that we can all move on, use them and never bother understanding scope. I believe that a good software engineer would not write code without having any idea on how the engine execute it. Scope and other related topics (such as closures) are building blocks of other JavaScript concepts like the module pattern. One can't claim being comfortable in a language without master its basic core concepts.
My opponent's queen moved all across the board to eat my own queen, only to sacrifice it to my king. That's one of the most ballsy move I've ever seen ... [edit] and I lost. I'm bad at chess. :(
Wrong thread.
tslint.
That's what most folks are doing, yes. But it sucks that eslint is basically dictating my project directory structure. I prefer to have my spec files side-by-side with my source files.
Nicely done. I'm not sure I understand your use case. Why do you need to install it on a LAMP env? Is this just for practice?
Thanks a lot! I'm also planning to release 'import from GitHub' and 'upload to CodeSandbox' functionality this week, really excited about this. I'm not really planning on really monetizing this, it was just a side project. I am introducing CodeSandbox Pro in the upcoming month, but people can choose themselves how much they want to pay for this monthly.
No monkey business 
You're the minority. If you want it so bad, submit a PR.
As I've said, PRs have already been submitted for this.
Renaming the project might help with searchability - there is an extremely popular javascript library called [Winston](https://github.com/winstonjs/winston) already. Nice code tho - lots of comments :) I like that you left a bit of a TODO to detect 3 fold repetition! 
Yes. As far as I understand doing "yarn install" is effectively the exact same thing as "npm install" just faster and better. Publishing and versioning might differ - I don't know. But for someone like me who only cares about downloading packages, it just seems as easy as typing "yarn" instead of "npm" to make it go faster :) From their docs -It paralellizes operations that npm does not, and -makes more efficient use of the network. -may make more efficient use of other system resources (such as RAM) as well. -You always know you're getting the same thing on every development machine Let me know if there are downsides I don't know about yet
Yes, but he says he'd like to build his own.
Found a bit of a bug. Managed to get a "stalemate" (the demo doesn't actually go to stalemate on repetition) when the computer was one move away from mate. Instead of winning by moving queen to d1 or rook to f1, we just both moved our kings back and forth between g and h. [Screenshot](http://imgur.com/a/AVzZu). Still haven't actually beaten it though :P EDIT: I decided to advance my pawns just because, and [this](http://imgur.com/mywdTNa) happened. Is letting me have the queen a pity move? EDIT2: Aaand back to [moving back and forth in the corner](http://imgur.com/sw6A1VR). EDIT3: And now I'm [here](http://imgur.com/CA8dCaR), with exactly one legal move per turn. The rook just keeps moving back and forth between d4 and g4.
You're awesome and I love this tool. Thx bye. 
If I am understanding the problem correctly and interpreting the code properly the culprit is probably line 84 where `lengthDirX` is assigned. I would try modifying the calculation there or determining if `rayWholeX` and `rayPosX` have the correct values.
You cannot directly write to a client via browser, security risks. But you could create a file and make it downloadable for the user. But if you want to keep your data after the message has been sent, you will most likely need to use a server with PHP or JS. Then you can use .ajax from the jQuery library to send it without reloading. The same goes for reading. Append it to the DOM with Javascript and have it check for new messages with a timer.
I can't speak one way or the other in the overall debate between npm and yarn, but from what I've seen, you use what you like. Also, I use yarn to run sizzy, and sizzy is pretty awesome, so there's that.
Very interesting. Thank you so much for the valuable information :))
Weren't most/all of these gaps addressed with NPMv5?
What happens looks weird indeed. However, it is not some random behavior. If you are still curious about the mechanism behind your result, check this: The confusion happens in this line: `console.log("Problem retrieving API, retrying in 5 min." + resp &amp;&amp; resp.statusCode);` 1- If you check JavaScript operator precedence, you will find that the addition operator `+` has a higher priority then the logical AND operator `&amp;&amp;`. Therefore it will evaluate first the expression: `"Problem retrieving API, retrying in 5 min." + resp`. Since resp is an object, it will concatenate into a string: `"Problem retrieving API, retrying in 5 min. [object Object]".` 2- Finally, the engine will make an AND between the string from step 1 and the resp.statusCode which is a number. Since, both the string and the number are not undefined, they both evaluate to true. The rule says: if you perform `expr1 &amp;&amp; expr2` and both evaluate to true, then the result is expr2. Therefore, given that both string from step1 and resp.statusCode evaluate to true, the result is expr2 which is resp.statusCode. 
really impressive work. Very well done and keep up. 
That handy feature was copied from Dart.
Hahaha, I never had this use case in mind when building this, but great to hear that it works!
What do you use that for? I can imagine sharing models. Anything else you've encountered which shares well between c&amp;s?
Hyped for string enums! Great work again from the TS team. Looking forward to the improved inference all around as well.
Dynamic async imports are really cool!
First three methods: for (var i=0; i&lt;viewDistance; i++) { Fourth method: for (var i=0; distance&lt;viewDistance; i++) { Also, you're distance calculations are super confusing. It seems that sometimes the distance involves the grid size.
No, yarn is still about 15-25% faster for me. And you can't beat `yarn upgrade-interactive`!
Hey FYI, i'm not interested in having a conversation involving walls of text it would be a waste of my time. Keep it around tweet length please. 
I still like yarn's `upgrade-interactive`.
lotions, potions -- promises, promises.
i don't agree with the "var is deprecated" thing consider this code: select("button#export", document).addEventListener("click", async function () { try { var storage = await browser.storage.local.get(); } catch (error) { console.error(error); alert("Failed to get data:\n\n" + error); return; } const text = JSON.stringify(storage, null, " "); select("textarea#data", document).value = text; }); i very much prefer `var storage = ...` here because if i did `let storage;` above the block and `storage = ...` inside it, the scope of the variable wouldn't be immediately clear from reading only the line with the assignment (from `var storage = ...` it's instantly obvious that it's function-scoped) it's kind of like how leaving out semicolons makes it harder to tell where a statement ends but people do it anyway
&gt; Yea thats a different method of stopping the line Right, but neither is working correctly and the first method doesn't even make sense. Change the fourth method to use `i&lt;viewDistance` and you'll see that it doesn't stop halfway through anymore because it's counting number of iterations instead of evaluating anything to do with distance. Also, just change the angle (`dir`) from -35 to 35 and you'll see that the way the grid size is included in the math isn't logical. Specifically: rayWholeY-=gridSize; That ends up affecting variables in your distance formula.
Yea, I will put more decision making for other directions but for now I'm focusing on the one direction. As for changing distance to i it made no difference.
I wrote a word cloud generator using [this](https://github.com/jasondavies/d3-cloud) library. Here it is: http://vps124502.vps.ovh.ca/projects-folders/wordcloud/wordcloud.html
How is this different than Redux?
I still dont see how its "worse" to be able to choose from 100 librarys where 10 of them are seriously maintained and all have specific pros and cons. Usually, since the web is so diverse, you need pretty damn specific stuff, which you then find to already have been done by someone else at the tip of your npm. Its not as bad as people put it.
Whoa. This is great. I've been doing tons of string unions with constants in there for each option in the same module. This is pretty much exactly what I want.
That's a lot of code. Typically, you should wrap exactly _one_ operation with `try{}catch(){}finally{}` and log an error related to that _one thing_ that failed. Additionally, be _very careful_ defining anything inside a request handler. Defining / allocated memory inside a request handler means all I have to do is slam your API with a billion malformed requests and you'll be burning CPU. Try refactoring this to be a lot simpler (ie: reproducible minimal case) so people here can help. 
https://i.imgur.com/6I8h0T1.jpg
npm5 been out for like a week and we're already getting these sassy headlines. oye vey, js community... oye vey.
That's pretty cool... I'm thinking about Instagram-like features in a social app I'm working on... be interested to see how it goes on mobile ( but yet to test ).
What's the benefit of nvm over n?
agree completely. need to bust that into a lot of smaller steps. 
It's actually a good trade in many cases because it prevents you from castling and leaves your king out in the open.
function fuel_consumption(n) { // velocity is a float, representing the velocity (in km/h) of a car // The velocity is assumed to be greater or equal than zero. // This function must compute and return the fuel consumption for 100 km // In case the car is idle, assume the consumption is 0 // If the velocity is up to 50, the consumption is 10 liters // If the velocity is more than fifty but less or equal than 100, the consumption is 11 liters // If the velocity is more than 100, the consumption is 12 liters. // Please initialize a valriable called consumption and assign the correct value to it. // Write your code below this line. // =============================================== var n = fuel_consumption; // ================================================ // Do not change the code below this line. // Also do not use additional document.write, console.log, alert, or prompt. // The only prompt/alert you may use are the one's already provided. return consumption; } var velocity = parseFloat(prompt("Enter the velocity (a nonnegative float):")); var consumption = fuel_consumption(velocity); alert("The fuel consumption is " + consumption);
function fuel_consumption(n) { // velocity is a float, representing the velocity (in km/h) of a car // The velocity is assumed to be greater or equal than zero. // This function must compute and return the fuel consumption for 100 km // In case the car is idle, assume the consumption is 0 // If the velocity is up to 50, the consumption is 10 liters // If the velocity is more than fifty but less or equal than 100, the consumption is 11 liters // If the velocity is more than 100, the consumption is 12 liters. // Please initialize a valriable called consumption and assign the correct value to it. // Write your code below this line. // ===============================================
I don't understand whats going on. QQ 
So to be frank, I think this is funny. But keep in mind we're not trying to push people to write JS like they're using languages other than JS, and that's never been the goal. It's always been about JS with types, not pushing JS to be a completely different language.
Thank you for leaving it to us purists. :)
A month ago or so I stumbled on this jewel - [Mnemonist](https://yomguithereal.github.io/mnemonist/). Along with some of the basics like Heap, Index, Queue it also has some advanced like Trie, Bloom Filter and SymSpell. If you are more interested on *how* it's implemented the [source code](https://github.com/Yomguithereal/mnemonist) is pretty good, too.
**Here's a sneak peek of [/r/learnjavascript](https://np.reddit.com/r/learnjavascript) using the [top posts](https://np.reddit.com/r/learnjavascript/top/?sort=top&amp;t=year) of the year!** \#1: [The Entire JavaScript Language in a Single Image](https://fossbytes.com/wp-content/uploads/2015/09/infographic-the-entire-javascript-language-in-one-single-image-491250-2.jpg) | [29 comments](https://np.reddit.com/r/learnjavascript/comments/675fk4/the_entire_javascript_language_in_a_single_image/) \#2: [Learn Modern JavaScript for Free (topics covered: webpack, nodejs, npm, es5, es6, esnext, &amp; rxjs, typescript)](http://courses.angularclass.com/courses/modern-javascript) | [29 comments](https://np.reddit.com/r/learnjavascript/comments/4vz5y6/learn_modern_javascript_for_free_topics_covered/) \#3: [This pretty accurately describes my feelings on my JS learning journey so far.](http://imgur.com/zKJt5rb) | [6 comments](https://np.reddit.com/r/learnjavascript/comments/5k71cn/this_pretty_accurately_describes_my_feelings_on/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
only a .netter would type that. TS will support it though! You should check out TS.
I built an automated tests repo to benchmark the performance of JS build tools (i.e. gulp vs. grunt vs. fly vs. brunch). You can check it out on [Github](https://github.com/karimsa/buildjs-benchmarks). I'd love suggestions &amp; to know what you think of the results.
I like using updtr - https://github.com/peerigon/updtr - because it automatically re-runs all the tests for you before trying to update each dependency. 
I haven't seen a JavaScript project with separate test directory in while, side-by-side with `*.spec.js` seems like the majority to me and it's very convenient. Haven't had the need to use different code style for tests and other JS, but it's clearly a limitation in ESLint if you *can't* do it without changing the project structure, the linter definitely shouldn't tell you where to put unit tests.
&gt;This page is unavailable when linked to from reddit.com. &gt; Please find a less toxic place to spend your time. lol
pretty dope
This was already posted [a few days ago](https://www.reddit.com/r/javascript/comments/6g0k7z/adopting_flow_typescript/).
&gt;and also a recommendation for the best environment to code JS in on an Android phone Recently found simple Android editor for JS code - "JS Run"
What parameter exactly is undefined?
The parameter you are having there are a bit weird. I think the `user` is probably part of the response json object. Can you print response and see what it has? 
Actually user is a parameter that I give to the first function, instead response is the body of get request. Basically i think this is a scope problem, i need the parameteres of the "main" function to be visible inside the "then". For now all that is visible is the response which contains the response to the http request
`then()` only provides one argument to its callback, but you're redeclaring the variables in the callback meaning they'll always be undefined. function doSomething(param) { asyncMethod().then((result, param) =&gt; { console.log(param); // Always undefined }); } vs function doSomething(param) { asyncMethod().then((result) =&gt; { console.log(param); // Value of param }); }
I was tired of not being able to simply draw on a screenshot on my android phone, and didn't feel like installing a 2mb app for that. So I made https://minimage.tk, a very minimal html5 image editor. I still get some "download failed" errors from time to time, i'm not sure why (given that its all client side). I does everything client side and works on mobile ofc.
You should definitely sprinkle some free cloudflare https on it :) It looks really clean, but I don't have a spotify account to test it :/ 
You can find couple of repos on github, they are pretty much the same at the end.
I'd prefer the underscore for marking properties private over a hashtag, since it's already a convention.
Thanks a lot. I'll go back through and work on making that more consistent. I've gone through a phase where I used one line if statements, using 2 lines looks better to me. Brilliant. Thanks again for the advice, means a lot. 
Link doesn't work anymore when linking from reddit :O.
You don't need to share your store between components. `createStore` just sets your initial application state. Inside your components you will work with action (pure function) and `dispatch` to dispatch actions that return new values based on your initial state, without change them. Your initial store state is immutable.
It looked so much nicer when they were using `@`before: class Foo { @privateFieldName; } although I guess they had to change it because of decorators using that symbol :/
F
is var deprecated if you emulate its behavior it's like how when i tried eslint once, the default rules recommended (ab)using constants and arrow functions and ignoring that there exists a keyword specifically made for declaring functions like it'd error for `function a () { ... }` and tell me to write it as `const a = () =&gt; { ... };` instead sure, you can't re-assign to the function variable or call it with `new` but isn't it the linter's job to catch those things? what i'm saying is that i don't think new things are automatically always superior just because they're new
This is just a higher-level wrapper for `lodash.clone-deep` + `deep-freeze`. Whats your motivation for desiring reference-free immutability?
Before I used Typescript, I assumed it would be some kind of java/c# horribleness, but I've been really surprised by how enjoyable it is. I found it engaging because it *is* like writing JS with types. I love renaming or deleting something or reshaping an interface and having the compiler tell me all the places my code will break. It gives me a new kind of confidence in my work. For what it's worth, I think your goal is being realized. Also, iz this a good place to ask for ADTs with pattern matching?
The motivation behind this was creating a way to prevent mutations (and in-turn their side-effects) in reusable test fixtures. This prevents us from needing to manually clone and freeze these, and gives us a simple api (via Proxy) with testing around the lib to ensure desired results. Ultimately throughout development though, our thought was this could be useful outside of that scope so we omitted that specific use-case from the docs.
It's different for various browsers, but what you want it `clientHeight`. `const windowHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;`
**Thats** not confusing, #[THIS](/r/confusing) is confusing!. *Y^aa^aa^aa^aa^aa^aa^aa*
jQuery doesn't give you a percentage height, does it? Either way, [check out the jQuery source code](https://github.com/jquery/jquery/blob/master/src/dimensions.js#L27).
&gt; Can't you understand lol
Ava is awesome, but we currently have numerous servers all running on top of the traditional mocha test stack. Fixd is simply a small utility that helps eliminate one of mocha/chai's many foot guns without having to rework an existing test suite. We're also trying to encourage our team to write their code in a more functional style, avoiding mutation where possible, and so throwing something like fixd into the mix lets developers see where they could make improvements. Ultimately it would be great to use something like Ava, where tests run completely independently, but there are always tradeoffs to consider. C'est la vie.
Sounds like you already answered your own question. Create some modern code, with a modern framework, and make a portfolio. Then go find jobs. 
It gets converted into appropriate promises that resolve the value of a `require` call in CommonJS, or it will stay the same if you use `esnext` for your module target. Webpack recognizes `import()` calls so it will just work. We've spoken with enough people within the committee that we get the sense `import()` is stable, and stage 3 is typically when we feel relatively comfortable adopting new features.
.
I'm having a little trouble following exactly how the benchmarks are calculated since it's literally just the build log. Given these results at the end: ############################ # RESULTS # ############################ fly average: 440692539.27 ns fly deviation: 39.47881616423943% gulp average: 713746702.55 ns gulp deviation: 53.749666809804076% grunt average: 1053175702 ns grunt deviation: 40.55947100990842% brunch average: 2008047552.82 ns brunch deviation: 32.11900837979439% Are those deviations the calculated standard deviations? If so your 95% confidence intervals would be the following: fly 0.44069 +/- 0.34100 s (0.09969 - 0.78169 s) gulp 0.71375 +/- 0.75194 s (0.00000 - 1.46569 s) grunt 1.0532 +/- 0.8373 s (0.2159 - 1.8905 s) brunch 2.0080 +/- 1.2641 s (0.7439 - 3.2721 s) As you can see the intervals all overlap, meaning there's really no statistical difference shown here. I'd suggest doing a lot more trials and/or running the benchmark on your own machine. By running on Travis-CI you can't know if each test is being run with the same CPU allotment, and I/O speeds could be wildly inconsistent depending on what other build tasks are being run alongside yours.
You're ok! Dutier not manage the application state, but instead it turn the local component state more Redux-like. I put the react example on repository.
Went for the code, stayed for the oddly satisfying examples 
and the name!
&gt; We've spoken with enough people within the committee that we get the sense import() is stable, and stage 3 is typically when we feel relatively comfortable adopting new features. That's good to hear (both that you think it's stable, and that you've actively researched that), and thanks for the explanation :)
Here's a codepen if anyone wants to fiddle around https://codepen.io/cheapsteak/pen/YQWBzQ 
call the same code that runs when you click the 'add' button when the user presses the enter key in the input field: https://stackoverflow.com/questions/11365632/how-to-detect-when-the-user-presses-enter-in-an-input-field you could also use the default browser behavior with an input wrapped in a form and a submit button, but that is probably more effort (though probably a better implementation). 
 self.badThings = [ "Jeremy Corbyn", ] lol
I'm not going to pretend to understand all of that, but wasn't shenanigans like this specifically why comments are disallowed in json. Tying functionality to comments turns comments into a defacto spec if enough people start doing it. And then people cry foul and block spec work over broken code if a spec comes later an changes the behavior. Seems very shortsighted.
I don't know if this is more my problem than a community problem, but when I read "Use Prettier with TSLint and relax" I seriously thought "Relax? What's this new package do?" TIL: [relax](https://www.npmjs.com/package/relax) is a couchDB utility.
The move ordering is the same in the alpha beta and the quiescence search, and is super hacky, loosely based on a few things I read. The idea is to put the moves most likely to fail high first, so captures (ranked by captured piece/capturing piece), movements of big pieces, and movements in opponent territory go first. It's a very temporary solution until I have a hashing solution and can start using static exchange evaluation, history heuristic, killer move heuristic and other techniques.
http://i.imgur.com/2neCZ.gif
Calling show on the element shows it, it does not imply that some future action will hide it. Call hide() on it when you want it hidden
The most surprising part for me is I thought it was a video. I'm on my phone using Reddit Now app, and it works as well as if I'm on the desktop. Talk about standards-compliant...
It looks pretty cool but I have three issues: * Clicking and dragging off a small image causes it to be highlighted (and turn blue/other default highlight color) on my windows pc running Chrome. * I can't figure out how to erase lines. * If I choose white for the line color, it's hard to see the button to change colors again. But good job regardless!
o.O wow
Oh wow, that's so cool! I was actually going to try to start learning JS today, and this only motivates me further. Great work!
Probably more effort than it's worth. I'd just put the babel code into a separate script, then transpile that and load that in.
You should always use braces with your if statements. It makes your code more maintainable and consistent. Airbnb has a brilliant [JavaScript style guide](https://github.com/airbnb/javascript) you should check out.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [babel/babel/.../**test** (7.0 → 5387d9f)](https://github.com/babel/babel/tree/5387d9f9033b3bed063b8fd28acbcf3f1b7bf26b/packages/babel-core/test) * [angular/angular/.../**test** (master → 0c07f8c)](https://github.com/angular/angular/tree/0c07f8c09955812d7ec54bba8aecdab8bc7da0fe/packages/core/test) * [jashkenas/backbone/.../**test** (master → 0eca92f)](https://github.com/jashkenas/backbone/tree/0eca92f441f63091f3cab0fc900fa21afbfc55fe/test) * [gruntjs/grunt/.../**test** (master → 115a182)](https://github.com/gruntjs/grunt/tree/115a18234d2ca40163761e76384101da0dfe5991/test) * [mochajs/mocha/.../**test** (master → 7647e18)](https://github.com/mochajs/mocha/tree/7647e1820a9720e9d4b4f837aef1fd1a69c5b876/test) * [webpack/webpack/.../**test** (master → 7eb7529)](https://github.com/webpack/webpack/tree/7eb752902fa9bd9fee921ea43877562494d4ee6b/test) * [karma-runner/karma/.../**test** (master → be83116)](https://github.com/karma-runner/karma/tree/be831165102c947951eaeba752cdc55743bd4883/test) * [gulpjs/gulp/.../**test** (master → a0ec3ff)](https://github.com/gulpjs/gulp/tree/a0ec3ff91c84baa1bd8de5331a502e330f5e3cfe/test) * [eslint/eslint/.../**tests** (master → 26a2daa)](https://github.com/eslint/eslint/tree/26a2daab311c8c59942c52f436d380a195db2bd4/tests) * [emberjs/ember.js/.../**tests** (master → 1425a52)](https://github.com/emberjs/ember.js/tree/1425a52efb0fdc5caaffa2f11726f350911a4660/packages/ember/tests) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply divabxt.)^.
The form approach is definitely the way to go. It's canonical, uses semantic elements, and will work nicely for accessibility. 
Thanks a lot for the post. In this case I want code execution to be synchronous and pause here until the while loop either breaks from the if statement or goes over the timeout (very unlike JavaScript, but suitable for the application/situation). Maybe it would be best to not include any code examples like this in the case that I get to show something to a potential employer since there's probably quite a few things that would be bad practice in real world JavaScript. Thanks for the detailed post, I will keep this in mind for my real world JavaScripting
I think the challenging part was that the spec doesn't allow any way to specify a chunk (there's no concept of chunks as far as the browser is concerned). So the only other alternative is basically the equivalent of `module.hot.accept`. Basically developer-only "accompaniment" code. So basically it depends on if you think that's worse or not. I will say: I think the simple comment is likely to get a lot more usage than `module.split.nameChunk` or something. I think people tip-toe around using that feature except in the one or 2 places specified by react-hot-loader. Also, even if there was `module.split.nameChunk` or something, it still would only work in Webpack. ...I think for now this is just something we have to live with. Perhaps in the future, code building will somehow grow some intrinsic connection to the browser. Like, it seems the browser would have to start considering how you build your apps for any single solution to become a standard. One last thing: they built this magic comment feature cuz they give a shit about DX. Without this it was hell figuring out what chunks to serve. They're smart people up against challenging scenarios and shitty tradeoffs they have to make. 
Update: I have started working on a detailed walk-through going through the exercises and solving them recursively and iteratively. The first section on reversing a string is up. More content will be added. Appreciate the suggestion!
While all 3 are web technologies, they're also quite separate conceptually. Knowing HTML and CSS definitely helps when working with the DOM which is like what 90% of the web is, it's not useful for things like this demo which are almost purely JS programming.
Spoilers: it doesn't
Holy shit dude that's awesome
I've been saying from the start that Webpack's pattern of breaking from or extending standards inserts it as an implicit dependency of almost every file in your project - which is great for Webpack, and bad for you. So, in a way, I'm glad they added this. Now it's becoming clear to everybody that WebpackScript is not JS.
This fucking rocks.
I try to do as much as possible in CSS before needing JS. But this pen? Ha, no way. Feel free to check me out though https://codepen.io/TravisL12/
So the checkStates not defined problem is that of scope; Your function is declared within another function (function(){ function checkStates })() The html relies on the global/window scope. So, to do this, you either need to declare the function outside of the enclosing function, or set the function to be a part of the window object (`window.checkStates = function() { ... }`)
um I don't really care but you do realize that ginder is a derogatory term for indians right?
r/fived material 
Call hide() on all sections and show() on the one that is selected afterwards. 
Yes, always use the braces. In many shops, including mine, it's acceptable to leave them out _only_ in a one-liner with a single statement _on the same line_ as the conditional, e.g.: if( ! text ) return false; But if you split it into two lines, then the braces are required, as in your example above. Here is why: hashOut.data = hashes + SSL_MD5_DIGEST_LEN; hashOut.length = SSL_SHA1_DIGEST_LEN; if ((err = SSLFreeBuffer(&amp;hashCtx)) != 0) goto fail; if ((err = ReadyHash(&amp;SSLHashSHA1, &amp;hashCtx)) != 0) goto fail; if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;clientRandom)) != 0) goto fail; if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;serverRandom)) != 0) goto fail; if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0) goto fail; goto fail; if ((err = SSLHashSHA1.final(&amp;hashCtx, &amp;hashOut)) != 0) goto fail; err = sslRawVerify(...); This is C code, not JavaScript, but the issue is the same. (JavaScript doesn't have a `goto`, but imagine all the `goto fail;` statements are `return false;` instead.) Do you see the problem in the code? If you don't see it right away, don't worry, a lot of people reviewed this code and missed it too. Try the exercise of putting in all the missing braces, and then you will spot it right away. And it's not a contrived example; this is the infamous "[goto fail;](https://www.google.com/search?q=goto+fail)" bug that allowed attackers to intercept "secure" SSL connections in iOS 7. Here is a good [description of the problem](https://nakedsecurity.sophos.com/2014/02/24/anatomy-of-a-goto-fail-apples-ssl-bug-explained-plus-an-unofficial-patch/). If you always use the braces, you're much less likely to introduce this particular kind of bug. And the reason it's OK to leave them out only in a one-liner is that you aren't so likely to put _two_ statements after the `if`. While we're talking formatting, thank you for using four-space indents! The majority of JavaScript shops these days use two-space indents, which are a real problem for older programmers like me who _need_ the extra visual spacing that you get with four spaces. Tabs are fine too, because whoever reads the code can select the spacing they find comfortable. Actually, on a second reading I see you have mostly four spaces, but in some places there are three-space and eight-space indents. Pick one and stick with it. This is also a big advantage of tabs: you will naturally have more consistent indentation.
You can just use Array.prototype.filter + Array.prototype.map for this. ~~Recursion would be a bad choice.~~
Can you write an example? I ended up loop infinately, and couldn't figure out why.
Thank you very much for the informative post. I have heard of "goto fail;" but I never actually knew what it was. That was a good read. Makes perfect sense, I have changed all my if statements to use braces and it's great to actually know why that is the preferred style. No probs! I find 4 spaces visually better as well, I think it makes things look neater and less jumbled. Thanks again for your time and the great information.
You definitely need recursion here. Array filter will give you only first level of nesting. 
I would love to see a write-up/tutorial explaining the math behind it, something I would love to learn how to do.
 #goodStatement _noAnswer $chooseYourSide
This looks pretty solid. Some more comments would help, at times I had trouble following what was happening. I noticed you cache the array length in for loop declarations. This isn't really needed as the compiler optimizes it just the same. The only difference is that you're writing more! Don't be afraid to write: for (const i = 0; i &lt; xs.length; ++i) { ... } EDIT: I was pretty tired when I wrote this and was thinking of `const x of xs`. The above is not valid, instead it should be: for (let i = 0; i &lt; xs.length; i++) { ... } 
Genius !
not so tedious once you know the maths, here is a 3D renderer I did some time ago: http://tamats.com/apps/raster/ The important part is to understand how matrices work.
Wild guess: no, he didn't realize that.
Using Ramda: `R.pipe(R.aperture(2), R.apply(R.add))(array)`
I cant even imagine what it takes to do this even know I know some js
Thanks. I understand every line of the code: first find all the first level subtasks, then if second level exists, get all the second level subtasks. But it is still tricky for me to think of the recursion... Please enlighten me, how to think in recursive programming...
I deal with recursion pretty frequently, and I still confuse myself every time :) I think the best way to learn recursion would be to start with mathematical functions because they make the manipulation of the result more obvious. Here is [a StackOverflow question with a whole bunch of explanations for a Fibonacci function](https://stackoverflow.com/questions/8845154/how-does-the-the-fibonacci-recursive-function-work).
Damn, son.
Hey, maker here. I always try to use CSS only for my pens if I think this is possible! I've done quite a few things without JS, like a [minesweeper](https://codepen.io/bali_balo/pen/BLJONk) and [quite a lot of GIF recreations](https://codepen.io/collection/XKpeay/). Actually, the initial idea behind this pen was also to use a mix of JS and CSS animations (6 canvas placed on a CSS rotating cube), but this was more complex than I initially thought, so I went ahead and used full JS. As the others said, we can do pretty crazy stuff with CSS but I don't think we could achieve something like this with what we can currently do. There are a few things like mouse interaction, the "physics engine", pong, and the "eletricity", that could not be done in the same way.
In the ball to player1 collision detection function you are only using player1Size. Shouldn't you be using player1Size offset by player1Pos?
Not working for me.
Thanks
The most popular editor of the moment continues to be Notepad++ (according to StackOverflow) but the trending editor was Atom and is now VSCode from Microsoft. I haven't seen any editors that feature abstracted DOM mapping. This isn't really a demanded feature. Either people completely put their heads in the sand and ignore how the DOM works as much as possible or they fully embrace it with no trouble in understanding or managing it. It is rare to see only two extremes like this, but the DOM certainly does it. Coming from a heavy jQuery background I am going to assume you probably are less comfortable with the standard DOM methods and how those relationships naturally come together. The jQuery sizzle selectors are now standardized as querySelector and querySelectorAll. Keep in mind that querySelectors are 2800x than the older DOM methods, except for when looking things up by attribute name or value in which case they are about 16x faster cross browser. You can start by reading this: http://prettydiff.com/guide/unrelated_dom.xhtml &gt; I see that Node.js is a thing now - but for simply accessing information from a database - is it worth the learning curve? Yes. &gt; Fifth, I'm seeing all of these different frameworks If you are learning or trying to get back into development after a long absence then ignore the big frameworks and all the trendy bullshit. Get familiar with the technologies again and how to organize logic so that it scales and is more maintainable. Frameworks will attempt to do this for instead of helping you learn it. &gt; Sixth, I see this npm - and if I understand this is like a giant repository of code. In order to access it, I need to install node.js on my server. NPM is Maven for JavaScript. It is a collection of many modules that people bring in as dependencies. I am not a fan of NPM (and it seems many people aren't, but it seems to have gotten much better with NPM5). There are two major problems exposed by dependency management in this way: * If the app is a service or something designed to execute in a widespread distributed way then all the risks and problems associated with unmanaged dependencies can be conveniently ignored by you until they expose defects that your users will notice before you will. * You can use NPM modules for client-side applications in the browser but this requires a build step and additional tooling that is otherwise completely unnecessary. Many developers cannot live without this, but I think it slows me down and gets in my way. &gt; How does npm differ from bower Bower is still in use, but not much. Bower never became the drug addition that NPM became. Also NPM has scripting capabilities that allows you configure code in response to events with regard to various package installation/publication tasks. &gt; So not to sound like a dick, but what's the point of going through all of that hassle when I can just fling a copy of jQuery jQuery is slow crap that exists for convenience and to ramp up people (otherwise unqualified people) quickly. Once you learn how the technologies work you will learn how to reuse code and write aliases/abstractions and these things largely account for all the goodness jQuery provides. &gt; Finally - I see git is a popular tool for source control. Absolutely. git is one of the best things that ever happened to software. It isn't perfect, but it is hands down better than all other version control alternatives. Once you get familiar with this I advise checking out IPFS.io to see the git concept on steroids.
Why your "service" need to be used from the web ? What do it so special to be not available to do locally, inside the plugin or a third party executable ?
"Modern", yet it has no migrations.
My analysis engine is written in Scala. So to do locally, JVM should be installed first. And I thought the "web service API"-version is better in that it's always up-to-date :) To be honest, full local version is on the future plan. I wanted to distribute API-version plugin first. (as a "lite" version)
&gt; to match my normal approach of OO design Consider freeing yourself from this burden. Many things become easier when you simply stop worrying about types and object API's and simply work with messages. 
Angular 1 is still around and maintained. It's essentially a separate product from angular 2+. Why not just use that? You already know it. 
Books about JS (or coding in general) are outdated the second they leave the press.
&gt; I see this npm - ...In order to access it, &gt; I need to install node.js on my server. No. You don't. You just install Node.js (and npm) on your computer (i.e on your desktop computer or laptop). Then you open your console (on windows you run `cmd.exe`) and run npm as normal command. Then you write your code in modular way, i.e. you divide your application on many smaller files (so called "modules") &gt; I could mentally handle looking at a file with a few hundred lines of &gt; code, but as that grew to thousands It shouldn't grow to thousands. If you have too big file it's usually sign that your application is poorly divided on modules. It's better to create many smaller files (divide project into logical components). Unfortunately JS doesn't fully support modules, so you have to use Browserify or Webpack to build your application (these tools can analyze your modules (even if you have many) and then output one `*.js` script you will be able to include in your `*.html` file. And about NodeJS - although you probably will have to install NodeJS on your computer, that's all. On your server you do NOT need have NodeJS. You can have anything you want. It's independent. NodeJS is not only for servers. NodeJS is just runtime environment which enables running JS files as independent applications/scripts. 
[React is fully type safe](https://github.com/ryanatkn/language-service-in-motion/blob/master/docs/react_vscode_typescript/react_vscode_typescript.md) out of the box, including templates and props types. TS parses JSX by default. Haven't used it but Microsoft has recently published a react-ts starter: https://github.com/Microsoft/TypeScript-React-Starter Facebooks flow is also a good choice for types, less intrusive at least. For a good tutorial in general check out [eggheads](https://egghead.io/courses/react-fundamentals). Most frameworks today are based on react, there are only a handful left that aren't. Angular being one of them and as you've noticed they are quite complex and large, which is a given once you deal with templates and traditional mvc. The functional paradigm will remain, so it probably makes sense to learn it. For logic you most likely want to look into redux, mobx or mobx-state-tree. Just like react itself, these are modern conventions, not framework specifics. 
&gt; What exactly are these frameworks doing for me that improves &gt; how I would normally do this? they make easy to create reusable components. I think this is their value proposition. Reusability, composability. You don't create monolith but you create visual widgets for your website (these widgets are often called `components`). These widgets know how to display itself, how to react when they are clicked etc. When you have bigger project you just don't write one big file but you create application in modular way. You create components which are composed from other components etc. Besides there are some other advantages (and disadvantages too).
Nice!
I can rotate it with my mouse, but I can't change the viewpoint like I can in Cities: Skylines for example by holding middle mouse button.
Thanks for taking a look. Yeah - when looping, I generally have saved the `.length` variable separately in the past. I think this is more a force of habit more than anything else though - good to know that this is optimized and we can make the code a little more readable without this additional variable. I think you make a good point on the commentary too. I'll have a second look at that and see if I can add some useful pointers here and there.
The experiment is "old", when I started to develop, probably I didn't know about Vuex. The idea was to do using Redux, a challenge for myself :)
I think [Elm](http://elm-lang.org/) would be worth a look, they boast no runtime exceptions.
I already changed to GameChange, thanks guys!!!
&gt; then all the risks and problems associated with unmanaged dependencies Can you expand on this? There's two interpretations I can take from it: 1 - npm doesn't lock down dependencies of dependencies 2 - "unmanaged" means unmanaged by you personally If #1, npm5 has resolved that as well as (or better than) yarn. If #2, uh, yeah. 
Since no one else touched on this specifically, `bower` is a package manager (though one that's quickly being replaced by `npm` directly, using something like `webpack` or `rollup` to actually build a distribution file). You want to use it for the same reason you'd use any package manager. Sure, you can download a version of jquery and drop it in your public directory. But with something like bower, it can tell you when something's outdated, and it will manage dependencies for you. If you want a datepicker based on jQuery 4.0 but you manually dropped jQuery 3.0 in your public directory, you have to manually google and download `datepicker.js`, you have to know about it's dependencies and that you don't have the right version of jquery installed, and manually download them too. `bower install datepicker` just does all that for you, and `bower outdated` will tell you when new versions are available. Is it necessary? Nope, and I know devs who manually download everything. But it saves you a few minutes here and there, and it's super easy to learn, so I figure why not. &gt; what in the fuck is the point of having 3 extra layers of dependencies/complexity Once you use `npm` or `bower` once it no longer feels that way. But if you've never used them I can see the hesitation. 
Do you have an alternative to bootstrap that you use and could recommend? I've looked into a couple but didn't really like the sounds of most of them. Ideally I want an alternative to bootstrap that will give me a grid system as well as responsiveness, and then I can apply my own styling on top of that. At that point it basically just becomes bootstrap again though, I realize. But I'd like to find a css framework that doesn't rely on jquery. 
I feel like if you want Bootstrap but lightweight and without jQuery, try [Skeleton](http://getskeleton.com/)
Take a look at [A Study Plan To Cure JavaScript Fatigue](https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1) 
&gt; observables can be modified anywhere Hey, check out `useStrict`, allows you to only modify state in actions &gt; mobx-state-tree to give us the best of both worlds Haven't looked at this much yet, but looking forward to it!
It's beautiful. My next thought was, "speed up the rotation, make it pulse (rhythmically scale up/down around origin), and add a chiptune soundtrack".
What modules does it use to analyze the code? Anything else beside eslint? 
Redux enforces structure around how you modify state. Mobx lets you modify state in a less disciplined manner. If you don't share a lot of state, you probably don't need much more state management other than setState. If you are sharing lots of state, it becomes much more important to control how you allow that state to be modified and where. That's where redux comes in. I don't see a huge use case for mobx other than allowing imperative programmers continue an arguably poor standard of practice with magical keywords and undisciplined mutation being the rule rather than the exception. The big downside to redux is the learning curve and the boilerplate. The learning curve is significant. I give it that, but in return for it you get explicit, easily identifiable behaviors. It gives you sanity in the exchange for a bit of ceremony. The only pain point besides the learning curve that I've experienced with redux is that dealing with nested state can be difficult to reason about even if the nesting makes the most sense for your application. You really want your state to be as flat as possible, and some times that doesn't make sense. Of course, because reducers are pure, this makes testing even the most contorted action a rather simple endevour.
Sorry if I sounded defensive, was just confused. Thanks for clarifying. But back to the main point, these types of features can easily be solved with PRs. That's the beauty of open source.
I think next is a good framework to get start bc its react but go can get away without configuring a lot of things and IMO is less bloated than using CRA (create react app) for starting. I just made a CLI tool to build static sites using next and tachyons [here](https://github.com/lucas-aragno/wodle)
thanks - a lot of food for thought 
thanks - the modular approach sounds like what I need 
 const doSomething = val =&gt; this.something(val) array.forEach(doSomething) 
thanks for this synopsis
Oh wow, I thought arrow functions where just a shorter syntax. I was not aware that they did not bind a this. Thanks! I probably saw it with function, not arrows functions.
Code has a decent amount of comments if you're interested.
Hey, would you be able to recommend a good resource for learning the kinda of gotchas like this in javascript? I am already thoroughly familiar with different programming constructs &amp; languages, so I don't want to pick up a book that goes over if -statements and design patterns etc. I just want something that focuses on the language. I've been caught up by things like var, let/none and this foreach stuff now. I think I should really look into some reading material.
[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript) you can look up anything you want, it covers all the language features, object / array methods, browser apis etc
Thanks!
I think [YDKJS](https://github.com/getify/You-Dont-Know-JS) is exactly what you're looking for. It does not cover beginner basics, but specifically covers JS specific "quirks". The "this &amp; object prototypes" series or "es6 and beyond" series cover the arrow-function/this interaction.
To be more specific, arrow functions keep the same `this` reference as where they're declared. If they're declared inside of a class method, they point to whatever `this` was when that arrow function declaration runs. 
&gt; I'm having some trouble figuring out how to add the variable names. You simply add to the object. Remember JS is dynamic, so unless you make it immutable, you're free to add or remove freely.
This is the correct answer. The "better way" is to just remove the alias in this instance since arrow functions do it for us already.
Looks good, thanks for sharing! 
Is there a guide for training your dog to press the poop button?
Bien joué !
Filter returns an array. What if you use [array.find\(\)](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/find?v=example)?. You can perform these operations millions of times per second. Unless you are dealing with huge arrays or doing this constantly I would not worry. &gt; premature optimisation is the root of all evil
You can try something like this: $('input:radio[name="shipping"]').change(function(){ if ($(this).is(':checked')) { //do something } });
A normal for loop with conditions will prevent you from looping the same array twice to get what you want. If you really want to use this with es6 features, you can make a cheesy hard to read statement with array reduce
Where can we vote to get decorators to be accepted in stage 3 ?
This is what I was thinking, I guess I don't have to be fancy and just use a regular for loop.
If you're confident to write this app in react, you should just make a class to do this. I doubt there's a library to do something as specific as this, and if there were, the overhead of learning how to use the library and glue code you'd need to write will be more work than just writing something specific to get the job done.
Just put it on another page 
This is actually a pretty cool idea.
i must be missing something. i don't see an actual question outside of what you're saying the answer should be. what was the question on the actual exam?
You forgot to actually post the question.
Was it multiple-choice or did you type it in? If it's case-sensitive, the answer would be `The cat named tiger purrs`, not `The cat named Tiger purrs`. Or maybe it was a trick question, since there is no code actually calling any output functions. If you posted ALL of the code, the right answer might actually be "Nothing."
If I'm reading your code right, nothing should be written to the console. All the constructors just create objects, with functions on them, but nowhere in your code are the functions being called. If you made a tiger, and then did `tiger.pet()` or `tiger.vocalize()` you would get text.
I thought it was a cool idea too! http://mrclay.org/encrypt-to-html/
In case you're wondering why JS Devs don't write tests and are not happy about it, it's because not a goddamn one of the things you listed in your incredibly comprehensive list is well designed. They don't take into account *any* of the best practices we've developed over the years. Here's an easy one, give functions names, that describe what that function does. If you give me a function called "it" I'm going to track you down, break into your house late at night, throw away all of your shoes and replace them with Crocs. "it" is not an acceptable name for a function and "it" never will be. I really don't know who the hell these things are designed for. Is if for Quality Engineers? Product Owners? They don't write the code, they don't write the test, most of them don't care *at all* about these tests. None of these are designed for humans (or even developers). They're so fucking bad. And none of them have decent documentation to explain the made up terminology they are using. You have a function called "describe" or "assert", but those don't tell me what the functions **do**, they give me *instructions* of what **I** should do. *I* should assert something, *I* should describe something. That's not how we fucking write functions. I can't read this shit. Just tell me what it is **you** are doing, and I will pass in the relevant data you need to do that. Jesus fucking bullshit. There are libraries that are logical and predictable and even intuitive to the point where you can have zero experience with them and just *guess* what a method name would be called and not only would it actually exist, but it would be called the name you intuitively guessed. That's some tough shit to do, but it's been done before. None of these come **remotely** close to that. All of their naming conventions come from preexisting shitty testing frameworks from other languages. I don't give a fuck how *Rubyists* or *Pythonistas* write their shitty tests in their shitty language in their shitty frameworks. Let them suffer with it. Let's makes something that actually makes sense for THIS shitty language (I actually like JavaScript, most of the time). I have no idea how to use any of these damn testing libraries and I have no real interest to. I've spent days looking over them and can't get past how every single one of them requires me to write shitty code to use them. If using your library requires me to write shitty code, I'm not going to use your library. Non-negotiable. Now don't confuse this with an excuse to not write tests. People who defend the shitty state testing is in will attack those who call it out and say "They're just lazy" or "They just don't want to write tests". Fuck you. Fuck you assholes so hard for keeping the pile of shit that we have as options as the status quo. I ***really***.... ***really***, want to test. So much so, that I write my own bare-bones system to test the logic in my own personal projects. I've written thousands of tests this way. It just runs in Node, and if any single test fails it throws an error with the info about the test that failed and the file it's in. That's it. Unless 100% of tests are passing I can't do a commit. I'm getting the main benefit of the unit tests, just without any of the bells and whistles. I'm putting myself through extra work, for a worse result, because I won't stoop to the level of writing code so bad that I have to use a single character function name for it to work. Fuck the state of JavaScript testing. We need a new revolution, and I don't think we can look to Facebook or Google for it.
In that case why not simply: ``` const myArray = test.filter(t =&gt; t.type === "apple" || t.type === "orange"); ```
voting? if you're in a ecmascript comitee you know where. If you're not, tough luck.
&gt; than scanning a few reducers in Redux. good luck if you have more than a few.
You could probably build this by using [microanalytics](https://github.com/yoshuawuyts/microanalytics) and then maybe something like [virtual-hyperscript-svg](https://github.com/substack/virtual-hyperscript-svg) or [svg-create-element](https://github.com/substack/svg-create-element)
No. Next!
X-Post referenced from [/r/node](http://np.reddit.com/r/node) by /u/J-Kob [Build a Serverless Twilio SMS Bot and Call Center in 7 Minutes with Node.js + StdLib](http://np.reddit.com/r/node/comments/6h6brv/build_a_serverless_twilio_sms_bot_and_call_center/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
This might be better done as a reduce? const { apples, oranges } = test.reduce((reduced, item) =&gt; { if (['apple', 'orange'].includes(item.type)) { reduced[`${item.type}s`].push(item); } return reduced; }, { apples: [], oranges: [], }); Though that's pretty gnarly. 
Additionally, if you use socket.io or websockets you can negotiate a key beforehand and encrypt all traffic with that key using AES. I've implemented it in a test project and it seems to be doing ok. :)
This title is all over the place. Password protect a static HTML page. Server? Client? Encrypt your string. Is the HTML page used as a string to encrypt? Download your string into an HTML page. Wait a different page? Upload anywhere. Upload what? Where? My string I'm uploading? Why the fuck are we encrypting on client side. I'm not going to read this just to understand the title. I'm not trying to be pedantic. I just don't want to give sites hits for deliberately confusing its readers.
There is such a thing as secure websockets. 
I see, this is pretty much what I had already. Was looking for something that doesn't call the filter function twice.
Enlighten me oh great one.
I'm unclear as to the problem this is solving?
&gt; let [apples,oranges] = [ &gt; test.filter(t =&gt; t.type === "apple"), &gt; test.filter(t =&gt; t.type === "orange") &gt; ]; There is no point in using destructuring there. let apples = test.filter(t =&gt; t.type === 'apple'); let oranges = test.filter(t =&gt; t.type === 'oranges'); Much simpler. Well, destructuring starts to make sense if there is a useful array on the right-hand side: let [apples, oranges] = ['apple', 'orange'] .map(type =&gt; test.filter(obj =&gt; obj.type === type));
 function Animal(name, sound) { this.name = name; this.sound = sound; this.vocalize = function() { console.log("The", this.name, "says", this.sound); }; } function Cat(name) { Animal.call(this, "cat", "meow"); this.pet = function() { console.log("The", this.name, "named", name, "purrs"); } } function Dog(name) { Animal.call(this, "dog", "woof"); this.pet = function() { console.log("the", this.name, "named", name, "wags its tail"); } } var ginger = new Dog("Ginger"); var tiger = new Cat("tiger"); tiger.pet(); There ya go
Already the status quo in China, so the answer is already yes. Seems like a more natural candidate for people migrating from angular than ng2 is, so I see it becoming big here too eventually. 
The title is pretty confusing. It's a tool you can use to turn html+a password into different html that first prompts for the password and then shows your original html.
I haven't clicked the link yet so all of this is what I've worked out just from the title. &gt; static HTML page. Server? Client? Static and dynamic are common terms to describe two types of web content. Static is unchanging and when served by a server is sent as is (i.e. no scripts or programs are run). CDNs are an example of a service that only hosts static content. As such static content does not require a server to be viewed correctly locally. Dynamic content is like a PHP file or other scripting language and requires a server to execute it to be viewed correctly. &gt; Download your string into an HTML page. Wait a different page? I would guess the link takes you to a form that you enter a string which is then encrypted with a password and put into a new page that you then download. This new HTML page can be run locally, it displays a prompt for the password used during creation and if correct will decrypt the original string and display it. Sorta like a self-extracting zip file. &gt; I'm not going to read this just to understand the title. Then you'll never learn anything new. &gt; I just don't want to give sites hits for deliberately confusing its readers. The poster picks the title and isn't necessarily the same person that made the site. Edit: Clicked the link, exactly as I imagined and described.
Do you even read your own links? &gt;Many markup languages **such as HTML, MXML, XAML, XSLT or other user-interface markup languages are often declarative**. HTML, for example, only describes what should appear on a webpage - it specifies neither control flow rendering a page nor its possible interactions with a user. HTML and CSS are indeed declarative, because by **stating something must be red** you are indeed defining a logic, just not doing it explicitly like in the **imperative programming paradigm** you are referring to as *"programming languages"*. 
Pedantic?
The same problem any encryption solves, to prevent others viewing content you don't want them to. This is geared towards HTML content and provides a convenient way to distribute and decrypt content that only requires a web browser (which everyone has) and not any other software.
1. Create an original HTML page 2. Submit your HTML page, and proposed password, to this service 3. Receive a new HTML page generated by the service. The new HTML page contains your original HTML page in an encrypted state. 4. Send the service-generated HTML page to some via the web or email. You can use insecure channels. 5. When the service-generated HTML page is opened, and the correct password is provided, the original HTML page you submitted to the service is displayed. Why encrypt on the client side? So that the person using the service can always see exactly what is happening with their data. Why decrypt on the client side? So that you're not dependent on any third party service being available, performant, and secure. Some may argue that the unencrypted data not being sent on the wire is a perk. The explanation could definitely be better but it isn't difficult to grok. 
&gt; If you give someone the library and method to unencrypt, there is no point in the password. So, if you're given AES encrypted content, and an AES library, you think you can read the encrypted content without the password/key?
I'd do it like this: const { apple: apples, orange: oranges } = groupBy('type', test) console.log(apples) console.log(oranges) const hasOwnProperty = Function.prototype.call.bind(Object.prototype.hasOwnProperty) function groupBy (prop, collection) { return collection.reduce((result, target) =&gt; { if (hasOwnProperty(target, prop)) { const value = target[prop] result[value] = (result[value] || []).concat([target]) } return result }, {}) } Most utility libraries already include a `groupBy` implementation ([Underscore](http://underscorejs.org/#groupBy), [Lodash](https://lodash.com/docs/4.17.4#groupBy), [Ramda](http://ramdajs.com/docs/#groupBy)) - most of them actually support a function as the "prop" parameter, allowing more complex grouping logic.
You're kinda missing the point. That's like saying you can unencrypt Json Web Tokens without having the password... Unless I'm mistaken, I think the idea is to serve someone the html generated page only. So this is more of a tool than a lib. I will give you a encrypted string and you will also know the algorithm I've used to encrypt it. Can you decrypt without the password? I don't think so.
Copy pasting the comment I made to someone else: You're kinda missing the point. That's like saying you can unencrypt Json Web Tokens without having the password... Unless I'm mistaken, I think the idea is to serve someone the html generated page only. So this is more of a tool than a lib. I will give you a encrypted string and you will also know the algorithm I've used to encrypt it. Can you decrypt without the password? I don't think so.
&gt;couldn't get my head around JSX at ALL Give [hyperscript](https://github.com/hyperhype/hyperscript) a try. 
Is it so? But being in digital era now, having everything online is easy i understand. But books are still everyone's friend everyday. So i would not accept the thought you have.
Check out RE:DOM! https://redom.js.org 😎
And how much of that did you get from the title without following the link? The claim wasn't that the concept is complicated, just that the title is garbage. If you got all that from the title, consider me impressed. 
I got all that from the title. The title isn't good. No argument on that front. 
If you haven't already, perhaps take a look at [Vue](http://vuejs.org). By default, it doesn't lend itself to an OO style, but I like to think that it's a part of its simplicity. Try it out and see if you like it. [There's also a library that enables you to write classes as well](https://github.com/vuejs/vue-class-component), which gives it better TypeScript support too.
&gt; So i would not accept the thought you have. I don't accept Windows being as popular as it is, but it's still true :) The problem with books about coding is that a lot of things change all the time. Best practices change. Functionality changes with every new browser version. Standards change every now and them. Books can be used in a limited way to communicate the very basics of programming or the "higher concepts" of how to do transfer ideas to code. But for actually learning a new language to code in online sources are always more up-to-date.
thanks, I'll check out this stuff! Thank you! 
You don't need any special program for JavaScript. Any text editor will do. Two that I use are Sublime Text 3 and NotePad++ although I prefer Sublime far over NotePad++.
There ain't best. All has good stuff and their own flaws.
Yea I mean more of the most favourite program
I don't disagree with your sentiment at all. But, the argument has enough of its own merit without trying to pull useless metrics in. The jQuery file was loaded from a CDN. Not only is the file almost guaranteed to already be on your visitors computers, and thus pulled right from their hard disk, it was originally served to them in a compressed state and was likely one of the fast loading assets on that page. The only real relevance "84kb" has is that's how much space it takes up on the visitors hard disk. Which there's hardly a soul on the planet that would get upset about that. If you want to convince someone to start using modern JS in place of jQuery 3, it might make sense to use a more persuasive argument than this.
malware writers will love this, I even see opportunities for wordpress ransomware "your blog haz been encrypted, send bitcoinz"
Thanks so much for the reply. The part of the code that I think I need to add certain statements is here function BBoxAnnotator(options) { var annotator, image_element; annotator = this; this.annotator_element = $(options.id || "#bbox_annotator"); this.border_width = options.border_width || 2; this.show_label = options.show_label || (options.input_method !== "fixed"); this.image_frame = $('&lt;div class="image_frame"&gt;&lt;/div&gt;'); this.annotator_element.append(this.image_frame); image_element = new Image(); image_element.src = options.url; image_element.onload = function() { options.width || (options.width = image_element.width); options.height || (options.height = image_element.height); annotator.annotator_element.css({ "width": (options.width + annotator.border_width * 2) + 'px', "height": (options.height + annotator.border_width * 2) + 'px', "cursor": "crosshair" }); annotator.image_frame.css({ "background-image": "url('" + image_element.src + "')", "width": options.width + "px", "height": options.height + "px", "position": "relative" }); Like you said, just changing the image_element.width or height values only crops the image. That means that I probably need to use CSS to scale it. But, that being said, (today is the first day for me reading HTML and Javascript haha) . How do I go about adding a CSS script into a function that is called in jQuery or is it Javascript. edited: for poor code formatting
React
I don't know, what the `options` object is and where it comes from, but you can do it you way: "width": options.width + "px", "height": options.height + "px", You just need to calculate the percentage of the image size relative to the `options.width` (**or however you can get the nominal width of the background image**). Then you set `height` to `auto`. like: var iPercentWidth = (image_element.width / options.width) * 100; // then in css object "width": (iPercentWidth + "px"), "height": "auto" **edit:** pressed *reply* accidentally 
Ahah, so this is a bit awkward for me, but here are a few things about me : I started coding at 11 (in Visual Basic 6), with very small and easy programs. I started getting quite actively into web dev about 6 years ago. I do like maths, I am lucky enough to understand quite easily so I've always got pretty good grades in science (especially maths) with limited effort. But I would be bad with very advanced maths/physics concepts. I studied computer science in France. I actually just finished my studies and started working as a web developer in December. The job was initially supposed to be mainly front-end, but I'm actually doing full-stack tasks. Let me know if you'd like more details about something!
you're welcome :)
r/titlegore
jQuery is not obsolete, but it is not good choice to make basis for big web application. If somebody makes small website using jQuery is probably still better choice than using React (or Angular). React demands more knowledge, more debugging skills and has more gotchas than jQuery. Although create-react-app at least removed need for manual configuration of Webpack). JavaScript fatigue is born at the moment when people start to use tools they don't need for problems they have at hand. Overthinking, overengineering. Besides jQuery solves different problem in different way than React does. jQuery solves pain of manual DOM manipulation and using browser API in general. It gives you friendly wrapper for this. React removes DOM completely and presents you an abstraction - virtual DOM for making components. It's more powerful than jQuery if you want to have component-based approach (and you should have), but React is limited if you need "go deeper", e.g. if you use third part widget and you need to monkey patch its DOM structure - React can't help you. You can either use plain browser API (addEventListener, querySelectorAll, etc.) or going with jQuery or some similar library which would give your more friendly interface. So jQuery can still be useful. Or if you want to add interactivity for existing website - in jQuery you could do it in 5 minutes. In React it would be cumbersome. And for smaller websites... maybe React would be useful, but often jQuery would be as useful as React. I do sometimes use React even in smaller project, but it's not the point. The point is that React has not made jQuery obsolete because these tools are different.
so pretty much a site with a login? how original
Sublime 3, VSCode, WebStorm. Or good old vim, if it ain't much code.
We're using typescript on a large codebase and it's just so much more fun to work with than plain JS. The tooling it brings is plain awesome.
The best burns are programmer burns
Lol no. We have mathmatical models down to less than 10 years. Again considering we have a wedge, and have the algorithm to derive patterns, we are talking a realistic time frame.
For older algorithms maybe, but not the stuff we actually use today. https://en.m.wikipedia.org/wiki/Advanced_Encryption_Standard Get cracking. There is money to be won by breaking encryption algorithms. Either as a reward, or the fact that you now have access to everyone's money. 
This is a very sane question to ask! I've been a Java guy for a decade, although I do web UI work from time to time out of necessity; I'll try to keep that Java bias out of my answer, but you should bear it in mind as you read my response. Also, these kinds of answers can get long quickly, so I'll try my best to keep it short and sweet. To answer your question directly -- What can JavaScript do that others can't? -- I'll cite the old, tired, and correct argument about Turing completeness that says there's nothing (computational) you can do in one modern language that you can't do in another. However, platform issues matter -- e.g., it's not easy getting Python to run in a browser out-of-the-box for &gt;=99% of your web visitors -- and standard libraries and user libraries matter, so some things will be easier or harder to do in different languages. Now I'll attempt to answer a question you didn't ask -- SHOULD you use JavaScript everywhere? A you pointed out, JavaScript now has runtimes available all over: at least server-side, desktop, browser, and mobile programming. AFAIK, it's the only language with runtimes in all those places that doesn't require users to jump through hoops to get it up and running. From that perspective, if your priority is to use one language to build a system across several or all of those layers -- e.g., because you only know JavaScript and you need to get work done -- then that's certainly a valid choice you can make. However, when building stuff, it's important to choose the right tool for the right job. Obviously, which tool is "right" in any situation is subjective, and different people will have different opinions about it. But I don't think anyone would disagree that different tools are better and worse at different things. Want to build an interactive web page? JavaScript is hands down great at that! Want to build a complex text-processing data backend maintained by a large group of engineers distributed across several time zones? A typed language with good support for text processing -- like Java -- might be a better bet. Different use cases can have different tools, and that fact doesn't make any of the tools worse, just different. So can you use JavaScript everywhere? As you already pointed out, of course. Should you? The answer is what engineers always answer when you ask them questions that start with "should you": it depends! It depends on the problem you're trying to solve and the resources you have available to solve it: on the platforms you need to support, on your use case, on the developers you have access to and the skills they have, on the available libraries, and so on. One other thought: if the decision about which tool in your toolbox is easy because there's only one tool IN your toolbox, then you might consider that there's a problem with your toolbox, particularly if you intend to be a career developer. That's true no matter what that tool is. TLDR: Aside from platform differences, there's nothing JavaScript can do that other languages can't. Should you use JavaScript across your whole stack? It depends, but you should always use the right tool for the right job, no matter what job you're doing. If you only have one tool in your toolbox, you should think hard about learning more. 
Thanks for the response! I hope you found it useful. :) And if I can offer one more bit of unsolicited advice: follow your interests rather than specific technologies for their own sake whenever you can. When you can, you'll learn more, faster, and have more fun along the way; when you can't, it's a lot easier to burn out, and that doesn't help anyone. If you want to learn Java, I'd start by finding a problem to solve that Java would be good at, e.g. something Java has a really good library for that you can use, and then solving it! You'll have your head around Java in no time. But even as a Java guy, I'll tell you that there's nothing magic about Java; there are lots of other good languages -- Schala, C, C#, C++, Python, etc -- that you might learn next, too. Obviously I think Java is a great choice, so don't let me talk you down, but I *just might* be biased. ;)
It is not that different from ES6 syntax-wise, but having the typing which provides safety and autocomplete features on top is very nice.
I wanted to do much the same; share encrypted documents but I didn't want every person to have an entire copy of the data. Instead I wanted to require multiple persons to collude in order to get them out, therefore https://chuyskywalker.github.io/secrets-in-case-of-death/
The cat named tiger purrs put it into the developer console in chrome/ff to see for yourself
 const obj = { 1: 'one', 2: 'two' } Object.keys(targetObject).forEach(key =&gt; { console.log(targetObject[key]) } // 'one' // 'two' &gt; That’s a little awkward. Well, try this! const obj = { 1: 'one', 2: 'two' } Object.values(obj).forEach(val =&gt; console.log(val))
How is everyone using `Map()` in practice? I am not using it much right now - is it best practice to use Map() instead of a tradiational object? If not, how do you decide when to use which?
Values() and Entries() isnt ES6 btw
I also came to recommend TypeScript. It really is just JavaScript; no magic. So it's not writing a new language; it's just a better way to write JavaScript, and one that's excellent for big team projects.
Implicit return just feels... weird?
Even with my extreme bias towards using JavaScript as much as possible, it's definitely not well suited for high performance applications. You would probably be better off making a AAA game in something like C++ rather than JavaScript or Java. Once you start getting to applications where speed is the main priority, then that's where JavaScript falls short.
`const obj = { foo: 'f', bar: 'b' }`
I still don't get it. Map isn't an alternative to that. That's just creating a single object. Map transforms a set of objects into a different set of objects.
Since you already know JavaScript then I think it would be great. Just keep up the base JavaScript skills. If you didn't know JavaScript and started with a transpiled language that would not be a good idea in my mind. I also use TypeScript on a large project and it is great except when people use "any" as the type which defeats the purpose of having a type.
You're probably talking about a map-function not a map-object.
I know what an object is... I asked what was meant by the question. Map is both of those things, and I misunderstood. I was thinking the function map. I didn't check the article first and it's still early.
Ah okay, then I understand :) If anyone else wonders, this is the Map we're talking about: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Map
Yep, you're totally right.
Most web servers are configured to do this, and if they are not, should be.
I don't know what you mean by "jumping through hoops to write code that doesn't look like JS". Coroutines are a pretty close conceptual alternative and I would say they are a 1000s more readable and easy to work with than threads. 
I have used C# in the context of Razor code, and it is definitely flexible and relatively easy to pick up. But is the mobility of the JavaScript world really an issue? Wouldn't the size of the community and the push towards new features/innovation make it more appealing because it can almost be guaranteed to be able to do the thing you want to do within a small amount of time?
Good point: I had not taken memory management into consideration when I wrote this question, and there is definitely evidence to prove that there are superior ways to go about handling it. Thanks!
Great responses. Just out of curiousity: is TypeScript actually adding OO features to JS? Or is it more of a syntactic sugar over prototyping in the way that ES6 classes are?
If you want a loop, just use a loop. There is no need to obfuscate it. const obj = { 1: 'one', 2: 'two' } for (const val of Object.values(obj)) { console.log(val); }
TypeScript has as a core goal to stay on par with ES6. To that end, it's a fairly good model to think of TS as ES6 JS, but with types. This implies you're not really learning a new language like you would be if you learned Elm or CoffeeScript. Think Babel, but with types.
Absolutely this is why I love it. I must warn you though it's not for everyone. I go through sprees where I feel like I'm on top of things then 3 months later I need to relearn tons of my libraries because their APIs changed. That said writing JavaScript has made me a much better engineer in the sense that I can pick up a new library and have strong feelings about how it's designed and works beyond just the "ohh I don't know how to use it so it sucks"
I kinda prefer using `forEach` over a `for..of` loop because it's pretty handy if you're chaining it after some other operation like a `map`. const obj = { 1: 'one', 2: 'two' } Object.values(obj) .map(val =&gt; val.toUpperCase()) .forEach(val =&gt; console.log(val))
They're ES7...
FYI, React 16 (still in alpha) will ship with its own portal implementation.
This is very interesting! Do you have any links with more information on this?
I'm not sure the React team has documented them yet, but you can see them used here: https://github.com/facebook/react/blob/master/src/renderers/dom/fiber/__tests__/ReactDOMFiber-test.js#L216-L231
Definetely Typescript
I will say there are a few gotchas with implicit returns though; e.g. const returnSomeObject = state =&gt; { someProp: state.ui.someProp * 2 } The above would throw at run-time or via linting since you need to wrap parens() around the object in this type of implicit return as the object {} are being read as a scope block for the function. e.g. correct way: const returnSomeObject = state =&gt; ({ someProp: state.ui.someProp * 2 }) I love implicit returns though, so much cleaner to read.
typescript and coffeescript are fine general career moves, what with them powering two of the most popular text editors today (typescript for vs code and coffeescript for atom). typescript also happens to be a serious language research project with adoption by companies like google, tilde, ericsson, ubisoft (oh, ubisoft...) and wix, while coffeescript is widely regarded as popularizing many of the features that ended up in es6. i don't know very much about elm and livescript, and other compile-native-to-js languages like scalajs and clojurescript always struck me as being targeted primarily at backend developers who didn't want to touch js. regardless of what field you're in, though, you want to choose a language that has a good reputation &amp; large market share; this gives you the greatest chance to land on a language that's both employable &amp; doesn't make you hate your job.
I don't think they are correct, it is ES6. ES6 is the "brand name" of the living spec that is ECMAScript, kind of like "HTML5". There is no ES7, the community has overwhelmingly moved to categorizing features by the year of it's inclusion in the ECMAScript specification. ES6 was renamed to ES2015, and since then certain features were introduced in later version of the same spec. So features like `.values` and `.entries` were introduced in ES2017, which would be ES8, not ES7, by /u/Poltras convention. In my experience when you want to talk about modern JavaScript, refer to it as ES6, people will understand. If you need to get specific about a feature use the date of it's inclusion in the specification (eg. `let`/`const` is ES2015, `Array.prototype.includes` is ES2016, `Object.entries`/`Object.values` is ES2017), and features that are not yet included in the spec can be referred to as being in ES-next 
My recommendation is, that you should read into the basics of inheritance and prototypes: http://www.crockford.com/javascript/inheritance.html (if you didnt already) But to answer your question in a more general approach - export new AppStore: if you want to use one single AppStore across your app - export AppStore: if you want to create multible AppStores from multible locations, this can especially be useful for testing... 
30 kb
Says 9kb here: https://521dimensions.com/open-source/amplitudejs Edit: without dependencies
I think you replied to the wrong comment. No harm done, but your intended recipient won't see your reply otherwise.
My favorite JavaScipt [wat](https://www.destroyallsoftware.com/talks/wat) talk. Worth the listen!
I use bootstrap with react on basically every project. Gives me a css backbone framework to prototype any designs so that I dont have to do styles and javascript in parallel.
doesn't setTimeout just run if you declare it? I'm not understanding your solution. How would you call the timeout function like youre saying
Damn I would have never guessed that. Thanks a ton.
There's absolutely no problem in using the css/less part of bootstrap with any framework, as it just let's you focus on coding in javascript without worrying about the styles. However, if you want to use the javascript part of bootstrap (like modals, popovers, etc) then the result of those behaviors might not be part of your component state (in react). So if you need them to be I would implement them myself in my components if I were you, to have full control over it.
Atom is dead. People shouldn't use dead things, especially things that died because they were slow. Use fast things, and you know what I'm talking about. Edit: Fuck you to those who are downvoting without mentioning why. Edit 2: Y'all can eat from the same bag of........ nachos.
It's slow, and even slower when dealing with large files. It doesn't syntax highlight very large files (at least when I used to work with it on a daily basis). Installing 7-8 plugins slows it down further, and on a large project (say some 1000+ files of all sorts, node_modules excluded), it's a disaster.
Ok, why does every description of every project have to have the word 'modern'. It's pretty tired at this point. 
This sounds pretty similar to the ads I've seen from Pluralsight, where they offer on-demand mentoring for different programming languages. I think their model is by the minute though, so your monthly subscription might be an attractive alternative.
I do not see a need for this past entry-level development. Most of the developers I know are apart of a network that offers them this for free or they know how to stackoverflow a question or break it into smaller pieces in order to stackoverflow those pieces.
How could this be approached with ``async`` and ``Promise``?
Have you tried it out recently? Performance has improved significantly. Although if performance was my main concern, I would probably be using Vim or Sublime. The main reason I use Atom is because of how hackable it is. I really liked VSC, but it's nowhere near as customizable as Atom. 
Uh.. ``Array.from(myMapInstance).forEach()``?
Could we see the script that includes your fetch call?
It's gotten way better, though. Large files were a big nuisance, remember when you accidentally clicked a big file and had to wait 20 seconds for it to load, but i haven't pulled any hair over it recently.
If you want to use bootstrap for basics, grids, and small controls, it's absolutely fine. Otherwise it can be a little problematic because of its non-component css roots. Selectors kind of cripple what you can do and sometimes feel out of place or unnatural. If you want to have absolute freedom try [ant design](https://ant.design/components/button/). It's modular, small size, professionally backed by a software giant, dozens of fully functional controls. 
 async function alertFetch () { const fetchInstance = await fetch('http://127.0.0.1:5000/cancers'); return fetchInstance.json(); } Return the ``.json()`` promise and handle it in your ``componentWillMount``. Your function returns nothing, so you're not really handling the fetch properly.
Promises are for code blocks you can't predict the execution time of. Anyway, thank you for that, that's a neat example.
Here is a function called `group` that groups an array by 2 functions. It is pretty specific to what you are trying to do but you could probably abstract it out enough: const groups = (fn1, fn2, list) =&gt; { const result1 = []; const result2 = []; for(let i = 0; i &lt; list.length; i++) { const item = list[i]; if (fn1(item)) { result1.push(item); } if (fn2(item)) { result2.push(item); } } return [result1, result2]; } const prop = k =&gt; o =&gt; o[k]; const equals = a =&gt; b =&gt; a === b; const compose = (...fns) =&gt; start =&gt; fns.reduceRight((state, fn) =&gt; fn(state), start); const isApple = compose( equals('apple'), prop('type') ); const isOrange = compose( equals('orange'), prop('type') ); const list = [ { type: 'apple' }, { type: 'orange' }, { type: 'pear' }, { type: 'apple' }, { type: 'apple' }, { type: 'orange' }, { type: 'orange' }, { type: 'grape' }, { type: 'apple' }, { type: 'orange' }, { type: 'apple' }, ] console.log(groups(isApple, isOrange, list))
Promises still have to execute on the same thread as everything else. You couldn't just inject the execution of a Promise into OP's while loop to interrupt.
I would just start littering my component with `console.log`s. See what's going on each step of the way.
Thanks, by the minute was something I thought of, but I don't think it is the best incentive for either side.
What about for something outside of your expertise. So say design help or feedback for a dev? Or DevOps help for a frontend dev? 
Once again, I would go to my network before I tried a paid service and I would assume that those in my network would do the same. If that failed, I would try Reddit or a Slack channel if I need a more immediate answer. A paid service would be low on my list of options when needing help like what you are thinking of offering.
Yes. That's what I did.
Everything seems to be going well until the actual fetch call.
Thanks for the suggestion, but that doesn't seem to make a difference unfortunately.
At least "elegant" phased out.
Atom is not dead at all.
Yep, there's something there... That worked as expected. Hmm... Thanks for the new direction!
Can you say more about what you're looking for? What is `funcToBeExecuted` doing? There's no way to stop the execution of a function. You can add branching logic to check if it should continue at different points, but once a function has been called, you can't stop it externally.
I like howler. Thanks for sharing though.
yeah, when i see var its just a sign that someone cant knock old habits. For fucksake, you can use `let` or `const` w/o babel or webpack.
 refactor the whole app and use redux, obviously ...or just read it from query string if it's a static page change. writing query string parsers is annoying and they can be finicky so in this case i would actually recommend a lib, i've used [URI.js](https://github.com/medialize/URI.js/) recently and was quite happy with it [here's plenty of other ways](https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript) 
I don't see why my answer won't work for this. To rephrase your requirements you want to: Send data until some timer is done. This is a basic tweak on my previous answer: // FAKE DATA STUFF const fakeData = [ { data: 'data 1'}, { data: 'data 2'}, { data: 'data 3'}, { data: 'data 4'}, ]; function sendData() { let idx = -1; return { next() { idx++; return fakeData[idx]; }, isEmpty() { return fakeData.length - (idx + 1) === 0; } } } function getDataForMinutes(minutes) { const timeout = minutesToMs(minutes); const data = sendData(); let done = false; setTimeout(() =&gt; { done = true; }, timeout); const pollData = setInterval(() =&gt; { if (!done &amp;&amp; !data.isEmpty()) { console.log(data.next()); } else { clearInterval(pollData); console.log('DONE!'); } }, 0); } function minutesToMs (min) { return min * 60 * 1000; } getDataForMinutes(1); This will get the next bit of data until a) the timer is done, or b) there is no more data left. EDIT: http://jsbin.com/xawivedisu/1/edit?js,console 
I found the following solution to get the specific element; var xhr = new XMLHttpRequest(); xhr.open('GET', 'B.html', true); xhr.responseType = 'document'; xhr.send(); xhr.onload = function(e) { var doc = e.target.responseXML; doc.getElementById('selector'); } However, I couldn't figure out how to change the selected option in the menu.
You should look into ES6 generators, they may help.
Whoever prepared the demo site, they have good music taste.
How is "no dependencies" a selling point?
Not sure if it's just me, but that site you linked for ant design looks rotten on my phone. 
As long as you give the function a name, it's simple: function foo() { console.log('foo'); foo = function() { console.log('bar'); }; }; foo(); // "foo" foo(); // "bar"
You can't assign something to `this`... that's a ReferenceError, `Invalid left-hand side in assignment` But function.prototype has both `call` and `apply` that sort of does that. These will allow you to change the `this` binding inside the function to whatever else you want. function whatever () { this() } whatever.call(function () { console.log('whatever is no redefined') }) Inside the function, `this` has changed to something else. See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply
Not really a good case for a generator. He's not looking for something operating in stages or co-dependent on other async calls. He just needs a single setInterval - keep ref to it. Then a setTimeout and after however long - it calls clearInterval with the ref and stops executing. No need for flags or possible bugs from multiple executions running simultaneously.
While dependencies are very cheap these days, they're still a burden. Mainly, it means that you don't have a checklist of prerequisites for it to work, you don't have to worry about it breaking because of dependencies and you have less to worry about it not playing well with other things you may want to use.
That downloads the contents of B.html within the existing page and stores it to the "doc" variable. I'm not too sure how this is helpful. You really want to do a legit page navigation with window.location.href and pass query parameters that B.html can read. BUT, using React and Redux would be fun :)
Hi /u/MoReeder, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
does it have to be assigned to this? it seems like some sort of function factory pattern could work but you didn't really say what problem you are trying to solve 
Clear interval only works on things in global scope, and he said scope was his problem. What I was thinking (using the same basic fakeData as /u/Pantstown) was: function* getDataOverTime( let time = true; let ind = 0; setTimeout(()=&gt;time=false, ms) while(time) yield(fakeData[i++]); return; } //then all you'd have to do is // create gen with time parameter let g = getDataOverTime(1000); // and use a for of loop to go through data for(let data of g){ if(!data) break; // manipulate data console.log(data); }
Guess it might help to know the end goal.The actual 'problem' is the lack of simplified defer functionality. I'm toolkitting some methods that will allow someone to just do something like below, which I have a working model, but I'm trying to simplify it further for anyone else who may use my code later. I've reviewed a lot of options and the best one `setTimeout` is still not a good catch-all solution. &gt; function fn(){ &gt; / * some function code */ &gt; return 1000; &gt; } &gt; &gt; fn.defer(function(){ /* some cleanup code that gets deferred */ }); After that, fn ends up becoming: &gt; function(){ &gt; try { &gt; / * some function code */ &gt; return 1000; &gt; } finally { &gt; /* some cleanup code that gets deferred */ &gt; } &gt; } 
Query string would probably be the easiest solution. You could also use local storage to save the value of the button before the redirect, and on page B read that value and pre-select it. https://developer.mozilla.org/en/docs/Web/API/Window/localStorage Edit: Don't forget to clear out localstorage data after you're done
I veered away from using localStorage for critical data after I learned the hard way some browser don't allow it in incognito mode, but maybe that's changed
Some web servers run expressjs and nodejs. Its not completely implemented yet.
Microsoft Word
https://react-live.now.sh
I can't go back. You can get to the terminal without leaving your file, or run build scripts with 3 keystrokes. 
It is? F*ck yes, finally! 
I don't know if I'm still an "entry level" dev after 4 years, but this isn't true for me. If I have many questions about some technology I'm new with, or have a hard question which is unlikely to get a quick SO response, I'll sometimes hire a tutor on codementor.io; granted there are some goons on there who will lazily google things for you while on the clock, but there are smart, good teachers as well.
I noticed the demo screenshot has bandcamp songs, but it isn't mentioned in the README. How would you get the path to the .mp3 file? 
ESLint is dead now. 
So many postrockers in the JS community (myself included). Strange correlation.
This is pretty interesting. I can see how it works when your user is required to bring their own Google account, and that single oauth can authenticate all your services, but I don't think this is a typical use case. In my mind, the biggest problem with serverless apps is that there is no way to securely interact with services without including your own private keys in the application. Is there any solution to this problem?
I use 'elegant' loosely, only in regards to making it easier for people using this hackish defer feature. I hate that I'm using eval(), but it's the only working model I got at the moment... which honestly ain't bad when you need hackery to happen. For now, I'm open to better ideas on how to implement a defer feature without having to slap `try { } finally { }` everywhere manually or teaching people a new way of handling their code. Sidenote: love that nope.gif!
I did a similar thing for my own react-native projects. "Dead simple portal without fancy features yet covers all my use-cases" was my goal. I've been using this both on `react-native` and `react`. https://github.com/zenyr/react-native-portal
Is it? What's better?
The main difference is that your lib provides default components that define how things are rendered. E.g your blackPortal always renders null. 
Yeah right, hence the name. hehe. I wanted to make sure the thing I put in would always render on the place I expected to avoid any race conditions and make it easy to use and blend in the react component nature.
Looks like either solution requires some work. I think wrapping it in an anonymous function might better encapsulate the package, like `(function(){ ... code here ... })();`. It seems to work fine as both YAHtk and yahtpl objects are still exposed with out module.exports. I have a copy of pages booked mark to read up on npm packaging later, but what do you think? Is it better to do it the way you mentioned or should the anon function call work as expected?
I've been converting some angularjs services to es6 singletons recently and end up doing something like this class MessageService { ... } export const constructor = MessageService export const instance = new MessageService() export default instance A single instance is the default behaviour, as I want requests etc. cached inside the service across the application, so general usage is just like import MessageService from 'services/messageService' MessageService.getMessages() // Promise with possibly cached result However, in unit tests I want to make a fresh instance of the service for each test, thus I need to export constructor itself and instead do import { constructor as MessageService } from './messageService' Basically, if your module needs to have *internal* state, export an instance, but consider a named export of the constructor so you *can* make instances on demand. If your module doesn't need internal state and it's used independently everywhere, then don't export an instance.
Even if you change `yahtpl = class {` to `var yahtpl = class {`?
Works in Chrome for me
well they have a client_id, which isn't exactly private. I don't think the private ssl keys go beyond cloudflare though. The API's must have a way to configure CORS based on origin and client id or something. There is still a fair bit of server setup involved here.
Sounds like you should be using promises then. 
yes 1 is always &lt; 3
Hmm really? It seems pretty good for me although maybe my projects aren't big enough.
Are you saying you're not seeing any diffs when you click on unstaged/staged files? For me it displays like this: http://i.imgur.com/fJG5Le5.png
[removed]
You can't type like a jackass then wonder why you're being downvoted 
oh, and the second wave of login opens up pretty much all the permissions to moo.do (read/send emails, calendar, all of docs, and contacts), which in retrospect is probably necessary, but still, that is a lot of trust needed. And if everyone is in the habit of just clicking on these things, then there is no accountability when something does go wrong (how does a user know when an app is looking where it shouldn't be?) 
INSANE would be more fitting. /r/leagueoflegends
self modifying code is not usually considered a feature, more of a nightmare. Numerous scripting languages can also change executed code on the fly and certainly more than a few scripts have modified other programs, i.e. in a build process. They are not mutually exclusive, and metaprogramming isn't the bread and butter of js fwiw, probably very little of that on the whole (no, html isn't a programming language). 
A beautiful, agnostic, opinionated framework toolkit library for ninjas 
good article
Metaprogramming is treating code as data. Manipulate a program to create a new program. There are various ways to achieve that goal, at various steps between parsing and runtime (a.k.a. evaluation time for JS, let's ignore JIT compilation, it is an implementation details for the topic at hand). While you can't modify the AST (either at parse time or at run time) nor the machine code in JS, you can use function composition to stitch new programs together. See an example [here](https://jsperf.com/inlined-vs-composed-vs-plugins-no-tco) with the `wrapper`, `middle` and `inner` functions, that once assembled give the `combined` function (which is quite fast, but that's not our point ;-). You can also use generic combinators (higher level functions) to achieve similar results.
This isn't reducing the bundle size at all. It's simply reducing the size of the bundle being transferred to the client. The client still needs to parse that entire 77% of code still. For higher performance gains, reduce the actual code the client needs to execute as much as possible. 
...with half of your mind.
The lines are typically a little blurry, but you seem confused because these two concepts aren't opposites - they're just attributes that characterise/describe **normal programming languages** to a greater or lesser degree. Technically all these categories are types of programming languages. Scripting languages are programming languages that are primarily designed (or merely good) for writing quick bits of ad-hoc or one-off code, *for example* to automate input of commands or other manual tasks, but not necessarily only those purposes either. Examples: Bash scripting, Perl, etc. Normal programming languages are designed for general programming - you can use them for quick scripts, but you can also use them to easily write large or complex applications, as they're designed to support such complexity. If anything they tend to lean more towards the large/complex scenarios with boilerplate and structure, to differentiate them from more scripting-oriented languages. Metaprogramming is a technique where you programmatically parse and modify *code*, in the same way normal programming involves parsing and modifying data. Examples: Lisp, Ruby, etc. The thing is that there are no real boundaries to these categories - they're vague descriptions that apply to most/all languages to one degree or another. For example Perl started off as a scripting language to do Bash-style Unix scripting, but it's evolved into a complex general programming language, and there are codebases out there with hundreds of thousands of lines of Perl. Nevertheless, most people would still call Perl a scripting language, because that's where it's best. Likewise JS started off as a way to make elements move around on a web page, but these days it's a fully-fledged programming language that people use to do everything from writing web servers to doing embedded programming. Conversely, while you *could* "script" in Java nobody really bothers, because the amount of boilerplate that Java requires to do anything makes it unwieldy and awkward for quick ad-hoc jobs. Many, *many* programming languages support some metaprogramming features, but there isn't really any such thing as "a metaprogramming language" outside of obscure specialist niches, because that implies that the *primary purpose* of the language is to modify code, and (to a first approximation) nobody wants or needs such a language. Languages like Lisp are the go-to example for languages that encourage metaprogramming, as Lisp code is expressed in its own data-format, so it can consume and modify its own code in exactly the same way it consumes and modifies any data. Many other languages also offer metaprogramming features - from languages like Ruby that do it a lot, down to languages like Java that offer the Reflection API, but do it slowly and grudgingly, and whose culture usually reacts to metaprogramming with barely-concealed horror as it often circumvents a lot of the protections of Java's strong type system. **TL;DR:** All imperative computer languages are programming languages. Scripting languages are the ones originally designed or primarily used for quick, ad-hoc bits of code to scratch an itch or automate a task. Metaprogramming is the act of operating on code, rather than operating on data. There are no "metaprogramming languages" in general use, because metaprogramming is a single technique that's not very useful for writing programs all on its own.
Yeah - calling JS a metaprogramming language is a stretch. I mean in the limit case you can dump out the body of a function as text, edit the raw text and then `eval()` (or similar) that back into a function, but JS gives you no real built-in resources to parse or modify its own code or AST.
Or for a more general-use function function timedLoop(cb, t) { const interval = setInterval(cb, 0); setTimeout(() =&gt; clearInterval(interval), t); } let i = 0; timedLoop(() =&gt; console.log(i++), 1000);
Ohh yeah - I shall have a search.
Ooops, what a way to lose the plot. Thanks for letting me know.
To be fair, you can [do the same thing with Atom](http://i.imgur.com/WQAPbPy.png). * Terminal: [`Termination`](https://github.com/Fred-Barclay/Termination). * Build Scripts: [`atom-build`](https://github.com/noseglid/atom-build).
I downvoted you because you calling something dead when it's clearly alive (see OP you replying to) doesn't make sense and is not contributing to any argument. 
I'm not familiar with power shell, but [it would seem so](https://atom.io/packages/search?q=powershell).
--- A wild [Alot](http://i.imgur.com/HuHNNWV.jpg) appeared! --- [^^This ^Action ^^was ^performed ^^by ^a ^^bot ^- ^Please ^^message ^eto_eskape ^^if ^you ^^have ^any ^^problems](https://np.reddit.com/r/alotabot/comments/6g7reb/why_are_you_seeing_this/) --- [Click me to opt out!](http://www.reddit.com/message/compose?to=alotabot&amp;subject=ignore+me&amp;message=ignore+me)
This is not a business.
I like this bot alot.
Show us your script
So where do you get the filename from?
Really cool! Serverless SaaS are great (If you manage to make it profitable)
which line? is Modernizr defined? is the "$" alias for jQuery defined? is containers correctly retrieved?
The repo has over 8000 stars and 2000 forks, so yes, it's not a hidden gem.
Its always been very fast for me after it indexes. Over NFS its instantaneous and with sftp it takes a while the first time.
Fuuu, for anyone who sees this, the fix is to add a `.extent` to the zoom. So in this specific case zoom went from: const zoom = d3.zoom() .scaleExtent([1, 40]) .translateExtent([[0,0], [width, height]]) .on("zoom", zoomed); to const zoom = d3.zoom() .scaleExtent([1, 40]) .translateExtent([[0,0], [width, height]]) .extent([[0, 0], [width, height]]) .on("zoom", zoomed); See: https://github.com/d3/d3-zoom#zoom_extent
You can use the proxy api for metaprogramming. The Reflect api is been use internally by javascript whenever you call the member of any object, in es6 the api was exposed, you can trap the real implementation of some functionality and modify the way it is suppose to work, even constructor functions for example let target = { name: "metaprogramming", } const proxy = new Proxy(target,{ get(target, name) { if ( target[name] === "metaprogramming" ) { throw new Error(`no`); } return Reflect.get(target,name); }, set(target,name,value) { if ( name === "language" &amp;&amp; value !== "javascript" ) { return Reflect.set(target,name,"javascript"); } return Reflect.set(target,name,value); } }); try { console.log(proxy.name); } catch(ex) { console.log(ex); } target.name = "scripting" console.log(proxy.name); proxy.language = "java"; console.log(proxy.language); // prints out javascript, irrespective of the fact that proxy.language was set to java [!documentation](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy) [!video](https://www.youtube.com/watch?v=NulCJdbARQ8)
2014 called and they want their article back.
It's like a lot of these frameworks. Far too many come with loads of components but suck for mobile. Ant design looks good on first look, but start digging in and it's not so fun. 
Thanks so much for all your helpp!!! I finally managed to fix it. Turns out the Javascript seemed to create some form of a canvas to place the image in. So altering those dimensions, helped to resize the image! Really appreciated your replies!! Doing this project has really made me realize how difficult Javascript is though! T.T
Awesome, this works and I totally see how to do it now. Thanks a ton.
 ^ for the win.
Or you could use mobx if you need reactivity in your data model?
React-bootstrap has been around for years, why is this news now?
There are tools to make apps in JavaScript. But the recommended, standard, method for creating an app is with Java and Android Studio.
&gt; ReactJS. New Kid on the Block Then I saw the date.
node or php :)
I found one :-)
I do think it is very cool fyi :)
So, the `onchange` event isn't supposed to work when a `radio` button is unchecked. So I put a click event handler on the named options and tracked the last one. This allowed me to subtract the shipping from the total when another one was checked. https://codepen.io/anon/pen/rwjNxe?editors=1111
C# is fine, and you have unity, but if you are going java you may find scala, kotlin or clojure (jvm languages) much nicer and modern. Anyways if you want to break really from js you should try elixir or rust (depending on your needs).
Radio inputs doesn't trigger the `change` event because the input's value doesn't change when it's unchecked. You'll have to manually process radio inputs which aren't checked if you need to update them.
Yes look into Node.js 
You can check out Ionic. With Ionic you are creating webapps that are turned in Android or iOS apps. **BUT** it uses Angular with Typescript(try and Google this two) and can be pretty hard if you are a beginner(personal experience). You can try to learn Java, there are lots of tutorials online on how to-s. Start with small programs/projects and build up. Good luck and don't give up!
While I love the innovation here, I'd be extremely nervous about having my whole business depend on a suite of services delivered by Google, given their history of leaving people in the lurch after cancelling products.
[Proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) get us a bit closer. What's the benefit of metaprogramming anyway? Magic syntax?
A little janky. I like https://github.com/veltman/flubber
I didn't downvote, but I'd guess because it provides literally nothing to the post. It isn't humorous, it isn't a discussion, it's just one person saying they prefer some other thing over the library in question for no apparent reason.
JS was totally inspired by LISP… where do you think first class functions come from?
Definitely, as /u/Persil1 said one option Ionic, but it's Angular / Typescript, which increases learning curve. There is also React Native, which is ReactJS framework (kinda), but just like with Ionic, there is a learning curve. There also is Cordova, in which you can use standard JS / CSS / HTML which doesn't require you to learn much to get started, but it's not a UI framework, so you are free to use any UI or write just plain HTML / CSS yourself, which is good and bad. I have created a couple of apps using these and generally performance is good. You can even write simple games and there shouldn't be any issues, but if you are writing an app where every ms counts (eg. game with amazing 3d graphics), then nothing will beat Java, but that's totally different language and comparing to JS that's a huge learning curve. Another downside to Java is that it's Android only, but if you use any of the above, then it will run on Anrdoid, iOS, Windows Phone (like anyone actually cares), etc.
X-Post referenced from [/r/programming](http://np.reddit.com/r/programming) by /u/comeththenerd [The Politics of Programming](http://np.reddit.com/r/programming/comments/6hn5l7/the_politics_of_programming/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Every project is different, so you should choose tools / environment, which suits best your needs. You can create an app using JS which feels and acts as native, while being cheaper to develop and maintain. Of course JS is not suited for all types of app, but I wouldn't use "recommended" for Java. Java was the best option years ago, but today Ionic, ReactNative, etc. have huge advantage of cross platform support, which Java can't match.
A worker runs in its own process. It's Actor-like concurrency. Passing data around is currently somewhat expensive, but this is supposed to get cheaper with shared buffers.
Yet it hasn't been posted here. Do you think everyone here knows everything you do?
Sure, but no macro though, which is his point.
Lisp is the quintessential metaprogramming language and it's interpreted.
Primitives are passed by value so, you would have to do something like make an array out of a and b and assign the result of the function call to said array.
Well, ng4/2 does a lot more stuff than React. It's more of a kitchen sink framework. I think both, as well as Vue, are all good for different reasons. It's like asking which food is best.
All he or she said was that imperative computer languages are programming languages. Made no claim about non-imperative.
The TL;DR version is they spent time optimizing their dependencies. Like literally every other article ever about this.
To be fair, their post isn't irrelevant while not addressing that blog post is still a post about a javascript library. Someone the other day made a post about amplitude.js, I just posted that I prefer Howler but thanks for sharing their preference. No one downvoted or if they did I don't really care. Point is people are talking about JS.
They could probably optimize about 80% off just by removing a bunch of those libraries and simply provide a vanilla JS solution. It would probably execute at least twice as fast too. I had to really struggle to look for code they wrote in those block diagrams.
Maybe `window.close()` will work? https://developer.mozilla.org/en-US/docs/Web/API/Window/close 
I have a similar project that I use `mgit2` and `lerna` to manage. The structure looks like this Project | -&gt; mgit.json | -&gt; lerna.json | -&gt; package.json &lt;- contains mgit and lerna dependencies | -&gt; -- packages | -&gt; -- api_server | -&gt; -- client I can run dev mode for both with `lerna run --parallel start` which gives me a webpack dev server and the api_server with nodemon to restart on changes. 
Is it dangerous to store pw in this.state?
Learn `C`, `C++` or `Rust` and then you can write `webassembly` modules -- get the `Emscripten SDK` too.
A framework running 10s of thousand of sites can be called dead? After working in Angular 1.s for almost 4 years now, I'm as ready as anyone to move to something else. While I definitely wouldn't recommend starting a new project with it, calling it dead is a stretch. 
I think if it makes sense to you to have it as two projects it's perfectly fine to make it two projects. I tend to structure my projects as frontend and various APIs (some would say micro-services). The advantage of this is that the frontend can be completely served by a static host or live on CDN nodes which improves page speed and make it less likely it will go down under heavy load. Some people call this style of building sites a [JAMstack](https://jamstack.org/) architecture. I didn't know that when I started doing it. It just makes more sense to me as well. I have never built a monolith web application. Of course if you are going to have some shared logic between you front-end and back-end it makes sense to have them in one project or have that logic as a shared module. 
Thanks for you answer. So then if you wanted to `dispatch` in `SomeComponent` you could _only_ dispatch `someImportedAction`? To me it seems like `mapStateToProps` is doing something that could be much clearer defined by actually passing the bit of state to the props of the component. 
Wow. It's amazing how old it feels.
TL;DR: Because React officially takes the stance that any component's `.render` function can be called whenever (which is why you're supposed to avoid side-effects in `.render` functions), you can't guarantee that a stateful DOM element managed by something less "clean" than React won't just be re-rendered. So third-party code could be destroyed by a change in the React algorithm. I had a similar issue with this when I was considering using React on a site with ads. NFL created a [component](https://github.com/nfl/react-gpt/blob/master/src/Bling.js) for this that relies on `shouldComponentUpdate`, which /u/rrosenfeld notes is not a great solution. --- On a personal note, I think the conclusion drawn is a bit sensationalist. If you're making a library that relies on this, you're passing risk down to the users. If you're making an application that relies on this, there's nothing forcing you to upgrade React, breaking your app. React v15 will always have the same reconciliation algorithm, and it will always be compatible with all the libraries you currently rely on (at their current versions). Tons of long-term projects use very old versions of technologies. Further, I'd give it a nearly 0% chance that React will upgrade the reconciliation algorithm to re-render _more_ often than it does now, especially violating `shouldComponentUpdate`. And even if they do, they will _definitely_ include a new way to handle this. It's too common a usecase to just say "Well, you should have read the philosophy documentation; we're not given you a migration path". ---- Granted... working third-party code into React is absolutely not fun. If your application is going to rely on a lot of vendor code mucking around with your DOM, you should probably skip it anyways.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [nfl/react-gpt/.../**Bling.js** (master → d66be53)](https://github.com/nfl/react-gpt/blob/d66be53f0e362e5cbb5d9b070e80d2278b049e00/src/Bling.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dj06uju.)^.
Or use `preact` + `preact-compat`, which gives you a React-compatible API under an MIT license. Vue is a nice library, of course, but hardly the only valid option!
Five years of polluting html
Vuex is what separates it. That and if you want to write html instead of jsx.
How does it help with the situation that I described?
&gt; but the more I read about react + the fact that we only need the "V" in MVC If all you need is the "V" then could just use the `document` api -- ie, you might need more than just the "V".
I definitely see where your concern is, and I would also like to point out that I respect your opinion very significantly, as you're both well-reasoned and more experienced than I am. I'm just calling it like I see it, so to speak. =) ---- With regard to the first question, I'm simply referring to a piece of the DOM that is managed by something that will essentially get "messed up" by re-rendering. It's essentially the problem you're referring to. So a "clean" component might be something that just gets rendered to a string, or a navbar that gets rendered as pure DOM while third-party code lives elsewhere on the page, changing it on scroll events. "Unclean" components might be ads (which hold auctions every time they're rendered, so re-rendering the div means you lost the creative and have to run another auction if you want anything to show up) or really anything in an &lt;iframe&gt;. I'm sure you know what I mean, as it's what you're writing about. --- I agree with you that it's not a great solution to suggest that you resign yourself to sticking with the current version forever. I would argue that it's not as bad as you'd think it is (again, nothing is going to *stop* working), and you can't really prevent it anyways. There have been no promises made that jQuery 4 is going to be backwards compatible (as far as I know), but you still feel confident enough to stick with jQuery 3, right? But more importantly than it not being terrible if that *does* happen... well, it's not *going* to happen. I understand your lack of trust for Facebook, but I do believe it is at least slightly misguided. You say that if Facebook's goals differ from your own goals, they will likely not support features that support your own goals. This may be true, but it doesn't actually have basis in history. I'm sure there are other examples of this, but off the top of my head I can think of the fact that React DOM can render to string, despite the fact that Facebook doesn't actually use that (not sure how it does its server rendering, but they've openly said they don't use React server rendering). The React team has consistently proven that they consider rendering to string a priority, despite offering (AFAIK) no direct benefits to Facebook. In fact, distinguishing React as a reconciliation algorithm and separating it from its render target is a pretty large investment for relatively little payoff (for Facebook). Loads of people use React for render targets that aren't native mobile and aren't web, but Facebook doesn't. React is also not just Facebook. It's open source with external contributors both to its core and its ecosystem, so you've got people with vested interest able to make genuine contributions. You've even got competing, 100% compatible projects with similar but different reconciliation algorithms (Preact, Inferno). You can largely switch freely between these projects with different Babel plugins and codemods. Champions of React (NFL being one of them, as shown in my last comment) rely on certain behavior quirks. If the React team decides to break these quirks, you will be in the company of bigger organizations. Lastly... this particular quirk that you're concerned about is almost definitely never going to change. Or, if it does, it will probably change for the better. I really think the philosophy exists as guidance for programmers to encourage them to program declaratively rather than to preclude developers from using them if they *can't* program that declaratively. I do agree, however, that they should take an official stance on how to deal with this kind of thing, because it is a very common concern.
Yes. It allows you to specify a condition to match.
I've always felt Inferno was superior... Guess Facebook did too considering they hired /u/trueadm
I would like to point out that these concerns apply to *any* stateful React component, not just 3rd party ones. For example, suppose I make a `Counter` component with up + down arrows and some local state. Then, I nest that deeply under some kind of router component. Depending on the URL, the router component will either render my `Counter` page or something else. What happens if I quickly change the URL, and then instantly change it back? Intuitively, I would expect the count to be reset to 0, since the `Counter` component should be destroyed and then re-rendered (we left the page, after all). In reality, the count might stay the same because React batches the renders, and the diff algorithm notices that the tree still has a `Counter` component in the same spot. Thus, if React locks down their diff algorithm to prevent these glitches, they lose a lot of potential optimizations. The good news (?) is that this affects everything, not just 3rd party components. There is no way on earth React would radically break their diff algorithm to the point where it randomly re-renders things - the sloppiness is so they can err in the opposite direction of doing too few renders. If their diff algorithm did stop tracking component identities one day, it would instantly break half the world (or at least the half that uses component state). I agree that more assurance would be nice, but I feel that the scale of brokenness this would create is assurance enough.
&gt; Because React officially takes the stance that any component's .render function can be called whenever (which is why you're supposed to avoid side-effects in .render functions), you can't guarantee that a stateful DOM element managed by something less "clean" than React won't just be re-rendered. So third-party code could be destroyed by a change in the React algorithm. The way I use React is at the component level. I.e. I have my own controller logic updating a myriad of hybrid components, and some of them happen to be React. This approach doesn't have the issue the author is complaining about, and seems especially non-risky for long-term projects, because I can always change the rendering library/approach for any specific component without anything breaking. So this seems to confirm my approach: don't let React (or any other framework) consume your entire app, let it sit at the component level and use your own controllers.
Hi, just sharing my first video tutorial. Sorry it's simple but I wanted to start out simple on my channel. message me any requests/ideas on what I can do a tutorial on next.
Hear hear. React is a tool, not your master.
Regarding "clean" components, it seems you would consider as "unclean" every component that can't restore an exact state upon initialization. I wouldn't call that "unclean" because it seems like it was badly written, which isn't usually the case. They were written based on regular assumptions which VDOM based solution end up breaking without necessarily providing an escape hatch. For example, if your autocomplete component options are populated from some XHR request, than reinitializing it would force that XHR to be requested again which could introduce a noticeable delay. It doesn't mean the component is not "clean". It just doesn't work well if something would be constantly removing it and recreating it. &gt; I understand your lack of trust for Facebook It's not Facebook I don't trust. It's the future of React implementation based on its documentation actually. I don't like to depend on any framework built to support any company's product only, it doesn't matter what product/company it is. But since there are many React compatible libraries out there, this is not something I'm really worried about. But since React is the reference implementation, if the alternatives would follow React's changes in the implementation, than I'd have the same problem. That's why I also asked Preact and Inferno authors about what they think about this. I've been using jQuery forever and I know its team is very concerned about compatibility breakages. That's very unlikely to change because it's part of its culture. I would probably never use Angular after they basically created another incompatible product with Angular 2. That means this could happen again with Angular 3. Indeed we can never be sure of anything but we don't take our decisions blindly either. We usually observe and try to make the best decisions based on the facts we know about. If React decides to update its documentation to point out clearly that they will always provide some means to integrate with non-react stateful components, then I may decide to trust its documentation and adopt it. But relying on jQuery and become surprised that jQuery 4 will break everything is different from relying on React when its official documentation explicitly says that shouldComponentUpdate could be considered just a hint in the future. The risks are quite different from my point of view. You mentioned it being open-source as it this was warranty of anything. Rails is also open-sourced but it's certainly much more optimized to Basecamp's needs rather than what most of the Rails community would expect. Most Rubyists seemed to prefer RSpec at some point, but the default was something else. Most preferred jQuery at some point but Prototype was bundled by default. Many were building traditional SPA and wanted integration with Node build tools and npm, but they used to provide their own thing for a long time and promoted technologies no one was buying such as TurboLinks and so on. I mean, of course people are free to contribute but whenever there are conflicts, the company's needs usually comes first. Since Google would no longer work with Angular 1 but would prefer to use Angular 2, then why maintaing something they wouldn't use? I understand Google's concern, but I also have my own concerns because I'm not Google, or Facebook or Basecamp. I'm in a two developers team, with little resources when compared to those big companies, which means those decisions have even more impact in our product. I also hope React doesn't change in a way it would break compatibility with existing third-party components that rely on its current implementation, but I'm not sure I should invest much time on it when the documentation explicitly says it could break that compatibility without providing any guarantees regarding third-party components...
so does [Array#find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find?v=control)
That has not been my experience with jQuery even after several years using it and upgrading it. Or with Rails. When the library goes through a deprecation phase and then they remove little used public APIs and provide another way of achieving the same, this is way more manageable than relying on some behavior which the documentation clearly tells you you shouldn't count on. While I value React's concerns with regards to deprecations, no deprecation would be needed to transform shouldComponentUpdate in a hint since the documentation explicitly says we should consider it as a hint. That's the difference.
I've started to move this way with Angular 1.x; Use it for UI/binding and nothing more. 'Course this is in preparation in moving to Vue or React while giving my boss the good argument of "we only need to change a small percentage of code". I've mostly had this approach from the beginning as I've long developed my App logic in a single global var, a'la YUI (at least that's where I learned the technique from). I've never been a fan of "the Angular way^TM". Using it in this way allows me to (in theory) change out Angular (e.g. the UI/binding stuff) about as easily as switching a Db. Course I guess we'll have to see how it actually goes :)
What you say makes sense but most of it holds true if you are using just Redux like I described and not React-Redux. Maybe though I haven't worked on large enough apps to see the advantage of `connect` over just accepting props that come from the state and a `dispatch` prop. 
ha, whatever - there's still tons of sites using it to generate real business value. i'm also ready to move on - but it's still solid for some basic things.
I expect every great library/framework to deprecate things and provide the new path to achieve the same. This has been the case with jQuery since I started using it several years ago. This was also the case with Rails for the many years I used it. However this is different in React because the documentation explicitly tells you that you shouldn't count on its implementation without telling you how to support third-party components, that's why I'm really concerned. React doesn't actually have to deprecate any changes to what it considers an internal implementation detail. Provided you're using public API from jQuery, Rails and most big projects, chances are that you're always be offered an alternative to the deprecated API methods as well as some time to migrate your code. For that jQuery deprecated list, they have been deprecated long ago and I haven't been using them for a long time, but they always provided the new way to achieve the old results. This is what really matters to me. I just want to know how I am supposed to support third-party stateful components with React, and React documentation doesn't tell me. Or it tells me that I could use shouldComponentUpdate and rely on the diff algorithm and how it won't touch children from an empty container, and then it will warn you that shouldComponentUpdate could be considered just a hint in future versions and that we shouldn't rely on the diff algorithm. In other words, I don't know how exactly React expects me to integrate with third-party stateful components, that's my main concern.
I agree. Testing without needing to mess with context is way easier. Your approach is definitely more testable, I think. 
What do you use the most from lodash? Only thing I've ever used is deep copy. Any advice on what I'm missing out on?
Yeah, I use very little from it at this point. I think my most used function is pick. The ability to iterate over objects is cool, but a bit confusing. I always forget what it returns, what order the params to the callback are, etc. 
&gt; How can it turn five when it's already dead? I read this as a bit of sarcasm/humor, but then I agree with /u/iends in spirit. It's actually a pretty clever response to the title. Of course I could be totally wrong with my interpretation. &gt;I'm as ready as anyone to move to something else. Again, just my take, but that's exactly my takeaway from "it's already dead", i.e., people are moving on.
Also the various weekly newsletters that deliver the best articles of the week to your mail box. 
Can you give an example?
Hi, thanks for responding. I'm not exactly sure where you're going here. I looked for .extend and it doesn't seem to apply to this situation? Did you mean I should use one of the libraries that has it? because that seems closer. I did find .assign while I was looking and it looks like it could be closer but it seems to only work if the keys match which isn't my situation. Sorry if I'm missing something simple, I appreciate your help.
Hi, thanks for responding. I'm not exactly sure where you're going here. I looked for .extend and it doesn't seem to apply to this situation? Did you mean I should use one of the libraries that has it? because that seems closer. I did find .assign while I was looking and it looks like it could be closer but it seems to only work if the keys match which isn't my situation. Sorry if I'm missing something simple, I appreciate your help.
@ u/shad0proxy, it won't let me respond to you so I'm posting here. sorry. Hi, thanks for responding. I'm not exactly sure where you're going here. I looked for .extend and it doesn't seem to apply to this situation? Did you mean I should use one of the libraries that has it? because that seems closer. I did find .assign while I was looking and it looks like it could be closer but it seems to only work if the keys match which isn't my situation. Sorry if I'm missing something simple, I appreciate your help.
From the [docs](https://lodash.com/docs/4.17.4#find) var users = [ { 'user': 'barney', 'age': 36, 'active': true }, { 'user': 'fred', 'age': 40, 'active': false }, { 'user': 'pebbles', 'age': 1, 'active': true } ]; _.find(users, function(o) { return o.age &lt; 40; }); // =&gt; object for 'barney' // The `_.matches` iteratee shorthand. _.find(users, { 'age': 1, 'active': true }); // =&gt; object for 'pebbles' // The `_.matchesProperty` iteratee shorthand. _.find(users, ['active', false]); // =&gt; object for 'fred' // The `_.property` iteratee shorthand. _.find(users, 'active'); // =&gt; object for 'barney' 
It doesn't make sense to attempt to reassign the "first" value in an object because the contents are not saved in a particular order. To access a value in an object, you need the associated key. If you really want a data structure that allows you to access by key or by insertion order, look for an "ordered dictionary" library.
It doesn't make sense to attempt to reassign the "first" value in an object because the contents are not saved in a particular order. To access a value in an object, you need the associated key. If you really want a data structure that allows you to access by key or by insertion order, look for an "ordered dictionary" library.
Object.extend is not a standard function. Are you thinking of Object.assign? It doesn't apply to OP's scenario.
You're missing a lot. First, while you _can_ manually write the code to subscribe to the Redux store in your React components, **there's absolutely no reason to write that code yourself**. The wrapper components generated by React-Redux's `connect` function already have that store subscription logic taken care of for you. Second, `connect` does a _lot_ of work to ensure that your actual components only re-render when they actually need to. That includes lots of memoization work, and comparisons against the props from the parent component and the values returned by your `mapStateToProps` function for that component. By not using `connect`, you're giving up all those performance improvements, and your components will be unnecessarily re-rendering all the time. Third, by only connecting your top-level component, you are also causing the rest of your app to re-render unnecessarily. The best performance pattern is to connect lots of components in your app, with each connected component only extracting the pieces of data it actually needs via `mapStateToProps`. That way, if any other data changes, that component won't re-render. Fourth, you're manually importing the store into your components, and directly coupling them together, thus making it harder to test the components. I personally try to keep my components "unaware" of Redux. They never reference `props.dispatch`, but rather call pre-bound action creators like `this.props.someFunction()`. The component doesn't "know" that it's a Redux action creator - that function could be a callback from a parent component, a bound-up Redux action creator, or a mock function in a test, thus making the component more reusable and testable. And finally, the vast majority of apps built using React and Redux use the React-Redux library. It's the official way to bind the two together, and doing anything else will just confuse other developers looking at your project. So, part of the issue is you're not using React-Redux and `connect`, and part of the issue is you're using an inefficient pattern for pulling data from the Redux store into your React components. For more info, see: - The [Redux FAQ section on performance](http://redux.js.org/docs/faq/Performance.html) - The [Redux FAQ entry on connecting multiple components](http://redux.js.org/docs/faq/ReactRedux.html#react-multiple-components) - The [Redux FAQ entry on components re-rendering too often](http://redux.js.org/docs/faq/ReactRedux.html#react-rendering-too-often) - The [Redux FAQ entry on importing the store directly](http://redux.js.org/docs/faq/StoreSetup.html#store-setup-multiple-stores) - The [Redux Performance](https://github.com/markerikson/react-redux-links/blob/master/react-performance.md#redux-performance) section of my [React/Redux links list](https://github.com/markerikson/react-redux-links) - And finally, my blog posts [Practical Redux, Part 6: Connected Lists, Forms, and Performance](http://blog.isquaredsoftware.com/2017/01/practical-redux-part-6-connected-lists-forms-and-performance/) and [Idiomatic Redux: Why use action creators?](http://blog.isquaredsoftware.com/2016/10/idiomatic-redux-why-use-action-creators/). Source: I'm a Redux maintainer, and author of the Redux FAQ.
Oh hi, Mark!
Yes. I meant `Object.assign()` I think `Object.extend()` is deprecated now.
Ok, so I get that it's the "official" way and that's kind of why I am asking: I feel like I _should_ be using it but am not. I really like Redux and think it makes things really clear but not React-Redux which is why I have been avoiding it. You make a good point on the organization, testing and that not having a `dispatch` prop decouples things from Redux. You convinced me on that. But the performance aspect is really interesting and I don't quite believe that I am missing out on optimizations. From a data point of view, if the state gets immediately converted to props in the root render method, from there on it should be pretty easy to work out which components need updating: just those whose props have changed. Seems like React should be able to take care of this. Where would issues arise? 
They are actually very similar. In fact the first example shows the exact same signature. I think it's fine if you like the more compact syntax, but the only problem is if you're bringing in the whole of `lodash` for a subjectively nicer `find` function, ie use modular imports. 
Let's take the classic example of a TodoList that has 10,000 list items in it. To start with, assume that the TodoList is the only connected component, and it renders `&lt;TodoItem todo={someTodoEntry} /&gt;` as its list children. If you edit the text of a todo entry and dispatch a Redux action to update the text of that one object in `state.todos[1234]`, the store will notify all of its subscribers (in this case, the TodoList component), and the TodoList will re-render. React's default behavior is that when a component re-renders, _all_ of its children re-render, and so on recursively down through the component tree. So, even though we only modified the data for a single todo entry, all 10,000 `&lt;TodoItem /&gt;` components will re-render, and for 9999 of them, their render methods will return the same render output as before. React will correctly see that there are no render changes and will make no DOM updates. That means that those 9999 component re-renders were "wasted" effort that could have been avoided entirely with the proper optimizations. However, if the `TodoList` was connected but instead rendered `&lt;TodoItem id={1234} /&gt;`, and those `TodoItem`s were themselves connected components whose mapState functions looked like: const todoItemMapState = (state, ownProps) =&gt; { const todo = state.todos[ownProps.id]; return {todo}; } In that case, `connect` would see that each `TodoItem`'s `mapState` function was returning the same `todo` object as before, and skip the re-rendering for that list item. This is also a good use case for normalization, because you generally should be tracking the items in your state by ID rather than array indices, so that you can look up an item from your Redux state just by knowing its ID. I talk about all this in the links I put in my original comment, and those also have links to more articles and reading. (I've used this example many times, [including this chat log discussion from Reactiflux](https://gist.github.com/markerikson/53735e4eb151bc228d6685eab00f5f85).) Please believe me when I say I know what I'm talking about on this topic :)
thanks! this helped to get me thinking about having both a and b be arrays rather than objects which will make it much easier! 
Nope. Remember that "rendering" just means "return a tree of objects describing how I want the UI to look like _now_". React then diffs the previous render output vs the new render output to determine if changes should actually be made. That process does take time and effort to accomplish, so if you _know_ the render output isn't going to change (because your component's props and state haven't changed), you can use `shouldComponentUpdate` to skip the render process for that part of the component tree. But, if you don't, React's default behavior is to always re-render everything.
Yeah, there isn't a sense of humor on reddit :D
Irrelevance to the discussion. The discussion in this particular comment thread was already about that, so people expressed interest in discussing that matter. I just chimed in with a possible explanation of the reason he got downvoted. To be perfectly honest, I really don't give a flying fuck about it - in fact you're right in the sense that I did discover a library today. Just giving my two cents is all.
Why mobx? I have seen several people suggest it over redux but not sure why? Angular and react are different solutions to different problems. I hate when people try to compare the two. If you can't identify your problem then you can't identify the solution.
I agree that the statements regarding possible changes to future behavior raise a couple questions about what _might_ happen, but as I've already said a few times now: re-rendering is _not_ the issue! If you have a component that wraps up a jQuery plugin, and only ever _renders_ a single `&lt;div&gt;`, then re-rendering will not change that div or interfere with the elements the jQuery plugin has appended.
Maybe we have a conceptual difference when we both mention re-render. If we're talking about re-render as in calling the `render` method which is part of a `React.Component`, I absolutely agree from you. What I understood from that "React could re-render the whole app on every action; the end result would be the same." sentence was, we will dump away your entire tree and re-create it, and you should be able to recreate it from scratch, only with the initial props given to you. As in, make sure your view tree can be represented as a function of input (props) to output (components) without outside influences. In that case I imagine that single `&lt;div&gt;` instance going away.
Vuejs better
Yeah, "rendering" does have a _very_ specific meaning - calling `render()` :) So, when the React team talks about "re-rendering the entire app", I am about 99.99% certain they mean recursively walking down the component tree and calling `render()` on each component, _not_ "blow it all away and start fresh". As mentioned, the React team is very pragmatic, and React does have all these "escape hatches" like refs and `shouldComponentUpdate` explicitly so that React can interop with non-React code and skip unneeded work, as _you_ see fit to use them for _your_ app.
checkout quasar and vue.js
Hmm yeah I use flow. Maybe more useful in flow? Not sure. My main program doesn't have flow (iterating too quickly) 
I've been an Angular 1.x developer for years and have built some big sites with it. It's pretty easy to wrap your head around once you get past the hurdles, such as scope. The key is to do things the "Angular Way™" and not try to inject your own JQuery/VanillaJS/React/Anything else mentality into it. Once you figure out how and why the developers chose to make things a certain way, things like testing and creating new code get a whole lot easier. That being said, I've been working on a site that uses Angular 4 with Server Side Rendering and I have to say that it's a big hurdle. There are things that just don't make sense yet, but it's coming along. I often compare the new Angular 2+ method to how React works and I'm considering jumping ship to React.
Because OOP and typechecking. Do you like it? I do. Are you calling a method on an object? Cool typescript can check that. Use redux and instead of class methods you'll find yourself writing reducers and big switch statements inside those reducers. Typescript is very good but it can't detect nowhere near as much potential mistakes as if you use classes and keep your referential integrity.
why does it matter if you use angular or react? I'm currently doing ASP.NET Core and React.... the more I work with react and read up on angular the more convinced I made the right choice. Microsoft released create-react-app with typescript: https://github.com/Microsoft/TypeScript-React-Starter MSFT is making strides towards React -- Both of the following are in react https://github.com/OfficeDev/office-ui-fabric-react https://dev.office.com/fabric#/components/button
https://github.com/Microsoft/TypeScript-React-Starter :)
This is scaremongering. React integrates with javascript libraries just fine-the proof is in the ecosystem which features thousands of wrapper coomponents for even the most archaic JS libs. I've used on the projects a lot of them and they always worked well. If they did not it was a bug of that react wrapper or underlying ui library, not a bug in react. BTW this shows how few people truly know how react works, because it got so many upvotes.
Next part of the article now available on [our blog](https://www.reddit.com/r/javascript/comments/6hm2jf/lodash_is_not_only_for_list_manipulation/) 
So how is this different and or better than lodash?
I would learn C# due to Unity, ASP.NET, Xamarin, and the fact that it's an elegant language. But know that Java is the most popular language in the world after JS, and it can be used for native Android programming, so if this is important to you, pick Java.
Quick hack for swapping (using ES6 destructuring): [a, b] = [b, a]; If you need reference parameters, you can wrap values in Arrays, as a work-around: function swap(a_, b_) { const tmp = a_[0]; a_[0] = b_[0]; b_[0] = tmp; } const x = [5]; const y = [1]; swap(x, y); console.log(x, y); // [ 1 ] [ 5 ]
You should compare element position and height (visibility on screen) with scroll position.
Your whole list of conditionals can probably be a single.
Replied: https://github.com/facebook/react/issues/9926#issuecomment-309205972 TLDR: React makes some guarantees, but there is a tradeoff between progress and promising too much. In our experience with 30,000 components these guarantees are enough for apps, but YMMV. 
I followed through the [MS tutorial here](https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/index), but that was about 9 months ago so I don't know if it has been outdated by a new release.
lmao, a redux maintainer is telling you about the performance optimizations and you still don't believe, why are you still here? just keep your head in the sand and keep doing it the way you have been if it works for you
lol keep arguing semantics bud
pickBy with custom filter functions is extremely helpful when you need it.
The main issue with React documentation has been clarified already by the React team and I can now become confident enough to adopt React, I'll just answer to some statements. &gt; Now what I don't understand from /u/rrrosenfeld is that how can you ever trust a third-party library with this paranoiac mentality? I'm not paranoic about every component, but something like React, Angular or Knockout, or jQuery, specially if they are used all over the application, should be considered a critical part and for those cases I'm very careful before adopting such kind of technology. I can easily replace some common datepickers, sliders or autocomplete components, so I don't need to be paranoic about those, so I don't have a problem with trusting third-party libraries in general because I don't actually have to trust them. I can easily replace them if they become an issue. But how am I supposed to replace something like React if it can't play nice with other technologies? Now that I understand this is not the case, I can feel safe to adopt it knowing that I'm free to change my mind later with a feasible migration path from React if I decide to move away from it. &gt; Lastly, no one makes you update react versions. Indeed, but no one wants to use an ancient version forever. If the new version breaks something by mistake, it will be fixed in the next version and I can wait before upgrading. However, if the change was intentional and it no longer allows you to integrate with third-party libraries, then that means you'll have to move away from it which will cost you quite some time. If you already know this is supposed to happen, why do that? That was my point. Fortunately this wasn't the case. I just misinterpreted the docs. &gt; I've worked in a Rails 2 code base before and the team could not update to Rails 4 because they knew they would break. Do you see how being careful can help? You called me paranoic, but I was always scared by the way Rails upgrades everything at once. If you want to upgrade ActiveMailer or ActionPack you're also forced to upgrade ActiveRecord, which has a terrible API and often introduced backwards incompatibilities. So, very soon, I decided to use Sequel instead of ActiveRecord and that with some other cautions allowed me to be always up to date with every new Rails version. I would often update to the newest Rails release in the exact day it was released and it would often just work after a few tweaks (in several cases with no tweaks at all). But I noticed how upgrading Rails was a nightmare to many people. But the way I choose what I want to depend on (I avoided any gems that would monkey patch some of the Rails libraries, for example) allowed me to have an easy time getting up to date. The reason why I moved from Rails had nothing to do with finding it hard to upgrade it. The upgrade process was always easy on our side. &gt; It happens, projects get rewritten, dumped, completely refactored, you got to take action at some point. The application I currently maintain was written with Grails when I got into this project. I slowly replaced it with Rails when working around some Grails bugs that were never fixed. At some point I moved completely to Rails. It wasn't a complete rewrite in the sense things were moved one little part at a time and trying to keep the logic when it made sense and improving over it as I saw fit. I would say I was evolving the application, not rewriting it. When I moved from Rails to Roda it was even simpler to move one part at a time to Roda as most of the code would remain unchanged as it's the same language. The only migration I had to perform at once was when I decided long ago to move the MySQL database to PostgreSQL since I can't move one table at a time ;) But the code itself required minimal changes in that case. The harder part was to script the data migration itself. My point is that proper planning pays off.
/u/acemarke was right with regards to what the documentation meant when talking about rerendering: https://github.com/facebook/react/issues/9926#issuecomment-309205972 I just updated my article to reflect that.
Don't loop and put event listeners on elements, instead put it on their closest shared parent, and observe event.target, it's way easier
The article never suggested it doesn't integrate. It was questioning whether this would always be the case or if that just happened by chance but the situation could change if the implementation details are changed. This has been already clarified in the React issue I created on GitHub and they explained what exactly they meant by "rerendering the whole app" in their documentation. I've updated the article to reflect that.
The only issue I have with Jest is it's non-specific name. For some reason I'm always struggling to get any search results - the 'jest' keyword seems to be omitted.
I never once mentioned typescript. I use it for everything. Thanks for attacking me on no basis. And you use mobx over redux because of switch statements. Good to know. edit: I actually looked at the docs for mobx and it seems it simply allows annotation use and classes over purely functional.
I'm sure there are many of those because they've invested so much time with 1.x and they're frustrated with the churn/time to ramp up on something new. Of course it will be a long time in the wild, it got massive hype/adoption. We still have struts 1 apps at work from 12 years ago, still in production. Two, on the team I'm on, are major apps, one is our most used app across the entire company/suite of products (and we have a bunch). I just finished up a rebrand on it a couple weeks ago. Not a rewrite, just window dressing, i.e., putting lipstick on that pig.
Built a site that tracks twitch's historical viewership trends for games, who their top broadcasters are, and top broadcasts for each day. This one took a little while. https://www.twitchmine.com/
I had been contemplating using React with firebase recently and then I saw this. Glad to see other people are thinking along the same lines.
Fair enough, good discourse. Have a good day.
Also work for a small startup where we use Aurelia, which has lots of similarities to Angular. I use React for personal development. I would choose React but they are pretty different when it comes to frameworks. React is a component based, DOM rendering focused framework whereas Angular seems to be more of the MVVM templating framework. Like I said, we use Aurelia so I could be mistaken, but it's totally up to what you're trying to do.
I like that microtransaction focus. Good angle. I'll have to think about how to differentiate from SO, codementor and hackhands.
Could you format your code (edit the post to add four extra spaces to the beginning of each line that should be shown as code)? Or, even better, create a [JSFiddle](https://jsfiddle.net/) with the HTML and JavaScript that shows your problem. EDIT: I *think* I see what the problem is. When you modify an element's `innerHTML`, every element inside of it gets deleted and recreated based on the new `innerHTML`. Because you're modifying `document.body`'s `innerHTML`, one of the elements that gets deleted and recreated is `&lt;table id="outside"&gt;`. The original table to which you added the event listener is gone. Even though your body tag is after the `&lt;table&gt;`, every visible element must be in the body, so web browsers will automatically start the `&lt;body&gt;` when they see a visible element, and then ignore the `&lt;body&gt;` tag later. I changed your code slightly to make it work: 1. I'm appending to a new `&lt;div id="numbers"&gt;`instead of `document.body`. 2. I added `var` before `cancelPressed` on the second line. As a few people here have mentioned, putting `'use strict';` at the top would catch that. Take a look: &lt;table id="outside"&gt; &lt;tr&gt;&lt;td id="t1"&gt;one&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td id="t2"&gt;two&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;div id="numbers"&gt;&lt;/div&gt; &lt;script&gt; var startingNumber = 0; var cancelPressed = false; // Function to change the content of t2 function modifyText() { var t2 = document.getElementById("t2"); cancelPressed = true; if (t2.firstChild.nodeValue == "three") { t2.firstChild.nodeValue = "two"; } else { t2.firstChild.nodeValue = "three"; } } // add event listener to table var el = document.getElementById("outside"); el.addEventListener("click", modifyText, false); var numbersEl = document.getElementById('numbers'); function incrementNumber () { if (cancelPressed) { return; } else { startingNumber++; numbers.innerHTML += startingNumber; setTimeout(incrementNumber, 10) } } incrementNumber(); &lt;/script&gt;
I've tried several different playlists, but everything that downloaded was unplayable. I've tried to play them on multiple machines. These are my media machines, so I'm fairly sure it's not a codec problem. Edit: I can get them to run via SubSonic, but the reported song length is too short, and the progress bar just stops while the song plays out. Also, when running thru MP3Diag, they show some of the following errors: * No MPEG audio stream found * Unknown stream found * Invalid MPEG stream. Stream has fewer than 10 frames (this error is repeated many times) I love the concept, but am I doing something wrong?
HTML &lt;p id="id1"&gt;1&lt;/p&gt; &lt;p id="id2"&gt;2&lt;/p&gt; &lt;p id="id3"&gt;3&lt;/p&gt; &lt;p id="id4"&gt;4&lt;/p&gt; &lt;p id="id5"&gt;5&lt;/p&gt; &lt;p id="id6"&gt;6&lt;/p&gt; JavaScript for(var i = 1; i &lt; 7; i++) { document.getElementById("id"+ i).innerHTML = "new " + i console.log(i); } Hope this help!
&gt; and here we get a taste of Polymers biggest weakness — error logging or rather LACK OF proper error logging. do you even lint? https://www.polymer-project.org/2.0/docs/tools/polymer-cli-commands#lint but I agree &gt; What was even more baffling is that I had another Polymer codebase from earlier where dom-repeat was working just fine, I spent an hour and a half looking at the 2 codebases trying to figure out what was different. the magic annoyance of globally shared imports &gt; The problem wasn’t with the array but with me not calling super() correctly, it should be connectedCallback() { super.connectedCallback() } and not connectedCallback() { super() } which is what I did. well maybe just learn js classes then. `super()` calls the constructor ~-~-~ Overall pretty bad article I think and the funny part about general javascript community is that it seems polymer will never be ready. I'm all for perfection but I think polymer is more than ready for production (depending on your needs of course) even with it's flaws and ongoing development. There will always be flaws and seems any little flaw is good enough to render it completely useless. But to not get downvoted into oblivion I guess I'll HAVE to add; polymer isn't for everyone or everything, and it does have flaws (many of which are actually features).
Why people still use bower for new projects? Isn't it supposed to be dead? What are the benefits against npm?
Here's my standard advice for learning React : The article "A Study Plan to Cure Javascript Fatigue" ( https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1 ) is a great place to start. It gives an excellent series of steps for tackling modern Javascript concepts one piece at a time: Javascript, React, ES6, and state management. There's also a "Front-End Study Guide" based on that article that's very good, at https://github.com/grab/front-end-guide . On that note, definitely don't over-complicate the learning process by trying to learn many different things at once. Some people will say you should use a "boilerplate" to learn React, and they're wrong - boilerplate projects almost always come with too many pieces configured, and are confusing for beginners. Instead, the best advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful, and you can learn about other tools later. You should start out by reading through the official React docs and tutorial at https://facebook.github.io/react/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part (so you can jump right into playing with React, instead of configuring Webpack and Babel) . There's an excellent post called "Simple React Development in 2017" ( https://hackernoon.com/simple-react-development-in-2017-113bd563691f ) that gives some more specific instructions on the actual steps to follow. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, and much more. I also published an "Intro to React (and Redux)" presentation at http://blog.isquaredsoftware.com/2017/02/presentation-react-redux-intro/ , which is a good overview of the basic concepts for both React and Redux. (My list DOES have sections for learning Webpack too, but I advise not worrying about that for now.) Finally, the Reactiflux chat channels on Discord are a great place to hang out, ask questions, and learn. The invite link is at https://www.reactiflux.com .
Switching from Karma to Jest improved the time running our test suite from one minute to about 8 second. That was huge for us.
looks cool, do you also have the reports for streamers?
Jest was pretty bad a couple of years ago. You should give it another look, it's improved a lot.
Super fast tests? When I tried to use Jest it was slower than Mocha (it's like it needed some time for start, and Mocha started immediately), so I stopped used it. Although I've used it in small project, maybe in bigger project timing is different.
Neat article. Not sure if rendering all 1M nodes is the right way to go (I feel like binning would be a more user friendly solution), but as an experiment in performance this was a good PoC.
great answer! I love how React only makes changes based on the V-Dom and is agnostic about what other attributes may have been attached to by an external library. For example I made a realtime data charting app where the Chart Component only rendered a div with an `id` and `className` and on `componentDidMount` it just called a CanvasJS function and CanvasJS safely renders a chart inside while React leaves the div alone only to possibly change the div's className as new charts get added. 
I think the observer pattern is brilliant and I hope something like rx gets native support, however I would recommend promises simply because they have native support and are easier to understand.
Also to highlight your point TypeScript works better with React than it does with Angular since angular uses templates which currently can not be type checked(this may have changed recently), but in React all code can be checked. The new Angular is also risky since Google is notorious for abandoning open source projects. Since google does not use the new Angular for anything significant who's to say they won't just get bored and abandon it. React on the other hand is actually used by Facebook themselves. 
I think that in general you're right, but there are a couple of things you get out of rendering every node (or at least a lot of them): * A neat visual * Insight into the long tail, which is something that is very difficult to get from a top-down view. Knowing that you have an extra 500,000 tiny objects or arrays clogging up your app -can- be a useful data point * A sense of scale. It might seem critically important to clean up your largest retainers, but when you have them in the context of your entire footprint it can show that the biggest win is to actually clean up a class of smaller but more frequently repeated nodes. Plus, as you say, the experiment in performance has been fun.
Minor nitpick &gt;We need to offset our circle’s position by half of its size in each direction because PixiJS Sprites do not have the concept of an origin point. This is actually wrong. You can modify the origin point by changing the `anchor` property of any display object. const sprite = new PIXI.Sprite(); sprite.anchor.set(0.5, 0.5); They also should have used a ParticleContainer, which is optimized for rendering tons of simple sprites, and runs about twice as fast as a normal container. It can definitely handle over a million sprites for something that doesn't need real-time rendering (I got ~6 fps @ 1 mil sprites last I checked). 
If your library needs either mechanism simply to deliver a payload that's computed/received later, use Promises. Observables are more flexible, when an object can experience a wide range of states and outcomes (not just "success" and "failure"), but is harder to work with and prone to callback hell. So both have their place, depending on the details.
Thank you so much for taking the time to write that out! It was very helpful!. I need to learn how to properly ask for assistance on this site. Thanks!
Thanks for replying! I will take more time to write a better example in the future. I was trying to write a simplified example of something I'm trying to write for a more complicated script - essentially to be able to periodically check if the script has been cancelled by the user or user action or needs to be restarted. Thanks for your help!
It was an interesting video, but I prefer to use them in this specific instance. There is, of course, the input -&gt; month element, but I don't think there is cross browser support. 
Definitely frustrating. Putting "js" in front of your searches tends to help a lot.
You are very much correct! I'll be talking about the ways that I optimized that piece in future articles, but it mostly involved rewriting the hot path in C++ so I could compile it to WebAssembly.
It's been a while since I touched the sprite renderer, but from what I remember I was having issues getting the sprite and hit area to line up correctly when using an anchor point. I'll edit the post to correct this, though. Also, good call on the particle container. I'll make an edit and run some benchmarks against the stackgl version. Thanks for letting me know!
Published my first npm package! A command line tool for `git diff --name-status` in the form of a directory tree: https://github.com/Bates550/diff-tree
really like it
... Good point... 
What's so interesting about using var?
What's wrong with JSON schema?!
Interesting, I'm doing it this wrong way you have described. Could you please give a small example of the right way to do the above using composition? Thank you!
JSON schema is okay though it's quite verbose like an XML schema. This library's usage seems...really awkward to me. Honestly I've found [Joi](https://github.com/hapijs/joi) to be the most intuitive for JavaScript and Object validation but it's a little heavy for the web browser.
that was something i needed. whenever checking for someone else's​ merges i needed to look all filenames and see if he/she did anything outside the allowed folder
Love that the examples demonstrate composing specs.
Yes, this is the same in any language (the difference between the two). The import thing in JavaScript is knowing which data types get passed by value vs. passed by reference.
The kind of memes computer professors use
I'd Recommend you use chrome on desktop for trying out the app. Cheers! The app is extendible using React components. You are welcome to contribute.
Something which is also interesting in functional languages is that you pass the cup to the `fillCup` function, but you get a new cup for it in return.
Bad username. 
&gt; this passes as a meme now? it's just a gif with words on it haha that's a pretty good meme you got there!
Which is also an important thing in many other languages, such as Java, C#, VB, Swift. Even Python, sorta. 
Go look up the definition.
Also, gotta note in JavaScript most types are Objects or subtypes of it. In C++ for example, all types are based on number type.
Most data gets saved in some sort of Object, yes. **But** most properties of those objects are primitives, so it's a bit confusing since the Object is passed by reference but the primitives inside those objects are passed by value when used somewhere.
have u entered any amount?
I think everything is a reference except strings, numbers, and booleans? What did I miss?
Never.
Didn't miss a thing, that's right. Primitives pass by value, all others by reference.
It gets tricky because in some languages you pass by value but the value is a reference for non-primitive types.
You missed Function.
It could vary by implementation, but I'd guess that strings are passed by reference since most/all implementations intern strings.
Not many files are actually shared between them, but to be able to code in the exact same style is a huge benefit. Not having to content switch whenever I'm switching between server and client is great. 
That's how java is
Man, I just love it when people who have never actually coded in a language that supports pass by reference try to explain what it means. This animation shows the difference between passing by value and "passing a reference by value", which is not the same thing as "pass by reference". **Javascript does not support pass by reference**. And if that sentence makes you want to hit "reply" to try and argue that it does, stop right now and pick up a book on C++, because you don't know what you're talking about. Shit, even C# supports real pass by reference. That might be easier to pick up for a JS programmer. It's probably somewhat difficult to describe visually in a 2 second gif, but in actual pass by reference, you are not only able to modify the contents of the cup, rather you are able to modify the cup itself, and even replace it with an entirely new cup. All the OP shows is the difference between passing a reference type vs a value type...you guessed it, by value, because JS doesn't support pass by reference. So again, go read a book on C++. Or even just read [this SO response](https://stackoverflow.com/a/13104500) with some brief code examples.
This is exactly wrong. In Javascript (and a bunch of other languages), everything is passed by value, including references.
What you're describing is what "pass by reference" means. Some "value" is always passed in stack based languages. "Pass by reference" means the passed value is a pointer instead of the value of the data type.
My current team uses Jest and I'm still on the fence. The watch functionality is phenomenal, but the caching of transforms has caught me out so many times, where supposedly passing tests are actually failing. I'd rather have deterministic tests that run a few seconds more slowly than encounter incorrect results. It's a good framework but overall, I feel that it does too much, and other than the watch functionality, doesn't provide me with that much benefit over my usual Mocha, Chai, and Sinon setup.
Imo this would be a great reply with some good info if it wasn't super condescending.
I have been educated.
It's just weird to use `var` in an environment where `let` and `const` are available. I'm not really aware of any benefit of using `var` over `let`, so in general most ES6 resources tend to use `let` and `const` exclusively.
&gt; From the point of view that a programmer cares about... This is the point of view that I'm working with, not referring to the internals. Mutability is a separate issue. As far as argument passing semantics go, all arguments are passed by value in Javascript, and many other languages. Go check out the code example in the [SO reply I linked](https://stackoverflow.com/a/13104500) in my other comment.
It actually does affect how the language works. In JavaScript, you're actually passing a reference by value. That's different than passing by reference in C++ or something. In JavaScript, if you use assignment on any of the arguments, it doesn't change the original value that was passed into the function. You have new variables inside the function that reference the object you passed in, but when you assign them, they're referencing something different now, and the original variables outside point to the original object. In C++ you can call a function, assign a reference that was passed inside of it, and you will change the value at where it was called from.
Haha alright well yeah I mean it's all well and good if you're joking around with friends but I think a lot of strangers online will take it as a serious insult to their intelligence/profession. Which I think we can both agree is unfounded. There are shit C++ devs and shit JS devs (though shit JS devs might outnumber the C++ ones just purely based on JS being a far more ubiquitous language). I'm not offended just, you presented some new info (for me) and I woulda have liked it more if my intelligence wasn't passively insulted while reading it :/
The difference is that "pass by value" is a well-defined and understood term with historical significance, and "pass by reference with immutable primitives" is a phrase that you just made up to try and explain pass-by-value in a way that uses the concept of "pass by reference" which, again, doesn't exist in JS.
imo if we call out this tone collectively it can change. i think it is a default for a lot because they see it used a lot and it's just not necessary (and yes i realize i'm giving a serious reply to probably a flippant comment lol)
Oh, but JS developers *should* feel insulted, because Javascript is a joke of a language... (Again, I'm sorry. Clearly I'm just in it to amuse myself at this point.)
To be fair, I'm not really much of a web developer, so you don't have to consider this a stain on the community or anything. Think of this more as a wannabe C++ greybeard (I'm not much of a C++ dev either) coming out from his troll hole to school you youngin's about pass by reference.
Java passes primitives by value and objects by reference. The confusing part maybe that some types can be represented by either primitives or objects and they can be "boxed" or "unboxed" to switch between the two representations.
It's not too confusing I think if you've worked with a language that has pointers. In C or C++ you can do the same thing as C++'s pass-by-reference with pointers.
This type of argument is pretty common in Java (and apparently now JS) communities. I've seen the same sort of arguments happen when it comes to memory leaks as well. It's clear to anyone who has written C++ (or any unmanaged language) that writing a true leak in a garbage collected language is not possible, but there are people all over the internet trying to argue the opposite. The "counterexamples" often include running an infinite loop that creates a new object every iteration, or invoking "leaked" file and DB handles. I think this is just another example of devs attempting to reappropriate, or broaden a term to cover a concept in their language of choice, even if the original definition may not really describe the situation they're trying to define. I saw this recently in a tech talk about async in JS. The speaker used the phrase "inversion of control" to describe...I guess, using callbacks? I did a quick google search, and it looks like she got that specious definition [from here](https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch2.md). Well again, most experienced Java or C# programmers probably understand this explanation as garbage, but since JS doesn't really have classical OOP constructs like interfaces and abstract classes, JS devs don't necessarily understand the historical meaning of "inversion of control". But for some reason this author decided to reuse that term to describe something fairly different anyway.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [getify/You-Dont-Know-JS/.../**ch2.md** (master → 77225d4)](https://github.com/getify/You-Dont-Know-JS/blob/77225d489b45749f832878afb697c5b3895f19f1/async%20%26%20performance/ch2.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dj2fy7y.)^.
What you're describing is a pointer. A pointer is a location in memory. When you assign to a pointer, you're only setting the location in memory a pointer points to. Hence why you can only modify properties of an object parameter if you intend for the scopes above you to see those changes. This also clearly explains why assigning a new string literal to the pointer does not change the passed variable's value. This whole thread of ridiculousness is driving me nuts.
Yeah seems like they haven't seen a language with proper pass by reference. I suppose this comes about because people learn pass by reference from c lectures and don't realise that languages like c++/pascal/etc have true pass by reference.
Those are probably C++ snobs, not Java snobs, and there's no "technically" about it. Passing "by reference" is a totally different thing than passing "a reference by value". What's misleading and confusing is Java devs using the term "pass by reference", when in fact, the language has no concept of "pass by reference". I mean, why even bring up the term to beginners if it's wrong, and the language has no support for it?
They are immutable? Can i not do Var hi = 4 Hi=5 Console log (hi) 5 
There's a reason stuff like https://msdn.microsoft.com/en-us/library/bb347013(v=vs.110).aspx doesn't exist in java. Hint: that reason is that it does NOT have "pass by reference".. It's not some grammar discussion, there's technical differences.. You can't just redefine it as you wish.. And you're calling other people snobby, come on man..
Thanks for giving these guys a concrete code example, which illustrates the point :) really hate when the "I spent 10 minutes on code academy"-crowd spreads misinformation about things you would learn in any introductory course/if you actually worked as a developer.
Observables are prone to callback hell? How?
 foo.addListener('complete', (bar) =&gt; { bar.addListener('done', (baz) =&gt; { baz.addListener('finalized', (qux) =&gt; { qux.addListener(...); }); }); }); Of course, the above situation would happen if the objects should've used Promises rather than events. If the above wouldn't happen and you have a very simple scenario where one "layer" of events is everything that happens in the system, it doesn't matter what you do.
&gt;...it is 'pass by object reference'. That's not a thing. You're passing an object "by-value". This concept has existed way before JS. No one who writes C++ would call passing an object by-value "pass by object reference". The ability to change the object contents doesn't make it not pass by value, it just means an object in Javascript is a reference type. Passing a reference-type by-value is still passing by-value. Take C as an example. C is strictly pass by value. Now in C, you can create a pointer to an object. Some might call this a reference. Passing that pointer as an argument to a function mimics the functionality of pass-by-reference, but the pointer is still being passed by value. [See this great example on SO.](https://stackoverflow.com/a/30519731) You can't change the pointer itself, you can only change the thing it points to. In your example, you can't change the object itself, you can only change the values that it "points to", if you want to call it that.
That's [exactly how javascript works.](https://stackoverflow.com/a/13104500)
Exactly the behavior I expect from r/JavaScript why do I try
I do agree that there are already lots of tutorials on this topic. I have started this blog with a hope that I will use it to improve my skills and share what I have learned with others. Although JS community is strong, new comers are always joining it. I myself know a lot of fellow developers who are new to Javascript and they get stuck with issues like callback hells. And this is the only reason I used var instead of let or const. I don't wanted to confuse new comers with let or const when they came to understand something else. Do you think it makes sense? Since, I am just starting up writing such stuff, such comments are valuable to me :)
I couldn't remember the name of it, but I found it here. https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing The main point being that it is a complex behavior that the usual terminology doesn't cover. You expect that you are getting the protection of scope, but in fact you are not. The mutation reaches back outside the function scope, which is not generally the behavior that you want by default, but there it is. You usually have to do some shenanigans with Object.assign or json.stringify to get a unique copy to enclose the function scope correctly.
**Evaluation strategy: Call by sharing** Call by sharing (also referred to as call by object or call by object-sharing) is an evaluation strategy first named by Barbara Liskov et al. for the language CLU in 1974. It is used by languages such as Python, Iota, Java (for object references), Ruby, JavaScript, Scheme, OCaml, AppleScript, and many others. However, the term "call by sharing" is not in common use; the terminology is inconsistent across different sources. For example, in the Java community, they say that Java is call by value. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/javascript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.21
As I mentioned above, I thought, I should not confuse new comers with let or const when they came to understand something else. This is just my opinion. If it does not make sense, will change for sure
Yeah, my point is that it is a complex, unintuitive behavior. It's not just simply pass by value or pass by reference. It works the way you expect with primitive types by passing values, but behaves differently with objects. You are expecting the safety of scope to protect you from mutation outside of the scope, but in fact you are not given such safety.
&gt; Technically everything in JS is passed by reference. Source? That's not meant to be a rhetorical question. I've been trying to figure this out myself, but the spec is awfully hard to parse. The section on [ArgumentListEvaluation](https://www.ecma-international.org/ecma-262/7.0/index.html#sec-argument-lists-runtime-semantics-argumentlistevaluation) seems the most relevant. It seems to say that JavaScript evaluates the argument expression, then calls [GetValue](https://www.ecma-international.org/ecma-262/7.0/index.html#sec-getvalue) on the result. Inside GetValue, if the result of the expression is *not* a name or property binding, then it just returns the result of the expression as is. Otherwise, if it's a property, then it will call `[[Get]]` on the base object, which will return the value of the property. Otherwise, it assumes the result of the expression is a name binding, and it will call `GetBindingValue` on the base environment record. Either way, this reads like everything is passed by value.
Everything in JavaScript is passed by value. References to objects are passed by value. If they were passed by reference you'd be able to do this: function foo(p) { p = new Cat() } let v = new Dog() foo(v) // v is now a reference to a Cat object But in actual JavaScript, v would still be a reference to the Dog object.
Misleading. In pass by value, the compiler makes a copy of the variable on the stack or into a register. In pass by reference, it passes a pointer to the variable. At the end of the function that modifies a passed parameter, in pass by value, the value in the stack or register hangs around until overridden, but the original variable remains unchanged. This can cause some massively confusing behaviour particularly if the function mistakenly passes what it was passed, but by reference, to another thread. Pass by value is deemed to be safest because someone else's bug (or malware) down the call string can't mess with your data eg by writing past the end of a struct... But with all the copying, it is slower, especially for large types. JS was designed to be used for arbitrarily large constructs, so it passes by reference, by default, except for small types, which are passed by value. This can get weird when the small type is a pointer to a big thing. Derferencing the pointer will give access to the big thing, but assignment of the pointer (eg changing it to point to a different big thing) will not persist beyond the function. So in the example, if the variable that refers to the empty cup is a pointer to a cup, then both pass by value and pass by reference will fill the original cup! However, if the function assigns the pointer-cup to a different set of hands, in pass by value, this may not (safely) persist after the function returns (the cup may instead be in two sets of hands at once, leading to spills, burns and broken cups). 
If you’re writing es6, then no. There’s a subtle difference between let and var, and some people might argue that var is useful in extremely specific situations, but in that case I’d just find a way to make it work with let anyway. Also, I very rarely use let as 95% of the time const will do.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [dwighthouse/onfontready/.../**onfontready.js** (master → aea0e5f)](https://github.com/dwighthouse/onfontready/blob/aea0e5fa6374ae99bf44d2d8ce9c6d93e9edd68d/src/onfontready.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dj2jzy4.)^.
&gt; No this is false. There's a reason people keep mentioning that java doesn't have "call by reference". Eh... it's messy terminology. The problem is Java uses the word "reference" differently than how C/C++ uses the word "reference". The [Java language spec](http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html) explicitly says references are pointers. The behavior of what Java calls a reference exactly matches what /u/pinnr was describing. What you're describing, on the other hand, is a [C/C++ reference](http://en.cppreference.com/w/cpp/language/reference), which describes a reference as an alias. That means the phrase "pass by reference" is also messy terminology. In C/C++, it means a parameter is an alias for something; in Java, it means a parameter is a pointer to something. JavaScript seems to have adopted Java's terminology in this case. So in JavaScript, whenever you hear "reference", think "pointer".
If I'm passing a number, I still call it pass by value, not pass by number. Just because the value is a reference doesn't make it pass by reference.
Or stop being so sensitive and letting shit like this get under your skin.
That's how JavaScript is as well.
&gt; Perhaps in JS they are, but I would consider this a broadening of the term specifically to appease JS developers who cannot do classical IoC. I'm not talking about JS at all. I'm talking about software architecture in general. &gt; To me, inversion of control means I create a class that says "hey, I'm a class, and I depend on these three well-defined, abstract types being given to me. I don't care about the specific implementation. You can worry about that. As long as you adhere to the interface that we've agreed upon, I'll know what to do with them. And I can have a reasonable expectation that they will do the right thing." No that's called Dependency Injection. See, sometimes when we rush to correct people, we miss the fact we may those who are wrong. The Java community has mis-appropriated the term IoC to be a synonym for DI. But DI is merely a tiny subset of what IoC is about. Let's refer to the Wikipedia page (https://en.wikipedia.org/wiki/Inversion_of_control): &gt; In software engineering, inversion of control (IoC) is a design principle in which **custom-written portions of a computer program receive the flow of control from a generic framework**. A software architecture with this design inverts control as compared to traditional procedural programming: in traditional programming, the custom code that expresses the purpose of the program calls into reusable libraries to take care of generic tasks, but **with inversion of control, it is the framework that calls into the custom, or task-specific, code**. Sound familiar? Not a thing about dependencies or constructing objects. Because IoC isn't about that. Here's Martin Fowler, expressing his frustration with the abuse of the IoC term by Java frameworks (https://martinfowler.com/articles/injection.html): &gt; When these containers talk about how they are so useful because they implement "Inversion of Control" **I end up very puzzled**. Inversion of control is a common characteristic of frameworks, so saying that these lightweight containers are special because they use inversion of control is like saying my car is special because it has wheels. Here's how he defines Inversion of Control (https://martinfowler.com/bliki/InversionOfControl.html): &gt; Inversion of Control is a common phenomenon that you come across when extending frameworks. Indeed it's often seen as a defining characteristic of a framework. [...] [When] the control is inverted - it calls me rather me calling the framework, this phenomenon is Inversion of Control (also known as the Hollywood Principle - "Don't call us, we'll call you"). [...] Inversion of Control is a key part of what makes a framework different to a library. A library is essentially a set of functions that you can call, these days usually organized into classes. Each call does some work and returns control to the client. A framework embodies some abstract design, with more behavior built in. In order to use it you need to insert your behavior into various places in the framework either by subclassing or by plugging in your own classes. **The framework's code then calls your code at these points.** There are various ways you can plug your code in to be called. In the ruby example above, we invoke a bind method on the text entry field that passes an event name and a Lambda as an argument. **Whenever the text entry box detects the event, it calls the code in the closure**. Using closures like this is very convenient, but many languages don't support them. Another way to do this is to have the framework **define events and have the client code subscribe to these events**. .NET is a good example of a platform that has language features to allow people to declare events on widgets. You can then bind a method to the event by using a delegate. So... straight from horse's mouth. Unless you think Martin Fowler is a JavaScript kiddy and so he isn't aware of the computer industry as a whole, and what IoC is.
It is a copy of the reference to the list. If it were the original reference, then reassigning it would have "worked" and executing the code would have printed "Bar".
It's amazing, thanks. 
Your description isn't really abstract enough to be useful. For example, I can quite easily force a function to be inlined to operate in the same stack frame. Also, one could argue that pointers are still passing by value since they are ultimately a distinct type. References (e.g. those found in C++ and D) are true pass by reference.
Wow, that's just a great example. 
`document.write`? Hell knows.
I think this covers what you are talking about: https://en.wikipedia.org/wiki/Evaluation_strategy#Implicit_limitations &gt;In some cases, the term "call by value" is problematic, as the value which is passed is not the value of the variable as understood by the ordinary meaning of value, but an implementation-specific reference to the value. **The effect is that what syntactically looks like call by value may end up rather behaving like call by reference or call by sharing**, often depending on very subtle aspects of the language semantics. The reason for passing a reference is often that the language technically does not provide a value representation of complicated data, but instead represents them as a data structure while preserving some semblance of value appearance in the source code. Exactly where the boundary is drawn between proper values and data structures masquerading as such is often hard to predict. In C, an array (of which strings are special cases) is a data structure and thus treated as a reference to a memory area, but a struct is a value even if it has fields that are vectors. In Maple, a vector is a special case of a table and therefore a data structure, but a list (which gets rendered and can be indexed in exactly the same way) is a value. In Tcl, values are "dual-ported" such that the value representation is used at the script level, and the language itself manages the corresponding data structure, if one is required. Modifications made via the data structure are reflected back to the value representation, and vice versa. **The description "call by value where the value is a reference" is common (but should not be understood as being call by reference); another term is call by sharing.** Thus the behaviour of call by value Java or Visual Basic and call by value C or Pascal are significantly different: in C or Pascal, calling a function with a large structure as an argument will cause the entire structure to be copied (except if it's actually a reference to a structure), potentially causing serious performance degradation, and mutations to the structure are invisible to the caller. However, in Java or Visual Basic only the reference to the structure is copied, which is fast, and mutations to the structure are visible to the caller. The behaviors are different, which is why we should use more than call by value and call by reference to describe them.
Alternative options include: 1) Ternary const result = condition ? 1 : 2; 2) IIFE const result = (() =&gt; { if (condition) { return 1; } return 2; })();
Can you pass by reference in C?
If it was pass by value, you'd either have to return a and b, or you'd get a function/method that does nothing but waste cpu cycles (unless the compiler just cuts it out).
Good point. In my case, my narrow view of IoC would be misappropriation by the C# community rather than the Java community. I'm still suspicious though on the apparent broadness of the term though, I mean, I've never heard anyone refer to event handlers in C# as being an example of IoC. How is the term even useful if it's that broad?
Huh. Kind of surprised - thought I'd collected most of the articles in that genre. If you do figure out what article it was, key me know so I can add it to the list. 
The only "tricky" part about it is knowing that objects and their extensions (functions, arrays) are always pass by reference. Primitives (strings, numbers) are pass by value. Then it's just a matter of remembering that an object that carries other objects is only a reference carrying other references. That's why everyone wants to bring immutability to JS. Too easy to fuck with existing objects. 
Ah, I see.
The fact that everyone is confused in the replies to my post proves it's tricky.
Oh god. Tell it I'm in the bathroom or something. I really don't want to talk to it right now.
A reference is a pointer and a pointer is a reference. The only people this makes a difference to are the ones who write asterisks into their code, and they're just confusing the point for pedantry.
In pass by reference languages, param would be a reference to blah, so changing param would change blah.
Clone all the things!
Char? 
Makes sense. I suppose such a broad definition doesn't seem relevant to me because I'm not a framework author, so I don't really have to think about the implications of one way or the other from a design perspective very much, I just use the framework/library however the author decided to write it.
Kind of, the language doesn't actually have references, but you can do the same thing using pointers.
That's actually sometimes a good question though, to find out what the root problem you're trying to solve is. Often the first question people ask isn't the real thing they're trying to solve, and maybe not the best way to do it, so by asking "why" a few times you can find out really what they're trying to accomplish. 
Welcome to /r/javascript Enjoy your stay!
I'm not aware of a char type in JS. Do you have a source?
I'm newbie, can someone explain this? By value, it gets duplicated or what?
Actually there aren't. :( JS is wierd man. TS is the future. 
❤️❤️❤️ TS
Strings are actually immutable references in JavaScript if I recall correctly, but since they behave like primitives, it doesn't really matter.
It's certainly confusing. The key is to mentally differentiate "value type" / "reference type" and "pass by value" / "pass by reference". There's really only 4 different combinations.
too real
One easy way to do this is to draw the background every frame but make it a layer with .05 opacity or something. That way the previous frame's circles will fade out over time.
*throws Ajax in the trash* *hangs head and walks away slowly*
And?
I wouldn't really think of it as a copy. myStringList is a local variable that is initially assigned to a reference of the original list. When you reassign it, it becomes assigned to a different list. Then it simply goes out of scope when the method exits.
thx :) I have managed to make some pretty cool looking things with this!
Imo, it is a great reply to anyone with thick skin. But I can understand if sensitive folks don't appreciate it.
The point is that `myStringList` (outside of `doStuff`) and `myStringList` (inside `doStuff`) both contain references, and that although they briefly point to the same *object*, they are not the same *reference*. I used "copy" to stay consistent with the earlier posts, but yeah, you could just call it "another reference".
OK, but what led you to believe that primitives are passed by reference in the first place?
Maybe it would be helpful to make a 2x2 table with pass by value/pass by reference along the top and value/reference along the left side. Then in the cells put code examples for each using relevant languages. Or more coffee cup diagrams. I'd do it with Paint.NET but I'm in a bar on a Sunday at 12:23 drinking and shitposting on Reddit with my smartphone
Wow, you seriously don't understand why a comment like this was downvoted? Or are you just one of those people who likes to play self-righteous internet warrior and defending innocents from evil downvotes? Pathetic...
use immutable data, then it doesn't matter
It's a great reply to anyone who doesn't need to be coddled and their hand held. I found it more educational and less condescending, but then again I don't worry about "my feelings being hurt being wrong or not understanding."
A picture is worth a thousand words ... ahem not this one though
You can do this in Python: b, a = a, b
/u/LtAramaki seems to have a bad habit of downvoting comments they don't want to deal with, rather than responding. I've noticed several replies directly to him have 0 votes and no response in this thread, comments which definitely contribute to the discussion. Upvoted them all for visibility, lol.
Using a _var_ inside an _if_ is an anti-pattern as far as I'm concerned. This code looks very hard to maintain, at the very least you should be checking whether _fontNameCopy_ is set before using rather wrapping in an _process.env.isTest_ conditional every time. Consider breaking it up into small functions - use of var/let/const becomes less of an issue then.
That exists in modern JavaScript as well, but the way Babel will do it is through transpilation. Writing [a, b] = [b, a]; transpiles to var _ref = [b, a]; a = _ref[0]; b = _ref[1];
Gotcha. Thanks for the update.
Except it IS simple and straightforward. Your implication is invalid.
I take it I had been downvoted?
Why would you need thick skin to learn something new? Why is that a prerequisite? Being condescending in one's post serves no purpose and really just distracts from any point you try to make in it. It's really just immature at the end of the day. You can inform people on things without needlessly bringing them down. The smartest people realize everyone doesn't know everything and teaching others new things is an experience to be relished, not something to lord over "noobs". I wouldn't work with/hire someone who had that sort of attitude IRL.
[The tutorial](https://davidwalsh.name/template-literals) that had the templating syntax used console.log to output results, so I just went with what I remembered would output something in the document. It also used var. I haven't really gotten the hang of the new syntax yet (`const` and `let` was it?) as I am more a php/mysql dev, and attempt JS when I need to. From what you said, I guess I should be using `const` and `let` with anything ES6. 
Logo look blurry on mobile - I'd suggest using a svg with fallback 😊
&gt; Why would you need thick skin to learn something new? Why is that a prerequisite? Nice strawman. I never said that. The fact is, the guy wrote a post that IS informative, but with a condescending tone. You seem to have the belief that the information in the post is useless and the post is a bad one because of the tone he used. I disagree with you. Just because you dislike someone's tone does not mean you should not attempt to learn something from them. Your attitude, that someone who has a bad tone cannot be learned from, is a bad one and should not be encouraged.
Passing a reference by value is passing a reference, yes. However, it is still a copy of the reference that is passed. Very subtle semantic difference. It is not *the* reference. It is a different reference, which starts out referencing the same thing. The subtlety comes in what happens if the reference itself (not what it references) is modified. Go to first principles: A variable is merely a block in memory of extent defined by the size of the variable. It could be in global memory, or stack memory, or a processor register. Depends on the declaration, scope, language and compiler/linker. But it exists somewhere. When you pass a parameter by reference, you pass a pointer to that block of memory. Or the register itself. When the function returns, all changes made to the parameter are preserved. When you pass by value, you make a copy of all of the contents of that block of memory into a new block of memory (or register), and then pass this (or possibly a pointer to this... depends on compiler/language). When the function returns, this copy is discarded. That is all. People get tripped up when the block of memory being "passed" contains references to other blocks of memory. This indirect reference is effectively passed by reference. Pointers are the degenerate case. References (C++, D) are also. As far as inlining a function, you are conflating "stack" and "stack frame". If what you call is a real function and the parameters are actually passed by value, (some compilers don't enforce this with an inline function) then the passed parameters need to be somewhere and they need to be separate copies. They won't be malloc'd in real time. Instead, these separate copies are made on the stack. Whether they are actually pushed to the stack at runtime, or pre-allocated statically depends on the compiler implementation. But for sure, they are on the stack, and they are in a separate piece of memory from the variable they were copied from. &gt;&gt;Also, one could argue that pointers are still passing by value since they are ultimately a distinct type. One could, but one would be wrong. This is what hangs so many rookies in languages that allow pointers. If passed by reference, and if the pointer itself is modified (e.g. to point to something else), then the original variable will end up pointing to something else. But if passed by value, then if within the function the pointer is modified to point somewhere else, when the function call collapses (either return, or from being inlined), the pointer will point to where it was before. 
^(THIS ARTICLE MADE ME INCREDIBLY HAPPY)
or that this is a javascript subreddit and contains tons of people with no formal computer science training and little work outside of a fairly accessible scripting language and nothing remotely near the metal
Yep, you were at a cool 0
Yes, that's what pass by reference is. But when you are doing pass by value, and the value is a reference, you still pass the reference, and a lot of people get tripped up and think that that is "passing by reference", but really you've just passed a reference... by value.
Well, first, consider that the picture is in r/JavaScript. So it should describe JavaScript. JS only has pass by value, so the left shouldn't even be there. What is pictured on the left is what happens though because the value *happens to be a reference* so the cup that is *referenced* by both variables gets filled. I'm a Java guy (saw this and thought it was r/programming originally), so I don't know is JS has primitives or if everything is an object. When you pass a primitive in java, it's value is actually the value, not a reference to an object in the heap, so what happens is what is pictured on the right of this gif (though it's not really accurate because you can't mutate primitives in Java).
I feel the same way. "I'll go read some interesting JS stuff. Oh another article explaining obvious details of a language I've been writing for years. Never mind..." When you want to read interesting stuff about the language, you're better off reading the ECMAScript standards committee's mailing list, or spec proposals, or the TypeScript issue tracker, or anywhere else that engineers are actively building the future. (Those are just a few of the places I go)
I think GHC often passes by reference, although it isn't observable due to lack of mutability.
That's just reassigning values, nothing to do with pass by reference.
...aaaaaand now I want coffee while I program. 
Functionally both that and pass by reference are the same. However in the pass by reference case you don't need to explicitly dereference the value when using it inside the function.
Not the most comprehensive benchmark... You're doing a single search in a relatively small string for a substring that exists once.
What? This is one of the very first things you learn when programming. If you can't understand pass-by-reference/value then maybe you should do something other than programming. This is as crucial to programming as knowing how to run a for loop. Any decent programmer should know up to classes and pointers and a little more. It isn't necessary to know data structures to do most programming but it would definitely help. If you don't know this then you better learn it now.
I hate when people assume they know who is upvoting and downvoting comments. There's literally no way to know.
Functions are Objects in JavaScript
[:-)](https://www.youtube.com/watch?v=OXqyzoY4G2U)
I'm mostly surprised this post got so many upvotes. It's an awful example. It doesn't even make sense in the scope of javascript. If you pass the cup to a function, and then the function does something to the insides (properties) of the cup (fill it with coffee), the original cup is absolutely going to be modified. class Cup { constructor() { this.coffee = 0; } } function fillCup(cup) { cup.coffee = 100; } const cup = new Cup(); fillCup(cup); console.log(cup.coffee); // 100
Yea I was shocked at the overwhelming amount of responses here that laughed off this "complex" idea. It's literally the first thing you learn in CS after for-loops. It's been a while since I did JS but jeez I didn't realize the difference between a CS major and self-taught programmers until now.
Yea I didn't take the gif too literally, I just thought it was a cute explanation, but yea the gif is technically incorrect if we're considering the cup to be an address/pointer and each cup to be a new instance of the original. I think if the responses to the post weren't so obviously out of touch that most people would have had the same initial reaction as I did.
Make something better in every possible way that works in all environments that javascript does and has a zero cost to upgrade, and I'll make it go away.
I must admit I have not done much programming in any of those languages. In C programming "pass by reference" usually refers to passing a pointer.
C can't, but C++ can if you mark a function's formal parameter with &amp;. Pass-by-reference is relatively rare in modern languages.
I agree, but I understand where it's coming from. This is a recurring topic that gets tons of wrong answers so often. It gets frustrating. ... There's a few common security-related topics that regularly get so many wrong and *insecure* answers that frustrate me to no end.
Of course I'm using antipatterns. This is a library designed to use as few bytes as possible when gzipped. It reuses variables and does all sorts of hard to maintain things in order to be both very fast and very small (designed to be inlined on every single page). Putting the let outside the if adds a useless variable to the unminified output for non test builds. Breaking it up into small functions can add 50% or more to the gzipped size.
Everything is always pass by value, fam. What you're actually passing may be less or more explicit tho
Thank you again for your help! I cleaned up the example to make it more clear what I'm trying to do and provided a link to the new example. 
I found this thread on r/popular . What you're seeing is passing interest from the non-coder masses as they click through their list of funny pictures or whatever, without much attention to any one subreddit's tone. This is more reflective of the nature of the Reddit platform as a whole, rather the core community of a specific subreddit.
One option is to keep an eye out for [talks](https://developers.google.com/web/shows/google-io/2016/v8-modern-javascript-and-beyond-google-io-2016) where Google developers tell us about v8 and Chrome and how things work under the hood. Another option is to take a stab at [Node addons](https://nodejs.org/api/addons.html). You'll be writing C++ and interacting with v8's code directly.
I'm not super fan of yarn since npm 5... imho It's an unecessary dependency
Im not 100% sure but i think yarn is still faster (not that much)
That pisses me off so fucking much. Fuck videos with no volume control.
Here's a *second* fiddle that uses some more advanced JS techniques, but might be more what you're looking for: https://jsfiddle.net/x7HVQ/1964/ In this case, each "instance" has its own `startingNumber` and `cancelPressed` variables, so they don't interfere with each other.
Yeah I pretty much only use lodash.debounce
This is described as passing value objects, and passing reference objects.
Please don't try to argue a general case based on limited set of example languages. That's how software designers learn bad habits. Yes, in *some* languages (probably all languages with which you are familiar), you are right by accident, but that doesn't mean you are right in all languages, or at all. &gt;&gt;The pointer is a distinct type which must be instantiated with a value. Note the way that one can pass a nullptr into a function. This is my point. This is why C does not support pass by reference. This has nothing to do with how a pointer is used. True in C. Not true in all languages. I have used languages where the pointer is a distinct type (yes), but without forcing initialization or type enforcement. Regardless of language, modern CPUs use data registers, address registers, and stack... and just about every language worth using allows you to drop down into raw object code and enjoy living dangerously, drive at speed without seatbelts. At which point, having intimate knowledge of the nuances of pass-by-value and pass-by-reference is extremely important. &gt;&gt;Also, your example is stupid: you seem to be describing an incorrect usage of pointer arithmetic: Purely syntactic. My example is just that: an example. The only purpose was to show that there is a very clear difference where you said there was none. It is not an attempt to illuminate a useful or purposeful function. Just that there's a difference for pointers between pass-by-value and pass by reference. Because there is. You said there isn't, and the example shows there is. This isn't the *only* way the difference can show up. It's just one very simple, very clear way. Test: can you figure out a "legitimate" example where the result is different if a pointer is passed by reference instead of by value? If not, you aren't very good, and if so, you owe me an apology. &gt;&gt;With regard to malware: What are you talking about? Buffer overflows? Please give an example, a snippet on godbolt.org pls Nope. Hacking is not something that gets explained to you. It's something you figure out. But hint: it involves "incorrect" usage of pointer arithmetic. 