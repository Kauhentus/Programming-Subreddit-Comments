Doesn't that only fire when the user tabs out of the field?
Im using 7 and i abuse async functions and await. 
Normally people call that feature autosave. Here's how to *actually* do (without resorting to lodash or some other abstraction) var DELAY = 5000, timer = 0 textarea.oninput = function() { clearTimeout(timer) timer = setTimeout(save, DELAY) } function save() { var x = new XMLHttpRequest() x.open("POST", "/save/thingie", true) x.setRequestHeader("Content-Type", "application/json") x.send(JSON.stringify({data: textarea.value})) x.onreadystatechange = function() { if (x.readyState === 4 &amp;&amp; x.status === 200) done() } } function done() {console.log("saved!")} The clearTimeout/setTimeout little dance is what people here are referring to when they say debounce. Basically it waits 5000 milliseconds (5 seconds) and then calls `save`. If you type again before the 5 seconds, it restarts the timer. While technically this is a debounce, the term debounce is often used in the context of instant searches (aka, typeaheads or autocompletion), where the frequency of requests is reduced from for-every-keystroke to every-once-in-while for performance reasons (rather than increased from never to every-once-in-a-while, for data persistence reasons, as is your case) The `save` function is how you send data to the server (via the http POST method, to a url `/save/thingie`, in JSON format). The `done` function is called when the server responds with a 200 status code (meaning the request completed successfully).
Because I was asked to do something contrary to the documentation that I was in fact asked to read, and contrary to ever other solution I could find on the same issue. But thanks.
If you're using Babel (you are using Babel... right?) then you don't need to polyfill.
Anyone?
Pedantic because it is not actually discussing the point of the question. Useful because it is a valuable distinction for where, how, and what your implementation is/is doing.
Not only does this article not contribute anything to any conversation, it's also kind of late to the party. Wasn't it like half a year ago that these sorts of posts were popping up by the hour?
Hmm...just want to make sure I'm following—are you saying that the responsibility to protect against vulnerabilities lies on the server-side? Apologies if I'm misunderstanding, but if that is indeed what you're saying, I think it's a bit of a dated notion and overlooks issues such as dom-based XSS attacks almost entirely. Browsers have increased in complexity and capability, and so have the sites and applications that are being built. We're seeing more and more web applications moving more and more processing onto the client and off the server thanks to the popularity of things like Angular, React and Ember (for example). As we do, attacking this client-side code becomes much more interesting. I'm not saying that you don't need to be sanitizing requests, etc on the server-side—that absolutely needs to be done. But you can't ignore the importance of locking down your client-side code as much as possible either. It's a critical layer of security.
Yeah this is what i was after. Anyone know the name for this, if not debounce? (today is first time i've heard that term... )
I love functional programming, so reading this I wanted to share the recursive version: const longest = xs =&gt; xs.length &gt; 1 &amp;&amp; (xs[0].length &gt; longest(xs.slice(1)).length &amp;&amp; xs[0] || longest(xs.slice(1))) || xs[0] const main = () =&gt; { const test = 'hi everybody how are you doing today'; const longest_length = longest(test.split(' ')).length; // "everybody".length = 9 console.log(longest_length); // 9 } main(); With this approach you can get the longest of any kind of collection meanwhile they have property called 'length' which is a function that returns a number. If you don't care about the actual string, but only the length, then the function ca be rewritten in this way: const longest = xs =&gt; xs.length &gt; 1 &amp;&amp; Math.max(xs[0].length, longest(xs.slice(1)).length) || xs[0] which, as you see is even more concise. Or even if you don't want to process arrays but strings directly: const longest = str =&gt; str.split(' ').length &gt; 1 &amp;&amp; Math.max(str.split(' ')[0].length, longest(str.split(' ').slice(1).join(' ')).length) || str.split(' ')[0] But this is not the most efficient way because we are splitting several times the string, so we could improve performance by reducing "elegance??" const longest = str =&gt; { const words = str.split(' '); return words.length &gt; 1 &amp;&amp; Math.max(words[0].length, longest(words.slice(1).join(' ')).length) || words[0] } 
http://code.nasa.gov/ uses the Polymer team's `iron-list` which is very solid. Extra: [Somebody on Twitter](https://twitter.com/coderitual/status/817471054381719552) added a transform to make a really nifty visualization on how it works.
Yea, don't get me wrong - of course if there are things we can do client-side to mitigate attacks, close up perceived vulnerabilities, etc, we should absolutely do that (and we do often in our work =&gt; we've outright banned the use of eval for example). However, because the code is in the client side's control ultimately, and because requests to the server don't even have to come from the app delivered in the first place, there's really no way to get around the concept of the server having to implement all protections (and even duplicate some protections the client side handles up front). It's the same concept of why people can cheat on multiplayer video games; modify local code, spoof that all is well to the server, etc. The only way to really prevent those concepts is a robust server-side verified and controlled process. Going back to my original point, I was trying to hit on the idea that this notion that JS libraries are contributing to vulnerabilities via outdated code, etc is really misleading to the general populous.
This almost exactly echoes my experience, except that we're experiencing this today. We've had so many things we've been the first in... People keep recommending the Slack channel, but for anything beyond the basics you'll either be met with silence or with people saying they think there's no answer for that (yet). And that just doesn't work when you're working with so much (currently) custom stuff, i.e. things that haven't been standardised yet and probably never will in this form. As an example, if you want to do unit tests (where "unit" is not that small a unit, and which is at least as cumbersome in Polymer as it was in Angular.js), the only way to measure your code coverage is by using a web-component-tester plugin made by someone who hasn't used Polymer for over a year and a half and thus is no longer maintaining it.
This is true, but it does say a lot about the Polymer philosophy.
A JS library can definitely contribute to that. The webserver is just one of the inputs to a modern day JS app. As a trivial example: modern JS app often parse the URL (e.g. for routing purposes). This is input that isn't necessarily provided by the server. If this is done incorrectly then this can easily lead to XSS vulnerabilities that a web server can't protect against. 
Gotcha. Thanks for the clarification. &gt; there's really no way to get around the concept of the server having to implement all protections (and even duplicate some protections the client side handles up front) Oh, this is true. :) &gt; I was trying to hit on the idea that this notion that JS libraries are contributing to vulnerabilities via outdated code, etc is really misleading to the general populous. We agree, apparently, on just about everything but this point. :) Using old and vulnerable JS libraries unnecessarily leaves a potential entry point. True, it's _possible_ the server will catch most of these issues, but why risk it? Hardening the client-side code makes it that much harder for an attacker to be able to exploit your application. Organizations trying to secure their app/site already have a tough enough job without making an attackers job of identifying and targeting exploits easier for them. FWIW (and I know this isn't something you were arguing against) while the dated use of client-side libraries is what the initial paper is about, that problem is equally true of server-side packages and libraries. Not keeping things up to date is a pretty common, and unnecessary, problem—both on the client and server.
Agreed 100% with everything you just laid out. I'm definitely for closing all vulnerabilities in any piece of an application, whether it server/client/engine/etc.
I'm on my phone so I can't write an extensive reply, but in short: - URL fragments never get to the server - The server may not actually know which URL are safe to handle (this is more often than not the case) 
I like to think about this kind of stuff often + am always looking for neat little things to build. I love coming up with custom visualizations using d3.js, that's usually what my mind goes to first. Other things I've thought of are making an 'easy' wrapper for regex since a lot of people get caught up with it, making a web scraping framework, making a purely server rendered framework, creating bots as passive listeners (or with commands!) for various mediums (twitter, telegram, facebook...) and creating a front end to display the information (maybe with that server rendered framework =p), reading through the source code of your favorite framework and actually understanding how it works... Just a few things off the top of my head! Some frameworks and tools that I love: Regex, d3, react, es6, graphQL (I wrote a guide, check my recent posts if you're interested!)
Correct, I should have said DOM. Everyt component is a DOM node that you can manipulate either via javascript API or bindings. That approach is as close to web platform as it is. You could use JSX/vdom's whatever with polymer or other web component libraries - nothing prevents you from doing so. Thats the beauty of it.
OP might have meant it in the sense of "overuse", just a guess.
That's what `await` does. It's essentially sugar around `Promise.resolve()`. async function () { const foo = await 5 return foo } Is translated into: function () { return new Promise((resolve, reject) =&gt; { const foo = Promise.resolve(5) foo.then(resolve, reject) }) }
if by contrary you mean exactly the same as, but phrased to invent a difference to complain about create a task named default. define a task named default. implement a task named default. generate a task named default. all the same thing
1. Write a function that combines the properties of 2 objects, leaving the original objects untouched 2. determine if 2 objects are deeply equal w/o === 3. Create your own implementation of a hash table 4. Explain how the event loop works, when items are pushed to the call stack, how web apis play into that 5. Implement basic underscore functions for arrays and objects such as forEach, map, reduce... Some of these you might consider esoteric, but even so I think understanding things at a bit of a lower level really helps with understanding why some things happen the way they do
Ah not at all, no worries - always good to learn and engage in conversations. I get these concepts, I'm just not certain how a JS library introduces vulnerabilities that plain JS itself simply would not also introduce in these scenarios. If you're saying code can be injected by hacking a user's platform/etc then we're deviating significantly from the original prompt of this conversation. In that instance I would say the vulnerability than lies with whatever portion of the platform itself was hacked, not the implementation of the JS specification.
&gt; are custom elements faster [...] Comparable if browser natively supports them (Chrome, Safari TP - http://caniuse.com/#feat=custom-elementsv1). Slower when polyfilled (most polyfills uses Mutation Observers) 
[Here is an example](http://blog.portswigger.net/2016/01/xss-without-html-client-side-template.html).
* higher-order functions: http://codepen.io/Keale2/pen/yNZxbZ * these are fun &amp; useful: http://reactivex.io/learnrx/
Hmm I'm really trying to follow here, but I'm still not grasping in this example how this is the library's fault. In the example, it is assumed somehow that a hacker/etc would inject JS/HTML on the page (or just literally the user would inject it themselves), which could then be used to manipulate the JS client-side of angular and further execute unsafe code that angular otherwise thought was "safe". This is the same concept as writing JS on the page to manipulate other JS... Which leads me back to how this could expose a vulnerability on the server side and/or further hurt any users other than the individual locally invoking this concept (whether it be their own intention or injected because the browser/engine/etc was compromised). Angular devs even responded to the issue with "The angular team doesn't see the sandbox as a security boundary.", which means they are aware of the fact that client-side code has an innate vulnerability to it.
RxJS is really amazing for stuff like this.
JavaScript is not limited to client-side browser.
I love vue.js at the moment and I'd recommend everyone have a go at it. There are some great video tutorials on Laracasts for a jump start in a few minutes. Leading on from that I had a big array of data of a few hundred items and thought it would be cool to paginate it using vue. It got really interesting to try and make the "Google" style pagination - so if there are 20 pages and you show links to 5 pages at the bottom of the screen: - show only pages 1-5 and a "next" link if you are on page 1, 2 or 3 - on page 4 the pagination should show pages 2-6. On all higher numbers just show the current page +/- 2 until... - on pages 18, 19 or 20 the pagination should show pages 16-20 It's simple enough to get your head around but if you work in a messy way before long your code will be utterly hideous and it's a cool little coding kata.
Inside of the jQuery ready function or just this alone?
This is awesome :) 
The *how* is the vulnerability imo. If the JS is executed in a compromised environment, then I don't view that as the JS's fault and/or a vulnerability. Maybe we just view these philosophically different.
what kinda bandwidth does it get? 
After getting the Inferno dev on board, this is another great step in my opinion.
So, let's see- I ask for some advice, you condescendingly ask me to "read the documentation" under the assumption that I hadn't, then, in your infinite wisdom, end up giving the **wrong** suggestion, anyway, and refuse to acknowledge the fact when it's pointed out. Not even an "oh, sorry, I didn't know that!", yet YOU feel you have the right to get pissy at ME? Jesus. Your suggestion, the highest rated comment in this thread, upvoted by folks who understood the documentation as little as you did, was *wrong*. Just get over it, and move on. &gt; if by contrary you mean exactly the same as... No. I mean contrary, as in, exactly different. I needed to get rid of an accidental */ character. That was all. Re-read your suggestion, and tell me what "create a task named default" has to do with pressing backspace twice in Atom. RE: 'define' vs 'create', I have zero way of reading your mind. All I had was an initial comment that **clearly** suggested I ''create a task named default'' that -- if I were to have done so -- would have been 100% at odds with what the documentation was in fact telling me to do. I chalked up the difference in wording as referring to two separate things, as I thought you in fact had read the doc, yourself, and assumed I'd been the one who had missed something. I apologize for my error, as I quickly realized the error was in fact yours. And do not PM me with more "advice", as your entire comment history is full of people calling you a dickhead. I've gotten along just fine with the vast majority of programmers, as they have an expertise that I lack. By contrast, *you don't even have a legitimate answer to my queries*, just a hard-on for masochism, I guess, when you're out-maneuvered by folks who see your childishness for what it is. Stick to JavaScript, as you suck at dialectic. This is the final time I am addressing you. Goodbye.
Isn't the officially supported way of using React through Webpack? Why switch to Rollup? Is Rollup simpler or something? If so, this just means learning yet another library or framework.. :(
React's usage of Rollup is perfect for building low-level libraries, such as React or Inferno. Using Webpack to consume React shouldn't change, they both solve different problems in different ways. Check this Twitter thread for some context: https://twitter.com/luisrudge/status/839998153407496193
&gt; are custom elements faster than the div soup I have now? slower? Slower in IE after I polyfill them? (right now everything works in IE out of the box). Hopefully should be ~ as fast. If you have a lot of them, it might be worth worrying about. &gt; often these elements get included via ajax. So they each have two JS loops which seek out the elements on the page, create an object in the window, and add some listeners. One loop that runs after "DOMContentLoaded" and the other one as a mutation observer. Does converting to a custom element remove this requirement? Yes. You can have a `constructor` to set up additional properties on your custom element. The `connectedCallback` and `disconnectedCallback` functions tell you when your element enters / leaves the DOM. One thing to note is that you can't add attributes from a `constructor`, but you can do other things like attach listeners if needed. &gt; Some of these elements have blur listeners. Only I couldn't get it working right with the div soup, so I cheated and put a window click listener that determines what was clicked and if anything needs to be done. Can you do this with custom elements? does it solve some of the blur issues? Not sure exactly what is the issue you are running into / trying to solve. It doesn't look like any of the elements in your example have a tabindex, so they will not be focusable. Also note focus is not a bubbling event, so if you add an ordinary listener to an element, it doesn't trigger if the element gaining / losing focus is inside it. You can use the `useCapture` param (e.g. `el.addEventListener('focus', callback, true)`) to listen for changes to focus on an element or a descendant. &gt; How do you convert div soup into an element?? You want to have a custom element, say named `x-myselect`, that takes some children and puts them in the right place. You want to have a [Shadow DOM](https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom) that puts those children in the right place. The first thing to do is create a shadow root and then give it the right structure. Just for the sake of example, this could look like the following with pure JS: class MySelect extends HTMLElement { constructor() { super(); const shadowRoot = this.attachShadow({mode:'open'}); shadowRoot.innerHTML = ` &lt;div class="head"&gt;&lt;/div&gt; &lt;div class="optionsWrap"&gt; &lt;div class="optionsInnerWrap"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; `; } } customElements.define('my-select', MySelect); now, when you have: &lt;my-select&gt; &lt;div class="option"&gt;&lt;/div&gt; &lt;/my-select&gt; the option will appear inside the custom element where the `&lt;slot&gt;` is. You can read more about all the cool things slots can do. &gt; if I wanted to extend the normal html element like select above, would this be possible?? for instance the out of the box option element is not style-able. but if I simply make it into a div then it is. would something like this be do-able? The old custom elements proposal allowed you to, but not all browsers have agreed and it does not seem like it will happen at the moment. &gt; can you use external style sheets to style the div soup inside the element?? for instance .optionsInnerWrap { padding: 10px; } You can't have external stylesheets target component internals at the moment. You can use CSS custom properties to allow for some styling. For example, in your custom element, you might have: &lt;style&gt; .optionsInnerWrap { padding: var(--my-select-options-padding); } &lt;/style&gt; And from the outside, you can do: .padded-select { --my-select-options-padding: 10px; } Note that you need to wire up everything you might want to allow the outside to style. There is a [proposal to allow exposing internal elements](https://github.com/w3c/webcomponents/issues/300) but it has not been implemented yet. I have created a [treeview custom element](https://github.com/sparhami/x-treeview) in raw JS in the past, which does some stuff similar to what you want to do. Might be worth looking at for actual examples of some of this stuff.
Tree shaking wasn't working in the Webpack 2 release, they're working on fixing it though https://github.com/webpack/webpack/issues/2867
WebVR https://aframe.io
I work in about 5 repos a day, all closely related (user friendly docs, code, reference code, notes, and settings). They're in a folder structure with the farthest path being about 4-5 cds away. I could use push/popd, or even make a little zsh script. Would this tool be helpful for me, or should I spend the afternoon creating a script that serves my needs? 
use them where a synchronous function would be sufficient? 
They have modular `es6` modules too.
&gt; RE: 'define' vs 'create', I have zero way of reading your mind. You don't need to read minds to read words, it turns out. Besides, you brought this fake difference up, not me. What does reading my mind have to do with anything? . &gt; Re-read your suggestion, and tell me what "create a task named default" has to do with pressing backspace twice in Atom. I confess, it is actually kind of entertaining to watch you keep suggesting that the problem was that you needed to remove two characters, which you keep calling one character, and in the process keep missing what's being said to you because you see a different thing. You'll catch on soon enough. Enjoy throwing around a bunch of insults, then telling people how well you get along with others. Best of luck to you. `:D`
Hi /u/Stephcraft, this post was removed because /r/javascript is not a job board. If this is a call for open-source help, you need to share the project's homepage.
Yes please do this. Kendo seems good an first but it's hell to maintain. We are trying to get rid of it but there's no abstraction so it's hell...
an apology was what the moment called for long ago. there's no need to be as angry and aggressive as you were, even if you are right.
You'd have to have some other browser-specific mechanism. Simply linking to a js file, even on a cdn, is no guarantee the source of that file is the same or what is expected.
Debounce is the right term. It's actually a term from physical circuits, where you activate a circuit by moving two pieces of metal together. Well, metal actually bounces a tiny bit when it makes contact, causing the circuit to flicker back and forth a few times before staying on. If you don't want the circuit to flicker, then you need to "de-bounce" it, by ignoring it turning on until it's been on for longer than a flicker. Here, "on" is replaced by "the user isn't typing". So, here you debounce by ignoring that the user stopped typing until it's been longer than the time between keystrokes. Throttling, by contrast, means limiting how frequently something runs. So, here, it would mean saving the text every five seconds even while typing. Which is actually probably a better idea than the approach you requested - if the user types for 30 seconds straight then you probably want to be saving partials along the way. /u/lhorie's code modified to throttle rather than debounce: var DELAY = 5000, timer = null textarea.oninput = function() { if (timer === null) { timer = setTimeout(save, DELAY) } } function save() { timer = null var x = new XMLHttpRequest() x.open("POST", "/save/thingie", true) x.setRequestHeader("Content-Type", "application/json") x.send(JSON.stringify({data: textarea.value})) x.onreadystatechange = function() { if (x.readyState === 4 &amp;&amp; x.status === 200) done() } } function done() {console.log("saved!")}
Using [Switzerland](https://github.com/Wildhoney/Switzerland) you can achieve this slightly more elegantly, as in my opinion using `class` directly to wire it all up can be somewhat cumbersome: import { create, pipe, path } from 'switzerland'; import { vars, include } from 'switzerland/middleware'; const css = () =&gt; { return { mySelectOptionsPadding: '10px' }; }; create('my-select', pipe(include(path('css/my-select.css')), vars(css), html(() =&gt; { return ( &lt;div class="wrap"&gt; &lt;div class="head" /&gt; &lt;div class="optionsWrap"&gt; &lt;div class="optionsInnerWrap"&gt; &lt;slot /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); }))); Of course it all comes down to personal preference. The proposal for exposing custom internal elements is also looking promising, as it's something I've long considered to be a must for web components, as otherwise your CSS needs to include CSS variables to define the hooks that users can override.
Addy Osmani wrote an orielly book on backbone with a section on marionette that he's posted fo free! Also, check which version your company uses, my company still uses marionette 1.8.8 :/ https://addyosmani.com/backbone-fundamentals/#marionettejs-backbone.marionette
Triggers everywhere
please do sit on your ivory tower and not elaborate and instead try and make yourself look smart :-) Here's my stance. `create-react-app` uses Webpack, which is **a** officially supported way of using React. Facebook themselves have mentioned that they used Webpack in their origins of React story. I knew Rollup supported tree-shaking, but I was under the impression Webpack 2 did too (apparently it's broken right now) I've used Rollup before, but it's always been webpack for large-scale apps. Rollup never saw much traction from my POV. I falsely assumed that this would knock on to end-users (mainly because it was late when I made that comment) &gt; So much misunderstanding it's unreal. Does not add to the discussion and does not educate the person you're saying is misunderstanding, it's just a way of insulting the person and make yourself feel superior.. don't be an asshole. 
Think about HTML like a raw meat, CSS is herbs and spices, but JS is like bbq, tongs, gas and other tools to make a good steak (including weather). They are all closely related. If you're willing to jump into webdev you'll find that js is as common as water in your house.
Compare it to https://github.com/hyperapp/hyperapp Becomes ridiculous then. Hyperapp is basically React + React-Router + Redux + React-Redux + React-Redux-Router and weighs like 2 kilobytes
It does work, but in some situations (like importing a commonjs module, importing a module that is a complex re-export, and some other small edge cases) it isn't fully working.
do this 100% -&gt; https://www.codecademy.com/learn/learn-html-css then this 100% -&gt; https://www.codecademy.com/learn/learn-javascript And honestly I would recommend a much less confusing and standard technology like C# or python where you can learn good OOP programming patterns and learn to write structured programs. The javascript ecosystem is a real mess compared to other more structured ecosystems and you will waste 99% of your time trying to connect libraries and build tools and compilers and the next cool thing together just to make simple apps. I wish that was the advice i was given 5 years ago when i started.
It's only a security issue if they can affect other people. 
Human interaction is the security issue.
Yes
C# is, essentially, Windows only which is antagonistic to the Unix-based web. It would be far better to learn any other language.
I've heard this advice a lot. Python is a beautiful first language to learn. That's fine, but it's not practical. Python represents some fraction of just the back end of the web. JavaScript is the whole front end, and a rapidly growing fraction of the back end. If you want to build websites, start with JavaScript. Vanilla JavaScript. With vanilla HTML and CSS. Then add some toys. Then do as close to vanilla JavaScript as you can get on the back end. Then add some toys there. Then you're a full stack developer without wasting any time. 
You can include it in e.g. HTML. But do you include it in JS files that are rebuilded by webpack (like `import 'vendor'`)?
Are you running webpack in watch mode? It should only rebuild chunks that have changed after startup (always builds the whole thing to begin with)
No, the only reference is in html
Facebook don't use Webpack. They have a custom packager for both web and React Native. 
This might be helpful: http://prog21.dadgum.com/23.html
essentially, meaning not really. with mono and .net core you can build C# apps and run them on any server. and with Xamarin you can build sweet C# android / ios / windows / mac / linux apps
Javascript is the opposite of structure. Be careful. I say this as a fullstack Javascript senior developer working professionally with it 12 hours a day. Wish i'd learnt proper programming elsewhere first.
definitely! Javascript is fun and not to hard. Learn some basic html and css first. Then transfer to JS: [eloquent js is a good place to start](http://eloquentjavascript.net/) If you learn javascript, you can basicly do it all, front end, back end, desktop (with electron)
How about something completely different - but going far deeper? I recommend this short(!) and of course free course on mitochondria: https://www.edx.org/course/cell-biology-mitochondria-harvardx-mcb64-1x How they create a proton gradient (complexes I..IV) by quantum-tunneling electrons to oxygen in many steps (safely, if you'd do it at once it would be uncontrollable) to oxygen. Then they use that gradient - which across the membrane has an electrical field strength equivalent to the power of lightning in a thunderstorm - to synthesize ATP, the molecule that powers *everything* in all life. This isn't just human biology, this goes back to 4 billion years ago, this is what has powered all of life since the beginning. I think it's worth spending a few hours trying to comprehend what makes *everything* that lives "tick". While mitochondria only exist in eukaryotes, the exact same principle (create a proton gradient) is used in archea and bacteria. Or if you want to combine Javascript and biology, the edX course "Nature in Code: Biology and Javascript" is very well done: https://www.edx.org/course/nature-code-biology-javascript-epflx-nic1-0x I took it just for the biology concept simulations and found it very valuable despite not caring one bit about the Javascript learning aspect of it.
&gt;It's only a security issue if they can affect other people. In other news, the same researcher confirms that water is indeed wet. 
htmlpurifier will remove js from inline stuff too? in that case there's little they can do to be evil, though maybe they could include css animations and the like to mess with your site styling or be annoying when someone views their post.
That's a great ELI5!
If you're on a Mac or Linux machine, you might want to checkout z instead of bitcar for your purposes. https://github.com/rupa/z ... brew install z on a Mac.
Yes but, just because you can, doesn't mean you should or that you would want to. In order to run C#, as you point out, you need to install non-native software just to get it to compile and run. It would be far better to stick with native tools instead of what are Microsoft related products.
&gt; C# is, essentially, Windows only was
sorry, I am new to reddit, but where do I post it then ? 
We're running 2.3.x, so still not most up to date. Thanks for the link!
Seriously. I like the Radio module though, but it's made me appreciate newer frameworks already
`Sure, you can Promise.all(), but what if you don't want all promises at once, but one at a time?` Promise.reduce?
Definately learn vanilla backbone first. The good thing you'll find is that whilst backbone is awesome, it's not *that* big. I learned it in about a week. Once you're that far marionette will just slot right into your understanding. 
I'm on a Windows machine running cygwin
I did hear the language is extremely loose from reading the introduction of a book about it. Never really got to see how that was, though.
You know you can construct an array containing one promise, and Promsie.all(newArray) to wait on that one promise, right? EDIT: no need to use a non-native Promise.reduce method.
Section 4) Sources is full of great stuff http://blittle.github.io/chrome-dev-tools/sources/restart-frame.html
This is very anecdotal and I'm not expecting React to do the same, but we just switched over Redux to do the UMD builds with Rollup and dropped from 10,738 to 5,827 bytes. Scope hoisting is pretty awesome! https://github.com/reactjs/redux/pull/2283
It IS only bits and pieces... :-) it lacks a lot of stuff, hence why Marionette and all the plugins. It's not that hard compared to today's frameworks like Angular
Cool So bad you don't have enough comment karma for [r/WebGames](https://www.reddit.com/r/WebGames/) edit: redditor for 9 years O_O
But what does that have to do with any of this?
Can your speaker output it? Or perhaps mic can't receive that?
That's like saying you can write a webserver in Fortran; its true, but most sane programmers would run from a programmer suggesting it.
It will take you a very long time to exhaust your uses of JavaScript. Yes you start off learning HTML, and then CSS, and then vanilla JavaScript, but after that you learn jQuery, React, Angular, Backbone, a host of frameworks for working with UI. Then you learn nodejs and learn how to make a server from practically nothing but dust. Then you learn about npm and the CRAZY tools for just about every situation at your finger tips. Then comes Electron and you are free to develop on the desktop! Top it off with some MySQL and MongoDB training and you can do most application development fields with just this one language. Except in cases where you need calculations or a system language (like OS development or high level gaming) JS can take the roles of PHP, C#, Java, Python, and C++, the other common langages. You arent hamstringing yourself by learning JS. And you can build almost anything with it.
Oh true.
Next installment in the series - this Sunday - I will.
JS is full of structue, just not at the language level. For instance, other languages build-in type-checking, but JS does that (when needed) with unit tests, or with an extra tool like Flow. It is important to understand the larger JS ecosystem and not just use vanilla JS, and its important to learn proper programming practices of course, but people can learn more about all that once they master the basics. If you want structure I'd highly recommend leveraging a good framework (Angular, React, Vue, etc.) But only after learning the basics first.
Tree shaking with Rollup is far from perfect either though. Is Webpack's worse?
If you want to build things in the browser, JS is the best choice to learn first. You can pick up the HTML and CSS along the way. I'd recommend http://eloquentjavascript.net/ and https://www.codecademy.com/learn/web to get you started learning. 
"or PHP" Nooooooooooooooooo!
Java for beginners? Uhm ... no. Python might be okay but it's syntax differs from most other languages (indentation as syntax element). JS actually is a pretty good language to learn. Just don't try to do tricky stuff with it because then it will become weird all the time.
Honestly, not really. It's a fine language to program in and it's easy to pick up, but you're going to learn a lot of bad techniques if it's your first foray into programming. I'd recommend starting with a stricter and more abstracted language like java, python, or ruby. The exception is if you only care about web development. If that's all you want to do then JS is the way to go. 
But those are all quite easy to grasp, and to find info about, that they are really just a minor nuisance for someone who is just learning how to program. Anyway, whoever is only learning is not really going to run into issues that you name until they are ready to delve deeper, preferably with another language... And another big benefit for JS beginners is that there's no huge standard library, so there's not that much to learn really...
In all honesty yeah, but not for the reasons you might expect. They have similar issues in many ways, webpack is still fumbling on some of the re-export stuff that rollup has down pat, but rollup's big claim to fame is that they have MUCH less overhead per module compared to webpack, and a lot more configurable options WRT module stuff.
&gt; here's what i was talking about by the way: You might want to read your original comment, where you made no commentary about network time overhead. You were talking about setup time. Explicitly. Repeatedly. I suppose it's possible that you didn't realize that the time before a function is able to process a request is meaningfully different than the frontispiece time or the network round trip time, but they are in fact critically different. Here are two of the various examples. When I explained to you the difference between cold call and hot call setup time, you did not respond to point out that that wasn't what you were talking about, and engaged directly on the topic. &gt; &gt; there may be a high likelihood of requests encountering the 200ms setup. &gt; &gt; I want to use it, but if the 200ms setup is still a common problem . &gt; here's what i was talking about by the way: &gt; &gt; (link to some rando having problems nobody else has) &gt; &gt; (silly bar graphs telling you something is slow with no defined measurement, made by someone trying to sell you an alternative, which say 200ms even though your first link said over 1200) &gt; &gt; (third link which now says it's 700, and points to your second link without noticing that that says they're wrong too) Your examples vary by 6x in claim, and still you manage to believe all of them. And later you go on to make numeric claims of your own which don't match any of them. Compelling stuff. To me, this seems like holding up web pages that say the average American weighs 60lbs, and also ones that say 360lbs, and believing both. . &gt; Because of 2 required SSL handshakes Nope. . &gt; API gateway adds 200-300ms of latency None of your links make this claim. One says 150-200. One says 750. One says 1200. You pulled this number out of thin air. 150 is reasonably fast. As a matter of course, my overhead with API gateway in `us-west-2` is less than ten milliseconds, as I already told you. I also told you how to go measure it yourself in less than ten lines of code. But instead you googled up results with no replicability, from not trustworthy sources (one guy asking for tech support, one commercial competitor, and one guy hello worlding for the first time under a third party project,) and tried to tell me to take them seriously. And then you gave unrelated numbers that appear to have come from thin air. . &gt; Is there any other way to make a public API out of lambda? Yes. Three others that I'm aware of. Probably many more that I'm not. . &gt; API gateway adds 200-300ms of latency in front of requests until you start doing 100+ requests per second No, it doesn't. I generally get sub-10ms overhead from API Gateway, and I don't even get 100 requests an hour. . &gt; It's not a place for javascript startups (which ultimately dominate the space) to go start, Says you. There are literally thousands. TJ Holowaychuk alone has more than half a dozen. I've got four and I'm building a fifth. . &gt; javascript startups (which ultimately dominate the space) lol . &gt; Most are deep into the scaling stage of their startup before the latency API Gateway brings makes sense. I'd ask you for the data supporting this belief, but we both know you don't have any. . &gt; My hunch is Not interesting. . &gt; I'm not the only one worried about this. That's nice. The rest of us just measured it, instead of believing a collection of contradictory things they googled up, realized it wasn't a problem, and moved on with life. . &gt; A little digging shows people everywhere are apprehensive: I really don't care if people post that they're apprehensive in public. I don't know why you think anyone should. Of course, if you bother to look at these two new links, you realize they're just as not useful as the other three. The first is a guy complaining that * the Lambda documentation isn't very good * true * that they think the approach in Lung's python tutorial takes too many steps * who cares? don't do it that way * that Lambda error handling is bad * false, it's actually amazing * and that "it's a building block, not a tool," * whatever the hell that's supposed to mean. And on those grounds, they don't think it's ready for prime time. Whoop de doo. This is what you're making engineering decisions on? What's really weird is that instead of linking directly to the article, you linked to a Hacker News comment thread where basically everyone is saying "dude that's not true, here's how we do it and it's actually really easy." The second link is to a discussion about whether or not to use API gateway for their lambda function (which I don't think you read, because it speaks very positively of Lambda, and the core premise of the thread answers one of the questions you asked later.) So, again, ***compelling stuff***. . &gt; ...So the API Gateway path is a problem in need of a solution. No, it isn't. You just don't understand it. . &gt; I'm looking for these indicators to turn green That's nice. . &gt; And perhaps API Gateway isn't needed. I'm looking forward to finding out. Then read your own links. Or the manual. Just to underscore, Lambda came out in November of 2014, public facing from day 1, and API Gateway came out in September of 2015. But I'm sure you have some more yelling, and some more non-credible tech support threads to shore up your no-experiment fear. Again, you almost certainly could have tested this yourself much more quickly than you wrote that post.
&gt; W3schools Oh god no. Stay as far away from that website as possible. And when you google problems or want documentation/reference, click on the developer.mozilla.org link, not the w3schools link. 
HTML and CSS first. Then JavaScript.
You know you can dance with hot chocolate if you're careful and agile enough, right?
Again, I'm sorry to say you're missing key details and the overall essence. I specifically suggested to go to page 2 of the AWS thread: https://forums.aws.amazon.com/thread.jspa?threadID=225458&amp;start=25&amp;tstart=0 search the page for "negotiate 3 SSL handshakes" and "per second", and read what "Bob" from AWS has to say. The hacker news link had nothing to do with the documentation issues. I dont care about that and I totally agree with you. It's a long thread, and i should have been more specific about that thread given its length, but you will eventually find other people troubled with latency as well. The github link clearly has serverless folk concerned about latency. But in short, you're doing the assholish stuff again. I wish I didn't have to use that term, but there's no other way to describe. ..So no, lambda + api gateway won't be quick and easy to setup. Since when is anything on aws?? Not for me based on the patient deliberate way I work where I'll research and master many related technologies/tools, and if it's because I'm a shittier engineer than you, I--or anyone--doesn't deserve to be treated the way you're treating me for your perception that I'm not as amazing as you seem to think you are. The latter half being my perception of how you perceive yourself. And that's the end of the story. But on top of that you're likely wrong, you didn't follow directions, the meat was on page 2, please read what Bob had to say in these 2 blurbs: ---- Re: AWS Api Gateway latency problem. request takes around the double Posted by: BobK@AWS Posted on: Jun 27, 2016 1:01 PM in response to: hectorg87 in response to: hectorg87 Click to reply to this thread Reply Hello: I wanted to share some findings and hopefully address some of the questions related to customer viewed latency when using API Gateway. As has been noted before, API Gateway creates a CloudFront distribution for each customer API. This has many benefits for active APIs such as your clients will connect to a local CloudFront POP then be forwarded to the API Gateway servers. However, for inactive APIs, particularly on the first call, it does add additional latency. This is due to the fact that in order to secure your API call, API Gateway enforces SSL in all of its components. This means that if you are using SSL on your backend, that your first API call will have to negotiate 3 SSL handshakes: 1. Client to CloudFront 2. CloudFront to API Gateway 3. API Gateway to your backend It is not uncommon for these handshakes to take over 100 milliseconds, meaning that a single request to an inactive API could see over 300 milliseconds of additional overhead. Both CloudFront and API Gateway attempt to reuse connections, so over a large number of requests you’d expect to see that the overhead for each call would approach only the cost of the initial SSL handshake. Unfortunately, if you’re testing from a web browser and making a single call against an API not yet in production, you will likely not see this. We will continue to investigate ways to improve the performance of API Gateway, including, but not limited to, increased connection reuse and making CloudFront optional for APIs that don’t need it. Regards, Bob ---- jamborta2: Unfortunately, while cannot give you an exact number, you will not see any significant connection reuse until you approach closer to 100 requests per second. API Gateway as originally designed was optimized for high throughput APIs. As has been mentioned in numerous previous posts on this thread, we aware that this continues to be a pain point for many customers and are actively working to address the performance with lower throughput APIs. Regards, Bob ------
Then when you want to land a job, learn a framework.
regarding your your top words about how i'm not being specific enough and various semantics: it is you who missed the essence of my concern--and it's the essence a good tech advisor should always be looking for. it wasn't about which precise part of the chain causes the latency, just that it's there and it's a problem, regardless of correct terminology the person submitting the "bug" might not know. it's obvious to everyone but you. you made the rookie tech guy mistake of focusing on precise details, before seeing the forrest. it seems you are extremely anxious to share your knowledge of the ins-and-outs of a lambda setup. i didn't care if it was time to setup the function, network time within the api gateway, some sort of combination of both--i just wanted to know if others had observed the latency, and then holistically get to the bottom of it. Skipping a step and pre-constraining the problem obviously was not the stage I was casually approaching the problem from. That's my perception at least, and I think a common perception many people would have of a casual reddit question. You yourself know I wasn't getting too technical--I'm not sure why at one point you essentially condemn me for not being technical enough and than at another point perceive I'm technically knowledgeable of Lambda and similar services that I would make such precise distinctions. It's contradictory. In short, you should have known I wasn't drawing precise lines and distinctions, and it's clear to many, but I guess not you. as far as setting it up being simple, it's not. it's known for taking a lot of work, and perhaps your an AWS genius, but more than likely even you, like everyone else, have devoted many hours to getting to a point where you can produce the sort of benchmarks you claim i could setup in minutes. Since when is setting up stuff on amazon easy the first time!?? it's also a bogus thing to claim--u dont know my skill level. how are you going to claim without a doubt that it's faster for me to set it all up and create load tests than it is for me to read a few articles. from that perspective, it's a ridiculous claim. ..but anyway, Bob from AWS answered my question. Perhaps you have figured a way around it (perhaps it has changed in recent months), but without listening and just answering, you're wasting your time. I suggested to read the AWS thread from the first page to the second page. You didn't. You only read the first, even though I explicitly said to read page 2. You were more concerned with your ego and proving me wrong. I'm sure you have tons of valuable information regarding Lambda, but if you want to be heard and respected for your knowledge, engage more cordially, making room for lack of knowledge on the part of the person your conversing with, and make sure you to listen first, being sure to pick up key details and the overall essence. Nevertheless I'd still love to hear your opinion on what Bob said. Maybe there's another route my lack of experience with Lambda is obscuring. ps. why are you still talking about time within AWS infrastructure (with references about your EC2 instance in "us-west-2 [being] less than ten milliseconds"), when you now know I'm talking about coming from the outside world. Based on what Bob said, there's 200-300ms you wouldn't see otherwise. No, I'm not gonna go test it cuz when I do I'll invest a weekend into Lambda and come out with a thorough mastery, as opposed to the 5 minutes it took me to write this. It probably initially took you that long. It sounds like you can't even put yourself in YOUR OWN shoes when you first started with Lambda or any AWS offering. But that said, I understand the damn thing--they are JS functions you can run (or other languages like Python); they have setup times; you don't need to worry about scaling servers; you can use API Gateway to point endpoints to them; API Gateway has various security concerns which amazon takes seriously, which cause small but significant latency; etc. I'm sure u want to get caught up on which semantics I missed, which terminology I didn't use perfectly, etc. None of which should hinder this conversation, and none of which will escape me when it comes time to set this up. So at this point, I'm just curious if u'll ever crack and become human--is Bob wrong now? Do I have to spend all weekend producing load tests to prove to you it took me more than 15 minutes to do? Do I have to create a competition for people new to lambda to see how fast the mean setup time is to prove to you it's not as easy as you're making it out to be? What is it going to take to have a harmless conversation about latencies experienced around a product? And most importantly, why does this all agitate you so much? Why does it get under your skin so much that someone is asking questions rather than silently doing it all themselves. Perhaps it's something you pride yourself of. I pride myself of saving time, and I know for me, a few harmless questions will save me lots of time. I know I don't need to touch this or competing technologies until I already know exactly which one hits the mark. And I collect that information casually in the time leading up to when it becomes urgent. I don't need to put in any work on a wide range of things. It's not that I don't on the very many I choose to focus on. I dont see it as black or white. But perhaps u see as black or white and what u respect is self-sufficiency on everything, never asking questions, etc. And someone like me casually asking questions upsets u because it doesn't reflect what you think is great about yourself. We all deal with ego issues. All day every day. We are supposed to be fighting them my friend, not fighting those that don't reflect or agree with our every perception. It's about cutting through them. Ima ask whatever questions I want man, post whatever links i want, cordially ask naive questions I'm not afraid to ask (because my ego isn't in my way), and it's gonna continue working for me. As for your anger and frustration (without a real cause--because sometimes there is true reasons to be angry), I'm not so sure how it's working out for you. Are you on edge all day at your computer keyboard??
(self) is weird. _ _init_ _ syntax is weird. The module/path system is weird. The standard documentation is notoriously obtuse and verbose for such a "beginner friendly" language. Just to contrast, you'll learn about most of javascript's deficiencies in like one lecture from Crockford. And most of it goes away if you ===. And to be fair, prototypes make sense if you think of them as javascript objects instead of an opaque special class objects. Frankly, you don't often use traditional oo in javascript. Function is king in javascript, not class. I mean python is nice, but there are weird things about that don't make a lot of sense.
Why no? A lot of universities will start people with Java.
&gt; That's like saying you can write a webserver in Fortran Yes, it's exactly like that except that C# is fairly popular. It's also used as "scripting language" by Unity 3D and Godot 3.x. So, you can actually do quite a lot with it.
What does this comment even mean? What is a native tool vs a non-native tool? It seems like you're trying to come up with a technical reason why C# is bad but really you just want to say "teehee M$ evil". e: Just looking at your other comments, you don't seem to quite understand what you're talking about... e2: Lmao, https://www.reddit.com/r/programming/comments/5xlmc6/a_new_hobby_os_from_scratch_in_c/dej7lld/: &gt; Cause he doesn't know what he's doing. No knowledgeable software engineer would use C# to create an operating system and no knowledgeable software engineer does for anything worthwhile. "No knowledgeable software engineer" uses C# for anything worthwhile, that's hilarious.
Prototypical inheritance has been a part of the language since it's inception. The class syntax is just a syntactic sugar for prototype system.
It's okay. It's not great, but it's also not the worst. As long as you learn more than one language, you can start with whatever you like. Anyhow, I recommend to start with a language with strong or optional typing, because you'll get better error messages. You'll also get things like context-sensitive auto-complete and things like that.
I don't know how using `Promise.all` with an array containing one promise has anything to do with calling async operations serially.
Unless I'm misunderstanding, you're still calling `onWaitingAction` for each player in parallel, then just awaiting the results at the end, which isn't what OP wanted.
JS is weird... To a programmer with experience in more OOP and strict languages. JS is a functional language that can be used in OOP. Java is the opposite. But the thread is about learning it new, isn't it? Java has it's share of weirdness too.
super bored of watching you wrongly guess and google at me notice that this one gives new incompatible numbers, all of which are lower than your old "i'll believe anything i find without experiments" not sure why you think this is of value believe whatever you like
google at you? i know nothing about you other than the camel cased word "StoneCypher" ...wait let me get this straight--im making critiques u've received before?? brother man, u sound highly passionate about technology and the technologies you use. u dont have to be mean about it when others don't talk about them the way you would like them to. but perhaps im just doing the same by coming back at you. so lets just end this...unless there is anything productive u'd like to add about what Bob said?? ...as far as the "without experiments" thing, here's the thing: i totally get you. and i wont believe anything. nobody said I "believe" all this stuff. and by the way, im certainly not trying to slander Lambda. I didn't believe the article the hacker news link pointed to just like u didnt. i'm using the aforementioned info to efficiently and casually make discoveries until the issue becomes urgent, at which point I have no choice but to invest in "experiments," which it is my belief that they are far more time-consuming than you are making them out to be or simply than they are for you. I know for me they will be very time-consuming, and I know i can avoid it and make the time-savings through casual research like this.
But was JS really seen as OO language before that sugar was added?
Wouldn't that call all promises at once instead of one after another?
Yes. You don't need to know HTML/CSS to get started with JS. It can help when you go to build your browser-based calculator, but they can be learned separately. 
We are really proud to finally open source our in-house used caching library. It is a framework agnostic caching solution with no third party dependencies (lightweight) and low buy-in. We use it heavily in our migration phase from Angular to React. Since it is independent of the SPA solution, we can cache the API requests regardless of Angular or React. - [Demos](https://petercrona.gitbooks.io/ladda/content/docs/Demos.html)
As someone who knows very little python and is mostly used to fp/js/java/C, (granted, many of these are purely syntax, but still) `self` as an argument, `len` as a function, `__add__` (and family -- why not allow arbitrary operators or use something generic like `operator+`?), the need for `:` (since it's redundant), everything about `lambda`, the list comprehension syntax (for multiple variables, the repeated `for` is unexpected; compare to `[x+y|x&lt;-xs, y&lt;-ys]`), the ternary operator (would be more natural as `if p then q else r` instead of `q if p else r`), negative indexing/slices (not that I think they're bad, but they are unexpected), lazy output of `map` (and family), probably a lot more.
Yes.
Kind of makes tree shaking useless if you use "import *" everywhere (at least makes it much harder to detect unused code). It is a little harder to reason about what is actually being used in a file as well. Edit: [More opinions](http://stackoverflow.com/questions/40061042/import-vs-import-specificname-in-typescript-es6)
You're not misunderstanding. I was confused by OP's do...while loop, which made it seem like he was trying to achieve the same thing. If that's the case you can just store everything in a single promise and then on the last player's promise. Can't you? let actionPromise = Promise.resolve(); for (let players of this.players) { actionPromise = actionPromise .then(() =&gt; onWaitingAction(player)) .then({ action, raiseAmount } =&gt; { ... }); } actionPromise.then(() =&gt; { ... // will be called after last player's action/raiseAmount is handled }); 
[removed]
I don't understand...
Hi /u/usamanoman, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Using Promise.all with a one-element array is no different than waiting for that one promise directly.
Well then that's excellent.
&gt; What weird unintuitive things would you say Java has? &gt; What is unintuitive in python, specially python3? I think once you've thought like a programmer for awhile it's easy to forget what it's like to think like someone learning to program. I've done a fair bit of programming teaching, and in my experience when you are first learning how to program it doesn't matter which language you use: *everything* is unintuitive. It doesn't matter whether your language uses `integer(foo)` or `Integer.parseInt(foo)` or `parseInt(foo, 10)`: the very concept of differentiating between `2` and "2", and having to switch between them, is not entirely intuitive. Don't believe me? Try finding a programmer who learned to program without ever referring to a string as an int or vice versa. Even in Java or other statically typed languages, where that gets caught quickly, people still make the mistake. In other words there's no point in arguing, for instance, which language has the most intuitive way of dealing with types *to a programmer*: to someone new to the craft every way is unintuitive (what's intuitive is writing English and algebraic expressions). And the concept of types and type coercion is *far* from the hardest thing to wrap your head around when you're learning to program. Of course, you can't take this to the extreme: I'm not trying to argue that Fortran is as easy to learn as Javascript :D But among modern programming languages I really don't think a newcomer's struggle is going to be with the unintuitiveness of how language X implements feature Y, because no matter what X and Y you pick it's going to be unintuitive to them.
That is pretty cool. What do you need from babel to use async/await in webpack? Is it just "babel-preset-es2015"?
No. The callback passed to `then` doesn't get called until the promise that is being `then`ed is resolved. I threw this together to demonstrate: http://codepen.io/anon/pen/qrrLrv
No, because it's building up a promise chain, if you unroll the loop (or, inspect the value of `promise` after it's finished). You end up with something (roughly) equivalent to this: Promise.resolve() .then(() =&gt; onWaitingAction(player[0])) .then(({ action, raiseAmount }) =&gt; /* do something with results */) .then(() =&gt; onWaitingAction(player[1])) .then(({ action, raiseAmount }) =&gt; /* do something with results */) .then(() =&gt; onWaitingAction(player[2])) .then(({ action, raiseAmount }) =&gt; /* do something with results */) // etc... It can also be written as a reduce, something like this (my usual preference, but YMMV): players.reduce( (acc, player) =&gt; acc .then(() =&gt; onWaitingAction(player)) .then({ action, raiseAmount }) =&gt; /* do something with the results */), Promise.resolve());
I actually do use JavaScript for desktop applications. I also use desktop applications written in JS on a regular basis. Not math heavy though, but I rarely do math heavy things. Which is why I wrote 99%.
console.log('it's a piece of cake!') it's a piece of cake! 
Dude, you are posting on r/javascript.... what kind of answers are you expecting to get? 
JavaScript is decent enough. It has quirky behavior just like every other language (perhaps a little worse, but whatever). I've never believed that one language is better than others for first timers because the breadth of your knowledge will come from how much time you spend studying the art of development and computing rather than what your first language was. If your goal is to write apps that run in a browser, then JS is not just okay, it's practically mandatory. Even if you want to do other things JS is common enough that it's unlikely that your skills will go to waste.
javascript is perfect for those starting to code. Vibrant community. Available on client and server. Almost zero ceremony to get up and running and coding. Def start with js
It's fine. There are some odd language quirks which will bite you sooner rather than later, but the tradeoff is the vast array of resources available to users of the language. - Most contemporary browsers have decent to excellent debugging environments - NodeJS for server applications - There are so many books and websites to help you learn - Tons of reusable code on github - NPM Lots of good things to recommend to it. Definitely pick up the *Javascript: The Definitive Guide* and *Javascript: The Good Parts* which are excellent references and guides. Someone can probably help you find a good "learn how to program using javascript" book.
Actually, you will not be given the response data for *any* promises, regardless of when they resolved. And the ones that have yet to resolve will continue running in the background. If you're downloading 10 files via Promise.all and 8 resolve in a second, 1 rejects after 9 seconds, and 1 resolves after 20 seconds, Promise.all won't return the resolution values for *any* of them. So you'll have to have a reference to the promises separately and call `.then` on each (or `await` in a for loop) And your code will end up waiting another 11 seconds after Promise.all rejects because you're awaiting the one that takes 20 seconds.
He asked un-intuitive things related to Java, and you cite Python.
One more thing, bettingRound check can be async now, iterating over players can async now, every line can be async!
Heh. Yeah. I guess I thought he asked about java and python because of the recommendation above in this thread. Whoops. :p
 await arrayOfItems.reduce((p,x) =&gt; p.then(() =&gt; doSomethingWith(x)), Promise.resolve()) :)
It's part of [es2017](http://www.2ality.com/2016/02/ecmascript-2017.html)
So can we all just agree that ASI is bad yet?
With node's commonjs modules, you can use [proxyquire](https://www.npmjs.com/package/proxyquire) for this kind of issue. Something like that will exist for ES modules.
The lambda syntax and how you use strong types (if you choose to) is sort of weird.
I learned C++ as my first language, and it was a true PITA but worth it. Having static, declared types helps focus the beginner on what's going on. I took Java in college, and while I absolutely hate Java, it's a reasonable choice for learning (I still prefer C++ though). Actually going through the compilation process and understanding what's going on is also useful.
It's probably best at this point then to start using the Grass Waving technique instead.
Yeah: http://ondras.github.io/rot.js/manual/#tiles
Yeah, I used the wrong term. "strongly typed" would have been a better one.
Great bubbles but where are the fish?
I've personally learned programming with Javascript. While JS is superb for quickly making small programs that run easily, and is generally super quick and easy to learn, I would've wished I had learn something more pure (Like Java) to begin with. Java (and many other languages) being strongly typed and full on OO, will teach you some good habits, If you will; and might also allow you to better understand the structure and philosophy of OO. (JS is loosely typed and hybrid OO and Functional, which makes for an absolute breeze to work with) tl;dr: I learned Javascript first; it is fun. Wish I had learned Java or equivelant (which I later learned on my CS course) because it is strongly typed and pure OO.
Fish are incoming :)
I will also add to this and say that a lot of stuff you will come across online is going to be ES6 stuff that needs to be transpiled, adding an extra layer of complexity to also having to know HTML and CSS to do anything self contained in JS. Not that you *have* to use any of that stuff, but I feel like someone new to programming may quickly get overwhelmed when they start to dig a little deeper. The JavaScript scene is *weird*, man. 
&gt; Python is a beautiful first language to learn. That's fine, but it's not practical. Python represents some fraction of just the back end of the web. JavaScript is the whole front end, and a rapidly growing fraction of the back end. Definitely a good point. But also depends on what the person wants to do with programming. For example, I'm interested in data analysis. So while I am currently going through a web dev bootcamp (it's free through a non-profit), I am very glad that Python was my first language (the bootcamp even used Python for 2/3rds of the class before letting us choose between JavaScript and Java). So I can agree that Python is not super practical to start with as a first language if you know you definitely want to do web development, but also the course I'm going through did exactly that for hundreds of people who had zero coding experience and it seems to be going pretty well. 
Oh my goodness, please continue っ╥╯﹏╰╥c
JS *is* untyped in the typical sense of the word. The post you're replying to probably meant to say "strongly typed" but is still mostly correct. You can do `typeof` but this is just runtime data. The fact that the program will compile (and run) regardless of any type differences means it's untyped.
A couple of years ago using Node on Windows I tried to figure out how to open a window and write some simple graphics into it. I tried 10 different libraries. Installed 15 different packages to support it. So many different versions, limited documentation. I never figured out how to do it. Have things improved since then?
Do you have more links like that ? :D really appreciate it.
That's one way to look at it. And I certainly won't claim that Javascript is the best programming language ever written. But another way to look at it is that Javascript *did* have competition, and won. You may not have been coding back then, but Javascript was not the first in-browser programming language: Java was. Java applets were supposed to be the future of logic on the web ... until Javascript supplanted it. Then came Flash, and that too was promoted as the future of client-side programming. It was in fact touted as superior to Javascript, because while there was only one Flash language, there were multiple dialects of Javascript back then (Netscape's JS was different from IE3's JS, which was different from IE4's JS, which was different from Opera's, which was ...). It's true Javascript had one non-language advantage over both of them, in that it was built-in to the browser. But both Java and Flash, at their peaks, had very heavy installation bases. Not being built-in was a problem, but it was not an insurmountable one. If Javascript was a terrible language developers would have gravitated to the alternatives, Flash and/or Javascript would have been automatically installed in every browser, and no one would use Javascript ... ... but it wasn't. That may not be proof that Javascript is the best language. Heck, JS might have been a little inferior to either Flash or Java (it most certainly was in many areas). But being built-in was hardly enough to guarantee it's dominance: it could never have triumphed if it wasn't a solid language on its own.
Okay I just started watching the Harvard's CS50 series. It's really good! As someone learning Javascript, I can feel that this course is going to add a lot of context, and fill in some programming blanks, for me.
&gt; console.log('it's a piece of cake!') Uncaught SyntaxError: missing ) after argument list
&gt; You think they'd explain how JS differs from other languages. First Class Functions, scope, context, etc, etc, As far as I understand (and this is from something like Fall 2010; I watched the videos/did the psets from that semester), the point isn't to explain JS in detail but to overcome the "I've never coded in JS before" hump, kind of a "look how easy this is now that you know C" thing. It's not a JS course, but it is thanks to it that I started coding in JS.
It's an option, especially if you want to work in Web development, in which case you'd need a little HTML and CSS knowledge. It's actually a pretty good option for a new programmer, due to the quick turnaround from 'alert("Hello World")' to actually doing moderately cool shit like, say, a calculator. However, my recommendation for a new developer who wants to do general-purpose development would be one of the object-oriented command-line languages, like C#, Java, Python, one of those. Something that'll teach you good habits for serious programming, and probably has less boilerplate than modern JS. (inb4 people defending setting up Gulp tasks, NPM package.json, and throwing everything in modules)
Ehh. You're probably loading an image on your frontpage that is 4 times larger than React.
There is no error handling there.
Uhh..?
The problem was never a disagreement, but backwards compatibility.
Yeah dawg! 1. It's easy 2. It's everywhere 3. It's hard to break your computer with it. 4. You don't need to install anything (just press F12 or go to codepen.io)
I would like to see something like `"use super duper strict";` where ASI is disabled.
Plenty of tools that can analyze this statically for you.
Personally, I took a college course to learn HTML JS and a little PHP, but the teacher was all but useless. W3schools.com is a great resource for starting out (it got me through the class). I would say focus on the syntax mostly as it is very unforgiving, and often hard to debug due to limited error messages. 
The first rejected Promise will be in the second callback to .then or a .catch, which you can parse. But the successful promises will be lost and any subsequent Promise rejections will be lost. But yes, any async operations in Promise.all (network or timeout or worker or whatever) will continue, but the results get dropped. I realize I wasn't doing a very good job of explaining it, hence the link to MDN. The big takeaway in my opinion is that Promise.all should only be used if you only care when EVERY promise is successful and you don't care how many actually fail if a failure occurs.
js engines don't parse images.
It's not any more untyped than Python, which will happily chug along until it crashes because something it expected to be there was missing. JS has types (such as they are), it just doesn't allow you to constrain what you put in a variable.
I maintain a static analysis tool, so that isn't what I am looking for. I am looking for run-time/compile-time failure when sloppy crap is encountered.
https://www.reddit.com/user/sunjienming
Thanks. I think I misinterpreted the error message. What it's saying is that an await does throw an error within an async function (the right behavior), but it currently just warns when there's no async catch block. I.e., when you call the async function at the top level. So they're saying that in the future when you do such things, node will crash. That seems just fine. For example: async function foo() { throw new Error("hi"); } async function bar() { await foo(); } async function baz() { try { await bar(); } catch (e) { console.log("Caught error:", e); } } async function uncaught() { await bar(); } Calling `baz()` at top level produces the following output - the baz() call shows the error is caught. Caught error: Error: hi at foo (/Users/aneil/code/deepdialog/api/sandbox/junk2.js:1:93) at bar (/Users/aneil/code/deepdialog/api/sandbox/junk2.js:2:30) at baz (/Users/aneil/code/deepdialog/api/sandbox/junk2.js:3:37) at Object.&lt;anonymous&gt; (/Users/aneil/code/deepdialog/api/sandbox/junk2.js:5:1) at Module._compile (module.js:571:32) at Object.Module._extensions..js (module.js:580:10) at Module.load (module.js:488:32) at tryModuleLoad (module.js:447:12) at Function.Module._load (module.js:439:3) at Module.runMain (module.js:605:10) Calling `uncaught()` just logs a warning: (node:19774) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 3): Error: hi (node:19774) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code. I think they're saying in future that `uncaught()` will crash node (which is perfectly fine, from my perspective). It should act as an uncaught error. So I've revised my opinion. I like the semantics of how this works, and the direction they're taking it in. Seems spot on.
await arrayOfItems.reduce( async (p,x) =&gt;{ try { await p; return doSomethingWith(x); } catch(e) { return onError(e, x); } }, Promise.resolve()) 
Here is what I tell my Java developers at work: * Learn scope. This is the single most important thing to learn. Learn it before anything else. * OOP and `this` are not scope. In this language inheritance is completely optional and it doesn't work like it does in C++/Java, so avoid it. **If you feel you cannot move forward without inheritance you aren't learning this language.** * Functions are first class citizens. This is a fancy way of saying a function can be used anywhere a primitive can be used. That description is very literal. * This language has a low barrier of entry, which means there is both wonderfully elegant things written as well as a bunch sloppy shit from careless lazy people. Code very defensively regardless of what other people tell you and without regard for code examples elsewhere. Just assume your code will always fail and have unintended consequences, so go out of your way to prove otherwise. * Objects in this language are just basic hash maps. Keys are always string types and values can be any data type. * All non-primitive data types are objects and can be treated as such, to include functions and arrays. That is enough to get you started. For most everything else you just have to practice getting used to loose typing, but really do everything you can in your code to avoid type recasting. Type recasting breaks JIT compilation. I see try/catch blocks used exhaustively in Java. Try/catch blocks also break JIT compilation, so avoid that too.
Ty for the book man :) http://jsforcats.com/ was an easy exercise for me, so will be looking more into this later on !
Guys, I wonder if I want to pursue JavaScript as a first language at all now or wait until I learn something else. I don't need a browser app at first. 
There's exactly as much error handling as there would be for an `await Promise.all(promises);` -- the first error in any of the tasks would cause the async function which contains the await to reject its underlying promise. But if you wanted to handle errors individually: await arrayOfItems.reduce((p,x) =&gt; p.then(() =&gt; doSomethingWith(x), handleError), Promise.resolve())
Yes. The concepts are what transcend through most programming languages - the syntax is what is in flux.
Ugh, I just lost a long reply to this and don't feel like remembering everything but I'll simply say that you are discounting the effects of javascript being built in far to readily, overestimating flash and *especially* java applets, and your assertion that js is a solid language it quite frankly wrong. Regarding that last bit, js was hastily designed to prevent Microsoft from entering the market with their own language. And all the hasty design decisions show. Js has some large problems that won't ever be addressed because the maintainers refuse to break backwards compatibility. A lot of the things added in the last decade to the language are a lot better. But it's still lipstick on a pig.
## Highlights - **Microscopic:** Around ~350 bytes gzip + minify, including the UMD wrapper (~80b). - **Functional:** Methods don't rely on `this` context. - **Compatibility:** Almost like Node's EventEmitter. - **Compliant:** Can `.emit` events with multiple params. - **Chaining:** Support all methods to be chainable. - **Useful:** A wildcard `'*'` event type listens to all events. - **Friendly:** Plays well with browserify, webpack and browser users. - **Bundled:** Available as ES6 Module, CommonJS and UMD. - **Meaning:** [Hear it](https://translate.google.com/?hl=bg&amp;tab=wT#en/bg/dush). It just means `shower` in Bulgarian. - **Clean:** Does not mess with DOM or anything.
[You don't know JS on github](https://github.com/getify/You-Dont-Know-JS) - has links to readable online versions of the books.
I started getting comfortable with JS concepts generally by watching this fellow's videos https://m.youtube.com/watch?v=BMUiFMZr7vk. You will likely find it a little pedantic at times, but he gives a great look at both JavaScript idiosyncrasies as well as features that will be more familiar. More generally, find resources from when you learned Python and replicate them in JS.
I write react native all day and it's great to be able to style inline on the fly and then just move that object somewhere else in the same file on refactor. Haven't done it in a web app yet but it fits react' paradigm to do as much as you can the same way across platforms.
Recently discovered lambda, been using it to mess around with some automated scraping and API calls. Very interested in checking this out.
The minimum start time is "00.00" and maximum end time is "24:00". If we start from "23.45", we will exceed "24:00". Of course you can set a hard limit on "24:00", but for brevity sake, we will keep the interval (15, 30, 60) as 15mins, 30mins and 60mins slots of an hr. Hope that clear things up
Careful of the bug with the poker table... Betting is done when everyone has either matched or folded. If player 1 leads in betting, and player 2 raises, and player 3 reraises, action has to go back to player 2. I think a queue would be easier to manage. Every raise causes the remaining players to enqueue again.
Yeah a slide or two on how js has functions would've been pretty useful!
Actually, It does have 2 slides saying pretty much exactly that.
&gt; it is recommended you not use innerHTML when inserting plain text; &gt; "recommended" &gt; "plain text" Why jQuery should decide when an embedded tag is safe and when is not? It overloads library with unnecessary check. When we need to clean the data before sending to server, then we start looking for the library which can do it (and only it). When we ingest something in DOM, it should come from trusted domain only and browser need to have something like `&lt;div scripting='disabled' loadcontent='disabled'&gt;...&lt;/div&gt;`. When we state that a library automatically removes potentially dangerous code, we create wrong illusion that it is safe to use innerHTML with it. It is always dangerous, reddit for example disables any custom html in the comments. I believe that is not because they can't afford to use latest version of JQuery. 
Lmao, that's an even dumber response than I could've imagined.
Thanks for the suggestion, but are all those pirated ebooks in that repo? C'mon, don't be an asshole and [link to where people can legally get the book from](https://www.amazon.com/Beginning-Python-Professional-Experts-Professionals/dp/1590599829).
Please, I've been in software development long enough to have at least as broad a knowledge base as you and I didn't make those comments to get into some kind of language pissing match. You'll notice I never once said which language I thought would have been better than js. I've been using it almost daily for a while now. It's possible to know a tool and also still be able to recognize the flaws in it and another thing entirely to recognize *why* a tool is even being used in the first place.
Can you elaborate why you are resolving the promise right off the bat? I've seen this before, but always wondered why.
I think I'll wait a couple of weeks for V5 instead.
&gt; V4 Final 2.3.1.really.jeff-2b
Can someone try to make an explanation as to how this actually works with reduce? I understand that it *does*, but every time I look at code that uses it, I feel like I'm failing to comprehend how it actually works, because I stare at it in total confusion for a minute before I realize it's serially promising. 
Yeah I guess so :) It just feels a bit wrong to show html like that. I guess the user could also add "&lt;/div&gt;&lt;/div&gt;" and it would probably mess up the rest of the page's DOM and ruin the layout. But i guess the user could just refresh the page... + Ah yeah you were right, i meant .html( preview_data_html ) 
:)
I am not asking about code style at all and I am not trying to force anything on anybody. Strict mode is opt in.
It's because you need an initial/empty value of a promise chain. The pattern is the same as if you were summing the values in an array. You start with an "empty" value (0 in the case of Sum). e.g. let sum = 0; for (let value in myNumbers) { sum = sum + value; } In the case of a Promise chain, a resolved promise is the "empty" case. Otherwise, you would have to do something like let promise = onWaitingAction(players[0]) .then(({ action, raiseAmount }) =&gt; /* do something with results */); for (let player in players.slice(1)) { promise = promise.then(() =&gt; onWaitingAction(player) .then(({ action, raiseAmount }) =&gt; /* do something with results */); } Which is kind of ugly, duplicates a lot of the code, and breaks if the array (`players`) is empty. 
&gt; What I'd like to do is generate a key pair for myself on my machine, keep it secret and local, then put up an application that lets people encrypt strings/files using my public key, which I can decrypt locally later on. The keys once generated are really just hash strings. Share the string value of the public key anyway you want by sending it out via Node or even publishing it on the web/social media. I found this in the documentation - https://nodejs.org/dist/latest-v7.x/docs/api/crypto.html#crypto_crypto_publicencrypt_public_key_buffer I would recommend using with the passphrase, so that it can only be decrypted by your private key and a password (probably some random string you build into your app that can be reproduced on your end).
&gt; Strict mode is opt in. In ES5, that is. Classes and modules are always in strict mode.
Yeah I agree. It seems like everything else should come before tooling. A lot of the tools require knowledge of arrays, functions and other fundamentals. I think day 1 won't be productive if it stays with this schedule. 
Pretty cool! IMHO a nice addition would be to lower the sensitivity if you press shift or another key. It becomes easier to be more precise.
Write a test to detect the bug. Show a big red warning message to let the user know that their browser is broken.
Software synths usually use up/down for this. Up/down (= high/low) makes more sense and isn't tied to the reading direction.
That's completely on you for using a pre-release version though.
"tooling" means installing node and a text editor, really not a big deal
Wow, I've been developing in React for 2 years now. Reading the code of the v4 is enlightening! I'll surely upgrade and start using some of those patterns myself. Amazing job!
I have a lower contrast version up and running at http://schalk.net:3055. I have been experimenting with centering everything or adding more content to the left column.
If its not too much work you could make it an optional feature if a particular data- attribute is set. Then the dev can decide whether its appropriate for their particular use case :)
Hmm, that's an interesting way to "creep" strict mode on people. It's amazing you can always find a way to modernize a language without breaking B.C.
Libsodium is designed to provide an opinionated, high-level encryption interface that reduces the possibility of programmer error. There are plenty of versions of this library available for node, such as the `sodium-native` module (wrapper), or the `sodium`module (JS port). For your use-case, take a look at the `crypto_box` libsodium API: https://download.libsodium.org/doc/public-key_cryptography/authenticated_encryption.html I realize this isn't quite what you are looking for, libsodium is widely seen as being the safest, most state-of-the-art approach to this sort of problem. The native node way would be to combine functions from the `ecdh` object to implement a key exchange protocol. Once you have that working, you would use a hash or an HMAC function to implement a KDF, as described in NIST.SP.800-56Ar2 section 5.8.1. Finally, once you have your shared encryption key, you could use functions from the `cipher` and `decipher` objects to do encryption. Don't forget that most encryption modes aren't authenticated, so unless you use GCM, you'll also have to add an HMAC to ensure integrity. Hence, the recommendation to just skip all this and use libsodium. I should also mention that authenticated encryption and decryption need to see all the data at once. There is no way to decrypt data "on the fly" as it streams in from the network. If you need functionality like this, your best bet is to break the files into chunks, encrypt each chunk, and then re-assemble the chunks on the other side. This is what SSL does.
If you already know how to code, I would start by just building something simple and learning on the way. 
inheritance and scopes / closures are probably the main areas that differ from most programming languages, other then that just go in and review different design patterns.
I would say that one exceptional wart stands out to me as exceptional to all other popular languages, and that's the lack of modules in browsers. This will affect beginners, and not in the way that a type conversion mistake would. And this will make Javascript quite unlike first-time learning experiences in Python or Ruby. This is, pedagogically speaking, a weakness worth mentioning, because splitting up your work into multiple files is a cognitively natural thing to do. But because there's no automatic or natural way to split program code, just having access to this feature and practicing with it will help people develop good intuitions about where code boundaries ought be. Having good modules in your first learning language isn't only about learning how to split your code with good boundaries. It's also related to the problem of how you use *other* people's code too. These are some near-critical concerns, which is why despite all of the complaints coming from the Javascript community, people still use things like Webpack and Rollup. It's also why, when you read older Javascript texts, you'll find pandemic use of the anonymous self-executing function style. It was the only way people could simulate modules before. Also, if we're talking about Javascript on browsers, as opposed to Node, I'd also say that browser variability in language support (which people use Babel to deal with) is a detail that's not useful to first language learning. That's like finding out that, as a first time learner in Ruby, you need a separate tool to transpile your Ruby code ahead of time to be compatible with multiple Ruby versions and multiple Ruby runtime vendors (BablyRuby). And you know what, Ruby doesn't have modules! That's why we need another tool, called RubyPack. Javascript only becomes great after you master the toolchains for the browser.
Thanks for the tips! 
Lost on me as well.
Author here. Semantic versioning is very clear and we've followed it, don't install betas if you aren't willing to keep up :)
I think this version is a step in the right direction. The text is far easier to read. Still not a fan of the colours though.
Author here. The router doesn't "break" anything. There are a lot of us working on this problem and it's not easy. I should expand in the doc, but you can make it work if you employ a "static route config", then match against that in the client to trigger the module loader to load the code the server used. The tradeoff is slower TTI (time to interactivity) because of the waterfall request problem (don't know what code to load until the previous code has loaded). To SSR, code split, and avoid the waterfall you need a way for the server to tell the client which bundles to load (probably in &lt;script&gt; tags) instead of doing a waterfall. Dynamic imports being promises also complicates things because of their "always async" nature, so now you need a module cache to get the client render and the server render checksums to match up and not blow away the page on initial client render! So again, the router isn't breaking anything here. It's just a hard problem that is independent of routing (though routing can help but brings with it the waterfall tradeoff). Additionally, routes are an incomplete answer for "where to split" and "when to load". Need a component-based solution.
&gt; Kinda like you need to install Ruby to run Ruby stuff or install Python to run Python stuff? You can't just install C# and have it run on Linux. You can install Ruby or Python or C or ... and it will run with nothing else. &gt;JavaScript, for example, has a tiny standard library and can't even do any kind of I/O on its own. Digging that hole, eh? Javascript is intended to run in the browser and nowhere else. Redditors want to believe the fallacy that C# will run everywhere. &gt;Your reasoning is clouded by misdirected hatred. No. My reasoning is based on logic that redditors fail at.
bower package/global library to create real funny animated eyes on web page https://zlob.github.io/eyes.js/example/index.html
Yeah, the module imports are just now starting to be implemented in browsers, so this is definitely a wart. But I wouldn't say it's a reason not to learn JS. 1) it's not an issue on Node, as you said 2) it soon won't be an issue in browser (and if you're learning on the latest browser version it's not even an issue now, unless you want to make your learning code public to people with other browsers) 3) there is already a "automatic or natural way to split program code": files. It's how we used to do it "in the old days" before Require/Babel/etc., and it works just fine when you're learning: at first you only have one file to deal with anyway, then you have multiple files that work the exact same way as one file, which is actually easier to learn/understand. Once you've mastered that and are creating apps with more complexity only then do you need to start grokking/managing the global space, and this is easily done with the module pattern (`(() =&gt; { code }`) or a library/tool like Require or Babel. 4) Speaking of Babel it solves this and many other "worts", very easily. Yes it's one extra tool to learn, but every other language has a "compiler" you have to learn, and Babel is essentially Javascript's compiler ... it's just one you don't have to learn to use when you are first learning the language. So IMHO wort, yes, but reason not to learn JS, no.
maybe try putting addEventList**e**ner instead of addEventListner
Author here: v1 - Nov 09 2015 v2 - Feb 09 2016 (completely backwards compatible) v3 - Oct 24 2016 (removed tiny bc from v1) v4 - Mar 10 2017 I only wish I was smart enough to have some new ideas that would justify a v5 in a couple of weeks!
top kek
&gt; You can't just install C# and have it run on Linux. Unity runs fine on Linux, Android, Mac, iOS, Wii U, and whatever. &gt; You can install [...] C Mh? You don't have to install anything to run native applications. &gt; Redditors want to believe the fallacy that C# will run everywhere. Everywhere? Don't be silly. Anyhow, your point was that it's "antagonistic to the Unix-based web" which is utter nonsense. You can write web servers with it and you can run those on Linux machines. &gt; My reasoning is based on logic that redditors fail at. Funny way to phrase that. I can't disagree with that statement.
But.. why?
"Learning" that stuff is an exaggeration. It's covered in the class, but the intro to it is the first day
Heh, guess I was being dense. Sorry.
Always check the console (F12 -&gt; Console) for errors. You should have gotten a TypeError (blabla is not a function).
Great! Let me know if you have questions, either through here or through the live chat on the site.
Oh my god these complaints. Jackson, Florence, and contributors are working tirelessly to produce quality code to make our lives easier, and everyone just wants to complain. The alternative is a future where nobody wants to deal with all the headaches, and we all have to write our own routers. Constructive criticism is fine, but can we try and appreciate the work that OSS maintainers do? Snide comments and nitpick complaints cause burnout, and we all lose.
Awesome idea! I think that marketing it at "people with zero programming experience" is a bit misleading, though; I suspect that if I tried to teach this amount of stuff to a friend without any coding experience, with just a few hours a night for a week, they'd be completely overwhelmed and discouraged. Happy to be proven wrong! But, if any of the organizers read this, I'd consider going simpler (or longer).
I'm too scared to upgrade from V3.
I'd love to upgrade, but I know it's going to be painful on my large project. Can't wait to have a spare weekend to rip out the old, love the new syntax.
Not sure if this is the only thing, but I know that with 'addEventListener' you can add multiple listeners
Nor nested objects
We're all laughing at you, but we've all been there. It happens!
/r/polymerjs might be a good source for updates I recommend looking at the getting started section of https://polymer-project.org some of it has some 2.0 content.
Tutorials: * https://www.codecademy.com/ * http://www.learn-js.org/ Other Subreddits: * /r/learnjavascript Books: * https://github.com/getify/You-Dont-Know-JS Practice: * https://www.hackerrank.com/ * http://www.exercism.io/
https://gist.github.com/indatawetrust/50066253b235417560a148ae6dd401c7
Congrats!
barring some esoteric hardware hack, wouldn't you need physical access to get into an airgapped computer anyway? 
Or decoding '+' to spaces.
I guess that's one way to overreact about a joke.
Or booleans with no `=`.
Keys and values can have `&amp;` or `=` in them. (On that note, you should only be splitting pairs on the *first* `=`, not all of them.)
All of those are very good texts. I recommend reading all three. The good parts is very opinionated while ydkjs explains how js works much more in depth. You can also watch Doug crockfords talk about the good parts and glean a fair bit of insight. 
Have released a couple. One hash based one and one browser history based. They're both really small and fast. It's not hard, at all.
Now there could be more then one expected reaction, because I always thought the expected reaction when brainf*ck is involved was "wtf"
Too many pages in it! ;-)
More of an experiment to learn about making the internals of a compiler, mostly based on the awesome [Super Tiny Compiler](https://github.com/thejameskyle/the-super-tiny-compiler) project!
Not necessarily no. Granted making it the default export will make requiring it a bit more nice. Do you have anything against exporting it as a property?
&gt; they both solve different problems in different ways. Almost all of javascript tools do. Rollup solves the same problem as Webpack which solves the same problem as Gulp which solves the same problem as Grunt solves the same problem as...
JavaScript the good parts is definitely a must read for someone who wants to get serious about us development. More important than the good parts are the pitfalls of the language that he outlines in the bad parts section. The author just gave the keynote speach at a conference I attended and it was very enlightening.
Thank you!
Which would be a valid complaint if they actually paid for the dependencies, or the changes were even breaking in the first place (v4 is a seperate package). For people to complain about this is just ridiculous.
Just that it's simpler (and more standard) to do it the other way.
.... wat 
How did you get away with that? 
I need something like this! Good work!
Right. It's ok if your code doesn't produce too many objects that are all wrapped to proxies. The reason why we should be careful with extensive using of proxies is (given that JS engine is V8) that they written in JS itself (not in C) - [GitHub source](https://github.com/v8/v8/blob/5.7.228/src/js/promise.js). It means that access to the properties and methods will be slower by definition.
I did not see appendPre so I removed it.
Aww ok, this is the append pre function, how can I incorporate this into your code? function appendPre(message) { var pre = document.getElementById('content'); var textContent = document.createTextNode(message + '\n'); pre.appendChild(textContent); } Also, it says TypeError: Cannot read property 'result' of undefined at the consol, how can I fix this? its for const messages = response.result.messages;
Also, is there a way of keeping it at 2 functions?
 const fromPairs = (o, [k, v]) =&gt; (o[k] = v, o) const serialize = uri =&gt; [...new URLSearchParams(decodeURIComponent(uri))] .reduce(fromPairs, {})
In the training organization where I learned to code the circulum is: * month 1: C# Basics | HTML * month 2: C# Advanced | CSS * month 3: C# OOP | JS Basics ... and honestly this works really well, as you acquire good programming habits with C# and later when you have a solid ground you start digging into JS. Also HTML and CSS are far different from programming, so they don't get you confused when you make your first steps. I'm now Senior JS dev, but probably I wouldn't be what I am if I didn't go through all the stuff such as Data structures, Algorhitms, Data bases, Asp.NET MVC, etc. in C#. And all this in 1 year - I'm saying it because someone can think that she needs few years to pass through all this thus to give up. No, guys, you can change your life for just one year even less, but you shouldn't start before you are motivated enough.
The message.Id is transferring through, I tested it with alert(message_Id). I am not sure why the length would be 0 thou, it worked in listMessage.
Go with JS if: * you want to be Web/Frontend/JS dev * you want to land an IT job as quickly as possible * you don't have ambition to work as a Software Engineer in big company such as Google, Facebook, Amazon, etc.
Im reposting this from r/webdev in hope of better feedback. &gt; If you don't bind functions like in publicAPI above then Marry will have each variable/property (like name and last name ), meaning those properties could be set on what ever value you want, be deleted etc. When functions are binded, then you have complete control on every property(trough functions that YOU define), how they need to be set, which one do you expose outside and so on. Marry only has those functions that you created in specific way. Has access to properties only if those functions have access. Those properties are in top on behavior delegation chain. Further explanation of code above: obj2 ----&gt; obj1 . Arrow means that Obj2 has delegated access(trough prototype connection) to Obj1 stuff. Marry ---only-function-you-want(publicAPI)--- Obj2 -------&gt; Obj1. (notice no arrow from Marry to obj2, no prototype link) So Marry is like a phantom head, has access to rest of the body that is Obj2-----&gt;Obj1 trough very "thin link". As opposed to Marry ----&gt; Obj2 -----&gt; Obj1. In code above it was used behavior delegation (or linked objects) inside modul pattern. Usually in modul you see just spagetty code (one function definition after another) that returns some object that have functions that form closures .. 
[removed]
rather than trying to make code you don't understand work you should first learn how to use promises correctly using a flattened callback structure. 
&gt; My research has led me to Node and Mongo, but I'm interesting in hearing your opinions. You could also write your backend without a db at first to reduce complexity, ie just use a mock obj as your db. Hell, if it's a small enough personal project, then this might be sufficient.
`p` take the initial value of `Promise.resolve`, iterates over each x calling `p.then` and doing something with `x`. You could look at it like this: Promise.resolve().then( () =&gt; somethingWith(x[0])) .then( () =&gt; somethingWith(x[1] ) ... .then( () =&gt; somethingWith(x[n]); Setting the initial value to `Promise.resolve()` allows usage of `p.then(...)`.
If you haven't learned JavaScript why would you immediately jump to React? **Learn JavaScript first.** Here is my answer from an identical question posted yesterday: Here is what I tell my Java developers at work: * Learn scope. This is the single most important thing to learn. Learn it before anything else. * OOP and `this` are not scope. In this language inheritance is completely optional and it doesn't work like it does in C++/Java, so avoid it. **If you feel you cannot move forward without inheritance you aren't learning this language.** * Functions are first class citizens. This is a fancy way of saying a function can be used anywhere a primitive can be used. That description is very literal. * This language has a low barrier of entry, which means there is both wonderfully elegant things written as well as a bunch sloppy shit from careless lazy people. Code very defensively regardless of what other people tell you and without regard for code examples elsewhere. Just assume your code will always fail and have unintended consequences, so go out of your way to prove otherwise. * Objects in this language are just basic hash maps. Keys are always string types and values can be any data type. * All non-primitive data types are objects and can be treated as such, to include functions and arrays. That is enough to get you started. For most everything else you just have to practice getting used to loose typing, but really do everything you can in your code to avoid type recasting. Type recasting breaks JIT compilation. I see try/catch blocks used exhaustively in Java. Try/catch blocks also break JIT compilation, so avoid that too.
Search for "douglas crockford" on Youtube, filter for "&gt;20 min length" and watch all his talks. Better and even more entertaining than watching movies, he's a very good speaker (meaning the talks are full of interesting stuff and never boring). Example Playlist: https://www.youtube.com/playlist?list=PL62E185BB8577B63D But there are more, those are just the ones from his time at Yahoo.
I know Javascript :)
important distinction for sure
Server side validation required. The form validation before submit should catch the pattern mismatch too. But, always validate data on the server anyways. Never assume the frontend is doing it for you.
We hit this problem last week and due to time constraints, moved the problematic page to our main bundle. We've come up with a few different strategies for how we're going to solve it. A fairly _naive_ solution we're looking at uses redux and dangerouslySetInnerHtml A working bare bones spiked implementation can be seen at the following link. https://github.com/luke-john/rr4-ssr-cs Also congrats on the release :thumbsup: really loving the router.
How about: var snippetIds = {} function logVal(val) { snippetIds.value = val.join(','); } `console.log(snippetIds)` returns an empty-ish object.
the reason is before logVal function is executed, console.log statement is executed, it is better if you use a promise here or move whatever code which require snippedIds inside callback
I think you might be misunderstanding how asynchronous calls work?
Well, it actually depends on the server implementation, the same with the arrays. But at least from what I've used, nested objects are just inputs with names like: `user[name] user[email] user[id]`, and the server would read that as a user hash with those values. And you can also do stuff like `user[phones][0][number]` or something for deeper nesting.
&gt; First, let's start with which way the slashes go in the address bar versus which way they go on Windows. Slashes work fine on Windows. Just use slashes everywhere. Problem solved. &gt; Then, why do Microsoft people call them "folders" when they're not. They're "directories" a totally different animal. Just call them directories like I do. No one will have a problem understanding what you mean.
Ah, then just practice with Node creating: * services * command line utilities (these don't have to be services and may only work locally). The goal should be OS-agnostic utilities. Once you get these down comfortably you will be in a better position to evaluate frameworks for your service logic. Just start writing programs. It is practice solving problems against the Node API that will convince you of what decisions to make next.
This is one of the most awful BS articles I've read in quite a while. &gt;Still using that pesky, impossible-to-memorize XHTML doctype? &gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; Who the hell ever did that?! Oh. Clueless redditors. Nobody else. There's a reason why it's called "transitional" and there's a reason no one should have been using it since 1999! And that's only the first point. It goes downhill from there.
&gt; Slashes work fine on Windows. Yeah, you still don't get it.
That's an HTML file. Just open it in your browser. 
perhaps this would help :p console.log( *'it'* s a piece of cake!')
&gt;With that said I'm now at a sort of "What's next?" situation. I assume that the next step would be to figure out how to write APIs and connect to databases. My research has led me to Node and Mongo, but I'm interesting interested in hearing your opinions. you're on the right track, but i think you're getting a couple steps ahead of yourself. you probably want a DB backed service, but you might want your API service to connect to a web service instead. i'd recommend you focus on getting some dumb endpoints that respond to HTTP verbs (`get`, `post`, `put`, `delete`) and respond with canned responses up, to get all the plumbing wired up. once you can make requests and log them, then i'd suggest looking at a datastore. mongo is pretty popular, postgres is good if you want all the good and bad that comes with SQL, you can even use a simple redis key-value store if you dont need anything fancy. i'd recommend looking into [koa](http://koajs.com/) as a way to get a quick RESTful API server interface up. koa is kind of an application framework that sits on top of express, which is the bread-and-butter nodejs application server. but koa also kind of patches up some weaknesses in express so it's more than just a bunch of sugar. anyway i'd suggest you define a few simple routes to get everything working together. from there, you can decide how you want to handle your data, whether it's a db, or some kind of restful request across the web.
You should not use document write because it will remove everything from your page, better use innerHTML to set some text inside the body. For example: .... &lt;body&gt; &lt;div id="test"&gt;Initial text&lt;/div&gt; &lt;script&gt; var div = document.getElementById('test'); div.innerHTML = 'New text for the div'; &lt;/script&gt; &lt;/body&gt; ....
redo works....try ctrl+Y ...its undo that isn't working for me... ctrl+Z. As far as the "In general" question with your code....I also made an input mask but did it completely differently, so It's all in how you want to do it I suppose. I am still looking for ways to improve mine because I have a bunch of different widgets and they get loaded via ajax so there are a lot of moving parts...
The reason why people used the transitional doctype is because it allowed legacy presentation in IE as opposed to a compliant strict document which rendered differently (such as a different box model). This was essential to support legacy applications without reworking support in IE and also because most developers sucked at HTML and CSS and couldn't be trusted to write it in any dependable way. These problems are a couple years old now and largely disappeared as IE8 fell out of market-share, but even know developers still don't test their products cross-browser. I frequently come across tools that work only in Chrome, which makes Chrome the new IE6 (before everybody realized IE6 was broken).
I see. something like [this](http://codepen.io/rossedfort/pen/GWmMrm)?
That works way better than I would have expected. Awesome project!
Yeah, 15sec vs. 1 minute to fetch (deterministic!) dependencies sounds almost like magic. It used to have some issues with native modules (e.g. bcrypt), so had to skip using it in some projects. Also, if you use heroku - build times can be decreased drastically.
Thank you! It looks even better in reality, it makes for a great learning experience. I have some information about the building process on github, if you have any questions don't hesitate to PM me ;)
Of course you don't *have* to invent your own alternative to OSS libraries, but if you choose to depend on someone else's work, you should also understand you can't dictate where it goes in the future. You take it or leave it. I'm just saying most people who complain about things like React router are happy to get the convenience of open source usually without contributing anything, but still act entitled to make decisions and bitch about what the actual contributors do. And as far as I'm aware, the previous versions don't just disappear from the package repository. Shrinkwrap your dependencies so you aren't "forced" to use the very latest version if it's so inconvenient.
I read the README, it looks like a decently cheap project, especially for how well it turned out. I'm definitely saving this for my home improvement list 😁
Hi /u/littledebugger, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `littledebugger.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [littledebugger.com](/search?q=%28and+site%3A%27littledebugger.com%27+author%3A%27littledebugger%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|11|100%
Thanks for the feedback! &gt; "Any number" is exactly three? :/ Haha, good catch. Will fix it. As about the other things... Most of them can be said to `mitt` and any other event system like that. But `dush` is product of needs - my and other users, and things that was not merged in `mitt` in one or another way. I believe there is a bit difference between pub/sub system and event emitter. This is emitter as seen in node.js. Every sane emitter support chaining and I need chaining. I won't use it in frontend in any way. &gt; Oh, one more thing I just noticed. Maybe. You noticed it so, anyone is aware of that effect. What would be the fix? Throwing/banning when `emit('*', 123)`? Btw just introduced a simple plugin api, so customizations is allow now.
Yeah, I need to expand the doc. Was writing everything really fast before release. This package (part of the React Router project) will help do SSR + Code splitting the v3 way: https://github.com/ReactTraining/react-router/tree/master/packages/react-router-config But again, using your routes to define and load split points is looking like its an incomplete solution to people deep in the weeds of this stuff.
Thanks for sharing!
I found it difficult to read, and a bit boring. It was not aimed at beginners. I greatly preferred YDKJS, but the resource that has helped me the most in understanding JavaScript has been [Anthony's course on Udemy.](https://www.udemy.com/understand-javascript/learn/v4/overview)
Ok so this is what comes up: http://imgur.com/a/7RT60. getMessage's response is very different from listMessage's, so now with that, how can I make the message variable work? var messages = response.result.message; 
Ah right, I think we call them cable channels. So hiding the cable si one part of the problem, but where do you plug it in? Do you have an outlet nearby? I was planning on having it in the entrance hall, but I have no power outlets there.
Yes I have a power outlet right underneath. You have two cables, one for the screen and one for the raspberry PI, what I ended up doing is hiding a power chord splitter inside the frame https://images.monoprice.com/productlargeimages/53081.jpg. This way i have only one cable. You must have an outlet though, you could use a battery for the raspberry PI but not for the screen since it consumes a lot of power.
Thank you! If you can spare the time you could easily build one yourself.
&gt; Im reposting this from r/webdev in hope of better feedback. Seems like unidiomatic code that tries to force constructs from other languages into your program. &gt; Usually in modul you see just spagetty code (one function definition after another) that returns some object that have functions that form closures This is not "spaghetti" code. 
How do you get the pi to permanent display this? How do you get it to display on start up?
The application runs in full screen and in the raspberry pi options you stop the screen from going to sleep. For the startup you can look at the README on the github page, you have some other tips but the short version is this: In `/home/pi/.config/lxsession/LXDE-pi/autostart` you need to add the line: `@npm start /home/pi/projects/smart-connected-mirror` Assuming that the project location is /home/pi/projects/smart-connected-mirror
 &gt; typeof NaN "number" NaN is a magical IEEE 754 floating point value (just like +/- Infinity).
You have to verify it on the server side. Users can send you whatever they want. Checking the data inside the browser is only done to improve the user experience.
You could run it for ~8 hours with [this guy](https://www.helidirect.com/plu25-220006-pulse-lipo-22000mah-22-2v-25c.html). :x 
&gt; Ah, so the usual ... This is syntax, not style. Curly braces, parentheses, defining an integer with `1` instead of `"1"`, ending statements with a semicolon, are all syntactical concerns, not stylistic concerns. &gt; why, when the compiler can actually figure it out? Because of needless bugs and tests like the one in the article, which prompted my comment and this thread in the first place.
This is already implemented natively, `URLSearchParams`. If you're just doing this for fun, then I suggest you take a look how query strings are actually parsed, [here](https://url.spec.whatwg.org/#urlsearchparams). A few examples of query strings this approach fails on are `a`, `a==`, and `a=1&amp;a=2`.
Really cool project. Thanks for sharing. 
If one function after another is spaghetti code, then functional languages such as Haskell are what? Spaghetti languages? I'll go with the [Wikipedia definition](https://en.wikipedia.org/wiki/Spaghetti_code). If this code is idiomatic, then can you provide some examples "from the wild"? &gt; I would argue more that by manipulating Function.prototypes and constructor property is unidiomatic since you are trying to replicate exact mechanism of classes in a language that does not have such thing. So, you would argue the most common implementation of classes in javascript is unidiomatic? Did I misunderstand you?
huge red flag for me. The coding interview should be done as step 2 after talking to both HR and manager.
You had a few misplaced quotes, here's a cleaned up version of your code on codepen http://codepen.io/lou_dog/pen/EWmGQe *edit: Describing the above link a bit more in depth, I took out your "write to document", and added in a change to the innerHTML of the id="a", where I concatenated the strings (simply added the together like 'joe' + 'grimm' will produce joegrimm). You can concate strings, or if you start to use other libraries like jQuery, you can use their append function. The beautiful thing with programming is that there are literally 1001 ways to create what your posting above. I'd just take a bit more time exploring with consoles online that update on the fly (codepen). https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Howto
That's what I'm leaning towards at the moment. I figure I'll at least express a desire to chat before I take the test. If the manager can't take 15 minutes to introduce himself, I can't take an hour to do his exam.
It's a strange one because you don't want to waste your time doing the test just to find out they don't like you in the interview. But from their point of view, they don't want to waste their time speaking to loads of applicants only to find that half of them couldn't complete the challenge and the time spent talking to them could have been better spent. You both don't want to waste your time but someone has to take the leap of faith first, and as the applicant trying to prove your worth in a sea of others, is it so bad to ask you to go first? Having said that, I am just playing devil's advocate and I personally would see it as a red flag too. Just wanted to throw in some ideas about why they would take such a strange stance on it.
That's what's interesting to me, they seem to have a very senior level staff. This isn't just some young company following the trends. Part of me wonders if this is simply in reaction to having a slew of poor candidates (the position is remote so I'm sure they get anybody and everyone)
Wow you really want attention or karma for this... I posted this on your post in /r/coding from 10 days ago (https://www.reddit.com/r/coding/comments/5x23tv/you_can_also_build_a_smart_connected_mirror/) Cool project but it has been done several times now and there are several other open source versions out there... * https://github.com/MichMich/MagicMirror * https://github.com/HackerHouseYT/AI-Smart-Mirror * https://github.com/HackerHouseYT/Smart-Mirror * https://github.com/evancohen/smart-mirror Those were the top 4 results from googling "smart mirror github"...
Wow you really want attention for pointing out that this isn't a completely original DIY project. I had never seen any precious projects, and I'm glad OP posted this. This post could inspire someone on this sub to go build something similar or improve on it
well that's probably not mine. although we have offices all over the world. I've noticed at large companies 10k+ employees you are surrounded by mediocrity and its just dumb luck if end up working with someone competent. See if they respond with "Google does it" when you ask why they want a coding test before talking to anyone. That should tell you all you need to know.
You need to make it clear how `DeriveJS simply seeks to find different ways of expressing JavaScript`. How do I use this? Is it just for reference? 
Pretty much! I have no really end game, might be useful for obfuscation in the future. My interest was piqued using void 0 in IE (http://stackoverflow.com/questions/19369023/should-i-be-using-void-0-or-undefined-in-javascript) and messing around with JSFuck (http://www.jsfuck.com/). I may write some sort of transpiler in the future...
 &gt; !0 true &gt; !1 false &gt; 1..x undefined I don't really see the point, though.
JSLint
this [exam](https://www.microsoft.com/en-us/learning/exam-70-480.aspx)? I've not taken this, nor have I ever heard about it. What is it for? Why do you feel the need to participate in it?
What I mean about "in the wild" is to find an example(s) of your pattern from established open source projects. This would show that is, at least somewhat, idiomatic. &gt; My question is what part of this is unidiomatic and what constructs are not neccessary? This behavior delegation is not idiomatic. I've never seen it in any javascript source I've ever looked at -- at least to my memory. Take a look at [this](http://eloquentjavascript.net/06_object.html) as an example of idiomatic OOP in js. And, in my opinion, private members are not strictly necessary, as evidenced by large scale js projects (frameworks etc) that have been written without the use of "truly" private members. Furthermore, in my opinion, your code example is not cleaner than the more commonly found OOP code. Edit: I think I come across as being overly harsh over text. I think you did was interesting, but I'm just not sold on it being "useful".
That was the best use of a selfie to convey useabailty of the mirror and demoing the features. Awesome project.
edit: Property initializers to the rescue! class Blah extends Component { state = { toggled: false } toggle = () =&gt; this.setState((state) =&gt; ({ toggled: !state.toggled })) render() { return ( &lt;div&gt; &lt;button onClick={this.toggle}&gt;Toggle&lt;/button&gt; &lt;pre&gt;{JSON.stringify(this.state, null, 2)}&lt;/pre&gt; &lt;/div&gt; ) } } 
I think a great way to learn anything is to hear how someone very knowledgeable and very opinionated feels about it. Lots of grains of salt have to come with it, but my entire initial perspective on JS was from listening to Crockford rant about lack of block scope and the horrors of global vars.
&gt; ... but covariance is actually just a fancy word for read-only. &gt; Contravariance is just a fancy word for write-only ... [What does this have to do with read/write?](https://en.wikipedia.org/wiki/Covariance_and_contravariance_\(computer_science\))
Depending on the complexity/scope of your project, you probably want to use JS libraries or frameworks. They provide some amount of opinionation that will sort of force you to structure your code at a high level. From your post, it sounds like you might be using jQuery to listen for UI events and update the DOM accordingly? You might want to look at something more declarative like React or Angular. It might be worth building a todo app like seen on http://todomvc.com/ but like you normally would. Then look at some of the other implementations and try to internalize the differences. I'd also read through the docs for some of the more popular frameworks/libraries. The intro sections usually contain a "why is it structured this way" bit that might help out. 
MomentJS
After a recent change to gulp-mocha broke code coverage I started to look for alternatives. Just using npm was fairly attractive, as my build chain worked fine from the command line tools. Getting them to work with gulp was getting increasingly annoying. I ran into some problems with pure npm 1) Dependency chaining was manual, I couldn't construct commands based on several tasks the way I liked to in gulp 2) Lack of variables. I like to keep sets of tests separate from each other (controller tests, view tests, etc). Having variables to hold each set of tests/sources was useful. Gluey is a wrapper to orchestrator that provides variable substitution for shell commands. You can run commands like: gluey.shell('nyc mocha {{test_files}}'): Not sure if it'll be useful, but it may. Let me know if you have any suggestions/find it useful.
Just use `execa` for the `gluey.shell`.
I may replace the node-cmd that gluey.shell uses, but the variable substitution is the key bit (otherwise I would not bother wrapping node-cmd)
Because a lot of people use webdriver in Selenium in the quasi-synchronous mode, where the code looks synchronous, but does some very weird stuff under the hood (which I can't quite fathom) to make is synchronous. To make it happen, it queues the async stuff. So if you're calling one of it's apis, that doesn't mean that it's being called there and then. It may be queued for later. It's very strange and mysterious. But luckily, their api is promise-compatible, and compatible with async/await - when you async/await, then things happen as you want them to. BTW, I just looked at their site, and I believe they have a new section called "Moving to async/await!". You can find it here: https://github.com/SeleniumHQ/selenium/wiki/WebDriverJs#moving-to-asyncawait
Webpack
The first thing that I teach new programmers, is to stick to small functions. You may start your process by writing everything in one 50 line function, but when you are finished, chip it down into 5 10 line functions with a distinctive name. That way ppl can see what is happening in only 5 lines of code, and if they are interested in how it is working, they can check the implementations. 
Im sorry but you dont understand the purpose of this. This library allows to build classes and method annotations in JS. ES6 'class' its like a wrapper of old JS prototype. Im trying to enhace js low-level tools.
Pretty agreeable list, I can certainly recommend Eloquent.
Thanks. Came across it, but this seemed simpler. I think its fine to wait for the initial compile once a day ;)
I'm pretty new to JS and I recently started reading The Good Parts, but I have a question. With ES6 out and the book being from 2008, shouldn't it be considered a little outdated?
&gt; Actually going through the compilation process and understanding what's going on is also useful. Yes, absolutely! People who are able to write, read, and understand make files usually won't have any issues in debugging stuff they loaded somewhere. But that is more like a general understanding of how the code will be made into a program and not necessarily programming itself. I'd like to drop in Lua here. Not a programming language but an interpreted scripting language (or JIT compiled if you want to). Lua has only very few syntax elements and you have to do a lot of the logic by yourself. So instead of just calling another convenient built-in function you have to code what you want to do bringing you a greater understanding of the logic behind your stuff.
Yes I think you are right some parts are outdated because of the new standard. A lot of the material is still valid and even if there is a topic that has changed completely in ES6 you will at least know how it used to work before and how it changed in ES6.
[removed]
See [this comment](https://www.reddit.com/r/node/comments/5z2c5q/exploiting_nodejs_deserialization_bug_for_remote/dev1pdw/). It's so subtle I didn't realize the vulnerability is inside a small unpopular module with a dozen of deps.
TGP is only a small book written by Douglas that can be read in a couple of hours (100 not extended pages). Is nothing more that his opinion. It's not a book to start learning javascript. You cannot compare it with "You don't know JS" series or eloquent javascript.
As I have said, The good parts is not a book to start learning js (also is only 100 quick pages). Is only Douglas' opinion (some people agree with him and some others disagree, you don't know if agree or not since you are reading it as your first book :p).
Haha, i don't want my face on the internet, but i had limited resources ...
The raspberry Pi can be connected to a regular computer monitor using a HDMI entry, so any computer screen works! I used an old computer screen, from the 2000s (1024 x 768). Since it has a VGA entry, you need to buy a HDMI to VGA converter. This is the one i got [amazon-link](https://www.amazon.fr/Adaptateur-Convertisseur-Compatible-Chromebook-Ultrabook/dp/B01ARLD1HU/ref=sr_1_1?s=computers&amp;ie=UTF8&amp;qid=1489398970&amp;sr=1-1&amp;keywords=AUKEY+Adaptateur+HDMI+vers+VGA+1080P). If you don't have an old screen, you can buy one second hand! I really advice you to do so since buying a new screen doesn't give you any benefits, since you will display text and maybe a regular image ^^
This is a good point. Frameworks tend to steer you in that direction at some level, but that's always a helpful approach, especially with the rise of [more] functional JS. 
Why do you need to set it in `.babelrc`? Wouldn't webpack's config override the value. I need my modules in nodejs-part of code
Awesome!! Thanks.
I always thought the reason why you see "classes, but not like Java" so frequently is because developers from certain classical languages bring with them a stubbornly persistent mental map of "universally expected class mechanics" -- and that leads to predictable problems in JS (same goes for closures and `this`). Saying those words is a simple and easy way to weaken that mental binding. I think it is axiomatic in JS to say "classes, but not like Java" for the same reason it used to be axiomatic in Java to say "inheritance, but not like C++". Someone new to programming won't understand the statement; someone coming from an older classical language likely will immediately benefit from it; and I'm guessing someone from Python or Ruby will yawn and turn the page. And to take your example a step further, the neatest thing for me about first-class classes is how functional OOP can become. const addClassA = Wrapped =&gt; { return class ClassA extends Wrapped { methodA() { console.log('method from A has', this.prop); } } }; const addClassB = Wrapped =&gt; { return class ClassB extends Wrapped { methodB() { console.log('method from B has', this.prop); } }; }; const decorate = (parentClass, ...decorators) =&gt; decorators.reduce((currentClass, decorate) =&gt; decorate(currentClass), parentClass); class MyClass { constructor() { this.prop = 'my class prop'; } } const MyABClass = decorate(MyClass, addClassA, addClassB); let myInstance = new MyABClass(); myInstance.methodA(); // 'method from A has my class prop' myInstance.methodB(); // 'method from B has my class prop' (`decorate()` is a little terse, but I love this pattern.)
ECMAScript 6th edition supports class expressions (`let Foo = class {}`), which makes them unarguably first-class. And given the changes since version 3, it is getting harder and harder to say it is just sugar.
I said that I prefer `class`, but I don't prefer `class` because it does what you are trying to do. I prefer `class` because it is the closest thing we have of a standard now. I know it is not the same as having true classes, but I personally prefer to use the more "standard" way, even with its flaws. It is more like a personal choice, not a critique of your work. I actually liked what you are trying to do with annotations, other languages have it, and I think there are a lot of benefits with it. What I suggested is a different way to write `post: ["parseBody", "translateCRUD", "$inject", function(req, res, $$ormInstance){`, instead of using an array like AngularJS does, you could build a preprocessor to write the code using `@`.
Shameless self-promotion: [The JavaScript Way](https://leanpub.com/thejsway) is a new book for learning modern JS. Written from scratch with the ES6/ES2015 standard, it is designed to be as beginner-friendly as possible while addressing some advanced concepts and good practices. It is developed in the open on [GitHub](https://github.com/bpesquet/thejsway). This book is still a work in progress, but the first part about language fundamentals is already complete and may be of some interest to JS learners. PS. I'm actively looking for feedback to improve the book content. Thanks in advance.
Nothing, except that it doesn't scale. That's just one constructor, for modelling exactly one object. Anything more that that (2 object like in my example), if you are using that model, has to deal with mimicking mechanism which doesn't exist. Go write your example with 2 function/constructors. Edit: Imagine your example that has many has 15 functions in it. You would have one flat constructor with 15 function, and if you would go to think about them you would see that some are more generic then others so you could easily make another constructor function that implement those generic ones. Intentionally(!) because they belong by their behavior to other constructor function of certain name. Not because code looks more pretty that way.
Ya rekn? Once it gets dom acesse why wouldnt it? Considering how many big companies bitch about js why wouldnt they ditch js?
Yes
Yes. RxDB has the concept of migration-strategies which handle this.
_Effective JavaScript_ is a great book, but it very much needs to be updated for ES6.
You're going through 3 transitions in the address bar during that video. 1. Load the page, and your address bar is at `groupon.com/deals/ga-bk-omni-providence-hotel-6` 2. You select the room you want, this changes the address to `groupon.com/deals/ga-bk-omni-providence-hotel-6#check_in=2017-03-17&amp;check_out=2017-03-22&amp;ga_deal_value=ODc1` 3. You book, and are redirected to the login/sign-up screen. Between 1 and 2, when you select the room you want, the # is added to the URL, and after that you have name value pairs, such as the `check_in`, `check_out` and the `ga_deal_value`. If you load that page, and select the 'Double Room' option, you'll notice the # appear in the url. You could in-fact press your back button at this point, and it'll deselect the option you just picked, effectively removing the # from the address bar. Changes to the hash of a url are seen by the browser as 'navigation' and can hold query strings after them, for to transfer data and update the page without re-loading or using any Ajax calls to reload information. When you click Back from the login page, you're loading the page with the selected options in the hash of the URL, that is how the page knows what dates/options to highlight.
I have a hard time with a list where every single link to the title of the book is an Amazon affiliate link. I'll bet almost every (if not every) book in this list has a website for the book. But the primary goal here seems to be monetization instead of helping folks out. I get that - but it makes the list much less trustworthy.
Isn't that still just sugar for `let Foo = _Foo(){}`? ES6 classes come alongside a lot of stuff like "super" that was very verbose before, which is a big win when working with classes if that's your thing. But I'm not aware of things you can do with ES6 classes that you can't do with Constructors (under the hood, of course, the native versions might be more optimized, or less optimized, hard to know). If they did, you couldn't transpile them to ES5 code, right? In fact, I can think of one thing you can do with constructors that I've never been able to figure out how to reproduce with classes so far: eliminate the explicit need to call new. With a constructor, you can just do... const Thing = function(x){ if (!(this instanceof Thing)) { return new Thing(x); } this.x = x; } Which allows you to use Thing in places that where it's syntactically awkward to use the new keyword (like a callback or an arg in a composition).
Answer i guess is Yes in some case it will replace javascript. Most of theses being entreprise shit like Netflix or other complexe web APP. Javascript will stay around for nearly forever... but at some point we're all going to look down on it, i feel... Not as its that bad but more of a ( you are still using javascript for your apps :-| , i would not want to be you! ) But this is in minimum 5 years maybe 10
I like how you threw in "2017" in there. 
I've read both YDKJS and Secrets of a JS Ninja (2nd ed.). My opinion is that they complement each other. Some very good explanations are present in one that aren't in the other and vice versa. So, I'd definitely recommend reading both, even if there is some overlap. I can't recommend Eloquent JS though. I tried reading it but it felt tiresome trying to get through all of the verbose examples. I was spending more cognitive cycles trying to understand the logic of his examples (unrelated to JS) rather than learning the details of JS. I consider it a pretty bad book to recommend to newcomers, especially, given the alternatives that exist now.
1. Search amazon for top selling / best reviewed javascript books 2. Write blog with affiliate links 3. Set title of post to current year 4. Post on social media Profit. There are millions of sites that do this - from automated to carefully curated. It looks like the author at least spent a bit of time choosing the content but it is what it is - a $$ grab.
&gt; Once it gets dom acesse why wouldnt it? Because it's a `standards + 1` situation. https://xkcd.com/927/
True, even though it might be useful to access it later. It seems strange to create an input without any other reason than putting values in a div. You're right, though.
nice, misplaced the equal sign with plus but it works. thanks
Nice! Interesting approach by writing and taking feed back from GitHub. Hit me up once it's done! Would love to review it!
Is there an easy way to read these through github? I simply can't sit in front of a computer to read things at length. Lol
Thanks, just what I was looking for 
I think I might have noticed one or two, but it was pretty obvious. Definitely not enough to distract from the quality of the material. It's a pretty fast read, too. Again, though, I'd recommend complementing it with YDKJS. Some topics in the ninja book do not receive the same depth as YDKJS gives.
I don't think this is "static class properties". Rather, it's the proposed property initializer syntax. I do it this way, too, because Dan Abrimov does it in all of his videos, and Dan is the man. :)
That looks like a great book in the making.
This is the kind of inheritance I mean: http://javascript.crockford.com/prototypal.html, where the goal is to explicitly build up behaviour via classical type hierarchies. `Kitten` extends `Cat` extends `Animal`. That sort of thing. The fact that Crockford changed his mind so many times on his recommendation for this "standard feature in his toolkit" sort of underlines why this is actually not-so-trivial. And `extend` now makes this so unbelievably easy (and even effortlessly composable). About that static factory above.... Maybe it's just me, but I've never really liked that pattern, though I've seen a lot of people I like using it over the years. For me, I just have a mental block whenever I see it. Is it a constructor? Is it a factory? Is it both? It is ambiguous. And I've always rankled a bit whenever I see it as a defense against an accidentally dropped `new`. Not to bash on Crockford again, but it reminds me of his linting rule (which I personally still follow) not to use `x++` because of the bugs that happen if you forget the second `+`. In my puffy, arrogant, vain opinion, if someone forgets something as basic as that, using code I wrote, they deserve every error message they get. :) That said, it does compose really, really well.
There is a difference between "popular" and "many people use it". I don't think you'll find a whole lot of people that are crazy enthusiastic about it like you do with JavaScript/Python/etc. I don't particularly enjoy working in it, but I certainly recognize why many people use it and why people are taught with it. It is extremely stable, and was designed 100% in mind with OO. It or C# are easily the most dogmatic OO languages. The explicit type system forces types to be at the front of the education. 
If you want help, you're going to need to provide a ton more information. Are you trying to use node modules in the browser (ala `let _ = require('lodash');`)? Cause that just... doesn't work.
And use passive event listeners, when those are available so you don't block the compositor thread.
&gt; ES2015 is standard javascript since june 2015. It is almost two years old. Then why are we using transpilers to convert ES2015 into older standards? Sure, there may be a governing body that says "this is A standard", but if you have to convert one standard to another for the same language, then I'm not sure I'd call it standard javascript.
This looks neat, but it does look similar to what Webpack does with require statements 
Just click on the names of the titles to read them: https://github.com/getify/You-Dont-Know-JS#titles And if you still have problems with this, buy them or print the pages to pdfs, merge those and read them on your tablet or eBook-reader.
Yeah I just meant because I find it difficult to read long texts on a computer screen. I'll probably just link to my iPad and deal. Thanks!
Yes it's out of date. But its basic idea is important: the language has had shitty things bolted onto it over the years. But if you sort it into good and bad parts, and stick to using just the good parts, it's actually a really nice language. The specific list of 'good parts' that Crockford recommends is (a) a bit subjective/controversial by 2008 standards, and (b) almost irrelevant by 2017 standards. Probably still worth reading if you want to understand how the language has developed in the last decade. It's a very influential book. It played an important role in legitimising JavaScript for serious work, by presenting a viable strategy for turning it into a good language.
This is a bullshit list of affiliate spam
Stefanov's book is great, but a bit dated, it was written with ES3 in mind, and talks about ES5 as a future spec. Definitely skim through first so you don't waste your time on ES3 stuff.
Look at the Exploring JS series. If you do want to learn Doug's stuff, YDKJS kind of has the same concepts explained there too in the prototype book.
If someone can see the map they can get the data displayed on it.
If you want to be taken seriously, you may want to have your articles proof-read before publishing.
[removed]
And thankfully I find all of this stuff fascinating, so I'm constantly learning. No reason not to! You're spot on about companies never changing. We're consistently a few years behind here.
Luckily, 99% of users are at least IE10. And if they aren't, then I hope functionality DOES break for them, so they finally get their machines updated. Lol And yes, that seems to at least look like the best benefit - not having to deal with jQuery or similar.
Don't know if it was you, but thanks for the reports (whoever it was).
Differences/performance compared to [the emscripten version?](https://github.com/kripken/box2d.js)
Hi /u/ReactDOM, I'm banning `reactdom.com` for a period of at least 60 days due to flagrantly breaking the rules (again). Feel free to petition to be reinstated after that time has passed.
Main difference is having a JavaScript-friendly API and readable and improvable JavaScript code, for example I have modified how event listeners are added to World, to follow JS conventions. I have not done performance comparison yet, but even if it is not faster yet, it is much easier to improve Planck.js performance and catch up with transcompiled code because its code is readable and editable.
Relevant username if I ever saw one. Well spotted on that.
Yes, it makes sense.
well, now I feel bad myself I have been a professional developer for 10 years, of which I had used JS heavily in the latest 6 (first 4 where mostly asp.net, all server side, and JAVA for mobile), and I only have 5 projects in my github, of which only 3.5 are js (4 pure js, facebook app, multi-social app with canvas, html5 game app, and a chat app I used with my wife to practice signal R, 1 mvc6 with entity framework and angular 2, hence the .5)
Well, I don't know for anyone else, but speaking for myself, I'd be way to angry to even post a reply. I consider this an insult for must of us developers who do our homework and try to do things ourselves. But, any way, you are now paying the debt of not **trying** to understand and do things yourself, seeing as how your position is being compromised As many had already mentioned, there's no better way to learn a framework, than trying to build something with it. Javascript it's not a hard to understand and learn code, it's one of the easiest actually, Try C or C++.... even better, Assembly, and you'll know whats hard Whenever I want to learn something new, I always go to https://www.codeschool.com/ There are many awesome courses, introductory ones are free, more advanced ones, pay a $25 fee monthly to have full access to all of them, even trying to finish them all in just 1 month Those are easy to understand, they guide you by the hand most of the way, and have a huge community that can solve your question almost instantly
I was able to fix this for me, steps below: If you are in Chrome: Menu &gt; Settings &gt; Extensions &gt; (Locate AdBlock or similar and Disable)
It has only become popular because it was one of the first books which took JS serious as a language. Contentwise it was always very mediocre.
Ok. If I just have the Web page used at my work from the C drive, is everything still safe? It's only unless I upload the Web page to an online file host right? 
Thanks for the youtube tip! Yeah everything I've seen seems to make certain things wayyy easier.
Reasonable. But I would generally agree that in doing so it would be great built-in practice. 
Would you consider [monaco](https://microsoft.github.io/monaco-editor/playground.html#creating-the-editor-hello-world) editor instead of ace? You get so, so much more out of the box, command pallete(f1), symbol search(ctrl+shift+o), peek edit(alt-f12), go to definition(ctrl+f12) smart code completion, like if you say document.querySelector('input'). when you hit the dot, it knows it is an HTMLInputElement and gives you the correct completion items. I have been swapping out ace for monaco and it is fairly easy 
Can you provide an example of what you consider to be a not JavaScript-friendly API in the emscripten version?
If you're not hosting the file on a server all is well.
Because browser support. The idea being that one day you can skip the transpile all together and just run the same code you wrote 2 years ago. Or, you can write this code on the server and no transpile step is required at all. 
Let alone if you're working with other developers or the company as a whole has not agreed that all developers need to learn or do this, then it's not just your call unless your work is relatively isolated/all under your control.
I am looking very much forward to using this. Well done!
Thanks ! I Hope you found the easter egg in the intro slideshow :)
Thank you for responding to the report.
still nothing. Is it because I didn't reference home or work as an option button?
Usually the danger is stupid users. They get tricked by phising schemes from "dangerous" sites, either to install malware, leave their credit card number etc. Sometimes, a vulnerability might be discovered in one of the browsers JS engine, and exploited to escape the sandbox. But this is a "rare" thing.
Sure, until you get to object oriented programming. At that point other languages might actually be easier to understand and work with as you are introduced to OOP concepts. But for variables, loops, conditionals - yeah JS is perfectly great.
I see. I never imagined NaN to be typeof number. Nice suggestion, but I was able to solve it using the isNaN method.
On the one hand, many of the ES6 features are actually simpler and easier to understand than the broken JS patterns they replace. On the other hand, if other people are stuck in their ways, they have to deal with both, and you get the worst of both worlds.
Demo was sweet. Maybe link to the repo on your demo page..?
Convenient API is one reason, another reason is being able to read and improve the code.
Adding to the AWS Lambda + React talk; if anybody is looking for a more detailed Serverless + React.js tutorial, we've put together - http://serverless-stack.com It goes into detail on how to use AWS and React.js to handle user authentication, file uploads, and securing your serverless backend. We go through step-by-step building a simple note taking app with detailed screenshots and code samples.
That's great! Thank you, let me know if you have any feedback or question when you use it.
&gt; We're consistently a few years behind here. So, your company consistently changes :D
Will do.
Thank you so much! Daggy _is_ very much barebones, but I think it'll become more apparent _why_ we have to use untyped libraries in JS when we get onto things like contravariant functors, when typing becomes a real nightmare without a Haskell-like type system. Still, let me know if I'm being unfair on tcomb! :)
The code looks fairly solid to me. You've got some boilerplate i there that I'm used to my transpilier handling for me, but there is nothing wrong with when doing hand-coded JS. The only thing I'd bring up in a code review would to be to suggest using event delegation, but my mapping project puts 20,000+ points on the screen. Delegation really saves us a lot of resources and was worth the hassle.
Agree. I've been directly involved in hiring many devs, especially front-end. Have same thing to say as /u/SandalsMan.
I have been using [`lodash/fp`'s `get`](https://lodash.com/docs#get) for this purpose, but I really like the idea of a babel transform. Thanks for sharing!
Router must not be optional, it must come with the library/framework. Vue got this right. People underrate how crucial router is for SPA. If you publish a frontend lib/framework, it must come with a non detachable router, period. To understand the magnitude of the importance of router, see how it fucked up Angular 2 development and initial release date. Again, Vue got it right. It seems to be the only solution out there that makes sense.
I actually don't use tcomb much for typing functions, mostly due to overhead of the built-in function typing and / or difficulties getting flow + babel-tcomb etc. working together... it works nicely enough with typescript, much as that pains me to admit (I really want to like flow better). Beyond that, I'll have to wait for the later posts to provide any other feedback. Looking forward to it!
They are still functionally asynchronous, at least the way rxjs handles them as they don't push the value until after the current context has finished executing.
In addition to what the others have already mentioned, there are several unnecessary and sporadic line breaks incident-list.js, lines 19, 56, 57 index.html, multiple occurrences While it may only be subjectively considered, this sloppiness can reveal a disregard for code conventions that may cause issues with linters and version control comparison. &gt; I don't think that anyone should spend whole day making interview assignment I very much agree with you and would encourage you withdraw your name for consideration, letting them know the reason, but only if you are financially able to do so, of course.
Auth0 is worth looking into.
This is false.
How so? You think 0-day browser exploits are common?
Overall the code looks fine. Since you asked for a review, I'll treat you like one of my junior devs. Here are the items I would ping you on (but most would be cleaned up/clarified during the code review phase): * Code assumptions. There exist a few assumptions in your code. For instance in map-service.js, L.map is called during init. What is L? What happens if L isn't available/defined? * Order of code loading. incident-controller.js assumes that all of the other code required to use this application has been loaded and executed. There may be issues loading and executing code (perhaps network troubles?), but nothing exists to handle any missing code errors. * Exceptions thrown but not caught. Several places in this code has *throw new Error* without any try/catch. * Comments. There is a dire lack of comments in this code. I can see *what you did*, but I do not have any means of verifying if you are doing *what you intended to do*. Good developers can sling code, but great developers tell you why. The code looks solid, especially for 3 hours of work. This code would be grounds *to hire* as you show competency and understanding of javascript. You however fail on maintainability, and working on a team because of your lack of comments. Personally, I think your interviewers are being petty. Perhaps you missed out on the job for other reasons?
Yes it seems so! I came across it and I'm enjoying their API with postman examples. I may have found the solution I was looking for.
I'm confused by what the current context would mean. The observable in my example will complete before the function returns. So, as I reason rxjs is pushing values before the current context has completed. ie, if i ran `console.log(combineAndFilter(arr1, arr2))` I might get output like this `[ [31, 123], [8923, 20938], ... [n, n]]`. If the scheduler for the observable is async, then yes, the execution context will complete. And you would get undefined as log output. I hope I understood you properly. [Here's](https://gist.github.com/slmyers/a0f81f1478c4dd50845b7637abb4e773) an example that might better express myself.
If you're using a transpiler - and already assuming that non-transpiled code can't run - then why not just `idx(props.user.friends[0].friends)`? Or, better, the `?.` operator as implemented in other languages? Really, though, I still wonder if needing this isn't always the result of architectural problems, because it still always has been for me.
The only negative to the idea of transpiling down is that the big bosses (tech managers) are going to ask you what you are doing and you will have to explain it to everyone eventually. Then they will label you a over-achiever on the project and first give you a shit ton of work, then kick you to the gutter 2 weeks before production release is due. Why? because you showed yourself as a threat to others in your company and that tech manager wants to protect his job. He will need to feel like the super-senior developer at your company. When you show off you directly threaten him. And good luck showing his bosses that you had all the best intentions. They will side with him and shit rolls down hill! So FWIW if the bosses want you to code in for ie9 and use es5, then just use es5. but secretly code in es6 and transpile down some parts. for speed. That way you can hide it, and keep your job. 
How does this compare to MatterJS? 
&gt; Or, better, the ?. operator as implemented in other languages? This requires a change to the lexer and parser to handle the new syntax. I'm not saying it's a bad idea, just that it's more work.
Great work. Swipe is intuitive​ though; are there plans to implement it?
yeah fair. changes...but usually 3 years behind.
I was talking about up to date browsers. Obviously, if you're running old software, you'll have problems.
Matter.js is a great effort and project, however I decided to start Planck.js for two main reasons: - In terms of features, stability and maturity Box2D is considerably ahead of Matter.js. Box2D is used in many well known games and libraries, such as Angry Birds and Apple's SpriteKit. Planck.js uses those algorithms with some refactoring. - I personally find Matter.js internals and API unconventional and difficult to follow. For example instead of `world.add(body)` you need to write `World.add(world, body)`. It looks very strange and pre-object-oriented to me. It makes app/game code difficult to read, and makes library internal more complicated because of lack object-oriented features. I prefer a neutral and transparent architecture/API.
Thanks for the details! Excited to try this out!!
You are welcome! :)
Pretty dope, although my 2013 MBP fan is going nuts right now after an epic game of Asteroid.
I don't disagree. I think he kind of shot himself in the foot on this by using the module pattern. Normally, I'd opt for ignoring something like this given the context, but when you've already got the modules and are already passing in other dependencies, may as well be consistent with it. 
Its easy. It runs internal in the javascript-process. You just have to require a module. Check out the examples-section of rxdb.
**One important note, Shims DO NOT Cover everything** in particular these things are literally impossible without an ES6 compliant environment: - The `Proxy` object and its related handlers - Subclassing of Native classes, `class Foo extends HTMLElement` probably won't work, `class Foo extends Array` will have bugs - `eval`/`new Function` will continue to only support the version of the browser - `new.target` but its use cases do have other workarounds - `Symbol.unscopables` only relevant if something uses the `with` statement - `Object.setPrototypeOf` its supported by IE11 but not earlier versions and its how you can change prototypes of objects later which can be useful - As a consequence of not having `Object.setPrototypeOf` the prototype of bound functions is also impossible, this is useful for having functions that maintain their prototype when bound - Shared Memory and Atomics (ES2016) for sharing data across workers 
no offense to you guys, but youd think for being a panel of front-end devs you'd have a better website :) 
This looks super cool! I just played around with it and have something pretty basic running, though I've mostly been using combinations of grep and http://box2d.org/manual.pdf to figure things out. Is there documentation of the API on the github page that I'm missing? This is phenomenal, nicely done!
I prefer multiple var statements personally. And some tools, like the Google Closure Compiler, complain about defining variables of different types all in one go.
Or you learn [Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) (with a polyfill for other browsers) and use the standard.
Better than a company that jumps on every new version/hot framework as soon as it comes out.
Depends, if I am building something that I have been done before (or something similar) I can imagine which chunks will be necessary, before implementing everything. But if it's something new (for example the infinite list, that I tried recently) I will just start with one huge function that will get split up later. Another example would be react render methods. It often happens that you are building very large render functions. These will first be split up into different sub render functions, which will later be refactored into separate components. 
You're confusing "simple" with "easy". That's a big fat layer of abstraction on top, it's far more complex than the simple way out. And, no, nulls don't force your functions to know too much, you're just chaining wrong. Every function must know the API of the functions it invokes, that's simply true and always will be. Whether a function can return `null` is part of its API. If function A passes the return value of B, which may be null, to C, which doesn't accept null, then the bug is in A. And, of course you can return `null` as the actual value, just define the API to handle failure another way. I'm honestly not an opponent of reconsidering control flow mechanisms. But please do so fairly - don't say untrue things about the old way just because it's old.
Well, there's nothing you can do except use a broken Javascript from 10 years ago without modules, classes, scoped variables, promises, async, etc. In short, a language that makes your job harder, leads to bugs and dirty, abstruse codebases. Just because IE11 will not go away for at least a quarter of a decade or longer. The vendors (Microsoft, Apple) have made mistakes, so that makes Babel and progressive enhancements the only standard we have. But sure enough that has turned out to be a very interesting thing. Transpiling has become part of what Javascript is, not just for drafts and back-compatibility and it's making it flexible in ways no other language can really mimic. 
Actually swipe was implemented, just a few lines using [HammerJS](http://hammerjs.github.io/) which seems to be a standard, but then I had some issues on some platforms -chrome on android !- and it clashed with the click functionality. I think it just needed more programming, but i decided to remove it completely for now.
Only looked at one file but... for `refreshRate` I'd prefer to read, const refreshRateMilliseconds = 120 * 1000; Don't just use `let` but instead use `const` for everything unless you have a good reason to need `let`. Regarding, incidentList.init("incidentListId", function(incident){ mapService.focus(incident.point.y, incident.point.x); }); Why is this set every loop? It looks like it could done once. Your `incidentService.get().then` doesn't have any error capture. 
&gt; Standard: something established by authority, custom, or general consent as a model or example The ECMAScript committee's specifications are the very definition of standard JavaScript. Anything that doesn't follow them is non-standard. It's a model all major browser vendors agree to implement and there's a formal process for processing new proposals. Transpiling is just a stepping stone to bridge the gap between specification and widespread implementation.
Hey, thanks for review! I have forgotten to mention that it was interview to senior position and I have warned them that I am mostly doing backend stuff. Anyway I didn't make it to person to person talk to defend my code. But here are my thoughts on your points: 1 &amp;&amp; 3. This is correct. I had a thought on that while writting code and error handling makes you focus on all corner cases, creating meaningful user feedback and creating good feedback for deverlopers. IMO this is usually separate "unit" you need to handle in production code. I did not do it, because I had mock data I knew that most of unexpected things wouldn't happen so I have focused on functionality. I have wrote some throw Errors to give them a hint that I'm validating input and I know what I am doing. Anyway I agree with your point but that would be my "defense" 2. This is right. In normal code you can use libraries (or ES6 modules) to load dependencies. My reasoning here was to write own modules and load them 'synchronous'. IMO it shows that I understand module pattern and honestly there is not a long way to write own simple "require" function, since modules are already present. 4. Comments - this one is IMO tied to personal preference. In my currenct company we had this discussion and concluded that code should be self-explanatory and comments should be written only in complicated algorithms or corner cases. Why? Comments tend to outdate very quickly - and no comments are better than outdates ones :). I think think that my code is quite easy to follow so I have skipped comments. But you are right I have failed to show them that I can use them. Point taken. Would be my reasoning be "good enough" on one-on-one interview? 
Only two genders?
Your variable Wallpaper is a number and not a string, so you can't use the method `match`, which is only available on string objects. What you can do instead is: var Wallpaper = Math.random()*3; var wallpaper1 = '1'; var wallpaper2 = '2'; var wallpaper3 = '3'; if (Wallpaper == wallpaper1) { document.body.style.backgroundImage = "url(Wallpapers/Wallpaper1.jpg)"; } if (Wallpaper == wallpaper2) { document.body.style.backgroundImage = "url(Wallpapers/Wallpaper2.jpg)"; } if (Wallpaper == wallpaper3) { document.body.style.backgroundImage = "url(Wallpapers/Wallpaper3.jpg)"; }
When you use `var`, you are creating five closure functions that all keep a reference to the same variable. Because they all execute after the loop has terminated, they all see the value of that same variable as it existed after the loop terminated. `var`-scoped variables only have function scope, not block scope. `let` creates a new lexical binding for the variable in the block each time through the loop, so the closures get a different copy each time. &gt; When using an 'alert' instead of 'console.log' and changing 'i' to a 'let' it outputs something totally different. You need to be more specific. Post the exact code and the exact output. 
When JS developers now have the same tools as Angry Birds and Apple's SpriteKit, I hope to see someone us this for exciting animation based UX and games.
Are those commits in your history? I'd love to help!
Thank you! I already have a web server at `/js/server.js/` that listens on port 6969 and updates the center message ^ ^ . You can check it out! But if you see any improvements or you have other ideas, don't hesitate to make a pull request! I would love to see it ^ ^
It's not overly hard to read, but breaking it up into a couple statements would probably be a good idea. 
It's not specific to ngrx and it's not the difference between hot and cold observables. It has to do with the [scheduler](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/schedulers.md). As you can see, for constant time operations it is suggested to use an immediate scheduler. And for iteration operations it is suggested that currentThread scheduler is used. So, these type of operations rxjs should push values before the current context has finished executing. 
As it is modelling physical gender rather than sexuality then that matches up with real life. Outside SciFi I don't think there are any examples of species 3+ physical genders on the planet. There are general purpose cellular automaton runners out there which you could program with a 3+ gender model to see what would emerge.
Why not split them up? And instead of six constants by splitting them all up you could split them in two in this way right? const { params, form } = this.props; const { query, somekey, anotherKey, another } = this.props.session; When they become too long or are reaching for stuff that's deeply nested I would prefer multiple, but more readable lines, over a less readable one-liner.
It's readable when you put each variable on a new line. I find it useful because I don't have to type "this.props" everytime I want to use something from it
Even in that case, you have to think about who is gonna manage the code after you. If in the whole company everyone prefer to not transpile anything and just use standard supported-by-browsers-outofthebox js, then you stick to it.
I would also advise using a switch statement too instead of all the if statements. https://www.w3schools.com/js/js_switch.asp
I think its preference, but I'd definitely set a project limit of max vars to deconstruct. Alternately adhere to the projects line length limit.
he sounds like he's being bitchy but for some companies that 1% represents a lot of money, enough not to be able to justify to stake holders to give the cold shoulder to
I think I agree here except on &gt;to create a server-side V8 engine. In 2017, Node.js will become an engine agnostic server-side JavaScript platfrom.
so show them the benefit to the business of using a transpiler, if i was your manager i would like to see that you've thought about not only the benefits ( which we can all agree on ) but also the cost. we all want users to update :). my company dropped support last august for below ie9 as they had dropped down to less than £7k a month, since then we have seen that those users have generally updated
&gt; Comments - this one is IMO tied to personal preference. In my currenct company we had this discussion and concluded that code should be self-explanatory and comments should be written only in complicated algorithms or corner cases. Why? Comments tend to outdate very quickly - and no comments are better than outdates ones :). I think think that my code is quite easy to follow so I have skipped comments. But you are right I have failed to show them that I can use them. Point taken. Your code is not as easy to follow as you think. Here are some questions I ask myself: --- **What is this code's purpose?** I had to come back to re-read your post mid-review to get some context. Add a readme. **What dependencies does each JS file have?** I mean dependencies on each other and on libraries. * Do the JS files have to be included in that exact order? * If I remove the Lodash dependency from map-service.js am I safe to remove it from the whole project? * How do I know map-service.js depends on Lodash in the first place (answer: ctrl+f "_.")? * How the fuck are dependencies being passed around anyhow? Oh a global `window.task` variable, of course. So obvious. **How do I actually use each exported service?** I'm not sure if you're aware of this but **JavaScript is a dynamic and weakly typed language**. I have absolutely _zero clue_ what each function accepts and returns. Do you seriously expect people to open incident-service.js, find the refresh function, scan for every possible exit point to see if it returns a Promise or not? Not to mention even knowing what the Promise can contain. Is every incident object in the array guaranteed to have a particular property or are some optional? --- I'm not even going to type up any more questions. Undocumented JavaScript makes me angry.
No :-)
This is bad mojo. Node is a dependency of NPM, but this is not true in reverse. You can run Node and some Node application without ever using NPM. To me confusing this point is no different than the confusion I saw in this subreddit between jQuery and JavaScript 7-4 years ago. jQuery used to be a religion that most developers couldn't live without. Now it is largely considered a legacy product. At some point Node will out grow NPM. NPM's biggest strength is that it is included with Node by default, but that doesn't mean its use is forced on anybody writing an original application... at least not yet. Just like Node is looking to become engine agnostic I would also like to see multiple various distribution options available in an agnostic fashion. Integrating parts of NPM into Node core defeats this. I understand NPM is convenient and popular, but it isn't a good fit for every scenario.
Oh yeah, what Parker square of π.
Yeah, agreed. Have you seen [`daggy`'s master](https://github.com/fantasyland/daggy/tree/master), though? I think the coming update will make it _much_ friendlier for REPL use!
You might be able to get around it if the function is in a global namespace (i.e. on a window object). You have not pasted the whole file so not sure, from the code you have shared it looks like it might be. To check, go to browser console and type validate_ssidchar, see if it complains about being undefined. If not, simply reassign it by typing `window.validate_ssidchar = function () { return true; };` If yes, then make the same change in your file, by replacing everything inside the validate_ssidchar with `return true;`
Yep, it's a cool new approach. But I don't think there's any solution to the constructor issue because javascript doesn't really allow dynamically assigning constructor names (aside from using eval). Afaik, it has to be statically written out in order to get a clean type name in the console. Which is not a huge issue in general, I just happen to enjoy having it (at the expense of losing a convenient abstraction and lots more typing).
[Hahaha yes!](http://i.imgur.com/TkyAaq4.png) Thank you 😆
Mm, agreed. For me, at least, I see Fantasy Land very much as a gateway to something like PureScript or GHCJS, and I suppose there's only so much one can do to reproduce another language's paradigm and style. It does beg the question as to when one is probably better off using a language _specifically built_ for this style. I'm perhaps a little biased, though, as a shameless PureScript fanboy. O:)
the next question is: How many clients will break when they try to connect to or show this SSID in their GUI?
I take shitposting my wifi very seriously.
Literally shitposting. GG
Interesting. I want to do a drink water reminder when I get some free time 
Empty recap of a previously posted article on outdated JS libs in the wild. Still no demonstration that there's a real security risk anywhere, just assuming outdated === vulnerable.
You might be able to bypass the validation, but the firmware in the router might not be able to store a character with that many bytes. Most definitely the firmware is written in a low level language that specifies memory location size... It would be funny if you bricked your router. :)
Oh nice.. so I can run node.js on Nashorn? (No, I obviously can't. Multi-engine might be a better term than "engine agnostic")
Try putting this in promise handler anonymous functions. :-D
I think I love you.
Isn't that just a dropdown? I'm not sure what you are looking for.
Majestic.
I will not be surprised if someone made Node.js run on Nashhorn next year...
&gt; I can create that dropdown and in-build playlist creation form. Problem is dynamic positioning of dropdown depending on clicked element and taking care of all the cases of positioning. 
Relevant username?
Please say you are an actual Dr
holy crap wtf
Yes, I did my doctorate on shitposting.
http://tether.io/
Wow, that implementation looks exactly like how I just did sharing buttons on my site.
Pretty sweet when you don't have to implement it then!
I'm doing this tonight lol
No problem. Btw. thank you for the inspiration, just finished playing with my router :P
Anything dealing with the character would treat it the same as a two letter byte array, though. 
[Done.](https://bitbucket.org/padavan/rt-n56u/issues/744/restriction-on-special-characters-in-ssid)
Yes, but in most cases it would just store the emoji as two or more chars. Yes, some edgecases might break something, but ssids are usually stored as an array of chars (or similar) in the first place, because they are intended to be multiple characters long. Combine that with something to make sure that your string termination is valid and that you're not vulnerable to sql injection and you've got your butt covered.
It's not a hard and fast rule, but I often find that if the data is in a well structured hierarchy, then the boundaries of nested keys tend to match up pretty well with where I want to consider breaking things out into HOCs or subcomponents. While that means more code obviously, it cuts down on the need to destructure as much in any one component and often survives refactoring more easily as well as ending up with the component structure I probably eventually would have broken things down into anyhow.
That's a great question! Flawless object reuse and efficient memory management is a top goal for this project. However it is not done yet, mainly because Box2D internally manages dynamic memory allocation (there are createBody and createFixture methods instead of addBody and addFixture) and I need to (and will) do additional refactoring to let API user reuse object.
I don't like nested destructuring at all. Just more annoying to read in my opinion. If you're just destructuring an object one level deep, you now have a set of curly braces, and within that are tokens, each of which is a variable that you can use. As soon as you start destructuring nested stuff, now you have a mix of some tokens that aren't actually available as variables, and some that are. Sure, it doesn't take long to figure out which one's which - especially with syntax highlighting - but I'd still say it adds an unnecessary amount of cognitive load for no good reason.
[this](http://stackoverflow.com/questions/14389420/how-can-i-model-a-backbone-js-application-with-uml) might help.
Can be done, even with native OS X notifications
&gt; The discussion skewed heavily toward npm because npm devs swarmed the thread grandstanding about how difficult their job is and how amazing npm is. It's not at all suspicious that isaacs (the npm CEO) is quick to jump in and suggest not doing it
The important part for us: &gt;Chrome 57 will delay timers to limit average CPU load to 1% of a core if an application uses too much CPU in background. Tabs playing audio or maintaining real-time connections like WebSockets or WebRTC won’t be affected. That's great news IMO. There was a lot of FUD with devs over whether their `setInterval()` would start behaving badly or playing music on another tab would become impossible.
CrossCode http://www.cross-code.com/en/home It was made with the ImpactJS game engine http://impactjs.com/forums/games/crosscode-demo
Honestly everybody with a brain should suggest not to do it.
Do what?
I still don't see why they should put it into core, though. One reason being as you stated - there are other alternatives.
you never know what the future might bring. Maybe npm will merge with yarn. I think npm is easier to type than yarn. Thought I do get a chuckle every time that I speed typo yarb or yarm.
Doing this seems to break authentication though - it's also important you use SSH as telnet will not work (the character isn't sent as a unicode one) Did you have any problems with WPA2 Enterprise (just hangs) or Personal (says wrong key) ?
It would be helpful to see the code but I bet you need to prevent default in your function like this: function linkClick(event) { event.preventDefault() .... }
Same router here actually, but with Asus-WRT (not the stock one) and probably a bit older.
Wonder if just spoofing your email address in the commit might have been enough to let you get away with it... Who would have merged a PR like that anyway though?
Indeed. When I first saw this, I was like "no way that will work. there's got to be a server-side check somewhere, and this will be too much of a pain for it to be feasible for my lazy ass." But as soon as I saw your screenshot, I laughed for a few seconds, and then kicked into action.
&gt; WebAssembly (not supported by your browser) My browser supports wasm, but I see this message. Looks cool though! I was curious if people were experimenting with languages intended for wasm compile targets. Thanks for sharing.
Wasn't even PR. I managed to get one of the IT guys GitHub login and worked from there
Works on an [Apple Airport Extreme](https://imgur.com/a/EJJ9w). 
&gt; Other than Ionic, is there any other choice? Implement css media queries to change view depending on device. 
This is painful to see in production if() return true return false
Almost anyone would just allocate the maximum SSID length+1. If it interprets the data as chars it will also read as an array, and the N-byte char will just go into N chars. Char N+1 will be a null char. Ofc, someone could always have intentionally tried to make a breakable function.... I'm more surprised their client side validation is stricter than their server side validation! 
If it is too complex for NPM then Node can have my biddle tool to solve this problem. It would only be a couple lines of code for Node core. Let's not make this more complicated than it needs to be. https://github.com/prettydiff/biddle/
I like that idea, thank you!
When you do something like this: &lt;a href="#" onclick="func()"&gt;Click Here&lt;/a&gt; The # refers to an id on the current page. So if you have an element further down the page with an id, for example &lt;h1 id="scroll-here"&gt;Heading&lt;/h1&gt; You could scroll to that location on the page by doing: &lt;a href="#scroll-here"&gt;Scroll to heading&lt;/a&gt; According to the [w3c spec](http://w3c.github.io/html/links.html#attr-hyperlink-href) (and contrary to what some people think), the href **IS NOT** required. If it's not present, the element will still have the anchor styles, but won't scroll to the top of the page like is happening to you. Try removing it and see if that fixes your problem.
&gt; one would hope they don't just depend on JS validation. I'm way beyond hope when it comes to firmware in consumer networking gear. There was that time [Netgear DDoS'd the University of Wisconsin by hardcoding their NTP server into a router with a buggy NTP client.](http://pages.cs.wisc.edu/~plonka/netgear-sntp/) There was that time [Belkin routers worldwide stopped working because they couldn't phone home.](https://techcrunch.com/2014/10/07/belkin-acknowledges-its-routers-cannot-access-the-internet-and-issues-workaround/) Then there's the all the security bugs combined with opposite-of-user-friendly update UIs that ensure most users will *never* update. Then there's how often a lot of these things need frequent reboots because the NAT engine dies for some unknown reason, etc. A bug that bricked the router on bad user input wouldn't surprise me at all. It's amazing that for how important consumer WiFi gateways are these days - and for how long they've been around - so many of them are utter, irredeemable pieces of shit.
Can't see any hint from the screenshots. My guess is that either the posted data doesn't meet the requirements set by the web server, or there's a problem in the server side's script that processes the posted data.
If your HTML code is like this. &lt;a href="#" onclick="doTheClick()"&gt;The Link&lt;/a&gt; Change it to: &lt;a href="#" onclick="doTheClick(); return false"&gt;The Link&lt;/a&gt; 
Ha, this ssid popped up on my phone as a network to connect to while driving home...funny that I see this post on the same day.
Idk. Sqlite seemed plausible to me. But similar things to SQL injection can be done with text based config files.
Hmmm I don't really like his example. Using the semantic functions makes the code much more readable. it could be improved yeah, but I still like it more than the reduce example. That being said reduce is great also.
Great. Do you want PRs or do you consider this a private project?
Sorry! Had to copy you! This is hilarious. Here's my [shit WiFi](https://i.imgur.com/VDFCzaH.png) 
God dammit why didn't I think of that joke?
Yes: &gt; (assuming you're in a situation where you really need to do the installation on the production machine) But that's the case they seem to want to improve. 
I like your way of thinking!
And this is why we don't rely on client-side input validation, guys.
Well, this is an interesting project, but see at least three problems 1. This script will be really huge and you probably won't be able to let it be loaded by the servers. Or what is a *Honey page*? Kind of a bot? 2. What does it mean, that the server has introduced some changes into the script? Why is this interesting? 3. The main problem are x-site-iframes, but this depends on the way, on which you get the script on the page. Angular has created an AST for parsing JavaScript snippets in template, maybe this is worth to have a look at. If it is all about checking to which version of JavaScript the scripts are aiming, maybe you don't need an AST and just checking for some keywords and operators is enough. But I'm not sure about that. Finally it might be interesting to look at how a Browser-plugin like Ghostery works, how it collects the data and what are they doing with the data.
&gt; Can I just make a large javascript object with 1000+ keys? Yes, you can. &gt; The exact maximum limit of an array is 2^32 - 1 or 4294967295, due to restrictions in Javascript's memory. The number of items, also known as the length property, cannot be greater than that. Other properties, namely the methods, are a matter of agreement: the ECMA 262-3 standard. *[Source](http://4umi.com/web/javascript/array.php)* But you should rethink your API.
If it's not actually a link, where I can't open it in a new tab or bookmark it, then use a &lt;button&gt; rather than an &lt;a&gt;. Also solves any page jumps
You're welcome to try :P
No, just do it, I'm waiting
Amazing work guys! I just played around with if for a fe minutes and I love it! There is only one thing that I'm not fan of — name. Sketch feels like a reserved name for product by Bohemian Coding (the UI design tool). Did you consider it as a problem for your brand at all? As far as I noticed I'm not the only person who isn't sure about this decision — so many pals on HN voice similar opinion. Great tool by the way. I love it and I'm going to use it as often as I use CodePen ❤️
Feel free to submit a pull request https://bitbucket.org/padavan/rt-n56u/
jQuery getJSON callback only has one argument. http://api.jquery.com/jquery.getjson/ .done(function(data) { $.each(data, function(i, country) { // now you can access country $.each(country.beer, function(i, b) { // now you can access beer
Yeah, I'm only a beginner, but couldn't you just do return(ch &gt;= 32 &amp;&amp; ch &lt;= 126); since it will evaluate to either true or false anyhow? 
With or without parens return ch &gt;= 32 &amp;&amp; ch &lt;= 126
Thank you for your great and simple explanation dude!
So to maintain accessibility when you anchor doesn't need an href I guess the best option would be to go with a button element instead 
Kinda. Was trying to say That I use that when I can so my code looks full synchronous. Was a bad choice of word. Sorry.
Thanks, but that doesn't really answer my question. I want to know how do we model the models, collections, views etc 
You're trying to use `var location` as a global which is already bound to the `window` object. This version works: http://jsbin.com/gibigicoko/edit?html,js,console,output
Yep! Very well put!
Mine gets escaped "server side" to `&amp;#128169;`, so I guess that's in the router firmware. Edit: apparently it's getting escaped on the request, because it's performing a GET request with url encoded parameters, so "💩" --&gt; `%26%23128169%3B` --&gt; `&amp;#128169;`
Hi, I'm the author of the article! While I agree that semantic functions make the code more readable, it boil downs to a readability vs. performance trade-off. And one has to be wary of this tradeoff, especially when dealing with production applications; where minor things like these tend to add up! :) 
Look on the plus side: their developers understand the concept of "never trust the user". That's pretty rare in consumer hardware.
Ah, now I see it. Worked perfectly. Thank you so much for your time! 
You're right on both points. `.entries()` returns pairs.
Is this for a school assignment? 
Hahah! I, sure, do!
[removed]
&gt; which can be avoided with a brief before-thought! Yes. That "brief before-thought" should be "should I do this". If linear algorithm on small amount of data is going to choke your clients, you probably should change your approach holistically, not try to optimize it at cost of readability.
One benefit reduce has over for each is being able to produce a new value without using side effects.
In the final example (before the timing) the code has const followers = node.followers.forEach What is the purpose of the followers variable? It doesn't seem to get used. 
It's a side effect if it's undesirable or unexpected. Otherwise it's just an effect. Also mutating a local variable has no observable effects outside the function you're using it in, so the practical implication of having local mutation as simple and transparent as this is precisely none. And last, because closures in JS can produce effects and side effects, using reduce is no guarantee you won't produce effects or side effects. People buy too much into the functional cargo cult. 
Well there goes my plan for the day, fuck.
Awesome article! You've got a great attitude and very good english.
Unless you're running ES6 in a production environment, which I highly doubt, your code is being transpiled anyways. Any "performance trade-off" is a product of your imagination :)
Good point!
This looks pretty slick. Going to try it out on the weekend.
Is this a race to get to the shortest but hardest to read one liner? I have flashbacks to my C days now.
Wow, I've never had gold before. Thanks stranger!!!
32 bits, actually.
OMG can i do this with any router or only this Xiaomi with custom firmware??
&gt; Is this a race to get to the shortest but hardest to read one liner? As a scripter, pretty much all programming looks this way to me. Mostly anyway...
/r/codegolf
**Here's a sneak peek of [/r/codegolf](https://np.reddit.com/r/codegolf) using the [top posts](https://np.reddit.com/r/codegolf/top/?sort=top&amp;t=year) of the year!** \#1: [Beautiful music from a tiny bit of code.](https://np.reddit.com/r/codegolf/comments/4acxcy/beautiful_music_from_a_tiny_bit_of_code/) \#2: [Ohm - a new golfing language inspired by 05AB1E and Jelly](https://github.com/MiningPotatoes/Ohm) | [0 comments](https://np.reddit.com/r/codegolf/comments/5w7zai/ohm_a_new_golfing_language_inspired_by_05ab1e_and/) \#3: [\[js\] return true to win](http://alf.nu/ReturnTrue) | [0 comments](https://np.reddit.com/r/codegolf/comments/4wem09/js_return_true_to_win/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
That's precisely the problem. If one were to fill more than 1/2 of the maxlen(ssid) with unicode characters, you'll overflow the allocated memory. As I said before, it's fine (at least in this particular case) but is dangerous.. Also, on embedded devices, it's certainly possible that they wouldn't just allocate maxlen(ssid), they'd actually measure the string length and allocate just that amount of storage, at least in some layers of the application. For different implementations of string length, it's possible that they could return different lengths for unicode vs ascii. 
For someone unfamiliar with javascript or custom firmware, is this ELI5-able or a bit too complex for a layman? I have an ASUS router, but currently at work so I'm not sure of model and specifics. 
Awesome that worked for me on a Tomato router.
Didn't for me on tomato. WPA2 Personal
you're welcome! :)
Tried this on my consumer modem, but it posts to a script that also validates the characters :( No emojis for me
Great read! I was a little disappointed you didn't actually explain a bit more about webpack but I suppose it's not that hard haha.
If this is for a personal project you may want to check out the IFTTT Maker Channel. Makes API interactions similar to your request trivial.
Not as cringeworthy as: a) Confusing Java and JavaScript b) Confusing Javascript and Java**S**cript If this is an attempt at trolling then that just adds further to the cringe.
Tried this on my Unifi APs, and the interface allows other UTF8 but not emoji. (I was able to create a second network called ↑↑↓↓←→←→ⒷⒶ, for example.) [The forums did have a solution, though.](https://community.ubnt.com/t5/UniFi-Wireless/Emoji-SSIDs/td-p/1661513)
It allows me to post from there, but when I try inserting the same info into the quickstart (https://developers.google.com/google-apps/calendar/quickstart/js) I get the 403 error, even though it's able to return things from the calendar.
Thanks! I actually just started using webpack for modules, hence the lack of detail... hehe. When I get more familiar with it, I'll write more about it. :) 
Please be a troll. EDIT: hahaha guess not.
So just spoof the request with postman, but without the escape char. 
You can probably do it. You have to go to the wifi name page on your router, bring up the JavaScript console, find the wifi name validator function, create a new one with same that returns true, put special characters into your wifi name, done! Any of those steps you can Google our get help with (also via the reddit community tech support irc channel). 
hmm...I wonder if my Netgear router can do this (i'm not home to look).
Exactly! 👏
This is server-side code, so there is no "choking of clients"! To rephrase FormerGameDev: &gt; 99 times out of a hundred code readability trumps most else, but in the case of multiple iterations over a list, you always do that shit as short as possible. 
For what it's worth I actually think you older code is more readable, here is how I would have improved it: const followers = (nodes) =&gt; { return _(nodes) .flatMap( node =&gt; node.followers) .filter( follower =&gt; follower.email) .map( follower =&gt; follower.email) .uniq() } I think some would disagree with this, but I personally favour readability in code and I think your old code is easier to reason about. As a bonus, the time required to complete this also faster. 
Unfortunately the only real "community" is the actual CanJS developers on the Bitovi/DoneJS forums. **Edit: As someone who is using CanJs 2.3 as well and has looked for community driven resources. I feel your pain.** 
I hate to be that guy, but I strongly disagree with every point of this article. Not only that, but I feel like it will actively encourage poor programming practices, as fat arrow lambdas not only increase readability but also save you from having to bind this all over the place. 1. This truly makes no sense to me. Anonymous functions give line numbers, which is all you need to figure out where the bug was, and you're always debugging with source maps. If you're dealing with minified code, function names have been stripped out anyways, or renamed to single letter names like a, b and c, so anonymous functions leave you no worse off. I really don't understand where the author is coming from on this one. 2. Honestly, and I'm not trying to be contrarian or anything here, but as a fairly experienced JS programmer, the second example is _so_ much more readable than the first. Having to hop between your Promise object's definition and the (let's be honest, single-use) functions defined for each section of the Promise will be confusing, and it will be hard to trace the logic. On the other hand, having all the logic for the Promise right where it belongs with anonymous functions, rather than spread across the map, will make the logic of the code much more easy to follow. Just look at any popular open source JavaScript project that uses Promises. They all use anonymous functions for .then and .catch. For example: [React.js](https://github.com/facebook/react/search?utf8=%E2%9C%93&amp;q=promise), [Angular](https://github.com/angular/angular/search?utf8=%E2%9C%93&amp;q=promise), [Microsoft's VScode](https://github.com/Microsoft/vscode/search?p=2&amp;q=promise&amp;utf8=%E2%9C%93). These are intelligent programmers working on difficult projects. I doubt you will find a single one that doesn't use fat arrow functions with Promises. 3. I feel like 2 immediately disproves this. When are you going to reuse the .then of a Promise on another Promise? In practice? Really? Truthfully? Never. (Again, if you don't agree with me, just search around Github and see if you can find other programmers in popular OS JS doing it.) If you were going to reuse it, you'd have wrapped the entire execution of the promise in a function instead. You never reuse *just* the then() bit of it. Yes, named functions do have uses, and making every single function in your project an anonymous function would probably be too much, but this article goes far too far in the opposite direction. I don't disagree with this entire article. I think that functional reuse is a good thing, and I find the examples the author gives of fat arrow functions to be good examples. He just needs to broaden his acceptance of anonymous functions a little. :) 
If you're using bluebird for your promises, then it's the more memorable `await Promise.delay(1000)`, or you can tack it on to the existing promise (which is particularly handy when you're not using `async/await`): fetch("http://some.url.com") .then(res =&gt; res.json()) .delay(1000) .then(() =&gt; this.setState({ isLoading: false }))
Ah excuse me! These are two phones; or lets say one admin-page and one client-page. I want to to let the client listen for instructions about background-color change. So when I want to change the color background of the client.html page, I want to send that code via the admin. (send #FFFFFF via admin, receive background-color #FFFFFF. Hopefully this gives you more information about this concept. 
&gt; 5ghz only for the worthy. and those not on the other side of a wall
&gt; I suspect you already know that, though. Yes, but I don't know which part you're trying to address. When I'm saying "local variable" the implication was that it's not referenced outside and/or it's not a mutable composite object/array, i.e. it's entirely local. &gt; Add on to that, that it's just plain smart to use reduce in place of multiple iteration steps on it. Reduce also runs internally "multiple iteration steps" so I'm unsure why regular loops are described in such a biased way, as if to seem slower or more complicated. Reduce, filter, map, etc. are just `for` loops packaged in functions. As for whether it's smart to use them: - If the problem cleanly falls into one of the categories you list, instead of multiple categories (which happens a lot in the real world). - If the compiler/runtime doesn't penalize using functional constructs vs. native loops. - If the functional expression is shorter and cleaner than an alternative expression (this varies on a case by case basis). - If you have a reason that offsets one of the other "ifs" above, such as needing to dynamically inject and compose collection processing closures. ... then yeah, it's "plain smart". But without considering those "ifs", it's not plain smart, it's plain cargo cult. 
Go with `for ... of` and use `break`. [See here](https://www.reddit.com/r/javascript/comments/5zhhur/javascript_patterns_wrangling_arrays_like_a_boss/deyphdo/).
Replying so that I can do this later
Heroic 
Yeah, it's possible, but quite rare (I can again point to the examples I listed of open source projects never doing it). I've never done it myself, and I just can't imagine why you wouldn't just abstract out the entire promise, rather than just the then(). 
May I ask why you'd doubt that though? All major browsers have 95%+ ES6 support.
Please make a tutorial on how to do this. I would love to change my wifi ssid to an emoji as well. 
Check out https://github.com/asvd/jailed It'll give you what you're looking for in a much safer way. Just looking at what you've got, I could break out with escaped braces. Sandboxing JS is subtler than you'd think! Good luck and cheers!
Anyone using a Fritz.Box? Can't find the .js script function to change.
I think in that case I would just have an overall transformation function that called .then() on whichever promise would fetch the data in the correct way. I can see why you'd choose to do it your way, though! I find the concept of naming a then function to feel very unnatural, but there's nothing inherently wrong about it. :) 
Thanks for the pointer. What do you mean exactly by "break out with escaped braces"? Could you give a specific example?
ah, what a relief
Always, my dude. Always.
Try `safeEval("} alert('hi'); {")` The first brace closes the with, and the code after it is run in global scope. The last brace is just to make sure it's still valid syntax. And scanning for braces can't work (since user submitted code needs them) and scanning for balanced braces needs to handle utf8 escapes and comments and and and. And that's not even getting into other stuff, like accessing window through various prototypes, etc. Jailed works sort of how you're doing it, but also runs the code in a worker (or iframe) to control the document level scope.
You mean irredeemable pieces of 💩.
Oh and I didn't even think about: `safeEval("setTimeout(function() { console.log( this ) }, 0)")`, which I'm pretty sure will log the window object, since the timeout is run in the global context.
Mine shows up as \&amp;#128169; which is the poop emoji in text form
for that one, I can add setTimeout and setInterval into the with statement.
&gt; validator.ssidChar() How do you figure out what the router-specific function is? I searched through the source code for mine but I imagine there's a simpler way (console?). 
Then you have other options: like to use [battle tested solution provided by lodash](https://lodash.com/docs/4.17.4#lodash) that comes with small peformance overhead still retains readability.
TP-Link?
Nope. Motorola gateway. And I didn't see any .js files, only .asp
I think you have started something here. Soon all public wifi will be this way. You won't know if you should join a turd, a middle finger, a pedobear or a banana
We should decouple only *some* methods from their objects. Data often has rules that make it valid or not. Let's say we have data representing a playing card: const card = { suit: 'clubs', rank: 2 }; There are rules that make this valid or not. The rank, for example, must be a whole number from 1 to 13. Anything else would make this card data invalid and meaningless. But if *all* methods are decoupled and the data is public, then every corner of our application is responsible for knowing and correctly enforcing the validity rules of every piece of data. It would actually be better if we pick a small handful of functions and decide that only those few functions may directly access the data and only those few functions are responsible for knowing and correctly enforcing the validity rules, and all the rest of our application must access the data only indirectly through one of those privileged functions. Except... we've just re-invented methods. Ultimately a method is just a function that we grant permission to access data that we keep private from the rest of the application. Map, reduce and filter are indeed good candidates to be ordinary functions because they can do their job *without* access to the underlying private data, but just be careful not to blindly do this for every method ever. Neither plain functions nor methods are the best choice in every situation.
Time to make a 15 part youtube tutorial for plebians like myself who will watch every one of them to do this to my wifi
I do not consider it a private project and I like to make it a community effort, however I prefer not to diverge from Box2D (which is actually a private project), so it depends on. If it is bug fix or local improvement, it will be merged as soon as possible. If it is new feature we can try to find an extension point to allow external extension. If it is a general improvement we will discuss it...
When in my career will I get to the point of needing something like this? I want to learn it and get better at algorithms, but looking for motivation 
I hereby declare you an honorary Australian
Yup, came here to say basically this. It's a lot easier to see the steps being taken at a glance, easier to understand than `.reduce`, and only requires 2 steps of indentation, rather than the "improved" version's 6 levels of indentation.
What's your general opinion on opinions in general? Also, would you consider changing its name from Sketch, since that's an established design tool?
It would just not "catch" half the string, or tell you the string is too long. The serverside must anyway always check inputs. The input validator would support the same charset - or you have another problem.
Fritzbox uses luascript on their device It checks the input on the router I believe
Different companies have different requirements. Many enterprise companies have a drastically different browser demographic, or some other internal pressures. But really, the real reason in my opinion is that it is relatively easy to transpile via Babel and have 100% support (because what comes out the other end is ES5). And these transpilers are in many cases very clever. You can have the best of both worlds: pretty looking ES6 in your source code, and more performant, nasty-looking ES5 than you'd ever care to write in your prod bundle.
If you write the type as generic and then use it with an instance that satisfies the generic then you don't have to explicitly cast it. Typescript will infer the type from the passed parameter. As a simplified example: interface Foo {} interface Bar extends Foo {} function Bizz&lt;t extends Foo&gt;(Bazz: t) {} let buzz: Bar = {}; Bizz(buzz); On that last line typescript will infer that for that call to Bizz t is type Bar. No need to add the type: &lt;Bar&gt;Bizz (buzz);
Ah, nice. In that case, do you have any solid info on V8 performance of ES6 methods vs their ES5 equivalents? I write ES6 for Node environments as well, but it's still churning through Babel. So I've never really looked into perf.
Good article but are any of these really frameworks? React comes close but it's really still a library. 
!!! Thank you! I wanted there to be something like this, but didn't have much hope that there would be. You've saved Christmas.
Fantastic! Thank you!
While `reduce` can certainly sum numbers, it's a very powerful construct that can "sum" many things. Suppose you had a list of produce, and you wanted to create a list containing each category: var myItems = [{ category: 'fruit', name: 'peach' },{ category: 'vegetable', name: 'carrot' },{ category: 'fruit', name: 'apple' }]; Where the categories are: `['fruit', 'vegetable']` with reduce, it's: myItems.reduce((cats, item) =&gt; { if(cats.includes(item.category)){ return cats; } else { return [item.category, ...cats] } }, []); Again, you're right that you can achieve this using `forEach` with effects, but I'd argue that there's large benefits to coding with expressions that are _referentially transparent_
Yep, my bad, looks like I got that particular word wrong! 
How did you found that? Can't find similar page on my WNR3500Lv2.
A framework is a "one-in-all" package to solve your problem A library is a module that can be used standalone but usually needs other packages to leverage it's full potential and solve your problem
Cool, that makes a lot of sense to me! I had always assumed that "framework" was a catch-all phrase, but apparently not.
You should try to learn the common collection methods. They come from functional programming, and they are used in just about every language now. In javascript, they are limited to arrays. So look into array manipulation in javascript. But you can convert any object to an array with Object.keys(yourobject) and then use any array method on it. Using functional style manipulation can make your code a lot more readable. And since you are no explicitly iterating, less prone to off-by-one errors. Using array methods won't magically make your code better under all circumstances, but it is good to favor them where possible.
I am extremely jealous
Actually dealing with this post would probably require another blog post, sigh. :P I knew that my TypeScript part would be the most controversial, so I buried it deep in the article so that everyone would miss it. :) &gt; (It's a lot more than just running tsc --init!) In the article, I was just referring to starting a new project, which is indeed as simple as tsc --init. :) &gt; And Typescript still has some rough edges around using it: dealing with typings for external libraries is still not ideal (despite vast improvement on that front), sometimes the type-checker's errors are arcane and hard to understand, much less fix, and there are some perfectly reasonable patterns that are just nearly-impossible for the type checker to understand. Arguably true. npm install @types/fooframework is incredibly easy, but there are a couple of old/outdated definitions. I'd say 1 in 100 type errors are weird and I don't understand them (or are errors on the wrong thing), which is a pretty good ratio IMO, but it can be annoying in rare occasions. As for the reasonable patterns that can't be checked, you can always fall back on `any` if you really get in a bind. &gt; And I've found the documentation on TS to be in a not-great state: there have been so many big changes recently (largely in the TS 1.0 to TS 2.0 migration) that a lot of the resources or documentation out there is just out-of-date. This is mostly due to out of date blogs and SO answers, which I'll agree is another bummer. The actual TS handbook is pretty good. I admit to getting most of my documentation straight from the PRs submitted on GitHub, which may not be the best place for beginners to start looking. :) &gt; At the end of the day, people should ask "Does the benefit of preventing the bugs that TS will prevent outweigh the cost of using TS?". In a lot of cases the answer is "Yes, definitely", but not always. Your overall post perplexes me, then! You've outlined a number of small issues with TS, but you haven't really illustrated any killer cases where JS would really excel and TS wouldn't. I would argue that the advantages TS brings are so great that even in the face of the issues that you bring to the table, the number of such cases are vanishingly small. (I'll admit - I've written something like 30kloc TS code, so I do have a tendency to gloss over some of the more rough edges as I don't really run into them any more - it's good of you to remind me of them.)
Wow. Is that the Official use for "^"? I always wondered. 
It's chocolate ice cream.
https://github.com/jayphelps/git-blame-someone-else
You can not prevent it, if you are using the node repl for this, i would suggest you use the vm module, to run code in a more sandboxed environment. 
Sigh, "Not a Number" does not mean it isn't a "number", it means the it is not a mathematically valid number, e.g. 0/0 has no logical value but the /type/ of the value is still a number. I blame the IEEE for the confusion around this, but it really should not be hard for anyone who actually thinks about how numbers are represented on a computer.
Ya, I prefer to stay away from non standard usage, stick with esnext and just follow proper standards, small medium large and even massive apps have been problem with the lack of static typing. I suspect you come from a back end background as no developer who started on the from end that I have ever worked with wants to touch typescript, like myself they all prefer to remain as close to standard as possible, while back end guys moving to the front love it. I don't doubt that it may have some benefits, but those were more prominent before es got a major boost in quality and capability. 
You can't stop it by stripping objects: `_window = (function(){return this})()`
It seems you have already drawn the conclusion that functional programming has no merits and only serves to confuse programmers steeped in OO, and so I believe anything I argue will be scoffed. One thing you should realize is that "clear" to you, could be "muddy" to others. `forEach` is for applying side effects to items in a collection. `reduce` is for **reducing** an array to another value. You're using `forEach` to **reduce** values, and so my argument is that your intent would be clearer with the `reduce` method. Just because you have a better understanding of how `forEach` works, doesn't mean using it is clearer to someone who also understands how `reduce` works. Regardless, I prefer to optimize for code clarity rather than preemptively optimizing for performance. Sure, the `reduce` implementation may take slightly longer for large arrays, but the mental overhead you're introducing degrades the long-term maintainability of the code.
Refactoring has limited effectiveness with standard javascript because of its dynamic types. Adding types makes refactoring more complete and safe because there is more information available. You can also get complete intellisense instead of just code completion and spotty type detection. Intelligent tooling is the entire reason why typescript exists. You should watch a demo of it. It brings a lot of smart tooling abilities that is very nice to have in javascript.
Thanks, it was a [great success](http://imgur.com/pfjGsGu)!
Can someone figure out how to do this on Unifi?
I agree with you in theory, but in practice server side validation is frequently not done. Just being a realist.
Now we need a screenshot of your WiFI SSID in the computer's GUI.
I managed to do this on a vanilla netgear "genie" router. Open the frame for the wireless settings 192.168.1.1/WLG_wireless_tri_band.htm F12 for console type "checkData" in console, that prints the function. Copy the result into notepad and edit it as: checkData = function() for the first line instead of "function checkData()" Look for and delete (or comment out) if (cf.ssid_an.value.match( /[^\x20-\x7E]/ )) { alert("Character is not allowed in SSID."); return false; } and if (cf.ssid_an_2.value.match( /[^\x20-\x7E]/ )) { alert("Character is not allowed in SSID."); return false; } paste the whole thing into console to redefine the function. Now you can use the emoji values.
Or, you just have a terrible AP/client. Source: CWNA
I think he means a non mobile screenshot
Why not stick a `debugger` or a breakpoint between the two lines? This is silly.
That's what Iowa would think too
&gt; I'm now banned from using government computers in my county Out of curiosity, who issued the ban?
[removed]
Suppose you needed to do this for two arrays. You may be tempted to do something like this: var catsIndex = {}; myItems.forEach((item) =&gt; { catsIndex[item.category] = true; }); var cats = catsIndex.keys(); var catsIndexOther = {}; myOtherItems.forEach((item) =&gt; { catsIndex[item.category] = true; }); var catsOther = catsIndex.keys(); This is brittle, prone to error, and isn't DRY. Consider an alternative approach with reduce. Since we're using a pure function, we can abstract it for better reuse. function byCategory(cats, item) { if(cats.includes(item.category)){ return cats; } else { return [item.category, ...cats] } } const cats = myItems.reduce(byCategory, []); const catsOther = myOtherItems.reduce(byCategory, []); Building functions that are referentially transparent isn't just "cool" or "cultish," it has real benefits that real programmers use every day. 
Apparently we do. 
&gt; Suppose you needed to do this for two arrays. You may be tempted to do something like this: Believe it or not, I'm familiar with the concept of code reuse, so you need to take your straw-man elsewhere. Code reuse and DRY has absolutely nothing to do with whether you're using `.forEach()` or `.reduce()`. function getCats(items) { var catsIndex = {}; items.forEach((item) =&gt; { catsIndex[item.category] = true; }); return catsIndex.keys(); } var cats = getCats(myItems); var catsOther = getCats(myOtherItems); **EDIT:** Just for the sake of being comprehensive, the same technique can be used with reduce, but thing is, I don't care if I mutate when I do it safely, or with purpose, while some people adopt religious silver bullet mentality that only ends up harming them and their software: function getCats(items) { var catsIndex = items.reduce((catsIndex, item) =&gt; { catsIndex[item.category] = true; return catsIndex; }, {}); return catsIndex.keys(); }
Of course, and that's why I posted the god-awful code that I put in as well. Like I said, it's not good. And I've tried 3 or 4 methods but like I said, I didn't get it at all. Right now my code looks like function transformString("a", "b", "c", "d", "e") { var vowels = ["a", "e", "i", "o", "u"] for (var i = 0; i &lt; letters.length; i++) { if (input === vowels[i]) { vowel.pop(i) } } return false } this. I know I shouldn't be using pop(), but I'm not too sure what else to use.
No idea. I had to sign something that barred me from using county PCs or I wouldn't graduate, so I didn't ask
I wonder if this will break any nearby clients, especially older devices.
I have this firmware version: V1.0.5.70_1.1.91 
I remember doing UML in school, and it did not feel straightforward. Mostly because, (a) you've likely never written a program like your assignment, so it's difficult to plan out and (b) you've probably never really done UML. (this assumes your class wants you to take path UML -&gt; code). Honestly, just try your best and don't get too hung up on it. In my experience the TA/prof is usually just trying to make sure you've thought about your assignment and are not going to mark you very hard. If you're just doing this on your own free will, then I wouldn't recommend it. UML seems to be a very java heavy concept for enterprise. Have you ever looked at a github repo and found their UML diagrams? Maybe sketch out the more complicated parts of your app. 
When I read that headline for the first time, I thought somebody is having fun generating ludicrous project titles using Markov chains filled with buzzwords... 
Kinda invalidates everything you wrote about. I personally stop listening when someone confuses Java and JavaScript. I know that it's not the same thing here, but it's close. 
Yeah I think the big distinction with JavaScript frameworks is, if you use something that considered itself a framework as if it were a library, there ends up being a ton of unnecessary complexity that you wouldn't have if you had just done it the framework's "way".
 .readable-2 { max-width: 800px; *not* `width: 800px` same for .container. and take those margins out of body and add &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; to your head and you'll be mobile ready. right now it's ~~unreadable~~ uncomfortable on phones. 
Seem to be getting closer. I wasn't paying enough attention. I'm trying to modify my guest address. Now I'm getting stuck on var cf = document.forms[0] I suppose I can just comment it out, but I'm curious why it is getting stuck there lol 
These type of problems are what regular expressions are best used for. Incidentally, if the input is a string, the [`.replace()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) method is offered. For an array input, there are a couple of ways to go about it. One would be to convert the array to a string first - this is very easy to do. Try figuring out how you would do this on your own and then you will have your solution. (For something even better, try finding out what array method you would use to do that so you don't have to convert to a string first.)
Well im not that well versed in JS im more of a PHP-Guy, but I think node.js is interesting :) Let me know if it works
Design-wise, it's cool, but my immediate impression was that you need better state control and a somewhat more intuitive UI. With respect to state control, I think that only one menu chain should be openable at a time; i.e., if you click elsewhere, previously opened sections of the menu should close automatically. With respect to UI design, I also would recommend (at the least) a "back" arrow at the point where the opened hexagon obscures the previous. An optimal solution might involve some sort of breadcrumb trail. I think it's a potentially useful concept, and a great opportunity for you to improve your javascript skills.
It's been years since I messed with it. It took a smiling turd to get me back.
Ironically, if you think about how React actually works, based on that definition it actually fits much more in the "framework" category. Once you call `ReactDOM.render(&lt;Root /&gt;)`, React runs things for you and calls your component code as needed. The callstack for any component lifecycle method or callback is going to start with a bunch of React internal methods.
Is this ddwrt or some flavour thereof? I tried doing similar with my own AP, but ran into difficulty because the damn thing filtered out the emojii on the server side &gt;: {
So it shows it as such for anyone who views it?
Yes. Assuming their device supports emojis.
I'm confused. Do you change the function before you create a new SSID? Then the router will broadcast that?
In Google Chrome, you can open the developer tools (Tools -&gt; Developer Tools), go to Network tab, watch for the request that gets executed when you submit the SSID change request, right click it -&gt; Copy -&gt; Copy as cUrl. Now I'm not sure if Windows console supports this, but I can just paste this into terminal on my Ubuntu machine and it executes the request.
I was using the insomnia client for sending the request, but the issue had to do with the cookie headers. I'll try again later.
So it's not actually enforceable, then.
This is either misleading or written by someone who doesn't really understand what Polymer is. Polymer is a _framework_ written on top of web components. It's not web components itself. The promise of web components is that you _don't need to write js to make complex encapulated html elements_. For instance a google map elements such as ``` &lt;google-map lat="125.1423" long="23.1423" zoom="2" controls="false"&gt;&lt;/google-map&gt; ``` is going to be incredible for a _lot_ of people. You say it's "just dom", and fuck ya it is! You say that like it's some sort of insult. It's not a spec that is meant to do computational generation of dom elements like React is. In fact you can use React as a UI library _on top of web components_. By your argument we can also just get rid of HTML completely, and do everything with javascript, which is a horrible idea. React makes doing complex app-like UI work much better for sure, but you forget that the vast majority of things on the web are not apps. They are websites. You forget that along with React, you'll also need a very non-trivial set of tooling, support libraries, and other things before you can even make _anything_. Webpack, JSX transformers, babel, some ajax lib, some promise lib, etc. For 90% of the web, naked HTML, CSS, and jQuery is more than enough to do the job in a perfectly acceptable and maintainable way, and web components will make that even nicer.
Of course it does. 
Just modular arithmetic. If something is divisible by 3 and 5 that means you can factor a 3 and 5 from the number so instead of x /3 / 5 why not x / 3 *5.
saved
TypeScript actually has shorthand for when your type has a single construct signature which is: new (...args: any[]) =&gt; T So you could write it as follows: function get&lt;T&gt;(arg: (...args: any[]) =&gt; T): T { /*...*/ }
The error 403 is code for a forbidden action. It means you are not allowed to perform the action you are attempting to perform. Having looked through the reference info, are you sure you've authorised the client to perform this action? The method requires [authorisation](https://developers.google.com/google-apps/calendar/v3/reference/events/insert#auth).
cool! suggestions: - open sub-menu by mouse over - make animations more subtle and end quicker - animation grow should not fill in the white space between hexagons
This isn't working for me. It commits it with no errors but the web interface isn't right, and windows shows it as a hidden network. However, in linux it sees the unicode just fine. Thoughts?
It's actually 8 bytes, because it is in Unicode's supplementary multilingual plane. This holds whether it is encoded in the UTF-8, UTF-16, or UTF-32 format. http://www.fileformat.info/info/unicode/char/1f4a9/index.htm
Maybe. As I said, I graduated the same day, so I honestly didn't give a crap
&gt; The eval function is the most **misused** feature of JavaScript. i.e. `eval()` is not the one that's doing the misuse. The programmers do.
Fizzbuzz is not meant to be something that you spend more than 2 minutes thinking about. It's supposed to be a drop-dead simple problem that any competent programmer can easily write off the top of their head. Efficiency is not the point at all. It's not a perch to show off that you know how to write awful obfuscated JavaScript that doesn't use any if-statements, or that you can solve it in one line, or any such nonsense. And it certainly doesn't highlight any significant mastery of important things like data structures and algorithms. It's a bare minimum, akin to asking a chef applying for a job in a kitchen to boil water and maybe peel a carrot or something. Because apparently in the programming world there are programmers that can't even do the programming equivalent of boiling water, so this is supposed to weed them out. And the vast majority of Fizzbuzz examples you see on the internet are absolute garbage, this one included. They miss the point entirely. Cramming a bunch of crap into one line or avoiding if-statements by abusing various operators does not make anything more efficient. (If anything, it probably does the opposite, because it obscures your actual intent from the JS engine, which wants to do its best to optimize your code to run as fast as possible.) Source code length does not in any way correlate to runtime speed. In many cases, making a program faster will require writing *more* code, not less. But even if you put all that aside, Fizzbuzz is a program whose purpose is to print things out, and printing things out is very expensive compared to virtually everything else the program does (e.g. modular division), so it's likely that any time spent even thinking about the performance of Fizzbuzz is utterly wasted. Moreover, code should be readable and maintainable above all else, so the typical "Clever guy blog post" solutions to Fizzbuzz that clog up a Google search are an utter failure on every level. I'm sorry if that turned into a bit of rant, but Fizzbuzz fetishizing is one of my pet peeves. 
I can't find a checkData function on my R6300v2 v1.0.4.6_10.0.76 genie, under the wireless or any other tab. Dang it.
The trick is that you have to be sure to have the console's "context" on the iframe for the wireless page. That can be a bit tricky, I just opened the frame directly. You could probably get away with just setting it to an empty function edit: it needs a return value checkData = function() { return true; }
reduce isn't semantic? edit: Maybe, I should clarify. What is not semantic about the reduce examples? In this context there are two possibilities that I can see: the function name and reduce itself. I'm operating under the assumption that a "semantic function" is basically a function with a name that properly describes what it does -- similar to a semantic html tag.
I couldn't directly alter the code like above(Netgear Router). Instead I used the Sources tab &gt; Pause Script Execution tool to go line by line. When you get to the validation function (it starts with 'if(ssid == "")') change the 'ssid' variable on the right to something that will pass validation. I then changed the 'ssid' variable back when it started validating 'ssid_an', and clicked the complete execution button.
More complete version of TilBlue's code. var safeEval = function(src, self, window, document, setInterval, setTimeout, XMLHttpRequest) { self = window = this; this.setInterval = this.setTimeout = this.XMLHttpRequest = setInterval = setTimeout = XMLHttpRequest = function(){}; return eval(src); }; safeEval = safeEval.bind({}); Note: `window` and `document` are empty dummy object (same reference), and `setInterval()`, `setTimeout()`, and `XMLHttpRequest()` are empty functions (same reference). `XMLHttpRequest()` creates an empty object.
Even if you're minifying code, you should have source maps anyways. 
Argue isn't the right word I was going for. Edited.
My problem is not the responsive CSS, it's all the custom mobile-specific features, such as the side menus, bottom navigation, etc.
No reason to add documentation to your method if the method name already tells you everything you need to know. That is especially true for private methods such as validate_ssidchar.
Although the cadence of browsers building and shipping web components doesn't match my desires I still have high hopes for it and expect in the long run it will happen. It sucks to have to wait, but I look forward to be able to include robust components with the simplicity I have today adding an input or select element.
That was easy. Thanks!
It's 👌💯💧😋
https://www.reddit.com/r/javascript/comments/5zcb8m/can_you_help_me_allow_my_router_to_accept_as_the/deze5q6/
So, if one of your network devices gets confused by this and starts broadcasting packets to every node on the network, is that officially a shitstorm?
And I guess you should know that 802.11 only allows one transmission at a time per channel, and just coordinates queues to handle multiple clients, which is why your 54Mbps connection gets more like 5Mbps when you have more than three devices connected... And more importantly, why modern routers try to get around this limitation by offering multiple antennas on multiple channels, in a band with less penetrative power (5Ghz). And why high end wifi setups never rely on a single powerful base station, but prefer many weak stations with Ethernet between them. So definitely reserve the 5ghz for the people you like, and put up foil wallpaper to keep the client count low. 2.4ghz is more likely to suffer from slow speed because of interference, multiple devices, or Dave from accounting microwaving​ his lunch.
http://caniuse.com/#feat=imports is sorely needed. Was too 20 years ago.
Piggybacking on the usability / overlap complaints: About Us functions as I expected all of it to: expand out, but don't overlap. 
I would recommend searching for 'array.prototype' at developer.mozilla.com I don't want to tell you exactly what to use because I think going over the methods available to you and reading what they do will be more beneficial
OO I think I might have it actually.. I'll have to see, but if I fully qualify it... validator.stringSSID is recognized in the console at least. *edit* nope, I can't work out how to properly call that function. 
Git? logs? surveillance cameras? Jesus kids these days have it rough. In my day all you had to do was NET SEND * "H4CKED BY ZERO COOL" to freak everyone out. 
d3.tsv(url, access, callback); requires you pass in the url or path to your source. url is defined on line 26: var url = "data/sample.tsv"; have you tried changing the path in the url variable to point to where the sample.tsv is?
http://i.imgur.com/WyJI0HW.png That's how it looks for me :)
Thanks
I tried a few of these methods and none worked on my cisco router ;( Not surprised tbh
I agree with everything you've said. Personally I wouldn't even consider starting a new project in vanilla js over ts at this point. But I would point out that there's a difference between starting a new project and trying to port an existing, non-trivial, one.
You're using JavaScript, not Java (similar names, very different languages). Google yourself up an intro tutorial, you seem to be missing most of the basics.
Curious if it show up on windows
I've had computers like that. There's a very good reason Microsoft removed net send
What are you going for? My router is behind about ~1.5-2 walls and I get the same or better speeds on my 2.4 ghz network than my 5 ghz network. And I definitely get better range on the 2.4.
var url should equal "../data/sample.tsv" the .. means to go up one directory, without the .. it's expecting the data folder to be in the same folder as the JS file. Or you could move the main.js fie out of the js folder and it should work.
Thank you so much! This was so much more helpful than I could have imagined... you are awesome!
Unfortunately this didn't make a difference. I'm pretty sure data/sample.tsv is right as the script is run from index.html at the root of the file system It definitely has to just do with some missing code or something.
Has anyone found a way to do this with DDWRT?
(Like I said i'm brand new to this) I am using w3schools and i found the [oninput Event](https://www.w3schools.com/jsref/event_oninput.asp) but I dont know how to actually implement it into the code.... By the way I copy pasted the code into Notepad++ and I am testing it in my browser
I appreciate the rant. For someone new to programming, your rant helps put things into perspective.
You don't need that event just yet. You don't need an event on the input. `&lt;input id="c4ammount" type="number" /&gt;` That's all the input needs to be. The `&lt;button&gt;` though, you want an `onclick` event. Point that to the function that prints the html instead of the `window.onload` event. You can leave the window.onload event in, it shouldn't bother things. Then when you click the button, the event fires. Well, if you pull the value of the input, and use that for the `c4` variable, you can just enter a new value and hit the button, refreshing the calculated html each time. Edit: it should be a number type, but text will do. Just allows for errors if you input letters or anything else except digits.
I normally judge them based on the content and value of what they say, but that's okay too.
And as a function you can call: function probablyNotSafeEval(src) { return (function() { with(this) { return eval(src) } }).call({ window:{}, document:{}, // eval: {}, setTimeout:{}, setInterval: {}, XMLHttpRequest: {}, Function: {} }) }
Hijacking this top comment to say that this same method works for setting the password on the network. On WPA networks, most devices (like my Android phone) won't allow you to attempt connection before you've entered the requisite 8 characters....but I just set my network password to 8 emojis and connected just fine.
yeah, i see so many emoji titles these days. :S
Thanks for the idea. Yes, i have not really thought about that. I was just so focused on creating the core code to produce hexagons and completely neglected the UI part. I will find some time to reCode those areas to behave in a more user friendly fashion. 
The road to being a good frontend dev is full of a lot of studying about design, usability, accessibility, etc., but there's the technical implementation side, too. Nothing wrong with focusing on the core code.
Yes, opening with mouse hover is a thing, and I will implement that later. Thank you for the suggestions. 
All this time I thought it was chocolate pudding...
This is less difficult than it appears if you only care about a partial implementation. Start with an AST generator (Babylon, for example), write implementations of the parts you need.
No, their IT was good, but the principal was paranoid that he would need old security tapes, so he made sure to keep everything spanning a year back
Typescript is an absolute abomination
Lol
Well, with this approach the loading spinner shows up and goes away. But yeah, if you need to debug the loading state, use debugger or a breakpoint. 
Well that error is because the url you are trying to reach does not serve up headers that allows CORS for your domain.
Please make a guide for us morons. I'd PayPal you good money. We need this shitposting !
Imagine taking an array of images. Search through them for something that matches the search terms. Make a new array from that subset. Render those elements to the DOM. Put that in an event handler for the search box. 
I was out of luck ;) http://i.imgur.com/dre8BSK.png
&gt; What's the point of describing React if you're not going to contrast it with Angular or Vue or any other framework? Having never tried React, I'm left unenlightened. This explains it: http://blog.wolksoftware.com/the-rise-of-functional-programming-and-the-death-of-angularjs As for Vue, it's technically a React derivative, but with a slightly less complex Angular on top, to which everything in the article above applies. 
NET SEND * "I'M SORRY DAVE, I CAN'T LET YOU DO THAT."
I'm writing an API for Web Components that uses IFrames for everything. It keeps the CSS modularised, encapsulates the JS, and prevents unwanted effects leaking out of the IFrame itself. Because they're components on a webpage they suffer from none of the issues IFrames classically had for SEO... such as the address bar and navigation. It's the future!
&gt; I fall much more on the CoffeeScript side myself. Sorry, I had to stop there. I'm forced to use Coffeescript for work every day and I hate every second of it. There are some good aspects, but those things have been replicated in ES6 now. We're slowly migrating to ES6 but getting a largely Coffeescript shop to convert doesn't happen in a day.
I have a Hitron CGN3 and I'm unable to change it, but here the code I found containing the validation: _validate: function(attrs, options) { if (options.silent || !this.validate) return true; attrs = _.extend({}, this.attributes, attrs); var error = this.validate(attrs, options); if (!error) return true; if (options &amp;&amp; options.error) { options.error(this, error, options); } else { this.trigger('error', this, error, options); } return false; } can someone stear me in the right direction or at least tell me that the firmware for this router is unpassable? thanks
Ok, acknowledged. Is there any demo you would recommend?
Let's start simpler. Forget about passing functions around and callbacks and all that. Say you have this function: function salute(someone) { // do whatever you want with someone, e.g. return "Hello, " + someone; } This is a simple function. It can do whatever you want. I'm using a simple example but it's irrelevant what it does inside. Now, think about this other function: function wrapSalute(someone) { return salute(someone); } And, why not, this other function: function wrapWrapSalute(someone) { return wrapSalute(someone); } // you could go on like this forever... So... does `wrapSalute(someone)` do anything more than just calling `salute(someone)`? No. It calls `salute` and returns whatever `salute` returns. So, besides wrapping it, it accomplishes nothing, right? Then, we could say that calling `salute("Crashyy")` and calling `wrapSalute("Crashyy")` does exactly the same thing, couldn't we? So, then, wherever we have `wrapSalute` we could just put `salute`. It would work exactly the same and do the same thing. Now back to the original example: var getServerStuff = function(callback) { return ajaxCall(function(json) { return callback(json); }); }; Let's extract that anonymous function. I mean, let's just look at that: function(json) { return callback(json); } This is a function which receives `json`, calls `callback(json)` and returns whatever that returns, right? So, it does nothing more than wrapping it. It's the same situation we had above. And so, wherever we have that anonymous function we could just put `callback`, couldn't we? Let's tweak the original example for a moment: var getServerStuff = function(callback) { function wrapCallback(json) { return callback(json); } return ajaxCall(wrapCallback); }; Now, at this exact point is where `json` _"disappears"_ from the line `return ajaxCall(wrapCallback)`. I know, we'll get to that in a bit. But let's finish this point first. As we were saying, now `wrapCallback` does nothing more than `callback`. So... wherever we have `wrapCallback` we can just use `callback` and it will work the same. So... var getServerStuff = function(callback) { function wrapCallback(json) { return callback(json); } return ajaxCall(callback); }; But as we don't need `wrapCallback` any longer, we just remove it: var getServerStuff = function(callback) { return ajaxCall(callback); }; Now we can do _exactly the same_ once again with that other anonymous function that just receives `callback` as an argument and just calls `ajaxCall(callback)` and returns whatever that returns. I'll leave that as an exercise for you. And now, I didn't forget about that `json` argument _"disappearing"_. You have this in the original example: ajaxCall(function(json) { return callback(json); }); but we wrote it like so: function wrapCallback(json) { return callback(json); } ajaxCall(wrapCallback); Right? So, the argument is still there. But `json` is the formal argument (i.e. the name you give to the argument) **when you define `wrapCallback`**. More in general, arguments are seen where you _define_ a function. function bigger(a,b) { return a &gt; b; } `a` and `b` are present in the _definition_ of `sum`. Nowhere else. So, if we call `bigger(3, 4)` you don't see `a` and `b`, there. If you pass `sum` to some other function, say you do `[1,52,4,62,56,2,7,9].sort(bigger)` you don't _see_ `a` and `b` there. You say, `bigger` is a function that takes two arguments. Oh, and what are those arguments called? Well, why do you care? The only one that should care about the names of those arguments is `bigger` itself in its code. So... back again to the original code. Somewhere, somewhere else not in the code you showed and also not in the code written in the book, someone writes a function which will be passed as `callback`. And they will write something like... function logResults(json) { console.log(JSON.stringify(json); } So there it is, your `json`. But... they could just as easily have written... function logResults(results) { console.log(JSON.stringify(results); } But that's your _disappearing_ argument there. ---- Oh, about those `()` _disappearing_ too. Those don't really _disappear_. They were never there to start with. When you do... var whatever = function(param) { return "Hello " + param; }; ...you're _not calling_ the function. You just assign the function to a name (`whatever`). Equally, when you do... ajaxCall( function(json) { console.log(json); } ); ...you're _not calling_ the anonymous function (`function(json) { console.log(json); }`), you're just passing it into `ajaxCall`, but you're not calling it. So... ajaxCall( function(json) { console.log(json); } ); // is equivalent to... var whatever = function(param) { return "Hello " + param; }; ajaxCall( whatever ); ...i.e. you're _not calling_ `whatever`, you don't need `()`. The same way you were _not calling_ the anonymous function to start with.
Whenever a function is created, it keeps a reference to the lexical environment (aka scope) in which it was created. function Cat () { var meow = 0; this.getMeow = function () { return meow; } this.incMeow = function () { meow++; } } Using this function as a constructor, `var garfield = new Cat()`, will return an object with 2 methods that have access to the 'meow' variable. Why? Because during the creation of these two functions, they keep a reference to the lexical environment (aka scope) they were created in. So both `getMeow` and `incMeow` have a reference to the `Cat` environment and what's in the Cat environment? The variable meow. I should add my point is better illustrated if you make an additional constructor call, `var hobbes = new Cat()`, so that when you call `garfield.incMeow()` and then `garfield.getMeow()` returns "1" while `hobbes.getMeow()` will still return "0". Both garfield and hobbes keep separate references to the Cat environment.
&gt; Unfortunately the only real "community" is the actual CanJS developers on the Bitovi/DoneJS forums. yeah, I have the same impression. Thanks anyway.
Not sure how to do it with a regex, but here's an ES6 function. const yourString = "First Line;\nThis is the second line; code dot.notation.ClassName;\nThird Line"; function codeParser(inputString, className) { return inputString.split(';').map((str) =&gt; { if (str.includes(className)) { return className + ';'; } return str + ';'; }).join(''); } console.log(codeParser(yourString, 'ClassName')); If you don't want the semicolon on the last line of the outputted code since it's not in your string, it's a pretty easy tweak. codepen: https://codepen.io/anon/pen/MpEzrx?editors=0011
If people aren't measuring performance and being aware of it, it won't matter if they write for loops vs. forEach functions. Using collection methods for convenience and then refactoring them to for loops later on isn't hard. There's got to be a balance, otherwise we'd all be writing C or Rust.
Tried this on my Google OnHub which uses an app instead of a web interface. I was able to set it as an emoji without any additional steps. Nifty.
It's easier for non-technical people to see what is happening. You might want to show the loading in a presentation without fiddeling with the dev tools. 
Thank you for illustrating my point. 802.11ac is rated and sold as as 1900 megabits per second by the lowest end routers. You got 100 megabits in your real world scenario... And less through walls. What's your router make and model? Let's look up what it SAYS it should be able to deliver, and compare it to your 100 megabits. To be fair, part of this is because they advertise the total combined throughput , which is usually (speed per MIMO Stream) x (maximum number of streams per radio) x (number of radios in the router). An individual client uses one radio, and two 80Mhz MIMO streams if it's reasonably current. [Each stream is rated for about 433 megabits per second](https://80211notes.blogspot.de/2014/03/phy-rate-and-udp-throughput.html?m=1) . So even though your router says 1900 megabits on the box, perfect-conditions, zero overhead, link layer only, single device maximum speed is 866 megabits, and your real world result is 100 megabits. The best way to guarantee good wifi speeds is minimum clients (low wait) and minimum range (low interference and fewer clients).
A var defined in the same scope or higher up as a function definition will be unique to each function call, so long as it is referenced. function db() { var storage = []; return function(item) { storage.push(item); return storage; } } db()(1); // =&gt; [1] db()(2); // =&gt; [2] var x = db(); // x has own storage var var y = db(); // separate from x x(1); // [1] y(1); // [1] db()(1); // [1] -- each db() creates a unique storage var essentially x(2); // [1, 2] -- repeated calls to same generated function use same storage var
Not working at all for me on Firefox (Android). Got it to load in Chrome. I think it is a little weird that you can have multiple paths open at the same time. Otherwise very cool.
I good response to this article, I had similar views whilst reading the original post: https://robdodson.me/regarding-the-broken-promise-of-web-components/
Cool. I have a related technical question... Is it possible to modify joint anchors after instantiation? I have thing here with trees/flowers that pop up: https://magwo.github.io/sway/ (click window to grow new trees). I would like to switch physics engine for performance reasons (multiple joints seem very expensive in P2) and also add the possibility to grow the trees slowly - which requires modifying the size of the limbs and updating anchor points of joints. I tried doing this with P2 physics with buggy results. If not already possible in Planck, I could make a contribution to make joints modifyable after instantiation.
Definitely. Looks like JS is going to get imports (incl/ dynamic) before HTML now. (`import()` is stage 2 or 3 now in TC39.)
You're one month into JS? You are doing very well.
Got this going with the Comcast-supplied Arris TG1682G by changing the regex to check anything. There's probably a better way, but it's 6AM here and I'm stupid tired. I'm using Chrome so it might be different on other browsers, but on the page where you edit the SSID, go into debug via F15, then in the console, enter: $.validator.addMethod("ssid_name", function(value, element, param) { return !param || /$/i.test(value); }, "1 to 32 ASCII characters."); Then change to your heart's content! http://imgur.com/WacTgAN Thanks for the inspiration, I never knew I wanted a shit SSID so much!
Thanks man, Yep, just felt it was easier to fill all the div's with the appropriate svg's, and dynamic text addition without having to dig into the html.
&gt; It sucks to have to wait, but I look forward to be able to include robust components with the simplicity I have today adding an input or select element. But isn't this what React does today? import SpecialButton from 'special-button' &lt;SpecialButton&gt;hi there&lt;/SpecialButton&gt; And the benfits, other then those most people already know ... The browser is made into a dumb pipe. The piece of code above could run everywhere. Other frameworks, web, desktop, mobile phones, tablets, watches. [React now renders apps in shell consoles](https://github.com/Yomguithereal/react-blessed). This is a major benefit as the dom isn't our horizon any longer. Or performance, React Fiber is out soon [which gets us closer to native performance](https://twitter.com/annalankauf/status/841357376074600448) through occlusion, chunk processing and render priority. Or animations and movement, with React-natives physics based animation-lib [that's currently being made cross platform](https://www.webpackbin.com/bins/-KfKys3S2mgEH9UsE8GL). The point is, when web-components are finally running without polyfills they'll do a fraction of what React does today. But with downsides, like larger and more complex code and the browser as the final limit. I think the spec even kind of contradicts the extensible-web manifest. Should they have tried to shoehorn view model semantics into the browsers core in the first place? This began years ago with now-outdated patterns like MVC and bindings and now it's fixed because punching it through vendor policies took years alone. There's now an additional layer of bulk on the browser, is this a good thing?
That's sad, but I really never tried it on firefox for android, I guess i'll have to find a way to make it work. Thanks for the info. May I ask what you mean by multiple paths open? in the svg's? I'm not that good with SVG's :C
Forget CanJS, move on to something the industry actually gives a shit about
The author's only criticism for using Angular was Typescript, that was apparently enough to declare React a better solution. I've found Typescript to be one of Angular's biggest strengths. Personally I'm​ an Angular guy but I don't find it constructive to push other devs to Angular without them trying out other frameworks. It's better if you just tell people what you like about your framework of choice in comparison to others instead of straight out bashing other frameworks.
Which one ?
Righteous stuff, migration worked like a charm for me.
Fantastic answer! 
I'll try my best, but there's a chance that what I say doesn't apply to your router, so in that case you're pretty much in your own. First let's start with client side and server side validation. When you sign up for a site and you enter an email without `@`, you might get a warning saying that the email is invalid before even submitting the form. This happens because of client side validation. The data that you entered is getting validated on your browser and it will not let you submit the form. Many old websites don't have client side validation, so you have to press submit and let the page reload to realise that you've entered the wrong email. This is because you send the data, and the server rejects it. Generally, there's nothing you can do about server side validation, unless you have access to it somehow. In this case, the "server" is your router, but tampering with it would mean tampering with the firmware, and that's complicated, so let's just assume that the server validation is out of our control. So in this case, the OP wanted to overcome the client side validation by overwriting a Javascript function which took care of validating whether or not an SSID is acceptable. If you're not familiar with programming, function are basically pieces of code that receive an input and produce an output. In this case, the output was a boolean, which is a data type that can have only two values: `true` or `false`. So by replacing the whole function with just `return true`, the function will always say that the entered SSID is acceptable, and the form will be able to be sent. That's what I did, and I managed to send the form. However I realized that the emoji was getting *escaped*. If you don't know what that is you can google it, but it's not really neccessary for now; you can just assume that it was getting transformed to another thing (`&amp;#128169;` in my case. That was literally the SSID name). First I thought that the escaping was being made server side, and I was out of luck (I'd need to install a custom router firmware, and that's too much effort for placing a poop emoji on the SSID haha). But then I realized that it was actually being escaped on the HTTP request, not on the server side. In other words, the escaping occured after the form was sent, but before it arrived to the server. So let's talk HTTP requests. When you send a form, you generally perform an HTTP request, which in human language is telling something to a server and waiting for its response. The method can be `GET` or `POST`. Those are HTTP methods, and there are much more, but let's just focus on those. You could divide HTTP requests on `url`, `headers`, and `body`. Let's forget headers for now. A `GET` request is the request you perform when you open Reddit, or any website ever. It only consists of the URL, and doesn't have a body (you don't type anything other than the URL to go to Reddit). A `POST` request does have a body, and it's usually useful for submitting form data. So generally forms do POST requests. The URL will be the target server endpoint, or in other words, where does the server want the data to get sent, and the body will be the parameters (where the SSID of your router will be). However, my router doesn't send a POST request, it sends GET. Pretty shitty programming if you ask me, but it works. So where does the data go? To the URL. Turns out you can put parameters in the URL too. Have you ever been to a site whose URL was `index.php?page=2`? The endpoint (the file you're opening) is just `index.php`, but you're also telling the server a special parameter: `page` is `2`. The server can interpret that as in *I want to go to the website, but instead of showing me the first page, show me the second one*. And here's when URL encoding comes in. What if you want to tell the server a parameter that is a sentence? Let's think that `index.php` is a music site, and you can send the parameter `category` to filter the music that the server sends. What if you want to say `Drum&amp;Bass`? You'd think the url would be `index.php?page=2&amp;category=Drum&amp;Bass`. However the server would actually interpret that as the following: Go to index.php Here are the parameters: - page = 2 - category = Drum - Bass = (no value) Because `Drum&amp;Bass` contains a `&amp;` character, the server will think that the category ends with that character, and that you're passing another parameter `Bass` with no value. So how is this issue solved? With URL encoding. Before sending the request, `Drum&amp;Bass` gets changed to `Drum%26Bass`, and then it gets sent to the server. The server then understands the parameters, and understands that `%26` means `&amp;`, and changes it. That's what's actually happening when you send the poop emoji. It gets URL encoded, and when decoded, you don't get the emoji back, you get that weird thing: `&amp;#128169;`. As to why, I don't know. If you go [here](http://meyerweb.com/eric/tools/dencoder/), paste the emoji, click on Encode, and then on Decode, you get it back. It's likely that the server is not prepared to decode emojis, but I'm not an expert on character encoding and I'm not really positive. So what I did next is send the request from an HTTP client that won't encode any characters. If you have Chrome, use Postman. If not, use Insomnia. In order to replicate the same request, you can right click on your router's configuration site and click on `Inspect Element`, then on `Network`. If you send the form, you should see the request appear on that tab. What I did was copying the request URL and pasting it on Postman, and sending. But the request wasn't getting authenticated. After all, anyone can send requests, and the server has to tell if you actually have the authority to do so. Let's talk request headers (remember when I said *You could divide HTTP requests on `url`, `headers`, and `body`*?). Headers are metadata related to the request. For instance, the `User-Agent` header is sent by the client, and tells the server the browser you're using. The server can answer with headers as well, but that's not useful to us. Headers are pretty much like the request body, but they server a different purpose. The body transmits data, and the headers transmit metadata. On your browser's debugger's network tab, you should be able to see the `Request Headers` (note that they are different from the `Response Headers`, which you don't need). So what I did was copying them to Postman (on Postman, under the URL there is a `Headers` tab). But the request was still getting unauthenticated. So I noticed that one of the headers was `Cookie`, with the value `Authorization=Basic%20xxxxxxxxxxxxxxxxxxxxxxxxxx` (the xxxx were my router's username and password encoded in [Base64](https://es.wikipedia.org/wiki/Base64)). Now, I don't know too much about cookies (IMO cookies are a thing of the past, there are better alternatives), so I didn't understand why the server didn't recognize the header. But I knew that the `Authorization` header was a standard, and `Basic` was a type of authentication. So before I had in my headers: Cookie: Authorization=Basic%20xxxxxxxxxxxxxxxxxxxxxxxxxx And I added: Authorization: Basic xxxxxxxxxxxxxxxxxxxxxxxxxx Notice how I replaced the `%20` with a space. `%20` is how the space character gets represented with URL encoding. And that did it: the request got authenticated, and my SSID is now a poop emoji. Now as I said, your router will probably be different, but hopefully this wall of text will give you the tools to investigate how to do it on your own. Good luck!
Because it's been around forever yet almost nobody uses it. Of course _the industry_ exists, don't be daft
Frameworks don't make it easier to debug code if you are a good developer. 
If there's bugs there's bugs, but that would not be due to lack of unicode support. Also I took some offense that you'd not risk it. It seems very much on the safe side. Especially like this. 
What's the best way to execute this once you add the text to the console?
Have you had any luck connecting to 💩? I can see it appear on my phone, but trying to connect seems to do nothing. I'll try on my laptop later.
Tree view decoration looks nice. That's one thing I wish VSCode had.
&gt; Because it's been around forever yet almost nobody uses it. OK, which does not mean, that it is a bad framework (technically). Also the decision to use it or not isn't in my hands.
Only Node has a concept of a local file system - regular JS in a browser operates on URLs, so files can only be loaded via AJAX requests, which means requiring a local web server. An alternative is to pack the data from the file in to a script tag with an ID and a text type, allowing you to store the contents in a variable. Best of luck :D
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/shitpost] [💩](https://np.reddit.com/r/shitpost/comments/5zqk80/_/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I like this because it provides the same value as Redux, but in a more compact package. 
I'm still really confused, I asked my professor about it in class and she only said it's a few lines of code that are missing. Are we actually required to load this from a web server? It feels very misleading if the instructions for the assignment require us to set up a file structure like so and the code making the url point to /data/sample.tsv
That was it... still can't make the checkData function behave, but at this point, it should be a matter of messing with it. Thanks! 
It looks like they've moved the API from wind-bow.gomix.me to wind-bow.glitch.me, and set up a redirect, but that redirect doesn't set CORS headers. Try using http://wind-bow.glitch.me/twitch-api/users/nalcs1 directly.
The promise chain might work better if you start with the timeout then chain the payload promise, e.g. `new Promise(res =&gt; setTimeout(res, 1000)).then(() =&gt; dummyData);`. I feel it's a little more elegant.
&gt; React is necessary because when you're using a non-React library, you have a ton of code all over the place that updates the DOM. And you go on comparing react to pieces of jquery code. Not really a fair comparison in 2017, eh?
Just letting you know, nothing happens when I click on a product ([this page for example](https://riqra.com/shop/page-1/?category=61)) and it's caused by my ad blocker (uBlock Origin). The domain isn't on any blacklists, so it could be as simple as a class name or something in the route name. Not sure if it's worth looking into, but I figured I'd let you know.
Here is my implementation. I hope it can help you. https://gist.github.com/gildas-lormeau/3de0d4bbfce1873b0286ef7ce293f2ce
Oddly enough, I never got it to work. I was running on zero lunch, though which could be the reason. I was trying to get my guest network to broadcast a turd, though, and I have a newer firmware version than /u/HauroLoL does (just by a bit) so there are some differences in what we were working with.
~~Yeah I am fairly sure I had it lined up with the right iframe's window.~~ ~~I was trying to edit the guest network on my R7000. I could see where it was getting stuck at when the debug paused, and it was the frame I was applying the console commands to. No dice. 💩~~ I mentioned in another post that I was without caffein and food when I was trying this. I got it to work and I'm absolutely sticking by that excuse. I completely glossed over the console defaulting to "top". Dumb. Clicked the drop down and set it to the right window - easy peasy. Don't code without caffein, folks!
Guest network from R7000 is 10.11.12.13/WLG_2g_wireless2_2.htm It doesn't seem to matter if I apply it to that, or any other frame for that matter &gt;:( Firmware Version V1.0.7.2_1.1.93
Does the prompt still show and is it still from JS? Maybe it has a slightly different flavor. Did you find checkData?
Yea, I agree =&gt; I ended my mini-open-discussion with &gt; All in all though seems like something we should be doing
Not enough npm dependencies. 
Right... Hammers are evil.
Do you think that, after reading the article, it impacted my or your understanding of the tools I described? 
Fair enough; I should have said that declarative programming in general does this, not just React.
Thanks for saying so. I appreciate it.
It should on Windows 10; it has native emoji support. Windows 8 launched with limited support, via the Segoe UI Symbol font which was included in a 7 update. 8.1 has the Segoe UI Emoji font which included colored emojis.
This post DONT mean to replace an https secure system with certificate, this is intended only for remove password unsecure alerts from your browsers, example: you have a local network in your office and you DONT want install https and certificates.
I've just gotten back to see this amazing response. thank you so much for taking the time to type this out. I'm going to make a cup of tea and give this a go.
This quote is exactly aligned with how feel about it, abomination isn't the right word, but Typescript is something I will never embrace. &gt;"I think that JavaScript’s loose typing is one of its best features and that type checking is way overrated. TypeScript adds sweetness, but at a price. It is not a price I am willing to pay. " - Douglas Crockford, author JavaScript: The Good Parts
I did look into Passport. Was there a lot of setup when you used it? I wish they had an API that worked independent of a framework.
You can do it with the curl command, but honestly that'd be much slower. I'd get a client and then uninstall it but you do you.
See my other reply, TL;DR: I was doing it wrong yesterday on an empty, uncaffeinated stomach lol
That's a great question! However, we're talking about the functional paradigm here, so it's quite difficult to draw direct parallels between MVC and MVI. Both MVC and MVI deal with the separation of concerns, but that's where most of the similarities end. Where MVC tries to simplify the application logic by the separation of data, behaviour and presentation, MVI focuses on *side effects* and *application logic* (expressed as transforming, or "looking" at data through a set of different "lenses"). In other words, there is no controller per se, just data and side effects. ### In MVI: Model stands for *data* or *application logic*. It does not care about the external world, but accepts data and returns it. It is important to say that a model can be represented as a pure function ^1: the same input will always yield in the same result. This makes testing incredibly easy, as in most cases, it makes mocking obsolete. The key here is the word *pure*. Intents are side effects *entering* the application. Since they come from the outside world (e.g. a timer event, an incoming socket message, mouse clicks, *network responses*), they're often called *write effects*. Views are also side effects, but the ones leaving the application and entering the outside world - they're also known as *read effects*. An example view would be a function taking an object describing the DOM structure (from the model) and rendering it on screen as HTML, a handler expecting a string message, rendering it to the console window, or a *network request*. In MVC, models, views and controllers can retain state. In MVI, there's no state as such, although one can argue that it's created in a scan function, there's no way of "peeking" at it from the outside. This makes testing easier and makes it possible to create more powerful debugging tools (e.g. "time travelling" debuggers in Racket or Elm). I can understand why this might seem a tad confusing at the beginning, esp. when when comparing MVI to MVC (as opposed to MVVM, MVP etc...), but although both paradigms try to solve relatively similar problems, they approach them from completely different angles (data vs. behaviour vs. presentation and data vs. side effects). ^1 or a stream, which could be understood as a "lazy, pure function" for the sake of simplicity. 
web-components give you encapsulation and imports but no dynamic structures, so all frameworks sitting on it bring their own parsers and markup extensions. If that standard is supposed to have each and every framework re-implement their own if-then-else-for-while and whatnot, how about this is a really bad idea? If anything they have invited fragmentation. About this hand waving for standards in general, it just doesn't make sense. A standard has to perform, otherwise it's getting discarded. How many standards have fallen under the rug over the last 10 years? Not just a couple. Some bigger projects have chosen to avoid web-comps because it doesn't solve anything that hasn't been solved already while offering no other benefits but rather limitations.
Do you mean hiding the bottom status-bar entirely (not just the linter stuff)? You can just add some CSS to your stylesheet to hide it completely: [Screenshot](https://camo.githubusercontent.com/6b273f44674c17a61cb52df08d490ea477574425/687474703a2f2f692e696d6775722e636f6d2f396353657274662e706e67). I currently have it set so that it only shows when I hover my mouse over it.
Those "alerts" are there for a reason. You either take a few minutes effort and install a free certificate or deal with the fact that your form is not secure. Even if its just for internal use, if its on the web then it should still be secure to prevent interceptions. LetsEncrypt are a free certificate provider if you really don't want to invest in a paid certificate.
let's just state the obvious: don't.
I modded itty53's fiddle a bit with a bunch of notes and some more concepts to get you started. https://jsfiddle.net/Lwmtugo1/
Awesome. Thanks! I hope I can report with a screenshot of my own. 👍
The guy whose password I got was a moron, but I knew the rest of the IT guys, and they were pretty good at their job
From my research it seems to be mainly supported by Chinese companies and US hasn't adopted it yet. Also as someone who is starting out(2 weeks), its a lot easier to learn. Compared to React, getting started with vue was a breeze, i was able to easily modify the tutorials. Honestly its great that jobs are not requiring it right now because they will(hopefully) and for someone new to JS this would be the perfect time to start learning it. I'm starting to see it listed as "nice to have/know" in a quite a few new job postings. But then I dont want to put all my eggs in one basket so i have picked up angular 2 as react doesn't interest me. 
In case you don't know how to access your stylesheet, you can just open up the command palette with Ctrl+Shift+P and then type in `"Open Your Stylesheet"`. This should open up your `styles.less` file. At the very bottom of that file, you would just need to add something like this: .status-bar { opacity: 0; } If you want it to show when you hover over it you could do this instead: .status-bar { opacity: 0; transition: opacity 150ms ease-in-out; // Add this line if you want fade effect &amp;:hover { opacity: 1; } }
Oh nevermind, got it already. Just need to copy/paste the emoji.
Actually, I've seen couple of companies requiring vue.js knowledge, including GitLab. Also, Alibaba is working on a project called Weex that integrates Vue.js and it's going to be huge. Also, I've seen lot of job openings here: https://vuejobs.com. The number of companies posting jobs are increasing day by day. 
Seems like an arbitrary distinction. MVC doesn't dictate whether you use functional, OOP, procedural, etc coding. You can do what you just described in MVC. Why not call "MVI" "Functional MVC?"
&gt; I can understand why this might seem a tad confusing at the beginning And it remains so, because the issue is you're describing these patterns using abstract and subjective language, the way a literary critic would review a poem. But what is needed is the language of an engineer describing a machine. MVC is brutally simple: 1. Controllers receive events from views, and based on those events it interacts with a model to mutate its state. 2. The model represents the business logic of the application. 3. The view presents an interface to the user (or in hierarchical MVC, it can be a machine interface to an intermediary controller). There are many details which are not fundamental to the MVC pattern. Things like: - Who updates the views when the model changes? It can be the controller, it can be the model, or it can be an automated binding mechanism. It doesn't matter. - Could controllers and views retain state? They could, if the language allows, but they don't *have to*. Only the model should, directly or indirectly. - Are model/view/controller objects or functions? Irrelevant. "A closure is poor man's object; an object is poor man's closure". - How should M/V/C interact with one another? Direct method calls, command objects, return values, functionally, imperatively, through delegates, through event busses? Irrelevant. There's nothing in MVC that discourages components being "pure". In fact, it's quite common to see stateless controllers and views, because the model captures all the state we need. So in that context, how does an "intent" differ than a controller? - Does it receive input events from views? Yes. - Does it use info from these events as a basis for communicating with the model? Yes. The only thing that's worthy of notice is that the calls are [trampolined](https://en.wikipedia.org/wiki/Trampoline_%28computing%29#High-level_programming), i.e. instead of this: function intent(sources) { var uiState = getDataFromEvents(); model(uiState); } function model(uiState) { var state = getStateFromUIState(uiState); view(state); } function view(state) { // View rendering logic. } ... we have a fourth function acting as a trampoline: function intent(foo) { var uiState = getDataFromEvents(); return uiState; } function model(uiState) { var state = getStateFromUIState(uiState); return state; } function view(state) { // View rendering logic. return viewRepresentation(); } function trampoline(thunk1) { var thunk2 = intent(thunk1); var thunk3 = model(thunk2); var thunk4 = view(thunk3); return thunk4; // Pass onto Cycle's own trampoline } Cycle.run(trampoline, drivers); Which is repetitive enough in the given examples at least, that we can generalize it: function makeTrampoline(...funs) { return (thunk) =&gt; funs.reduce((fun, thunk) =&gt; fun(thunk)); } Cycle.run(makeTrampoline(intent, model, view), drivers); But the larger point is that converting something to trampoline representation doesn't change its behavior, nature, or responsibilities. So as an excuse to rename *one* of the components in MVC, because it feels more pure... it's just pushing it IMHO.
It's a new framework. Unfortunately, companies don't widely adopt new frameworks just because they are popular with developers -- or should that be 'fortunately'?.
Do you see the new branch on Github website? If so, after `git clone` did you make `git checkout dev` to switch branch? Also, you can try to use Github GUI client to clone repo and switch branches. How to push changes: when you are working in `dev` branch, do `git push origin dev`
[this](http://stackoverflow.com/a/9537923/764384) should help. 
If you don't have `.git` folder, it's not so easy, I can't describe it from mobile :) Easier to clone the repo, checkout the branch and then just copy-paste modified files. After that make a commit and push to `origin dev`
I mean I don't think the two things are that related. No real job is going to hire you based solely on a specific framework. Vue is a nice alternative to React but they ultimately serve very similar purposes. Pick one you like, start building stuff with it, then show off that stuff to potential employers. If we only used what's most popular in job listings then we'd all be using Angular still. Or worse, we'd be PHP developers.
This is helpful on so many levels, thank you!
My company's entire web framework loads incrementally, every component loads lazily the moment it's encountered in code... There's no AMD or webpack or whatnot.
It's more fun with a lot of tech :P You can model rotated rectangles as circles can't you? Depends on the accuracy that you want ... but the only real source I could find for "collision of arbitrary polygons" was a 159 page dissertation and I don't think I'm smart or patient enough for that. Just use an off-the-shelf physics engine :D
i wrote it off immediately after not seeing `left-pad`. i mean, how serious can it really be?
It does? Can you post a screenshot​ of that feature? 
I have not tried these, but these came up after a couple of Google searches. Maybe you find something interesting here :) - https://github.com/kucherenko/jscpd - https://github.com/danielstjules/jsinspect - http://pmd.sourceforge.net/pmd-4.3.0/cpd.html - http://www.semanticdesigns.com/Products/Clone/
So now I'm stuck on getting the individual elements of the arrays, I need to access the max of the x elements and the y elements. what would be the easiest way to do this? I know you can use Math.max.apply() but I can't seem to figure out how to get an array of all x or y values. It sucks that I have to work with someone's code because I'd otherwise just rewrite this.
How is behavior/nature not changed? In the first example I can't reuse the model because it doesn't return a model, it chains to view.
The examples, as presented don't change their behavior. Before/after the refactoring, it's the same behavior. As I noted earlier whether the model or the controller updates the view is not fundamental, you can see implementations doing both approaches. As for reuse, when you want to reuse something, and it invokes something hardcoded, you simply have to inject it, thus making it a part of the configuration. So a reusable version would be: function model(uiState, view) { var state = getStateFromUIState(uiState); view(uiState); } Or, for multiviews, even: function model(uiState, ...views) { var state = getStateFromUIState(uiState); views.forEach(view =&gt; view(uiState)); } Although I'd rather keep the view calls in the *controller* if the code will be so basic, and free the model from this concern entirely and let it just be "the model". Aside from not having to inject the model with views, controllers are less reusable, so you don't have to write generic update code in there, if all you'll do is invoke them (not smart bindings etc.). All of this is absolutely trivial to change as you see, and doesn't represent a significant alteration in the responsibilities of the components. In my apps, for example, I'd have situations where a controller *creates* the views it manages, or situations where the views are *injected* into a controller, or a situation where the controller is injected with a *view factory*. None of those choices is the correct choice 100% of the time. There's no silver bullet solution here. Those are choices to make on a component by component basis, not application-wide, because MVC has always been a component level pattern, not something you have to replicate in absolutely identical way for all your components throughout the app. BTW, in terms of reusability, probably controllers vary the most in every MVC triad. Models can be reusable, views tend to be *very reusable*, controllers... well, sometimes, but not nearly as often.
No worries. Though this isn't a great way of doing this. I just started down the rabbit hole of trying to solve this problem in a "different" way and ended up with something not so smart. Usually the best way to solve a problem is also the easiest way. To explain what's going on, I'm making a base-4 number (0, 1, 2, 3, 10, 11 .. etc ..) and adding 1 to it every cycle. Then, I left-pad the number with enough zeros to make it ten digits (so 121 becomes 0000000121). Next, it will take each digit from left to right and add the value of the array at that digit's index. If that's too confusing (because it is), I have an array ['AT','TA','CG','GC']. If I have the string 0123000000, it goes left to right picking from that array's index. 0 is 'AT', 1 is 'TA', etc. Then those 10 array values are concatenated into a single string, then that string is pushed into the results array. The loop continues to "max" which is the number of pairs to the power of the resultLength (4 to the 10th power).
&gt; Is there any reason or best practice to using something like console.log("value of myvar is : %s", myvar); ? If your codebase is in es5 and you can't transpile, then you don't have a choice but to use this style.
If you focus on learning the language and fundamentals of program/software design, then it matters less about what framework(basket) you put your "eggs" into. 
Web browsers should not allow such sensitive information to be accessed. However, there are ways, such as https://clipboardjs.com/ 
For something like this I would use Array.map and loop through the dataset array and pull out values where index = xVal but I feel that might be too much for intro to JS. For something like this maybe: var xVals = []; //create a new empty array for xvals var yVals = []; //create a new empty array for yvals for(i=0;i &lt; dataset.length;i++){ //loop through dataset for length of dataset array xVals.push(dataset[i].xVal); //push xVals into xVals array yVals.push(dataset[i].yVal); //push yVals into yVals array } console.log(Math.max(xVals)); //find max of xVals array and log it console.log(Math.max(yVals)); //find max of yVals array and log it edit: didn't notice you needed yVals too
Yeah, keep using template stings.
Actually I figured it out a moment ago without using a for loop, I can post the method of you like, but thank you guys for all your help!! :)
Yes, you're on the right track. Just keep plugging away and in 6 months you'll be happy with your progress. And don't be intimidated by the command line. You don't have to be a UNIX/bash god to run webpack etc.
The one you should make!
I'm on my phone at the moment, I'll post it when I get on my computer :)
What exactly do you mean here, an example to learn from?
Didn't even know you could do that. I always just used console.log("value of myVar is " + myVar); What's the advantage of template strings?
I'm amazed you even had this idea, let alone went ahead and put a lot of hard work implementing it. I personally find the history fascinating, going to read this after work. (I played a small role in the UMD era.)
Most shared hosting doesn't allow you to install anything fun like node. Your best bet is getting a VPS somewhere to play on. I love digital ocean. 
Yes; this is neat! I forget about the bind methods since ES6 spread (...) operator allow for this to work: Math.max(...dataset.map(function(o){return o.xVal})); the ... basically does the same thing as .apply here but I still learned a little something; thanks! 
terrible name given that it is not an implementation of the raft consensus algorithm. 
K
Yeahhhh haha I became aware of that algorithm a little while ago, but didn't think it'd be a huge deal. I suppose if this were to ever gain some traction I might look at a name change. But for now I don't think it's a big deal.
I have node installed on my shared host. It really should just be a matter of pulling down the package, simply unpacking it, and finally updating the path. I don't have sudo or any kind of admin access on my shared space. Now, to be fair, I am just using Node as a systems utility. I am not running it as any kind of service or web server. I have done this before using something like forever to keep a process continuously running. It always eventually goes down though. My shared host has custom modified OS kernel to watch for excessive CPU draw and kills the process and watches for auto-respawn of the process and then kills that which spawns the node instance.
uery
I hate jQuery 
Looks useful, but unfortunately it [doesn't look like](http://imgur.com/zPLY5By) it supports Scala. Maybe one day!
Thank you
thank you. it worked in my ddwrt router.
There is a jQuery 3?
I'm confused by the comments here, are people not using jQuery anymore?
"Less than x lines using y" is nonsense... "Gmail in one line using gmail.js" Just say you wrote a piano. Cool.
jQuery's pretty great man. I don't have much wrong with it. It's big, sure, but it does everything and makes my life so much easier. What do you hate about it?
React, Vue, angular, vanilla es6
Well damn. I guess I better start learning those then, shit. Can we just agree on one and stick with it? Lol.
&gt; Can we just agree on one and stick with it? Lol. You must be new to .. well ... *everything*.
If i understand the problem you're trying to solve, I think you could achieve everything via anchor links. Have links in the sidebar that are essentially `&lt;a href="#problem"&gt;immiproblem&lt;a&gt;` and then mark the content you want to scroll to with the corresponding id like: `&lt;div id="problem"&gt;this is the problem...&lt;/div&gt;`. If you want to animate the scroll, you could iterate over the sidebar links, adding click listeners, preventDefault and run your scroll method.
I hate Angular. Now we both feel better!
Briiiiick....
Yes, that is what I'm trying to implement, but cannot get it working yet :C.
You don't need to assign them individually, HTML **IS** data. Don't let the framework/library zombies tell you otherwise. [link](http://redditairplane.com/sideProjects/simpleSPA/) edit: it occurs to me you might just be looking for an article on [fragment identifiers](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-href)
This is cute.
It's probably the most widely used JavaScript library in the world and running in production on a ridiculous number of sites. Anyone saying nobody uses jQuery anymore is absolutely full of shit. Hell, even somewhat modern JavaScript projects that use package management depend on jQuery, it's has 3 million monthly downloads in the NPM repository. There's just less reason to use jQuery if you target modern browsers or use a transpiler, because the APIs have evolved, there's less cross-browser issues and the language itself has become more convenient. jQuery is practically ingrained into things like WordPress, with massive arsenal of plugins anyone can use to get basic interactive elements on their site. That isn't going away any time soon. I haven't needed the library in a good while and have been fortunate enough to work on applications for modern browsers using the latest bells and whistles, but I'm so annoyed when there's a new release and people go "someone still uses jQuery?" Yeah, people still use jQuery. If it disappeared overnight we'd be in much deeper shit than if some of the modern favourite libraries went away. jQuery is a "skill" many employers still actively look for when they recruit developers, which should say something.
&gt; When we dropped Glimmer into our flagship app, we saw between 10 - 15% improvement in Real User Metrics (RUM) at the 90th percentile in the U.S here's some perspective: https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts/table.html