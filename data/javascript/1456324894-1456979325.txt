Dart is getting [generalized tear-offs](https://github.com/gbracha/generalizedTearOffs/blob/master/proposal.md). You can closurize anything. Constructors, named constructors, getters, setters, and even operators. class Foo { int _x = 0; int get x =&gt; _x++; } void main() { var ctor = new Foo#; // tearing off the ctor var instance = ctor(); var getter = instance#x; // tearing off the getter print(getter()); // 0 print(instance.x); // 1 print(getter()); // 2 } Kinda wild. It isn't needed for methods (foo.bar works fine), but you can also use # for that if you like.
Always check the console (F12 -&gt; Console) for errors.
Yup, totally - right up /r/techculture's alley.
I did, no errors there.
https://github.com/MrRio/jsPDF/releases Latest release: Sep 29, 2014 (Pre-release: May 16, 2015). Assuming, that by active you mean master branch, is there any information on how stable it is?
yeah dunno what that guy was talking about I've been using webpack and loving it. I found the tutorials very simple to follow. As far as getting your package.json setup correctly I've been using yeoman to generate a project template then customizing from there. They got tons of generators to fit just about anything your trying to do. I use this one mostly cause i use react https://github.com/newtriks/generator-react-webpack you could probably search around and find just what you need to get started.
I've done that :) I thought since the fiddle dint wrap the code between script tags you assumed I haven't done either.
I'm confused as to how this works. It doesn't seem to start/stop any server to be able to view the different components, so how would it go through the repository?
I would argue that they are not excellent developers. Maybe excellent programmers, but excellent developers are good at - wait for it - *developing* software. Like you've pointed out, if your people skills suck, it makes getting work done hard. A former manager/mentor of mine always pressed me to utilize and develop my social skills and teamwork as much as my 'technical' skills, and it has definitely served me well.
Did you test on OS X? It doesn't seem to be working for me...tried Chrome, Safari and Firefox 
Can you show me an example of how to do private scoping elegantly in OOP JS?
Sorry, but having to bind / call / apply the correct context is not good. In classical inheritance OO languages, you don't have to do that. The context is fixed and reliable. Because it's not in Javascript, it's far more prone to entire classes of errors that simply don't exist in other OO languages. Yes, it's "powerful" to be able to supply a new context to a method, but I've not run into many scenarios in programming (in any language) where that would have been a necessity. And yes, you CAN do that in other languages if you want, but nobody does because there's almost never a reason to do that. Doesn't justify the opportunity to call those functions incorrectly. Leveraging closure and scoping is better than using `this` in JS by miles.
Try explaining this at job interviews though. All project owners seem to think their project requires the fanciest of design patterns and so on. Even if the project is a simple line of business application. Sigh. It'd be funny if it wasn't sad. 
instead of return quote: (pseudocode) get element with class "box" set textcontent of this element to randomquote
I have no idea how to write that.. var quote = document.getElementById(randomQuote); quote.class="box"; ?
Yes, you and I are in agreement - this is precisely what I was talking about before, but your example is not OO JS. Here is what I mean by OO JS syntax that is the closest thing a Java developer might get to familiar feeling OOP: function User(age) { this.age = age; } User.prototype.haveBirthday = function() { this.age++; } var user1 = new User(30); There's no privacy here. You can't encapsulate behavior because you can just directly set age to whatever you want. Meanwhile: function user(age) { var age = age; return { haveBirthday: haveBirthday }; function haveBirthday() { age++; } } var user1 = user(30); Is far better. 1. No wonky `this` behavior that depends on calling context 2. Can't set age directly, it's totally privately scoped. 3. Don't need to follow the idiomatic convention of capitalizing the first letter of the function so developers remember to use `new` with it (and `Object.create` is a far less elegant way of newing up an instance compared to other languages) THAT is good JavaScript. OOP JavaScript is just shit in comparison to its functional equivalent, and other OO language implementations. The only argument against that factory function pattern is that it eats more memory as 100,000 users will have 100,000 full definitions of functions and state, rather than just state. But it should be exceedingly rare you need that many instances of an object in memory, so in reality, the higher memory consumption of object factories is a non-issue.
Microsoft has tried this before. Typescript is JScript.NET 2.0 
I think there is an aspect of oversensitivity, it's a colloquialism that means "separates the mature from the immature" - Google can help you out with those: https://www.google.com/search?q=define+separate+the+men+from+the+boys It's not about being sexist or exclusionary - if anything the offense is towards adults who act like children. It's just a locale-specific phrase that subjectively sounds better than "separates the immature..."
This is why most software projects eventually require entire rewrites. Over time you'll probably discover that investing those two days (even if for the sake of elegance) will save your entire team months to years of work when they don't have to scrap the huge pile of rushed hacks and start over. And before that rewrite happens, those single quick fixes turn into several dirty fixes that take a few days to implement without bringing down the house of cards. Maintenance is a daily chore, and when you start fixing those pain points early and often you'll ultimately train yourself to write better code to begin with. Just like paying off the balance of a credit card every month is easier than digging yourself out of $20k of debt. Pay off your technical debt as you go and you'll avoid the need of a rewrite (bankruptcy) altogether. And of course be pragmatic about it, clean code does not need to be gold-plated.
I usually add a few new questions for each track every week, so there will be more soon!
I'm not sure what that means or how do I run it "on Load"?
Just tried that, nothing. Could you tell me about the "webserver" u/senocular mentioned that I need to have to run the script? 
As this only works with browser that support touchstart, touchmove and touchdown (i.e. no MS Edge), consider using the Pointer API. There's a great polyfill available: https://github.com/jquery/PEP
It's "else **if** (...)". Always check the console (F12 -&gt; Console) for errors. I also recommend to use an editor which does syntax checking like VS Code.
 boundFn = (arg1) =&gt; (arg2) =&gt; fn(arg1,arg2) Purely esthetical, but you can also just do boundFn = arg1 =&gt; arg2 =&gt; fn(arg1,arg2) Which IMO looks better than binding with nulls. But IMO even when you keep the (), it still looks better than .bind(null.
You can take the conclusion reached in the article to another level. JSX is not necessary to write react at all - you can use something like [hyperscript](https://github.com/mlmorg/react-hyperscript) and not need to transpile your code at all.
Nice work, these are fun. A couple of suggestions: * The answer buttons are hard to read with the white text on a light blue background. More contrast needed here. * After tapping an answer button, there is no clear indication of whether it is the right answer or not. The button for a right answer turns green and a wrong answer turns red, but that is not obvious at first, especially if you tap the right answer each time. Suggest changing the Solution heading to also indicate if the answer was right or wrong. Keep up the good work!
You only return something from a function if somewhere in a function you tell it to return a value with "return blah". If this is the case, you need to set your function invocation (when you run the function with function() ) equal to a variable, and then use that variable in some way. Here's an example that shows what I'm talking about: &lt;div class="box"&gt; &lt;button&gt;Click me&lt;/button&gt; &lt;div id="box-quote"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var quotes = ['quote1', ' quote2', 'quote3', 'quote4', 'quote5']; var button = document.querySelector('button'); button.addEventListener('click', function() { var result = getQuote(); document.getElementById("box-quote").textContent = quotes[result]; }); function getQuote(){ var index = Math.floor(Math.random() * quotes.length); return index; } &lt;/script&gt; Here we're not using the onclick="" handler attribute; we're instead adding an event listener to the button by first storing a reference to it in a variable called "button", then using addEventListener() to add an event listener to the button — when the button is clicked, the function inside addEventListener() is run, which includes the key line "var result = getQuote();" This runs the getQuote() function and sets the result returned from it using the return command (the index variable) to be equal to a variable called "result". The next line: document.getElementById("box-quote").textContent = quotes[result]; Then sets the textContent of the box-quote &lt;div&gt; to be equal to the contents of the result variable. Now, this may look like a lot more code to do basically the same thing, but it is a more reusable way to write JS — it is a bad practice to use HTML event handler attributes, as you are mixing content with functionality, and if you wanted to have several buttons doing the same thing, you'd have to write and maintain several event handler attributes. instead you can do the same thing with a couple of lines of JS, and keep it easier to understand and maintain. Also, by updating the getQuote() function in this way we've made it more reusable — now you can return a random quote index and use it anywhere you like, not just in the one particular &lt;div&gt;. You could improve it further by putting the random number generation into its own function, so it could generate any random number you like: function random(myArray) { var number = Math.floor(Math.random() * myArray.length); return number; } function getQuote(){ var index = random(quotes); return index; }
What do you mean? 
In theory, Arrow functions should be faster since they should have less overhead (no extra bindings), but afaik, in practice, there's no guarantee that this will be taken advantage of in the near term: it's up the engine builders to do all this optimization work... and it took them *years* to get there with es5.
Funny enough, if you paste the code there in to CodePen as is, it doesn't give any warnings or throw any errors in the console (Chrome). http://codepen.io/anon/pen/LGwwKe How's it get away with leaving out the if?
[removed]
Thanks for the tips! I'll work something out with the contrast of the buttons and answer text. And maybe for the solution sliding down, I'll have the header say "Your answer was Correct/Incorrect" or something similar. I'll give it some thought, but thanks for the recommendations!
TypeScript is the new Coffescript. It'll be really cathartic to see it and Angular 2 go down together. remind me 3 years
Because it is perfectly valid javascript, even if it does not what you expect.
[removed]
Amazing. Next steps: 1) Ditch html, css and javascript. 2) Go plain text. 3) Uninstall all your web browsers. 4) Use curl and enjoy.
&gt;Arrow functions should be faster since they should have less overhead (no extra bindings) What do you mean by this? Arrow functions are a shortcut for Function.bind, they all bind.
You know what is really backwards and needs improvement? The arrogance of programmers without any education in design that still want to tell designers how they should do their work.
You can also use `.bind` to pre-fill function parameters, i.e. partial application.
And just to add: here's a [relevant portion of the spec](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-arrow-function-definitions-runtime-semantics-evaluation) (see the note) and [explanation with examples](http://blog.getify.com/arrow-this/) from Kyle Simpson.
You use it when you want to tear off (or "closurize") a method. E.g. if you want to create an alias for querySelector: var qs = document.querySelector.bind(document); qs('#foo').addEventListener('click', function() { qs('#bar').innerHTML = 'ohai'; }); Another common scenario is when you want to call some method via setTimeout or setInterval. You have to glue the "this" object to that function in order to pass it around. https://jsfiddle.net/qkLcuh8f/ (a bit of a mess, but you get the idea)
It should also be easy to maintain, refactor and reason about somebody else's code. I would rather insert a glass rod into my urethra and snap it than wade through a large teams' type "agnostic" code to do refactoring. When you talk about code completion working OOTB, you're absolutely wrong. It is guesswork completion and will only be caught at runtime if incorrect. You can say, well, I don't need unit tests because they're hard to read, too. Doesn't make you right.
Wow, thanks! function foo() { return () =&gt; { console.log("id:",this.id); }; } var arrowfn = foo.call( { id: 42 } ); setTimeout( arrowfn.bind( { id: 100 } ), 100); // id: 42 That cleared it up for me. I always assumed arrowFns did an implicit bind to the outer function's context. 
Yea, that pointless expression becomes the else-branch and what follows is a block which is executed either way.
Right. Just found that if you add a line in the code: var forine = 11; Because 'forine' is a substring in the search string, it gets colored red.
Yep. The rest is a block.
Let me tell you as a TypeScript believer I don't even know what that line is supposed to do, never felt the need to write my code like this. Only use what you need. TypeScript brings you 2 features: Type checking Transpiler Great thing about TS is that it is just JS with type annotations. It adheres to the JS standard, present as next(as much as that is possible). So you can in fact write JS hand it to the TS compiler and get your JS back. Use it where you want, no need to use type annotations everywhere. Even if you don't use type annotations at all you can still use TS to transpile your ES6 code down to ES5/3 like babel. Of course the beauty of it comes when you use type annotations and the latest JS features that then get transpiled to run in todays browsers all in 1 step You can't get that type of comfort with Linters. Not to mention autocomplete support is unparalleled since it was typically hard to do for JS with no type annotations. You had to guesstimate. Not only can the pc understand your code better, humans also benefit from it. Looking at a function definition you see instantly what types the parameters are, if it is a custom object just ctrl left click on the type to jump to that type. No more need to skim through the function body. If you don't see the benefit in any of that, then well TS is not for you, use if you need it, not because it's popular right now.
exactly. var foo = function() { console.log(this.name); }; var x = { name: 'x' }; var boundFunction = foo.bind(x); boundFunction(); // above two lines are identical to: foo.call(x); 
The main hiccup in OOP JS is the lack of pointers. Such a pain to workaround.
Aha! Thanks!
[Neovim](https://github.com/neovim/neovim) + [Neomake](https://github.com/benekastah/neomake) + [eslint_d](https://github.com/mantoni/eslint_d.js) is the (fast) state of the art. Eslint has fulll support for JSX and ES2015 among other things. Protip: stick a [nice](https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb) `.eslintrc.js` in your home folder, and (optionally) copy it to the root of any shared projects. Programmatically standardize project style. Burn the unbelievers. 
It may work on iOS devices, but probably not on OS X. The trackpad events are not sent as touch events I guess. If I get my hands on a OS X device, I can check. 
I see. Thanks for taking the time.
That makes sense, maybe time to refactor some bits.
Both are available in some form or another in livescript (some of my examples above are in it). I really cannot recommend it enough if you're doing more functional work in javascript: // pattern matching-ish smallest = (a, b) -&gt; | a &gt; b =&gt; b | a &lt; b =&gt; a | _ =&gt; null smallest 4, 5 // 4 // pipe [1 2 3 4] |&gt; map (* 2) // partially apply an operator |&gt; map (-&gt; it + 3) // implicit 'it' in a function |&gt; console.log _ // partially apply console.log to get [5, 7, 9, 11] // really useful for things like setTimeout -&gt; $ 'p' .hide() |&gt; $ document .ready // compose odd = (not) . even odd = (not) &lt;&lt; even odd = even &gt;&gt; (not) // automatic curry add = (a, b) --&gt; a + b add-two = add 2 add-two 3 // 5
This is something I like from Redux. It gives you this concept of stores where you can save your data. And then you can fetch just the data you need with a selector. Selectors are functions that pick data and pass it as props to the components. That feels like an actual solution, and later down the road when you want to test your app is easy to create a mock selector that passes test data to the component. When I'm using Node.js I do store the user inside the request object. `request.user = userFetchedFromDB;`
They don't *re-bind* the this, arguments, super, or new.target keywords. MSN: "lexically binds the this value (does not bind its own this, arguments, super, or new.target)." I'm not sure it's a distinction with a great deal of difference for coders in practice, but in theory it seems like you could build arrow functions as the base case and then implement conventional functions as adding in keyword re-binding logic. 
Great examples of the sort of flexibility these things add. I'd love to see autocurrying come to native javascript, but it sounds like there's no real consensus on how to add it. It's definitely cumbersome to have to wrap functions in a auto-curry function or else use a utility library that does it by default.
So the answer is yes. Failing to update all your apps to Webpack yesterday will lead to financial and personal ruin. Ha. People thinking they can get jobs without 2+ years of ES6 experience.
Hey, thank you for getting back to me. I'm just having a look at changing this to setTimeout() now, and letting it run so that I can test and check its all working okay. So, will setTimeout() not speed up in the same way that setInterval is? Sorry if this is a silly question, just trying to wrap my head around what's happening!
I found Grunt with grunt-babel easier than Webpack to setup for compiling JSX, but maybe that's just me.
I started using VSC a month or so ago because we are thinking of using it as a baseline for our bootcamp students. Its git integration is reallllllllly good and super easy to use. This tool is another nice touch.
Hmmm, will do. Should i delete this post?
After looking into this, Context would not help at all here, as the parent node content won't exist during a unit test.
So you are mocking Redux and React-Intl in all your tests?
Works on iOS Awesome work 
~~~I disagree on the 2+ years ES6 experience. Explain why it would take 2 years.~~~ ~~~If a season dev. knows multiple languages, including JavaScript, learning ES6 doesn't take 2 years. Solid 6 months heavy usage on real projects is enough time and practice for any seasoned developer.~~~ ~~~Everything in the [feature list](http://es6-features.org) is already available in other languages. If a developer knows how the features work in other languages then it's just a case of learning the ES6 "language".~~~ ~~~Some of us don't have the luxury of being able to devote all our time to learning everything possible. Bills need paying.~~~ Oops I misread that joke. My bad.
I believe that shared web workers are only active as long as a tab to the domain is active and maintains a connection to it. It sounds like you may want to look into Service Workers, which live beyond the lifetime of the page.
Very interesting. Will definitely try it out. Been using VSC for 3 months now both for c# asp.net 5 and js/react. Works very good, the eslint extension does wonders for our code quality when working in a team of students. If you are using vscode for javascript, look into enabling Salsa.
Hmm. I still don't seem to be having much luck. I've removed setInterval() &amp; clearInterval() and replaced them with setTimeout(), so this is what I have now: http://pastebin.com/LZxq08Uc But for some reason it still seems to speed up like crazy after a while. This is for a dashboard that's running in Chromium on a raspberry pi - so once the web page is open, it just stays open. It's working fine - except for this interval which speeds up gradually and eventually becomes a strobe after an hour or so. Have I implemented setTimeout() correctly?
Might have to try Code soon. But I like atom too much :(
Kent explains here (https://medium.com/@kentcdodds/first-timers-only-78281ea47455#.w1pc6w6vj) how to get started. Have fun!
You've to use setInterval or requestAnimationFrame to do your animation loop. Within this loop, you've to iterate over all still-active buttons and update their "value" attribute. Use CSS to make that "value" attribute show up on the button as text: https://jsfiddle.net/utr5rgky/ &gt; can i use that document.getElementById("something").value thingy to name a variable? No. But a user won't see what your variables are called anyways.
 &gt; document.querySelectorAll function querySelectorAll() { [native code] } &gt; document.querySelectorAll('object') [&lt;object type=​"application/​x-shockwave-flash" id=​"flashtest" name=​"flashtest" data=​"netgauge.swf?v=3.0" width=​"620" height=​"420"&gt;​…​&lt;/object&gt;​] &gt; document.querySelectorAll('object').constructor function NodeList() { [native code] } Yea... so?
Well.. you wouldn't setup webpack *just* for JSX compiling.
That looks fun. What was the inspiration behind it?
Weird... This is what I'm getting =&gt; http://imgur.com/0Qnze7H
- prefer map rather than prefer pluck - prefer filter rather than prefer where - prefer find rather than prefer findwhere - prefer lodash rather than prefer underscore
This also solves a problem posted in [this related /r/javascript thread](https://www.reddit.com/r/javascript/comments/33f9kv/how_can_i_restart_a_js_function_i_have_a_music/)
You could, but JSX is just a much nicer way to express it and looks more familiar to people who already know HTML. 
To convey grouping information in a limited space. Certainly background-color or other CSS stylings can accomplish this, but if members of a group are spread out and not actually all physically together, the fluid contiguous connections across distances add to the visual language.
Bundling code into fewer files means fewer network requests on the client. RequireJS's optimizer supports this kind of bundling as well.
Every time I use Code I see there's no plugin for X so I go back to atom. Plugins I need: sftp browser, react with jsx syntax, a terminal, monokai theme, eslint w/ line by line linting, minimap and a few others. It's not much but not having those severely hinders my development. My roommate likes Code but he doesn't like to customize things, no extensions in chrome, no useful computer apps.. he codes in JS with no linting or any Code plugins at all. Code seems to have that market... Customizations are important though to a lot of people.
I've Googled salsa, but haven't found anything except change logs and github issues. How do I do? Edit fixed words
Thanks I'll give it a try
I was [inspired](https://www.reddit.com/r/javascript/comments/46uu1w/question_what_do_you_use_for_syntax_checking_in/), so I wrote a little wrapper around `eslint` and `esformatter` to use as my equalprg. So far it's great. You can probably make it work with other editors, but I dunno anything about that. 
Wow...going to have to try code soon. I love the simplicity (yet highly functional) of Sublime Text, but I also love VS an IDE, so I can imagine that VSCode is really god as well. Not only that, but it is an accepted download at my company while ST3 is not unless paid. I also like a lightweight editor to compliment my IDE and for when I am not near a wall charger on my laptop. This only makes it so much better.
One semi-crazy use case is binding a bind method with which you can use to bind a function: var bind = Function.prototype.call.bind(Function.prototype.bind); bind(function(){console.log(this,arguments)},{foo:3},7)(9);//-&gt; {foo: 3} [7, 9]
They are starting to bring some strong stuff. Something to keep an eye on.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/tinycode] [Experimental URL abuse • \/r\/javascript](https://np.reddit.com/r/tinycode/comments/47h7kq/experimental_url_abuse_rjavascript/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
If it's a new project or you have the luxury of switching, I would recommend Webpack. Not because RequireJS and Browserify are bad or that you won't be able to live without Webpack, but because these technologies are evolving and improving and Webpack is the best in the biz right now. Things like dynamic requires (https://webpack.github.io/docs/context.html#dynamic-requires), bundling static assets, hot reloading, etc. are things that may be a benefit to you. I know dynamic requires was the first thing that kind of forced me to drop RequireJS and Browserify and move to Webpack. Your requirements may be different than mine though. For what it's worth, I used to do a lot of work with RequireJS and wrote about it quite extensively (http://aaronhardy.com/tag/requirejs/). Good luck.
I found that atom was just too slow and buggy for me personally. I tried Code and it just worked. I'm just using it for js/webapps. 
Here's the [scoop on salsa](https://code.visualstudio.com/Updates). It's javascript that uses some typescript mechanisms to provide a better editing experience. 
Just added support for Smooth reset, and touch events to parent of the image. Not adding IE support yet, mainly due to the fact that touchstart is split into two events for multi-touch with pointerIds. 
That should be quite easy. Do you have a small recommended library? I would use the native crypto, but I'm only using http (no https) on my rented server.
I don't. Your guess is as good as mine.
For me at least, with code I don't have nearly as many performance issues or crashing as I did with atom. I also really like the "working files".
&gt;repitiour
Completely agree. I just can't get used to not having vim keybindings (something even less supported editors have had for a long time). Third highest request on their support: https://visualstudio.uservoice.com/forums/293070-visual-studio-code/suggestions/7752447-vim-style-keybindings and has been "Under Review" since May 2015. The best plugin for VSCode is currently https://github.com/VSCodeVim/Vim but that doesn't even support simple things like yank (yy), paste (p), delete&lt;motion&gt; (d&lt;motion&gt;, change-inside&lt;character&gt; ci&lt;character&gt;, visual mode. This is just the basic stuff and it isn't supported. Also it's insert mode is very buggy often jumping out of insert without any reason or visual cue which leads to many unintentional keystrokes. There is an alternative called vim-style but there is a whole bunch of essential stuff that it proudly states in it's readme that it will "never support". I'm shocked that there are no devs on the official VSCode team who used vim or other editors with vim keybindings. I could be wrong but I think when sublime came out they had vim support from day one.
Ah, then it makes more sense :) Were they complaining about the lack of `goto` in Javascript? :P
&gt; The only downside Well... It also only supports one browser... (And one editor, but that's to be expected :P)
Yeah, I agree. I try to use fat-arrow everywhere it makes sense now.
And HTTP2 makes this moot. :)
nice work, but are there any benefits over debugging directly in Chrome? Cause the chrome dev tools are actually already pretty amazing, at least for me, it gets the job done.
I use Atom for JS apps and it's not slow for me... When's the last time you tried it?
We made a similar thing a few years ago, in 32 bits: https://github.com/xem/32b
Thanks for this!
Just come back to this as the other solutions didn't work, this might not be the most optimum solution but the best by far, works in every situation no matter the length of the word. 
Long story short I'm bringing in data which is location names, from the server they come with hyphens instead of spaces. hyphens need to be removed and words need to be capitalised to display properly front-end. very good solution posted by: rightturnclyde34
https://tweetnacl.js.org/#/ is great. 
Thanks. It looks good, I'll give it a go.
I've used this lately in production. The main downside with wkhtmltopdf is that you can't use javascript to render your page, only static html. 
It's in all the passport examples too, here's the real answer: http://stackoverflow.com/a/20774958/2277117 In my opinion it's unnecessary and just serves to confuse people. Proof being that I've seen code in the wild that mimics it for no good reason.
What are some of the packages that cannot be built with Webpack? I haven't encountered any yet, although I'm sure there are some out there!
Yes you can! If you have issues you probably need to set the `--javascript-delay` option, it defaults to 200ms. http://codingexplained.com/coding/php/using-google-visualization-with-wkhtmltopdf
I've done something similar in the past with a browser game. Basically when you create your map, each tile should have more states, in your case it should be 'clear' or 'not-clear' or any other naming convention you want. If you move the character manually, it's simple, when you try to move on a tile that is 'not-clear' you won't and maybe a popup with a message will appear. If you move the character via a script(say Astar for pathfinding), you just need to make sure you only consider viable options(tiles that are 'clear').
I think you mean [Phaser](http://phaser.io/), Pixi.js is a simple renderer. Otherwise there is plenty of physics engines in JS.
Noob question, Why use underscore map when array has it already ?
:) whoops, thanks!
You'll not want to bother with canvas, have a look at http://phaser.io/ and http://www.pixijs.com/ for 2D and http://threejs.org/ and http://www.babylonjs.com/ for 3D. 
They output to canvas via webgl, fallback to the regular canvas context api where it's not supported.
Yes, it's something like that I would like! But is it possible by using data attributes ? I have no idea ! Thanks for hlping me :)
Should be, the attr() function can change pretty much any attribute of a DOM element. Just change src to be any of the attributes you wish to target.
yeah, I'm trying but it doesn't work, the iframe src doesn't change :( here is my code so far : &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Button iframe&lt;/title&gt; &lt;style&gt; div.btn { padding:5px 15px; display:inline-block; margin:10px 20px; background:#4aa3df; cursor:pointer; border-radius:3px; } &lt;/style&gt; &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function(){ $('.btniframe').click(function() { $('#iframe').attr('src', $(this).data('url') ); }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;div class="btn btniframe" data-url="www.wikipedia.fr"&gt;url1&lt;/div&gt; &lt;div class="btn btniframe" data-url="www.wikipedia.com"&gt;url2&lt;/div&gt; &lt;/nav&gt; &lt;iframe id="iframe" height="800" width="800" src="http://www.wikipedia.fr/index.php"&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; Am I doing something wrong ?
You did not load jQuery anywhere, include the jquery script before your javascript code, right now $ is undefined.
Phaser uses Pixi as its renderer engine. Pixi is the most performant canvas replacement (with fallback to canvas where needed). I second the advice given. If you've never done any kind of game programming or you are alien to the front end ecosystem, you're better off going with Phaser. Alternatively, if you want to reinvent the wheel, I would recommend this talk as a very basic starting point: Mary live-codes a JavaScript game from scratch https://vimeo.com/105955605
You're welcome! Once you do a couple more sites it'll stick in your head and you'll never forget it ;)
Browser compatibility (map was only introduced in I.E. 9), consistency (I don't want to have to remember which methods are native to which methods are underscore), and strangely: performance.
I absolutely realise that. It's just unfortunate that there are sometimes [over-reactions](https://www.techdirt.com/articles/20150723/06094731734/geniuses-representing-universal-pictures-ask-google-to-delist-127001-piracy.shtml). The same argument could be used for torrent trackers - they don't host they just link. Anyway far be it for me to spoil the fun. Great proof of concept!
In my experience "engineer" can be a buzzword but not always. I'm currently working as a UI engineer (buzz buzz) and I think the title is fitting. I spend more of my time solving architecture problems and scaffolding an app where as the developers are in the trenches solving individual stories. Plus engineers make more money (;
The main benefit is it feels more like an integrated experience. You it the debug button and the breakpoints you set in your actual code are hit. No fussing around with finding them in chrome's sources, setting a breakpoint, and then refreshing to get the point hit. I agree however that chrome dev tools are pretty awesome, and when you need to do some other things, like inspecting HTML or looking at DOM event handlers, the code debugger falls short. But it feels a lot more smooth when you're debugging JS code.
Well, if they said "code now has native debugging in Edge" people would go "so what?". This is one of the problems that visual studio proper has - a lot of its tooling has good integration with IE, but much less so with other browsers, which is a problem if you're not fond of IE.
Impossible? If canvas is just the view layer, and with JS being as fast as C 5 years ago, not impossible. Just no ones really done it yet.
Why are you jumping from a method of rendering to a method of client/server connection? Seems like a total non-sequitur. Are you saying websockets are impossible?
Use Pixi. Having made a MMO-like thing with canvas I can definitely say that achieving stable 60 fps with any complex graphics is not impossible of course, but much harder than one would expect. I originally went for pure canvas instead of Pixi because I didn't want to mess with scenes and sprites and preferred to handle sprite logic myself. I was wrong.
is Phaser the go-to library for 2d now? I've used impact.js in the past, but last I checked it didn't seem to be actively worked on.
i personally pick projects i like using. Eslint was a good one for me. they have friendly maintainers, lots of rules and guides (so youre not just floundering on what to do) etc. When i made a rule suggestion, they asked me if i would be willing to fix it. So i did.
Still not as bad as IE/Edge, though. 
Javascript isn't exactly the most CPU or memory efficient thing, but it could get the job done for something simple. There's a pretty nice 2D/3D HTML5 engine and collaboration tool called [Superpowers](/r/superpowers) that you might want to check out. [Examples here](https://itch.io/c/27733/games-made-with-superpowers)
Why not just use the esformatter plugin for Vim? I'm not using it but I think there's also a plugin to show eslint errors.
The author mentions contextless arrow function from es6 but doesn't even mention or use them in coffeescript.
Interesting article. Thanks for sharing. I think elmish is very similar to the framework [CycleJS](http://cycle.js.org/)
Here's a web page hosted entirely on reddit: data:text/html;charset=utf-8;base64,PCFET0NUWVBFIGh0bWw+DQo8aHRtbD48aGVhZD48dGl0bGU+SGVsbG88L3RpdGxlPjwvaGVhZD4NCjxib2R5PjxoMT5IZWxsbyB0aGVyZSE8L2gxPjxwPlRoaXMgVVJMIGlzIGVudGlyZWx5IGhvc3RlZCBpbiBhbiBVUkwgc2hvcnRlbmVyPC9wPjwvYm9keT4= It's a perfectly valid browser URI, but I couldn't find a shortener that supported it.
It's interesting to see this comparison, but the "insane littering" of the author's opinion throughout is distracting.
When I think of Ace I think of https://github.com/ajaxorg/ace/ The project looks really cool though.
I like the idea of the project. Hate the name they chose. Ace is already a well known Javascript web editor.
Too bad nobody will use it
Here you go! https://medium.com/@chetcorcos/elmish-functional-programming-in-javascript-50995f1d4b9e#.jjbqx189l
Looks like a more rudimentary version of NativeScript.
Write a pull request.
Worst article I've read in a long time. I'm still not sure what it was trying to accomplish.
To see why your code is not equivalent, try running: `new TaylorClassic` and compare it to: `new taylorClassic`
I use it *all* the time. One usage, say you're given an array of objects from a datasource var arr = [{id: 1234, name: 'hello'},{id: 3333, name: 'foobar'}] Once I get the data out, I often times need to directly access an object to do some transforms, join data from other sources (such as adding time-series data from elasticsearch to some document out of a document store or SQL db), and export it. Scanning an array each time when I'm looking for a specific object is inefficient, so I usually transform the data using reduce in order to optimize for direct access: arr = arr.reduce((names, item) =&gt; { names[item.id] = item.name; return names; }, {}); Now I have an object that makes getting directly at an item very easy. getMetricsFromElasticsearch((err, metrics) =&gt; { if (err) return done(err); metrics.forEach(metric =&gt; { arr[metric.id].clicksPerSecond = metric.cps; }); return done(null, arr); }); Which is a generalized worst-case O(n) efficient solution vs an O(n^2 ) one if I used arr.indexOf() or something similar to search through the array each time.
Here's how I do collision for 8-way movement; it can certainly be simplified by the way ;)! Main thing to keep in mind with collision is, do you want to setup boundaries or do you want to register actual collision events (where the objects you're checking share the same space), and then go from there. This example sets up boundaries, basically it returns true if there's a collision or false if not and from there I can use that check to determine the next course of actions. This function also refers to a parent global (mapActive) that just contains an array similar to your map. Also, the reason I'm using floor and ceil is because my character in this game could move distances shorter than the actual single block of an image in the array. So for example, a tree may be 16 pixels high, my character can move 1 pixel, so I have to check is the pixel position of the character within a range that could cause me to hit the tree (hence floor/ceil to check upper and lower bounds). This concept can be evolved further and further for checks depending on how precise you want your interaction to be. function collision(direction, objectX, objectY) { var mapX = [objectX, objectX, objectX]; var mapY = [objectY, objectY, objectY]; switch(direction) { // left case 0: mapY[0] = Math.floor(mapY[0]); mapY[1] = Math.ceil(mapY[1]); mapX[0] = Math.ceil(mapX[0] - 1); if (mapX[0] == -1 || eval(mapActive[0])[mapY[0] * mapActive[2] + mapX[0]] != 0 || objectY != mapY[0] &amp;&amp; eval(mapActive[0])[mapY[1] * mapActive[2] + mapX[0]] != 0) { return true; } break; // left-up case 1: mapX[0] = Math.floor(mapX[0] - 1); mapX[1] = Math.floor(mapX[1]); mapX[2] = Math.ceil(mapX[2]); mapY[0] = Math.floor(mapY[0]); mapY[1] = Math.ceil(mapY[1]); mapY[2] = Math.ceil(mapY[2] - 1); if (mapY[2] == -1 || eval(mapActive[0])[mapY[2] * mapActive[2] + mapX[1]] != 0 || objectX != mapX[1] &amp;&amp; eval(mapActive[0])[mapY[1] * mapActive[2] + mapX[2]] != 0 || mapX[0] == -1 || eval(mapActive[0])[mapY[0] * mapActive[2] + mapX[0]] != 0 || objectY != mapY[0] &amp;&amp; eval(mapActive[0])[mapY[1] * mapActive[2] + mapX[0]] != 0) { return true; } break; // up case 2: mapX[0] = Math.floor(mapX[0]); mapX[1] = Math.ceil(mapX[1]); mapY[0] = Math.ceil(mapY[0] - 1); if (mapY[0] == -1 || eval(mapActive[0])[mapY[0] * mapActive[2] + mapX[0]] != 0 || objectX != mapX[0] &amp;&amp; eval(mapActive[0])[mapY[0] * mapActive[2] + mapX[1]] != 0) { return true; } break; // right-up case 3: mapX[0] = Math.floor(mapX[0]); mapX[1] = Math.ceil(mapX[1]); mapX[2] = Math.floor(mapX[2] + 1); mapY[0] = Math.ceil(mapY[0] - 1); mapY[1] = Math.floor(mapY[1]); mapY[2] = Math.ceil(mapY[2]); if (mapY[0] == -1 || eval(mapActive[0])[mapY[0] * mapActive[2] + mapX[0]] != 0 || objectX != mapX[2] &amp;&amp; eval(mapActive[0])[mapY[0] * mapActive[2] + mapX[1]] != 0 || mapX[1] == mapActive[2] || eval(mapActive[0])[mapY[1] * mapActive[2] + mapX[2]] != 0 || objectY != mapY[0] &amp;&amp; eval(mapActive[0])[mapY[2] * mapActive[2] + mapX[2]] != 0) { return true; } break; // right case 4: mapX[0] = Math.floor(mapX[0] + 1); mapY[0] = Math.floor(mapY[0]); mapY[1] = Math.ceil(mapY[1]); if (mapX[0] == mapActive[2] || eval(mapActive[0])[mapY[0] * mapActive[2] + mapX[0]] != 0 || objectY != mapY[0] &amp;&amp; eval(mapActive[0])[mapY[1] * mapActive[2] + mapX[0]] != 0) { return true; } break; // right-down case 5: mapX[0] = Math.floor(mapX[0] + 1); mapX[1] = Math.floor(mapX[1]); mapX[2] = Math.ceil(mapX[2]); mapY[0] = Math.floor(mapY[0]); mapY[1] = Math.ceil(mapY[1]); mapY[2] = Math.floor(mapY[2] + 1); if (mapY[2] == mapActive[1] || eval(mapActive[0])[mapY[2] * mapActive[2] + mapX[1]] != 0 || objectX != mapX[1] &amp;&amp; eval(mapActive[0])[mapY[2] * mapActive[2] + mapX[2]] != 0 || mapX[0] == mapActive[2] || eval(mapActive[0])[mapY[0] * mapActive[2] + mapX[0]] != 0 || objectY != mapY[0] &amp;&amp; eval(mapActive[0])[mapY[1] * mapActive[2] + mapX[0]] != 0) { return true; } break; // down case 6: mapX[0] = Math.floor(mapX[0]); mapX[1] = Math.ceil(mapX[1]); mapY[0] = Math.floor(mapY[0] + 1); if (mapY[0] == mapActive[1] || eval(mapActive[0])[mapY[0] * mapActive[2] + mapX[0]] != 0 || objectX != mapX[0] &amp;&amp; eval(mapActive[0])[mapY[0] * mapActive[2] + mapX[1]] != 0) { return true; } break; // left-down case 7: mapX[0] = Math.floor(mapX[0]); mapX[1] = Math.ceil(mapX[1]); mapX[1] = Math.ceil(mapX[1] - 1); mapY[0] = Math.floor(mapY[0] + 1); mapY[1] = Math.floor(mapY[1]); mapY[2] = Math.ceil(mapY[2]); if (mapY[0] == mapActive[1] || eval(mapActive[0])[mapY[0] * mapActive[2] + mapX[0]] != 0 || objectX != mapX[0] &amp;&amp; eval(mapActive[0])[mapY[0] * mapActive[2] + mapX[1]] != 0 || mapX[1] == -1 || eval(mapActive[0])[mapY[1] * mapActive[2] + mapX[1]] != 0 || objectY != mapY[1] &amp;&amp; eval(mapActive[0])[mapY[2] * mapActive[2] + mapX[1]] != 0) { return true; } break; } // no collision return false; }
Long term support. 
The real power of reduce is that its codomain can be anything. The codomain of map is always an array. The codomain of filter is always an array. But reduce can return anything you want it to return. That's a pretty good case for reduce being the fundamental list operator. You can implement map and filter with reduce (as the article shows), but you can't implement reduce with map or filter. As far as I know, any operation you want to perform on a list can be done with one or more reductions. It's definitely something that every developer should know how to use well.
Your comment isn't on-topic for this post (probably why you're being downvoted) but if you think it fits in the sub then make an X-post. 
Well put. Thank you for that. 
[I hacked you](data:text/html,&lt;script&gt;alert("I%20just%20hacked%20you%20bwahaha");&lt;/script&gt;) EDIT: doesn't work, which is good
Thanks for sharing this new hosting service and sorry for the bad performance :D
Interesting to see JSPM used in a larger application. I always recommend it for just how simple it is to get up and running, but I would have figured the configuration options that webpack provides would have been more attractive for larger applications. I couldn't use it in most of my applications without stylus support, though. It seems like they "solved" this by dropping sass entirely and using radium instead. 
Map can in theory be used on any functor, not just lists. And reduce can be used on any foldable type. So for example if you had a three dimensional vector you could implement scale by mapping times x on each element in the vector. 
(I'd point out your use of `this` in these examples is totally unnecessary) 
Here, now it's just a simple function that doesn't require you to call a `.start()` method: import Promise from 'bluebird'; import debugModule from 'debug'; const debug = debugModule('PromisePoller'); export default function promisePoller(fn, interval, retries) { debug(`Creating PromisePoller with interval=${interval}, retries=${retries}`); let attemptsRemaining = retries; return (function attempt(){ return fn().then(null, error =&gt; { if (--attemptsRemaining) { debug(`Attempt failed, waiting ${interval}ms before retrying`); return wait(interval, ms).then(attempt); } else { debug(`No more attempts remaining, rejecting`); throw error; } }) })(); } function wait(ms) { return new Promise(resolve =&gt; setTimeout(resolve, ms)) }
In what ways is it not? The original code sets up a prototype chain, but then exposes it as a singleton anyway. The author is clearly writing java in javascript. 
To me it looks like you could either go (with the original): new TaylorClassic() Or TaylorClassic.getInstance(); The latter example is only a singleton. The first example is a bit silly though. Why on earth allow both?
The whole thing is a little silly. The original is technically a class, but if you look at the unit tests, the author only uses it from the singleton method. In practice, the way the author uses it is actually closer to a static helper class, which can be represented in javascript as just an object literal, as /u/cwmma did. 
[GIFV link](https://i.imgur.com/uzuEneW.gifv) // [FAQ](https://www.reddit.com/r/livven/wiki/gifv-bot)
`map` only returns arrays from `Array#map`. The `map` implementation for `Promise` (called `then`) returns Promises. The `map` implementation for functions is called `compose` and returns - you guessed it - a function. This is actually the real limitation on `map`: the "box" of what you're mapping over must remain, but the shape of the data inside can change. `map` just allows you to keep this "box" around and use it for things in addition to the data inside. However, I agree that it's important to know about reduce. It's hugely important in functional programming. 
They use === vs. == 
In practice, you won't use the subscription for all that much. Mostly, it'll be used to hook up redux to your view layer to tell it to rerender. In other frameworks, you might use pub/sub to help you to manage state a bit more easily. You'll have decoupled event listeners which respond to an event and do something. In redux, all of that "doing things" is meant to be represented in your state and handled by its reducers. 
I am going to disagree with the general response from others. I like writing games with canvas (and without any external libraries) because I like the idea that I'm using vanilla JS. But, more than that, I think it's important to understand how to use canvas before you try using a library. I was trying to dive into [Phaser.io](http://phaser.io/) last year and decided that to hold off on that and instead stick with just canvas. But this is all just my opinion. I don't see any reason why you *couldn't* make an mmo with canvas only, but like others have said, it may be easier to use a library. Regardless of what you decide to try, I'm going to say that you should learn canvas. It's not complicated and it's another tool you can use. 
For people using NeoVim, I recommend replacing Syntastic with [NeoMake](https://github.com/benekastah/neomake). It doesn't freeze the editor while it's checking, which makes everything seem a lot smoother and faster. For more flexibility and even more speed with linting, I'd also recommend trying out [eslint_d](https://github.com/mantoni/eslint_d.js), rather than JSHint. (It works great with NeoMake, even though it's not listed as a JS maker in NeoMake docs.) [Edit: Forgot to mention [deoplete](https://github.com/Shougo/deoplete.nvim), too, which is a nice replacement for YouCompleteMe.]
Thanks for sharing, a good explanation.
If you use console.log.bind(console) as a callback instead of console.log, it'll work just fine (since it's now bound to what it needs to be in order to work). I often use these patterns when I need a quick way to throw a log statement in somewhere: Creating a simple log callback: var log = console.log.bind(console); Creating a log callback that will spread arguments (looks better in chrome, otherwise they'd come out as an array) var log2 = (...args) =&gt; console.log(...args) Quickly popping console.log into a simple function (since console.log returns nothing, the inverse of it is true, and adding &amp;&amp; will return the result: x =&gt; !console.log(x) &amp;&amp; x; 
 Compare this example (snippet, non-complete) from the blog: // define a parent component (or "container") for our Hello app class Container extends React.Component { constructor() { super(); // get initial state from our store this.state = getStoreState(); } updateState(state) { this.setState(state); } componentWillMount() { // connect to our store somehow to recieve updates connectToStore(updateState); } componentWillUnmount() { // clean up our listener on the store removeConnectionToStore(updateState); } render() { return ( // we pass in a handler to the onChange event // to create an action to change the name on our state &lt;Hello name={this.state.name} onChange={changeNameAction} /&gt; ); } } ReactDOM.render(&lt;Container /&gt;, document.getElementById('app')); With this simple (complete) redux app: const helloReducer = (state, action) =&gt; { if (action.type === 'Change Name') { return { ...state, name: action.name }; } return state; }; const store = createStore(helloReducer); const container = state =&gt; ( &lt;Hello name={state.name} onChange={name =&gt; store.dispatch({ type: 'Change Name', name })} /&gt; ); const render = state =&gt; ReactDOM.render(container(state), document.getElementById('app')); store.subscribe(render); render(); I'm not sure if the author looked very hard into redux, but it's exactly intended to deal with a lot of the boilerplate and make it very simple to conceptualize our application. 
I haven't noticed any freezing in MacVim yet, but I need to take time out to play with NeoVim at some point. Looks promising!
Check out the transducer pattern: http://phuu.net/2014/08/31/csp-and-transducers.html and trine: https://github.com/jussi-kalliokoski/trine for some more cool ways to compose these sorts of operations and make them lazy without resorting to imperative code.
So the average LTS for a popular Javascript Framework is about 5 months long? Huh, interesting. 
WTH happened to the demo?
I think at least part of it is NIH. The rest is that what is "productive and ergonomic" for me may not be for you.
Comparing the performance of map+filter vs reduce is a little pointless. Use whichever one communicates the intent of the code. If perf is an issue, use a for loop.
Yea, this should be written as a module which just exports some functions. There is absolutely no point in sticking it into some object. And one should *never* use the singleton pattern in JavaScript. It's always plain silly. If you want a single instance, the language has that perfectly covered with object literals. People only do this "getInstance" bullshit in Java, because there is no better way to do it.
It's good to know the pitfalls of these native implementations, say versus a lazy implementation. Isn't that why we have these discussions and create better building blocks than the ones we were given?
document.write() expects one argument, which should be a string. https://developer.mozilla.org/en-US/docs/Web/API/Document/write
[removed]
[removed]
I understand some of what you're saying. I don't quite understand DOM so I will start there. After that you think I can do the rest with jquery (I have a PHP backend).
Can you explain how `then` is a `map` implementation?
I am glad Ember is trucking along. I don't personally use it in any of my projects, but I see it as a sane alternative to all the turbulence happening in the JS framework world right now. Especially if I get burned again like I did with Angular.
I thought observable wasn't cool anymore?
There are so many things that can be implemented with reduce: Deep flatten: function flatten(arr) { return arr.reduce(function(flattened, item) { return flattened.concat(Array.isArray(item) ? flatten(item) : item); }, []); } // flatten([[1,[2,[[3]]]]]) =&gt; [1,2,3] Fibonacci sequence generator: function fibonacci(n) { return Array.apply(0, Array(n)).reduce(function(seq, _, i) { return seq.concat(i &lt; 2 ? i : seq.slice(-2).reduce((sum, n) =&gt; sum + n , 0)); }, []); } // fibonacci(10) =&gt; [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] 
yes, not everyone ditches a good framework for js-framework-of-this-week
Your code wouldn't throw exception by the way, cause bad arithmetic operations would just get coerced into `NaN` ;)
Yes, exactly. I usually comment on the initial value in case people miss it. Shouldn't have used numbers as IDs in this example, but you get the idea. Also shouldnt have shadowed the variable named "arr". Actually that was the most confusing way I could have presented this example. For those just reading: the "arr" goes from being an array to this // arr is now this object { 1234: 'hello', 3333: 'foobar' }
Elm version: import List exposing (sum, map) pow : Float -&gt; Float -&gt; Float pow num p = if p == 0 then 1 else if p &gt; 0 then num * (pow num (p - 1)) else 1 / num * (pow num (p + 1)) fact : Float -&gt; Float fact x = if x &lt;= 0 then 1 else x * fact(x - 1) sine : Float -&gt; Float sine x = sum (map (\i -&gt; (pow -1 i) * (pow x (i * 2 + 1)) / (fact (i * 2 + 1))) [0..9]) And with foldl instead of sum/map import List exposing (foldl) {-- pow, fact --} sine : Float -&gt; Float sine x = foldl (\i sum -&gt; sum + (pow -1 i) * (pow x (i * 2 + 1)) / (fact (i * 2 + 1))) 0 [0..9] 
The most maintainable way is probably to use your static_path function in the view's controller to produce a string that you set as a parameter on $scope. ng-include will take any Angular expression, so you should be able to reference an interpolated expression.
Terrible name choice, ace is a JS editor already
The function described would literally take a team of engineers months/years to create. If what you need can be accommodated by standard flow HTML document, then there are a lot of WYSIWYG text editors out there. https://github.com/cheeaun/mooeditable/wiki/Javascript-WYSIWYG-editors You might be able to find one that's close enough for what you need and integrate it. 
"Productive and ergonomic" is just marketing. What might be productive for Google/Apple/Facebook/Microsoft might be horrible for you. The feature touted might be irrelevant to your application. At best, they would solve your problem nicely after some learning curve. At worst, you have to engineer solutions to get around workings/limitations of their design. There is generally no study done to show whether the features advertised are true or beneficial. At most they would do a case study. Those studies are not scientifically rigorous (random sample, control group, blind experiment, etc). A lot of the lesser libraries are actually not very well designed/written. They are generally created to replace some existing library so it can solve some oh-so-important problem. While those problems might be pain-in-the-butt, but by replacing the existing system, you also expose yourself to problems that the old library solved perfectly and the new library doesn't. ---- I would do whatever is best for long-term learning. Instead of learn to *use* the library, learn how they solve the problems, learn their architecture/design. 
A major way Not-Invented-Here can lead to new libraries is cross-platform Web development: If you didn't pick a library to start with, you'll end up writing one just to deal with the cross-platform inconsistencies.
Mm, we used angular at our work, and the devs made a big mess out of it. It's easy to use it wrong &amp; get into performance issues when still using $scope &amp; $scope.$watches's. We're currently in the progress of refactoring it back to components (directives), and it's getting a lot better. Part of those issues were ofcourse the developer's approach, but I suppose the angular documentation at the time pushed people a bit that way. And there's also the endless whining of people that are offended by angular's 2.0 breaking with angular 1.X (though now they're actually working towards that a bit to make the switch easier) (minor edit: It also got a lot more fun to use when using ES2015, to reduce the angular boilerplate code)
It's easy to get caught up with anti patterns in any language/framework though. It's the developers fault for not using it correctly.
Disclaimer: Yes, I'm being pedantic. Still, it's something I think about every time I see "JavaScript Developer" used. The title is very interesting to me. It suggests that JavaScript comes first, and the non-JS skills, while being important, are a side component of being a "JavaScript developer." It's kind of like saying, "Non-mitre saw skills every mitre saw expert should have." Which equates to "Skills a carpenter has." I understand the general scope of a front-end developer or a back-end developer, but I think JavaScript developer falls short of describing a meaningful skill set. You wouldn't look to hire d a mitre saw expert to build you a deck. 
One advantage of a single state is that state changes become transactional. An event might result in changes in multiple components. If the components do not update simultaneously, there might be some time where the components are in inconsistent states. In Elmish and Redux, changes resulting from the same event always resolve in the same reduce pass, so there is no period of inconsistency. Another way to look at this is to consider interdependencies between values in the state hierarchy. In [vanilla Flux](https://facebook.github.io/flux/docs/overview.html#content), you have multiple independent stores, which tend to read from one another during updates. Making sure that stores update themselves in the right order to prevent inconsistences can be pretty messy. (Flux has a `waitFor` method for just this reason.) On the other hand, ordering of state changes ordering is much less ambiguous in Elmish and Redux. For example in Elmish a higher order component that manages multiple child components of different types can be implemented to update the state of `childA` first, and use the new state in `childA` as an input when updating the state of `childB`. And that all happens in one transaction. And as OP points out, with centralized state you can get time-traveling debugging, or add undo features at any level in the app.
&gt; we replaced the Ember rendering engine for our most common view with a custom virtual DOM based renderer. A custom solution is always going to be the fastest. Frameworks like Ember and Angular provide abstractions to increase speed of development, which they do an excellent job at. However abstractions always introduce performance overhead, and can't provide highly specialised optimisations for specific cases. An approach I've used is to write 90% of the app in a framework, but the critical 10% (e.g. the chat window of a chat app) in hand rolled DOM manipulation. You get the best of both worlds.
&gt; A custom solution is always going to be the fastest. Note that here "custom" is the abstraction layer (widgets/components), the virtual DOM base is the [virtual-dom](https://github.com/Matt-Esch/virtual-dom) library.
Took a while but i figured it out using webpack. It exports a global namespace now, ~~but can actually be used modular as well, which is nice~~. Internally it's all ES2015 and webpack packs two versions, one inculding polyfills and the other doesn't. Both end up in Bower and the customer picks whatever applies.
I got it working. Essentially i had to dive in to know in detail what the options do but once i did setting it up was easier than i thought. Comparing the new setup with our Gulp builder it's kind of awesome that a few lines of wp-config allow for a modular ES6 lib that can be included globally or required/imported whole or in single modules, while being distributed in a minified bundle. With the added bonus of having a clean codebase now, finally.
mobservable was a much better name
I don't really have a preference. At least it is shorter to type those import statements.
So what's the difference in theory?
No, what I've just described is `map`. `bind` is actually quite similar to `map`, with an important difference: Your transformer function must return the same kind of thing as what you're `bind`-ing. So `bind` for a Promise must accept a transformer function which returns a promise. Bind for a list must accept a transformer function which returns a list, etc. For promises, we call this `then` (it's overloaded). For Arrays, we call this `flatMap`.
I don't get it.
probably better to switch jobs, its a bit like that everywhere but in your situation it seems to be particularly bad. But does this happen to other developers on your team, issues getting reopened all the time? If so did you guys report to management, what did they reply? Sometimes its just a matter of a manager to send an email to the testing team and things get better.
Talking about a "collection" and "elements" is getting too specific again. Lots of containers only hold one thing, so there's no necessary concept of "all elements" when talking about mapping. The fact that .map applies the transforming function to each element of an array is a _particular_ specific to Arrays or Lists or similar things.
Object.observe allowed you to track changes to an object's properties. Observables allow you to track changes to *anything*. They are a higher level abstraction. Most libraries also bring with them the LINQ-like functionality of map/zip/scan/etc. with streams.
So...you suffer from poor management. Your scrum isn't working at all. This happens in a lot of places. I'd raise the issue with my boss. Perhaps find a new job. 
Awesome saying.
Trying to shoehorn a OO class structure onto your code where none is needed would be fine if you did it in all languages. But you only do it in JS. In idiomatic ES5, you'd use a IIFE (like you did), but wouldn't create a singleton and prototypes. Instead you'd define functional functions without `this`, and return a object with all non-helper functions in it. Like var TaylorClassic = (function(){ function pow(base, exponent) {...} ... return { pow: pow, ... } }) In idiomatic ES6, you'd write a module instead: export function pow(...) {...}
Sorry, fixed it :) When removing jquery dependency, I messed up.
Wow that answer was a real eye opener, thank you
Thanks. I think the last hallmark of really understanding something is being able to explain it in plain enough terms to make other people understand it, so it means a lot to me if my explanation helped you understand `map` better!
If you would have just wrote the tests you could have saved yourself all of the pains in the ass you're talking about. Take 30 min and write some very rudimentary tests for the library. Don't worry about edge cases, just check to make sure it works under ideal circumstances. Manual QA rejects because of problems? Write tests for the problems found BEFORE fixing whatever the issue may be. It will take a few extra minutes but in the long run makes your job 1000x easier. We're programmers, we are supposed to be lazy. That's why testing and similar tools exist, so that we can pass off the boring monotonous work to an emotionless computer. Yeah your process sucks but that doesn't mean you have to make it 100x harder on yourself by doing the absolute minimum amount of work. Seriously, try it for a few weeks, you won't go back. 
Which is why I am saying only worry about very basic tests. Decoupling the code should be a high priority though. 
You should definitively move on, become a freelance. You will recognize the signs in your new job when you see that you no longer enjoy it. Instead of staying too long and get to the current state of demotivation, you go to the end of your current contract of 3-6 months and leave to do something else, give plently of warning if it ever happens. You should definitively try freelancing if you like new challenges, you will have a lot more control over your career and the content of your work. Probably right now you should take a short holiday of a couple of weeks, and then look for a new job. There is no point staying in a place you don't like to work and know that there is a 95% chance that nothing is going to change, its job fatigue happens to all of us. The trick is to leave before being too demotivated, but choose the timing don' do that in the last month of a huge release. I saw a guy once that was so fed up that in his last scrum standup he threw the token teddy bear in the garbage can! no kidding this happened.
Oh, sorry if I wasn't clear. I absolutely know the meaning of that phrase and yeah it's common, but not really appropriate in a mixed-gender context IMO, which development is. I didn't want to get too into details but every single one of his sample developers is a guy too. BTW That "colloquialism" is not "locale-specific" unless you mean, "all locales in which English is commonly spoken". Everyone's heard of it. It's not my ignorance of its meaning that's an issue.
I'm holding out for Mobux...
[Right-to-Left](https://en.wikipedia.org/wiki/Right-to-left)
That is actually a bug with Safari not pressure. I have tried to send many bug reports to Apple, no response. :(
My favorite * [Building a Progressive Web App](https://youtu.be/m2tvYGCdOzs) It's about implementing an App Shell by using Service Worker, and other tricks, to speed up Flipkart (eCommerce) on low bandwidth mobile devices.
Is it me or when you have a huge data set that needs to be manipulated on page, the way to go is using streams instead angular binding? This is a cool trick tho, but would be not beneficial for small data sets
``` var sjo = document.querySelector('button.btn[data-site="SJO"]'); ```
- [ember-concurrency docs website](http://ember-concurrency.com) - [online slides](http://alexmatchneer.com/ec-prezo/)
It's a problem with you. You're writing crap code in a crap way, and not stretching yourself to learn how to do it better. It's also a problem with your company. They don't know have anybody mentoring you, a junior developer, in how to write good code in a good way. From my experience with similar companies, they'd probably actively inhibit you from doing good work even if you knew how. I'd suggest taking some time to learn how to do your job better. Read Martin's *Clean Code* or my own *The Art of Agile Development.* Put the ideas into practice in your own personal projects. Once you understand them, try to introduce them at your work. If they won't let you, find a better job. You'll now be qualified enough to know what a better one looks like. If you're not motivated to do that, you're going to hate your job and turn into a bitter useless crap programmer who can't get hired anywhere that does good interesting work. If *that's* not motivating enough, it's time to take a long vacation or find a new career. PS: It's not like that everywhere.
https://github.com/rtsao/postcss-rtlcss-combined
I went through this 6 years ago. Fatigue and not caring for the work I was doing. I left, did some consulting work, hated it, and came back. What fixed our problem was that we got a new CTO from outside and he brought a lot of new ideas, new motivation, and accountability (no tests written and running in the nightly build? then the bug/feature isn't finished, go write tests). &gt; but my department/team/boss are quite cool. Project is kind of uniqe and I used to really like it, also i get lots of autonomy and sometimes lots of free time to do my stuff... even though im not overworked at all Sounds like a good place to work! &gt; code is not so great That code will always be like that unless you do something about it. Think about how you can make it better and then make it better. "I'll clean it up eventually" **never happens** unless you clean it up **now**. &gt; no test because we didnt write tests and honestly i have no motivation to start it now We went through this as well. No one wanted to be that guy that wanted to get others to write tests because it's more work and QA's gonna find the problem anyway. I'm so glad we took the time to write tests because now when I make a big change, the tests let me know right away if I screwed up. Also, every place I interviewed at asked me questions about testing. &gt; Then it goes to code review, nobody really gives a fuck so its always being accepted Went through this as well. This one is hard because it would lead to other developers getting offended (they didn't understand that you are not your code and I'm not attacking you personally). [Crucible](https://www.atlassian.com/software/crucible) provides a more enjoyable coding review experience. &gt; but no real specification Getting specs can be hard when users (testers, customers, product managers) don't always know what they really want. It's not realistic, at least where I work, to expect a beautifully crafted specification to fall on my lap. So we took the initiative to have meetings with testers, product managers, and others that use the software and get their input on how the features should work while taking notes and adding it to our internal wiki along with the names of the attendees for future reference. Also, are testers involved in the planning of the new feature? Our problem was that our testers weren't involved in the beginning and they only got to test the new features when we threw it over the wall to them. Our testers know the product way better than us developers, so this caused problems. We fixed this by including the testers immediately in the research and design phase of the new feature. &gt; not working as it was supposed to... not working on specific version of browser on specific system... Is it that code isnt high quality? This takes a lifetime to learn and improve on. Can you think back to why it didn't work? How did you get it to work? What could have been done to prevent this? Is this problem a common occurrence or just a specific situation? If it's common, is there some framework/library that has addressed this issue? If specific, are there code comments / wiki describing the fix? &gt; Should i change the job in this case or try to fight with it? I chose to fight and the war was worth it. I love my job more than ever, and I'm making way more than I did just a few years ago because I fought. &gt; maybe im just not suited for programming and should change career? Do you work on any side projects at home for fun, even if you don't complete the side project? If so, do you enjoy it? If so, then you shouldn't change career. &gt; very physically active Jogging really helps me when I'm burned out. You have a golden opportunity to bring change for the better. Even if you can't make it happen, you'll be able to talk about the experience in job interviews.
http://i.imgur.com/TnQRX6v.webm :P
The most exciting Ember Addon of 2016?
The problem is you. You're not owning your projects. You're not choosing to make your product better. You're not innovating. You're not building quality. *You're not improving your own skills.* You're just shitting out whatever you need to, to get to the next boring task. I'd be tired too, if I spent 8 hours a day doing something that gave me no satisfaction. Where is your pride? Where is your sense of adventure? Either pick yourself up and start looking for ways to make your project better, with conviction, or find a new career. If you can't find excitement in engineering and architecting beautiful code, you shouldn't be doing it. You'll always be a mediocre developer at ANY job, wasting everyone else's time, and worse yet, your own. tl;dr - Find joy in solving problems, or drop your career.
No worries! Even just a comment in the code or readme or something that says "thanks /u/jcready" would be plenty.
Here you go: https://github.com/joeattardi/promise-poller/blob/master/README.md#contributors
Answers question, gets downvoted.
eh.....
Well, that escalated quickly.
express is the shiznit. wtf is going on?
This is another example of the GitHub/JavaScript generation of publish fast publish now! meeting the IBM generation meetings and conferences.
TJ "sold" express to strongloop IBM bought strongloop current maintainer not used to IBM bullshit management and giving up.
I hate to say it, but the javascript open source community looks like it is even more toxic than the day I unsubbed from the Node.js list. This intermingling of corporate interests in these projects, what I would call Third Wave Open Source Companies, has not been what was promised. It looks like dougwilson was trying to privately vent to someone he thought was a confidant, only to find out that the confidant was telling @jasnell everything. It looks like this transition is going very, very, badly.
&gt; This was brought up yesterday because some people were publicly talking about the exploit and how it was not patched in Express 5.x. How long is reasonable to take to make a security release? It's been almost 24 hours since I asked about making a release. I really like Express, but this comment from Doug seems to be more of a "final straw" then a meaningful complaint. Express 5 isn't stable release. It's not even a *beta* release. It's **alpha**. And it isn't as though the request was met with silence. James said; &gt; I'm still tied up in Vegas for the conference. I'll be able to look at this in a day or two. I guess I don't understand what the urgency is. Doug's complaints are not rational in this context.
I read the whole thread on github, but still can't make much sense of what is happening. Can any kind soul tldr this for me?
Inside the for loop, put an if statement where you determine the remainder. If your remainder comes up even, then print the number. If it doesn't come up even than the of statement put anything through. Thus you only get even numbers.
There has been tension and conflict around Express ever since TJ backed off from it.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder_()
TJ selling it to Strongloop was the worst possible decision ever. Maybe he regrets selling what was probably his most well known and most used node project, but then again he might not care since he decided to drop almost everything and move to Go.
I wrote [this comment](https://www.reddit.com/r/javascript/comments/47k3d4/array_reduce_like_you_may_have_never_seen_it/d0ekdaf?context=3) not too long ago on the subject. I like explaining it in more practical terms, since words like "morphisms" tend to make people's eyes glaze over pretty quickly. Moreover, functors mean different things in different languages, so it's nice to have an understanding that isn't tied to that word.
Maybe you could have your build script as a part of the deployment process. It seems as though you could point your `Procfile` to a small script that runs your build process before a `npm start` You can also connect Heroku to GitHub, such that when you push to `master` (or whatever branch you want) on GitHub, it automatically deploys to Heroku. Good luck.
nodejs is just a fad.
&gt;the javascript open source community looks like it is even more toxic This, 1000x. And so much of the community is in denial. 
Uh.... I would never claim that. Cygwin and other interpretations of Linux on Windows sucks. Cash states "cross platform Linux without the suck". 
at 1st i was all js fanboy, 5 months in i am already getting burned... i realize it's a monumental waste of human intelligence and life. just learn enough jquery and learn something that lasts. Or be medicore for rest of your life and spend 10x time learning while creating 1/3th of the time. become backend dev (or in past become flash dev). you will enjoy what you do. you will master it, it will become your tool to create and express (;D).
yeah. "Linux without the suck" -- stopped reading. Somebody obviously doesn't understand Linux.
&gt; community around go is 100 times more friendly. I'm sure growing popularity will fix that problem.
:'(
I went over to Go and it's the best language I've ever worked with. Everone is docile like Hobbiton up in here. All this node drama is like friggin Isengard, devs working with Sauron and burning up the forests and shit.
Would you mind telling me more? I've been doing some work lately on JS and am looking to get more involved in the community. But I didn't know it was having problems. Why is the JS community toxic?
It was dead with Mongo. :) Use Hapi and a real DB or still use Express if you like?
He's been basically the only one working on expressjs – one of the things that propelled js, and the E in the MEAN stack – for nearly a two years and has been bogged with IBM/Strongloop and politicing the entire way through. Now that v5 seemed to have daylight, with Strongloop having claimed its a [new day for Express](https://strongloop.com/strongblog/a-new-day-for-express/) but **only** after an [extremely popular thread that asked "express is dying".](https://github.com/expressjs/express/issues/2844) But here we are, with dougwilson still being bogged down and apparently being ratted on. If I were dougwilson I'd ragequit too.
I like how you slipped in the idea that functions can be Functors, which is a very powerful concept in its own right, especially when they can come in different flavors (mapping over the input or mapping over the output).
Yeah, there are tons of options out there other than MEAN. I'd put in a +1 for [koa](https://github.com/koajs/koa) and [postgres](http://www.postgresql.org/). And react, probably. 
Would you be able to provide an example.... that isn't related to frameworks?
Doug has said in the past that he actually wants to start over and build something new. He's had a difficult time getting express adapted for HTTP2 and thinks it would go better with a totally new framework.
In the context of the earlier issues with IBM, I feel like @dougwilson's reactions were understandable. It's hard to understate how critical he's been to the express project for a long time now, nor how poorly he's been treated by the project's new overlords. He'd already quit once, and then been lured back by promises that things were going to be better. I doubt he had any patience left. Nor should he, in my view. Edit: typo
Express is still worth knowing (and Mongo is still worth avoiding). The JS world has a ton of hype and drama; it's worth taking it all with a grain of salt.
Reactive programming is a much nicer paradigm than flux. The functional purists might disagree but I don't care. I prefer to get work done. Here is a tip for anyone using this: use the transaction() helper to batch updates together. So if you are updating several properties of a model or state, the UI observers will only need to update one time.
MEAN expired long before this. No one with any sense is building real applications with MongoDB as their primary database, and Angular's fad has passed. edit: typo
It seems like you can't querySelector('object') anymore. It used to return the DOM element, but now it returns anonymous 
Read the comments on this sub alone. Check how people forget there is a feeling human being on the other end of that Fiber optic cable. And on that note: hello there fellow traveller.
Large-scale community health calls for community pruning. That means getting rid of bad people and behavior, and I don't think that programmer communities have been good about that in general. Programming communities are over-accepting, they think that every person and every argument deserves patience, gentleness, and respect, and they think that ad-hominem is inherently dishonest. These communities do not have well-honed mechanisms for exclusion and disrespect. And when bad behavior causes too much frustration to the inclusive spirit, there's no graceful degradation. Being liberally accepting is a strength in growth, but you can't keep turning that crank forever. At some point you have to go into management-mode rather than growth-mode. You have to make potentially risky judgments on community-worthy behavior and community-unworthy behavior.
Thanks for this, this helps to contextualize his response. 
Semicolons, using ES6+ features in production, callbacks versus promises, promises versus async/await, underscore versus lodash, large libraries versus small libraries, webpack versus other options, the `class` keyword, OO stuff in general, anything Eric Elliot or Kyle Simpson have said about inheritance, about 1/3 of what Douglas Crockford has written, every comment thread where `feross/standard` is mentioned, the mere existence of coffeescript, etc.? I'm probably forgetting a few, but I think /u/spizzike has it correct. Compared to, say, the Python community, the JS community is just a seething pit of people looking to have a fight about why every single thing you're doing is wrong. :)
Um. What?
You were probably thinking of this article when you wrote your comment, but if not, I think you'll agree with it: [Five Geek Social Fallacies](http://www.plausiblydeniable.com/opinion/gsf.html)
Btw, Strongloop.com is spammed by reddit, we have to approve any links (posts/comments) due to prior [astroturfing](https://www.reddit.com/r/node/comments/3af9a0/what_is_strongloop/csca6ad).
Have you seen [Adonis](http://adonisjs.com)? I've been using it even though it's still in the early stages and so far it hasn't pissed me off yet.
Nooo that is just holy war hysteria. Nobody maintain open source projects/communities cares about that childish stuff. I was asking if you had an example of toxic JS communities/projects that aren't related to frameworks.
Can you elaborate on AngularJS being a fad that has passed? 
Switched all of my projects (including m.reddit.com) to koa over a year back, haven't missed Express yet. (Also, koa v2 async/await is exciting.) Edit: I don't want to imply that Express isn't great, or that the current drama isn't unfortunate - just that Koa is the "official" replacement anyways, and I'm quite happy with it.
There's a _lot_ of react native stuff, if that interests you. The [Netflix preformance](https://www.youtube.com/watch?v=kDARP5QZ6nU&amp;list=PLb0IAmt7-GS0M8Q95RIc2lOM6nc77q1IY&amp;index=21) talk was pretty good, and [rich text editing](https://www.youtube.com/watch?v=feUYwoLhE_4&amp;list=PLb0IAmt7-GS0M8Q95RIc2lOM6nc77q1IY&amp;index=3) was interesting. Also, [enzyme](https://www.youtube.com/watch?v=V5N0Ukb8LGg&amp;list=PLb0IAmt7-GS0M8Q95RIc2lOM6nc77q1IY&amp;index=26) looks great for testing (lightning talk.)
Fork! Fork! Fork! Fork!
You can't alias an NPM module, so forks are extra awkward 
As far as mvvc is concerned, React and Vue are popular options atm, with React relatively established and Vue quickly gaining momentum
I'd love to hear about specific examples of drama, if you'd be kind enough to share. I also want to understand better why you appear to be despondent. I don't think open source folks should be sad and negative. Is it a lot of little things? Are people in low spirits collectively? Are there certain toxic individuals? Have there just been a bunch of bad incidents that can be pointed out lately? I don't follow the news as much as I used to, but I would love it if you could help me get back in touch. I don't really understand what's going on.
Isn't that what Koa is? &gt; Koa is a new web framework designed by the team behind Express, which aims to be a smaller, more expressive, and more robust foundation for web applications and APIs. 
&gt; Everone is docile like Hobbiton up in here. Just wait. It'll turn toxic as soon as more people start using it.
Check out Koa, RethinkDB, React, redis, Polymer, Meteor, etc. MEAN sounds cool but things change too fast to base things on cool acronyms.
Mostly personal attacks when people don't agree with them, hypocracy about harassment, user empathy skewed towards being accepting vs addressing issues that people have running code and applications at scale, dismissive responses to real issues. Things like this. It's welcoming to users who know nothing, but completely alienating experienced engineers. They constantly bring up toxicity of other communities (they constantly talk shit about the ruby community for example). They also always want to do things their own way, rather than follow any kind of convention (npm's verbosity flag is -d for example). I've got more, but nothing is coming to mind right now. I try to block it out because it's just a distraction, but I have to write nodejs full time and I'm constantly running into this stuff and these are very real problems. I don't know how Netflix supports this sub-par platform at scale. I suppose it's a testament to the quality and patience of their engineering teams. Edit: a word
&gt;So I'm a bit out of the JS loop - what non-fads are worth checking out? Fads are all the rage in the JS community.
&gt; user empathy skewed towards being accepting vs addressing issues that people have running code and applications at scale Being accepting? Of what? &gt; dismissive responses to real issues Which people are doing this? Project leaders? Project founders? Other people? Or is this just the way that people in general in the JS community treat the Ruby community? &gt; I don't know how Netflix supports this sub-par platform at scale. I suppose it's a testament to the quality and patience of their engineering teams. A good engineering team can make just about any piece of crap work. That's what engineers do.
In the javascript space these "curated" stacks mean nothing. They are often brought about by mere trends rather than solid proven tech. For example in the Java space, (I don't come from a java background just recently have been exposed at work) there is Dropwizard which are the time tested libraries for various aspects of building a service or web server brought together under one banner. The Mean Stack came about rather quickly, with many of the initials in pre-release stages. 
Sorry I didn't mean to sound like that, there's wwwaaay more good news than maybe 1 or 2 bad news everyday, more things created than projects abandoned. I just meant that no community is perfect. Maybe google [Linus Torvalds](http://lmgtfy.com?q=linus+torvalds+fights) if you want to get started :P
this subreddit loves drama and loves projecting that drama onto js. all of those topics you listed are not big deals and many reasonable things have been written and said about them. for some reason, this sub gravitates towards the overly opinionated articles which tend to polarize opinions and generate heated discussion. there's a reason eric elliot's crap doesn't get noticed anywhere but here. maybe take a step back from this sub and see how people talk about js elsewhere.
Technical committee, I believe.
Thank you.
Open Source &amp; Enterprise: A Love Story
I've only worked with MongoDB. I'm interested in learning other stuff, what would you recommend as an alternative? 
Anecdotally, fewer than 1 in 10 (maybe 1 in 20) users who request a feature will follow up with a PR if you suggest it. There are probably a variety of reasons: they might not have the time, they might feel under-qualified, etc. But I understand how it can be interpreted by the maintainer as them wanting you to do it for them (for free) as if their time is more valuable than yours. That being said, try not to let it get to you. I often realize after the fact that I was wrong when I assumed the worst about someone. :)
&gt; they think that ad-hominem is inherently dishonest. Maybe this is me being an academic, a programmer, and a geek... but it is.
With chloroform. 
Take the year out of "function is_leap(year) {" The point of that is so you can pass data to it when you call the function, for example: function hello(name) { console.log("Hello " + name); } hello("world"); // Outputs "Hello world" Quite late over here, so if someone else reads this, please explain it more in depth if you have some free time!
Note Postgres JSON fields are very performant if you want schema-less objects in your stores. (there's also native Array and Hash objects)
You are defining a method but it is never called... Just add console.log('test') in the first line and see if it gets printed to console - &gt; it won't You can just call the function after or before the definition with is_leapyear(2012); And you can remove the var year=2012; because year is already defined as it will be passed as parameter into the function 
If you applied signal v. noise as a metaphor to individuals, then no, it's not a dishonest technique, because *even* if you were occasionally correct, outputting too much noise means that you are too costly to listen to. At the most extreme, a clock being right twice a day doesn't even output information, even when it's correct! It is an excellent judgment to deprioritize any truth claims made by that clock. Also, listening to people isn't free, and resources are limited. Given that problem, a bounded rational machine must prioritize and de-prioritize sources of information based on signal v. noise ratio. That's called an ad hominem judgment. You're not trying to prove if people are correct. You're trying to *predict*. When some highly respected mathematician outputs a massive volume of work and claims to have tackled a non-trivial problem, and mathematicians decide to take that person seriously (a costly move to dedicate yourself to a possibly false math proof), that's also an ad hominem judgment. The mathematician example is one of an optimistic ad hominem judgment, as opposed to a risk-aversive ad hominem judgment. It's not immoral or academically foolish to accept ad hominem judgments against individuals -- to judge people as *low or high quality*. You do the same when you go to a doctor and fail to evaluate their medical model of your conditions. That's an ad hominem judgment. Or when you trust a lawyer's advice without evaluating their legal arguments. That's an ad hominem judgment. You're assuming that the doctor and the lawyer, by virtue of their history of achievement, are credible. Credibility is a predictor of value. An indicator of signal v. noise ratio. You call yourself an academic, but every time you read the academic papers of others, you assume that they are not liars. You don't personally amass a personal fortune to replicate their experiments. You prioritize with a techniques like trust and distrust.
1. use only one level of indentation per method 2. avoid if/else 3. [don't be a smart ass](https://fr.wikipedia.org/wiki/Principe_KISS).
 &gt;I don't know how Netflix supports this sub-par platform at scale. That's a bit of a disingenuous quote, no? The issue isn't the platform. It's a social issue and any community that reaches a certain size will have people issues. 
And why this being downvoted?
so fork it
I like to believe that, in the same way that go's architecture prevents spaghetti code and use of antipatterns, the foundations that the community is built on will prevent this same sort of thing from happening. Maybe wishful thinking.
sackville-bagginses will move in.
lol This has been my experience so far writing code for companies. One person is writing code while 50 people are always at some friggen' convention somewhere. I want to go to Vegas too!
He can't because it's not true. Angular has been around since 2009 and has been the king of SPAs and largely unchallenged until 2015 when react came around. It hasn't been the only SPA framework in that time, but was (and still is) by far the most popular with the most production apps and libraries. Compared to react, angular is outdated - it's also half a decade more mature. Saying angular is a fad is like calling node a fad - it's a proven tech that's been around for years and it works. Angular2 on the other hand has yet to be proven in the same way.
Rare in dead.
It's a large reason why a company that I've done a lot of work for in the past has never bothered to contribute any of their changes back to anything -- they don't want to get involved in politics. 
&gt; No one with any sense is building real applications with MongoDB Care to explain why? Never used Mongo but heard it doesn't scale for very big projects but that it got better recently? Currently I'm looking into RethinkDB and I'm liking it a lot
Computations derive information *from* the state, while reducers *produce* a new state. So in that sense they are conceptually quite different. But since reducers might be used to derive data (although reselect is a nicer alternative) they might act as computations. The big difference then is that you as a programmer are responsible for setting up your reducers in such a way that they produce an consistent state. In MobX, it is the responsibility of the lib to make sure that all computed information is consistent with the state. (But it will only keep derivations in sync that are actually used somewhere, which is saves tons of CPU cycles)
The first in mind is sails/trails.
made me lol
hahahahahahhahahahahahahahahahah
&gt; this comment from Doug seems to be more of a "final straw" Doug already quit express once and was lured back by promises that things would change, so it's less "final straw" and more "and then they set the barn on fire".
That is a really nice comment :)
 didn't know about hapi, always used express, tried it today (replaced express in a small project) and it's working flawless, more logical in my (short) opinion
Don't forget the SJW drama around nodejs and many other projects; they cause brain leak by pissing people off.
i would try to make a vanilla app and a jquery app and a framework app. sounds like ur 2/3 of the way there or more. the reason is just for getting a job, most places use various frameworks. so knowing jquery and react is valuable. for animations, but only for the same reason: eventually a client is going to want animations. you should try a simple jstween or css3 to/from animation. gl!
Another fan of Koa here too. I had always liked Express, it helped me get into Node and I feel for Doug, but I've jumped to Koa and haven't looked back. My whole MVC framework [Kratos](https://git.io/kratos) is built on top of Koa.
Nailed it. People need to stop being shitty.
Jump into the docs, I am a MySQL user my whole career (since 1997) and recently jumped to Postgres, it's not really that far off when it comes to basic database stuff.
His message states he quit the "Express TC"... implying he _was_ in fact on it, no?
This might be true, but I believe Doug has nothing to gain to continue to pander to the corporate overlords who'd prefer to bog the entire thing down in nonsense process and faux support. Doug doesn't even get paid for any of this work he does in his free time. At this point, Doug can walk away from Express altogether with his head held high and if the masses decide to stick to the old poorly managed Express it shouldn't matter. It'll either be the preferred framework for people in the know or it'll become a full blown replacement that people migrate to leaving IBM with egg on their face. If IO.js vs Node has shown us anything, it is the community will back something different and force the change they believe in. Even if it only becomes the framework for people who realize following Doug is infinitely better than following IBM, I don't think this is a loss as at the end of the day I hope Doug is more interested in making "express" better more than having the most popular version of it.
This is great though. Honestly, the only reason I start understand any of this stuff is when I sit down and confront the problem of trying to explain it.
Sure, but if you just replace Mongo with Dongo you can use the DANK stack.
&gt; The whole thing seems basically designed to force development away from Express and towards koa, although I assume that wasn't intended. I'm usually a cynic, but in this case I think koa was more of an exploration of what express could be after TJ had learnt a lot of new things and a lot of new things were being added to ES6/7. I think TJ continued to lend his hand to that because unlike most projects this one was less for pragmatic purposes and more for academic purposes, but that isn't to say koa is not pragmatic just his goals while working on it.
Why do you say that Mongo is worth avoiding?
I didn't touch on the laws at all in my comment, since I find for the most part javascript developers will already be working with well-behaved types. I agree the interesting question about functor laws isn't *what*, but *why*. We can write them very generally: map(ctx, id) == ctx map(ctx, compose(fn1, fn2)) == map(map(ctx, fn1), fn2) If you read them, you would read out "mapping any given context with the identity function returns the same context" and "mapping any given context with two composed functions is the same as mapping a context with the first function, then mapping the result of that with the second function". We can indeed have a `map` function for basically anything, since intuitively it is just an abstraction over function application, and we can apply anything to functions. Here's a trivial map for numbers: Number.prototype.map = function(f) { return f(this); }; However, even though `Number` is a type, and `map` is the name of the function that functors use, this is not well-behaved in terms of our functor laws. Let's observe: // this is fine map(1, id) == 1 // so is this! map(1, compose(addOne, square)) == map(map(1, addOne), square)) But I just said it doesn't obey the laws? What gives? The functions we were testing *just so happens* to return the same type -- numbers. But things get a little weird if they don't .. const addBang = x =&gt; x + "!"; Hm . . . map(100, addBang) // 100! map(100, compose(addBang, addBang)) // 100!! map(map(100, addBang) addBang) // type error, or 1!0!0!! This is because we move from mapping over a number to mapping over a string. Whereas, if we look at a "well behaved" functor: var promise = Promise.resolve(10); map(promise, compose(addBang, addBang)) // Promise of 10!! map(map(promise, addBang), addBang) // Promise of 10!! Here, we are always mapping over the same thing - a promise. That's different from before - our Number `map` simply returns whatever our function does, so if it returns a string, then we suddenly have a string. I think this is why a lot of people use the "box" analogy, even if it's not the most accurate thing. It's really the piece that allows the functors to be well-behaved. `Number` *is* a type, but `Number of string` doesn't really make any sense. `Promise of string`, however, makes plenty of sense. 
Yes. It was very crude pre-Sencha. Sencha created connect and hired him. Express 1.0 was built on top of connect. 
Mostly no one with any sense is building real applications with *any* NoSQL database. I would venture that 98% of the time someone's using a NoSQL database, they *should* be using a real database, but the efficiency (perceived or real) of NoSQL is too attractive. Unless you're storing documents, or data that doesn't need to be joined, ever, you should be using a real database. That said, I recognize that ignoring schema's, foreign keys, and the hit the ground running time is a large time-saver, so for smaller applications, it's probably an okay tradeoff. But for large applications, you're going to outgrow NoSQL very quickly. [Here's a good article about it](http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/), if not a little biased, but then again what programmer isn't biased.
Do it dougggg! https://youtu.be/nGQJodNC_oc
Every framework seems to be about streams these day. So take a gander at [reactive programming](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)
Mongo hate has reached an all time high. You can dislike it for its eventual consistency, but to claim it has no use cases is absurd. 
DynamoDB Angular Node Koa
Finished updating [one of my toy projects](https://nokkelat.fi) (kind of thisiswhyimbroke-clone) to all the trendiest tech: es6, babel, webpack, react, react-router, redux, single page app with initial server side rendering, http2... Pretty snappy end result, and nice dev experience once all the parts have found their place. UI looks garbage though, maybe that's the next focus for learning and experimentation.
Yeah there's a lot of glitching / visual defects, which doesn't help
Thanks - I hadn't heard of Vue at all and only briefly looked at React. React definitely seems to be popping up on job listings, which was kinda the incentive to bring my JS a bit more up to date. Time to look at React this weekend I think! Cheers
But but... did someone ask for pure ES6 goodness? :D PA ONE Postgres Aurelia Objectionjs Node Express
No that's not him. 
Heroku looks for [npm postinstall script](https://devcenter.heroku.com/articles/nodejs-support#customizing-the-build-process). Either way, Heroku requires loading all the dev dependencies so they had to be moved to dependencies. I got it to work but it doesn't seem like a best practice.
You must've missed the whole point of this Koa thing...
Koa isn't new, it was created back when Node 0.11 added generators. Koa is ~~functionally identical~~ historically similar to Express, it just relies on generators/yield for managing async flow instead of using callbacks. Doug doesn't work on Koa, but some other members of the Express TC do.
Mongo suffers issues with replication reliability. Their mantra has always been "eventual consistency" when it comes to data replication, and that can be really scary. For example you can write to a cluster, then try to read back the data you wrote and get stale data. It works best in low write high read situations, such as using it as an interstitial system for caching documents built from data in a RDBMS such as mysql or postgresql. Just don't rely on it for being your primary data store, because you're bound to get burned. There's a lot of good commentary on [this reddit thread](https://www.reddit.com/r/programming/comments/3dvzsl/why_you_should_never_ever_ever_use_mongodb/) and [the article its referencing](http://cryto.net/~joepie91/blog/2015/07/19/why-you-should-never-ever-ever-use-mongodb/).
If you have 500 base64 encoded images, they better be TINY images for the thing to even run in a web view. 
Oh! That's actually a great idea. `postinstall` is standard in Node world, not just exclusive to Heroku, so anyone that clones your repo and runs a `npm install`will also have your `postinstall` script executed. I like this option a lot.
Sequelize Thrift Angular Cassandra Koa Yep.
[This sums it up fairly well.](http://blog.bitovi.com/wp-content/uploads/2015/07/react.jpg.001.jpg) Every year there's some new frontend framework that tons of people rally behind as being the defacto way to write web apps. Then 6-9 months later a critical mass of developers are on it and all those apps that were super easy to build on the new framework are now a pain in the ass to maintain. People start writing articles about all the ways that the framework is flawed, all the people who were against it to begin with say "I told you so", and some new framework becomes the new hot shit. Angular's specific issues have been covered fairly well: - https://medium.com/@mnemon1ck/why-you-should-not-use-angularjs-1df5ddf6fc99#.849gu4idu - http://larseidnes.com/2014/11/05/angularjs-the-bad-parts/ - http://www.quirksmode.org/blog/archives/2015/01/the_problem_wit.html - http://www.letscodejavascript.com/v3/blog/2015/01/angular_review Currently React is still riding high in its popularity wave, largely because React has a smaller surface area than its predecessors and all the churn has been in pieces used alongside it (Flow vs Flux vs Reflux). React also came at a time when a lot of people were adopting pre-compiling build steps to take advantage of ES6 and/or CommonJS loading in the browser, so JSX was an easy extension to that. 2016 is starting to look like the year people go back to writing progressively enhanced conventional websites instead of gigantic SPAs, but it's too early to call it. 
Let's say you're implementing an application in which undo &amp; redo functionality is important. Using a single state tree, you can serialize the entire tree anytime a mutation occurs then save that state so you can revert to it later on. I believe that's what mweststrate did during the Reactive 2015 demo at a conference. The [code is here](https://github.com/mobxjs/mobx-reactive2015-demo). Doing so isn't too hard, just wrap the relevant serialization code in a MobX autorun function. The problem with that is saving the entire tree for every mutation is not memory efficient. To make it so, we'd need additional architecture. In this case, you'd have a dispatcher which says for X action/data, run Y function. And actions which are the actual functions which mutate the state. MobX handles updating the view and informing all relevant parties of the state change. To handle undo/redo, you don't serialize the entire tree but instead just the stack of actions from an initial point. This is much more memory efficient since actions can be small objects, analogous to a diff/patch. Flux as a pattern (at least as it is defined within Facebook) doesn't actually require immutable state---just that mutations are done via actions held by a dispatcher and not encapsulated into every component. 
React seems to be having some staying power, most of its fad chasing has been in the data models used with it (Flow, Flux, Reflux, etc). Backbone has managed to still be pretty viable for non-SPAs. 
It's REALLY slow... looks are meaningless if I can't use it. The stock chart just takes seconds to update if I try to change anything. Another thing... the map example that looks like a folded map is buggy. If I tap the right button it flips back and forth between two views on its own.
Yeah. I suspect webpack loads in the assets in some in-line data blob. I'm betting I could have my assets package export the result of a function that does this for each asset, so importing the asset is really just importing the result of what webpack does. I will certainly share it here if I come up with a solution. Still looking for people who might be able to give me a further head start. =)
I don't have much of an opinion on the project itself, but this line caught my eye: imgLess.factory('Handler', function ($http) { You'll want to rewrite this to have the DI annotated. imgLess.factory('Handler', ['$http', function ($http) { Otherwise you're going to have a bad time after minification. The dependency on bootstrap also seems a bit needless.
You seem to know a lot, so maybe you can answer this question. If Doug is the main contributor, why doesn't he just fork the project and go his own way? I would imagine that other developers would go with him. 
Damn, this was well written and spoke my feelings.
I understand that. I just meant that since your observable is where all the change is happening, you could monitor that using mobx's great tools instead, alleviating the need for your own dispatcher. 
Postgres ORM React Node
Firefox nightly on my Nexus 10 Tablet.
You can indent using two or four spaces. IDE tools, such as [Atom](https://atom.io), should detect and auto-indent to match the document. Trailing whitespace are invisible characters, namely spaces or tabs, at the end of a line.
Well, everyone has settled on Redux by now.
oh ok cool, I dunno why but I was kind of expecting it to be more like JSON linter, which will take hideous and unreadable JSON string and turn it into something readable. 
&gt; maybe take a step back from this sub and see how people talk about js elsewhere. Hell, sometimes you just need to step back and try things on your own and block out the noise entirely. Sometimes the things that work best for you are completely against what everyone else is doing.
It's not relational. As your project gets larger and more complex, you'll eventually hit a point where you need relations. With Mongo you're stuck doing all the hard work yourself, while a RDBMS like Postgres will do the hard work for you, far more efficiently than Mongo ever could. Not to mention all the other great features RDBMS's offer over Mongo, like transactions, complex aggregation, more flexible data types, etc.
Well, it does not have to be base64 encoded, I guess I can save the images and save the path in the json file. Any alternative you can offer for the functionality I need?
It is possible. Learn how .sort works first though. http://reactivex.io/learnrx/ Here is a great site to learn how map ~~sort~~ filter etc etc work. I highly advise it.
Ah! You are correct. Excuse me. Nevertheless, if you go through the site, sort will be easy to understand. 
I'm not sure what everyone is using, however, [fetch](https://github.com/github/fetch/blob/master/README.md) is now a part of the web standard, so I prefer that with a polyfill.
Maybe not, but it's certainly more of a framework than jQuery is.
I'm guessing browsers didn't work that way back then. 
JQuery marks the last time I did frontend dev after spending years in pure-JS hell (and a couple in Prototype). It was a fantastic end to my frontend days. I love backend, though.
Underscore is great but its really just a utility. Maybe out it on your list, especially if you get into backbone!
Given: [[4, 2, 6], [3, 1, 5]] Do you want this: [[2, 4, 6], [1, 3, 5]] Or this: [[1, 2, 3], [4, 5, 6]] Or maybe even this: [[3, 1, 5], // 3 + 1 + 5 &lt; 4 + 2 + 6 [4, 2, 6]]
I'm in the same boat as you. That's why I get disheartened when I see articles/comments saying that jQuery is old/was once useful, but is no longer needed.
For a whole host of reasons related to kludgy things related to how browsers used to work (I believe that long ago, validation rules actually expected all scripts in the head and threw warnings for scripts in the body!), and also just because a lot of best practices hadn't been worked out yet. There are still a few good reasons to put js in the head: Modernizr, for instance, needs to run tests before the document body loads so that when it does, its core support css classes will already be active (preventing any flashes from rules matching or unmatching later on). Some analytics and testing libraries have reasons to be in the head as well, though often it's just because they haven't been fully optimized themselves. If there are a lot of complex scripts loaded and executed down farther a body, and you want certain things to start as soon as possible, it might be justified to start loading things in the head to jumpstart them as long as they are relatively small and non-blocking. Loading scripts as far down as possible, and as async as possible is the right starting point these days, and then you'll have to see what gains are possible from other patterns.
&gt; Once you understand them, try to introduce them at your work. Im just afraid that its too late to fix it. I was talking with my boss once, told him that its shit and he kinda agreed that we need a complete rewrite but i just dont think its possible when the only person that cares is me.
Thank you for the response! I think I was thinking "relative to BBone" the scoping is a little more structured but I may be wrong. When I wrote that post, I was hoping to get NG jobs but I ended up staying in the BBone world. Now we are adding React. Anyway, I present my view on NG with much humility and I respect your comments. 
Forking would split the community. The website and main source of documentation remaining in the original hands. Thus just like io.js it would be a mess better serving everyone to stay together (hence io merging back with node). Many people said he should fork it but he specifically responded to them with no.
yea - like x-skeww said theres more than 1 way to sort a 2d array assuming you want to sort the inner arrays **and** the 2d array: a=[[2,0,4],[6,3,9],[5,3,1]] //sort inner for (var i=0;i&lt;a.length;i++) a[i].sort( (a,b) =&gt; a - b ) //sort 2darray now that inner is sorted a.sort( (a,b) =&gt; a[0] - b[0] ) // sort by first item arr[0] this works by passing a sorting function to `.sort()`, im just using new syntax. normal example: `a.sort( function(last,current){ return last - current; })` -------------------------------- you can do all sorts of cool stuff like sort by average, last item, or array length / # of items: **sort by len** `(a,b) =&gt; a.length - b.length` **sort by last item** `(a,b) =&gt; a[a.length-1] - b[b.length-1]` **sort by all items** (a,b) =&gt; { for(var i=0; i&lt;a.length &amp;&amp; i&lt;b.length; i++) { if (a[i] &gt; b[i]) return 1 else if (b[i] &gt; a[i]) return -1 } if (a.length == b.length) return 0 else if (a.length &lt; b.length) return -1 return 1 } 
&gt;&gt;Do you work on any side projects at home for fun, even if you don't complete the side project? If so, do you enjoy it? If so, then you shouldn't change career. Yes i love that. I also enjoy going to meetups and hackatons. &gt;&gt;You have a golden opportunity to bring change for the better. Even if you can't make it happen, you'll be able to talk about the experience in job interviews. Yes, when i think about it, I would actually love to take initative to make try to make everything work better. Im just not sure if its worth it. Hey thanks for detailed answer. Actually in the meantime when i was tired, i got offer from different company, looks like very good company and very good money. I talked to my boss that im burned out and that project is shit but he kinds convinced me to stay. I told him that i feel like we need a CTO from outside, someone who will create better architecture and mentor entire team. He basically agreed to hire someone new. Then i told him i feel tired of project, he agreed that project is kind of shit and we need to fix it or rewrite it. Basically he gave me green light to start rewriting parts of the project from scratch which made me excited. The problem is i dont think i will be able to do this on my own, i dont believe anything will change unless he will hire new CTO, which im note sure about, i dont remember any new employee other than interns in 3 years time. I dont think i will have enough will power to change process, convince people to work better and be more passionate. Second problem is there are couple tempting offers on the market, and im in current company for 3 years already basically working on same project. Im just afraid it will be the same or worse somewhere else.
Don't worry, express isnt going anywhere. :)
You really dont need to do that. Express isn't going anywhere. Not only is it very stable, it is backed by more than just Doug. Like any big open source project, there are people who will step up.
Ryan sells Node, no one cares, I sell a project I had worked on for several years, everyone freaks out. Good times. My apologies to everyone has to deal with the drama. For what it's worth, both StrongLoop and IBM have been reasonable from what I've seen, slow perhaps, but professional. 
Nice flair. 
There's jQuery routers? How did I never know this?
Old projects aren't abandoned; they're placed in maintenance &amp; improvement mode. Edit: They're also a good testbed for new libraries/frameworks, since you know the project code is tried and true and works, so whatever goes wrong is due to improper usage of or bugs in the new library/framework.
Use happiness if you like tabs https://github.com/JedWatson/happiness
[There's tons of routers](http://microjs.com/#router), including some framework agnostic ones like [sammy](http://sammyjs.org/docs/routes).
I think my question wasn't clear. I was talking about routers specifically built for jQuery, as /u/btdiehr suggested or implied that some were built specifically to go along with jQuery. The ones you list are, well, micro-libraries, meant to be plopped into and used with any front-end code. I'm aware this means jQuery is fair game, but -- my understanding of /u/btdiehr's statement is different. So, my bad if I misunderstood.
Can I just drop lodash in place of underscore and not update any code?
But that's the same as $(document).ready(), so i guess hta'ts not what he means
Not to mention document.addEventListener('DOMContentLoaded', ()=&gt;{}); is a thing
It's still a very essential tool; i use it every day, especially for ajax stuff. But the biggest difference to the past is that manipulating the DOM manually is incompatible with using a virtual DOM for writing to the DOM (like with React). You can still use it to read from the DOM just fine though.
How is it functionally identical to Express? It's not at all, which is why it's a different project.
The node community has always been pretty toxic from my perspective, if anything it's better now because people are learning to be civil. Everyone else involved seems totally chill and professional, Douglas appears to be the only one freaking out.
Yep, maybe it's because I've stayed off IRC etc but I've had exactly zero hostile encounters with Go people. I can't even begin to say the same about node. I've learned a lot from the experience though so it's not all bad, being defensive about your work turns you into the people you dislike. Having strong opinions is fine but not at the expensive of bringing someone down.
Why mixing React with jQuery? 
Wait, so are we treating IE6 as properly dead now? [mfw](http://i.imgur.com/sqgyltQ.gif)
I don't think this is Survivorship bias. I could see why you might think that, but this is distinct, and wholly different. In fact, its probably the very opposite. Personally, if the most prominent JS frameworks all exhibit this level of toxicity, then regardless of the smaller, lesser-known frameworks, the community is toxic by the very definition of the world "community". There is no intrinsic trait that is missed here, as the community is the observation. As much as we like to think that small pockets of people can work together and are "the real community", the larger bodies are unfortunately always going to represent their communities. If large groups of people are consistently having problems in a space, it is absolutely a fact that the community has a problem, and is not a product of random chance or limited observation. Unfortunately, in JS lately, It's precisely because of that visibility that makes a framework potentially toxic. The kind of competition and avarice I have seen of late are insane. I only know (2) frameworks which I can think of which are highly visible, have a large number of users, and I would consider friendly enough to contribute to. I have even seen very negative reactions from smaller frameworks, even, and am unconvinced of your assertion. I in all my years have never seen Ruby, Python, or any other language I have worked in ( C#/Haskell/ML ), come anywhere CLOSE to the level of vitriol of the general Javascript community. I'm sorry to say this, because I love Javascript too. 
I think your framing is in error. "...it is still dishonest, because you are simplifying and/or generalizing with no guarantee of correctness." I don't think you'll build consensus among geeks or academics for that obtuse definition, and that's putting it mildly. And I think one could say something about the mind that demands for guarantees of correctness, so much that they would accuse generalization and risk of error as "dishonest". You haven't broached the underlying reason why mathematicians might take the risk to dive into a respected person's claimed proof for a non-trivial problem. It's because of *information* arising from an ad hominem *predictor* called credibility / respect / trust. The difficulty of proof checking just raises the stakes, and that makes information even more valuable. If you were an executive at a hospital responsible for hiring and management, you are also relying on credibility / respect / trust. Except this time, the stakes are health, life and death. And yes, you will be generalizing. Refusal to look at ad hominem predictors, refusal to look at information for fear of error, is what smells intellectually suspect.
You need to store the array of teams outside that function, because the way you currently have it, it is re-created with each invocation, but it needs to be mutated; also, when running an [event handler](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Event_handlers), `this` is a reference to the element that caught the event, and you should use that rather than the `table` element. Finally, you would use [`innerHTML`](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) to inject markup. --- I was tinkering with this fiddle and I found that maybe JSFiddle doesn't like inline event handlers, so I made a loop to add event handlers inside the JavaScript (you should do this sort of thing anyway, known as "Unobtrusive JavaScript"), and I made sure to keep the default action of the button from working with a `return false;` and to keep the button from working if double-clicked by setting the `onclick` handler to `null` inside the handler. I also, importantly, used the array's [`splice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) method to remove elements from the array: https://jsfiddle.net/lewisje/k7h6dffw/
"Fetch"?? There's a Mean Girls joke in there somewhere...
If react is a framework for wanting your templates in the JS, then vue is a framework for wanting your templates in the HTML. Also, that would make angular closer to a library, since you can specify the template as a string or as some resource url which can be [fulfilled by anything](https://docs.angularjs.org/api/ng/service/$templateCache). What popular technologies would you consider to be just libraries and not frameworks, other than jQuery?
&gt; just because a lot of best practices hadn't been worked out yet No, they were just different best practices. Times change. Things evolve.
Just so beginners understand: - jQuery is great - people who critique jQuery are largely idiots - learning jQuery is a *must* for web development - frameworks get popular and come and go, but jQuery stays around and will never go away (in my opinion) - as jQuery is free, look at the source code - it is some of the best written JS out there for you to learn from jQuery allows for 2 main advantages in DOM manipulation: 1) it makes browser differences disappear by making the same call work on all popular browsers, even if the browsers implement it differently. 2) it simplifies the JS you need to use to access and update the DOM Even as browser become better at following standards and being compatible item 1 will not go away. And item 2 just makes sense. JS sometimes is quite verbose and jQuery as very simple syntax and optimized code to make things easier. Framework users (especially Angular) dont like to use jQuery and make up all sorts of BS about spaghetti code or jQuery soup. If your code is like this it is not because of jQuery - it is because you are a bad programmer unable to create maintainable modular code. OP - good article !! 
I didn't realize reddit was using node at all, so this is really interesting to learn.
I'm guessing what is happening is that your 'dogCenter' variable is initialized at 300. But your CSS left: px width is not, or the value is different see this fiddle. https://jsfiddle.net/qabghvL4/1/ If I change dogCenter to 100 which is the same on the css. I don't have that issue.
They reject it because it's not modular. It relies on a global pattern that ultimately is a very poor way to structure code. Using a module system like CommonJS is leaps and bounds better (particularly, for unit tests but explicit dependencies via import/require are wonderful). jQuery has its place. I don't think anyone begrudges it. I inject it into the page on some CasperJS tests to make things easier. But I don't use it in modern production web application code. I prefer modules and if possible, native code. The need to wrap everything is mostly gone. And if it is needed, a module that does one thing is much easier to deal with. Ha! I guess one shouldn't explain the obvious in a jQuery lovefest thread.
Okay, that totally fixed it. Thanks! 
Check out [Lasso.js](https://github.com/lasso-js/lasso). Lasso.js is JavaScript module bundler and an _asset pipeline_ for Node.js apps. I'm the author of Lasso.js, and while it is not nearly as popular as Webpack, it is arguably more powerful and a lot easier to use (no crazy configuration files) and is definitely production ready (used heavily at eBay and it's getting pretty good traction outside eBay). It definitely supports the use case of moving assets into separate, shared packages. There's also an isomorphic plugin for retrieving image info (URL, width and height): https://github.com/lasso-js/lasso-image The code will look like the following: var lassoImage = require('lasso-image'); lassoImage.getImageInfo(require.resolve('./my-image.png'), function(err, imageInfo) { if (err) { // Handle the error } console.log('URL: ', imageInfo.url); console.log('width: ', imageInfo.width); console.log('height: ', imageInfo.height); }); For the [Marko templating engine](https://github.com/marko-js/marko) there is also a custom tag that allows any marko template to reference image files in any package and the referenced image files will automatically go through the asset pipeline: https://github.com/lasso-js/lasso#lasso-img The usage of the Marko custom tag will look like the following: &lt;lasso-img src="./foo.jpg"/&gt; Which will output something similar to the following when rendered to HTML: &lt;img src="/static/foo-25b047cc.jpg" width="100" height="100"&gt; Hope you find it helpful.
Your opening makes it seem like there were no best practices back then though. There were and, yes, you even brought some of them up.
Ping. I found a solution when using Webpack. It's actually very simple. See my main post edit if you're interested.
Agreed that there's a lack of tools that just work. I really wish I could find more tools (even if they're "just" pre-bundled and pre-set up) for various common projects. One of these days I'll try to get started on such a thing.
There's [yeoman](http://yeoman.io/) for "pre bundled" or "pre setup". You still have to setup yeoman itself, though, and find the right "generators". It's not really what I want for plug and play though. It's still a fragile mess of highly-configured tools, just one that someone else went through the pain of setting up for you.
This is great man. Thank you so much. How about an algorithm for generating weighted random numbers so that say the cavs team gets a 25% chance at getting the number one pick instead of using the Math.random() function to randomize all teams. would I just need to create 8 separate functions for each of the teams in the array or what. If I knew the correct formula for just one of the functions the other 7 would simple be copy pasting the function and adjusting it to the correct odds. also any way I could have the contents of each button click emailed to my league after its clicked? sorry if that's offbase as it's probably more of a php question. 
I've been doing JS since 99 or so and jQuery is awesome in the same sense that a hammer is awesome for hammering nails but not for eating a steak. As far as micro DOM manipulation goes it's amazing. Of course once you enter the data binding realm there isn't much need for it anymore, but not all websites are Angular SPAs. In my experience the only real shitty part of jQuery is the animation engine which has poor performance compared to GSAP, CCS3 transitions, etc.
na. too long and the new name breathes a lot of fresh life into the project (I would have definitely ignored it if not for the change of name).
I think bringing in all of jQuery just for AJAX is overkill. As others have mentioned fetch works for the majority of cases, but if you need something more jQuery-like there are other libraries that fill just the AJAX gap. I've said it before but I'll say it again: in this day and age jQuery is just not necessary unless you still need to support older IE (which should go away very quickly now that MS has dropped support). That said I do absolutely agree with the OP. I would not have gotten into JS without jQuery there to help me out in the beginning. With such a powerful crutch it's like a completely different language.
I could always just allocate more items of the same to array to get the % I want. like having cavs in the array 25 times next team 16 times and so on etc.. but has to be a more constructive way without adding all that extra code. plus i'm dealing with precise weights. just to reiterate the odds for each team would be for 1st pick = 25%, 2nd pick 16.4%, 3rd pick 16.4%, 4th pick 16.3%, 5th pick 9.4%, 6th pick 6.6%, 7th pick 4.4%, 8th pick 2.7%
That last question probably is for whatever server-side platform you use (in your case it's PHP, but for a future project it could be Javascript, via Node.JS). You probably would still use `Math.random` to randomize, and I just thought of a way to use the ES5 [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) method [`reduce`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) to deal with this: // below that array of the teams, presuming the chances are in the same order var chances = [0.25, 0.164, 0.164, 0.163, 0.094, 0.066, 0.044, 0.027]; var total = 0.972; // manual sum, could have used array's reduce method // now replacing that function function teams() { // cumulative chance, normalized as if total chance were 1 var cumul = chances.reduce(function (prev, curr, idx, arr) { if (prev.length &gt; 0) { prev.push(curr / total + prev[prev.length - 1]); } else { prev.push(curr / total); } return prev; }, []); var test = Math.random(), pick = null; for (var i = 0; i &lt; cumul.length; i++) { if (test &lt; cumul[i]) { pick = i; break; // would use array's forEach method, but that has no equivalent to the break statement } } if (null != pick) { this.onclick = null; this.parentNode.innerHTML += aTeams.splice(pick, 1)[0]; total -= chances.splice(pick, 1)[0]; } return false; } I have made these changes to the fiddle: https://jsfiddle.net/lewisje/k7h6dffw/3/ You can also try adding a `click` listener to just the `table` element that adds the images in the right order for you, and then removes itself once there are no more images; I might whip up what that would look like soon.
Early on (first year), they did a lot of lying with the marketing, and replying to technical issues with marketing. Mongoose is great, however, so it attracts use.
Make? Why not Bazel?
http://caniuse.com/#feat=fetch Unless this is wrong ... basically only Firefox and Chrome. While I dislike IE, I still make sure those that use it aren't completely FUBAR.
I could still read your OP, and as my code below indicates, your chances don't add up to 100%, but I dealt with that anyway; also, your idea of duplicating teams (using 250 cavs, 164 of the next team, and so on for preciseness) would require something like a [`filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) operation to ensure you got all the copies of each team out of the array, and although it's kludgy, it could well work (imagine a `for` loop to `push` the same string in, possibly within another `for` loop running over the original array of team images).
No.
Thank you! I miscalculated my percentages there and adjusted the code accordingly. although the chances are in reversed order so I just swapped them around. I wanted it so the 8th team in the array has the lowest odds to get the number one pick since we will reveal the picks in reversed order all the way to #1. so by reversing the order of the values in the chances array I think that accomplishes it. here is what I have now. https://jsfiddle.net/ocow8Lm9/3/
You can totally do what koa does with generators in express. And the thing, it then can be read like a blocking block. var wrap = require('co-express'); router.verb('some-route', wrap(function* (req, res, next) { var val; try { val = yield aPromise(); } catch (e) { return next(e); } }); 
I respect your opinion. However (in my opinion) its wrong... A framework is just a tool that is opinionated and forces its own standards on a developer or development team. Equivalent standards can and are forced by any decent tech or project lead, especially for large complex systems. You do not need a framework to enforce good architecture and maintainable code. jQuery as a tool can and is part of very large well-designed systems. The majority of web applications are not very complex on the front-end - they are a bunch of input screens that pass data to a back-end server and a bunch of presentation screens that present different kinds of views on data received from a back-end server. 
The big idea is that the fetch and promise polyfills are fairly small and that you can get rid of them in the future without having to change a single line of code.
They tend to try be minimal and let you choose how you want the tool to work for your needs. You might prefer Sass over Less, or just plain CSS, you might want to minify your CSS but with a minifier of your preference like CSSNano instead of whatever default they could throw in the "box". If you're familiar with web dev there is plenty of choices out there and what's popular is changing fairly frequently, so it's in the best interest of the tools to remain relevant by not pushing their opinions on you I guess? That said, you don't have to put yourself through potential pain of learning a new tool properly and configuring from scratch, normally someone else has gone through this, and released it(config file, yeoman generator, starter-kit/boilerplate project on github, etc). You can start with that, then make any changes you disagree with as you go. Like with ESLint for example, AirBnB's config is quite popular, much easier to get started with theirs than go through each rule yourself and get stuck with paralysis analysis making your mind up on things like spaces or tabs for indentation :P It's pretty close to working out of the box then, these community releases usually provide brief instructions to get you going faster.
I feel it would be much better if people stopped digging Express out. Let's just switch to some newer alternative (Koa2 is obvious choice)
Interesting project. Obvious comparison for me would be Ramda, which also has a lot of support for manipulating objects immutably. Eg: scour(data).get('users', '1', 'name') // =&gt; 'john' scour(data).set(['users', '1', 'updated_at'], +new Date()).value Versus: R.path(['users', '1', 'name'])(data); R.assocPath(['users', '1', 'updated_at'], +new Date)(data) But the model stuff looks interesting and a little novel to me, at least in JS land. Anyone actually using this for anything cool? How does it work with React/Redux?
Nested promises are considered an anti-pattern. Yes yes yes - standard question to such a claim, "considered an anti-pattern" by whom? - http://taoofcode.net/promise-anti-patterns/ - http://www.datchley.name/promise-patterns-anti-patterns/ - https://sdgluck.github.io/2015/08/24/promise-ponderings-patterns-apologies/ to list just a few. Well, it *does* actually defeat the purpose when you think about it.
you should look in to google analytics https://www.google.com/analytics/ 
you try to make a profile ID based on IP / browser version / username / macaddress (even better). then give that person a uniqueID #. ex start a global counter at 0 and each person gets a +1.. store the unique id as a cookie. note you have to warn eu customers u use cookies cuz of new law. if customer visits the page without the cookie you try to find their username/ip/browser, if they dont they get a new id ping the server with the uniqueid and action when the user does something. its done on JS side to prevent cookie blocking, but its better done on server side if the user disables cookies or you want the IP/mac address profile. recommend mixpanel or kissmetrics. 
Can you explain how it's easier? I've converted my earlier CodePen example I linked to [async/await](http://codepen.io/anon/pen/qZBKpp?editors=0012), async/await doesn't address the issue I was asking about though it is cleaner to look at.
I'm not sure if you looked at my CodePen link at the end of my original post? I'm attempting composition, the other options don't really seem too viable due to the dynamic nature(input of array = n promise sequences chained). My problem was that due to extracting logic out into their own functions so the rest of my app could use the same methods(I'd like to implement looping of the sequence but also pause/resume as well as next/prev navigation of the hardware state it's changing). If you look at the CodePen while not the best example, I have a `make_request` function at the end, the promise chain at the start branches off 5 times, each branch from there 3 times, and then those branches through 2-3 functions to perform an async request. My question was about improving how I've approached this as I'm sure I'm doing something wrong, or if there is a better way to handle state when it's that far down the function sequence. I could contain it all in one function like your examples, but then I'd be duplicating the logic elsewhere which would be bad? I appreciate the nice response though :) With the mailbox example, you'd supposedly be aware of the connection limitation, and then guard against new mailbox access until the current promise is complete(just check it's status, if active/pending, then return an error/reject or add the request to a que which will action the request once the first one completes :) ). My example actually is similar in that I can only make x requests to hardware before triggering errors, so I've batched them into small groups and wait until they're complete before sending the next batch, promises have given me a nice and more predictable control flow than I had with just sequenced delays via timers where network latency issues was causing errors from causing too many requests at once. The bit about treating a promise as a value/variable is spot on :) I haven't been thinking like that, much like you said as treating it as a function, which I guess is pretty clear with my example code I linked. Still new to using promises beyond `fetch()`, the example code is my first attempt with them over a day, ran into a bunch of the problems you described, took me a good while to figure out why my code was broken quite a few times haha.
I think that little code sample I placed is getting looked at without the text content being given much thought :P That was just me sharing an example of a common solution I'm aware of, I later link to CodePen example I made that's larger and illustrates the problem I have from breaking the logic out into functions. I think I've approached the extracting to functions wrong though, the function that requires state is in not in the initial chain function. (5 Promises) -&gt; (3 promises each wrapped in a `Promise.all()` with some `then()`s after) -&gt; (these 3 actually being objects before having state changed and performing async request which returns them as a promise). The CodePen probably makes more sense to look at than reading this. `make_request()` is the function I'm referring to as being difficult to pass state to.
More like 29k when minified and gziped. https://mathiasbynens.be/demo/jquery-size
after briefly looking at the codepen example, I have to ask, what is wrong about the way you are doing it now? Im asuming this is probably a trivial example compared to what you are actually doing? (keep in mind, I am pretty new to javascript, and come mostly from a shell scripting background, so I really havent dealt with many complexities like you are asking for help with, so I genuinely just dont have much exposure to these types of issues, and am just trying to learn about these types of problems, so my questions / responses are probably extremely naive)
Like any framework? 
Your example describes perfectly why jQuery was such a success. It has easily understandable syntax and a lot of convenience compared to native DOM manipulation. The native DOM functions are generally just annoying to work with. I recently rewrote a Chrome extension I made to not use jQuery as the concept was easier to make work with it but I didn't want to have 3rd party libraries in an extension that just takes images on a page and makes a lightbox gallery out of them. Doing it all natively was a lot more work to get right. 
FYI: I've added a 2nd Metalsmith version using Nunjucks template layouts, see [/metalsmith-nunjucks](http://staystatic.github.io/sites/metalsmith-nunjucks). Cheers. PS: The 1st version is using Handlebars.
&gt; jQuery is a great tool, but whether it even led to a net increase in good code is an open question - the idea it "started professional web development" is crazy. I started out in 2001, before jQuery. It made a lot of people content with nasty, nasty javascript in the browser. But it also opened up a whole new world of cross-browser compatible jQuery plugins that made front-end development much, much easier, and much, much more interesting. When I started, javascript was mostly used to display alerts for simple form validation. jQuery made (most of) us go "wait, javascript... can do more?" I remember most of the websites from back then. I remember making hundreds of them in the years before jQuery. It wasn't all crap, but it was all tables and shit.
Thanks. I'll have a think about this.
Nice post! A lot of the time people will throw around phrases like "programming is math", which is, at best, really vague, but i like the tie in to functional programming
Yeah, sorry I should've written frontend development (like the last sentence), and more like kicked off. But I never avocated that it led to write good code, bad code is to be found in all tools, ecosystems, frameworks and so on. It's more related to the people that writes the code that to the tool itself (although the tool can bias you to write code into a particular way that can be consider bar, or is going to be). Do you remember &lt;!--[if !IE]&gt;, that's hacky also.
&gt;harder if they open two tabs thats why google uses mac address its pretty easy to dump into JS from the server side, just in your view you do something gross like var ident = json_decode("&lt;?php echo $macaddress ?&gt;" || "null") (assuming you can get it, if not theres probably an apache module for that). you can use hacky stuff like `json_decode`, try/catch, and `"$var" || "default"` to not output such breaky js. ------------------- anyways i wanted to reply again to mention: its best to do a fallback scenario for finding the id by cookie or mac, then ip then hash of browser+osname and versions (or whatever). they also sometimes use the ip geolocation api to determine somewhat where the person is. // backend: // lookup() queries the DB for profiles matching the current and returns null if not found var id = lookup($cookie['uniqueid']) || lookup($username) || lookup($macadress) || lookup($ip) || lookup(hash(browsername+osname+osver+browserver+first6IPorCity)) if (id) setcookie('uniqueid', id) else setcookie('uniqueid',uniqueid()) ---------- and if your having trouble a good db schema for this would be like identifier string | uniqueid int | PageOrAction string | extradata json in identifier you can either put a json object { mac: "xx:xx:xx", ip: "1.1.1.1", etc } or csv, ex: `xx:xx:xx|1.1.1.1|cookieid|hash(browsername+os)|etc`. and query it with `identifier LIKE '%xx:xx:xx%' or '%12.63.123.2%'` (or of course seperate it into columns but its grosser to work with imho, but better for v2,v3 down the road) n i use extradata json to stash referer and who knows what else, b/c i always change the req's :) i would look it up on the backend, dump the ID to view, and write it to cookie or localStorage, afaik theres no law about storing shit in localStorage (but there may be lol)
Sorry, I overlooked that part of your question.
With current Internet speeds and CDN, I think people worry way too much about it. 84Kb is like 1/10 the size of a single high res jpeg on your site that is not cached. If you're gonna have 1 or more images on your site, why are you gonna worry about an 84Kb file?
Because you wrote "=" which is an assigment. You need to write == or ===. (Preferrably the latter.) Edit: and, I am stupid, that was exactly the point.
&gt; That function f(){} you see there, is not a function declaration but a function expression. That is, we're not declaring a function named f which will be generally available. We're constructing a function value. In function expressions, you can (if you want) give it a name, such as f, but that name will only be available inside the function expression itself. That's it. The explanation given in the article is completely off. 
I have been using vim for a while now, but never for large projects. This article taught me so much. Thanks!
&gt; It made a lot of people content with nasty, nasty javascript in the browser. But it also opened up a whole new world of cross-browser compatible jQuery plugins that made front-end development much, much easier, and much, much more interesting. Absolutely, yes - it made it *easier* to write cross-browser JS, because it abstracted away a lot of the incompatibilities, sure. &gt; I remember most of the websites from back then. I remember making hundreds of them in the years before jQuery. I think you're confusing "happened around the same time" with "caused". Cross-browser client-side JS and using JS to build rich user-interfaces was already *well* underway before jQuery was around. [Dojo](https://en.wikipedia.org/wiki/Dojo_Toolkit) was already huge, [Prototype](https://en.wikipedia.org/wiki/Prototype_JavaScript_Framework) had been around and popular for a year and a half before jQuery was launched, not to mention massive corporate projects like [YUI](https://en.wikipedia.org/wiki/YUI_Library). It was already a well-understood possibility, and there were already many, *many* libraries and frameworks looking to take advantage of the potential - jQuery wasn't the first, let alone the cause - it was merely the most successful of the bunch. Fuck, *I* was experimenting with writing my own client-side framework and library of rich UI widgets before jQuery was around, and I was a nobody developer working in a no-name web-dev agency. It didn't take a great genius or prophet to predict that client-side JS libraries were going to be huge - just someone with a modicum of experience and industry-awareness with their eyes open. I have no doubt that a lot of people came to web-dev around (of even slightly before) that time, found it a bit irritating, then discovered jQuery and noticed the explosion of front-end UI development that happened around the same time, but jQuery really had nothing to do with it. It's a great library, but the burgeoning development of sophisticated front-end web-dev was already both clearly visible and had already been well underway for a couple of years before jQuery was even a twinkle in John Resig's eye. &gt; It wasn't all crap, but it was all tables and shit. That kind of demonstrates my point - jQuery had *nothing* to do with the adoption of CSS, flow layout, semantic markup, ditching tables-based layouts or the million other things that were happening at the time. They were all things that were already happening before jQuery cam along, and jQuery did absolutely nothing to encourage or discourage any of those things. At best people learned about them *at the same time* as they learned about jQuery, but there's no causative relationship there. jQuery was around at the time, it's a great library for DOM manipulation and I have no doubt that the ease of jQuery helped some newbies get into web-dev more comfortably, but I suspect if anything you're confusing the surfer for the wave.
I'm not by any means an expert, but what I'm learning at UF right now and use in a part time job is AngularJS. I've also heard good things about Typescript. 
Sure. Like I said in the linked article, part 2 will go into using observe-component and React to implement a less trivial program using the Model-View-Intent pattern. If you'd like, you can poke around the code here: https://github.com/Lokeh/observable-drag-drop-example
Thanks! React definitely seems to be getting talked about a lot, and also on plenty of job listings - time for a little project I think.
Do you mind if I ask why you cannot use any 3rd party analytics products? Is it because you don't want a 3rd party to get your data? If that is the case, there are several 3rd party analytics tools that live on your server (rather than the cloud) and do not call home. You can keep your data private without reinventing the wheel.
Does your laptop use an SSD while your desktop uses an HDD? Reading a zillion tiny files is much faster with an SSD.
Satan, is that you?
The software we're making is sort of an analytics product. So it needs to be original / custom built... 
Wow; thanks for making the effort to write that up. It clarifies. 
What does this do that node doesn't? What is wrong with c, Python, Java, shell scripting, sed awk, perl, etc? The command line was built to be simple and fast why muck it up?
I'm using v2.14.12 on Windows. Should I update?
You know what, I never even considered that. I wonder if the $ sign was influenced by PHP
Like atheism! 
IIRC FF can take advantage of the proprietary codecs provided by the OS.
I wish there was support for Tally
Am I the only one with zero patience for examples I have to download and run myself?
could it also be because I am video.js? Also would it be safe to assume most other web developers have an OS that can run mp4 videos? 
Cash is a great example of someone not having anything interesting to do so they just did something. ls in js for a Linux shell makes tons of sense. The shell is a long lived interactive tool. And js has debugging in the browser.
Yea, it makes no sense considering that Github makes it very easy to set up front-end examples.
Can you please tl:dr-explain for me what this is doing better than js-traverse? https://github.com/substack/js-traverse
Accidentally lost my reply of several paragraphs.. If this response was about /u/GentleMareFucker 's mailbox promise problem, I made a small [CodePen](http://codepen.io/anon/pen/jqOpRY?editors=0012) demo to show that it could be avoided. In it I only use numbers to represent the mailboxes, but they could be full on class/objects with properties and methods. I'd still think the open/close functions appropriate, where I have in comments about running logic to open/close you might have your own open/close methods on the mailbox to run, but if you encapsulate it all like you show, how do you avoid the error of another mailbox breaking the connection? My example has the new request wait for the old to finish. --- If you just happened to use a mailbox example as well to discuss my own problem, if you look at my original CodePen, linked at the top of the original post, you'll find that is not quite an option to take your approach. It may not be clear but I'm using an API that returns objects with a bunch of state, you can modify the properties on the objects then to actually action them, you need to send them back through the API as a request(these changes are applied to actual hardware). Due to this I'm finding it difficult to see how OOP is going to help? I want to have the logic split out into functions so that I can reuse them with other actions. The sequence I've built will loop until the user actions it to pause, they can resume as well as navigate the state to the previous/next states manually. My problem was with `make_request()` being quite far down the call of functions and referencing state outside of it. I only know of passing it through all the functions(obviously bad), having a const outside of the functions that it can refer to(ok in this case I guess) or maybe I can find a way to flatten it out a bit more so it's more composable. I put together a [simple example](http://codepen.io/anon/pen/EKxpWp?editors=0012) for another user to illustrate what I mean.
It's all MIT licensed software, no matter the outcome, that is a fact that remains true, so there's nothing stopping anyone from forking it even if I have nothing to do with it. You can't rely on someone who created a package to maintain it indefinitely, this is true of anyone. Frankly I find what you say offensive because many of the more prolific Node authors have helped employee hundreds if not thousands of people. I don't expect anything for that of course, that's not why we write code, but I think your statement is ignorant. We all have to make a living, I truly thought it would be a win-win for myself, Douglas, and the community. 
Chrome will play mp4s on any OS. mp4s play on FF on Ubuntu. I assume mp4 playback is supported on any OS people will be using to view your site.
Why not use elm? 
This article sucks. Typos, and a bunch of things that are misleading or wrong
According to the post below meteor comes with its own node version so you may have to go through their channels. If you want to try to update node in general on windows just download and install msi since updating npm from the windows cli is not very intuitive. If you decide to update, you must delete all node modules installed so that npm will force a refresh with the flat module structure which should be much much faster due to less fs stat calls. I'm on mobile so there may be grammar issues. *spelling
I'm pretty sure the only sensible answer to this interview question would be "why would you do that?" 
Browsers are way more resilient than you think. You could crash a chrome tab, but the others will be fine. You could slow down Firefox, but it'd prompt you to kill the script. I'm no security guy, but I don't think there is a way to break anything from inside the browser.
I never use named function expressions because I have never found a place where they can be used and something else isn't simpler/more clear to use. Therefore, I don't know much about their specifics. I knew the article explanation was off (is evaluated using eval?! No way that's right) but couldn't for the life of me figure out why. Thank you for restoring my sanity.
There was another thread today asking the difference between a website and a web app. Long story short, there is hardly a difference. If you want to draw lines, a website offers a mostly static experience with some user interaction. A web app is a website but molds itself depending on user interaction and input. But still those terms are nebulous. Facebook could be a website, but also a web app. You're thinking about this wrong. You don't need a framework right away. You can build everything that you need without needing something like react or angular. You say you're good with Python, why not setup a server with something like flask and start building? On the front-end whenever you need data, just make a request to your server. Of course, you could even decide to keep all the important logic server side (not that I would nowadays, but to each his own). You don't need a framework if you haven't built anything yet. Build something to understand how the parts fit together and show yourself that it isn't so hard. After that if you feel that you honestly need a framework, then find the one right for your app.
I've used named function expressions exactly once, in some weird recursion scenario.
ohhh okay thanks!!! I can't in mind that i would pass in a string like april, june etc. and was so confused.. Could you also explain birthday.getMonth()) and birthday.getDate() please! what is getMonth and getDate? 
There's two problem in the html 1. &lt;span class="off"&gt;1&lt;/spleftan&gt; (misspelling in the closing tag) 2. You're never closing the &lt;ul&gt; Also you're not including jquery anywhere Here's a fixed fiddle: https://jsfiddle.net/cgvg6gmf/2/
Curious if you've checked out react-virtualized Grid: https://bvaughn.github.io/react-virtualized/?component=Grid Seems very similar.
Javascript is the language of the browser so it is closely tied to the web. Node has pushed it out of the browser so it is starting to open up into other areas, however it still very strongly rooted in the web. If you want to use Javascript without using the web might I suggest that you look at the recent mobile frameworks (React Native or NativeScript). In both you need to set up a Node environment and use npm to bring in the required components. Since both are emerging there is little around in terms of tutorials except those provided by the frameworks. However both are excellent products and rely on using the good parts of Javascript.
I honestly got teary eyed reading this. Shit man. I feel bad now for moving to Angular. 
&gt;What should I start learning framework wise? don't sweat frameworks right now. just start making what you want to make. you don't have much familiarity with the problem domain or the language, so you don't have much to go on when making a decision about a framework. after you start making things and running into real problems, it's a lot easier to choose a framework that best solves the problems you're facing.
[**@BrendanEich**](https://twitter.com/BrendanEich/) &gt; [2012-03-13 16:49 UTC](https://twitter.com/BrendanEich/status/179610205317902337) &gt; @magrangs because that is how java.util.Date did it. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
The explanation is that the article in question is complete nonsense. If conditions are not `eval`ed at runtime. This article is included on an improbably popular list of "curated" JavaScript resources for new developers and it is hopelessly incorrect.
My problem is, the idea of multiple different function syntaxes in one codebase bothers me quite a bit. I don't need the extra `this` stuff provided by `function` ever, and sometimes (not in this case) the extra `this` stuff makes my code ugly (have to use `bind` all the time, or `self=this`, or other nonsense). So I thought, maybe all arrow functions all the time would make sense. I know it's slower, but this is not code where that matters (function is called at most once per page load, usually 0 times), and in the future it might not be slower. Is that the only downside? Because consistency is a big advantage in my mind, much bigger than a trivial and probably temporary performance difference.
This is awesome, thank you for making this! Question: It looks like DOM element *removals* aren't animated (only the surrounding elements are). For example, in your notification demo they just disappear when you click "X", then the other notifications move around to take up the slack. Is there any way to change this, like have them fade out or something?
&gt; Kinda like opening the docs to a JS library and seeing all the examples in Coffeescript. That's cold dude, I am not as bad as a Coffeescripter :) The root of the problem is all these fucking ways to declare functions. Sometimes I hate JavaScript. And as the reader of code, I don't want to think "hmm what kind of function declaration is this, and what does that imply about `this`?", I want it to be exactly the same every time. I don't need 8 different kinds of functions, I need one (or, what I really need is Python, but alas...). And the arrow function is the one that seems to be the least horrible, so my plan is to use it in all ES6 code, and since I have a high opinion of myself I imagine most others will come to the same conclusion. The funny part is, the app I'm using my library in is not ES6 yet, so the only code actually using this library is written with the boring old function syntax.
Not having anything interesting to do can result in many kinds of expressions, where bitching online on non issues is even less so. 
Nice! I've been doing this for quite a while manually, and per use case. Gotta see what makes your library tick :D
how do I test internet explorer on a mac? Also it's not spaghetti code, it's actually pretty well formatted and modularized code, since I am pretty sure if I send a buggy crappy app for a job application it would not only make the whole thing pointless but will probably hurt my chances even more. but unlike a normal site i develop, there are certain compatibility things I ignore, such as graceful downgrades for browsers that don't support the latest things. It's meant more like a container of organized information. BUT! maybe i could really impress them by writing quality code like this: &lt;script&gt; var listItems = document.getElementsByTagName('DIV') var things = new Array('1', '2', '3'); for(i = 0; i &lt; listItems.length; i++){ var number = things[0]; var ok = document.getElementsByClassName('stuff'); if(number == 1){ document.getElementById('crappyDiv').innerHTML += ok[i]; } } &lt;/script&gt; &lt;html&gt; code like that will surely impress any JS dev 
Because Windows sucks. And, to be clear I'm not just being glib. All of these cross platform tools can "work" on Windows but the internal compromises are vast and deep. They add up and the hacks just mean things get slower or the behavior is slightly different enough as to be annoying. It's the same with Python, Go, the GNU tools, Chef, Puppet, Ansible, and on and on. It is much easier to write tools and languages for the *nix'es and then backport to Windows than to write something for Windows and then port it the other way. In the end it means that Windows will always be a second class citizen (as it should be IMHO).
This is true, but Github maintains a polyfill that's only a few KBs compared to I think more than 100 for jQuery (minified).
Doug has just **reopened** the PR. But it doesn't mean he will be involved. 
Gulp is pretty much it for me. I like Grunt and Webpack too but I prefer the code-like syntax over the config file type syntax. 
You should completely ignore that page. It's got bad/wrong information all over the place. Find a better tutorial.
There's no reason you can't write it with an arrow function. It could even be desirable, if you want to indicate the function has no context.
Here's an example of how I do it for Minecraft. https://github.com/GoMeep/daemon/blob/master/modules/instance.js edit: essentially I just wrap the java server so all information goes through Node. This can be used to generically wrap anything that executes it's own instance in the command line.
In my opinion, [this talk](https://www.youtube.com/watch?v=Il4swGfTOSM) by Google engineers is what finally convinced the industry to move &lt;script&gt; tags out of the &lt;head&gt; once and for all. Long story short, JavaScript blocks rendering, so it makes more sense to put `script`'s at the end. Especially on mobile (the most far-reaching platform by far as of 2016), this is important.
The Infor CRM mobile team uses JSDoc for our [API](http://developer.saleslogix.com/argos/v3.3/index.html#!/api) docs. We are now on ES6, I have Babel set to preserve comments, and our doc tool (JSDuck) runs on the ES5 output. The Closure compiler can type check on them, so you could go all in with them if you really wanted to.
I can see the merits for customer-facing code, I.e. SDKs. But would you do the same for your internal codebases?
I guess that depends on the size of the code base and/or team. API docs are nice for new hires to get familiar and up and running, or even venturing into a different area of the product. Dev managers love to eat this kind of shit up too. So you get brownie points from your manager.
I know what a polyfill is ;)
 var today = new Date(); var dayNumber = today.getDay(); if(dayNumber == 6) { // it's saturday } if(dayNumber == 0) { // it's sunday }
From what we've seen at my work, the problem is that node is doing a lot of "stats" (i.e. does file exist?) to figure out where a node module is - is it in this folder? Nope. Is it in the parent folder? Nope... etc. This is worse than it seems because the module can be just a file or it can be a folder with a package.json in it. If you have 10s of modules in the app, and believe me, you do, then node will do thousands and thousands of those "stats". And it seems that Windows is not as good as Linux in that regard. We built a module that hacks Node's "require" and caches the locations of the module files so that the stats aren't needed the second time it is run, and the startup time went down _significantly_.
Sorry, I'm still very novice so I'm going to pick your brain a bit more! So by p tags you mean this section right? &lt;p id="courseName"&gt;&lt;/p&gt; &lt;p id="courseCode"&gt;&lt;/p&gt; &lt;p id="courseInstructor"&gt;&lt;/p&gt; &lt;p id="credits"&gt;&lt;/p&gt; &lt;p id="roomNumber"&gt;&lt;/p&gt; &lt;p id="timeScheduled"&gt;&lt;/p&gt; I can understand why I would want to generate this code in that function, since I can generate it as many times as I want by calling that function again and again. I'm just not sure how to actually implement it. I added the function you made to my &lt;script&gt; section so it looks like this now. function createNewEntry(props) { var subjectP = document.createElement('p'); subjectP.textContent = props.subject; var section = document.createElement('section'); section.appendChild(subjectP); return section; } What exactly is the (props) variable I'm using to call the function? Better yet, how exactly do I call the function and where? On every button click?
Wow Vantage seems really cool!
I definitely want to learn how to remove saved entries and some data validation! For removing saved entries, would I have to include a button on each entry that when clicked would remove it? I'm not sure how I would un-append specific entries though. For validation, would it just be a simple if statement where it checks if the string is null? My styling is pretty lacking too for sure, I don't even know the depths to which I can style it! The Bootstrap is pretty much the extent of my styling abilities at the moment unfortunately! 
 I've published the demo http://babotech.github.io/react-ingrid/
Wow that's awesome! I could remove courses from the array as well with your method too right?
Sure, just remove one course from the array and call the update function 
@observer will just make sure your components will react to all the data that you are using in your render function. But it will not deliver the data itself in the component. For getting data there every method will suffice, passing complete stores, individual objects, using context, closure variables, global variables, that will all just work fine. It doesn't rely on the props thing it self, its just need to get hands on the store data somehow. So once you have data in your component, you don't need to worry how data get there in the future if stuff changes, that is handled by the @observer decorator. So if for example your parent component passed in data, it doesn't need to do that again if the data changes in the future (similar to @connect)
**This does not work!** Why do people upvote this? It seems A LOT of knowledge about basic workings of asynchronous code are missing in the readership. The state is on the network. You can encapsulate all you want, useless! Your `then` functions will not run immediately in sequence! It is possible for two of your `open()` commands to run in sequence! You share the network connection! Your internal state does not matter, this is **external** to your code. But I already wrote this. Sorry for yelling - not the mistake agitates me, I make plenty of them each time I write a single line of code, but that it gets upvoted. /u/MoTTs_ /u/kwhali 
I take it you haven't checked [my mailbox example](http://codepen.io/anon/pen/jqOpRY?editors=0012) yet :) I'm pretty sure while basic it addresses a solution to the problem you describe. It's emulating async requests via timers, I tried to setup the mailbox test function in a way that would trigger the problems you're talking about and show how it can be prevented :) Didn't realize that I replied to someone else with it at the time.
Awesome, we need it Nico Nico Douga style now :)
Why do you downvote me??? What does YOUR example have to do with the comment I replied to? /u/lilactown's "solution" **does not work**, he seems to not understand what the problem is, it doesn't do *anything* to solve the asynchronous problem. What *you* write - what about it? I'm not concerned with what you write, I have not even looked at it. I didn't respond to *your* comment. You are pinged because you replied in this thread. 
In my own experience it's a good thing to be able to understand what Phaser truly does. Every component that Phaser brings to the table, you should try it yourself. Animation ? Can be done by hand, and pretty easy. Animating sprites ? More challenging, and interesting too! Try an implementation of Box2D for physics. Try implementing the Gamepad API. Try all of those with WebGL instead of a 2D Canvas. Try implementing preloading of assets. Try doing a fast implementation of particles. Once you'll have tried all these things (and a lot of others), you'll virtually know how to do a game without Phaser. Then you can use Phaser because you'll understand (somewhat) how it works and what it does. And you'll have learned PLENTY. Maybe that's not really what you expected as an answer, but I've done my share of HTML5 games before, and to tell you the truth, engines and frameworks have most of the time been a pain in the ass rather than something that helped me. 
Program in language paradigms outside your comfort zone. If you're used to imperative OOP, take a functional language for a spin. I saw my biggest boost when I made a habit of writing automated tests though. 
not one thing, but a list in the order they happened: * lexical scope * closures * function scope &amp;amp; 'this' * the event loop * partial application * composition I should say prototypal inheritance, but after some early dabbling with OO, I just avoided it because pure functions and composition are simpler to work with 
But if you want to receive stores in a similar way as `connect`, this probably solves your issue? https://www.npmjs.com/package/ryan (see below)
I guess this exactly addresses the above [comment](https://www.reddit.com/r/javascript/comments/47omi9/mobx_20_previously_mobservable_has_been_released/d0hob98)? 
Just to be clear. I've not downvoted anyone in this thread, I rarely ever do such. I don't think I've upvoted any responses yet either. The example I linked is about the mailbox issue that you're bringing up, it solves that problem you brought up far as I can tell. I also let lilactown know about it, when I responded to his reply unsure of if he was referring to your mailbox example or just a coincidental example to my own problem, although it doesn't appear a suitable solution for either. As to what I write to you. I've read your large response, and taken time to put together a tailored CodePen about the issue you describe hoping it'd show you something neat about an issue you felt was difficult, or that you'd respond to it in a way that I'd understand the problem better if it did not help. If you read my comment that lead you to ping me, you'd realize there was no need to. If your concerned about downvotes, reflect on your communication skills. Even if your knowledge is superior, or the input/actions of others agitates you, I would advise against conveying that via tone. The comment you've made, comes off as quite disrespectful. You go on about how the network issue is a problem, yet care not for a solution that works or the time I commit to help. The comment of mine that you question was relevant to the sub-topic of the async issue you addressed and were discussing. &gt; But I already wrote this. If you're not interested in what others have to say, why should anyone bother with yours?
Phaser was a great asset when I took a game programming course. I suggest you take a look at the official site and browse around. The get-started section does its job just fine, then there are a lot of intermediate tutorials to follow up, most are user created. Find one that suits your taste and take a look. Lastly, there are so many code examples which will almost always contain the answer to the question that bugs you at the time. Oh, and perhaps the biggest asset once you get somewhat comfortable with Phaser is the searchable documentation chain. There is almost always a logically named object doing pretty much exactly what you assumed there would be something to do. Enjoy! 
That code snippet wouldn't suit inline code block so I used the multi-line code block. I was assuming the post would be read linearly so the context would be understood that I was aware of the common solution, but that it didn't seem appropriate with the problem I was having, **it was there to avoid receiving that as an answer**. I provided at the end of the post the CodePen link, assuming if someone was to skip, they'd see the blue hyperlink and check that out. I didn't put the linked code into the post due to the size, I'd imagine the CodePen syntax highlighting along with Console for a live example would have been better suited and appreciated since describing it in text alone is kind of difficult for me. If you're referring to the mailbox example that's been linked around in the thread, that was in response to another users comment where they brought up a scenario of mailboxes and promises being troublesome. I felt that problem could be avoided without much trouble and put together the CodePen to demonstrate. It was 3am, I mistakenly thought you were the other user responding to me, which is when I put that together to show how I understood getting around the issue. My mistake. In the original post, along with the original CodePen linked at the top with the update, you can see my example reflects what I'm discussing and the problem of state being far down in `make_request()`. It's not the best example code since in this case an external const could probably be used, assume you had to pass state into the function that was near the start of the sequence.
Basically, the API is far more better. Instead of writing fetch('./api/some.json') .then( function(response) { if (response.status !== 200) { console.log('Looks like there was a problem. Status Code: ' + response.status); return; } // Examine the text in the response response.json().then(function(data) { console.log(data); }); } ) .catch(function(err) { console.log('Fetch Error :-S', err); }); you write const client = new Yoyo() const response = await client.get('api/some.json').shouldHaveStatus(200).fetch('json')
It is not exclusive, though. I use TypeScript and generate docs with Typedoc, and as someone pointed out above, it really pays off
&gt;to make it feel faster But be considerably slower depending on how shit your connection is. I love it.
Reading source code. I remember the first time I read through Backbone's and Underscore's source and felt like I learned so much. 
Ah. You're right. I shouldn't have jumped to conclusions sorry about that.
Having someone review my code for every merge request.
Totally agree! I have been working with a mentor for almost 2 years now and my skills increased immensely! 
You are using syntax which is not finalized (async/await, which is not in es7) 
Yes, as I said, I'm using it in example but the code don't use this syntax. You can also ask to get the raw promises. const client = new Yoyo() client.get('api/some.json').fetchRaw() .then((response) =&gt; { // Your code }) 
A blog?
English only, please.
no offense, but these things sort of completely non-descriptive things seem to pop up constantly, it is like click-bait. what is this and why would anyone want/need it? what do you mean "the open source" ?!? just github? or lots of repositories? or??? what do you mean "code search"? Does it integrate with an IDE? Or just dump a bunch of text somewhere, is it a js library? or a mile high stack-o-crap to print text results? 
`s/Your/The`
Question: You say "The need to wrap everything is mostly gone" as I read in other comments, my question is, are you referring to the fact that modern browsers are in tune with js standards? Because correct me if I'm wrong, what if you need to give support to older browsers? your argument still applies? thanks.
[Check out CORS.](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS) Also, a preflight (OPTIONS) request is sent whenever you send a non-standard header. Nothing to see here. But you'ld know that if you googled it ;)
Reliably: you can't. Certainly not permanently or in a cross browser manner. And as a user I would not want you to be able to! This is an arms race - when sites find ways to bypass the blockers to give you pop-under/over content that you don't want, the blockers get more clever &amp; block the new technique and the cycle restarts. There are techniques that work *currently* for at least one browser (anecdotal evidence: I experienced a pop-up yesterday in a fully up-to-date browser) but they may not be cross-browser compatible and anyway the loophole(s) will probably get closed soon enough. It is unfortunate that the few genuine uses for pop-ups are affected by the traps, but there is no way to differentiate these from unscrupulous or otherwise irritating uses and it is a small price to pay. If browsers provided a way for code to say "I have a legitimate use for a pop-up that the user will be happy with" then illegitimate code would use it too which is why the current method is to block first and then ask the user if they want to set an exception for this particular site in future. For the legitimate uses I can think of from the top of my head you have two alternatives: a pop-over (where the new content is in the same window above your other content) or in modern browsers you have the option of using the notifications API (http://caniuse.com/#feat=notifications) if you want to alert the user outside the current tab/window. Pop-under windows are not really a separate entity from pop-ups, so they aren't dealt with separately by blockers. What happens with these is that immediately after the pop-up (otherwise identical to any other) opens focus is passed back to the original window. I don't think there are any legitimate used for pop-unders, though I'm happy to be enlightened if you have one in mind and want to correct me on that!
Yeah I should totally learn a framework that'll be completely irrelevant 1 year from now on. It's already getting blasted by Angular1 &amp; React, aaaaaand Angular2 is on the way. I don't see any reason a developer should learn Ember at the moment. React/Angular1||2 is the smartest option.
Thanks for the replys. I had thought about going the Django route and have been using flask to learn browser javascript. I think the appeal is one language for the full stack. I've always had a hard time switching between languages. I'll follow your advise and just start working on a project adding in frameworks when I feel they are needed. Think I just needed a pep talk.
X-Post referenced from /r/reactjs by /u/zuko_ [Eradicate Runtime Errors in React with Flow](https://www.reddit.com/r/reactjs/comments/48ajlw/eradicate_runtime_errors_in_react_with_flow/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
[This](https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;index=1&amp;list=PL0sgaODow8PRfVkMm-jDzNH5iMWXcH6mi) video really cleared up the asynchronous nature of javascript and the event loop for me.
Considering the poor bastards who have to maintain it when I am gone.
Hi, great questions. 1. CoCycles currently works with code on Github, identifying and classifying functional pieces of code. 2. It is a search engine which allows develoeprs to search by functionality ("is string" / "hash map" / "is mobile") and find open source functions (or classes etc..) to fit their need 3. It also provides usage examples, docs and metadata 4. An IDE plugin will be available in a while 5. You can simply see the full src code, and also copy the relevant part if you wish. In a couple of weeks you will be able to generate an entire functional snippet containing all sub-functions and vars as well. 6. This is the first time you can search (almost) all GH repos for code on the function level, and by describing what you want it to do. Best to look for yourself: www.cocycles.com To get a grasp, u migh want to try "is string"- and get the idea.
Thank you jgarp for your answer!!! I'll do it, for sure. I hope I'm enjoying a lot with this, I want to love it, to relax with code, a thing that it is really complicated sometimes. Thanks again! Like I said to Psykopatik, I'll try to keep you updated ;)
oh never mind, just realized that thats what the getVillainName function does :) Thanks for explaining before!!
Hi /u/JoniSar, this was removed as blogspam. If you want to post a site, link directly to it (http://cocycles.com/), and not some other site that adds zero value to the topic. Thanks.
filing github issues tends to get the best responses. It also helps me to easily find back questions and address them in the docs.
You ignored the original question only to give a totally opinionated albeit irrelevant response. I'm not torn on whether to use es6 or TypeScript. 
now i only need some kfc and my working hours will be perfect
The guidelines don't say anything about whether you should use a variety of sources or not. Edit: also this is his first submission to this subreddit from the domain above. The only other submission he's put on this subreddit was 2 years ago, a self post. https://www.reddit.com/r/javascript/comments/14u499/examples_of_proper_javascript_modularization_on/
to get the idea, try searching for "javascript is string" or "hash map"
It's right from the reddit guidelines.
The purpose of this project is to combine a popular demo application with applied cryptography using good default settings. There are some limitations to the implementation: * only one room * no nicknames * no direct messaging **Also** a lot of the code is about propagating pools of keys among the individual clients. Matching the appropriate private and public keys with the incoming messages could also be handled better. 
I think that's a different problem than what the OP is asking. From what I grokked (he has modified his post multiple times, it looks like), he is trying to avoid using a global variable for, or passing down the entire promise chain, the `SOME_API_INSTANCE`. Doing the requests in sequence or parallel is completely orthogonal.
Yep, I'm taking precautions like that to ensure data isn't persistent but I guess generally speaking, you run into equivalent problems in any password manager (including enterprise ones) that provide a web interface.
ember-concurrency looks very cool. I see this as a progression of where JS has come regarding asynchronous coding styles. First, people were writing nested code. Then people started using callbacks. Then people started using promises. Then people started yielding promises and writing seemingly synchronous code.
Or React or Ember or Vanilla (+jQuery) ? Backbone is fairly dead, last commit was 3 months ago and i haven't seen anyone recommending it for ages.
Event handlers like mousemove as well as requestAnimationFrame fire at a maximum of 60fps. If you want more granular timers, use [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout) or [setInterval](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval).
[Riotjs](http://riotjs.com/)!!! Web components without crap! Its a react replacement that keeps syntaxe in a way that web dev understand on first look. I paired that with Redux for client side cache and data flow, use redux mixin on connected containers to subscribe to stores and Voila! 2016 but maintainable mind blowing project !
I'm well aware of ES6 and most of the proposed ES7 ([bind may be getting a shorthand!](https://babeljs.io/blog/2015/05/14/function-bind)). I think the refactoring is just experience. (just turned 38... been developing since I was 7 or 8. Woo BASIC!) Sometimes you just have to experiment with your code running in a known state and see what you can do to simplify calls. I generally try to do that to help identify duplicated logic or unnecessary passing. I stopped where I did mainly because of time. It takes time and experimentation to figure out what needs to move around. (If you only knew the various iterations I went through!) I don't mind mostly because it's practice for me, but I did have to draw a line. ;) What I like to do is view the code and find those repetitions in pattern. The toggling states still kind of bug me since both are a "update state + wait" and I think that could be extracted as well. (maybe a method that returns a "update state + wait" promise, which from your description of the hardware may be a common pattern) Some of it is just a second pair of eyes on the code. You can get into a groove where you just type something out and don't put much thought into it. That works well enough and I see it every day in code. It's generally not terrible, and it gets things done for the most part but sometimes it's fun (for me) to step back and rework. It's both good for learning and practice. Sometimes the boss doesn't appreciate the time because "the code worked as it was" but you have to weigh that with the benefits. As far as your initial question of passing state, the first thing I thought of was a bind for the config and I found by experimenting that it just worked for the toggles as well since you were passing along the `slice` for those specific operations. The only other piece of data was the `isOn` flag which is easy enough. I originally noticed that these two lines were essentially the same: return Promise.all([ ...update_slice_state(slice_of_objects, {isOn: true}) ]) .then(() =&gt; Promise.all([ ...update_slice_state(slice_of_objects, {isOn: false}) ])) and due to the way promises work, the sequence but taking out the logging really emphasized the similarities. Also, my main objection to the map was this following: function change_state(object, new_state) { return object = {...object, ...new_state}; // &lt; ---- this line! } Removing the `object = ` part doesn't completely breaks things (and in this case it's pretty benign), but it's generally not good practice to modify parameters (especially if you have object reference passing of arrays) because it introduces side effects other than the returned data and can really bite you in the ass. This is where I assumed you had copy/pasted it from somewhere and missed that assignment. Just out of curiosity, what hardware are you using? I got some [espruino picos](http://www.espruino.com/Pico) I'm playing with and they don't support the full subset of JavaScript like I'd wish, but they are still fun enough to putz with.
TechCrunch article: http://techcrunch.com/2016/02/29/mongolab-is-now-mlab/
I would think it will depend on the place to which you're applying and for what position, and also how important it is to them that you have experience in framework X. Couldn't hurt to spend some time doing something like this to learn, though. Gotta start somewhere, right?
Write yourself a bugtracker. It can start out really simple, but you can improve it over an extended period of time. It'll give you other things to do when you're stuck. It'll track your progress, like a programming diary. It's something you'll need to come back to edit after time away building something else, when you've forgotten what everything is and the code might as well be written by someone else.
ClojureScript doesn't have "automatic" particularly. I don't need to do that, but if I did, I'd just wrap the navigation stack in a "cancel whatever is going on" action. Pretty simple. I don't like magic.
Writing html/css/javascript/jquery from scratch? That might take you at least months if not years to come up with even a decent prototype. I'm talking about non-trivial apps with some complexity.
FWIW ember-concurrency leverages both declarative programming (e.g. Task Modifiers declare up front the concurrency constraints) and much of the internals are based off of CSP, but in a manner that exposes the state of whether the internal channels are saturated, not to mention a baked-in cancelation story, which you have to write yourself in Go / core.async.
Sorry, which one specifically? I don't see anything other than the self-promotion guideline, which is unclear in this case if this is self-promotion or not. Also, you linked to the guidelines for this subreddit specifically, maybe you should edit it to the specific subsection you were referring to, instead of a place that didn't include the rule you mentioned.
Whatever works :)
It's a good question and it's complicated so this might be a tiny bit long. But today, many projects are realizing the cost of supporting legacy browsers is too high to be worth it. For example, on my current work project, we support down to IE9. Well, we did. We are dropping IE9 because it's far less than 1% of our clients. The cost to support IE9 is relatively high -- biggest annoyance to me is lack of pushstate support. The flip side is if IE9 didn't support pushstate, how did we support it until now? Well the answer is using clever libraries that push the URL part in IE9 only to be a hash. It isn't ideal but it works. We did that by loading a module that provides backwards compatibility -- in IE9, it does something. In modern browsers, it does not (or passes the calls to pushstate straight through). The issue with using jQuery to wrap all legacy concerns is that if one thing doesn't work right, you need to upgrade all of jQuery to get the fix (that is, if the fix exists). By using modules, you can more carefully pick and chose what exactly you want to use to provide this legacy support. Or you can write your own if your needs aren't addressed and share it. The focus is on fixing a small area not paving over all the browser differences in one library. Whether any of this matters to you or not really depends on how much you view JavaScript/DOM as your target platform. If you're merely enhancing a web page with JavaScript, maybe jQuery does all you need. But if you're writing applications, the flexibility that comes with a modular approach is much better than using a legacy library like jQuery. The other aspect is jQuery wraps over so much of the API that some people don't know how to use vanilla JavaScript. Today, if your browser support doesn't have to go way way back, the most popular browsers are now more compatible. So you can use say Document.createElement without fear. If unsure, a quick check to: http://caniuse.com/#search=createElement Reveals support levels for core APIs. A 3-4 years ago when people on Stack Overflow following and answering the [javascript] tag started calling out people who assumed jQuery was in use, I was surprised. I mean, jQuery is ubiquitous and who are these people to force me to use vanilla JavaScript. But after working with JavaScript without jQuery for many years now, I see they were correct. Using jQuery is not compelling anymore because it simply isn't needed and adds another level of complexity. The final nail in the coffin is that jQuery plugins need to monkey patch global jQuery to function. At least, that is the common pattern. Modules are the opposite of that -- cleanly separated into packages that compartmentalize a specific concern and can be upgraded separately. Some will point out that upgrading modules can be painful and I don't disagree (although I have more opinions there that will make this even longer so I'm going to ignore it). To those people though, I would say there is no silver bullet -- no magic that solves all of their problems. Merely better solutions.
Absolutely not. If ES5 is working for you then there's no reason to adopt ES6 features just for the sake of using ES6 features. Now, if you're already working in Node 4+, then you could probably start sprinkling in some of the stuff that's available, just be aware of what you're doing.
Good article. Minor correction: Haskell Curry didn't invent the language Haskell, it was just named after him. 
Sorry on re-reading my post, it probably isn't fair on you guys. It sounds like a massive dumping on Ember, but that wasn't my intention at all. We had different requirements than Ember was a good fit for. I've spent the last 2 years building our app first in Ember, then rebuilding it in ClojureScript, and now I'm in process rearchitecting it entirely (backend as well) - in Haskell. Ember was too *opinionated* for my liking, which really is just a personal preference thing. I wanted more and different control and didn't like having the framework do stuff for me. So, Reagent was a much better fit (it's a small clojurescript wrapper over ReactJS). I built my own mini-framework in that that suited our need more better. Not to detract anything from Ember.
Does anyone know why npm install takes like half a minute even if I've set exact versions in package.json and I have all packages installed?
What version are you on? Try upgrading to the latest version. It may possibly be subdependencies and deduping
no
Why make a git repo for one image?
Looks like the repo has the editable dot file that generated the image.
if you are choosing a framework based on what's popular today, you are missing out on the best ideas.
Not everyone buys into the Typescript hype.
I think the ideas in ember-concurrency are readily portable to react and other frameworks. This post really isn't about Ember, but about ember-concurrency.
This doesn't sound very scalable. Cool implementation though.
Same could be said for: windows, fedora, apple, pivotal, (this list goes on forever...)
Let me first say that I don't think we should make this into an either/or situation. A strictly OO-only approach, or a strictly functional-only approach, will almost certainly cause problems at some point. I think it's better to use a combination of styles to find the best solution. So why use functional? For now I'll limit this answer to just one widely accepted part: pure functions. That is, avoid using non-locals (such as globals), and avoid side-effects (such as spooky action at a distance). In fact, this has been a best practice long before this recent functional hype. It can be summed up as `assert(f(x) === f(x))`. So, for example: var n = 42; var o = { x: "Hello, World!" }; f(o); assert(n === 42); assert(o.x === "Hello, World!"); Can I be confident that `n` is still 42? That `o.x` is still "Hello, World!"? If I can't be confident of that, then a large program written this way may become hard to understand and hard to maintain. function bad_f(o) { // Bad: accesses non-local // Worse: mutates non-local // Bad: mutates argument o.x = n++; } function good_f(o, n) { // Good: receives dependencies as parameters; uses only locals // Good: makes new object with new value rather than mutating existing one return { x: n }; } That being said, **I think** it's possible to overdo it. Sometimes mutating state seems like the absolute right thing to do. "When you fire the machine gun at the alien, most people do not mentally model that as the construction of a new alien with fewer hit points; they model that as a mutation of an existing alien's properties." I'm inclined to say we should **favor** pure functions. That is, try to write each function that way first and see if it makes sense. If it does, awesome. But if it doesn't, if the most elegant solution means you need to mutate something, don't feel like you're breaking a religious commandment. And, of course, like I said this is just one part of functional programming. An awful lot of the rest either seems a lot less useful or it's behind a nearly impenetrable wall of jargon.
I`m wrestling now with a sudoku solver-generator.
That's the idea behind Structured Concurrency, which models a vast majority of UI use cases, but certainly there are use cases where a child process should outlive the parent.
State of the (pop) Art, however I mostly agree.
I set out to demonstrate that your jsperf example is true only to JavaScript, at least insofar as this discussion goes. That means, any sufficiently capable compiler can produce efficient code regardless of the higher-level abstractions (FP, OOP) used in the compiled language. My demonstration targets were F# and C# - both .NET CLR languages; F# is focused on functional programming, and C# is focused on object-oriented programming. You can do both is either, to some extents, which I believe is actually the right way to handle the "FP vs. OOP" debate. You get the best of both worlds. Anyway, onto the point. I was surprised to learn that Microsoft's compilers actually produce less efficient code for C#; I expected both applications to produce equivalent code. You can find both my F# and C# examples in this [gist](https://gist.github.com/aholmes/cff5800d07b5aec573c7). They more-or-less resemble your jsperf. I was perplexed why the numbers were different (each test was about 1s slower in C#), so I took a look at the Common Intermediate Language from each application as well. I'm not an expect on CIL, but I was able to determine that the compiled C# code is executing 3 more instructions than the F# code and is creating a local variable to store that value, *and* is creating a branching statement. Use this [reference](https://en.wikipedia.org/wiki/List_of_CIL_instructions) for IL instructions. Code comments are my own Here's the F# IL for `add(x, y)` .method public static int32 'add' ( int32 x, int32 y ) cil managed { .maxstack 8 IL_0000: nop IL_0001: ldarg.0 // load x onto the stack IL_0002: ldarg.1 // load y onto the stack IL_0003: add // add x and y IL_0004: ret // return the result } Pretty simple. Here's the same IL from C#. .method private hidebysig static int32 'add' ( int32 x, int32 y ) cil managed { .maxstack 2 .locals init ( [0] int32 // creates a local int ) IL_0000: nop IL_0001: ldarg.0 // load x onto the stack IL_0002: ldarg.1 // load y onto the stack IL_0003: add // add x and y IL_0004: stloc.0 // pop the stack and store the value (x + y) in the local int created above IL_0005: br.s IL_0007 // branch to the next instruction IL_0007: ldloc.0 // push the value of the int created above onto the stack IL_0008: ret // return the result } Perhaps there are some guarantees that FP can provide that allow the compiler to avoid the pop/store/branch/load that OOP can't, but I'm doubtful. More than likely this is related to compiling the code with debug symbols or without optimizations. Either way, I'm curious now and will probably ask on Stackoverflow. ------ Edit Did some quick searching and found this [explanation](http://stackoverflow.com/questions/880021/can-someone-explain-these-few-lines-of-msil) on Stackoverflow. In short, the C#-generated code was because it was compiled for debugging. There are some other interesting tidbits in the accepted answer too. Having recompiled for release, the C# CIL now looks like this (the same as F#'s), and the speed is the same as F#. .method private hidebysig static int32 'add' ( int32 x, int32 y ) cil managed { .maxstack 8 IL_0000: ldarg.0 IL_0001: ldarg.1 IL_0002: add IL_0003: ret }
is that so? I didnt know that. thanks! apparently I also got functors wrong too ;)
yeah I really should keep away from sarcasm. In the past I seriously considered creating business cards saying, "writes highly coupled spaghetti code, sure to exceed any call stack"
Well, I outlines this stuff in the article. (1) bound congnitive load. @MoTTs_ reiterated that by showing how it can be hard to reason about the value of an object if it can be mutated. (2) performance -- if you're using Haskell, you're going to get an insane amount of performance from the compiler due to lazy evaluation and being able to statically analyze and optimize the entire program. It will be impossible to get the program into an undefined state. (3) I tried to show you how, stylistically, function composition can result in better, more understandable code, rather than inheritance and interfaces with the greeter function. Of course there is an idiomatic OOP way of solving it especially if you knew the entire requirement from the beginner. But my point was really to show you how changing requirements can lead to incremental changes that build technical debt. And when you take an OOP approach, things get out of hand quickly. But when you use function composition, its a lot easier to change your code to meet new requirements that don't involve hacks.
Not really, these days jquery doesn't add a whole lot other than convenience if you're already familiar with the api. 
We are not talking about jQuery specifically, but high-level abstraction frameworks like Angular, Backbone and ReactJS. There is a reason a lot of people start with these frameworks rather than pure JavaScript. However, their mind-blowing usefulness compared to high level frameworks in backend world (like Django, Symfony, etc.) is not something I'm so sure about!
JavaScript (or V8 specifically) has gotten a lot of coverage for how it walks the prototype chain. Ruby, Python, PHP, etc, have received zero-to-no coverage, and they don't operate through prototypal inheritance, so the precise way they operate must be different. That said, I'm certain there is runtime (versus startup) execution to determine what code is inherited. Do you know of any write ups regarding how other languages handle it?
cool concept
The leading zeros with reversed granularity allow for ascii sorting the numbers. 
Sounds alot like .Net's Task API on which its async/await keywords are based. Would be great to have a JS equivalent.
Correct. Angular is a double-edged sword, it feels like a cool breeze until the point when something goes wrong and you hit a bug. You are not getting an output where expected, or a data grid is not displaying a row value properly, and you hit the great wall! Its a very simple thing, but since you were hidden behind the angular abstraction all the time, you can't do anything other than desperately hunt the zillions of stackOverflow answers and hoping that you find the one you need. Digging into the spaghetti code of Angular is just not an option, its so convoluted! Angular is a good toy, but I'm yet to see any major big website implement it. The real world is still using backbone! **edit** There is also the problem of *Angularizing* a component. If you are not using angular, using an external javascript charting library or calendar library is just a matter of adding a `&lt;script&gt;` tag and calling `$(foo).calendar();` function. But with angular, you keep scratching your head and keep thinking, "How can I *angularify* this stupid thing?". Because you have crippled yourself in this watertight MVC paradigm, there is just no way out!
For ruby, one of the early chapters of Metaprogramming Ruby, maybe the first, does a great job of going through inheritance from the compilers perspective. Much of the technical documentation of ruby is unfortunately in Japanese first, but that book is a gem. I don't know of other pieces on other languages that really go into it that well
Let me get this straight, you presented your idea/opinion on how to solve the situation, and they fired you for it?
Your title is poor, the reason you were fired wasn't because of your opinions but rather how you presented them
Venting
Check out [simple-xdm](https://www.npmjs.com/package/simple-xdm) for cross frame communication.
&gt; tacked Tact
20160229T200600 Capital "T" can seperate date from time.
This is why I use moment.js wherever possible.
That and the performance of angular, from what I've seen far, is horrific. 
Why? That's stupid. Either use Date.now() or new Date().getTime(). Implicit your casting is slow and stupid to rely upon.
So maybe a better title would've been along the lines of "Being antagonistic towards superiors at a new job; Spolier alert, don't be" or "Being unable to communicate technical concerns unemotionally; Spoiler alert don't be" IMO you have to be at least somewhat opinionated to be a good JS dev; with the sheer number of frameworks/libraries/build tools out there you can't be skilled with all of them.
I think it's good to be aware of functional programming because it can offer you a direct counter point to OOP orthodoxy and allow you to evaluate the best choice that will work for the problem set that you're solving. And as you said, they needn't be considered either/or. Promises represent functors and monads, yet have a very recognizable OOP-ish interface. One could understand prototypical inheritance as a way to mimic classical inheritance ... or a way to implement type classes. Things like this make javascript pretty awful at being haskell or java, but quite good at being a pragmatist, somewhere in the middle. 
Well that's a good life lesson then :-D
I'm a bit more open minded today I think. Seems your right. For most things this could be useful
Which browser doesn't parse ISO 8601 correctly?
Read the docs, look at examples. The API is pretty small. [&lt;Link&gt;](https://github.com/reactjs/react-router/blob/master/docs/API.md#link) [Other examples](https://github.com/reactjs/react-router/tree/master/examples)
Checkout /r/learnprogramming and /r/dailyprogrammer
Breaks on mobile currently :(
Is... Is that a back tick? How'd you manage that?
Can you elaborate? From what I know of current web development best practices he seems to be spot on. I'd love to read why you disagree and hear your arguments for what he should have suggested instead. 
Hope you get back on your feet. Next time just try to implement the changes slowly as you complete the tasks. People will learn to respect or hate your code depending on how right you are.
There are so many things wrong with this picture that it could be easily posted to /r/programmerhumor
Added an eCommerce section (static site stores ftw)
I am choosing a framework based on what I think lands me a good job today, and will still land me a good job 2 years from now. This is all opinion.
[A handy guide](http://dygraphs.com/date-formats.html) to various browsers' Date parsing quirks.
TODO! It must be a TODO list :D
[Welcome to your one-stop shop for cross-browser JavaScript Date parsing behavior!](http://dygraphs.com/date-formats.html) edit: oof, /u/rjw57 beat me to it below!
I'll have to check this out tomorrow
Oh you mean two things the article you linked doesn't mention at all? I don't see how that's relevant.
Welcome to 90's JavaScript, that comment is to hide the content of the script from browser that don't understand the script element, otherwise the page will render your script in the page, the innerHTML thing was pretty common as innerHTML was much faster than using the DOM, have you also notice the inline onclick handler? 
Mmh, didn't know that and yeah, I can see that inline onclick
[removed]
This is standard Angular practice designed to be safe for compilation. If you want your code compiled and minified, the names of the parameters will likely also be minified, thus preventing Angular from knowing which services to inject. For example, this: ``` calculator.controller('calculatorController', function( $scope, $http, $location) { /* logic here */ }); ``` could easily be turned into something like this: ``` x.a('calculatorController',function(Rv,Rw,Tx){/* logic here */}); ``` by a minifier, thus making it impossible to introspect what services you want dependency injected. Declaring them as separate string params prevents that data from being lost, leading to something like: ``` x.a('calculatorController',['$scope','$http','$location',function(Rv,Rw,Tx){/* logic here */}]); ``` which is still usable by Angular. [This section in the docs](https://docs.angularjs.org/guide/di#dependency-annotation) should help you understand it better.
[removed]
Great thanks! I didn't know that e-commerce tools! 
Of course, of course https://www.planet-source-code.com/vb/2010Redesign/images/LangugeHomePages/Javascript.png
[removed]
This infograph is quite old. The copyright message is from 2012. I knew something was up when they mentioned CoffeeScript as it is not really relevant in the year 2016. 
Probably some guy with heavy investment in Angular
That's really quite good
This just reminds me of Adobe's logos. 
this is cool! thank you so much. Will apply it soon.
sure, cheers.
Have a look at PHPStorm *et al*'s new logos too.
Why would you care that it's compact?
Yep, that's the official one I think.
The image would probably be supplied by the course creator, which for that particular course is PacktPub.com. It doesn't seem to be a part of the actual course though, so it was probably just whoever uploaded it to udemy. Edit: Found the [source](http://www.shutterstock.com/pic-148972376/stock-photo-program-code-on-a-monitor.html?src=Fe8qMWEWULIcmwjibQkQiA-1-21), and wait - there's [more!](http://www.shutterstock.com/pic-158882201/stock-photo-program-code-on-a-monitor.html?src=pp-same_artist-148972376-Fe8qMWEWULIcmwjibQkQiA-5&amp;ws=1)
JavaScript typo ahahahaah
&gt; Currently waiting on a call back i understood that one :D 
`.innerHTML` was later; 2000's stuff, became common with IE6 and others added that to be compatible with the majority(?) of web pages, which were written for IE in those time. 1990's things were basically highlighted `img.src` swapping with `onmouseover` / `onmouseout="imgswap(...)"`, `document.write();` as well as `document.forms[form][field]`. My guess is the screenshot is from some stock image collection with some back-then-valid-ish-js, maybe captured from the source of a random web page.
That was my hilarious subconscious, because I definitely didn't mean it. :) 
Also, has anyone noticed the `&lt;script&gt;` tag after the `&lt;/body&gt;` tag?
Sorry, I misread the exact title of the topic. However, you did an awesome work, thanks for sharing!
LAMP Existed before node 
Sweet, will do. Much obliged
I guess their target market wouldn't know if it's wrong or not.
Also: The description is capitalized, which is just utterly completely wrong. Even if it were to be considered as a title, it is still wrong.
- Usage of `&lt;table&gt;` for layout - Iterating elements by id forgery instead of class
[These guys](http://www.scmagazine.com/feedly-fixes-android-javascript-code-injection-flaw-deems-it-harmless/article/343570/) are using the same graphic. 
Must be the same people that spam me on Linked In about java jobs I'd be perfect for since I listed javascript as a skill.
Careful there Rick. edit: Not that I worry about karma but I do try not to be a dick. Just trying to do a funny meta thing. Here is the [reference](http://www.reddit.com/r/rickandmorty/comments/3j4vwi/much_obliged_contradiction/)
`callback()`
Hi a few questions before i can give you some better feedback. Will the popup areas appear at the same place everytime? or will they be pinned to the image they are changing? You need to hook up the show popup function to the Hover or Click events of the Fridges.
&gt; ck Hey! Popup will appear at the same place. Inside this popup you will have a different type of fridges to choose from. "The magic" should happen when you click on particular fridge. Than image of this fridge will replace the default one on the kitchen image.
Actually, there isn't an "official" one, but that is the closest thing. 
frontendmasters.com
No love for Hoodie ?
Don't get into rxJs just for the sake of it. Its entirely overkill for most if not all client side situations. What RxJs is actually map/reduce nosql people bringing their pattern to the event system. Convert event into stream so you now have Stream arrays you can run incremental map/reduce from. Elegance here is questionable since even if you have the most efficient map/reduce you'll lock your code away from anybody who isn't used to it. Which is most people. That being said, streams are a beautiful pattern indeed but i'd suggest you start playing with nosql and learn to think in map/reduce with either couchDb/PouchDb or one of your choice. After a few weeks you'll see data as a continuous incremental directional flow and will be able to build yourself such an architecture. RxJS alone as shown in example receiving DOM event is really just a way to listen to events. It does not solve anything else like how to connect your store to containers etc. Don't be un a hurry to implement anything with it, keep an eye out for functional patterns, make some try but i'd suggest not using it in production until you have a clear grasp of map/reduce/filter way of building data. 
I work in adtech. Ads are usually created by marketing or a third party. You should not shy away from Udemy because someone in marketing doesn't understand the difference between Java and Javascript.
Well I get the map/reduce/filter thing. And I should clarify, I am building a command line script with node ( Im parsing all the product data from an old asp.net site ). But that gives me 500 async requests. I need to do some additional maps and filters over the JSON that gets built by my scraper. If I define an observable and wrap my scraper with can I just map over it after even if the data hasn't all come back yet? I need to be able to run some code once all the network requests are done as well beacuse I need to write a csv file.
You promise?
I'm not super up to date with the React world, but it seems like you're going about this in an odd way. Are you using React Router? Also, I would say it's a bad idea to store a React component class in your state. Your components are based off of your state, your state should just be state. Edit: added a word
thx!
Some random on the internet proclaiming "The clear winner right now, is React." demonstrates that they have a clear bias. "State of the Art Javascript in 2016" should be titled "My opinionated blog post about Javascript in 2016". It's absurd to claim anything is a "clear winner" right now, or ever, in an ecosystem as diverse as javascript. Everything else in the article is pure opinion, and it's not really useful unless you support the author's confirmation bias. Webpack, eh, it gets stuff done but so does Gulp. Just because it's newer doesn't mean it's better. Babel is transpiling and I'm not a fan of transpiling code - ES6 will be ready and fully supported soon enough, and ES5 is getting the job done. I have no need to fall over myself for "new and shiny" when I'm getting shit done without it. "Redux is also a clear winner here." - more opinionated drivel. While all the tools the author describes are useful to himself, there is no reason to declare this is the only source of truth for "state of the art javascript in 2016". Saying that is like saying he's the king of Javascript. It's just stupid.
Not sure what you're after... just some advice on how to get started? You already have divs sectioning out the... sections. Put background images in them. Create a modal div with choices... could do one for each category of appliance or whatever... hide it with opacity or visibility or display. Add an event listener that fires when an appliance is clicked. It unhides the modal. Put event listeners on the modal options. The listeners will fire handlers that update the background images of the divs when clicked. Is that what you're looking for?
Perhaps the most important things to start out learning is how JavaScript differs from Java, because their syntax appears fairly similar. Here are some quick things to get you started: * Learn scope. Scope is not related to inheritance or references and is perhaps the biggest difference between the two languages. Nested scopes allow an implicit public/private, because JavaScript does not have explicit public/private * If you understand scope then learning closure is a 2 minute conversation. * Inheritance is optional. You have to choose to use it. (Life gets easier when you realize you are free to choose to not use it). * There is only one numeric type. * Classes are a new convention and they aren't true classes in the Java sense. * Synchronous/Asynchronous executions. Typically if you call an API that leaves the language to do something the thing it does is asynchronous: timers, events, network requests, and so forth. * You will also want to learn the APIs: dom, queryselectors, Node api (I use the file system API all the damn time), web (browser) api, and probably others. The two most common mistakes experienced newbs make is to think they can fake till they make it, because they can. You can absolutely get hired like that and get paid.... but you will always be a shitty developer and everybody knows it. Imposter syndrome is a big deal among JS developers, because most of them absolutely fucking suck. Seriously don't cheat yourself on learning the APIs (this is really simple shit) and learning the very basics of how the language works. If you get those down plus two years of experience doing this kind of work you will be a stronger developer than most (far more experienced) JS devs (sad).
This is going to fail for the same reason ``` function() { return throw new Error() } ``` will fail. You can't return a throw statement. What would it mean to return a throw statement? throw interrupts the control flow, so the function would not return anything. My recommendation is `() =&gt; { throw new Error() }` instead.
v8 source in ./src/builtins.cc // If the formal parameters include an unbalanced block comment, the // function must be rejected. Since JavaScript does not allow nested // comments we can include a trailing block comment to catch this. builder.AppendCString("\n/**/"); edit: https://chromium.googlesource.com/v8/v8/+/refs/heads/5.1.9/src/builtins.cc#3515
Might be worth looking into select2 if you want to clean up large select boxes
Yep! Especially seeing as it's inside a closure. Basically, it's shit code.
I dont understand what var isMinorLookup={}; for (var i=0; i&lt;minor.length; i++) { isMinorLookup[minor[i]] = true; } does.. Also, if (i &amp;&amp; isMinorLookup[minorWord]) { //if isMinorLookup[minorWord]=true but what is -if i- doing ?
&gt; Non-monospaced font I use non-monospaced font in Visual Studio, and find your comment offensive. /s But seriously, though, I use a plugin for something called “elastic tabstops”.
What next? A C++ course with a musical note as a logo?
good catch, I wonder if `() =&gt; do { throw new Error('should this work?') }` works
Dont
i could yes, but i am looking for a more elegant solution... i do not want my code to depend on webpack specific features. The day i get rid of webpack- i do not want to change my code to make it work
I don't see how it's any different from adopting React or backbone? In fact it doesn't really make you do anything different in terms of your code. You'll still have the same codebase regardless.
why is that bad? is it because we can't guarantee those particular calls will synchronously execute, in relation to other possible calls going on in that page?
Calendar with vanilla, was one of first stuff I did myself too. It's really easy, and result is awesome. What else you need while still learning?
`page` is defined inside the onclick handler string, right before updatePage is called.
That logo looks like it was very poorly photoshopped in.. 
Only comments and the end tag for the html element are allowed after the end tag for the body. Browsers may perform error recovery, but you should never depend on that. IE doesn't allow this anymore and will ignore such scripts. Firefox and Chrome still tolerate them, but there are chances that some day they will drop this as non-standard.
`() =&gt; /* any code */` is same as `function () {return null;} You might want to wrap it in `{ }` as /u/btdiehr mentioned. To answer /u/mkmoshe's question - that would be syntax(or type?) error.
I think do in JS is only used for do... while loops - that code certainly doesn't work in Chrome.
Here's some more `Date` fun: &gt; new Date(2016, 03, 01) Fri Apr 01 2016 00:00:00 GMT-0500 (Central Daylight Time) Yup, the `Date(year, month, day)` constructor one-indexes the year and day but zero-indexes the month.
What do you rec for learning functional programming principals? A lot of the haskell resources/books I've seen seem to jump more deeply into it than other languages do, do you think that's right? Even in this article, there are a few 'oh in haskell it's done like this' points.
I'm well aware, a real tragedy. The library uses a polyfill on browsers that do not have Object.observe. I plan on implementing Proxy functionality in the future.
I haven't used either, but it seems like everyone else prefers react over angular. I would love your arguments for why angular (1 or 2?) is superior to react. 
Unless perf is a concern. Moment is slow af. And all of its date manipulation is mutative, which is a major source of bugs if someone on your team doesn't expect it.
ah your right! Wasn't expecting it there heh.
I think you missed the point xD
I actually changed my code a little and it works too: function titleCase(title, minorWords) { var newTitle=title.split(" "); if (arguments[1]){ var minor=minorWords.toLowerCase().split(" "); } var word=[]; for (var i=0; i&lt;newTitle.length; i++) { word.push(newTitle[i][0].toUpperCase() + newTitle[i].substring(1).toLowerCase()); } for (var k = 1; k &lt; word.length; k++) { if (arguments[1]) { for (var j=0; j&lt;minor.length; j++) { if (word[k].toLowerCase()===minor[j]) { word[k]=minor[j]; } } } } return word.join(" "); } Just for the last possibility it doesn't work- if its titleCase('');
There are as many ways to organize code as there are projects. Similar to how we talk about "progressive enhancement" when it comes to websites, we should also think about *"progressive design"*. Our design patterns should match the application, not vice versa. For myself, I've been using Model-View-Intent in a lot of my newer projects. But I'm pretty committed to exploring all [unidrectional architectures](http://staltz.com/unidirectional-user-interface-architectures.html), which is the current buzzword that encapsulates most of the latest trends in front-end development (Flux, Redux, Functional Reactive Programming, Channels). ES6 has brought with it a slew of tools (module support being the big one, IMO) that allow us to better organize our code in a variety of ways. The days of global jQuery plugins should hopefully be behind us. There will always be never-ending development in the design pattern space, though.
"superiority" is not something I mentioned. If you want "superiority" in an answer from me, you're asking the wrong person. Angular 1.x is stable. React is not, it's still changing. The problems with Angular 1.x are well understood, and only people misusing data binding run into problems, the same can be said for any complex framework. Angular does many things, React does not. Angular provides a consistent workflow across many different organizations, so the knowledge you gain in Angular is transferable, React not so much. JSX is a ham-handed approach, and a poster child for "just because you can, doesn't mean you should" - the industry has already waged a war on separation of concerns and JSX throws that out the window and goes towards an "anything goes" approach. That decision alone is reason enough to be wary of React. It was created by a programming noob, so it's no wonder this happened the way it did. I could go on but I doubt you'll ever be satisfied with my replies. 
do expressions are a stage 0 proposal: http://wiki.ecmascript.org/doku.php?id=strawman:do_expressions
Nice! I like this `if (arguments[1])` for checking to see if anything was passed to `minorWords`. &gt; Just for the last possibility it doesn't work- if its titleCase(''); What's it supposed to return in that case?
I remember have asked me this question before many years back. And I think before and know always the answer has been there is no answer. When writing software the most important things are know how components messages each other, how the project is structured and how testable are your components. So for me has been a journey of learning what things work and what not and for me right now React with Redux makes sense. For several reasons. - Components are very testable with React classes. - I like the way in Redux information travels one way. From models (stores) to views. - And each component has a folder that contains its tests, stylesheets, views, actions, reducers, etc. And use BabelJS just for the syntax sugar because anything that I use from ES6 are things that I could do before but I can make them now in a more clean way.
A couple of points: * it's unlikely this is from Udemy's development team * it is likely from the marketing department, which likely paid for a graphic from a photo site. The marketing department would not (and can't be expected) to know that this code is 90's-00's era code. Additionally, this is an ad, and may have been outsourced to a 3rd party that was not Udemy. * relax. There is old code floating out there...even more prevalent is pseudo technical images of code that strives to evoke Hackers or the Matrix
Boxes with two letters are now logos.
Its suppose to return just "" I tried to say: if (arguments.length===1 &amp;&amp; arguments[0]==="") { return ""; } but then Im not sure if I have to do an else statement for the case that arguments[0] is not "" and if so not sure where to include that..
Just hideously unstructured.
I'm definitely in agreement with you for the most part here. When I first started using Angular, I fell into the same anti-patterns as most people do: fat templates and controllers, heavy use of ng-controller and ng-include, $scope soup... I moved over to React for my main pet projects and really enjoyed how it made me think about my application structure and data flow. Flash forward to this month--I had a coding challenge for an interview which was basically write a full-stack CRUD app with Angular. React had changed my approach to program structure to be more component-based, so I was wanting to do something similar in Angular. Turns out you can do the exact same thing in Angular these days (especially post-1.5 with .component). It provided the same structure and explicit component dependencies. All without having to bring in 20 different competing libraries. Lesson learned: poor design structure will make you dislike any framework regardless. How do you compare JSX mixing of concerns with Angular directives directly in HTML? Isn't all the same side of the coin, just a slightly different flavor?
Yeah true, but then Angular makes it kinda okay by balancing that with an incredibly steeply curved, complicated structure behind it ;) Genuinely though, the `ng-click` pattern of Angular is a design decision that I've never really understood. Just like React's inline templating...
"Are you a marketing professional with zero technical qualifications, zero familiarity with programming technologies, and don't give a fuck about attention to detail or accuracy? If so, we have a job waiting for you!"
Interesting... Thanks for these explanations! So as concise as possible: a functor is a container with a .map so you can open up the container, change the value and close the container; a monad is a container with a .bind that you can construct with values in them; a monoid is a type that has associativity and identity such as numbers (adding, subtracting, zero) and lists (concatenating, empty list). Is that more or less correct? Whats a functor that isn't a monad though?
!= instead of !==
I'd highly recommend watching all the videos for [this free online class](https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0). I learned a lot of the deeper concepts through these videos. If you really want to understand functional programming, you need to understand haskell. I don't program in haskell, but I can read it and see whats going on. In the class I mentioned, they don't even use haskell, but a mathematical syntax thats basically haskell. Haskell is functional programming and where all this stuff comes from. Its pure math and its glorious. But its hard to wrap your head around sometimes because you need to fundamentally understand whats going on for the abstractions to make sense. My point is, watch that class, embrace haskell, and then use those patterns and that way of thinking everywhere else. If you want to lean functional programming, theres no way around haskell.
For the most part, ES6 didn't introduce module tooling. There are some (rollup comes to mind), but we've had CommonJS and AMD bundlers for ages. This is true for most of ES6, actually. Not a lot of what it adds is actually new, but it's useful, standardized sugar. I doubt using ES6 would change how you organize your code much overall if you were using any kind of module builder before it. 
Furthermore, `do` expressions cannot be used as expression-statements, much as function expressions cannot be used as expression-statements (however, I imagine wrapping it all in parens will work just fine.
You're close: `() =&gt; expr` is equivalent to `function () {return expr;}` except for how `this` and `arguments` are resolved.
Well, the "best practices" are going to change from library and framework. I know a lot of best practices for angular, for example ... pretty much none of them are applicable to react. Similarly, the structure is going to be quite different. If you want to learn JS, I'd advise writing the same simple application in three different ways: one with popular framework A, one with popular framework B, and one without one at all ("Vanilla JS"). The libraries and tools will come and go quickly, but the patterns and lessons you can learn from them are much more resilient. Also, I'd avoid anyone who tries to tell you what the "correct" way to write JS is. The JS community has a lot of quite opinionated people, and usually there's an axe to grind or a book to sell that you just don't need to bother with. However, that doesn't stop you from adopting a [style guide](https://github.com/airbnb/javascript) to make sure your code is consistent.
So sorry! Will look into fixing!
For some end-to-end application stuff, check this series out: https://www.youtube.com/watch?v=h_tkIpwbsxY&amp;list=PLK_hdtAJ4KqX0JOs_KMAmUNTNMRYhWEaC&amp;index=1
 if (title.indexOf("java") === 0) { return "Good enough"; }
its click event its based on the orginal source code from this duckhunt js game https://github.com/MattSurabian/DuckHunt-JS
"Few" paragraphs? You could write a book on the differences... haha
That's nice of them, ensuring that people stupid enough to put in unbalanced block comments won't hurt themselves; I wonder whether other engines do it, whether it's an ambiguity or an explicit permission in the spec.
I had 3 of them :) First explaining that these two are different languages. Second about origins of JS name, and why it's so similar to Java. And last one showcasing some unofficial JS logos which would work better than image that was chosen by them. 
Check the css. Safari doesn't like to trigger click events for dom elements that are not standard 'clickables' (a, button, etc) and don't have `cursor: pointer`.
Ha I can't believe I missed this — it makes perfect sense now. Good call.
depending on what they are, they could take forever and block the UI on click.
can you call something along the lines of: e.attribute('alt')? i don't think you can rely on e._layers.59._latlng.alt
Your question is answered in entirety in the excellent free book, [mostly adequate guide](https://drboolean.gitbooks.io/mostly-adequate-guide/content/) to functional programming, written in JS. Side effects should not be dreaded, they are what they are: side effects. If they were inherently bad, they would be call terror effects, or side damage or something. The idea in FP is to contain side effects.. tame them even. // angry side effects! function somethingAsync (url) { ajax(url).then(data =&gt; document.write(data)) } somethingAsync('lolz') // a bit more tame function somethingAsync (url) { return cb =&gt; ajax(url).then(cb) } var fetchLolz = somethingAsync('lolz') fetchLolz(data =&gt; document.write(data)) Actually that wasn't a great example, but at least I've turned my `somethingAsync` into a pure function which returns a function that causes a side effect. It's useful to think like this! If you want to see this stuff in action check out some code written in cycle js. It has a super clear separation between purity and side effects. Actually first read that book--you won't regret it!
Rather than saying "how do I go 100% functional" it might be better to look at how you can go as functional as possible while not making things too hard for yourself. One of the key takeaways I have is that I try to reduce the amount of state, reduce the amount of side-effects, and utilise things like composition. I try to make my code as lean as possible, while maintaining legibility. I try to remove state where I can (within reason) and use as narrow a scope as I can. Most functions are pure, besides a few that may interact with the interface. With regards to state, I really like the ideas of redux and cyclejs but in my day to day work that's not useful. I tend to work on smaller components that affect parts of websites, so there is no 'Centralized state model'. There is however a scoped piece of script that consists mainly of pure functions with few side effects, hopefully with very legible code and logic that isn't too hard to follow. I wish I had more for you, but I feel like the way JS is used with handling and representing state it will never be 100% pure. That's fine. Just get the best out of FP and make your code as reliable and reusable as possible in doing so.
Interesting. Are they implemented yet?
Direct link: https://codesi.nz/serializing-object-methods-with-ES6-template-strings-and-eval/
Looked really cool until I read this: &gt; XAML compilation currently must be done on Windows 8.1 or later. However, Visual Studio is not a requirement. You can compile your XAML from a command prompt by running markupcompiler.exe from the plugin’s markupcompiler subfolder then manually copying the .xbf files to the www\xbf folder. You can then add these to source control so you can do the rest of your development on a Mac. wtf Microsoft? The company I work at has more Linux and Mac users than Windows users. Actually we only have a single Windows user our Windows Phone developer. I would imagine that this is the case for most development shops that specialize in App development. It feels like a really stupid move to release a tool for cross platform development that you can only use on Windows. Stuff like this is really counterproductive for the whole "open" Javascript community movement (as far as I have seen the compiler is even closed source). There is absolutely no reason this compiler shouldn't be written in Javascript so it can run on any platform. /rant
Is your mouse plugged in?
From your title I was going to say requireJS/AMD - but I see you were asking something else. 
Udemy is the worst. 
It really, really depends on the goal, size, framework, etc. of the project. I know generally for MVC (speaking for Angular here), our best practice is to organize your "pages"/"features" into components. The example directory I'm going to use is for a simple Angular app. It probably won't address exactly what you want, but hopefully will give you an idea or point you in the right direction. ---- So let's say you have an application for a vet's office with pages that list dog patients and cat patients. Each of those pages has HTML, a JS file as the controller (remember, Angular here--this could be any JS type file) and maybe a service. We would structure our app like: ("root"-type directories are in bold and all directories are followed by "/" if that's not obvious) * **app/** * **assets/** * img/ * css/ * js/ * lib/ * bootstrap/ * angular/ * **shared/** * header/ * header.html * header.js * modal/ * modalDirective.js * **components/** * dogs/ * dogs.html * dogs.js * dogsService.js * cats/ * cats.html * cats.js * catsService.js I know this is an Angular app and maybe not what you're looking for, but perhaps it'll give you some idea of how most developers organize their web apps. The idea (in most Angular cases anyway) is to have each "feature" as a "component" and thus give it its own directory. Within that directory, you'll have your files that serve up whatever functionality you want. This is a good logical separation for features. Separate each feature out and give it its own directory so that you can easily jump to the feature's HTML, js, etc. without having to look too hard. It's also general practice to have a "shared" (also called "common", "core", etc.) directory for things that will be re-used or used globally in the app, like the header or a modal or something. The "assets" directory varies from developer to developer, but I like to have my assets divided up by type (css, js, img, libraries). A lot of other people would put bootstrap.css in the css/ directory or angular.js in the js/ directory, rather than having a directory named for the library. I like having directories named for the libraries for organization/readability purposes, but there's not really a "standard". Anyway, again I know this is an Angular example but I hope you can extrapolate this so that it'll help you. 
Regarding the second point, I'm taking a few courses on Udemy and i've noticed their prices are ALWAYS in flux. I bought a couple of "$300" courses for $15, that later jumped to $150, just to fall back to $10. It also fluctuated based on what browser I was using, and if I was logged in or not. It doesn't seem to have a rhyme or reason but I'm positive there's some rule engine behind it.
The guiding principle, now as ever, is to seperate your presentation, your data, and your business logic. How you do that, and what you call it, can vary. MVC was a hot term for a while (although what JS devs called MVC wasn't really anything the inventors of the term would have recognised). MVVM is another term that some people like. Others prefer MVP (Model View Presenter). Others use MV*; Angular I think is billing itself as MVW (Model View Whatever). Facebook made a bit deal when they launched Flux about how it was better than MVC, but it's just another way of separating logic, presentation, and data, and most good flux apps look a lot like most good "MVC" apps, just with some new labels glued on top. Yeah, sure *technically* the difference between a presenter and a view model and a controller are all meaningful and important, and obviously a viewmodel (which maps your data to your view) is totally, totally different than a presenter class, or the select/connect block in a redux app, which...uh...maps your data to your view. Totally different. But not in any way that is actually going to impact the code you write. &gt; Has ES6 changed the way JS code should be written? You should probably use the new ES6 module syntax instead of the old CommonJS module syntax? I guess? Of course, you'll then use babel to convert them right back to CommonJS modules which will then be bundled with webpack into code the browser can run, so the difference is pretty meaningless. In short, naa. We've got a bit better about figuring out how to implement the Eternal Truths (Backbone does not lend itself as well to clean separation of concerns as Redux does), but that's just the result of years of incremental improvements. The big principles haven't changed, no matter what buzzword is hot right now.
Free online: http://speakingjs.com/es5/ Disclaimer: it’s my book. I wrote it for programmers who already know an OOP language (Java, C#, Python, Ruby, …) and want an in-depth guide to JavaScript (ES5).
You're saying it's also not wrong. That's where we disagree.
I've been able to use a folder structure like this for both react and angular applications: app/ ext/ (OR ../node_modules) ... fonts/ ... img/ ... areas/ cats/ cats.js cats.html cats.css services/ cat-service.js cat-service.spec.js dogs/ dogs.js dogs.html dogs.css components/ dog-thing/ dog-thing.js dog-thing.spec.js dog-thing.html dog-thing.css services/ request.js request.spec.js components/ header/ header.html header.js header.css header.spec.js The idea is similar, but with some important differences: * **areas** is used for what you would call *pages*, and are meant to resemble your urls. This is MV* agnostic. * **components**, **services**, etc. are all for shared resources. Anything *not* in the **areas** folder is shared. * A folder in the **areas** can have itself a folder with the same name of any of the "shared" folders, such as components (or ext!). These are services, components, etc which only exist in this area of the application. If it needs to be used in another part, it is simply moved up. * css, tests, readme files, whatever, live along side the html and js. Very easy to jump from one file to another and keep things like documentation and unit tests up to date when you make changes. * Works very well with module bundlers. * Allows you to slice and dice your bundles as you see fit
No, that would be C#. (Not to be confused with C-Pound)
Someone offered me a lead for a fully Linux sysadmin role just because I subtly mentioned Linux in LAMP stack on a resume.
The joke was confusing similarly named languages.
So after you get the job you find out its discounted by 93% this week only!
That will change the double arrow function though. I want to keep double arrows as-is and add new functionality for single arrows. I guess a macro would work too, but it's not doing any parsing.
Enjoy reading https://www.reddit.com/r/javascript/comments/48eynl/udemy_offering_javascript_course_with_java_logo/d0j9zvk
Regarding monospaced fonts. I recently switched (back) to Anonymous Pro but I am not loving it. In Sublime like 1 pixels worth is cut off of the left side of some characters. I need something better. What is everyone else using?
Understood, thank you!
https://medium.com/@puppybits/clojurescript-is-the-triforce-of-power-984ac29da3d7#.3o9sal79c
Peperidge farms remembers.
https://github.com/adobe-fonts/source-code-pro I use it everywhere lately.
This make sense, I used to see it in several different conferences. 
Cool. I'm trying inconsolata as well. 
I recommend using touchstart because it has snappier response. If you must use click, add an explicit onclick handler to your element so that iOS issues the events for it, similar to: &lt;div id="enemy0" onclick="void(0)"&gt; Ref: https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html
I see few issues with your current implementation. The store shouldn't trigger the Ajax request. You should have a dedicated action for that and the view (your component) should have an access to it. So if you click the button you trigger that action. Then usually you have a service that listens for that action and it fires the ajax request. Once you get the result you dispatch another action which is then caught by the store. I don't see any benefit placing the logic for the new window inside your component. You better create another service for that and hook it up to the dispatcher. Once the ajax request finishes you then handle the new-window logic in the another service. The store says "I'm updated" when its internal state changes and when this change should reflect the UI. In your case looks like the view doesn't care about the response of the ajax request. If you place the logic that opens the new window in a separate service then your component doesn't need to know about the ajax request at all, right?
From what you wrote, separation of concerns into presentation, data and logic has been and still is the way to go, which would translate into an MV* pattern (assuming we use the terms Model for data, View for presentation, and * for C, P, VM, W or choose your preferred name here). Would the * you choose at least slightly influence the way you code your M &amp; V in regards as to how they interact? And would the use of modules supersede or be used alongside any of the MV* patterns? Thanks.
 repeat("hi", 2) //-&gt; "hi"
 repeat("hi", 2) //-&gt; "hi"
I can't be the only one that always just did +(new Date()) to force it to be numeric, can I?
Image is changed now for that course. Was that your call or they found out themselves?
It just resets page to 0 there. page had to be not equal to 0 to even get to that reset so it needs to be defined before the if statement, and I'm not seeing that in the snippet.
dumb people are bad, mmkay
That's why I suggested copying it - give the module a different name and keep your current settings as is + add your custom single arrow plugin
In Babel, yes.
I dont know whats more stupid, these idiots who post these pirated tutorials on Udemy or me for buying some of these through stackskills/stacksocial in a pay what you want deal!
Try `e._layers['59']._latlng.alt`
So, essentially, you just have one commandment: Enforce everything in JSHint?
1. Thou shalt not write JavaScript while drunk. 2. Thou shalt not use angularjs while drunk. 3. Thou shalt not use angularjs. 4. If you are using angularjs, you are drunk.
eww.
I respectfully disagree that looking at elm or clojure is the best way to go for OP if they're having trouble with applying FP. Learning new syntax and taking on that cognitive overhead will likely not be the quickest path to understanding. For a deeper dive or if you want to really commit, then clojure or elm are fantastic, but a much better guide would be [reactivex.io/learnrx](https://reactivex.io/learnrx). That starts with implementing forEach, map, filter, and reduce, and moves to querying trees, and then brings in side effects. JS supports all the necessary language features to write 'purely' functional code; it just also has elements of OOP paradigm. But if you already know JS and you want to learn functional programming, it's much easier (and just as sufficient) to learn it in the syntax you already know. 
The Array and join trickery can be avoided, and this can be implemented with a recursive function that supports tail-call optimizations. const repeat = (s,n) =&gt; (recur = (s, n, acc) =&gt; n &lt;= 0 ? acc : recur(s, n - 1, s + acc) )(s, n, '');
I'd highly recommend taking a look at Khan Academy to learn polar coordinates and trigonometry. https://www.khanacademy.org/math/trigonometry https://www.khanacademy.org/math/precalculus/parametric_equations/polar_coor It might sound daunting, (or even scary) but trig is so helpful to programmers! 
I have added a dropbox link to the original post, do you mind taking a look and seeing if you could find a solution? This is driving me mad!
I have added a dropbox link to the original post, do you mind taking a look and seeing if you could find a solution? This is driving me mad!
1. Always keep conventions. Do not deviate a bit. You don't agree with the existing conventions? Change **everything** to fit your view (after agreeing with everyone that you are right). There's nothing worse than having a javascript project with every file looking like a different programming language. 2. Never write a single piece of code on the global scope. 3. KEEP YOUR FOLDER TREE STRUCTURED. Conventions - do not throw code into places no one will have the idea to look in. Order your folders by modules, not a single folder for controllers/services/models/etc. 4. Use promises whenever you can. Wrap callbacks in promises. 5. Use promises correctly. Make sure you know what will happen if you return a value here and don't return there 
I'd try and flex a few more muscles than just CRUD. Make some calls to 3rd party APIs, load and resize some images, leverage a cloud service. 
I tried Polymer before moving onto React, primarily because there were so few Polymer resources and tutorials at the time. I loved the concept of Polymer, but reading/watching tutorials for React 0.13.x and translating them to work in 0.14.x was still easier than jumping in head-first without a sizable pool of information. I suppose that's because I'm not a strong enough programmer to feel comfortable being one of the first to commit to a framework -- it's a mental barrier more than anything.
You store it in an object. The UI reads its state from the object, not the other way around. 
Nope, store some data that tells another component which tab to render i.e. const tabStateMap = { foo: FooComponent, bar: BarComponent } export function DynamicComponentController(props) { return {tabStateMap[props.tab.type]} } If you're compiling the app with webpack/browserify, you're not lazy loading anything as it's all in the bundle already - just require it in and use an object to relate components to state. If the tab is manipulating the URL, then something like React Router can take care of this for you.
01 - Though shalt strive for clarity over cleverness. 10 - Though shalt use semicolons.
- Avoid eval(); 
Ah I see. Thanks! 
[**@malyw**](https://twitter.com/malyw): &gt;[2016-03-02 10:13:44 UTC](https://twitter.com/malyw/status/704972953029623808) &gt;Object.values\(\), Object.entries\(\) and Object.getOwnPropertyDescriptors\(\) landed in Chrome. [*pic.twitter.com*](http://pbs.twimg.com/media/CciRKjuWwAARghI.jpg) [^[Imgur]](http://i.imgur.com/L7NoeaY.jpg) ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/48lkc5%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
I'm not sure I agree with this. Writing comments allows you to be lazy with code structure and unless you (and more importantly your team) maintain those comments, they just become a load of lies (which are not checked by the compiler). By not relying on comments, you need to make a bit of extra effort to write truly "self documenting" code - so rather than something like this: EDIT: made my example more fair to the OP in response to their comment /** * this function extracts the user credentials from the request * then uses them to locate the user in the DB * at which point it works out their locale and selects * an appropriate template from the file system * and finally renders their data into the template * * @param {Object} userData */ function renderUserData(req) { // some code that does the above } you might have something like this, which tells you what it's doing by naming the functions appropriately function renderUserData(req) {} return pipe( extractUserCredentialsFromRequest, locateUserInDatabase, determineUserLocale, selectTemplateFromUserRoleAndLocale, parseUserDataIntoTemplate )(req) } 
In *duckhunt.js* there are some 'mousedown' event handlers but there are no alternatives for touch based devices ('touchstart'). Add these and it should work (it won't because it needs to be fixed a little bit more to work with touch events in this case).
So you make up your own stretched bad example as "counter-argument"? Nice. You could have saved yourself the trouble: It should be obvious the the number of possible examples of bad code not rescuable by comments is *infinity*. That a person tries to make an argument on such a basis is... just sad.
 "use strict";
Adding this seems to make no touch recognition on iphone (not even the water droplets or water stream works when touching)...?
Sorry where / how would I add these touchstart events? Within the mousedown or as a seperate script?
Context: It's a grid layout that has a constant margin or padding for each box/div. I cannot use flexbox since each row has a fixed height.
1) Javascript is Javascript. 2) Javascript is neither Java, nor C#. 3) Deal with it. 4) Use libraries, not frameworks. 5) Keep your dependencies up to date. 6) Good code is pretty. 7) Javascript can not fix bad design or stupid. 8) Scrum can not fix bad design or stupid. 9) Good companies do not employ stupid. 10) Good companies pay a lot of money. you want more? 11) Product owner needs to shut up and let pros do their job. 12) String is a primitive type.
Jackpot! Thanks a lot mate
Thank you~
Why the braces always? ```if (true) act();``` has become a common pattern for me.
I think this is all true, but after 1.x they actually are pushing things into production.
Yep, you are close. Don't think about the store and those services as connected. They should communicate only though dispatched actions. The store should not know that there is a ajax request somewhere. It should simply dispatch `GET_DATA`. Similarly `OPEN_NEW_WINDOW` action will reach the appropriate service. Or in other words, use the dispatcher as a hub and always go there first. Don't directly call methods of services or stores.
Choose standards, then stick with it. I repeat: stick with it.
If you are using pre ES6 yes... afterwards, it's not necessary.
Didn't they also have Array.values() but that was removed?
My belief is that you should write code that needs very few comments. The more comments you write the less value you'll place on each successive comment you see in a codebase. The comments I do write are for when I do something which would, at first glance, seem strange to whoever is reading.
A familiar story. I'm on board with R&amp;R for most of the same reasons, myself. Further, even if I weren't using React, I'd still be using Redux. One point of disagreement: I wasn't sold by Redux's documentation, myself. There's plenty of it, and it answers your questions, but its code examples seem at times unfriendly. This could impede adoption. Specifically: gratuitous "transpiler required" javascript. This is fine if you're comfortable with ES6 and JS's functional aspects. But suppose you're coming from ES5 and jQuery, and you're scanning documentation to see if it's a good fit for your next project. And you see this: let todoApp = combineReducers({ todos, visibleTodoFilter }) Or this: return [ ...state, todo(undefined, action) ] You might say "Never seen JS like that before! I guess I better learn something new!" But you might just move on without giving it a fair shake. (Examples above were taken from [Redux's documentation](http://redux.js.org/).)
...behind a flag. And in Canary.
&gt; Don't tell me how it's almost as good as the tool I'm already using; tell me how it makes my job easier. How is it better than React in a way that matters? Very good point. I looked at TodoMVC example for polymer - it looks nicer and cleaner than react versions - but that is subjective obviously. I was also looking at Aurelia. But the ecosystem seems small atm.
I'm pretty sure that you can achieve this using flexbox, too.
Okay thanks a lot!! I get it now :)
1. It's a functional language; embrace that. Don't try to shoehorn static class inheritance into your code. Read through the API of underscoreJS/lodash. 2. If available prefer fat arrow functions over the more verbose function() declarations. 3. When manipulating data structures, you get more maintainable code by passing through a series of discrete _.map() steps than you will get from cramming everything into a giant for loop. 4. Start out with as little baggage as possible. Basically nodeJS and npm will do. Pull in stuff as you need it. 5. Initially, use CDNs to server libraries to the browser. Along the way, pull in browserify and get libs from npm. 6. If you reach a point where you would benefit from typing, consider migrating to Typescript. Initially you can just type everything as "any", then add proper typing where it makes sense. 7. Use promises; it will make your flow so much more readable. If you create async API methods, make them return promises. If you use nodeJS, use bluebird to wrap the async native methods. 8. For build environment, use simple scripts defined in package.json. Or do the same thing using a makefile. Avoid grunt and gulp, they are just boilerplate. 9. Document your APIs. Provide examples. For a plain API, provide JS snippets for invoking it. For a REST interface, provide curl commands which can be copy/pasted to the terminal. 10. Automatically test API methods which have a well defined input and output. Don't unit test the internal workings unless you have am empirical reason to do so. Accept the fact there may be no gain from unit testing UI stuff. And keep in mind that test coverage may be a vanity metric.
With ES3526 you don't need Angular, you can do it all in Vanilla™® JavaScript!** **Only works in Dolphin 325.235352.1, Alphabet Chrome 32523677.123515125.111 and IE Edge Not Explorer 0.1.33
It can be done with canvas' arc() method. w3schools has a pretty decent write up on arc(). And there are countless others just a Google search away.
Really? I agree 1, 2 and 3 are a bit of a rant against people switching from other languages and refusing to accept js principles. It was inspired by the actual ten commandments (I am the Lord thy God, Thou shalt have no other gods before me). I think 4, 5 and 6 are quite practical and about development. Rest is career advice based on first hand experience.
I hope Object.values gets in so I can stop doing `Object.keys(myObj).map( key =&gt; myObj[key]).map(StuffIActuallyWannaDo)` :P Edit: I should also mention I didn't realize .values was so far along in the spec process. I use babel, but at my work we only use stuff that has a good chance of getting in, so I can totally just use it now...
Exactly this. "Braces always" isn't for you--it's due to the fact that a codebase is something that needs to be maintained, sometimes by someone other than the original author. Your original if (true) act(); can inadvertently become if (true) act(); doThisToo(); and now there's a bug.
If you use a linter this is not an issue. I don't know anyone writing modern JS who doesn't use a linter. It's insanity to not use one.
1. Declare your vars at the top of the function. They're hoisted there anyway. 2. To check whether an object has a property, do not use ```if (object[property])```. Instead, use either ```if (property in object)``` or ```object.hasOwnProperty(property)``` depending on whether you care about properties that have been inherited. 3. Don't pollute the global namespace.
Yep. Do not attempt to minify your own code. Attempt to make it dead clear what you intend, make it readable, and the minifier will handle making it tiny and unreadable.
Use lodash? edit: There are a few ways to not grab the entirety of lodash and only include what you need. Don't write your own low-level utilities, it is probably a waste of time. Are you also documenting, optimizing and testing your utilities? If you're not, use lodash.
I think angular suffers from the same issue that ColdFusion did, back in the day. It is so easy that anyone can use it... so they do.
You could polyfill `Object.values` or `Object.entries` easily...
* no numeric or string type coercion, if you use [+-*/%] convert via Number or String * avoid Promises if you are doing tasks that can throw unexpected errors ( sadly, most of the time ) * throw errors, and make the error message long enough it explains what happened * use semi-colons * use curly-braces * use "debug" from npm, not console.error for debug output * only inherit when necessary * avoid benchmarks until you make it big * don't extend builtin types * no globals
You can grab individual lodash functions.
I just posted an article today! To be honost I think polymer never really explained how to make applications with polymer well. To me it always felt like "here's something cool, figure it out". I had to develop best practices in polymer that was based off better explanations from people in the react world who actually took/had the time.
Google Ultron uses latest technology in AI research to detect JS that was transpiled from CoffeeScript and then calls developer names. 
So where is the article? ;-)
object is better than array
How about a for-in? for(key in ob){usefulFn(ob[key]);} I dunno about the performance on it, but I assume we're talking about the hassle of writing this out without just writing a helper function.
JQuery messed a lot of people up in that regard, myself included (for a while). It made it far to easy to just read and write things to the DOM and use it as your system of record.
The spaces inside the `if` statement brackets really grind gears of mine.
I have been trying for hours now and still dont have any luck :( would you be able to write some of the code for me to get me started? Im completey lost with this one...
If you need the ability to lookup a single element by a unique key/id, you should probably make the collection an object with the element key/id values as the property names to get ~O(1) lookup. If you're never going to do that, probably easier to have it as array where you can use Array.prototype functions or lodash. You can of course use collection functions of lodash in either case--object or array.
for-in loops will also give you things that have been added to the prototype (maybe by a library you depend on) which you probably don't want. You can filter out with obj.hasOwnProperty though. Edit: An example of this can be seen when working with Immutable. You get things like 'size' in your for loop (since it's defined on the Map prototype.)
Used to use this, but it ruins the kind of functional flow you get with map since it doesn't return the array :(.
You are executing '...innerHTML =...' before the element is loaded. I would move '...innerHTML =... ' into the onload event instead of 'addNumbers()' for obvious reasons. Edit: I just saw the title tag.. 'Assignment 3 - Question 1' LMAO
LOL, I actually read that today already :D
Yeah? it's for an assignment...so? I just started javascript and we haven't covered any onload thing in class yet...so i'm trying to get help. But thanks anyways it helped solving it 
Polymer is just too experimental to use in a production site. For that reason alone it precludes the idea of mass interest. We all have jobs (I assume) and spend our time working and talking mostly about things we use and have experience in. 
we all gotta start somewhere.
Yeah I think Polymer is a sweet concept, just needs to grow organically; it was unfortunate enough to launch the same year as/after React, which was the hot topic all year and beyond. It also is a bit more involved than simply running Babel + jsx transformer on a `.js` file; you need to manage each element's HTML import, the actual HTML element, and the JS constructor/manipulator object.
What if it isn't? How do you handle branch testing?
a regular else statement below, nothing changes. Why would branch testing nog be possible?
Exactly, if the else is one thing, once again braces can be omitted. It almost reads as a switch statement, and that's the most common way for me to use it.
false. Angular is not easy for newbies. The concept of "Dependency Injection" really fucks with new users or non-cs people. 
Hm. Not sure I like the readability of that. 
1. thou shalt pick framework that works for YOUR team and YOUR project 2. thou shalt use js management tool (RequreJS, Browserify etc) 3. thou shalt use package manager (Bower or NPM) 4. thou shalt lint thy code using excessively strict rules that strive for clarity rather than pedanticness 5. thou shalt use a build tool 6. thou shalt spend time with thine junior developers teaching them about best practices in an emotionally sensitive and constructive vs destructive manner. 7. thou shalt run code reviews periodically as a team and not every commit 8. thou shalt not argue about tabs vs spaces. 
Does it bother anyone else that the code in that header image doesn't work?
Don't use `var` at all if your coding in a transpiled environment
ok so I have this constructor(props) { this.state = props.redux.something; // ? } and then if I say.. change this.state in some way.. it "trickles down" through to via redux to the store ? what if I maintain state say using a symfony2 backend api service. ? I can create a redux -&gt; symfony2 mapping of sorts? 
and like all for-loops, they are ugly syntax.
Seconded. This sounds like the de facto use case for Redis.
It looks like you moved variables into functions. So there is now more code. How exactly did this help you?
Redux generally encourages you to not use state within your components. Instead, refer to their props directly. If your component wants to change a prop value, do so with an event. There are still scenarios where component state is a good idea. These are cases where data shouldn't be allowed to escape outside of the component instance. I often use state with "edit mode" components. When they initialize, they copy relevant props to their state, allow the user to change it using setState, and then push the changes back to the store via action when the user clicks "commit." Integrating Redux with an API service basically amounts to: * Creating an action when the API is contacted * Creating an action when the API responds * Creating a different action if the API call results in error There might be better ways to do this, but I've been handling the suite of API call actions with the help of [redux-thunk](https://github.com/gaearon/redux-thunk). But yes, you would need some kind of "mapping," too. This would probably come in the form of a reducer for each of the three actions listed above.
[Start here, maybe?](http://codepen.io/anon/pen/MywpRL)
Slack is using polymer and youtube and other sites are using it in production. I would think that its stable enough for general audience if you target IE10+ as baseline?
DOM0 handlerz 4lyfe
Hi /u/whatisprogramms, First off, this is not a job board or a place to post classifieds. Secondly, we will not do your homework for you. Lastly, for most professional JS developers, $70 would buy you 1 or maybe 2 hour's worth of time. For this to be worth my time, I'd require at least $250. You're basically asking paid professionals to work for minimum wage... p.s. academic dishonesty is terrible and you should feel bad for not doing your own work.
I was about to make a comment much like yours, but even more closely following the language of the Decalogue.
foo buz? WHAT IS THIS MADNESS
Sad my favorite framework EmberJS didn't show up on this guys radar. We get no love.
I'll follow the actual [Ten Commandments](https://en.wikipedia.org/wiki/Ten_Commandments#Traditions_for_numbering) a bit more closely here, including the fact that there are about 14 statements that at least one Judeo-Christian tradition considers one of the "Commandments": --- This is JavaScript, which has brought you out of the land of Java, out of the house of type enforcement. You shall have no other languages before it (no CoffeeScript, TypeScript, etc.). You shall not make unto yourself any graven image of JavaScript (no transpilers). You shall not take the name of JavaScript in vain. Remember Friday (when the JavaScript Weekly newsletter is distributed), to keep your knowledge up to date. Honor your father and your mother (make sure your code runs even in on their antiquated browsers and devices). You shall not negligently or maliciously kill the browser (with your bloated, inefficient code). You shall not adulter your JavaScript with reliance on browser plugins. You shall not steal (this includes scripts, assets, and user data). You shall not bear false witness against your neighbor's browser (by claiming it's incapable of using your site, even though it's capable). You shall not covet your neighbor's office. You shall not covet your neighbor's userbase. You shall not covet your neighbor's backend tooling, Internet connection, or anything else that is your neighbor's. You shall publish these packages that JavaScript requires unto npm (for the good Samaritans out there).
I've written some JS search libraries recently ([js-search](https://github.com/bvaughn/js-search), [js-worker-search](https://github.com/bvaughn/js-worker-search), [redux-search](https://github.com/treasure-data/redux-search)) and for those- where I think performance is super important- I've used for-in loops. But for my application code, I tend to use `Object.values` or `.forEach`.
Say you have this function, I did this in my code: /** Shows configuration dialog hiding the display of information **/ showConfigurationDialog: function(){ self.configurationDialogVisible: true ; } what's the why? /** I need to set the display flag for the configurationDialog **/ something like that?
There's a huge amount of developers that need to target IE9, especially in the ecommerce world. 
This seems to work: use an array, fill the gaps with your repeat text, thats why n+1, same answer only no test, not needed. function repeat(s,n) { return (new Array(n 1)).join(s); }
Didn't RTFA, but I assumed the thumbnail with the tiny text is a capture of the full article and it says something like: "Don't use classes in JavaScript and use stampit instead"
tried generators? function* values (target) { for (const key of Object.keys(target)) { yield target[key]; } } function* getSomething () { for (const key of values(myObj)) { yield StuffIActuallyWannaDo(); } } const result = [...getSomething()]; 
The code within the function only gets evaluated when the function is called. When the function is called, the variable "i" has already been set to the highest index (by the for loop). It doesn't matter what value "i" had when you created the listener.
I think it does.
Should I stick with Express or move onto Koa? 
how about "export" and "import"?
 &gt; const secret = ({ msg = 'ES6 rocks!' } = {}) =&gt; () =&gt; msg; ReferenceError: Invalid left-hand side in assignment
Thanks, just wanted some affirmation here. I feel better now.
Seconded. Code should be clear enough that you don't need comments to explain the structure of the code, however, comments can be useful explaining the reason for the implementation, which usually means contextual information around its usage and the behaviour it implements (behaviour as in BDD behaviour). There are always exceptions, but that's how I do things 90pc of the time.
Do you have any sources of information for polymer dev you think are doing best practices?
Cool implementation!
1. Spend the time to pick some good libraries and a solid toolchain. 2. NEVER TOUCH IT AGAIN 3. Install eslint and the airbnb ruleset 4. Focus on getting shit done and ignore the nonsense that can overwhelm our otherwise excellent community 5. When new versions of all your libraries come out twice a week, refer to rule #2. 6. Write good code. Much of Python's PEP-8 applies. Be kind to the poor guy who has to maintain your code (especially if it's you.)
Literally two seconds of additional load time for all your dialup users. Say no to bloat!
Okay thanks, that makes sense..Do you have any ideas what I could do instead? If I just use a loop without shifting anything, it won't check for the palindrome either..
There is no element in that code with an id attribute, so searching the DOM by id would always result in null regardless of where in the page that JavaScript is put.
Hah! I just wrote a blog post about this today and was about to submit it here :) http://emptypipes.org/2016/03/02/es6-module/ It uses yeoman, but the procedure is really rather simple. Essentially you just need to run: npm install -g generator-gulp-webpack-es6 yo gulp-webpack-es6 And then serve up the example page using: gulp serve You'll have to add the testing yourself, but it shouldn't be too much trouble to add it to the existing scaffold. Let me know if any of it doesn't make sense, is unclear or flat out doesn't work.
Generally, if you override the prototype of built in types, you're running the risk of messing up the way the browser does things. If you ask me, people take this advice way too far. I would really like a modern, safe, careful version of lodash or ramda that overrides built in prototypes in a polyfill-esque way (checking if the functions exist first). But you're going to find it difficult to find other devs who feel the same way and feel comfortable overriding the prototype like that. e: 3,3s/to/too
"Damn computer scientists, they ruined computer science!" https://www.youtube.com/watch?v=8iusUq4-f5U
I think you hit the nail on the head. There are a lot of people out there who just want the web form to submit to the database and don't care what a DTO, class, or promise is. They just need something to happen. Angular is just easy enough to pick up that you can make stuff happen with little to no knowledge of what the best practice might be. It is fantastic, but awful to inherent and explain why you have to "waste time" refactoring existing code.
Pretty sure the whole concept of how directives work and the array of scoping options/passing data in and out of directives is way more confusing to newbies than DI. At least, that was my experience when learning Angular...
It's only one guy's radar. Ember is very well crafted. It's especially good for those looking for sensible opinions to build from and gain some perspective on designing good javascript applications. 
Checking if the function exists first is the wrong choice and has caused problems in the past. The right thing to do is to always clobber whatever you find. To do otherwise invites the browser to break you by adding a like-named method that does something differently.
Gotta wrap that function: var list2 = document.querySelectorAll('.list2 li'); for(var i = 0; i &lt; list2.length; i++) { (function(n) { // you could technically use 'i' here as well, but I changed it so you know it's something different list2[n].addEventListener('click', function() { console.log('My index:', n); }, false); })(i); }
The people "in the know" in my area are recommending that new projects look strongly at using Angular 2.0 from the beginning. That being said, I would consider it "production usable but very unpolished" I think. I'd join them in recommending new projects strongly consider Angular 2.0 over angularjs 1.x due to the pain of migrating. I think the pain of migrating is greater than the pain of dealing with the lack of polish. I have little personal experience though, as I work on a large pre-existing angularjs 1.x codebase and moving to 2.x is going to take a lot of work for us.
Obviously this didn't fly, but I'd love it if you expanded on your comment. Do you really see no benefit here?
That is awesome!
I'm just wrapping my head around React. (I have some degree of familiarity with Angular 1.x.) Why would one use React with Angular? And, just to be sure that I understand you correctly, did you use ngReact with Angular 1.x, or was it with Angular 2 beta?
You can find a ton of literature by googling React vs Angular, but I'll just one thing: React is an easier mental model, and therefore less stressful as applications get big.
This is a little confusing. Let me make sure I understand you correctly. Gulp runs my files--e.g., JavaScript, Less/CSS/SASS--through processes like minification, concatenation, etc., whereas Webpack bundles all files of a particular type--say, JavaScript or CSS--into a single file that is served to the front end. So, I'd come away with a single JavaScript file, a single CSS file, etc. But Gulp can be used to accomplish the exact same thing. Is this correct? If so, is there any real advantage to using one over the other? Also, I've heard mention of people using the two tools in combination. Why would someone do this?
Ok let me try to emphasize the main differences: Webpack is a module bundler. When you write your code, you say thing like `import $ from 'jquery'` or `var YourCustomReactComponent = require('../components')`. You can organize your code in many files/modules etc.. and webpack will bundle up all your code in a single file. --- Gulp is a file processor. You give it specific tasks to execute on files--passing them through a pipeline of processes. ___ I've heard of people using both as well, but I have found webpack to do everything I was able to with Gulp before.
The difference between what Webpack is designed to do and what Gulp does is that Webpack creates separate customized bundles for each page of the site, which only contains the css/javascript that actually gets used on that page.
Thanks for the suggestions, I'll take a look later. Do you have any examples of cases where it looked safe to modify the prototype, but something bad happened? As for iterating object properties, I can use object.defineProperty to prevent these functions from being iterable. I guess I really like being able to chain functions without having to go back and add stuff in the beginning of the line.
Not just messing up existing libraries, but messing up the web in general. There are a bunch of ES5/6/7 methods that literally could not be named what we'd hoped they could be because old libraries that modified prototypes used those names... but had a different implementation/api than what the language ended up going with. 
If you're going to do this safely, you could use symbol keys. That is, add all the Symbol key _lookups_ to the _ object and then add the bound methods to the prototypes with Object.prototype[_._without]. That way, no native methods or extensions can clash with what you've done. This is basically the sort of job that Symbols are for.
You just ruined what had been my favorite code for two days.
A lot of jquery code treated the DOM as their data model directly. What's the name of a contact? `$('.contact .name').text()`. What is their address? `$('.address_line_1, .address_line_2, .address_city, .address_state, .address_zip').text().join(' ')`. The performance hits are huge, but worse, a tree data model might not be the most correct for our data, and is almost impossible to manage state in large applications. Instead, we learned it's much better to have an object in your javascript, `{ name: "elprophet", address: {line_1: "123 Main St", line_2: "", city: "r/javascript", state: "Reddit", zip: "12345"}}`, and then we update the DOM from those. Now we have a javascript object that we can do any logic to, without needing to know anything about how it will be displayed. We can do nifty logic heavy things in the browser, without being tied to our server language.
&gt; To prevent conflicts with future browser additions, we can prefix function names with an understcore. For example, foo._values(). So... *sort of*, yes, you're right. If you namespace what you add to the prototype, then the chance of a conflict is a lot less. *But*, the flaw is you went with the *shorthand* name, "_", rather than the full name, "underscore". What happens, for example, if the lodash folks decide they want to do the same thing? This has all happened before. We ran into exactly this sort of problem when every library wanted to call themselves "$". That shorthand seemed nice at first, but it caused all kinds of problems later. Just don't do it. Shorthand namespacing is bad. And if instead you namespace on the full name, then your code is going to look like this: `[1,2,3].underscoreWithout(1,3)`. Moral of the story: Don't muck around in someone else's space; don't monkey patch someone else's prototype. Trust me when I tell you the headaches are not worth the syntactic sugar. We JavaScripters have had a lot of experience with this. It always turns out bad.
I agree, although I think if you're going to go this route, you should always clobber as that's the only way that doesn't hold the web back. Worst case scenario is you or some library depending on browser-native behavior which you can control for by testing and such.
I don't mean this in a rude way I swear! The mistake is feeling that way. Pick the tools that are right for you. If they're not hugely popular, you just have to do more due diligence before depending on them.
Completely disagree on only using webpack for small projects. I work at a relatively large company and we use webpack for several reasons and it works very well. Our project contains Typescript, angular2, sass, images, fonts, HTML, phaserjs, and more. We make use of tree shaking, code splitting, and many other features. At the end of the day I’m more than happy with webpack.
Can we piggy back this to discuss what the best JS API documentation examples are. E.g. https://stripe.com/docs/api
&gt; there is always a risk of conflict whenever you declare or modify anything that exists outside of a function expression Which is why good namespacing is so important. Choosing "_" or "$", for example, as a namespace is a poor choice.
Ive never used Webpack, but is that similar to Browserify?
I've got 80-90% coverage on my ES6 front end at work. It's not a tiny project either. We have ES6 classes, angular components, and our tests have ES6 as well. It generates coverage too, and I haven't had issues of the line numbers matching or anything. I'm not using Karma though, just Mocha to unit test each class.
Gulp is particularly attractive to me as the maintainer of a large JS project. Why? a) simplicity, and b) because it's future proof and its value is primarily conceptual. Gulp's philosophy is incredibly simple: All your assets are piped through your build in the form of streams of files. You, as the build author, define the series' of transformations over those streams. For the most part, these plugins come from the massive `npm` ecosystem, but it's extremely simple and straightforward to create your own plugins. It's all just node streams all the way down. Huge ecosystem of utilities, very low lock-in. Even if Gulp "goes away" (i.e. loses favour in the fickle frontend world), it can easily be replaced. It's primarily just about streams. It is as advertised: A streaming build system. You could easily argue that it's more of an idea than anything: builds are streams of assets that are transformed via pipelines of various, single-purpose plugins. This can include bundling, minification, all that stuff. However, these build steps really just operate on Node's Stream APIs,. These things makes Gulp really attractive (to me at least). I'm using Gulp not only to build products, but to run refactoring steps, bundling, source mapping, instrumentation, hot reloading, et cetera. Even if it goes away, I'll be doing exactly the same things and with a lot of the same code. Streams in, streams out. IMHO, things like bundling, tree-shaking, et cetera, are ideally build-agnostic. This is likely where Gulp and Webpack start to differ. Handing glob patterns to something that simply consumes/produces read+write streams of files to execute some sort of transformation upon them is about the least binding way to build, er, a build, and to have it be future proof for a large or long term project. This is Gulp. Whether you pick Webpack or Gulp, my opinion is that - in an ideal world - you should treat things like bundling as a function in a stream of assets in your build. I don't think that "module bundling" should be the primary factor in choosing a build system. That's the primary argument I hear for Webpack: It bundles stuff. Cool, I need that, but I need it in a way I can directly program. Remember this: In Gulp, you *code* your build. In other tools...not so much. If you're building a side project, do whatever you want. If you're building something for the long term, avoid lock in and trendy tech! You may want to check out SystemJS (mentioned already) and TypeScript, which will now (as of 1.8) simply just transpile JS and even bundle AMD and System modules into a single file.
Interesting historical fact, the second jQuery plugin ever written was a DOM plugin that did pretty much what this does, connected to the jQuery namespace. A decade ago last week. http://mg.to/2006/02/27/easy-dom-creation-for-jquery-and-prototype 
I thought about that but the text input correctly updates the observable when I originally had it as just a text input. If I make `self.pick` an object with observable properties how would I set the properties from the API call? Currently I just do `self.pick(data);`
Very yes!
I like it, though really 10 is implied by 01.
You're using "just mocha" and have code coverage working with ES6? How? Because I'd love to get off Karma and get back to my familiar Mocha testing in the browser.
Awesome. I've generally been impressed with web audio and html5. It'll be cool to see how the technology evolves. 
Using basically all the same stuff you mentioned without karma. It's not open source or I'd link it. If you have any specific questions or problems I can answer though.
*I'll have my go at making this a really simple summary while not really adding any additional information to this topic:* * **Webpack** takes a master script and rolls all the assets it requires into a single self-executing bundle. Almost your entire application's source code will fit into this single bundle, aside from the initial HTML page that includes it (as a &lt;script src="bundle.js"&gt; tag). * **Gulp** is a 'task runner' that has lots of plugins that do just about anything. You might have a gulp plugin that compiles SCSS into CSS, or you might have a gulp plugin that runs webpack on your main script to create your application's bundle.
What code coverage instrument tool are you using? Istanbul doesn't support ES6(2015), or are you using some custom build of it? Are you still using Babel and Browserify?
Using isparta. Yes babel and browserify. Using gulp as a build tool. 
There really is nothing new under the sun. Web development is just increasingly complicated methods of concatenating strings. 
It will never not be confusing. They're a bunch of tools and plugins that overlap in different ways to compensate in different ways for all the various deficiencies of JavaScript.
lmth is "drop-innable" - a single JavaScript file with no build step or dependencies, but both hyperscript and hyperscript-helpers are not only two different packages, but have dependencies and require a bundler. In my opinion, for client-side projects (which is what I plan to use lmth with mostly) less dependencies and shorter build times are good. - - - The "type safety" is errors at runtime, not silent fails if you mistype an element's name. (Also, when I had initially conceived this idea, I was/am thinking about only allowing legal child elements to parents according to the spec: for example, attaching a li to anything other than an ol or ul will result in a runtime error).
&gt; const secret = ({ msg = 'ES6 rocks!' } = {}) =&gt; () =&gt; msg; Yeah, you're right, so I was wondering what node 5.7.0 is missing... babel-node --presets es2015 -e "const secret = ({ msg = 'ES6 rocks!' } = {}) =&gt; () =&gt; msg;" # works node -e "const secret = ({ msg = 'ES6 rocks!' } = {}) =&gt; () =&gt; msg;" # breaks [eval]:1 const secret = ({ msg = 'ES6 rocks!' } = {}) =&gt; () =&gt; msg; ^^^^^^^^^^^^^^^^^^^^^^ Looks like default parameters is behind `--harmony_default_parameters`, although that still barfs, maybe the implementation doesn't include arrow functions yet.
Hyperscript sure, but that's only one of the libraries I mentioned. You can partially apply any of them to get the same kind of "type safety": var p = m.bind(m, 'p'); var h1 = h.bind(h, 'h1'); var h2 = React.createElement.bind(React, 'h2'); The "validating your vdom as you create it" *would* be kind of unique, but that could also be written as a helper library for any of those other ones and not need its own thing.
Thanks for the heads up.