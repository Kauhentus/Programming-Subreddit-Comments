Thank you. I will have some time during the next weeks. I will check if it makes more sense to me if I dig deeper into the topic.
You'll do it less as time goes on and your confidence increases
I cannot get over JSX. My mind cannot interpret it.
Yes. It's even suggested by [airbnb's styleguide](https://github.com/airbnb/javascript#commas)
I'm honestly sad that you have to support IE8 users.
Or does this mean JavaScript is the least complex language because the code required to perform a task is more complex to make up for deficiencies in the language?
Hi, mates! This is the third similar project I'm releasing this week. The end goal is this to become the go-to "JavaScript Toolbox". Currently, this is based on the official Github "awesome javascript" list. Again, I will be more than happy to receive any feedback or ideas how the site could be improved and become more helpful. I already received some excellent suggestions in the context of Python and Ruby. Thanks!
You are a troll. Fortunately, I can censor you with a handy-dandy Reddit feature *block user*. Now you can rage and downvote to your maximum joy. I hope you have a better day and get a hug from a stranger.
The proper way is "don't." Instead, use a mechanism that just doesn't interpret them in the first place, like `.textContent`. If, for some nightmare reason, you actually do need to escape content, this is usually the best way to do it (on a node not attached to the dom of course,) since you get the browser's interpretation. &lt;!html&gt;&lt;head&gt;&lt;script&gt; window.onload = function() { document.body.textContent = '&lt;script&gt;window.alert("not haxed?");&lt;/script&gt;'; } &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 
* immutable data has some neat performance optimizations * working with immutable data can be a pain, but that's why immutablejs exist * check out freezer.js for an immutablejs library that behaves like plain old javascript
Definitely worth 15 mins of your time (if it's new to you). I liked it enough to subscribe to his channel
It's good, but he starts using alt without explaining it at all. 
This is what I do 90% of the time. When I really want to keep things hidden, I'll do the WeakMap trick.
The more imperative a language is and the less syntax sugar it has, the better this works. Highly functional code needs good formatting, so either you need to spend *much* time coding a good formatter, or don't touch the code.
I use [this function](http://stackoverflow.com/a/6234804/4840882) for a small project and it works just fine
But the straw grasping! How else am I gonna tell you my perfered method is better than yours unless I grasp straws from my ass and throw them at you?!?!!?
The point of the gist is that WeakMaps accomplish this while avoiding the drawbacks of existing methods.
What do I have to do with this??? Your comment makes no sense at all. I'm only presenting a link to an article I like. It's true, I've not written C++.
Fair enough, I assumed you knew what it referred to because you said originally: &gt; Can we stop with "batteries included" as a way of describing software. and &gt; A lot less lame than Batteries Included IMO which both led me to believe you knew what it was referring to and just didn't appreciate it. I'm sorry I was misguided in my response. It's a pretty common term for an environment that's ready for use upon download/install whatever, rather than a library or environment that you need to set up or install other things to make it useful. See: [Python Stdlib "Batteries Included" philosophy](https://docs.python.org/2/tutorial/stdlib.html#batteries-included) [Blog post: "What Batteries Included Means", from 2010](http://www.protocolostomy.com/2010/01/22/what-batteries-included-means/) [discussion about whether one should include ActivePerl bundled in software, in order to make that software "batteries included" from 2010](http://www.activestate.com/blog/2010/11/activeperl-system-requirement-or-batteries-included) [Batteries, an OCaml "community-driven effort to standardize on an consistent, documented, and comprehensive development platform", with the first release being in 2008](http://batteries.forge.ocamlcore.org) EDIT: Formatting 
Immutability is so hot right now!
Tyre analogy is really bad. "Closure" is closer to "merging on the highway". You can drive in most placed without knowing how to merge, but if you want to drive on the highway safely, you would need to learn it. 
I haven't tried it either, but I watch a video where Scott Hanselman talks about it at length with the devs. It's a layer between an Ubuntu setup and the kernel so that the Ubuntu side doesn't know it's on Windows. The bash shell in this environment can't call Windows bins, and the cmd.exe shell on the Windows side can't execute Linux bins.
Yes it was introduced with ES6
Yeah I'll be covering redux which is just a bit different than flux. A lot of people prefer redux for a few reasons which I'll also cover.
In my experience, any time I found myself needing ```var```, I was doing something wrong/not ideal.
Right click anywhere on the bottom-right area to pop up a fake Windows(7) (chrome) context menu. I am pretty happy with it. It is kind of creepy and already fooled me a couple of times! Here is a comparison of them, side by side (left one is real): http://puu.sh/ogTdW/0932bc7480.png As you can see, I did not include some of the options, but otherwise they look pretty similar to me at least. I got lazy at the end, so I did not implement any functionality to the context menu buttons. I also did not implement some of the left texts in the menu being "inactive", but I might add it later if I am bored again.
I've personally never found one, but I remember reading an article from someone who said he still had a use for vars
Let's get you starrrrrrrrrrrtttttted... `var xVal = document.querySelector("[name='x']").value;` What that will allow you to do is get the value of your various input fields (where x is the value of the `name` attributes in your html). Probably easiest to do one for each of your input fields. When you get those all set up, link back and let me know!
Trying to duck type by ... strictly checking against a prototype? Huh? If you were duck typing, you'd just do this: someObj.getX(); And not care where it comes from. And indeed, that is what you should do. As for "prototyping convention", prototypes are not intended for private data. You can still do things like inheritance quite easily: var Person = function(name) { this.getName = () =&gt; name; } var Manager = function(name) { Person.call(this, name); }; var joe = new Manager("Joe"); joe.getName(); // =&gt; "Joe" I'm afraid I cannot agree that some random map with a hackish-sounding name of `__` is the correct solution to private variables, when closures are clearly the intended way from a language design perspective. 
I dunno. React is pretty well designed. And, there are really good dev tools that work with it. However, you're still trying to do the same thing: make a UI in JavaScript. It's tough because only until recently people were really trying to do that. The solution is to focus on the problem: make UIs easier to develop. There are a lot of things for your traditional UI, many of them React gives 0 shits about. React mostly cares about the ShadowDOM and making renders mad fast (which is REALLY GOOD for apps like Facebook, this is why they freakin' made it, obviously!) 1) User input and validation 2) Persistent data state 3) Safe data state (revision/versioning) Are all important, incredibly important, for consistent UI. JavaScript doesn't have well supported features to help you roll your own objects: Sets, Ordered Dictionaries, so forth. So, you have this "JavaScript is missing a lot of neat features" and "React is just trying to do A, and it does it really well, but you need to do B...Z yourself." coming together with what we're trying to do: develop UIs.... What you end up with is what you got.
You have a very long way to go and quite a bit to learn in two weeks. Start skimming MDN. I won't recommend a framework without basic knowledge of JS, get to that point before you run with it. To get it done though... do a search for: jquery forms I don't use jquery, but it's good for rapid prototyping.
5 ECMAScript.next links per week, curated by /u/rauschma and me.
The whitespace around the separators is off :P
Yeah, I just noticed the padding is a bit off with the menu items in general. I will probably try and fix that later, it does not seem to be too simple because I am doing vertical align with a simple line-height rule for the menu items (which breaks with padding), so I will need to align them vertically in another way. Edit: I think I fixed it with just border-spacing!
To understand what happens here, you need to grok two things: 1. Variable declarations are hoisted, but assignments are not 2. `y = 10` actually means `window.y = 10` If we make the hoisting explicit, your example looks like this: // Hoisted stuff function x() {} var z; // Your code window.y = 10; z = 25; When you write `x = function() {};` you're not declaring anything, you're assigning an anonymous function to `window.x`. This assignment, like the others, will not be hoisted.
Give the 3rd div a margin-top of 4px. Give the second div a padding-bottom of 4px, and increase the height by 4px to compensate (while keeping the line-height at 27px)
I still stand by my it is a meaningless way of describing software. If it's no-configuration, no-dependency - SAY SO! :) Adding a catchy phase just adds confusion. It's a basic concept of the english language (and i'd assume most languages) -- say what it is, avoid jargon.
Inheritance does become a problem in this case if you ever care to override functionality. Because everything is an instance member, even inherited members, if you want to override with any kind of semblance of `super`, you'd have figure out what to do with the original before you stomp over it with your own version.
Mixing two things that were never meant to be mixed.
- Weekly newsletter - Goes out every thursday - You can get it on wednesday for $2 - Has 10+ curated links with a brief opinion on the subject - Topics include javascript, web dev, design, hacks, programming inspiration and more!
You're right it's not hard, but it is repetitive, and it needs to be done with perfect consistency. Machines are great at repetitive tasks with perfect consistency, but humans are not. Not that long ago, I was trying to track down a bug at work. It turned out the bug was a simple typo of a method name. Normally such a simple mistake would emit an exception that would kill the program and report the offending file name, line number, and stack trace. But that didn't happen here. The error happened inside a "then" clause, and one missing catch meant the error was silently ignored. Ideally, good things should be easy and bad things should be hard. Reporting errors is a good thing, suppressing them is bad. But the current state of promises is that reporting errors requires explicit code on our part, and suppressing them requires... literally nothing. I think that needs to change so that errors are reported automatically. I noticed recently in the [Q documentation](https://github.com/kriskowal/q#the-end) that they seem to hold the same opinion. Requiring explicit handling just to report that an error happened is a bad thing. They consider their "done" method to be only a stopgap. But even their "done" is an improvement over ES6 promises at the moment.
I don't like to mix mark-up &amp; code, feel free to do it yourself.
If anyone's looking to work on React Native projects, contact me james at faceyspacey.com. I'm willing to train younger junior developers and have several times. Remote is fine. 
&gt; 99% of all front-end apps don't need "mad fast" renders. 100% agree. &gt; Many people using React don't have any memory of those days because most of them weren't programming back then. This brings up a great point. Lots of times when I'm doing JavaScript development (I got my start not in web dev) I feel that I *need* to do things the `wrong way` to make them work. The design patterns throughout the community seem to make very little sense to me. &gt; We tried React once at our shop and everyone had a negative reaction towards it. I think this is because you really shouldn't have been using React in the first place. Sometimes I'll have a client come to me and say "We want to use React on a new application." My first response is always to dive deep into that and find out why. Most times they do not have a reason to start with. 
I actually never used the implicit examples I gave, but understanding it does clarify a lot. Thank you.
I see, where I went wrong was thinking x = function was an assignment to window.x thanks.
I think you're really misinformed.. &gt; 99% of all front-end apps don't need "mad fast" renders. React is not about speed. Yes it's fast, but there's faster out there. But you're right, not everyone need React. Doing a marketing site for a business? You don't need React. React is good for **web apps**, not **websites** &gt; This is only an issue if you have way too much going on in your DOM and then you should probably rethink your design. As I said, if all you're doing is a marketing site, you will most likely never need react. Vanilla/jQuery is fine. &gt; Putting HTML into Javascript is going back to the days of putting HTML inside Javascript (that's so 10 years ago), which was frowned upon for very good reasons and the industry moved towards separation of concerns. JSX is NOT html. You don't have to use JSX in order to use React. It just makes it easier. [Read more](https://facebook.github.io/react/) JSX: render: function() { return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;; } compiles to render: function render() { return React.createElement("div",null, "Hello ", this.props.name); } &gt; JSX and its proponents have redefined "separation of concerns" to mean whatever they think it should to validate their use of HTML inside javascript and to make themselves feel better about what they are doing. Again, it's not HTML.. and yes, it is separations of concerns. A concern is a set of information that affects the code of a computer program. It doesn't mean different languages. [source](https://en.wikipedia.org/wiki/Separation_of_concerns). It doesn't make sense to separate the HTML out of the javascript if the Javascript requires the HTML and the HTML without the JS is not alive. Components FTW. &gt; it's still pretty bad for many workflows that involve designers and people who do HTML but not javascript. From my experience, that's just not true. I have a few designers who were only doing marketing sites, jump on React stuff in less than a day. JSX looks like HTML, and since they're designers, they don't touch too much except for using `className` instead of `class`.. come on, they're not *that* dumb. Also, the workflow is so much better, since it's so easy to do live-reloading with React while keeping the state. 
I'm missing the [sarcasm] tag. But nicely done. For a moment i thought you guys were serious
no support for YUI, GWT and eval()? this is a letdown.
I thought this was for real...instantly said to myself, "I don't care how good it is, I am not using something called FapFap"
1) JS is deeply nested Yes, JS uses lexical closures. I guess Scheme must be hideously complex, then, if this is your metric. 2) People ask about JS a lot on Stack Overflow Yes, JS is very popular and web development has a huge number of programmers. 3) JS programmers change many lines of code in commits and thus JS is not very expressive / efficient. What is the connection between commit LOC and expressiveness/efficiency, exactly? 
I like the way Vue.js handles it with [single file components](http://vuejs.org/guide/application.html#Single-File-Components). The css, javascript and html are together but separate.
Your corporate dinglydangly should force you to use a linter which would catch every single problem with ASI. And since I never start lines with array literals or IIFEs, I never in my life had a linter tell me I should insert a semicolon.
That's a loaded question. If you're looking for basics of JS, I suggest reading `The Good Parts` by Douglas Crockford. It'll give you a good sense of how the language works. If you're looking for design patterns, I recommend reading `Learning Javascript Design Patterns` by Addy Osmani. If you're looking for a more web-based approach to learning, try out [Eloquent Javascript](http://eloquentjavascript.net/). Once you know your way around the language, its syntax, and nuances, start looking into a small project and do some basic stuff like form submission, input validation, and dom manipulation (with pure JS, not jQuery). If you are still looking for more resources, check out /r/LearnJavascript. Hope this helps!
But I neither like indenting with spaces nor semicolons 😢
Doing what, exactly? You'd probably get more interest if you said what project you were looking into. 
Awesome thank you. I do have some programming experience so I think the hardest part will be the syntax. I'm going to check out Eloquent Javascript since I'm looking to do some javascript on a webpage I'm building. 
That's true, too. What's your point?
&gt; What is the connection between commit LOC and expressiveness/efficiency, exactly? The idea is that a commit generally represents a completed task and that the scope of the average task is relatively fixed across languages. If both of those hold, then you can use lines/commit as a proxy for language expressiveness. My counter-explanation is that the JS community really likes committing build artifacts under the `/dist` folder which, being build artifacts, generate enormous diffs off tiny changes. I found the whole graphic amusing in how hard he's working to justify his belief that JS is the worst language ever but the lines per commit part was my favorite.
`apply` and `call` become significantly more useful when you really start thinking of functions as fundamental building blocks instead of just object methods. Coincidentally, I'd say that's the big "aha" moment you're looking for. If you don't want to tear your hair out when going back to a language without first-class functions, then you're probably not using javascript to its full potential. If you want to dive into programming with functions, give [Javascript Allongé](https://leanpub.com/javascript-allonge) a read. The other major milestone in developing a javascript-brain is event-based logic. Javascript (particularly when executed in the browser) relies heavily on the [observer pattern](https://en.wikipedia.org/wiki/Observer_pattern). My javascript got significantly better when I learned to structure my code into small loosely-coupled modules that communicate through event emitters.
I would love to see anyone try that use this on a CMS based site (Drupal, Wordpress, ...)
It's basically HTML with a few tweaks. Putting jsx into JavaScript definitely looks a little strange at first, I had the same impression, however React really is fantastic. React is far easier to understand and use compared to say Angular.
You can use React without JSX. That's what I keep saying. It'll only make sense if you understand the simple concepts behind it but it seems too complicated for you. You're putting off from really trying and understanding it because of JSX, and I'm saying **you don't have to use JSX**. I can't understand how you can even mention "tech-debt" and then mention "I'll stick with Angular". Like... what? LOL. You're confused man. How the fuck is this better than JSX? Angular 2 &lt;p [style.background]="'lime'"&gt;I am green with envy!&lt;/p&gt; LOL. 
I just started using this in my build setup for Crafter.js, and the output is amazing and more compact than babel! Babel makes my code compatible but murders it's beauty with Buble it transpiles it while leaving the structure of the code and the flow almost untouched which I like very much. The only thing that would be very nice if possible is if there could be a gulp plugin made for it. You win my star :D keep on working this project is awesome
You can get privacy by using a closure and a WeakMap. The instance of the class becomes the key to the WeakMap and the value can be an object containing all your private instance methods/values.
Vue.js is great. I just wish we had this syntax highlighting working in IntelliJ based editors. There are two plugins both are currently broken :'(
FWIW – this is the archive of issues: http://us12.campaign-archive1.com/home/?u=d3a2c4d93441c84c0a1e6e808&amp;id=705caf4dc7
I've interviewed roughly 40 people for a front-end engineering position over the past year and the funny thing is the people who just walked out of a Bootcamp are the *only* ones I could count on to know the answers to basic questions like: * What problem could you solve using a closure? * Where might you use .bind/.apply/.call? * How would you emulate the behavior of `Class`es from other languages? * Describe how events move through the DOM It's the "been developing for 10 years" crowd that it was a total crapshoot whether they had an understanding of what was going on under the hood or had simply made a career of implementing jQuery plugins or some basic client-side framework solution.
that site has css? I thought it was just tables and porn.
Why is this spam allowed?
Great Idea! hmmm I am trying this in the debugger and it's not working. It does output a lot of blank space as if it were trying to fill it up with Sting but nothing renders. 
and as long as your original abstraction _actually_ covers those next 4-5 times.
There are a couple special case-type things in React. Not being able to use class is one of them. Some people don't like JSX, but there's inherently no requirement to use JSX at all. Ultimately I think there are about 1/100th the amount of gotchas in React/JSX as there are in a tool like Angular, and that's why I don't really view them as unacceptable. The rest of the industry is far worse.
&gt; I'm afraid I cannot agree that some random map with a hackish-sounding name of __ is the correct solution to private variables. You do have the option of naming it something besides "__". Also, lest anyone thinks using WeakMaps for private data is some random idea I dreamed up, it is not. [Lots](https://www.sitepen.com/blog/2015/03/19/legitimate-memory-efficient-privacy-with-es6-weakmaps/) [of](https://curiosity-driven.org/private-properties-in-javascript) [people](https://developer.mozilla.org/en-US/Add-ons/SDK/Guides/Contributor_s_Guide/Private_Properties) [are](http://www.2ality.com/2016/01/private-data-classes.html) [advocating](http://ilikekillnerds.com/2015/02/what-are-weakmaps-in-es6/) [the](https://www.nczonline.net/blog/2014/01/21/private-instance-members-with-weakmaps-in-javascript/) [technique](http://fitzgeraldnick.com/weblog/53/).
Hi /u/FaceySpacey, this post was removed because /r/javascript is not a job board.
Jesus. Closures aren't that hard.
what tables?
 function writefile(file){ return function(buffer) { return new Promise(function (resolve, reject){ fs.writeFile(file, buffer, function(err){ if (err) reject(err) else resolve() }) }) } } Use it as such: readfile('a.txt') // resolves a Buffer .then(operations) // resolves a Buffer .then(writefile('b.txt'))
You put an empty line before starting your code, but each line of code should start with four spaces. This will format your script so other people can read it and possibly help you. p.s. - [urgent plz help](http://www.catb.org/esr/faqs/smart-questions.html#urgent)
Meant Angular just as an example of another (highly compared to and widely used) JS framework, not that it was black and white, you have to use Angular or React. There's Ember, and a million more. I'm pretty sure that if Facebook, a site that has well over a billion users can use it without major issue, it isn't just "because company X uses it," it's a site as massive as Facebook standing behind it.
https://gist.github.com/lhorie/1204893c2f0e3ba3c14ac204b2df4b24
Thanks!!! You're awesome.
I once saw approved by the auth wizard 2/8/08 7 years later and it was still there, I doubt "the auth wizard" even works at the company anymore
Hi /u/richcarman504, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
This is the correct way, very simple, easy to understand, and works great. 
I highly *don't* recommend immutablejs. I use it daily at work and it's hugely verbose and a pain in the ass to work with. You can't use any libraries like lodash any more either. I would look into something like seamless-immutable or using object.freeze or even just making it a convention to always create a new object when you mutate something. But taking away JS's easy to use API for manipulating an object just sucks. When you first spend 10-15 minutes figuring out how to get some nested property updated properly and end up with 6 lines of dense code, you will understand. Also, it makes debugging suck too. You need to install immutable-logger or you will need to manually call .toJS on everything to see its contents in the dev console. 
They are far easier than inheritance.... but then I don't come from a Java background.
Thank you for this answer, it is very detailed and helpful. Out of curiosity, do you know why Object.values() does not yet exist in ECMA 6, but Object.keys() does? 
Super excited for this! I have been working specifically with Firebase + Vue.js at the moment. Trying to wrap Firebase so that you can sync offline. Also @yyx990803, great work on Vue.js. It is unbelievable and I am super excited to see where it is going!
Sorry, I don't have any special insight into that beyond what you can find in the usual sources. Perhaps you might find some of the discussion linked from the [TC39 page about the proposal](https://github.com/tc39/proposal-object-values-entries) interesting?
Taken out of context your comment on mixing mark-up &amp; code could apply to Handlebars and Angular as well as React. Handlebars and Angular both implement a mediocre programming language amongst HTML with their own syntax for loops and ifs.
And those advantages are? The advantages of the client side are manifold: + you can test for specific features/capabilities as you render + you get free distributed processing, as template expansion etc is now done on the client cpu + you can manipulate the DOM without reloading the page + you can cache parts of your application to run offline I can honestly say I think PHP is an abortion, and that server-side page rendering is antiquated nonsense, so im certainly biased here. Sell me, cause i (and it seems most of the web developing world) aren't seeing it. EDIT: I will temper this a bit, and express the piece i think is missing. Everyone is making reactive, data-driven web apps these days -- that's why client side is so popular, because that's where all the toys are. You aren't going to generate flashy D3 visuals or WebGL animations on the server, you aren't going to generate reusable web components (read React) on the server... There just isn't any innovation there.
I hate to throw a link here instead of contributing to the discussion myself, but I remember [this](https://medium.freecodecamp.com/angular-2-versus-react-there-will-be-blood-66595faafd51#.919ac5k8b) article was one of the best comparisons I read about the differences between the two and their respective advantages/disadvantages. 
This book is really great at giving you a primer not just on what is hoisted but why (and it's free and on github): https://github.com/getify/You-Dont-Know-JS/tree/master/scope%20%26%20closures
I did read that one, it was pretty reactjs biased regardless of whether the author warns of it. Most of the article is about where react shines, and it's pretty vague whether it's advertisement (clickbait headline, strong use of pathos) sponsored by react or an actual attempt at unbiased.
&gt;a lot of people still struggle with prototypal inheritance. A lot of people struggle with pointers. A lot of people struggle with recursion. That doesn't mean there's anything wrong with these concepts. In my opinion, prototypes are simpler than classes. &gt;If you as a developer make something that the majority of people struggle to understand and use, is it your fault or theirs? Isn't it true that the majority of people struggle with machine code, with pointers, with recursion, and with asynchronous code? Yet all of these are absolutely essential parts of computing.
You're making a common mistake that's made by many web developers today. This is not about client-side vs server-side rendering. What big sites like Twitter and FB are doing is using both of them. The advantages you mention can and ARE being used by websites that do a lot of server-side rendering.
&gt; but I don't really feel like getting deep into it point-by-point. Just to quote the conclusion: *beat* &gt;Well let's go into point-by-point then, 
ok, edited just for you.
That property needs to be non-enumerable or it'll break for/in loops.
Like I said, I happen to like the article. It jives with my experience. But if you have a problem with the article, then go to the source. Why attack *me*?
For 15 you will also need react-dom. The render function you need is there. Loading React from a CDN therefore requires two scripts. It makes more sense to bundle your code at this point using Webpack, rollup or browserify, etc... Most people who need to use React will need a bundler anyway to manage their dependencies.
I agree with you about having a single file contain all 3 parts - although in practice, does the file end up getting pretty large?
You'll probably not like hearing this, but unless they offer you an API, anything you scrape from their webpage or try and interpret yourself will likely just be too brittle to use in any meaningful production application. Their source files are quite rightfully minified, meaning you would have to reverse engineer that into meaningful code *before you could even start analyzing what the code does*.
It doesn't break the loops. It makes them better by adding more sting.
you should decode that string... before blindly running it ... for all you know it is installing malware...
what do you mean several emails? like, you have a giant text file with full emails copy pasted into it? or do you mean you want to get email addresses out of a giant text file? This code is written sing ActiveXObject to access files, which means it requires internet explorer as the browser. a quick read of this script shows that it is searching line by line through the text file "links.txt" for any line that contains "@gmail" in it... if you just need to go through a bunch of text and pull out anything that matches the format of an email (username@domain.com) that is pretty easy, I wouldnt use javascript to do it though, it would be very easy in most shell scripting languages... are you on windows or linux or mac? Is this so urgent that you are willing to pay for someone to do it for you? edit: here is a quick way to do it via powershell (if you are on windows vista or later, just hit winkey + r and type powershell, then edit .\emailtest.txt to the path and filename you want to scrape for email addresses, paste it into the prompt, and hit enter): (get-content .\emailtest.txt).split("`n").ForEach({$_.split(" ").foreach({if($_ -match "[a-z0-9!#\$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#\$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?"){$_}})})
I would have liked you to dive into the event bind more. I understand this.zoomIn, but this.zoomIn.bind(this) gets me confused. So the first this references the scope of the component, but why isn't the second one automatically binded? 
Ahh. Linux probably does not have the Windows system font I use for one. That "Paste as plain text" is also a bit of a problem, because the menu I use the real width of the menu that windows uses, as well as the real size of the font, but for some reason that text still won't fit there. I forced it to overflow like that or else it would just disappear under the lighter text. You might be using a lower resolution, as there is very little space in your menu. The fake one is just "hardcoded" for 1080p.
Journalists who don't know how to use tenses are fine
&gt; No. If you sue Facebook over their patents, they will terminate your license to their patents, not your license to use React (which they couldn't legally do anyhow). Could you elaborate on that? Not sure what you mean by it. Thanks!
Thanks for the effort! The ASCII art made it easy to understand. Been using CSS for some years, but never knew what that property did.
Heh yeah for a startup your number one problem is reaching ANYBODY.
Author here. I realise there’s an abundance of JS XHR libraries, but I had to be able to override the mime-type easily, which is usually unsupported by other libraries. That and I wanted a simple script that was able to define reusable presets/macros. Feel free to ask questions or provide some feedback. A tiny roadmap: - Add a licence, - Add cross domain request-support for &lt;IE10, - Add a cache-busting mechanism, - Anything else?
You want to become a great programmer, not a great *javascript* programmer. read SICP (start with HTDP if SICP is too hard at first) and use JS to do the exercises.
It's the same "naming convention" as AngularFire and ReactFire. 
tests?
You can also look into the open streetmap API. It's free and open source. 
What is the reason to switch back and forth between npm and gulp? Just do everything in gulp, alias via npm.
I see, I was being ignorant.
I have yet to write those, can you recommend a library/suite? I was thinking Jasmine. I'm definitely going to look into that. Thanks.
I would prefer that also but using `gulp-typescript` gives me bunch of errors but running `npm run tsc` does not.
I'm going to assume you're being serious. First of all, you've assessed the security of my entire codebase based off the fact I've said we omit semi colons, template strings and trailing commas? That creates a mockery your certification. Secondly, this isn't hipster code, these are ECMAscript standards. Nobody down the line will want to touch the code you're preaching because it will be verbose and dated. Stop holding the web back and start pushing things forward. Stop being a dick too.
The thing about closure is that likely everybody is using it in varying capacities even if they don't know what it actually is (and consequently maybe a little limited in what they can do with it). The best car analogy I can come up with is knowing how to work on the car. Yes I can use the car and get by without ever needing to know anything about how a car works but my life would be easier knowing how to listen to what the car is telling me and make repairs. Now I'm not having to rely on someone else's expertise when something breaks down. I guess this is more or less the same thing as the tire-changing analogy :P
Potentially, although if your files start becoming too large to manage it's probably time to refactor. You can also pull the pieces out into separate files and require them individually if that's your bag. 
SICP really is that good... and the [videos are excellent](http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/) and hilarious - but more relevant than ever. I joke that SICP is like the almanac from Back to the Future II: if I want to know what the "next big thing" is going to be, I just check the next chapter. "so, today it's all about streams... looks like tomorrow will be... *flip* *flip* *flip*... ooh, logic programming! Better brush up on prolog!"
Hmm, no no no - you are doing it seriously wrong... Someone coming here asking for beginner help, you're supposed to say "Well, first you need to set up babel and stage-0 plugins, and then get it integrated with webpack. Next... how much do you know about monads?" Don't let them know it's easy and logical, we'll all be out of jobs!
https://www.npmjs.com/package/npm-run
its only a jpg file and its been sitting on github for 9 months even if there was some exploit to run code from a jpg file it'd be a waste of m$ney to just put it out there instead of submitting it to one of those bug bounty things
Well it can make the interface read-only, but whatever structure holds the data for a getter is still accessible and easy to look up. My point is not to try and make a truly private variable like in many other languages. Trust in the user and your documentation to make _var good enough for any purpose where you need it to be private. 
This is similar but polygoat uses a callback to do the magic so that it works on platforms without Promise support.
We use a structure that looks like this (in node): var q = require('q'); function mything(callback) { callback = callback || function () {}; //now the callback is optional var d = q.defer(); //do stuff if (error) { d.reject(error); callback(error); } else { d.resolve(result); callback(null, result) } return d.promise; } [kriskowal q](https://github.com/kriskowal/q) also has the ability to wrap normal functions with a node style callback and turn them into promises, maybe other libraries do too?
Ew, people are still using deferreds? And Q?!
CoffeeScript has had this since forever - the existential operator :) `val = myObj?.bar?.foo` http://coffeescript.org/#try:val%20%3D%20myObj%3F.bar%3F.foo
What problem are you solving with your site? I don't think, "Man, I wish I had a new Javascript framework" and then go visit your site or Quora or something. If I need a new date picker, I use Google. I don't expect some random site to always be up to date with the latest, or even to necessarily have good information. You probably shouldn't have been downvoted (except possibly for self-promotion), but I can't see why people would upvote it, either.
&gt; That is not at all what I said &gt; If your code were evaluated by any sort of corporate security accreditation you would fail. If feel confident in that conclusion because I am a former CISSP. Uh huh... This is like talking to a brick wall, and the irony is that you strike me as the exact sort of person I was referring to in my original post. I'm out of this conversation now, feel free to get the last word, you strike me as the type who needs it.
I'll add it to my investigation list. Very green when it comes to testing. Thanks for the suggestion.
So strip off the "//OK" -- that is just the confirmation that the data was sent OK. And you are left with a big old array. If you are using Javascript, you could wrap it in: jsonstring = '{ "data": "' + data + '" }', and then do a JSON.parse(jsonstring), and you have it in a JSON object, all parsed and ready to use. Now, actually knowing what all the pieces mean is up to you, but at least it is parsed. 
&gt;go to /r/javascript &gt;post "X is the best framework" ( make sure X is one of the least popular on /r/javascript ) &gt;angry redditors tell you which framework they think is the best &gt;??? &gt;profit
Bahh... Just messin around. Sorry. :-)
Here's a little wrapper I use for [co](https://github.com/tj/co), to support both promises + callbacks: const co = require('co'); /** Error-first-callback wrapper for co */ function coAsync(generator, callback) { callback || (callback = () =&gt; {}); const promise = co(generator); promise .then(res =&gt; callback(null, res), err =&gt; callback(err)); return promise; } function exampleAsyncFn(cb) { return coAsync(function* () { // co lets you use both promises and callback fns const foo = yield Promise.resolve('foo'); const bar = yield cb =&gt; cb(null, 'bar'); return foo; }, cb); } function consumingFn() { // promise style exampleAsyncFn().then(/* */) // callback style exampleAsyncFn((err, res) =&gt; {/**/}) }
It is valid inside an object literal, `let obj = {f(){}}` is valid ES2015 syntax.
No, it doesn't include the polyfill. You may add one or let your users decide.
These comments are good when you're learning, I used to do this too.
&gt; 1. Browser Support (what happens when my userbase uses mostly ie7?) Not sure about Angular, but IE-support on versions less than 9 isn't checked on React. Things may work, but I doubt any third party components would work on IE7. &gt; Performance with support in mind (sure react is faster, but what if I want to write a everything-friendly SaaS with massive functionality?) Then you'd have to benchmark your model / controller or whatever other pattern you are using, because React really doesn't give you that. React though is simple enough that you can stuff it into your home-brewed system (like we're doing at work), without having to change much. Angular basically requires you rewrite your entire project in Angular. &gt; 3. User-experience with performance in mind (what if my users are people that will throw the switch if they have to wait longer than 3 seconds?) This really depends strongly on what you are doing. What are you doing? 
Uh... we're trying to help you work through your actual problem. If your problem legitimately is "I want to target everyone" and "I must have more functionality than anyone else" and "It must be faster than everyone else"... then your solution is to write your own framework and buckle down for the next 2-3 years with a large well funded team because you're going to be pushing the limits of current technology. If that's not your issue, then maybe we can help.
function(callback) { callback(new Promise((resolve, reject) =&gt; { resolve("example value") } } /joke
I updated the README as it seems it wasn't clear what are the intended use cases. &gt; While you can use polygoat to promsify/thenify any callback function, it is most useful to library authors. Use it to let the users/consumers of your API decide if they want to use callbacks or promises. &gt; It is also an elegant way to support platforms without promise support and let the users decide if they want to load a polyfill.
polygoat is not so much about turning a callback function into a promise function, it's about designing an API/library that supports both https://www.reddit.com/r/javascript/comments/4eqhic/make_a_javascript_function_support_both_promise/d22l139
Deferreds are an anti-pattern and Q is flat out slower than bluebird. The only reason to use Q is in the browser when download speed is important.
&gt; unless it's a recurring event, in which case you should always be using callbacks. I am still trying to wrap my head around them, but aren't observables for this case? I do not freaking get those.
You can add properties to functions just like an object. var colors = {}; colors.red = function () { console.log("Red!"); }; colors.red.underline = function () { console.log("Red, Underline!"); };
In this case, I am worried there is will be repetition. Its okay for small copying. but if red was a longer function and underline just adds a bit of extra feature. is it possible to define that **within** red ? is it possible for underline to *inherit* from red ? thx a lot !
http://jsbin.com/vobezunima/edit?html,js,console,output here you go, no jquery dependecy either
Can't say I know anything about Observables :/ Pretty much the only time I handle recurring events is on the server side (Koa or Express) or DOM, both of which use ES5-style callbacks (or sometimes property handlers, in the case of the DOM X_X)
Yep. Uploading full resolution images from a camera at 28 megapixel resolution or whatever (sorry not megabit) for use on a website and not noticing because the page's styles have "max-width: 100%;" on all images is a common mistake, and represents a massive 10mb-20mb image for users to download, instantly breaking any performance budgets.
yeah, I thought it was "who is the fastest coder?" not the fastest typer :(
Even though Emscripten is currently the most viable way to port native apps to the browser. I dont see how it could continue to be a compelling option once wasm is introduced.
AJAX generally works on the same port as any normal web server, 80. It's just another request served by the webserver. It could be a static page, a script, a node-based server (Express, etc) or whatever. If you want, you could put a different server on a different port, but almost nobody does that.
Apologies as I'm no expert, but... What are you wanting to do? Something like this? console.logInColor = (item2Log, color) =&gt; { console.log("%c" + item2Log, "color:" + color); } console.logInColor("I'm green!", "green"); //...logs "I'm green!" in green
You can do all sorts of crazy stuff with JS, like this: function mixin (api, name) { var colorFunction = function () { return `${name}!`; }; var styles = [ 'underline', 'italic' ]; styles.forEach(function (style) { colorFunction[style] = function () { return `${name} - ${style}!`; }; }); api[name] = colorFunction; return api; } mixin(colors, 'red'); console.log(colors.red.underline()); // =&gt; "red - underline!" However, I wouldn't recommend it. It provides an non-standard API (`colors` is not a great reference) and also makes the code more difficult to maintain. IMHO a better option is just to have an API like this: color.red(); color.red({ underline: true });
A library that claims to support "both" callbacks and promises which doesn't provide a fallback Promise implementation is of limited utility IMO. Likewise, a library that reinvents or is ignorant of the dozens of popular, mature, well-documented, well-tested, and well-known alternatives is always gonna be a hard sell.
It doesn't claims to support both. It claims to allow you to support both. I don't owe you shit, if you don't like it move on :) EDIT: I see you removed the part about me wasting your time, well I'm leaving my comment anyway
You don't have to define a new variable, it's just a good practice and mimics the concept of classes. You could still technically say 'colors.red(); colors.red.underline;', etc, but as I was mentioning and matt pointed out above, the better practice is just to pass parameters into your red function as opposed to building a separate property that does it. The main thing to note is, colors.red.underline isn't a function, it's a property and those are typically reserved for read purposes, not to call two separate functions.
Yup that's what observables are for. Like in rxjs you can go with Observable.fromEvent(document, 'click') Which is like a promise (it will emit data at some point in time) but it can emit more than one value (if user click several times in this example).
Yeah, that is where I doubt people can assist - you are reverse engineering someone else's data structure. Unless you get lucky and find someone who has actually worked on this system, your guess is going to be as good as anyone else's. 
Also, I looked over the API - if you want to have strings pass into functions, here's a basic example that shows you how to access the string itself that is passed into a custom function. You just have to be careful not to override prototype functions that the String function may use: String.prototype.test = function() { return this; } console.log('test'.test()); 
same here ! I am not sure if the author of color is an idiot or a genius ! I am learning new java-script today ! never in my proffesional programming career as a web developer have I seen someone use ```__proto__``` it seems really cool what he did - his api is unique - I tried googling around but could not find a lot of information regarding this style - he also avoids repetition and also avoids having to use new - which causes excessive memory usage. its seems like a really cool trick. 
Huh, that's a lot simpler than they seemed! I keep getting tripped up on things like getting all results from promises, but then again that was a year ago and in C#. Do you know any good observable tutorials for JS? Thanks!
Hi /u/DaveVoyles, please don't use self-posts to link to content; if you wish to include commentary with your post, please leave it as a comment. Thanks!
Thank you for correcting this injustice. I keep hearing deffereds are an anti-pattern and while the `new Promise` structure is much cleaner, that hardly makes manual use of a deferred object an anti-pattern.
I stand corrected. Thanks. :)
I am trying to create a demo example of this process :( there seems to be none that exists on the internet.
See OP's addition above - &gt;it is most useful to library authors. So while I agree with you regarding user code where consistency should be enforced (i.e use only promises, or only callbacks), this gives library authors a nice service.
https://atom.io/users/tofagerl/stars Did you know you can autoinstall all your starred packages? apm starred --install 
What I'm trying to say is that the article definition of language complexity is incorrectly defined and using the correct definition, JavaScript is not nearly as complex as other languages, such as C++ The article states analyzed written code in JavaScript has deeply nested logic, thus the language is complex. This is inherently incorrect, what the article should state is that developers who write in JavaScript tend to write more complex logic (as defined by the level of nested) The articles basis that JavaScript is the most complex is wrong. That's what I'm getting at
The original author is using the prototype chain as a terribly hacky way to implement call chaining within the object, instead of just implementing it directly. People who don't understand the code are saying to this guy "just read the code," because they can't explain what it's doing either, but still want to look like they're giving advice. This guy is trying to struggle through learning from bad base code because until about ten minutes ago, nobody gave him the three function trivial answer.
&gt; that seems similar to promises. Not even a little bit. A promise is basically an object with a couple buried callbacks that says "I have an answer" or "I don't have an answer yet." This is a chain of immediate calls on an object that make new versions of the object along the way, making new calls to further change it at each step. . &gt; what is cool is you do not need to call a function In both cases you need to call a function, and wasting time trying to get around this is just making your life more confusing. . &gt; mydumbthings.red.blue() You changed the code in three completely unrelated wrong ways. No. 1. You need to make the new object. Don't drop operator `new`. 1. `red` is a function, not a member or a getter. You need to call it with parentheses. 1. That's not the name of the object in the first place. `:/`
You're being very pedantic on all points. It is like promises in the sense that both use chaining, and if OP's only knowledge of chaining is promises then so what (even if the classic example is most array functions). Your other points are only in reference to your original code, which has nothing to do with the library OP is referring to. The library doesn't use call chaining, it has nested objects where the properties can either be properties or functions. 
I prefer [Ava](https://github.com/sindresorhus/ava) these days.
I use this library very heavily. You know what the consequences are? Readable, concise, easy to write code. 
That's great. So did I, until I switched to chalk. Because they're just `VT-100` codes, you never really chain them very deeply, so it doesn't tend to cause a problem. His habit of decorating primitives did, though. That's why most people moved on.
Actually, I'm quite familiar with the library. I used to use it extensively, until I found better options.
Isn't this just a speed typing test? I suck at typing fast. I guess it's for fun, but I'm one of those slow kind of coders. I like to be thorough and such. It would be great to have simple programming problems and then trying to solve them in any way you want. Only the final output would be evaluated. That'd be cool. 
I like the [flex-tool-bar](https://atom.io/packages/flex-tool-bar) for adding shortcut icons/commands to the right side of my screen... pretty useful.
You're attacking a tangent. I didn't put effort into it. After looking into his other works, yes he's a pretty smart, but he still follows clickbait techniques: https://medium.com/@housecor An excellent source to sponsor. My example is pathos, 'Guys, lets be honest, we all know that javascript fatigue, right?'. Go to /r/diction if you want to correct people. He doesn't follow the correct guidelines of the 12factor.net but he's close-ish. His tutorials are pretty bad though, I wouldn't reccomend them except the concepts. '7 tips for getting accepted' his most recent clickbait. You're an example of the toxic that is causing reddit to be the way its become.
&gt; Not sure about Angular, but IE-support on versions less than 9 isn't checked on React. Things may work, but I doubt any third party components would work on IE7. Rewriting in angular is not the problem. Why is dropping support such a huge forthcoming? I'm targeting elderly people who might not know what the hell a browser is. It's to simplify aspects of the web to be viewed in ways they are used to, with performance of a web app via instant gratification of popular news sources and such in larger print and near-instant render time.
I like both, depends on what I'm doing. Anyway it's not about what I like it's about letting the consumers of your API/library choose and as a bonus supporting older platforms without forcing the user to load a several kb promise polyfill if he doesn't want too and he's fine with callback. It's all about giving choice. 
Uh... redefine 'help'. Going 'Gwarsh, well he don't know a single thing bout he talkin bout' is not helpful. In fact, I did not ask for help. I said 'discuss' not "Hey guys, check out this intro. Go OCD!"
What I've done here is traded a tiny tiny fraction of the gigabytes of memory at my disposal for better code legibility (especially if there are multiple potential resolutions) and fewer bugs. It's much easier to remember to always have the `callback=...` first than to be absolutely certain that you remembered the if check.
Learn more than javascript, like others have said. Limiting yourself will refine your self-fulfilling prophecy. Other than mindset, theory to practice to development. Learn a new theory every day, practice that theory, then apply it to development. A good example of a theory to practice is the [12 Factor App](http://12factor.net/)
I doubt it has any effect in real world performance, but you could always define the no-op function outside myThing
&gt; I like this. There was some uproar a while back about adding this sort of dual capability to node core but it got shot down. Yes that would have be nice but too much tweaks/breaking changes :( &gt; IIRC, the big sticking point was error handling. Callback-accepting functions throw synchronously on bad input in node (instead of passing the error to the callback), whereas promise-returning ones (it was argued) should never throw and only return a rejected promise, even on bad input. The conceptual rift was so deep that the idea of dual-purpose functions got rejected in favor of moving the promise stuff off into its own namespace. &gt; fs.readFile.promise(__filename).then(data =&gt; { ... }) &gt; What's polygoat's philosophy on this? Interesting, to be honest I haven't though about it. As you can see [here](https://github.com/sonnyp/polygoat/blob/master/index.js#L4) my polygons-made goat doesn't do any magic nor tries to be smart. That's why I'm stating that it is mostly aimed at library authors. You could use it to "promisify" any function but the result would be inconsistent (as you explained). It really shines when you build your own library/API because you can then think of both cases (promise and callback) and offer a consistent dual-API to the consumers. In this case well, never throw maybe? I never really like the idea of callback functions that could throw anyway, makes things weird if you want to recover exceptions with a try catch.
On a second thought, adding exception handling for promise to polygoat would be very easy and won't require any hack. What do you think? EDIT: https://github.com/sonnyp/polygoat/pull/2 something like that?
Deferreds *are* an anti-pattern. They are an "extra concept" to learn on top of Promises and most importantly make it more difficult to implement the contract of a promise returning function. A function returning a promise *must never throw* but reject the returned promise instead. With the Promise constructor you don't even have to think about this but with deferreds you need to either wrap your code anyway or force everyone to catch both rejections and exceptions from the function. So you have essentially lost the benefit of promises.
&gt; I changed "not a good use of my time" to "limited utility IMO". No you changed from "waste of my time". At this point I don't expect you to understand. You're spending too much time with negative comments on stuff that are "a waste of your time" to have enough time to author libraries. &gt; Not sure why you think that's a notable change given the constant changes to the README. So you think they're for you? cute 
The OP is not talking about [method chaining](http://schier.co/blog/2013/11/14/method-chaining-in-javascript.html).
Ugh, the PAIN! For front-end, a year ago I made an effort to familiarize myself with the 1500 (at the time, now almost 2000) libraries on https://cdnjs.com/ I do not recommend my approach. Your site/idea looks interesting, you just need lots and lots more (didn't see yesterday's link)
&gt; Why is dropping support such a huge forthcoming? What do you mean by a 'huge forthcoming'? &gt; I'm targeting elderly people who might not know what the hell a browser is. If that's your target market, I'd say don't use Angular *or* React. Trying to use either and polyfilling for older browsers is going to be pretty difficult.
Alright so I guess this is kind of like those typing games you play to become a faster typist, only specific to programming. This is actually a pretty good idea, if only because the keys you press for coding are often very different than the keys you type for general writing.
Yeah, essentially it's just a speed typing competition. We originally debated whether to make it about coding, or typing, and in the end, we wanted it to be more about getting used to typing code. Even seasoned programmers have certain problem keys and characters that they slow down on. Furthermore, we figured just typing code benefits the coder a tiny bit each time, ingraining syntax into their minds. Also, I watched as some friends who were obsessive with beating a certain record play a level (like fizzbuzz) over and over again. Now if they're asked how do fizz buzz in an interview question, they can do it without even thinking about it. Thanks for the input!
No way I'd hire someone who doesn't know the difference between apply and bind.
Unusual to see a framework specifically encourage the use of a service locator, considered bad practice in almost DI I can think of.
OK, thank you. So my best bet is to post it as a link (not a post), then lead a comment beneath the link?
&gt; If you don't do oop you don't need it Could you explain this? The main alternative to OOP I'm aware of in JS is a more functional/declarative approach and that _definitely_ uses prototypes.
So, another blog-oriented static generator ? Don't we have enough of those ? I'd be really interested in a React-based static generator. I've seen quite a few boilerplates, but never a dedicated project.
Talking about something like this? https://github.com/gatsbyjs/gatsby Yarn supports blogs but isn't exclusive to blog only sites. For example the documentation website uses Yarn to help automate collecting all doc pages: https://github.com/yarnjs/yarnjs.github.io
I am transpiling with WebPack for production use and it works OK. Today systems can be quite tricky, for example we have own HLS streaming server writen in Node.js than can peer-grab and restream from other instances of same server. There are some authorization and protection this that require Socket.IO connection during streaming in our case. With transpiling, I am using the same own written ES6 module for client side authorization as well as node.js peer authorization. I can also use nice features like async/await, ES6 modules and so.
Something like it, yes, but not focused on blogs - everything I see in the realm of static site generators focuses on posts and stuff like that. I'd like one which would be oriented on generating content from a CSV or a JSON, you get the idea - make it adaptable. For example, very often in the sites that I do, I need to generate pages from an array of stuff - either CSV, JSON, YAML, etc. Right now I've made my own node script which does that for me (also did something with Metalsmith but the plugin overhead started feeling unnecessary after a while). I've read the post and I see that you've started from gatsby, but I can't really put my finger on why exactly should I try out Yarn. I might play around with it a bit on a smaller project I've got going on, and will come back with feedback. Anyways, best of luck! I appreciate someone who can dedicate such an amount of time for a project, and the dashboard stuff you got planned makes it a potential tool for small to medium projects. Will keep an eye on it.
[Image](http://imgs.xkcd.com/comics/random_number.png) [Mobile](https://m.xkcd.com/221/) **Title:** Random Number **Title-text:** RFC 1149\.5 specifies 4 as the standard IEEE\-vetted random number\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/221#Explanation) **Stats:** This comic has been referenced 478 times, representing 0.4460% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d233fsw)
Never written prototype since I started programming JS, mostly doing React/Redux
It was late, I was tired.
I use pify. var pify = require('pify'); // ... exports.func1 = pify(func1);
It is, and it's there to stay for some time.
Seems like a missed opportunity consts('FOO_BA')('R', 'Z')
Along with the chaining comment above, check out the "builder pattern". I used it in Java for object creation, but the idea is the same where you append functions together to incidentally set desired properties. In Java you'd return the "this" object within each method, allowing you to chain the calls together.
Oh, that's a specific framework not necessarily a paradigm shift away from OOP.
A coworker of mine came up with this pattern, which I like a bunch and use everywhere now: function doSomething (ready) { if (!ready) { return new Promise(begin) } begin(ready.bind(this, null), ready) function begin (resolve, reject) { if (somethingBadHappened) { return reject(new Error('wups!')) } resolve('success') } } What's nice about this is a promise doesn't get created or returned if a callback is provided—which is a lot cleaner than some methods I've seen—and you don't have to do anything awkward when it comes time to resolve/reject, it works great for both.
This is like the perfect 60 second explanation of a new feature.
&gt;The bottom line here is to save transpiling for the client-side where it is still needed for full browser support. You should never add complications or additional steps to run your code where it is not necessary, and the server is one of those places for JavaScript. Keep your server-side development cycles fast, lean, and simple. Your future self will thank you. I don't think it's fair to say I missed the point of your article. I understand the nativist argument - I've been hearing it for ages, since coffeescript became popular. You are advocating writing non-standard code that you will have to replace in a year or so's time. You are also ignoring the fact that there are many kinds of transpilation, so focusing just on ES6 -&gt; ES3/5 transpilation makes the article's messaging misleading. I find this short-sighted, as you are sacrificing long-term maintainability of your code for short-term flow feelings. I decided to focus on the two parts of the article that were not subjective, since I'm not going to convince you of much value in using ES6 modules if them being standard doesn't automatically convince you. And of those two points, I disagreed pretty strongly, for the reasons I listed why.
Surely there is some irony in using a string representation of the constant to pass to a function to get the same constant back.
I'm a fan of jscs, even if there was a bit of overlap with eslint. Glad it's going to join with eslint, makes eslint even better imho. Guess I'll version bump my current projects and look to an eslint bump in a couple of months. 
Thanks for your feedback and the informations. I didn't know that. I would appreciate if you could indicate some materials =) 
Materials such as this: https://drboolean.gitbooks.io/mostly-adequate-guide/content/index.html ?
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise Using deferreds is sufficiently antipattern that it's not really even supported by ES6 promises. If you don't pass a function to new Promise(), it will immediately throw (eg. VM277:2 Uncaught TypeError: Promise resolver undefined is not a function). That said, I'd recommend using an ES6 promise polyfill instead of another library (or at least something like bluebird which is layered on top of the polyfill).
Addr- the ULTIMATE js solution for adding any two numbers. Just use Address.sum(a, b) to get the sum of two numbers. Support our kickstarter so we can develop new features, like product() and weirdlyNamedDifferFunc().
Yea, asking for a discussion on the topic definitely does NOT work when trying to define exception examples. I never asked for help
Yeah, we understand people have different preferences on how they like writing their code. The beauty of our current implementation is that you don't need to be whitespace correct. Perhaps we need to communicate that better on the site. Either way you typed above would still consider it to be correct. Unfortunately, that leaves the side effect of having no spaces still be correct and if you were declaring a variable name like var foo, you'd actually need spaces. We do have a solution in the future for requiring some spaces while ignoring whitespace that doesn't matter. Hopefully we'll be able to implement that in our next iteration! As for the editor, I bet there's a bunch of options we still haven't touched. We're using the awesome Ace editor from the cloud9 team and we didn't have too much time to dive deep into its options and documentation. We know that style is something that is impossible for everyone to agree on, so we did do our best to adhere to commonly subscribed style guides like AirBnB. For example, we had to make the call of requiring semicolons in JS, which I know not everyone uses. Thanks for the feedback!
It's really easy to write curried functions with just ES6: const map = f =&gt; xs =&gt; xs.map(f); I also don't like `bind` just because passing `null`, `this`, or `undefined` everywhere feels hackish. It's simple to eta convert it up with es6 arrows, though.
Yeah, I realized that way after the fact. My hope was that the domain in which they exist is sufficiently different as to not present any confusion. At least I hope that's the case. :X
hi harry 
[Antwar](https://github.com/antwarjs/antwar) is generic even though it obviously works for blogs too. Here's a [little example](https://github.com/survivejs/site). Perhaps that could provide inspiration for a proper solution. Note that you would have to use it straight from the repo (still in dev mode with this). I could cut a release if there is interest, though. Now it's a one man project.
Do you polyfill for environment that lack the plus operator?
If you want react and a cli then look at Ember. They basically took Reacts aiffing strategy and made it happen. 
Absolutely! And if you use Java, we also provide a `AdditionFactory` (and of course a `NumberFactory`)
It has done the same for me. Functional programming in that sense allows you to more easily predict the outcome of your code, which makes it easier to test. It also reduced dependence on state which you need to keep track of, which is always a good thing in my book. After writing some Clojure, I find myself moving away from using OOP in JS, instead making modules that expose a couple functions that might keep track of state only in the module. I use plain maps/objects and arrays to keep data. As little dependence on state makes it possible to move code around easily however I like. Since you are providing the data as arguments rather than assuming it will be there, your functions aren't as dependent on the code around them. 
Specifically, [this random number generator](http://arstechnica.com/tech-policy/2016/04/tsa-spent-47000-on-an-app-that-just-randomly-picks-lanes-for-passengers/).
[relevant Dilbert](http://dilbert.com/strip/2001-10-25)
Hi /u/unicon0987, sorry but this is off-topic for /r/javascript. However, I found this: https://en.wikipedia.org/wiki/Shakespeare_Programming_Language
At Addr.io we believe in doing one thing really well, so this feature request is outside of our scope's focus. `#wontfix`
HUEHUE LEFT PAD SO FENNY SO FENNY HEHUEHUE
These are not equivalent, to make them equivalent, the former should be: let d = q.defer(); try { doSomethingAsync(res =&gt; { d.resolve(res); }); catch (e) { d.reject(e); } return d.promise; Is it now easier to see why it's an anti-pattern? You will easily forget that catch and make your API unusable because promise users don't want to use *both* `try-catch` and `.catch()` to catch your errors. You should read https://blog.domenic.me/youre-missing-the-point-of-promises/ which is written by the Promises/A+ and ES6 Promises specifications author who is also a Q contributor. &gt; it's literally how promises work How something is implemented doesn't have any relevance to whether it's a good idea to use in everyday application code. This is like saying that computers literally work by flipping bits so it's a good idea to write code at the bit flipping level. ---- Also because `resolve` is guaranteed to be bound to the promise, the latter can be much shorter in your example: return new Promise(resolve =&gt; doSomethingAsync(resolve));
My functions are shorter and more organized. I split functions more so tasks are broken into subtasks.
There is this (long) gist: https://gist.github.com/staltz/868e7e9bc2a7b8c1f754 It's an introduction to reactive programming. It goes a bit further than just observables, but it's really interesting and written by André Staltz, a core contributor to RxJS and creator of Cycle.js (a reactive and functional framework based on rx/observables)
Happy to help out. PM me if you have any questions or "there has to be a better way" kind of feeling.
Do an if statement and check it the first character is “&lt;”. Else you know it’s not html and you can parse it with JSON.parse(
In that case people already have the choice to use promises on callback-based APIs, by using something like [es6-promisify](https://www.npmjs.com/package/es6-promisify)
Ever tried out this: http://www.codewars.com
Sounds like exactly what I've been looking for/procrastination writing myself. I'll be taking a look 
I'd say it is as good a time as any: the current version has just hit a tested "feature complete" state (hence the major release version coming out of beta/what-ever) so there is no big push to develop/finish new parts and people have time to plan the transition of effort. 3.x will presumably still see refinements and bug fixes over time so you are safe to keep using it, and the key features missing from ESLint will be merged into there so that product will improve. It is also not a bad time for someone else to fork the project and if they'd rather it continued as a separate concern.
Yes but "swipable" meaning by dragging with the mouse you can make the page scroll within its container on the page. Not sure if I'm clear, it's exactly what Chrome Device Mode does.
Impressive
Just delete the dataType, and jQuery will figure it out on its own.
 for (var i=0; i&lt;b; i++) a++; // @TODO support non-integer values for b
So what happened? I must've missed some drama, and now the old medium post is gone 
Be careful with your kerning, I read it as Yam in the title here on Reddit.
You're right that it can do a lot more - I actually removed a short reference to that, after some deliberation. However, the post is mainly targeted at those that think it's a major departure from Javascript. Understandably, that leads to some reservations regarding TypeScript that are not necessary. Once you've come to accept that, posts like André Staltz's will become more acceptable. One might then start looking at all the other (optional) goodness TS brings you, or decide it's not for them but still appreciate libraries adding type signatures using TypeScript.
&gt; .bind() is around 100x slower than a normal function Source? I use bind profusely in a current React build...
Have you looked at http://electron.atom.io/
"André, too, simply needed a catchy headline" No, I believe he genuinely thinks that, just like he thinks React/Redux is an inferior paradigm ( http://staltz.com/why-react-redux-is-an-inferior-paradigm.html ) or how he though that Flash would prevail over HTML 5 ( http://stackoverflow.com/a/9567794/617839 ).
whats the bottom number?
the point here was focusing on quality over quantity (which seems to be the current focus)
Cool. It might not be easy. Poke me through gitter for direct questions so I can guide you through it.
&gt; "Also I don't wholly understand what map() is supposed to do in this context"....what context? You gave us no insight on what the problem might be or were you're having that problem. Just by ranting I can't figure out what you're saying/asking, if anything.
Interesting! My apologies, I was having trouble getting jsfiddle to load a Google hosted jQuery file and it wasn't working. I'll try this when I get to work and if it doesn't work I'll try to get a working fiddle going. Thanks!
Didn't think I was ranting or even complaining, just asking a question. I didn't post code cause I didn't want the answer, just an insight to the broader task. /u/ugwe43to874nf4 pointed out there are multiple such problem sets out there, and I did not know that was the case.
Interesting that the post quotes wiki on TDD, rephrases the same quote on wiki ... and then ignores what that bit of wiki said. In TDD, you're supposed to start with the tests first, describing what you want, then writing as little code as possible to make the tests pass (red-green refactoring).
Thank you, I will rephrase it. Thanks again for the valuable suggestion.
Thank you :) I thought i'd post it in the Javascript area because it's kind of related but i will give that at try!
Thank you! :) i shall give this a try to.
hybridify@2 won't need promise support. meaning you can pass what promise library you want. Others, checkout the all hybrids, they are just awesome, flexible and powerful. https://github.com/hybridables/letta https://github.com/hybridables/relike both may worth looks. All hybrids works on node 0.10.
Yes, a lot of IoC containers offer a service locator, but actually using it is seen as a last resort, not the primary injection mechanism. I don't have any experience in Zend or Yii, but this is definitely the case for Unity, spring, and angular. Javascript in particular already has a module system that allows dependencies to export a factory with all of its dependencies met. Since it's not a simple namespace, you can do this kind of logic in it and not necessarily even need DI: import depA from './DepA'; import depB from './DepB'; export const someRandomExportedFunction = ({ arg1, arg2, depA = depA, depB = depB }) =&gt; { return depA.someRandomFunction(arg1) + depB.someOtherRandomFunction(arg2); } Just as much strings as most JS DI, only the indirection is clearly visible in the code with simple ES6 features, and not hidden behind magical framework. As for catberry js, I can't offer too much. I've only just now heard of it.
That's the idea of hybridify and you can do it. Wait for v2 (soon, maybe can be even v1, because there's no breaking changes) or simply try handle-arguments with handle-callback, it's easy like 1,2,3.
Since there was no reference to anything it just seemed to me like a rant. As /u/ugwe43to874nf4 stated there are more koans out there so without seeing the problem it was harder to be helpfull. You can see more katas/koans in websites like [codewars](http://www.codewars.com/), [codinggame](https://www.codingame.com/start) and codecamps like [this](https://www.freecodecamp.com/)
Their page doesn't tell me what the fuck it IS...
Completely agree with this. It is one of the reasons jQuery is still as popular as it is (and a myriad of others not related to ease of use). It's stable, goes through all the edge cases, and is a great facade. Sure if you only want a small feature and know you wont ever hit any edge cases, then yes, you may write your own micro module. Just don't release that on NPM please.
try a one way hash, can find the library at npmjs.com you get these from running the hash with the encryption key, `encrypt(secretpassword, decryptkey, string)` var passwords = {page1: '9f9f9f9f932902asadf', page2: 'aiioh323920' ...} then on your page you decrypt them with the second half of the key decrypt('9f9f9f9f9f', secondkey)
[Image](http://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2768 times, representing 2.5800% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d241u6w)
Its a desktop JavaScript run time so that you can write desktop applications in JavaScript directly without a compiler.
This. Hashing &amp; salting on the client is useless. Why? Because it's all about what your backend expects. If your backend expects a hash &amp; that hash is sent unencrypted over the wire, then the attacker sends that hash over the wire. The only thing you hide is the fact that the password might be shared with another website, and even that could be defeated through backwards engineering the salt + a rainbow table. 
I would argue against using md5. Either use nothing or use something stronger. If you use md5 on client, you'd be inclined to just store it in DB on server. That is a very bad idea. I'd go with plaintext password over HTTPS + strong hashing upon save on server. Only case where I'd argue agains plaintext password would be if it was reused for anything else besides logging in. For example decoding an encrypted container on client. In that case use strong hash on client, so that the password never leaves the client. 
Officially _finalized_ standards and officially _supported_ features are two very different things. I am advocating a realist and pragmatic position that focuses on simplicity. I am not sure why this message has been lost on you. You definitely seemed to have missed the point by saying it's only about ES6 transpilation. I think it's pretty clear that I am advocating not transpiling _at all_ on the server side in order to avoid having a build step. This isn't some anti-ES6 rant - I even advocate using the supported ES6 features at the end of the article. Everything is programming in about tradeoffs, and I am choosing and advocating for the pragmatic solution that avoids un-necessary complication. I am not sure why I am getting downvoted for that.
Substance maneuver? What in the article are you referring to? My position is the same as the title - don't transpile on the server.
The real Javascript fatigue is all the articles about Javascript fatigue 
Express had only 1 real developer working on it regularly since the days of TJ "selling it" to Strongloop. IBM acquired Strongloop and it broke the camel's back. There was an Express 5 planned, but it seems to be DOA now that the lead has left. There has been no serious momentum on it since the end of January.
That's a matter of opinion. I currently use `cli-color` because I find predef patterns convenient, because it doesn't decorate primitives, and because it carries a minimalist cursor API that's portable. `terminal-color` is absolutely tiny and has no deps. I mean, it's not a big deal no matter how you look at it. They're just terminal coloring; even if you have dive depth problems, you're never going to dive 1500 function calls deep with one of these libraries. This isn't a meaningful utility library that has to be kept high quality; it's a terminal lib. It's okay for one of those to be garbage. The world won't end. But there are something like 200 terminal color packages on NPM. If you've only ever seen the one you use and `chalk`, it's because you've never looked. That's not really worth bringing up, frankly. . &gt; Are there any *actual* benefits Yes, there are actual benefits to not decorating primitives. There are others, too, like that some of them have better dep trees, are more portable, cover more of the VT-102 protocol, &amp;c. I wonder if you realize how unpleasant your level of broadcast skepticism is, or if you've noticed that you were already given answers to the question you're currently asking a third and fourth time in two distinct threads. I get that you are skeptical of the importance of not decorating language primitives. You don't have to believe me, or the community, if you don't want to. Asking again isn't going to change the answer, though.
Salting only makes brute force attacks 'harder'. Imagine if you will that a hash contains a common word and the first attempt to brute force the hash will use a common dictionary list. **password123** would be found quickly (first round) Doing **!5@Ltedpassword123!5@Lted** wouldn't be solved in the first round. At least without knowning what the salt is. So in short it depends on what your HASH is used for; but generally more security is always better. Additionally to what others have said; md5 isn't the most secure option (really never was) but can be fine for somethings. But things like passwords should be use something more advanced than MD5. In general I don't know why you would send the password hash into a http(s) request.
Apparently there are some politics around it, but it's still very much alive and kicking. I still use it in my new projects and will continue to do so as long as it's stable and works as advertised.
Well, yes, thanks, but I'm definitely aware of all the "popular opinion" on this topic. I remember when prototype.js was still somewhat widely in use. I've been writing JS for 5ish years now. I'm talking practical things to look out for. Is it basically that if I wanted to do a for...of loop over a string I'd need to use hasOwnProperty or I'd get some weird results? Because that's something I can live with. :p I wouldn't use colors in a project where a team of 50 devs might be working on it at the same time but for my own open source projects (even highly used by other people) I haven't seen anything that would lead me to believe it's an actual problem, more like a "problem" in that it's not a recommended best practice.
But how can you explain this behaviour? http://codepen.io/dmitriz/pen/pyVvPx?editors=0100
Ah, yes indeed - that has caused us great pain with migrating our own Polymer-based framework.
I can see that. Personally, I'd have difficulty trusting someone who was comfortable sharing my text messages with the world, but it's good that he's able to put that in the past for the good of the project, and ultimately, the community.
I think the best solution is to have something large like lodash from which you can then import/require only individual modules that you need, or if you can't be arsed for all that, the whole thing.
Shouldn't you be mine? You are better help, after all. Side note: Valentine's Day candy hearts for programmers... we could make hundreds... maybe even THOUSANDS!
You're going to need to be a little more specific. Perhaps share your code so far on jsfiddle or codepen? Also you will need to realize Java and JavaScript are completely different.
What are you actually trying to do? What is your functional requirement?
&gt; Well, yes, thanks, but I'm definitely aware of all the "popular opinion" on this topic. When you refer to best practice with clearly explained technical examples as popular opinion in scare quotes, you lay bare that there is no purpose in further discussion. . &gt; for my own open source projects (even highly used by other people) I haven't seen anything that would lead me to believe it's an actual problem I don't know why you keep saying this, when I explicitly repeatedly said that it wasn't.
http://codepen.io/Thawqir/pen/revaoN i am doing javascript
hold on you spent hours searching for a library to do something, when you could have just ripped out the part from jquery you like and roll with that, or even write your own, in less time? No wonder you're fatigued...
Client-side? Don't even bother...
Use code blocks on Reddit for better formatting, please. 
My team is looking to bring on someone with io.oh and great.js experience. Looks like you might be a good fit. Do you have at least 5 years experience?
Is the API on a third-party domain? Does the API support CORS? * If it is on same domain, you can do a regular AJAX call, and execute the JS yourself. * If it is on 3rd-party domain without CORS, what you described is not possible. * If it does support CORS, you should looking to calling the API with a CORS AJAX instead of JSONP. Regardless, if the API returns HTML when there's 404 or other errors, then it is fine, it will fail silently. 
Thanks, but just because one person says it's not a problem doesn't mean I just give up asking the question. No offense, but I have no idea if you are Brandon Eich or someone who just figured out how to use jquery yesterday. You can probably understand why I might want to form a consensus on the topic rather than believe the first answer I get as gospel truth. 
Here's are the versions I use, just throw some more examples in. Recursive functions like yours and mine are probably going to be faster than reduce in the long run because of TCO (if we've done it right). Though since most people don't compose together 1000s of functions, there's probably no risk of overflowing the stack. :) const compose = (fn, ...rest) =&gt; rest.length === 0 ? fn : (...args) =&gt; fn(compose(...rest)(...args)); const curry = (f, ...args) =&gt; (f.length &lt;= args.length) ? f(...args) : (...more) =&gt; curry(f, ...args, ...more); 
&gt; Do you have at least 5 years experience? When I left college with 15 I already had 24 years of experience!
That's a problem with React, not you! :) Function.prototype.bind is slow because it has to walk up the prototype chain to make sure it's not being called as part of a constructor using "new." That's one reason why lodash bind is so much faster than the native method: it doesn't handle that extremely rare edge case. I'm not sure 100x slower is going to be noticeable when it's 100x slower than operations that take .0002ms or something, but if you're using the native bind, it's worth checking out if using the lodash version speeds things up noticeably (or maybe that's what you're already using).
This looks nice, I prefer this license over http://isotope.metafizzy.co/
It does what I want, I just need to reproduce that on my own site.
&gt;As for catberry js, I can't offer too much. I've only just now heard of it. That's exactly my point, you should try first. The example you wrote looks more magical to me than any implementation of a service locator.
But Express isn't even dead yet. It has been picked up again after everybody calmed down and went further as best buddies.
I don't mind people getting up and running easily. The main issue is that there are not a lot of people diving in the "ok i got the basics, what now" stage or the "ok i got no idea on how to do this" stage, followed by the almost impossible to find "so it seems almost nobody has done x, any suggestions on how to tackle this" situation. I think we can improve many projects if there was a bit more advanced stuff to ELI5 it. Also it seems that many people are trying to change the core of Javascript with ES6, ES7 and so on, that its very hard to distinguish what is still useful and what not. Not to mention that pretty much everything that allows you to write better code has ben locked behind some "pay us monthly" system. Seriously whats wrong with supplying a standalone package these days.
The example I wrote is pure ES6, so you might want to brush up on it if it looks magical to you. :)
you could always host the site in an iFrame to mimic the site in different sizes. look at how CodePen or JSFiddle work
Hopefully you'll put it back up: if you had said that it explained Functors simply instead of Monads, it would have achieved that goal, and it's great to have people trying to explain these concepts. Monads aren't that much more beyond Functors, the only difference is that .map takes a function transforms the values inside a Functor while .chain/.flatMap takes a function that transforms the values inside a Functor/Monad to another Functor/Monad of the same Type. Would make a great part 2 to the original post.
Still don't get why. JQuery is as good as dead in the modular phase that JS is going through now. We're at ES6, nobody is going to load a 100kb+ monolith into an otherwise modular project simply for performing a micro-option. Even if you use a couple of functions &amp; helpers, you'll be using a very small percentage but ship the whole thing anyway. npm is perfect for delivering small things that when combined only put little weight on your project. They screwed up this one time, but the principle of npm is probably more forward thinking than they may have realized when they started, as in, they're literally prepped for the future whereas Jquery is going down unless they split their entire codebase into consumable pieces. 
I don't see a real commit since the end of January on any of the branches that would see development. EDIT: It looks like you're right. They restarted, but have made 0 progress in terms of commits in the span of nearly 3 months.
&gt; If you don't know the answer, just don't comment. You were given several answers. I can't help the whoosh.
The reason to not use something that "just works" when no one is maintaining it is due to security, lack of general enhancements, the possibility that features in new versions of node are never leveraged, and the possibility of breaking in some newer version. The primary reason though would mostly be security. If someone figures out an exploit on the current version of node and it remains the current version for the next several years, it'll turn into a wordpress like situation.
Cool. Nice idea, and could work in tandem with this idea.
 file-icons@1.7.1 firewatch-syntax@1.0.1 git-blame@0.4.8 git-time-machine@1.4.1 highlight-selected@0.11.2 linter@1.11.4 linter-eslint@7.1.3 markdown-preview-plus@2.4.0 merge-conflicts@1.4.1 minimap@4.21.0 minimap-git-diff@4.2.0 nucleus-dark-ui@0.7.16 pigments@0.26.0 react@0.15.0 terminal-plus@0.14.5 travis-ci-status@1.0.0 looks like this http://i.imgur.com/Lgtrflc.png
I think, this is not the case anymore. After companies and developers are realised, Ember is one of the best and easy to use JS framework, more and more people migrate to Emberjs. It is basically the only choice if you wanna ship quickly and professionally. I love it.
FWIW I use React Lite in production. It is an interesting point though. I don't think it's a "problem" with React, though, because at the very least you could declare a local variable before entering a child scope. On a general note, I've never really fucked around with lodash or underscore... Convince me? What's the advantage given footprint? And given that in the real world most existing codebases are already going to depend on jQuery.
Cool. Thanks!
https://www.google.fi/search?q=javascript+pacman+tutorial
Of course that exists. 
Two things that I love: 1. code style and standards 2. merging groups to reduce noise and reinforce signal. Today has been a great day.
Did you try the quick-start section or the tutorial section?
More tools? Seriously? We literally have duplicates of everything related to linters / best practice / testing / modules / eg. We already have everything we need and huge diversify of developers to write good code. There's already shitload of good code - even if less than 5% of npm modules were decent that - in and of itself - is too much noise to parse through. I agree we need some way to filter the noise and consume modules without the overhead of having to manually manage the 30 or so repos I might use in any given project. Other than that I just assume OP got lost in the jungle and didn't recognize the cities already established that one can seek.
I want to play a drinking game where I take a drink every time I see an article about JavaScript fatigue, but I'm afraid of dying of alcohol poisoning.
for. fucking. real.
Those were just meant to be random names. I'll edit it a bit so it's more clear.
1995: Put all of your logic with your HTML!! -php 2005: What are you stupid?! Why would you mixup your logic with your HTML?!? - Flex/Silverlight/jQuery 2015: Hey guys! Look at this cool new tool you put your logic with your html!! -React I'm being cynical but I can't get behind React. I spend 4 or so hours learning about it and it just looks messy as hell to me. 
From the readme: &gt;No frameworks required, but if you use jQuery it integrates itself as a plugin. Is this incorrect?
I'm not sure what you mean by appear in the DOM.
&gt; About 30kb is still a sizable chunk. About 30kb is less than most images, less than a lot of web fonts, and a fraction of the overhead introduced by most of the trendy JS frameworks. &gt; If jquery doesn't go modular they'll likely go under. JQuery is more successful and more widely used than the entire Node/NPM ecosystem put together, and it has stood the test of time more successfully than almost any tool in the history of the Web. I suspect you are dramatically over-estimating how much of the Web is web apps built using lots of the trendy tools. I also suspect you are dramatically under-estimating how much pain the numerous tiny modules approach of the NPM ecosystem will bring in the future. `left-pad` wasn't an isolated example by any means, and the situation will get worse if projects continue to have crazy numbers of dependencies that lack the kind of maintenance and support infrastructure that big projects like JQuery have.
Haha yea, imagine if `shitty-router` was the most highly acclaimed routing package out there, used by Facebook proper and all.
I guess for many web developers it's just to much of a hassle to set up a build tool for client project nr x. They will use jQuery to slap on the occasional effect and AJAX call because it just works. I don't see that change any time soon. As long as there will be people building wordpress websites there will be jQuery.
[npmaddict](https://npmaddict.com/) is pretty good
I use var f = function(){}; since my visual scan is for the keyword 'var' when I am looking for allocation in a code block (ES6 aside). Further, I can cut/copy the right-hand-side as an anonymous function, if I need to move it. That said, I don't discriminate, and have nothing against using or reviewing modules written with other declarations.
Put this in your Sublime user settings. "translate_tabs_to_spaces": true, "tab_size": 2, "indent_to_bracket": true, "detect_indentation": false
ES5: function someProcedure(array) { var someArray = array.map(function upperCase(item) { return item.toUpperCase(); }); var ifBig = function() { // a lot of code }; return { sample: function ifSmall() { /* if small */ }, sample2: ifBig }; } ES6: function someProcedure(array) { const someArray = array.map((item) =&gt; item.toUpperCase()); const ifBig = function() { // a lot of code }; return { sample: () =&gt; /* if small */, sample2: ifBig }; } ... unless it's in a class, but that's more or less standard. Why? Because. /shrug. I do sometimes name my functions when passing them into map() or where anonymous functions would be used because stack traces will show the name of the method if you include it.
Consistency all that really matters IMO. Named function expressions will also be hoisted making them contextually more suitable on occasion. Edit: my mistake, I meant declarations. 
You probably used hard tabs instead of soft tabs. Hard tabs are evil; the tab character should never appear in a source file anywhere. (For some reason this is controversial.) Always use spaces, i.e. soft tabs. 
Have to learn somewhere, If it makes you feel better I thought I was in /r/circlejerk after reading this
Thanks man. This answer is well detailed without over complicating. 
I prefer spaces, too, but I have to ask: why are hard tabs "evil"? The one major benefit I can see from tabs is that we can each set our editors to represent them as a size we prefer, and not have to argue about how many spaces to use.
&gt; why are hard tabs "evil"? Isn't the question at hand sufficient evidence? Your code will be totally mangled when displayed by something that uses a different tab setting, unless you are extremely careful about consistently using tabs only for indentation and spaces for alignment, which is very subtle and often neglected. If you just use spaces then it always displays correctly.
Fair enough. I just figured they had configured something incorrectly. Without seeing the file in question, it's hard to tell.
I can totally understand your feelings. For this reason, I wrote the above tutorial, because the developer experience is so different nowadays than 2 years ago. Basically Ember is became the most easiest and meanwhile the most advance framework. Give it a try and let us know how do you like it today. ;)
I like the elegance of those implementations. I went with a more pragmatic approach. The compose uses a loop simply because the stack trace is nice and JITs optimize them very well. My actually curry implementation is much larger. I special case functions with up to 3 arguments (that's the overwhelming majority in my experience and adding 4-5 would easy if I saw much improvement). export var curry = (function () { var curry1 = function (fn) { return function curry1fn(a) { return (arguments.length &gt; 0) ? fn(a) : curry1fn; }; }; var curry2 = function (fn) { return function curry2fn(a, b) { switch(arguments.length) { case 0: return curry2fn; case 1: return curry1(function(b) { return fn(a, b); }); default: return fn(a, b); } }; }; var curry3 = function (fn) { return function curry3fn(a, b, c) { switch(arguments.length) { case 0: return curry3fn; case 1: return curry2(function(b, c) { return fn(a, b, c); }); case 2: return curry1(function(c) { return fn(a, b, c); }); default: return fn(a, b, c); } }; }; var curryN = function (len, prevArgs, fn) { return function (...args) { var currArgs = prevArgs.concat(args); return (currArgs.length &gt;= len) ? fn.apply(this, currArgs) : curryN(len, currArgs, fn); }; }; return function (fn) { switch(fn.length) { case 0: return fn; case 1: return curry1(fn); case 2: return curry2(fn); case 3: return curry3(fn); default: return curryN(fn.length, [], fn); } }; }()); 
I use `var f = function() {)` because it is consistent with anonymous functions and with other variables. I don't find that I need named functions for debugging - Firefox seems to be able to figure out names of my functions anyway in the stack trace.
I work on projects that use both and github has no problem with it. It auto detects. Nano,vim,atom,sublime all auto detect I don't have to pay attention to it. So no hard tabs are not evil. 
How dare you impose all those extra bits on my hard drive! :P
Obviously this is not the case, otherwise the person would have never asked the question, which was specifically about the fact that what looks right in their editor is mangled on Github. And even if it was perfect, Github is just one tool. Not all tools are the same. For example, creating a patch with the `diff` command and viewing it in the terminal will always use tab stops of 8, which almost always mangles the indentation. So, yes, they are evil. 
2 space is standard [airbnb style](https://github.com/airbnb/javascript)
Just a simple bot that will private message you on slack if you've forgotten to make a public contribution today. Challenging myself to make at least one contribution to open source repos daily. This little guy offers some positive reinforcement. 
Is that the whole article?
This is super helpful! 
and also it's hoisted, so I can pop that thing in pretty much anywhere I want to. BTW: const does not make the variable immutable.
Holy moly, I love it! This is great
 const sweet = function sweet(){};
The final example just returns upon finding the value vs iterating through the entire thing and possibly flipped bool? Thats your sage advice? http://www.reactionface.info/sites/default/files/imagecache/Node_Page/images/1310483866536.jpg
damn.
I don't care what that package did, I would install it just because of the pkg name.
 const doThing = () =&gt; { const foo = 'bar'; }; This is what I prefer: * it's the hip new thing * if you're foolish and try to access `this`expecting it to be anything other than the enclosing lexical scope, **things will crash and burn.** Which is good, because you were trying to write shitty code. It won't let you follow traditional JavaScript patterns, it forces you to make the switch. * _and to the guy who downvoted me (and seemingly everyone else mentoing ECMAScript2015+ syntax, of course there's still a reason to use `&lt;= es5`... and that reason is *legacy*, nothing else. Seriously. Try to make that case, please)_ * It's cleaner and I love it; totally divorced from instancey/prototypey/objectey behavior with `function() { }` * I earn the privilege of saying, "oh... I only use the _modern_ syntax" * *holds hand in front of mouth to snicker* *
You still pay the cost of *parsing* that extra JS. 
Shouldn't the title of this post really be _Building a complex web application with Ember.js 2.4_ ? 
var fn = function () {} I like to bind all my variables similarly. 
I used it a little bit this past summer. My experience with Ember itself was fine, very Railsy so it felt familiar. But my experience with EmberData was filled with frustration, possibly because I deviated from what the standard use case was.
Advantages would be cleaner code, easier to modify, etc. Disadvantages would be if you were to switch to a different front-end such as react, you would have to re-do it. There's no performance hit/gain from doing it either way afaik, it just gives you a property to work with rather than modulating the code when its not necessary. Entirely preference
Quick question, how is this (or node-webkit) any better than PhoneGap?
Good point, though I also don't like tabs because when refactoring code, it's easy to end up with a tab where you think it's a space, and once again you're mixing the 2. Unless you turn on the annoying "show whitespace" option, a tab and a space can be visually identical. Example: let sp = 1; // space between the ";" and "//" let tb = 1; // tab between the ";" and "//" Anyways, there are fair arguments for both sides... the reasoning for spaces just resonates more with me.
* It helps their own development process to have a framework for their own development team to use. * it helps raise the profile of the company as a credible technology outfit. * It helps with employment as developers in the wild are already experienced with the tools the company uses.
Spent more than an hour looking for library which builds query strings? Geez, making it by hand would be a couple of minutes. Do you still know how to code? Or you need leftpad? I understand it's pointless to invent own compression algorithms or 3D graphics engines (if they are not the project's goal), but seriously... It won't hurt if you parse some strings with regex or whatever fits. Damn, one day I wrote FSM (finite state machine) in about 5 lines of code coding live on video call, because I needed something parsed with FSM fast. And of course because I love coding for fun. If it is no fun - I don't do it. Really. I don't. I was never fired for refusing to do the job. I quit many boring jobs. There can be something repulsive in programming. If it was about spending hours to look for libraries doing the most basic things - I would definitely hate it. Don't do job you hate. Quit it. Good software is not made by people who hate their jobs. And yes, I can spend a week looking for software library like for example browser engine, complex audio/video processing library, because those are things which takes years to write for highly skilled specialists. Obviously I won't try to write my own. But if you have to use jQuery to iterate over an array or something like this just stop it.
https://www.reddit.com/r/javascript/comments/4eznkd/slug/d252mvb
&gt;It helps their own development process to have a framework for their own development team to use. Yes, but with publishing them publicly? &gt;it helps raise the profile of the company as a credible technology outfit. What kind of good comes out of this? Google is already exceptional in this retrospect, Facebook and Walmart I can understand. &gt;It helps with employment as developers in the wild are already experienced with the tools the company uses. That sounds right. But again, publishing their tools publicly? And free? Perhaps they are close to what the company actually uses? But this still creates little benefit to the companies (excluding walmart), no?
Anyone has a test-site where this is running? I'd like to know how one can start chatting with one of those bots 
Test sites at the moment are not possible because each bot has to get an approval from facebook. This is a manual process and I am yet to hear back from them after submitting one 2 days back. Till approval only developers of app can exchange messages with bot. I can share with you screenshot if you want.
Yeah, I got what you meant but it's not an IoC pattern and it still does not have the advantages I described, so in your option I see the following disadvantages: * Bad for testing, you can't easy mock modules * You can't replace implementation of any module in the whole project * You can't add a plugin to your project that depends on other modules (plugin must now your project's structure) * Your modules are strictly tied to each other which is IMO a bad practice and architecture in general.
Pluralsight
As per doc, they want to control experience. This might be like App Store review process.
Internally built closed source general purpose libraries and frameworks have less people working on them than public open source libraries and frameworks. So, when a company releases its tools out in the open it gets more developers, bug testers, and people who write documentation without having to increase the payroll. But what if those tools are so good that they provide a competitive advantage? That doesn't usually last very long. The process of developing software out in the open will likely produce something better than what you're now using internally. It is only a matter of time. Another advantage of opening up those tools is that if they ever become popular you can then hire people who have experience with those tools so you can save some time and money on training. But what about my precious business logic? There is no advantage to open sourcing the code that runs my business! That is correct which is why most companies don't open source their internal business logic. But here's the cool thing: the auxiliary tools that you just open sourced exist for the single purpose of supporting your business logic. So, by open sourcing those tools you just got a bunch of people who will indirectly support your business logic, the code that runs your company. And as an extra gift you just eliminated a bunch of bike-shedding in your workplace. In addition to that you get a bunch of free marketing. 
It's for teams who are unable to write good JavaScript (i.e spaghetti)
I'll give Erricson as an example. The Erlang VM was developed under then in the 90s, but its usage was set to be replaced with C++ and more common languages because management thought that using a propriety language made it harder to hire employees since (a) they'd lack experience in the language and (b) they wouldn't be able to work outside of Erricson so they'd simply choose against the company. Open sourcing it allowed both factors to be nullified. 
I definitely prefer named function declarations. If you ever need to debug a Node production app with dtrace, etc (anywhere you can't use a live debugger for obvious reasons), you will be very happy you used named functions. The following can be major headaches. var foo = function() {} and const foo = () =&gt; {} Anonymous functions and arrow functions like above don't have a name and it can make debugging very difficult because all functions have the same name (anonymous).
You're telling it to log an undeclared variable. Log userNameCtrl instead. Edit: userNameControl -&gt; userNameCtrl 
&gt; Javascript fatigue articles considered harmful
Not really. Stop upvoting?
Ohhh sorry, there's another mistake. Those curly brackets shouldn't be there. Just place the console.log() on the next line.
I'm only good at finding one mistake at a time apparently, you also never called the function enterInfo. On your submit button, add this property. onclick="enterInfo()"
function enterInfo() { var userNameCtrl = document.getElementById("userName").value; console.log (userName); } thats what i have now still doestn work, and removing the () from the console gives a syntax error 
Kitschy TicTacToe game I made: http://codepen.io/ForScale/full/wGoaKV The programming isn't very elegant, but I *think* the AI I built up is unbeatable... Prove me wrong! :) without hacking in to the code of course. *does feature sound
http://codepen.io/anon/pen/bpMBWZ?editors=1111
that works, brilliant thank you! :)
1. Ensure your name and id attributes on your username and password input's match. It should be name="userName" and id="userName". Personally I would only use id 2. Add onclick="enterInfo()" as an attribute to your button tag. 3. Also change the button tag from type="submit" to type="button", that way you won't get a form submit action (reloading the page) when it is clicked. 4. Change your console.log line to log out the value of userNameCtrl Works for me after doing that.
You could try http://prettydiff.com/?m=beautify Checkout the documentation so that you can run this from the command line. That would allow you to beautify your code with a git hook so that this problem never happens again and its fully automated.
2, 7, 1 and then boom
I'm working on a javascript console for mobile development https://github.com/Mat-thieu/MobLog-JS it catches errors and window.console calls, then outputs them to the console element in the DOM. Not sure if it's actually useful, but it's a fun little project, comments and suggestions are more than welcome!
I use this pattern with two changes, I use `var someProcedure = function (array) {` and I always put the `return {` at the bottom of the function, makes it very easy to find it.
Also open source is the only way for big companies to work together on the same codebase. Without it, even with contracts in place to say multiple companies have rights to some code, there's always the question of transferability (e.g. can I sell my rights to someone else? what if we get bought) and subcontracting (can I work with third parties on this shared code-base?). 
Making them open source means you don't need to maintain it so much yourself. Other developers can spot and fix bugs that you might otherwise have missed.
It should also be added that front-end frameworks are already in the public domain anyway. It's simple enough to open up a console and view your source code; sure it might be minified but with enough time you can make sense of it. So why not ask for contributions to something that is already in the public domain.
Those tools listen to config files those config files can be a part of the project. 
Here is a much simpler 'Hello World' program you can paste into the source area and compile :) mov byte [1024],0 // Change screen mode to text mode. pushb byte 10 // Push x position to stack pushb byte 0x06 // Push y position to stack (hex works too) pushw text // Push address of text to stack sys byte 5 // call syscall to draw text loop: inc r1 // Increase R1 mov byte [1025],r1 // Set background colour to R1 jmp loop // Jump back to label 'loop' brk // End execution text: db "Hello, World!",0 // Declare some memory containing text and a 0. 
Not bad, I'm guessing your phone is heating up a bit...
What browser are you using? The text on mine is baseline to the parent (near the bottom both times...) Baseline is the bottom of the standard letter. Below that is the descender area where the `gjpqy` tails go. To make room for those tails, the content box also has a `bottom` value that allows space for those tails. This is font dependent. You can see how the baseline is not the bottom [here](https://upload.wikimedia.org/wikipedia/commons/thumb/3/39/Typography_Line_Terms.svg/2560px-Typography_Line_Terms.svg.png). Edit: Looks like ~~chrome~~ webkit doesn't handle this well... Edit2: The [right side](http://i.imgur.com/YNODy7j.png) should be how it looks. This is Chromium/Webkit (left) vs. Iceweasel/Gecko (Right) Also, your other (now modified from what I saw) example [looks proper on Gecko](http://i.imgur.com/MVAnlVA.png). You can see the middle aligned box set's the precedent and the `top`/`bottom` alignments fall in line.
Interesting, that would be very unfortunate. Luckily uglifiers refactor everything, and I suppose they get that fixed if it's an issue (not sure though). Seems that it's still an issue http://stackoverflow.com/questions/29812849/firefox-function-hoisting-error
That's what an immutable reference is; the reference can't change, but the value can.
The () bugs me for argument-less functions in ES6. I tend to use _, which looks OK in anonymous functions but i wish they'd introduced something like this. const doThing =&gt; { const foo = 'bar'; };
&gt; BTW: const does not make the variable immutable. &gt;&gt; Nope. It makes the reference immuntable. &gt;&gt;&gt;No it doesnt. It's hilarious how much of ES6 is confusing. It's like javascript just got an order of magnitude more difficult as its surface area has grown, which seems like an unintended consequence.
How do you get misalignment with spaces? If you use spaces everywhere, the code should look the same no matter what.
Why don't you use arrow functions? 
Have you tested on Windows? I'm getting an error running yarn init.
Seems lie people are "loving" it over hackernews https://news.ycombinator.com/item?id=11510207
Nice! The slang is a good example.
Yes angular and hapi are frameworks. Node is an environment. React is a library. No, I don't think the code itself is valuable, I am wondering why its such a trending business stance, but many have given good examples why they are. I start to think of redux when people are talking about the open-sourcing, so I understand more now. You seem pretty Reactified. I have been learning angular for years since the beta was first announced, but am starting to like react except for jsx. Do you believe react is the way to go? I don't know about the whole 'html in js' vs 'js in html', but it seems to me that angular is higher quality but less flexible since it isn't a library. Is this a good assumption? Or is react higher quality but just easier to learn, so it creates this idea that react is not high quality, but thus creates a larger community &amp; faster growth? 
I looked at hexo but it didn't do what I wanted out of the box. I'm sure it could have been configured to do what I wanted but at that point the idea of writing my own sounded like too much fun to pass up. 
I just dislike how () looks i guess. 
Author here: Any feedback is welcome.
TL,DR; for vendor lock-in. Once you learn and develop your websites using angular or react, you just can't go back to standards.
You are being bad at reading. A "read-only reference" means that the reference is read-only. A synonym for "ready-only" is immutable. The value, however, is mutable. The C equivalent is a const pointer: you can change the value itself, but you cannot change the actual memory location. Put more simply: **reference =/= value**.
I didn't make a note of anything specific, I just googled around for instruction sets and assembler instructions for various architecture (like x86 and 6502) and came up with a hybrid, simplified set of instructions. To make something like this yourself, I'd start by making a big array of bytes to represent the computer memory, then focus on a core set of instructions like move, add, inc, dec. Then have a few variables to represent some registers and special registers like the program counter, which represents which instruction the CPU is currently executing. You can eventually make it as complex as you want, but I'd skip writing an assembler at first and just load your binary instructions directly into your ram array. Best of luck!
Hello all. I accidentally published the post before it was finished. I’ve now completed the first draft. Please have another look!
&gt; Do you believe react is the way to go? I honestly think that Ember is the way to go unless you have specific reasons to pick something else. They have an excellent track record of making good decisions about tech and rolling it into the framework. They provide a full set of architecture patterns that are almost universally followed and all their tech choices are reasonable with some arguably best in class–Broccoli, Fastboot, and Glimmer 2. I have specific reasons for picking React: the update model is compatible with Clojurescript, which I use at work, and I favor DOM diffing over KVO because it scales better and on rare occasions that matters. I write non-work js projects in my own framework. For Angular specifically, the move from dirty checking to tree invalidation for change detection and the simplification of directives to components fixes my biggest complaints. I wouldn't choose it because I disagree with the base assumptions (stateful components, runtime parsing of directives, dependency injection, scopes in ng1 and zones in ng2) but I don't have any particular reason to avoid working on an Angular 2 project at the moment. I have no idea why you'd think React or the major community initiatives around it aren't high quality projects. There's a lot of motion because people have different ideas on how things should be done. Some I agree with (router), some I don't (css in js) but I've only run into two problems in React in the 2.5 years I've been using it. The negative reaction to JSX is very common. It's really not a problem and I've only run into a handful of people who continue hating it after they're used to the idea. I'm not really reactified so much as I've been doing js forever and am news obsessed so I track the development of several dozen javascript libraries. I could probably do similar benefit outlines for open sourcing Angular (e.g. Animate is an external project, Angular in Dart, Ionic, I believe most of the core team are external hires) or Ember (huge marketing for Tilde, StateCharts was a completely novel thing when it showed up and turned into Router, and Apple's open sourcing of SproutCore years ago has paid tons of dividends for them from Ember).
iphone6 @ 30fps, no heat :) anyways, serious awesome project, i've always been sceptic about that weird javascript language but nowadays it's such a guilty pleasure :) fun times
It's an interesting and light weight experiment, but I think the name is very misleading. By calling it w3components I'm sure people will expect you are implementing the [w3c components specs](https://www.w3.org/standards/techs/components), but it sounds like you're advocating the opposite.
 const sum = (x, y) =&gt; x + y;
You just want it to not function if an hour hasn't passed? You don't need timeout for that. var lastTweeted = new Date(0); function tweetEvent(eventMsg) { if (lastTweeted &gt; new Date() - 1000*60*60) return; lastTweeted = new Date(); //rest of code If you want to implement some queueing system so that it'll report every hour only if something has come through, then that'll require something else, though.
~~You could just convert to a number~~ Edit: don't listen to me
I wish there was an easier way to offload those functions that do get a little too big, especially with Node.js. I would love to have a module which is an empty shell, and all it does it load a swarm of files, each containing one method of the module. Then it silently loads all found files and adds their single function contents as methods of the main module. Does anyone do this as an easy way to break down complex modules?
IIRC there is an option in the dev tools to disable caching.
`(1.3400000001).toFixed(2)`
The *recommended* way to deal with floating points is to use a small tolerance level: let isApproximatelyEqual = (x, y) =&gt; Math.abs(x - y) &lt;= 0.00001; 
Weird. In Firefox, when I wrap a let in parentheses, I get this error, which is diffenent from Chrome's: (let x = 0;) SyntaxError: missing ) in parenthetical
Though this will give you a string, not a number. This could work if it was going to be stringified immediately afterwards anyway, but will not be ideal if you're doing a lot of floating point calculations. 
For `const` and `let`, the kind of hoisting it does doesn't allow use of the variable within its scope but before it was declared (the "temporal dead zone"); this is different from `var` hoisting, where the variable has the value `undefined` at the top of its scope.
Tbh Egghead's content is really geared towards beginners. Dunno about thinkster.
Does cmd+shift+R work?
 tweetIt(replyto, newTweet); setTimeout(tweetIt, 1000*60) This explains why the bot replies and ignores the setTimeout. The function passed to setTimeout doesn't take any arguments. What you have now is basically `tweetIt()` after the given timeout. I think what you're after is.. setTimeout(function () { tweetIt(replyto, newTweet); }, 1000 * 60) Also get rid of the regular `tweetIt` line
I agree, but that's what I gathered he wanted from his post. He never said anything about eventually getting a tweet from the 2:10 tweet; just that it won't reply... which this will do. It completely ignores the 2:10 tweet.
1.34000000001 was just an example. It's usually 1.5000001. Since base can be a decimal (0.5 or 0.1), you get a decimal number.
Which is not going to be ideal if you're doing a lot of floating point calculations, as I said. :)
http://eslint.org/docs/rules/no-confusing-arrow This is why eslint is cool :p
http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
sure, i'll search google for you http://stackoverflow.com/questions/3184731/how-do-i-test-geolocation-javascripts https://chrome.google.com/webstore/detail/manual-geolocation/jpiefjlgcjmciajdcinaejedejjfjgki?hl=en https://www.google.com/search?q=how+to+test+browser+location&amp;oq=how+to+test+browser+location&amp;aqs=chrome..69i57.3684j0j7&amp;sourceid=chrome&amp;ie=UTF-8#q=html5+geolocation+testing
But this applies to most programming languages, in general...Java, C#, PHP, Python, C++, etc. In all of these languages, you may or may not write large, complex functions, but *statistically* it all comes out in the wash. The languages are on a level playing field, so you can apply LOC as a useful metric of complexity. You hit the nail on the head with the word "encouraged." JavaScript encourages sloppy and undisciplined coding by virtue of its flaws. And that's the point of the Seerene study.
Canadian Style Sheets are a good idea. Sure, we all hate how much cruft JavaScript has. We hate there being a dozen ways to say and do everything and that you have to learn new libraries any time you want to read someone else's code. And sure, maybe to most people the spelling of *colour* isn't important. But it's about equality and opportunity. We're all supporters of Women in Code. So why not Canadians in Code? Imagine how awesome Canada could be if we were able to program too!
Really fantastic! 
Yes but use Number.EPSILON as your tollerance. 
Hello! Using cordova on it's own has grown out of fashion due to the amount of things you are required to set it up to make it look like a semi decent app. That said, there are those who still do that, but they likely have a suite of things they've developed over time to make use of it. Phonegap isn't a different framework though, it's the non open source version of Cordova that is marketed by Adobe. Ionic is the framework you'd most likely be looking, as they do provide a number of useful mobile components, and styles. You could also look into React Native, as the community is growing at a faster rate than Ionic did. It doesn't use Cordova at all, but rather the JavaScript runtime on iOS &amp; Android to make use of the platforms' native UI components.
No, it is because parens in JS require an expression, whereas `let` is a statement. If it used to work like that, it was wrong I believe. 
Title seem a bit dramatic? If you had written a web site and it broke the way your site worked, sure. But this is just a random one liner in the console, and it's even using eval. You shouldn't even need to declare a variable for something like this anyway, if you're trying to one-line it. Anyway, gripes aside, I was bored and it's like 2am so I made my own one liner. Not using eval, because of the whole eval is heresy thing. (s=&gt;`${s.split``.join`+`}=${s.split``.reduce((r,c)=&gt;+c+r,0)}`)('1234')
Well, to start, just removing the 'w3' part would help, if that's not what you're going for. Naming is the hardest (and sometimes the most important) part of building things. Don't let someone steal that from you =)
What are some of the things you need to do to make a decent app with Cordova? Is it really that difficult? Was planning on make an app with it.
Hey Thanks for the reply ! I had a feeling about not many people use Cordova on its own. Any ideas of where I could find sample apps that are just coded with Cordova ? I tried googling it, but didn't find anything proper. I was looking into Reactive Native, but it's not write once, run anywhere - which is what ionic and phonegap offer. I know that most of the code is the same between Android and iOS, but still about 20-30% of the code is different. 
I've built an app with angular + cordova. I've no experience with ionic, does it provide a lot that I am missing?
React Native is intentionally like that. In reality, different mobile OS are very different in their ui and ux design. If you think about it, it doesn't make sense to have the same identical design across all platforms. For example if you make it look like an ios app, then it will feel odd to use on android. The only bit you need to rewrite for different platforms with React Native is the views themselves, which are trivial. 
I'm currently writing an react native app at work, and to be honest, it's pretty easy and that 20% UI difference really makes a native app feel native for that platform. We are using https://github.com/react-native-material-design/react-native-material-design for buttons and general UI widgets
I made a *moderately* simple app with React which recreates part of Imgur. You can [check the live site](http://jonoco.github.io/Img-Gal/), or look at the [source on github](https://github.com/jonoco/Img-Gal). It's more interesting than another tedious Todo app at least.
Here's a simple demo app I made while learning React: https://github.com/jbkly/inventory-system 
I'm looking to make something simple like CRUD application. Where people respond to posts, questions, share content etc. Ionic or PhoneGap would suffice I assume, right ? 
By "hoisted" do you mean "implicitly accessible at global scope"?
Sorry i only now understood what he's trying to do 
We use cordova and angular for our app in production. We've found the experience to be useful for our purposes and a good way of rapidly developing a cross platform app, but eventually we are probably going to look at native implementations to take advantage of the speed and full functionality that the devices can provide. To get access to stuff like push notifications and other native functionality, you will need to utilise the large library of community plugins out there. If you are going with angular, I'd suggest using [ngCordova](http://ngcordova.com/) and picking and choosing what plugins you need from there. The main downsides we've found are situations where there is either not a plugin to accomplish the functionality you require (so you need to write your own native hooks), compatibility issues with certain devices and the fact that a cordova implementation is never going to have the same speed and efficiency that native will give you, so process intensive things are almost out of the question. I haven't used much of Ionic but from my brief experience it is quite opinionated and they have a way of doing things you must follow but apart from that it is fairly similar to cordova. I suppose cordova is more of a "choose your own way" approach. Hope this helps you decide.
I use Cordova with React and Framework7 for UI. Works pretty well. 
Well, anyway, in case anyone wants to mess around with Cordova and JavaScript, I made an app called XWalk Cordova Github Runner. Basically you make at least two commits to master on a github repo, load the app, type the repo name in like runvnc/holoships, and it loads Crosswalk Cordova code from github under main.js. Just in case someone actually wants to download it, I think I may be pretty close to 0 downloads. But it allows you to play with Cordova without setting up any build stuff. https://play.google.com/store/apps/details?id=com.jlivesay.cwgh&amp;hl=en
Stupid AutoModerator flaired it as help.. Well thanks for answer. I just wanted some sort of discussion, rather than answer. So far it seems if you need MC, best option is Classes + Redux, and I was wondering if there's any alternative. &amp;nbsp; Edit: Uhm guys.. downvote isn't disagree button.. if anything his comment deserves upvote for being helpful.
Because waiting for someone else to approve my bot would suck balls
When you deploy traditional applications, you ship hundreds of dlls, runtimes and distributions crammed with functionality you don't need. I have a hard time relating to your example anyway, i have deployed apps on several platforms - there wasn't a single one where i wouldn't ship huge dependencies. Perhaps i must have done something wrong. With cdns and modules Javascript is in a pretty neat spot the way i see it. Modern buildtools feature your dead code elimination, for instance Uglyfyjs2. Rollup and current Webpack even eliminate code within modules, which is [far more effective anyway](https://medium.com/@Rich_Harris/tree-shaking-versus-dead-code-elimination-d3765df85c80#.19ejqlx9z). The problem is, this is very hard to realize with a monolith, or even next to impossible in some cases. An example: We have a full modular setup, using only the code that we need. That is until Jquery, Signalr and three.js come in, which blow up the endbuild and there is nothing we can do about it. I know that we probably only need 15% of what three.js offers, but due to its outdated structure it ships tons of shaders, effects, objects that are so wired in that a removal tool can't extract them. Same with jQuery. They can ignore ES6 for a while, but if they don't act something will supercede them.
I use Cordova, angular and Ionic. 
No, that's the weird thing about material design. It's just a spec, and even for a regular native app you need to implement it manually.
They have contextual CSS, so things look and feel more native on each device. That's the main benefit over doing it yourself -- things like context menus and widgets etc are all implemented specifically for each device. They also have a ton of other tools, which are currently beta so they might charge for it soon, but things like a build process (helpful for ios if you don't have one), a push framework, live deploys, and a bunch of other stuff. 
I use plain Cordova and like it. It is certainly popular to use Ionic, but I found it brings a lot of complication (and bugs) for what are basically just templates. I'd recommend you find or write some basic mobile site templates that you like and just use those. It will be lighter weight and more maintainable.
I have built an app with cordova only, without JS framework. I think it is not that much extra work, but sometimes you do not want to spend X hours to build something that comes with ionic. It is like reinventing the wheel. I was missing mostly UI components and I used [clank](http://getclank.com/) for start and then I built on top of it. But soon I realized I need some kind of structure, routing, etc. and I ended up with small framework. Probably I could have spent the time implementing features. Btw, I personally do not like ionic. If I had to build another app now I would start with React + Cordova or ReactNative. 
I like it.
Thanks
I still raise Baobab/baobab-react as an option, as it's pretty intelligible and simple once you get the hang of it. Used it on a client project and it worked pretty well, so sticking with that pattern for now until things get much more complex. You just create a tree of "state" data and then just use mixins.branch in any components that hold state. Then you just create specific actions that will each update the tree in particular ways using baobab's select/get/set/etc. methods. Baobab's "monkeys" (dynamic nodes) are also helpful because you can create stateful output based on several different parts of the state tree, and the value will only update if any of the parts are updated.
That's so weird, you'd think the library was an OS API.
I'm sorry, you rather manually write out the generated JSX objects, hoist elements that are constants to the outer scope, remove all the propTypes for production? No of course you wouldn't, that would be stupid, let a compiler do that for you. The pure class to function thing is just another thing that the compiler could do for you automatically.
&gt; Number.EPSILON I was wondering why I hadn't seen this used often. No IE or opera support. It's for ES6 environments, though it's probably easy to polyfill.
I would. Explicit &gt; Implicit. If a component is pure, write it as a function. If an element is static, create it at instantiation time. The react website even talks about doing these things as good practice. Mashing all your code into one area and then having it corrected for you is just bad software engineering. You're no-longer able to reason about your code's structure and element lifecycle. Runtime complexity becomes non-obvious. It's another layer of "learn what magic is happening outside this .jsx file" for a fresh set of eyes. I just don't see the gain.
That's funny. I didn't even bat an eye at it. Made complete sense at initial glance. 
Minification is also a good practice, do you minify your code by hand? Or does whitespace and variables longer than one letter sometimes help make your code easier to understand? Well why don't you minify your code by hand? Explicit is better than implicit after all! Clearly you are just an amateur programmer for relying on tooling to do the hard work for you! Pffff pleb
There must be a good balance between writing explicit, readable code and not doing all the work yourself. Minification doesn't exactly try to significantly alter the runtime behaviour / complexity of your code, while this does. "I don't have to worry about writing a performant render() method because compilation will fix that for me." Leads to developers who don't understand what is going on behind the scenes and get lost when they hit serious performance or rendering issues. Now in addition to what you wrote isn't what's being displayed by the react plugin, you've also spent all those days, weeks, months, *not* learning how to write good render() methods. I'm strongly against it, but I'm not the dictator of JavaScript, so it's ultimately up to the user to decide.
To start, this does not change the runtime behavior of your code. That's something you're inventing. Look, these are optimizations that can be automated rather than manually thought about and done, and at the end of the day it will catch far more of them than a human will. So (in regards to these types of transformations) code passed through the compiler will inherently be more optimized than any code your weak human brain can optimize. Use tooling, cause your brain isn't as smart as you seem to think it is.
It depends on what you want. I've never used knockout. I use Superagent - it works on Node if you ever wanted it, but I only use it on my React clients. Knockout exports a 'request' object that lets you chain what you want. request("POST", localhost:3000).attach(data).send(data).end(function(err,res){}) It's really that simple. I wrap the object in an 'unauth' and an 'auth' function so I don't have to authenticate every time. So instead of doing this every time.. request("POST", "localhost") .set('Authorization', `bearer ${JWT_KEY}`) .type('json') .send(data) .end((err, res) =&gt; {}) I can just wrap it in an object like this.. export const auth = (method, url) =&gt; request(method, url) .set('Authorization', `bearer ${JWT_KEY}`) .type('json'); //Does not authenticate a request/response. export const unauth = (method, url) =&gt; request(method, url) .type('json'); //multipart uses request.post instead of request(method), easier for multipart post requests. export const multipart = (url) =&gt; request .post(url) .set('Authorization', `bearer ${JWT_KEY}`); Then I can just call auth like so: auth("GET", url) .end((err, res) =&gt; { //Handle response if (!err) { const response = JSON.parse(res.text); if(response.status === 'OK') { store.dispatch({ type: "SET_EVENT_ITEMS", payload: response.payload }) } else { store.dispatch({ type:"SET_ERROR", error: response.message }) } } else { store.dispatch({ type:"SET_ERROR", error: err }); console.log(err); } }); }; Since I use React/Redux, I don't use JQuery. There's not much sense in including JQuery for one small part of the library when Superagent/request does such a good job. If you intend on doing a lot of JQuery, go ahead and do it. Now a-days though, it seems like you could benefit from doing basic JS more than JQuery when you can help it. 
Sure it does. It takes elements that you asked to be rendered every time and does it once then includes a reference. Obviously you wouldn't want to do it this way, but why not just write better code rather than having an auto fix button?
The main.js file is 6.3 MB, that seems excessive.
So you would rather write over-complicated non-readable code rather than letting the compiler optimise it for you? The V8 engine also does many such things to optimise your code, would you prefer to do them yourself rather than letting the VM optimise it for you?
I _think_ a more moderate/reasonable version of what /u/Mackinstyle is saying would be "understand the optimizations and why they help". At that point you can make your own decision about how you want your "source code" to be structured. The same could be said about using Babel and writing newer flavors of JS. People are error prone. I think we should all use linters because the redundant check is good. Not because we don't know how to write JavaScript but because we make mistakes when we're tired/distracted/whatever. *Edit* There are also different kinds of mistakes. Syntax (linters help with these) and logical (you're on your own here unless you have a good code reviewer). Certain styles of writing code (newer JavaScript syntax, not going crazy with the optimizations in your "source code", etc.) can make logical errors easier to spot. So that's an argument _against_ too much manual optimization.
It won't be over-complicated, non-readable code if you write it properly. V8 optimizes things "behind the scenes", so when you read source, analyze your code or look at traces, you still see your code, not something that's been altered by V8. With this tool, what I've written will not be what I see at runtime when I open up my console and inspect the React tree. This makes a valuable debugging tool unusable. If you turn it on just for production mode, why not just write it in a performant way to begin with so you're able to test with those performance gains?
Yeah, I don't understand Webkit alignment. `inline` elements should be aligned `baseline` by default so that the letters all line up (each letter is technically an inline element) so if you extend that thought out to `inline-block` elements (`inline` elements that contain other elements in a `block`) then you'd align to text baseline which is what Firefox does.
Since you already have a pretty good mobile website, just use cordova to wrap it up. There is a cordova push notification plugin, google it. Ionic: you will have to re-implement site in iconic. Its mostly angular. react: you will have to re-implement your site in react. Based on my hacker news app, I know user don't care about native look. Some user do (only after they find out its not native), but you can't have 100% of the marketplace. Cordova works pretty good for 90% of apps out there. In fact if majority of app uses cordova, mobile platform would have been in better place. These are my apps build using cordova: * https://play.google.com/store/apps/details?id=com.premii.hn * https://play.google.com/store/apps/details?id=com.premii.reddit * https://itunes.apple.com/us/app/hacker-news-yc/id713733435 and on the web * https://hn.premii.com/ * https://reddit.premii.com/
The point of extracting it in that format is so that you can parse it to whatever output you need. (https://github.com/sstur/draft-js-export-html) That plugins extracts it to html, but you might want to store it to some database, etc.
Any one use nativescript or react native?
Well, floating point is imprecise. OP should deal with it instead of modifying the results. Or use integer-based decimal math.
Glad I found this thread, I have a mobile website too and have been asked by multiple people to turn it into a native app and I have had a hard time decided what to learn. If I understand correctly, Ionic is basically just HTML/CSS/JS and React is just JS right? Could I use that as both my web version and my mobile version? I would like to avoid having to change things twice (both for the web, and then again for mobile) so I could use the same code base. 
To make a page respond to events (such as a mouse click), you'll need to use what are called event listeners. These can be added in JS through common libraries like jQuery or native JS (e.g. document.addEventListener('click', function() { // event code here }); As far as 'greying out' elements, you can add the prop 'disabled' through jQuery to accomplish this (e.g. $('#mySelectorId').prop('disabled', true);).
I didn't deal with that part of Draft-JS yet, but you can check https://medium.com/@rajaraodv/how-draft-js-represents-rich-text-data-eeabb5f25cf2#.n0eyc5rsf
Happy Cake day ! Do you mind pointing me in the correct direction on learn how to wrap it up. Or even better if I could take a look at your code if you have a Github account
I wrote a little app that recommends music artists to you based on an artist you already like. It's called [discoversounds](http://dvrylc.github.io/discoversounds) and there's a link to the source on the page itself. Hope this helps! :) 
Javascript with closures and nested call backs is chef boyardee of programming languages. 
I made those changes, and my files already look way nicer, thanks!
Are there any libraries for Cordova that give you some of the missing features?
Thanks! I don't have this project on github. follow this guide https://cordova.apache.org/docs/en/latest/guide/cli/index.html Replace the www directory with your app. Building a downloadable app is more than html/javascript. You will need to create icons, app stores dev accounts, creating a listing, building and submitting an app.
Because it's unminified well documented code. The minified version is 401kb.
&gt; It won't be over-complicated, non-readable code if you write it properly. It'll still be more compilcated than necessary. Why complicate things when you don't need to? &gt; what I've written will not be what I see at runtime when I open up my console and inspect the React tree The react tree stays the same. Just because it hoists the elements to the top doesn't mean it's different. Yes, the generated code is different, but so is any generated code which is transpiled by Babel. I don't see why you'll be against generated code looking different when you already use a transpiler and uglifier which already change your code a lot. And it's never what you've written is what you see. &gt; If you turn it on just for production mode, why not just write it in a performant way to begin with so you're able to test with those performance gains? I don't see the point. React makes several optimizations only in production so it can stay helpful in development mode. For example, `propTypes` are useful in development. But useless in production. Doesn't make sense to not add them in development only because they aren't useful in production. 
Sure, lodash, react and all his other dependencies are probably well documented, but not sure why you think he should be serving all his libraries unminified on the live site for that reason.
Hello [Straw man](https://en.wikipedia.org/wiki/Straw_man) my old friend.
Just to clarify, they are allowed (or refused) by the server you are requesting. Modern browsers allow or refuse access based on the response headers set by the server.
&gt; very, very weird implementations for some things, like history A-fucking-men. Ionic's history / back-button component has definitely challenged my patience.
[Here](http://codepen.io/anon/pen/yOjKYV) is how to do it with just javascript not extra libraries, the key is to set `onchange="myFunction()"` on your input thus whenever it changes the function will run, then your function can check the value and set the input to disabled. Also FYI this is a very common need and there's an attribute max for number type inputs.
I created [morsecode.io](https://www.morsecode.io) with React.js
Certainly Ionic, or at least phonegap. Both are layers on top of Cordova. Ionic will provide you with a good component library and it's use of Angular means you can go from nothing to a working app very quickly. On my first app I went from minimal exposure to angular (but strong js experiences overall) to a functional app in 2 weeks of hardcore hacking. 
All that adds is extra complexity, not extra security. Instead of needing the password to access the server, you now need the client-side hashed password. If it is possible to sniff the connection between the client and server, it's exactly the same security as sending the plain password to the server. The only difference is the plain password doesn't end up on the server, which could possibly be better for the user who uses "myp@ssw4rd!" on every site, but that's it. You could make this more secure by having the server provide the client with a one time salt to hash the password with, but given HTTPS is deemed good enough there isn't any point. You are probably better off spending the time implementing something like 2FA instead.
Draft-js is unopinionated on how the data should be exported. It is upto the dev on how they want to represent the raw data provided by draft-js. Once you understand the data representation, you can export it to html, markdown or even native views of android or ios. There are libraries that export the data to html and markdown as [Busata](https://www.reddit.com/user/Busata) mentioned.
Okay, I updated your fiddle: https://jsfiddle.net/x3qak2mx/1/ The body has no height by default as there is nothing in it. If you log it's height to the console you'll see it's 0. I put some content in there to show you that it will then work, as long as you click within the outline (or to the right of it), as that expands the body height. It's weird how when you apply a background to the body it covers the entire thing but that's probably an effect of the browser wars years ago. If you apply your code to the html tag it works right away, even without content. 
I can see it being confusing if one hasn't read the documentation of =&gt; before.
Instead of writing your own UI widgets and wrangling several libraries, you get one package that provides it all along with some easy to use tooling for building, debugging, and deploying. That can be better or worse, I haven't found any particular downsides though. Especially if you are already using Angular, it's going to be a very simple transition. 
Because it's a demo app? Who cares? Obviously don't do that for a real app in production. Edit: removed "tutorial" and replaced with "demo app". 
You can use the debounce function in lodash as well. You give it an interval and it will call the function at most once per interval. It's generally used to make something like handling a window resize only take effect once every 500ms (or whatever) and it would solve your use case. The reason to use that over something like this solution is that you don't need to keep track of the current time or handle checking the time in your function which makes your code simpler and easier to reuse. 
How is it a tutorial? &gt;Who cares? Well, no one, was just giving advice.
 Uncaught TypeError: Cannot read property 'createBufferSource' of null
Sorry, I meant demo app. My bad. I'll fix it. 
You underlined the main reason, people will and do reuse passwords. The second is security from the server's perspective. Trying to break a 16 character password that has been salted and hashed with random tries is hard, but breaking a 64 character hash + salt which has also been hashed is even harder. Then they have to reverse the user hash once they've obtained it from the server hash. Each layer of additional hashing slows down an attackers ability to retrieve the original password by brute force so that their other accounts are not vulnerable between when the breach is discovered and the user updates their passwords. Similarly each additional layer of hashing also adds cost to the server to execute, but if you can offload some of that hashing to the client then there is added security without additional server cost.
Nice one - Went a lot further than my toy example one - [Codepen](http://codepen.io/volv/pen/JXvLxx?editors=0010)
Netflix is another big one, here's an overview of some of the big ones from last summer: http://reactkungfu.com/2015/07/big-names-using-react-js/
Unpopular opinion, look at the stars &amp; downloads and choose the most popular one. More often than not people gravitate towards the better option, that's the whole point of ratings. Boom instant bullshit filter.
Isn't phonegap proprietary? Also do you know if people typically use a separate mobile type website for phonegap / cordova, or do they reuse the main computer focused website with some special css properties?
Umm I don't know how to code it, that's why I'm asking for help. I've been trying to go through https://developers.arcgis.com/javascript/jshelp/ but so far unsuccessfully
Not sure what you mean by proprietary. It's as propriety are as Cordova I suppose. Both are "owned" (or whatever you wanna call it) by the Apache Software Foundation. I can't say what people typically do with it, but I would highly recommend writing a UI specifically for mobile devices otherwise your app is probably isn't going have great usability. I used it to write an app targeting specifically mobile devices, without any desktop counterpart. It would be easy to share code between them though if that's your goal. 
Awesome, thanks! worked perfectly.
No it actually is open source. They're basically the same, but Phonegap ties into other Adobe services if you want. I've used phonegap build, which is actually pretty great (for a PC dev who can't build Apple dists -- though I do still need MacInCloud to upload it but that's really cheap). There's not really any benefit to using pure Cordova, but using Phonegap gives you some advantages. 
what stops someone from just allowing everything indiscriminately, other than good sense? Edit: nm I rtfa
Would love to join if a spot opens up...
Plex just rewrote their web player with react. 
I hear what you're saying. You want a nice looking product page for your nose app. Wordpress is easy. Find a nice template and you're ready to go. You could also do a Github page, Squarespace site, Launchrock, etc. Spend your energy on the app, unless building a product page is what you want to do. 
This is really interesting! I love how smooth thesite is between navigation steps. I'll have to investigate this technique a bit more. Thanks for posting!
I dont really have to rebuild it, but my company wants me to learn some mobile dev and I was planning on giving it a facelift soon anyway. My site does have a php/mysql backend tho. So it sounds like I can't simply wrap it up in cordova and would have to rebuild it in react or ionic.
Restricting boundaries is pretty targeted, I don't know how to be more specific
What have you tried? What specifically isn't working? I might suggest doing some JavaScript coding exercises (I like exercism.io) if you aren't to the point where you can at least try out some code. 
Glancing at the API docs, I don't see anything about restricting the boundaries of the map. You may SOL in that respect. You might try asking them directly if such functionality exists in the API. 
Thanks onchange I knew I was missing something as onclick didn't work and I couldn't work it out. it is a common need but everything I found online was quite complex but for what I need to build i want to keep it simple.
Oh yeah, I totally see how it could be a bit befuddling. It's a bit [like the `while(i--&gt;50)` syntax](http://stackoverflow.com/questions/1642028/what-is-the-name-of-the-operator). I've just been working with arrows for so long I didn't even see the confusion at a glance.
According to this: https://twitter.com/tomdale/status/714888232018640897 it's faster on a fps test, but slower on first load. I've no idea what's up w/ comparing Ember 2.6 + Glimmer2 to Glimmer2. Also, pretty graph with no actual numbers and no link to bench code is kinda... fishy. If one's interested in a more batteries-included React-like framework with good performance, then they might want to take a look at mithril.js
Awesome!
Check out this project :) https://github.com/anorudes/redux-easy-boilerplate
It's been going on for a quite a long time, much longer than Google has been around. It's simply gotten easier for open source projects get visibility, become community maintained, and get pulled as dependencies into other projects. GitHub and NPM (and other modern module management systems) have played a large part in facilitating this. 
Just because you can deobfuscate the code doesn't mean it is public domain. There are many front end libraries that have restrictions on their use despite the fact that you have access to the source code. Accessible to the public != public domain. 
Nope, definitely not. The services are standalones, you can choose to use them or not. As for the actual development/configuration of phonegap, all cordova plugins and stuff also work. 
I personally dislike tabs because they **force** you to use inconsistent indentation. What happens when you want to align some code that's not on a tab boundary? You use a space. So you are in fact using spaces, sometimes, for indentation. I value consistency and dislike special cases in the logic of my code, and that extends to the formatting of my code. 
Is this a school project, if so you should try and fail a few times yourself before jumping to looking right at a solution. To answer your question though http://codepen.io/search/pens?q=pong&amp;limit=all&amp;type=type-pens
I'm using keystone.js fairly successfully. It's node.js, express, handlebars. Building out a simple blog and CMS would be easy with it.
Very interesting. Transparency + visibility. Whoever found/started this trend is ingenious.
It sounds like you need a marketing site. There is no need to build a marketing site or a blog in pure JS. That would be very silly. Use Wordpress or even something simpler, like Jekyll (static page blog engine), to build a content-driven site. 
Well now I know how to say "eat shit" in morse code. Thank you. 
Parts of airbnb.com and the hipchat desktop app (not sure about other devices). Both interesting to look through with chrome dev tools open. 
Yep, I do this all the time. Like anything, it's not ideal for every situation, but it can actually make building a website incredibly quick. In most implementations, I have a really basic CRUD API on the backend that lets me do something like api('foo', 'read') from JavaScript. I can pass it arguments to filter the data down but for most things you just want to grab everything. I combine all of that into a single API call, then store the data in a simple JS object called the cache. No need for LocalStorage. The cache object is now literally a copy of the database tables I care about. JavaScript then has it's own custom CRUD API. I can cache.read('foo', {'bar': 'a'}) or cache.get('foo', '1) for example to get data. For large datasets anything other than an ID lookup can get slow. This allows me to navigate to test.com/articles/5 for example, and then do var article = cache.get('article', 5). Then just plug in your favorite JS templating engine or just build the DOM yourself. Overall it's really freeing. A single API call when you load the page to get your data, then just worry about the website instead of worrying about getting data all the time.
Cool, I would make a suggestion that the red dot should pulsate or something to make an idiot like me realize how to start. Even though there's instructions I think the dot, blinking or something every now and then would seal it.
This approach lends itself well to redux apps. Redux's createStore takes an initial state value to seed its client side store. You could pull and store that state in localStorage and retrieve it on app startup. I think there are some complications that can arise though like invalidating this data and the like.
Alright, I'll bite - what am I supposed to be seeing here exactly? Outside of your standard stack overflow argument.
I'm not even positive if there *is* difference between the code lol. All of Adobe's addons are tools on the side, I don't think there's any hooks in it. 
So a guide for one works for the other?
Basically, the programmers.stackexchange community always puts down JavaScript wherever it is brought up. My comment was the last one in that picture. It's basically responding to the first comment about how we our actually wasting MORE of our time *reading* their comments complaining about JavaScript; as compared to their time crying about the language.
I get what you are saying but honestly there's nothing we can do to stop it so we have to find a way to "curate" npm for our needs.
On my last project (in Angular), I used Semantic UI. I loved it. Whenever we needed something Semantic UI didn't have, like a date picker, we pulled it from Bootstrap and wrote our own templates using Semantic styles. I have only really prototyped in Aurelia, but dynamic controls were way easier to reason about.
The thing about books is that they're so structured. This is perfect for learning, but everything is nicely packaged with a bow. It's like programming back when you were in college compared to your first real gig. I'm not saying that books don't have their place. I refer back to a couple of reference texts often enough. Once you get the basic structure and syntax, however, move on to projects. They don't need to be anything extravagant, but do something that will push your abilities. A personal example I can think of is callbacks. When I first learned about callbacks in JS, I thought I understood them. I couldn't have been more wrong. I had to write a callback to update page info after data had been calculated as sorted. The issue was that it wasn't some simple, clean scenario that matched the structured tutorial. Many months later, I had another callback situation with jQuery. Again, this was nothing like the tutorial nor the previous situation. TL;DR: Learn the language basics, roll up your sleeves, get your hands dirty.
This is really good advice, however, I struggle into finding hobbie projects that are *actually* useful. I can come up with project ideas, but they are mostly things that already exist, not something that will solve any problems or that will have a significant use case. How do you go about this?
&gt; "A straw man is a common form of argument and is an informal fallacy based on giving the impression of refuting an opponent's argument, while actually refuting an argument that was not advanced by that opponent". &gt; "The main.js file is 6.3 MB, that seems excessive." &gt; "Because it's unminified well documented code. The minified version is 401kb" &gt; "not sure why you think he should be serving all his libraries unminified on the live site for that reason." See how the Straw Man applies here? He's refuting an argument I never made. &gt; also, ironically, pointing out someone is using a logical fallacy weaken their argument can also be called a "straw man".. Yes and no. That's the beauty of a Straw Man argument. His point is valid. But it is also off-topic and has absolutely nothing to do with the statement it is responding to. So by responding to it you're inherently joining the off-topic derail. The problem is if you don't respond retards will think he's made a relevant argument. And if you do point it out you still get down voted because this is reddit.
You could also try something hackish like (document.body || document.getElementsByTagName('body')[0] || document.getElementsByTagName('frameset')[0]).innerHTML += '&lt;img src="image-url" /&gt;'; Maybe you meant something about the [`Image`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image) constructor.
Pretty cool. I didn't have any errors.
The author addresses this in the readme. To paraphrase, Typescript/Flow are by and large better solutions, but there's still a place for **duckless** if: 1. You don't want to use a transpiler 2. You're using external data (e.g. json from an api response) and want to enforce a contract on it. Situation #2 especially seems like a great use case for runtime type system 
[Brickout](https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript) was the program that really got me into Javascript. One issue with Javascript is because there's so much interaction with the DOM it becomes hard to separate learning Javascript from learning HTML. Working with the canvas API makes it really easy to focus on learning Javascript. As for books, my experience, and pretty much anyone I have have known who programs, find books extremely boring. They're good to have around for a reference, but for learning it's better to just look up code examples, type them out, compare the results and then go back and learn how to tweak and configure them.
I myself have started relearning JavaScript one year ago, and I'm loving it. I would highly recommand : * the [Crockford on JavaScript](https://www.youtube.com/playlist?list=PLK2r_jmNshM9o-62zTR2toxyRlzrBsSL2) video series * the book *JavaScript : the Good Parts*, by the same. The later is a slim tome (150 pages) but each page is a treasure of insight. It was first published in 2008 and a few paragraphs were outdated by ES5 and ES6 but still worth it. (actually it may very well be that ES5 and 6 took heed of Crockford's ideas). Currently I am focusing on the following traits, which can be safely skimmed in early stages but that become important when you advance : * the event loop , asynchronous operations and callbacks * prototypal object model * [namespacing](https://javascriptweblog.wordpress.com/2010/12/07/namespacing-in-javascript/), modules ... So far I barely touched node.js but it is definitely on my to-do list. A next step will be to investigate and put to good use tools like Bowser, Broserify, Require.js ...
&gt; his initial comment was that the file size was quite large for a live site No, it wasn't. Perhaps what he meant - not what he said. &gt; This one guy Socrates was downvoted so badly by his people that they forced him to commit suicide. What has this got to do with anything? &gt; You can handle reddit's criticism. And you can boil an egg, I presume? Again, what has this got to do with anything? &gt; If he removed "you think", you wouldn't have seen his argument as flawed Quite right. He's refuting my argument by refuting an argument I never made. His argument isn't flawed regardless - and I never said it was, I implied it was a Straw Man argument, which it is. It's not the argument. It's the fact that he's refuting my argument by attacking his own made up argument. Putting words into my mouth so to speak. This is not rocket science.
Is the proper way to respond to this to not respond at all? I don't know.
I actually wanted to learn Javascript vanilla and then use the website I want to build my client as that personal project. I have a very good idea that he will certainly like. He is a vet. This is why I put in this raw material. I was going through freecodecamp and I thought there were gaps that needed to be filled. The idea is to learn Javascript from the ground up before entering the lab to conduct practicals. I fear jumping right into the chemistry lab without knowing that water to acid is bad bad and the other way around is right. The thing is I want to avoid spaghetti code and since JS is a loosely typed programming language spaghetti code is more likely to happen.
While frameworks may come and go, there are certain abstractions that provide good training wheels before you dive into vanilla code. I usually recommend jQuery since the abstractions are fairly easy to explain, and it's an industry standard in many cases, and not in the same category as the SPA/MVVM frameworks like Angular and React. Once you become familiar with jQuery is when I'd learn the vanilla equivalents. 
if you have words like `var words = 'foo bar baz foo bar baz'` you can remove dupes by doing: var nodupes = words.split(' ').filter(function(x,i,arr){ return arr.slice(0,i).indexOf(x) == -1 }) and then its an array; if you need it in a string list add `.join(' ')` on the end maybe you can use greasemonkey to add the script to the page. edit: added arr, was wrong before sry
Pro-tip: In HTML5, the only *required* parts of a page are: * `&lt;!DOCTYPE html&gt;` * A non-empty `&lt;title&gt;` So you can remove all of that `&lt;html&gt;&lt;head&gt;&lt;body&gt;` boilerplate and still have valid markup.
Sorry I just love the opportunity to throw out a strawman when I get the chance.
https://jsfiddle.net/1es0svuv/
Good, I'll take it back. Have a nice one.
[removed]
Not a major point against this in favour of Flow, especially given that his 2nd assertion (runtime validation of external data could be useful) is valid, but one way to have type safety is to use Flow's annotations in comments, thus removing the need for transpilers.
I like your approach, and I don't think it's too different from what I explained. I could still watch those kind of videos and get something from it. But before my "realization" concerning code abstraction and "need to understand everything", I would be frustrated and not feel like I got something out of it. Now however, if I watched those it would kinda videos I could view it from a similar standpoint to yours - soaking up what I could, and be inspired/puzzled by the advanced parts that seems like magic.
Oh exactly what I was looking for! Thanks! Searched over 300 threads and couldn't find that one ..
Use wordpress. You're basically looking for a landing page + other elements. If you open up the question a little bit... there's other blogging/CMS software that might be better suited for you too.
This is cool and all, but...why?
I'm not a developer, but would like to hear some thoughts on this. Is this a "nice-to-know" kind of thing or are there some real benefits for web development here? What problems are being solved here?
only 2 seconds of googling found this https://webqr.com/about.html Never used it so wont comment on its quality, but i just ran a newly generated link through it and it worked fine. ps. be sure to try find the answer before you ask others
I'm assumimg the name is trying to copy JSX. JSX is JS and XML, is this CSS and XML?
Use [jsfiddle](https://jsfiddle.net/), easier to see it working and to read the different parts of the code.
I second the camp to learn in the context of a framework. Frameworks often force you to learn best practices. People often avoid frameworks when starting out because they don't want to incur the initial learning cost. Hacking things out on your own is much easier to get started and rolling, but you'll likely end up with a mess of code that not only doesn't do much, but you also don't learn any useful conventions.
I feel dirty after reading that.
Can't you just do inline styles in JSX? https://facebook.github.io/react/tips/inline-styles.html
I think you're right.
You can, but this supports hyphen-separated CSS property names! Such clever, very wow etc.
Jesus this guy don't stop yanking on and on about how JavaScript sucks. Ffs.
**Unless there are JS libraries for features like blogs and homepage content that are production quality out of the box?** Jekyll with github pages? https://pages.github.com/
Hi /u/creativebrains, This is plagiarism: http://www.tutorialspoint.com/javascript/javascript_overview.htm
I already tried that out and it kept crashing. I already searched google for an hour and tried out almost everything to no avail. I asked reddit because often times people will have found their own ways to do this stuff. 
Do you get any error messages when it crashes. Have you looked into the github page for that plugging for anyone with the same issue. You could raise a bug on the project or try dig into why it's not working, fix it and report the fix back to the dev
We're currently discussing the topic https://github.com/sonnyp/polygoat/issues/9 if you're interested and/or have feedback.
Intermediate to Advanced (IMO): https://github.com/getify/You-Dont-Know-JS
&gt; Can I ask what news feed(s) you follow? This subreddit and hacker news are about as fringe as news feeds get. If you want to know more you need to follow people on twitter / github.
This blog is literally just one guy's rants on Javascript. It all just reads like some bizarre attempt at navel gazing from a dude with a chip on his shoulder. I'd be willing to take it more seriously if it weren't for the author's comment on a different article that recommends avoiding the headache of JS frameworks and just using Jquery. I mean what? I certainly don't think JS is perfect but this seems like a pretty bizarre way for the author to spend their time.
name taken thou
Yeah I'm not sold on it, but what I was responding to was the point of this. And the point is to try and provide modular css. A better way would be to observe the route and load css partials with the modules that will be loaded on that route. I personally don't think writing css in javascript is a solution whatsoever, but again, was just responding to what the point of cssx might be.
I'm currently working on a commercial SPA. Admittedly we use SASS (SCSS syntax), but we use conventions such as BEM to manage our specificity, thus we have small files representing the styling of our respective components, which are bundled at build time. This problem has been solved for a long time.
The less dependencies the better.
I'm not familiar with the term "CSSX", but the article is talking dynamic CSS, not modular CSS.
I don't get it: am I supposed to be looking at a documentation page or a documentation tool?
actually what confuses me is. where do we define the part to check if the user is at the bottom of the page? do we define that in the `component` itself? 
The article's title is `Finally, CSS In JavaScript! Meet CSSX`
&gt; do we define that in the component itself? Add your listener in `componentDidMount` and remove it in `componentWillUnmount`.
Hmmmm.... wondering if you and I work together.... lol
404
try again, it's a medium post. here's the link without the #tag if it makes a difference https://medium.com/@lpaulger/modularize-legacy-javascript-2758ffcdcd3e
It's the doc generated by https://doclets.io . You see the API-Doc pages of node-spotify-web as generated by doclets.io. what's your opinion on it?
Finally? Why does EVERYTHING need to be in JS?
I also prefer Baobab over Redux because I find it simple in comparison. Many of the abstractions that Redux creates only become truly useful in large projects, and in smaller projects only create unneeded complexity. Of course, this is in part because Redux is the "MC" while Baobab is just the "M", but writing methods directly on the React components to update Baobab's state has worked well enough as the "C" for my projects.
&gt; The nice thing about having all local references is that you can hack away on your chunk of the code without caring about the system as a whole. But that benefit doesn't apply to this library, does it? What he's doing is sucking in CSS strings and appending them as literal &lt;style&gt; elements to the document in the normal global CSS scope. 
Every tutorial I have looked in google is already outdated is it really this fast in the front-end? 
No, `componentDidMount` on the list itself would be where you put the scroll listener. You'd have the ajax call in some other method and do a `setState` when the results came in, which would cause an update. The `componentWillUnmount` would just be preventing event listener leaking.
Lol, wish I had some to add here. Would love to see some more. That Browserify/Nodal one is too great. Like, what?!
Lodash works with arrays, objects, strings ... [65.1Kb] This library just with strings. [14.6Kb]
Pretty much anything where people are angry and demand the application be modified in some way. My blanket answer is something like this: https://github.com/Glavin001/atom-beautify/issues/565#issuecomment-210078645 If you want the ability to demand things without contributing back to the project then need to be a paying customer.
Loved the elegance of your font rendering, took me some time to decipher it all, but it was lovely. Really good work. EDIT : I wrote font, but I meant your line rendering.
It's quite funny. In the *Programming* subreddit, the feeling is that Reddit users generally **hate** JavaScript. They are much more sympathetic to these articles. I guess since this is a *JavaScript* subreddit, I should expect a much different reaction. I didn't expect to find a fan club. My bad.
I am just going throw these two in https://github.com/css-modules/css-modules and https://github.com/gajus/react-css-modules
np :) any reason for ArcGIS? Leeflet and or mapbox is way easier to manage IMO
Haha, if you work at an online fashion retailer then it's possible!
Yeah the general tone of that issue makes it seem like their concerns are gonna become the team's new top priority. &gt; If this is distressing it might be better to use an editor with a conservative constricted license that you pay for with money. Well put lol.
Lots of people say "don't reinvent the wheel", and in general I agree. However, reinventing the wheel is a great way to learn how wheels are made and how they work. Side projects don't actually need to be useful or original if they are for learning. Just pick something that you find interesting. For example, make your own mini version of Reddit. I guarantee you'll learn a ton doing that.
I stay sane by using proven technologies and not letting the siren call of this stuff trick me into using it at work. ;) It's super fun at home, though.
Hmm, that does make it sound like that's what the name should refer to. Its main connection with XML is still just the looks, though :P
Thankfully I only skimmed and scrolled, so I'm only a little dirty.
All of them.
I spent the last 2 years working on a large SPA. I did not run into this problem.
Maybe. I'd need to see a use case where this was a better answer than existing libraries/methodologies.
Ain't that the truth? I don't know how many times I've been excited by a new technology or other idea only to come to realize it has little value in my *current* paradigm. That is, it's perfect... for some future I'm not in yet.
All of coding is about convention and discipline, why do people like you treat CSS any differently? It's not special at all and it's not hard to use or maintain. 
"Dependency removal" just to insert their own library which is just another dependency.
Jesus I thought he was kidding on the "DO NOT CROSS ME" one until I read the [issue log](https://github.com/ParsePlatform/parse-server/issues/1050). &gt; WHO TAUGHT YOU TO CODE? RANDOM GOOGLE QUERIES? Haha.
I had someone (indirectly though my boss) submit an issue once to add localization to an internal SPA because apparently we hired someone whose primary language was French. Looked into it and the person hired was our English&lt;&gt;French translator. Order stands. We implement localization. I had to send this guy a spreadsheet so he could fill in all the translations because (surprise!) he's the only one at the company who speaks fluent French. Over time he sent a few corrections. Corrections to his own translation. Based on re-reading the English version... In the application.
Most of the most annoying ones I've come across is when a particular project is aimed at a non-JS stack and someone comes along and ask when are they going add support for Node.js E.g., Asking a Laravel or Rails based app when are they going to support MongoBD **Edit:** I already know what NodeJS and MongoDB are. I made reference to MongoDB to because the request was from a project that clearly needed a RDBMS for its models. The request came at a time when web-devs were NoSQL crazy. People were rushing to use MongoDB just because it is "web-scale".
Last 3 for me, I believe the solution here is a crazy concept: writing clean and easy to understand CSS. Shocking I know. 
Oh for fucksake...
It took me a long time to admit it (especially coming from a Windows programming world) but CSS is coding. You have to treat it like you do other parts of your application. It needs to be clean, DRY, etc.
https://github.com/casesandberg/react-color/pull/18
Absolutely, SASS makes it even more so. Following those simple rules makes it so easy. 
that depends on what module type you're using. I believe by default webpack uses CommonJS and it's not possible to do "tree shaking" on that format. Definitely true for ES6 modules though.
lol Nope! Same setup though. :)
I have no idea if that dude is right or not but "DO NOT CROSS ME" doesn't even do justice how out of control he got: &gt; DO NOT CLOSE THIS ISSUE, ASSHOLE. YOU HAVE INTRODUCED A NATIVE LIBRARY DEPENDENCY THAT BREAKS THE WHOLE FUCKING INSTALL ON ALMOST EVERY FUCKING MACHINE. MAYBE IF YOU NODE PROGRAMMERS COULD ACTUALLY CODE AND DIDN'T RELY ON NPM INSTALL for 90% of your shit tier code. &gt; &gt; -source I have a trophy in competitive programming solving and can code ibm 390. Do not cross me.
I tried to be as ridiculous as possible, which means that even why I try to be as ridiculous as possible, I'm still not as bad as actual people complaining. 
did someone compare to https://github.com/Khan/aphrodite ? edit: ahh, i see, this is plain ol javascript, aphrodite is only for react
When you require or import lodash/padStart it'll only include that and nothing else, commonJS or not. Should padStart itself contain exports that aren't needed Webpack will not be able to get rid of them unless it's a ES6 module. In a proper ES6 environment tree shaking will have little benefit, but it matters a lot when you work with modularized monoliths that [export everything in a single entry-point](https://github.com/rollup/three-jsnext/blob/master/src/index.js).
Must've got that trophy after SEAL training.
The problem is that you're comparing apples to oranges. That's why these frameworks were created in the first place. To clean up jQuery's mess.
But good CSS is clearly not easy to write; if it were so, there wouldn't be so much bad style code around. CSS has simply never had the kind of scrutiny that JS has had, and that means that lots of front end developers with strong opinions on effective scripting still have low expectations of style code. They think it's okay that you can't reason how something looks until runtime. They think it isn't a problem when the stylesheet has to know about a DOM structure that is only implicit from template partials. They think it's OK to use descendent selectors, overload attributes with styling, scripting and test behaviour, allow specificity to increase and shrug when it becomes impossible to style elements without cracking open an element inspector. We've all met developers like this, and use local styles is one way to mitigate these bad habits and make good practices simpler to implement.
&gt; the main difference is that you usually only render the visible set of items This is interesting. The crux of this idea is that the (potential) gain of not rendering above-the-viewport content is greater than the cost of re-rendering that shit if someone scrolls back up. Not sure I buy that. In any case, isn't React smart enough to deal with overlapping state-changes? I thought that was the entire point of the virtual dom? 
I've also spent two years working on SPAs, and I _have_. And these were not tinpot organisations.
Locality of reference; a single file per component; I'm guessing better portability across multiple applications?
&gt; But the last part sounds totally normal to me. Human beings make mistakes and they correct them if they. Well, I'd agree if we had other French customers. But if he understood the English well enough that he was able to refine his French localization we probably didn't need it to begin with.
Same boat here too. I'm aiming for a true Front-End Dev roll and JS makes me want to pull my hair out.
Also laravel does have third party mongo support!
Why not use lodash' flatten() with join()? _.flatten(["foo", ["bar", "baz"]]).join(",") // =&gt; "foo,bar,baz"
I have a moderately-popular angular lib, and this one guy opened an issue where he had run my source through a linter and it generated a load of errors. Fair enough. But rather than, say, suggest adding JSHint to the build, he left this classic: &gt; Basically this needs to be rewritten from scratch. I'm going to rewrite it. it is disturbing to me that people write code - don't test it, clean it and make sure it is 100% error free - before releasing it to the public. My response riled him up even more, and he then went to *great* lengths to inform me how right he was, in painstaking detail. If you want to kill five minutes, [here's the issue thread](https://github.com/michaelbromley/angularUtils/issues/300). **EDIT:** Thanks for the response, everyone! I'm glad I could provide some laughs. Just don't go hunting down the guy and calling him a dick, please. Also, the new GitHub emoji feature has really come into its own on that thread :D 
I just implemented react infinite in my application: https://github.com/seatgeek/react-infinite It's working great so far, couldn't be happier.
As long as we're nitpicking, the arrow is a little stretched.
Poe's law'd
Or just construct an array and then use [Array.prototype.join](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).
Looks like you can use pseudo classes (unlike with react built in styles) with this, so you could ship a react component without needing the consumer to care about your styles, it's completely encapsulated in your js code. I'm not sure if that's worth it but those could be nice. 
I'll have to investigate if that's possible to implement with comparing to the DOM and not against the previous items.. Maybe would need to save the key property with the DOM element or something. https://github.com/pakastin/frzr/blob/master/src/setchildren.js
more than that, even: i feel like this was developed as a *parody* of jsx. i felt certain this was a joke, then i looked at the comments...
It hurts the eyes.
After looking through all the code, cleaning it up a little to make sure nothing was going to happen. It boils down to the last line that becomes: window.top.location.href="http://...not going to post url..."; So basically it is trying to make you go to that page. Edit: took out url because I don't want to be responsible for some idiot actually going to the page or any sort of google ranking they will get for having their url plastered everywhere.
Heh. Good laugh. I don't understand people's reasoning about open source. IT'S VOLUNTEERED CODE. 
Oh, sorry, I am an idiot, I was somehow not seeing the full sentence.
Github creepypasta.
Thanks. That works well for making a list out of all elements of an array. The cases I was thinking of, however, were where I've needed to build a list inside some kind of iterator based on some kind of logic. I didn't start with a nice, clean array. Though, now that I think about your idea, it might be a better pattern to Array.push() items that meet the criteria and then Array.join() after all is done. Thanks for the suggestion.
This is only confusing if you don't know the difference between value and reference. And if you're a programmer and that's the case then, holy shit...
"heh - of course my code functions properly" fuckin' guy
Thanks. I really appreciate it. I now know I'll be able sleep better tonight. You're a life-saver.
Your reddit app probably broke on the angled brackets: https://i.imgur.com/PMRuAX5.png
Nope! Never saw the need for them.
That's why you can still use your sass/scss syntax inside the style tag, as long as you specify lang="scss". Then, afterwards, you just import your variables like you would in any other sass file.
This would give my cs professor a heart-attack. 
Yes, it seems that's exactly what happened. Thank you for pointing that out.
If it were me i'd go with vueJS. The bigger question is how are you going to persist the changes? It's pretty easy to alter elements in that instance of a web page. But it's meaningless if a user refreshes the page everything changes back unless you can store (persist) the changes somehow.
That's a good question. Any suggestions? Can I use a PHP backend to save changes?
Or it was just a [legal issue](https://en.wikipedia.org/wiki/Toubon_Law)
I agree with the other user. Copy other projects. Try to make a WordPress, EverNote, or Wiki clone using JS techs. Remake Tetris or space invaders. The only thing I would add is slightly do something different. If you're making a basic Twitter clone raise the char limit or only allow emoji instead of text. These slight differences may not seem meaningful but you're building upon an idea and making feature changes. Something you'll be doing if you ever work as a SE/SD.
"Ego has no place in our industry" said ego guy
I should have said "users of a given tool" not just users. I agree, not every employee spoke fluent english though
That's pretty great... would've been even more hilarious as a `console.warn`
Any server side solution will do the job, however given the format you want to store is CSS i'd recommend you pick one that deals with JSON (mongoDB or perhaps implement a couchbase cache natively or on the front of an RDBMS). Not only this you should also consider client-side caching. If it were me, id transform the stylesheet into a json object (key/value store) with webworkers and use localstorage (or another solution) to cache the changes on the client-side. The advantages are: - The changes are persistent to a certain degree already. Unless the user manually goes in and clears their browser cache. Even if the window is closed, they accidentally hit the back button, or something hinky happens with their session, the changes can still be reloaded client-side. - Naturally because of the above as you can imagine this has all the pros and cons of loading things from the client side cache. The biggest pro being everything is fast... SUPER fast compared to having to get things over the network which is an important factor i'd wager in your "dynamic" application. The biggest con being you need to be meticulous with your versioning (cache busting). - Combining these things with webworkers (provided using chrome or ff) and depending on the structure of your application, your site can potentially function without maintaining an internet connection, it only requires one for the initial page load. P.S. stay away from appcache for your own good.
Thankfully, repo owners can now block users on GitHub. Well, thankfully for repo owners at least. I'll miss these entertainments. Thanks for sharing!
Heh, reminds me of the people who call and expect you to walk them through installation and configuration in its entirety. We had to explain many times that we offer documentation but unless they had a specific error or question we couldn't help. 
Hi. I recently finished reading "The Definitive Guide" by David Flanagan and I really need to practise my JavaScript skills in a project. Any of you knows any JavaScript open-source project needing developers in which I can contribute to? Thanks a lot
What a mean-spirited subreddit. 
I respect the demeanor you responded with.
LOL 
What's wrong with vanilla JS? I feel the basic language is way more than enough to build any complex app.
Fuck that guy. 
If I had to guess, I would say you have a tiny cock. 
This and Array.prototype.includes, yep :) FWIW, all of the big implementations have the vast majority of ES6 implemented. No catch-up time required! We're working on ES7 and ES8 stuff too (which is only a year away!).
You got a lot of problems there, Spider. Is this homework or are you trying to learn? Of it's the latter, I'd be happy to scale things back and build up to that one concept at a time - just PM me. If it's homework, go back and read the chapter again...
Alright. I love coffee. So let's go. Can you change the markup? There's a couple things there that will make this a lot easier. Also, you have JQuery so can we use that, too?
This is the type of person that makes it so terrifying for newcomers, including myself, to commit to an open source project. The frustrating part is that his attitude and others like his are often validated through big paychecks from tech. 
what do you have so far? function improve(self) { return improve(self); } ^ also don't run this in a console, it creates a stack overflow
First thing I'm doing here is cutting it down to one question. This is a great way to start most problems like this: Make it work for one thing and then take that solution and "fit it to your larger problem. So let's begin. Step 1: Fixing the Markup. We got some funky things going on in the HTML, so let's straighten that out for starters. Generally you will learn if your html doesn't work, your scripts and styles won't work. Sometimes it's not a bad idea to just make your html first without any styles or scripts -- ideally it should be generally "readable" and roughly resemble what your final goal is. Anyhoo - here goes: 1. You got two opening &lt;html&gt; tags there. You should only have one. Fixed... 2. You've got some funky attributes on those &lt;button&gt; elements. Specifically the one that's like questionId[0][1]... from the script below I think I can kinda see what you were going for, but you are definitely "crossing streams" between your markup (the html) and your script. Let's take that off. 3. On the "correct" one, you've got class - correct... it needs to be class="correct". Attributes (which is what "class" is - an HTML attribute) always follow that form: ATTRIBUTE-NAME="ATTRIBUTE VALUE". Fixed. 4. onclick attributes - while not technically "wrong" in that "it works", linking buttons and other html to code through those violates something called "separation of concerns". We don't need to get into that now (you will if you decide to keep doing web dev) - but there are better ways to set that up in code... the rule goes like "keep markup in markup and code in code"... onclick is too "code"-y for good markup so let's pull those out. Now there are some nice things I see here: keeping your answers grouped inside divs of the same class - that's good instinct. Keep doing that. Alt tags on your img: I know senior devs that screw that up and you got it right there - always do that. Here's the link to where we are so far: https://jsfiddle.net/66qxnm21/3/ ... reply if you're still following...
I almost said this and then realized it is really only the bad implementations where you get stuck waiting for content before it suddenly flashes every component like a goddamn eink viewer, and it forces a scroll to the newly loaded content even though you gave up ages ago and scrolled back up to find the link to the rest
The nice thing about this is that if you ever hire any other french people, they are good to go.
Backbone.js? With [backbone-relational](http://backbonerelational.org) and perhaps [backbone-relational-jsonapi](https://github.com/xbill82/backbone-relational-jsonapi) if you're speaking to a JSONAPI-compatible endpoint.
Jared Fogle shaped Macaroni and Cheese?
I'm going to play devils advocate. **It's very widely used.** Doesnt have to be widely used just well documented. **It's highly asynchronous by nature, which is kind of inherently interesting and exciting to me** And?... node is async by default you could just as easily pick mocha or any other node app. **I'm often confused about just what's happening under the hood. The stack trace is completely impenetrable to me.** It means you are not writing your tests correctly. **It's relatively small (roughly 1/10 the size of angular 1, in terms of lines of code** Angular also has Jquery as a dependency but size is not relevant to usefulness. If you're going to pick something make sure people in your group are already using it across the board or can replace some of their dependencies with it.
Modules are several orders of magnitude more difficult to implement than exponentials. It's partly the standard and partly the difficulty involved. Also, System.load/import is still up in the air, I believe. 
I sort of agree with you, for example using libraries like Socket.io/ D3/ Velocity.js that tackle one area and do it extremely well. But I don't think client side frameworks are a must, with vanilla JS you can build whatever you want in a way the handles your specific needs needs. Big frameworks come jam packed with features, and are designed to be equipped for anything. I have learned several client side frameworks, and in most cases I feel they're unnecessary for most applications. What I would suggest is start building with just Vanilla JS, then build with a Framework like React. Look at the source code, see how it's built then try and borrow and incorporate their great ideas into your own project. All of these frameworks are written in VanillaJS so knowing the base language makes it easier to understand/patch bugs a newbie will run into with a new framework. 
jQuery &amp; Underscore are great starting points.
I - perversely - quite enjoyed it, too.
Perhaps a better way to search and store your parentElement once in the constructor. But it still remains fragile. I think I would prefer to make the parentElement a constructor parameter, so you can use this code in a more generic way and you are able to identify the parentElement more securely from the outside
This should be an advice mallard. Thank you!
He's right! That's because his ego is taking up all the space and there is no room left for any other ego! 
thanks for sharing, this is what I was hoping to learn by posting. I'm new to webpack but I'd like to see how I could use it to improve my build/development process. I think I found the relevant documenting but please correct me if I'm wrong: https://webpack.github.io/docs/library-and-externals.html 
But how is one large file beneficial over separated JSX and CSS? In my current React project, our components live in folders containing respective JavaScript and SCSS files; isn't that simple enough? Furthermore, what if one moves away from React? My solution has styles that are ready to go, whereas the CSSX approach means you'd have to manually extract them first.
Thanks! I guess docs are getting more important if you have a lot of (really) reusable code / modules ... Imagine underscore without docs :) Doclets is supposed to lower the hurdles to actually write and publish API-Docs. Would be great if Doclets gets useful for you! Let me know if you are missing something or something does not work as expected. 
This tightly couples your JS to your markup which is everything but good. Maybe try to use the click event on the actual element that you want to expand? Kinda hard to give good suggestions without seeing the markup
I thought this said Github Tax Formatting and was _way_ more interested.
This guy sounds like he belongs to the /r/iamverysmart world of programmers, he's very confident and uses big words but I could barely understand his argument. I worked with this kind before, they take the linter advice to heart, its even worse with Java and C# projects where they start marking methods static, remove unused setters and getters, set variables constant. They do all that because their tool told them so despite the fact that the code logic says otherwise. 
Backbone and I think jQuery and underscore have annotated source codes.
I should say you are very polite and calm. 
My favorite was the typo in the comment. Seriously, he went to all the trouble to clone, modify, commit, push, and open a PR... And didn't even proofread.
https://github.com/prettydiff/prettydiff/issues/291
I'm so excited.
I'm pretty sure GitHub does all that for you if you edit a file directly through web UI and try to save. Probably that's what happened here.
Relevant: http://www.androidpolice.com/wp-content/uploads/2014/09/nexus2cee_fa5.jpg
So in order to solve the problems of everybody developing a new standard or small framework, you started with your own standard/framework?
This makes sense, thanks.
Is it really that simple? And I'll show you as soon as I get to schhol
Going on a limb here, you're toggling the visibility of an element. Personally I have a .context on every element hidden by default, and that way you can do `var context = Element.closest('context');` and `contex.classList.toggle('expanded', context.classList.contains('expanded'));` instead of the whole if-statement.
https://s-media-cache-ak0.pinimg.com/236x/51/45/2c/51452c394f15be8d37c3a5f3dd011644.jpg
"Logic linting" exists; it's more commonly known as "unit testing". 
~~typo: `doRequest` should return.~~ See reply below
The MIT license is more liberal (free) than FSF approved licenses.
If you're talking about AngularJS, the scope is not the giant loop, in your text, the scope is "the list of variables" you're mentioning. The giant loop on the other hand is the *digest cycle*.
https://imgur.com/HfJO8mM That's the two I have so far, I don't think the boolean one is 100% correct, but it gets the point across.
Where did you get the `private` keyword from?
I assume that you are talking about this example: function doRequest(url) { ajaxCall( url, function(response){ it.next( response ); }); } function *main() { var user = yield doRequest( "http://yourdomain/api/v1/user" ); var roles = yield doRequest( "http://yourdomain/api/v1/roles" ); console.log("The user", user, "has the following roles", roles); } var it = main(); it.next(); Please note that when the response is received the promise success function executes: it.next( response ); This will assign user the value of the first response and perform the second request. With the second request the response will be assigned to the roles value and since there is no yield the execution of console.log will be performed and the generator function will be set to done. 
You probably need to update an old dependancy or your minification tool if you're using one.
ah yeah, I was jumping ahead, thinking async/co in my head when skimming the example.
package fails to install because the name in package.json is incorrect. It should be "name": "webpack-react-node-express-boilerplate",
Good start to an article talking about frameworks when 2 of the ones mentioned specifically identify themselves as libraries.
Oh, I see. This is TypeScript. I guess you are using ES6 classes.
It's beautiful. Because it's largely using pure functions. It kind of illustrates that a really solid architecture is a stateless one. 
&gt; It means you are not writing your tests correctly. Can you explain this to me? I've been spending a lot of time on testing lately, and 90% of the stack trace is still inside Jasmine. Isn't that kind of... necessary?
Yes, it really is. Any time you're working with graphics, you're going to be squaring something. Almost all actual math is going to involve exponentation at some point.
I wasn't necessarily referring to semi-colons in that comment, more to the other features ES2015 brings (arrow functions, template strings, 'classes', etc..)
I create financial tools. Yes. 
The guy is unrelenting.
Eh, I take issue with the idea that "good coders still go OSS after hours." For some people, it's just the job, and they leave it there. I know plenty of good mechanics that don't work on cars when they go home at night. But asking for an existing project is a reasonable alternative, assuming they have one to offer up.
Remember that Senior Developers in this market are interviewing you as much or more than you are interviewing them. Unless you're offering some insane perks, you don't want any roadblocks like this in your hiring.
You might find this read interesting: https://github.com/facebook/react/issues/5677
I would _love_ a webpack boilerplate that DOESN'T use React.
&gt; If they're a senior level developer and don't have a single piece of OSS, chances are, they aren't that senior. My experience is that having a public GitHub repo bears little relationship to ability. Most OSS projects are a complete shitshow. Horrible design, questionable features, no tests, absent documentation. And conversely, I've worked with some really great developers who haven't contributed one line of code to an OSS project. Personally, I have no problem with a potential employer asking me to qualify myself by spending a couple hours on a coding exercise. I think OP is asking too much -- writing an app over the course of a week is going to take quite a bit of time -- but I don't blame them for asking them to write some code. We have so-called senior candidates come in all the time who can't make it through our on-site coding exercise. (We give them a laptop set up with a development environment.) 
Opens a PR just to change your style with no intention of contributing anything more. That's just insulting unless you already had a discussion about it in an issue some place. Might as well change all of the variables from camelcase to underscore style or vice-versa.
In a similar vein mercury.js is a good one. Small, loosely coupled, and comparable to react+redux. I think its an excellent example of combining small stable modules into a larger framework.
I mean if you are doing unit testing properly there should be very little reason why you should be unable to read the stack trace presented. Take a look at the following clip: https://youtu.be/Kfkmzd64hNQ?list=PLOxOmO43E6Jt0SruKGxtZs-W3PJN90G_a 4:35 there's an error he's demoing - Firstly it gives you an error: &gt; ReferenceError: helloWorld is not defined. Second it gives you the stack: at [object Object].&lt;anonymous&gt; (*filepath*/helloWorld_spec.js:3:10) I won't list the entire stack but the numbers at the end tell you how to trace the error, filename, line number, character on that line, thus even if there's multiple tests in a single file you should still be able to debug assuming you're testing as you go. If the expectation isnt met (in this case with regards to a certain function) then you know where to look in your code to fix it. The only reason this would become difficult to do is if you're making the unit tests too complex on a per test basis, perhaps mistaking unit testing for integration testing. I don't understand how you can't read a stack trace that is presented to you? Unless of course we're talking about how jasmine detects errors itself. This has less to do with debugging a stack and more to do with knowing javascript prototypal models, how they are implemented (objects are established) and how GC occurs. 
Maybe fix your code then and properly indent it with four spaces instead of one tab ... 😀
at the other posters in this thread - as a thought experiment - if we assume the candidate was not insulted by the request, what would the content of a take home assignment be?
I take that as a fair point; a full "app" is probably overkill (and not very interesting) for a position like this.
I know many incredibly talented senior-level people who have absolutely nothing to show on github because they have other things to do than doing extra work on their spare time (the usual story is family &gt; other stuff, if we're talking about spare time, and highly specific skillset that doesn't even come to play, if we're talking about putting a sample project together) In fact, you'll find that good people are also generally good at managing time (read: they understand the value of a good work-life balance), which does mean that they're indeed not going to spend a week doing something that has little to no returns for them. With that being said, since OP is looking for ideas, here are some questions/assignments I've come across when applying for senior-level positions (in no particular order of quality) - build a calendar widget (basically figure out an algorithm for event placement in google calendar), ~3 hrs - design a communication scheme between servers to fetch data from several servers and display a timeline showing latest 7 items with the least number of network trips (basically, twitter), ~20 mins - refactor some angular code (basically, can you follow established best practices for a well known system), ~30 mins - talk about GOF design patterns you've used and why, ~20mins. Personally, I don't really care that much about what the take home assignment is, because it doesn't tell me much about how the candidate would do at a senior level position (which, for places where I've worked for/interviewed at, are more oriented towards managing other developers' time/workloads and communicating requirements, resolving workflow problems, etc, than actual coding). 
Ah, thanks for clarifying
They might have to come up with a catchier name than that.
[jQuery](https://robflaherty.github.io/jquery-annotated-source/) and [Backbone](http://backbonejs.org/docs/backbone.html) both have nice annotated sources that you can read.
I'll do whatever they need as long as they are paying me my normal hourly rate - I'd refuse to waste my time writing throwaway code anywhere other than in an interview.
different one `var generator = new genFunc1();` - shouldn't new generators
That's not entirely true. New ES versions are adopted by browsers really fast nowadays. It's less than a year since ES2015 and already chrome and Firefox are at 90% and Edge closing in. The only reason we need Babel is for IE and mobile browsers, and ES2016. In 5 years time we won't need to support IE, and hopefully mobile browsers will be up to par in terms of development speed (basically just fucking mobile Safari) and the only reason need Babel will be for using *next* year's ES (if any). With HTTP2 and native modules Webpack will also be obsolete most probably. 5 years is a lot of time.. 
"I suspect this conversation is over" Immediately continues conversation
This should be exactly what you need: https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/PLYLoader.js
For work, I made this library in about a day, so I'm sure it has issues in it (I won't bump it up to 1.0.0 until I'm fairly certain it's been vetted). The idea is that it keeps track of scroll handlers for each DOM Node (defaulting to `window`) as collections, so every time a scroll event happens, it batches the event to each handler. It also uses `requestAnimationFrame` (or a `setTimeout`, if raf isn't available) to call each callback so they won't block. I would love it if someone could look over it and give me any feedback.
&gt; bleh, any senior dev would use a library for this Well, the point of the exercise is to demonstrate that you can actually do algorithmic analysis pertained to UIs. This particular one was a standardized test at a famous tech company. If you feel you can submit what is clearly not your work and be taken seriously, go ahead... &gt; sort of thing a friend could help with True, but a friend could help with any take home assignment. Hell, I help my wife with her day job projects all the time... This one was also a standardized test, and a good solution required working knowledge of angular, one of its styleguides and promise composition. It *can* be answered by a junior-level person, but personally I would be able to tell the difference in knowledge levels. 
For the curious, [here](https://gist.github.com/gaearon/ffd88b0e4f00b22c3159) is a gist of redux stripped down to 99 lines. It's quite easy to understand how the entire framework works just by reading these lines. 
 (function enableNextButton() { var elements = document.getElementsByName("next"); // Select all elements on the page by the "name" property var el = elements[0]; // Pick the first one out of the list (assuming there is only one on the page) el.disabled = ""; // Removes the disabled property })() This should do exactly what you want, you can paste it into the console (or use an extension) and it will execute immediately. 
much apriciated!
http://codepen.io/anon/pen/PNaWYL Here's my attempt. Mostly used it to practice Bootstrap. Still needs work in the responsive design department. I've brought the JavaScript down to less than 10 lines by going the opposite approach of /u/ridicalis. Kind of hack-y but should be easy to understand, even for a beginner. 
Even then, Underscore is much easier to understand; much of what makes lodash more performant also makes the code more difficult to understand.
Looks like a troll... and an drunk one with a lot of time to kill on their hands.
Not even sure what the point of encapsulating this in a class would be since it's so fragile it could probably only be effectively used in like a single place. Don't deeply traverse element hierarchies like this, and if you absolutely have to, use selectors instead.
there is multiple, anyway to do it to all of them? EDIT: to clarify the thing is working, i want it to work for all of them 
What happens when the services need to read/write state? In exercise, we found that it was easier for the services layer to sit in between the handler and the store. In many cases, it's a pass-through, but in other cases there's business logic which may or may not interact with the store. This made the lifecycle of a request more straightforward. I also suspect it would make more dynamic handling of requests, like memoization, or some request that may conditionally require the store and/or a service simpler to implement. I'd be eager to hear your thoughts on what you see as the pros and cons of this. P.S. love the layout and design of the blog. I dream for a day where I have the time to write posts of this visual quality.
I basically pulled five years out of my ass. I was trying to make the point that you can use it in x years, but you can't use the features added in those x years.
Tests show me what's actually important in the application, it's easy to get lost in the code itself - tests are more specfiic
that's a fair point, but who's the better mechanic, the one who goes home &amp; watches TV, or the one who goes home and works on his motorcycle/old mustang? Having been on the hiring side, I only want to hire the absolute best: the people who dream in code. To me, a great coder is worth 3+ mediocre coders, and greatness is a function of skill AND desire. But then again, you may just need a maintenance programmer to manage your old LAMP stack. 
You probably shouldn't hold your breath. The first comment on HN sums it up well for me, I think: &gt;I feel like I'm in a bizarro world reading this "interview"... they're just describing web sites before "web 2.0" (around when Google Maps, Prototype, jQuery etc. came along), but talking about it as if it's a new thing. And if the WASM ball keeps rolling, then you'll see less JS, but the same ideas coming into play with. Not this though. 
 [].slice.apply(document.querySelectorAll('[name="next"]')).forEach(function (btn) { btn.disabled = ''; });
In a way, it's like the current trend toward functional programming in JS: The '70s called to ask us what took so long.
"...if your app is just a couple of forms"
So why make an operator for it? So now we have ** littered around in addition to the Math.exp() calls still needed for dimensions greater than 2? 
You can use other numbers with it. `1.7**Math.PI` `e**273819` 
Ah ok. That makes more sense. 
"App"
+1 Backbone is nice and small and well documented
Any general memoization technique will solve this. There's no reason to have something special for Promises. An already resolved promise can be used again-and-again, returning the resolution (or rejection). This means that if `promiseA` has already resolved, calling `promiseA.then(doSomething)` will call `doSomething(resolution)` on the next process tick. Also, the initial example is a _terrible_ example of using Promises. Generally speaking, you should probably never create your own Promises, unless you are writing low-level asynchronous code. IE: you are writing your own sockets or file access. *(edit: the other main reason is if you are starting a promise chain and you can't trust the input data, then something like `Promise.resolve(input)` is a good way to start a chain)*. This: return new Promise((resolve, reject) =&gt; { fetch(`/article/${articleId}`).then(r =&gt; r.json()).then(function (data) { resolve(data) }) }) Could simply be: return fetch(`/article/${articleId}`).then(r =&gt; r.json()) More importantly, there's a _massive_ bug in the first example—if the `fetch` fails, there's no rejection, and no way to process it.
You could try customizing Fullcalendars AgendaView since it seems to meet most of your requirements out of the box. You can set the [agenda options](http://fullcalendar.io/docs/agenda/) (e.g. duration of slots) before initializing FC. 
It's just the nature of JS; scope ordering of closures (methods, functions, etc) doesn't matter as long as they simply can access each other in the same scope. Just like this works: function1(); function function1() { console.log(function2()); } function function2() { return 'yep'; }
It's called a linter; the kewl kidz use [ESLint](http://eslint.org/), while [JSHint](http://jshint.com/) has an easier setup, especially if you just want to use the website to lint a small script (under about 2500 lines). **EDIT:** I just tried JSHint on default settings and it didn't find anything serious, possibly because for all it knew, the `change` method could accept the `undefined` value; however, its predecessor, [JSLint](http://jslint.com/), gave a bunch of cryptic warnings, including one that basically meant you were using a variable before it was declared, which is generally a bad idea. JSLint Will Hurt Your Feelings&amp;trade; More generally, there are unit-testing frameworks (testing each piece of a program) and integration-testing services (testing the entire program in a variety of environments).
&gt;Because JavaScript has no concept of getters or setters, there is no good way to tell when a value has been updated in either the DOM (excluding the DOM’s native eventing) or the in-memory object model of the app. There is absolutley a concept of getters/setters in javascript, as of ECMA-262. You're at least right about the DOM part, but saying there is no such thing as a getter/setter in javascript made the article lose a huge amount of credibility. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set
I love them. Makes me like me, since I also chose (years ago) to build my own library. Lately, the anxiety in seeing every one hop onto React (employers too) has been draining. So seeing this article makes me feel good.
Previously you could always use Object.defineProperty, it's less elegant of course.
How would a return statement look like? // like this?↓ return { param1, newParam: true } = obj; How would it work with the spread operator? // like this? ↓ const foo = { ...({ param1 } = obj), newParam: true }; I would like to see some sugar for the *pick()* function. Look it up in Lodash or Ramda.
`_.pick()` is currently how I'm getting by, but it requires typing quotes and array brackets, and importing a library. It's also not as intuitive, I think. I imagine your second one to be better for `return` statements: return { ...({ param1 } = obj), newParam: true, }; and those parentheses also open up the possibility: const newObj = ({ foo, bar, newParam: true } = oldObj);
Express is robust and has a huge support base, but it is basically abandoned as far as future development. That doesn't mean it is immediately useless, though. At work we're planning out a platform for the next several years and we went with [hapi](http://hapijs.com) because it does [pretty much everything we could ask](http://hapijs.com/plugins#The%20extended%20hapi%20universe) including HTTP/2 support.
 const obj = { param1: 1, param2: 2, param3: 3, param4: 4, param5: 5 }; var newObj = Object.assign({}, obj, {newParam: true}); To be selective, just pick the params first then object assign them. Or assign them all and use delete. const obj = { param1: 1, param2: 2, param3: 3, param4: 4, param5: 5 }; var {param1, param2} = obj; var newObj = Object.assign({}, {param1, param2}, {newParam: true});
yeah, you're in a situation where you're mixing sync (while loop) with async (prompt.get). If you want an asynchronous loop, you'll need to skip the conventional loop structures like while, and handle the looping manually, something more akin to a recursion loop. Only because the apis being used are async, its not really recursion because the function calling the would-be recursive function is the async callback rather than the function itself. Confused yet? Lets put it to code to better show it off: function ask1(){ // request user input prompt.get({ properties: { name: { description: colors.magenta("What do u want?") } } }, function (err, result) { // now determine if we need to ask again (the loop part) if(result.name != "quit"){ // once we have the user input, respond console.log(colors.cyan("You said you want: " + result.name)); // keep asking (loop), starting the same process over again ask(); } // else no ask, no loop, just let the function die on its own }); } // start the first question ask1() Notice that the loop is off the table. Instead, ask1 can call itself, which can call itself, which can call itself, etc. effectively doing the same thing as a loop would: repeating. This is the recursive-like part, though recursion is usually within the same call stack rather than being broken up like this asynchronously (ask1 technically isn't calling itself, its the `function (err, result) {` callback function that's calling ask1). This keeps going until "quit" is recognized where ask1 isn't called again. That's when the loop ends.
TypeScript would also detect this (and much, much more).
Use hapi instead of both of them... Hapi + Joi + Boom!
I'd posit that it's because you're rolling your own lib, hence supporting the lib is, and will always be, ongoing.
Based on the links in that article, I made a nice patch for `Math.random`: (function (Math, String, Array, Date) { 'use strict'; // https://advancedweb.hu/2016/04/19/proper-random-numbers-in-javascript/ // From http://baagoe.com/en/RandomMusings/javascript/ // Johannes Baagøe &lt;baagoe@baagoe.com&gt;, 2010 // https://github.com/nquinlan/better-random-numbers-for-javascript-mirror/blob/master/support/js/Mash.js function Mash() { if (this instanceof Mash) return Mash(); var n = 0xefc8249d; function mash(dat) { var data = String(dat), len = data.length, i, h; for (i = 0; i &lt; len; i++) { n += data.charCodeAt(i); h = 0.02519603282416938 * n; n = h &gt;&gt;&gt; 0; h -= n; h *= n; n = h &gt;&gt;&gt; 0; h -= n; n += h * 0x100000000; // 2^32 } return (n &gt;&gt;&gt; 0) * 2.3283064365386963e-10; // 2^-32 } //mash.version = 'Mash 0.9'; return mash; } // From http://baagoe.com/en/RandomMusings/javascript/ // Johannes Baagøe &lt;baagoe@baagoe.com&gt;, 2010 // https://github.com/nquinlan/better-random-numbers-for-javascript-mirror/blob/master/support/js/Alea.js function Alea() { var i = arguments.length, args = new Array(i); while (i--) args[i] = arguments[i]; if (this instanceof Alea) return Alea.apply(null, args); return (function (args) { var s0 = 0, s1 = 0, s2 = 0, c = 1, mash = Mash(), len, i; s0 = mash(' '); s1 = mash(' '); s2 = mash(' '); if (args.length === 0) args[0] = +new Date(); len = args.length; for (i = 0; i &lt; len; i++) { s0 -= mash(args[i]); if (s0 &lt; 0) s0 += 1; s1 -= mash(args[i]); if (s1 &lt; 0) s1 += 1; s2 -= mash(args[i]); if (s2 &lt; 0) s2 += 1; } mash = null; function random() { var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32 s0 = s1; s1 = s2; return s2 = t - (c = t | 0); } //function uint32() { // return random() * 0x100000000; // 2^32 //} //function fract53() { // return random() + (random() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53 //} //random.uint32 = uint32; //random.fract53 = fract53; //random.version = 'Alea 0.9'; //random.args = args; return random; })(args); } Math.random = Alea(); })(Math, String, Array, Date); I commented out all of the code related to adding properties that the native `Math.random` doesn't have.
Try reading es-discuss or https://github.com/tc39/ecma262 sometime :-P 
It helps because it gives us total control over how the guts of our application work and we can adjust and tweak it as the application grows and evolves. It is true that you can always adjust and tweak the guts of any 3rd party framework, but you run the risk of anchoring yourself to an older (and eventually unsupported) version of the framework because upgrading would break/overwrite your modifications.
`..._.pick`, `x**=++x`... JavaScript these days I tells ya!
There's also MutationObservers for DOM stuff, they are pretty cool
maybe this - (function improve (self) { if (humans &gt;= self) { return improve(self) } })(AI) I think it might get your point across. 
If long term support is the concern, can't you simply fork an existing framework and maintain your own copy? No need to reinvent the wheel when you just needed a reliable air pump.
Thanks for this! Going to try it out in my next project!
Total control is a good reason, but it doesn't seem to alleviate the problem of being married to a particular framework, vis-a-vis: &gt; to move to the latest “cool” framework, you have to pull your app apart. Though I suppose your own framework will always be "cool" in your eyes, your flexibility to *rapidly* change will always be hindered nonetheless.
I fundamentally disagree with all of this. The manager who approved this should be fired. 
That looks really good, not too complicated, thanks, man!
Yep, same experience here. The digest loop was too expensive when I had a large dynamic table. 
I appreciate your input, but I disagree: modifying your own code yourself is almost always faster than waiting for someone else (or the community) to do it for you, especially if you took the time to write it with future changes in mind.
At first I was like &gt; why would anybody need this but then the preview gif was perfect -- 10/10 explanatory value.
First off, do we really think that browsers will still be running JavaScript in 20 years? :) Regardless, I think it will last because it was designed with change in mind. If you do a good job and try and anticipate future changes and architect it in such a way that it can grow and expand, it'll last a very long time. 
Actually I'm already using Koa 2 but instead of using async/await I'm just using bluebird and returning promises which works just fine since async/await is promise based. You can use Koa 2 today with that setup and once async/await is finalized, switching will be a breeze.
I just run `rm -rf ` as a Node child process or replace it with `rmdir /s /q ` if the `path.sep` is `\\`.
ESNext (currently stage 2), if you don't mind the removed elements going into the local scope let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; x; // 1 y; // 2 z; // { a: 3, b: 4 } or you could wrap it up in an iife newObj = (({ x, y, ...z }) =&gt; z)(obj); // { a: 3, b: 4 } https://github.com/sebmarkbage/ecmascript-rest-spread
JavaScript has already lasted 20 years and is a fundamental component to the web. Without it pages don't work and if pages don't work the web doesn't work. So yes, I do think it will be. What about React? Marionette and Angular aren't convincing arguments for rolling your own system.
IBM bought the project and of course being corporate douchebags they basically turned it into a beurocratic clusterfuck making the only significant contributor back away recently. 
Why not add an alias for the root of whatever bundler you're using? I usually set an alias for the root of my project in webpack so that a request to `ns/services/foobar` would go to `$projectRoot/services/foobar`. This allows you to only use relative requires for things which *should* be relative to that file.
That is such shit news. Express was one of the first NodeJS packages I ever used and taught me so much about the back-end. 
After TJ, Doug Wilson was the primary maintainer of Express, despite StrongLoop's ownership and subsequent acquisition by IBM. The issues all came to the surface in January. In [the discussion](https://github.com/expressjs/express/issues/2844) Doug mentioned he doesn't see a way forward for HTTP/2 support. Basically it ended with IBM/StrongLoop handing Express to the Node Foundation and Doug donating all the modules he created/maintained as well. It looks like Doug is still a project member and answering questions, but I haven't seen (and may have missed) anything that changes the discussion in which A) Doug is moving on and B) Express itself doesn't have an HTTP/2 future. I recommend you read through [the issue](https://github.com/expressjs/express/issues/2844) if you want it first(ish)-hand.
"fundamentally" isn't an argument. What do you think is wrong with this?
Great write up. I need to come back and read some of the more technical parts. I'll be sharing this with my team as we consider a similar scenario. 
Do both. Don't over-bloat by trying to future-proof, but it's always good to anticipate change and growth.
Yes, but readability goes out the window. I'm happy with the current syntax.
I use Boom in my koa app. Works wonderfully!
That's basically the idea but with more convention. The upside is that since it's babel compatible, it's also portable. I use browserify and I have no way to setup aliases (as far as I know) and this seemed like a nicer way of doing so especially since I can define a multitude of aliases and don't have to be too concerned with the modules' actual paths when in a project. However, I'm happy to find out that other solutions are out there! :)
Back in my day, I had pure HTML and only notepad on Windows 95! None of that CSS stuff, we used tables and the blink tag! 
There are tons of solutions to this already, that don't involve total rewrites. It's definitely an issue, but not one that can't be solved.
I haven't tried Hapi but have worked with Express and Koa within the same app. Koa would be my choice especially for your needs. If you're not already comfortable with promises then you'll get to learn some cool stuff working with Koa.
Who needs javascript when you can make your website out of flash and java applets. Right? Guys..? High five.
Man, haven't run into this at all with Angular2... is it an Angular1 thing?
And in the process, create a different mess. JS devs suffer from "choice paralysis." Angular, React, Backbone, Knockout, Ember, Meteor, Polymer, Mithril, Aurelia, etc., etc., etc. Are you f*cking kidding me?! These frameworks have the life span of a fruit fly. React is the new kid on the block right now, but who knows how long it'll stay on top. And let's not forget the Angular 2 vs Angular 1 mess. Good Grief! At least jQuery is solid, well-supported, and proven. It's one of the most widely used frameworks in the world. Sure, it's not perfect, but what is?
just don't let it be you for reals!
 when did the decision making happened? while the article was written recently. I think the actual decision making must have taken place 2-3 years back
Fork the framework, use your patch, submit the patch upstream, update when/if patch gets merged. If it doesn't get merged, submit higher quality code. 
I just finished-up a project with a company that sort of did this. They wrote their own framework as a fork off of backbone and marionette. The result was a bastardized "MVC" ball of mud that will haunt my dreams forever. Ultimately they decided to migrate off of what they had to Angular 1.5. Key reasons: * Every new developer had to be trained for no less than 3 weeks on the new framework before they could be, at most, 50% productive. * Documentation was slim to non-existant, and no one person really knew how all of it worked. * Testing was similarly slim to non-existant, so "fixes" to the framework often broke other things. * A small crack team of developers had to devote 50-100% of their time maintaining the thing. While they had 100% control over the guts of the framework, they also bore *100% of the maintenance cost*. They couldn't benefit from any improvements from the wider JavaScript community. Is this worth it to you? If you went with a popular framework today it wouldn't disappear next year. React isn't going to be the most popular in 5 years, but it certainly is not going to be unsupported. If a framework is solid and widely used it can carry on for a long, long time. Prototype.js even got updates 7 months ago, and it's 11 years old! 
Maybe replacing it with something else would lessen vulnerabilities in folks' computers. Then what that something else would be... well that something else hasn't arrived.
As the "manager that should be fired" (see comment below) what we wrote is not a framework. It's a simple and elegant set pattern that takes a pretty simple problem, binding a UI to methods and properties of your model, and solves it with code that took a few days to write. It's not a ball of mud. It's easy to learn and maintain. Angular and other frameworks are the balls of mud that make all this much more complex and opaque than it needs to be. IMHO. 
I've been using babel for quite a while now, and I haven't had any problems whatsoever. For most things (arrow functions, default parameters, `class`, etc) the code babel generates is remarkably similar to the code you write (I've found myself accidentally making changes to "compiled" code, thinking it was the original) I will say the async/await stuff is a much more complicated transformation, and the output code is a bit gnarly. Still mostly readable, but it's not terribly pretty. Webpack handles sourcemaps for the client side, and as long as you tell babel to output source maps for server code it's literally as easy as adding this as the first line in your project: ``` require('source-map-support').install(); ``` If you couldn't already tell, I would highly recommend going for it. 
I'm surprised no one's mentioned this yet, but a license is one of the first things I look for when looking at open source code.
Angular's also had its own getter/setter for ng-model for ~2 years now as well.
It looks cool but unless you're buying a "premium theme from theme forest" or building a heavily creative animated site, don't bother. The UX research that I've done over the years is that people just want the page to show up ASAP. My 2 cents.
Yep. Nov 2013. 
&gt; async/await is promise based Can you elaborate on that?
Not a back-end developer, but just curious. What is the state of sails.js? Can one still use it?
Did you guys consider Aurelia?
javascript is embedded in much more than just browsers.
Next time use /u/matthiasak to mention an user! (Works in comments only). But since he deleted his account, it doesn't really matter. 
While one *can* use it, I would strongly recommend not using it for anything other than when you need a Proof of Concept API in a big damn hurry. I've been using it for the last 6 months on a project because the organisation I'm delivering for mandated it for consistency with other projects within their organisation, and it has *a lot* of problems. A couple of my favourites not covered by [this article](https://kev.inburke.com/kevin/dont-use-sails-or-waterline/): * plugin loading is done by traversing the local ./node_modules directory, and loading anything it finds. This means that a) it's easy to accidentally be using a module you don't mean to, and b) it's easy to be not using a module you mean to, and in both cases this leads to subtle errors and failing silently. This also makes it impossible to use sails in a project which is not the top level module. A sails app *cannot* be a submodule of another project. * all of your components are implicitly generated at app start up time, which means that you can't actually access them without starting up a server. This makes for incredibly complex unit testing workflows. * ALL OF THE GLOBAL VARIABLES!! * All of the options and features are enabled by default, so your code is necessarily bloated and underperformant (in some cases catastrophically so). The first thing you do when creating a new app is go through all the configuration and disable all the things you don't want. In some cases, not disabling or reconfiguring certain default options (websockets/pubsub) will lead to memory leaking behaviour in production environments. Other things (blueprint) are just outright dangerous. Some of these hooks (as sails calls them) have complex, undocumented internal dependencies, so disabling some will cause other things to fail. In summary, while sails has its uses for rapid prototype development (it can be really quick to get going from a development perspective), its "monolithic-by-default" architecture (compared with express' "everything is a module" approach), enormous bloat, and deeply naive approach to dependency loading make it a total no-go for serious production use in my opinion. Edit: I a word ("not"), which completely changed the nature of my post.
Hmm, every discussion I read about one technology or another there is someone that drops by and says "hey guys! ember.js can do this", perhaps time to check it out :P
Seems as though it [was public](https://github.com/jayphelps/lazy-dom), but now deleted &amp;mdash; or more likely *private*. Reasoning behind that is probably due to [the following](https://medium.com/@jayphelps/thanks-for-the-positive-vibes-815113db9e30#.kcskmdfaz): &gt;Thanks for the positive vibes! At this point it’s just an experiment and the code written for the demos is nowhere near production ready so don’t want people building real things with it outside of the JSBins or people filing issues about things not working. If the reception is positive, I’ll spend some time to change that. 
This is a mistake IMO. You have made something very interesting at least and it won't get much attention after this, even if you realize it's as cool as it is.
Exactly. async/await is just syntactic sugar on top of generators. Nothing a very simple code mod can't port for you.
This is great! I was trying to do this as well last weekend. I was wondering how could I integrate React for server-side rendering in here. Any idea?
I've personally been wanting to do some data mining and other analyses on my Reddit profile, and as it happens they offer [RESTful endpoints](https://www.reddit.com/dev/api) and [OAuth authentication](https://github.com/reddit/reddit/wiki/OAuth2). If you have an account that's been around for a while and you've done cool things with it, this would be a good opportunity to explore it further.
Because now you get to spend precious resources not delivering value to your stakeholders!
Thanks!
yes but I think the angular source code is too large and complex to be easily maintained by developers who haven't worked with it. It was a long time since I looked at it but it was a problem then and I think it still is a problem. On the other hand Mithril, Riot or even React could be perfectly ok to fork and maintain.
I am missing some description of what other frameworks you looked at. Did you just say that angular was too hard to work with and ditched everything or did you try React or some other library?
Nowadays JS is so disgusting ...
The overarching theme of this article centers around a team that had no idea how to properly evaluate the right tool for the right job. Every popular JS framework has strengths and weaknesses that lend it to being better, or worse, for specific applications. Angular rocks for heavy form-based apps, but I would never use it to try to tackle an application like this team did. This statement right here exemplifies to me just how inexperienced these developers were in their approach to evaluating libraries. &gt; As we thought more about how to replace the two-way data binding provided by Angular.js it became clear that we didn’t need some bloated catch-all solution to try and alleviate ourselves the terrible and arduous task of writing actual code. Had the thought not occurred that maybe using an out-the-box full featured MV* framework (a "bloated catch-all"), for an application as complicated as the one they sought to build, might lead the team down a road riddled with problems? Why not continue to leverage the power of open source and put together a collection of smaller and more specialized libraries that do fewer things, but do them in a manner that is better suited to the needs of your team? React (paired with some kind of state manager and other supporting libs) is the first thing that comes to mind when looking at a large piece of software like yours with so many tightly coupled features and controls. You said you evaluated React but chose to go with Angular, a framework that has many known issues in regard to performance with the number watchers running at any given time. That fact alone should have raised red flags VERY early on that it may not be the right tool for the right job. It seems to me like you barely skimmed the surface with your "research" and, instead, made an arbitrary decision to go with Angular. Now you're demonizing the framework because that decision bit you in the ass? *"This hammer is a piece of shit. Its not helping me turn these screws"*
I'm intrigued. I've been working on an internal platform team for my company and we've been working on something similar. I'm curious to read the source and how a Roc app plays out in practice. Nice work!
Promises are a good thing to know as well and maybe some type of js module loaders such as require or es6 (javascript 6) export an import. Creating a sample project and putting up into your portfolio would be really good as well.
I'm sure someone will put it here anyway - https://xkcd.com/927/
[Image](http://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2779 times, representing 2.5770% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d2a7yvl)
I would also guess that the operator invocation is much faster than the method call.
It's refreshing to hear this in the JS community.
I still code like this.... but then I am old.
Noob here - it's clear the project is dead short term, but does being handled by the Node Foundation mean it might pick up steam again in the future?
yup
Webpack is definitely more than a module loader and will happily do all the things you mentioned (and way more). Even if you later find something that it's not capable of you can always introduce a task runner. But I would recommend to start with just webpack
Sure you can. Check out webpack-dev-server, it has a 'hot' parameter which enables hot reloading. You can configure webpack extensively to support most things you'd expect support for. Setting up your first webpack boilerplate is not trivial, so be in a patient mood when you start..
I will give webpack a chance then, thanks!
`async/await`: const foo = async () =&gt; { let response = await request.get('/foo').catch(err =&gt; console.error(err)); if (response &amp;&amp; response.ok) { console.log('ok'); } }; is just sugar for var foo = function() { request.get('/foo').then(function() { console.log('ok'); }, function(err) { console.error(err); }); };
Thanks there! So it is not some infectious script right? Just some sort of URL redirector?
Yeah, with something as "great" and "popular" as angular, you shouldn't have to deal with problems like that. It's poorly engineered. 
*Checks subreddit* Are you lost?
It easily replaces gulp/grunt for this stuff. There's live reloading inbuilt that can also reload components without refreshing the page, keeping your state. While you're at it, take the opportunity to jump into ES6 with Babel, it's just a loader away in Webpack, alongside uglyfy, css-minify and all the others.
I'm just glad these companies can rise to the challenge once again now that they have achieved 100% browser compatibility with existing Javascript code and API features. Luckily, they don't all have their own existing, internally developed languages and ecosystems that would compete with accomplishing the pinnacle software achievement of a write once run everywhere binary target. END OF SARCASM. I give this 0% chance of becoming a reality. No doubt the people working on this are an order of magnitude smarter than me, but this will never happen if for no other reason than politics and money are still a thing. The fact that Javascript has invaded the server should be proof enough that it isn't going anywhere.
I don't see the need for alarmism. Javascript is a tool and WebAssembly is a tool. Like any tools, adoption plays a big role in its success. Given current Javascript/DOM adoption rates, WebAssembly "killing" javascript is about as likely as WebGL becoming mainstream for thick client app development. Besides, the frontend landscape already changes at light speed anyways. Even if WebAssembly wins, so what? Surely people can learn a new language if it does somehow manage to become an industry requirement.
One thing I think I forgot to mention is, I am applying for entry level, and the projects would be small personal projects. 
Bookmarked this yesterday, thought the data was kind of interesting: AllTransit - data from 805 municipal transit agencies in 287 cities http://alltransit.cnt.org/potential-uses/ Charting/graphing/mapping would be excellent JS skills to acquire, IMO. Also, https://api.nasa.gov/
Well, it doesn't appear to have a payload, if that's what you're asking. It's called [Self-XSS](https://www.facebook.com/help/757846550903291), and it's notable that the script is meant to look innocent and doesn't call anything like "eval", perhaps so it can get past security filters or a glance of the human eye. So it's a bit like social engineering, because people are told not to click links, but they may not realize the threat of executing code in the developer console. Honestly, browsers should implement a cheat code or something the way Android phones do to enable developer features. 99% of users have zero need to access the console. By the way, if you hit F12 while browsing facebook you'll see they've actually implemented a giant warning for users to fend off this sort of thing. 
Sometimes I am. I never felt the need to use any of the frameworks or fancy new kinds of creating functions or modules and whatnot. I really miss good old vanilla JavaScript.
Couldn't you have the same benefits by open sourcing your internal framework, like the Rails guys did?
It is strange to see JavaScript as the thing you compile to. I mean, *most* experienced devs don't get too caught up in the hype of awesomeNew.js frameworks and select their libraries based on what saves them time and will be supported. The sampling here of fancy new toys is a bit like how Popular Mechanics has for the last 40 years told everyone we'll have flying cars soon. It all sounds neat until you realize it's really just an overpriced plane that folds into something that fits on the road. 
Probably fine. Doubly so if you are using ubuntu. It just redirects you to some url that probably does nothing. The bulk of the code is sort of like a "decoder" function. Large blocks of random characters so it can just get the Nth character from off of a list and concatenate into a string. At the bottom of the page there are 4 calls to the function. Those translate to `top`, `location`, `href` and the url. That's all there is to it. Calling the function and passing in a string will just return another "decoded" string.
Nah the was it was sent to me was thru a friends chat as an html file. My father downloaded and clicked on the html file, causing the JS script within to execute on Google chrome.
To expand on this, can you add paths and virtual hosts while the server is running?
In the end we did end up using a some smaller libraries for specialized functions for parts of the app as you suggest. But as "inexperienced JavaScript developers" we began with the assumption that we needed to start with a UI framework. The point of the article is that we found that it didn't buy us anything (but problems). The problem that we were trying to solve is simple enough that writing some straightforward and transparent code got the job done. Sometimes all you need is a hammer and a nail. Not a set of socket wrenches. 
Nice!
OK I've done it for client code, but its the server I'm scared of. Would you recommend always using source maps, even on production, or would there be a performance hit?
Generally speaking.
Thanks for the feedback! 1. You are right about returning fetch directly, I just wanted to show a raw situation. But since it's not something developers would normally write, I changed the docs. I also cleaned the code quite a bit. 2. While `_.memoize` will memorize the promise by args sent to the function, it doesn't clear its cache once the promise is done, which is the major benefit of the module (and if you do want your promise not to run again, there is a `memoize` option). Another use case would be an `async` function that opens a modal as a result of a click, but waits until one or more async operations are performed. It can be guarded by `@reusePromise` to not allow more than one instance of a modal opened. Obviously there are other solutions of manually-writing this code, but the decorator provides a cleaner code. class UserProfileModal { @reusePromise() async open() { this.loading.show() const foo = await this.loadFoo() const bar = await this.loadBar(foo) this.modal.show() } } 
Great advice for making yourself a better developer but when going your first job having a pretty web page that uses an external api is enough. Very few interviewers will look that deeply into the code, just do enough to be able to talk about your decisions.
CSS is fine for the goal of eliminating dependence on client-side scripting (except for CSS expressions, which are JS in CSS); also, in a modern browser, some of the original use cases for JS are now doable in HTML directly, like client-side form validation.
Well it's really slow and crashed the embedded browser in AlienBlue, so maybe that has something to do with it...
In my opinion, yes, mobile users should also be allowed to look at resumes :)
You have no work experience on there? There's some apprenticeship and github stuff, but no actual work experience. If they said, "we want someone more senior", they probably mean someone who has actually shipped a product. No matter how much work you do on your own, actually working in a business requires some different skills and they aren't looking to take chances right now.
Hmm, yeah I guess I didn't really write about the projects I did in my apprenticeship at all. That probably was the biggest issue. Thanks!
I don't see any previous work on production/non-academic projects listed. Unless the job was tangibly related to Meteor your Github page might give the impression you don't have a lot of practical experience. Also you say it's a frontend dev job, but to be honest your site misses the functional design goal of a resume page, which is to allow someone to quickly and effectively navigate what you have to offer the company. I mean, more than half the page on my screen is just random pictures and the other half is not easy to navigate (the section buttons don't even have labels). It took me way too long to scan to see if you had any previous jobs listed. Creativity in this case might be a euphemism for "too flashy, not enough meat". All that said, I wouldn't give up! It's good to put yourself out there so you can learn to harden your soft spots.
lower pay, lower responsibility
Oh my god, this is incredible. I am going to put this on *everything*.
Our proof-of-concept started with Express. We looked at Hapi specifically because: 1. Express had just seemingly exploded 2. We were talking about HTTP/2 Support 3. Hapi has [quite the community](http://hapijs.com/community) (Walmart, Yahoo, PayPal, Mozilla) which mitigates risk for management. Configuration-centric design is a nice benefit. Despite what [some projects](http://gulpjs.com) suggest, configuration scales well. We can implement Our Hapi prototypes have gone together faster and with less code than almost anything we've built before (admittedly this is one of our first forays into server-side JavaScript). This is prototype work, but 145 lines of code produced a traffic-splitting proxy with full logging and an admin interface that can live-load a new config to change the routing without restarting the server. We even ran a multivariate test [using confidence](https://github.com/hapijs/confidence) during a live demo because one of the managers asked if it was supported. While the attendees discussed how much more complicated it was, the presenting developer implemented it.
A flashy page doesn't really say much about your coding skills, and unless you're applying for a role that very heavily focused on design, such a page will probably work against you. If you notice, marketing and sales websites are usually very simple, with all of the important information 'above the fold', with few (if any) UI effects like animations, etc. There's reasons for that. As an interviewer looking for someone with JS skills, the last thing I want to do is suffer through a ton of animations and such looking for the info. As others have pointed out, it's pretty heavy -- on my MBA it's still [janky](http://jankfree.org/), and I can imagine it's much worse on mobile. I would highly recommend removing all special UI effects, and making a single [long] page website with minimal graphics (just a pic of yourself and maybe a header image should be all you need). Now, perhaps they got passed all that and got to your code. When I finally found your code, I was pretty put-off by your lack of semi-colons and lack of braces: if (!dev) plugins.push(new webpack.optimize.UglifyJsPlugin()) if (!dev) plugins.push(new webpack.optimize.DedupePlugin()) Maybe you have very good reasons for both of those decisions (though I don't see you talk about it anywhere...), but I think a large majority of professionals would disagree with you. So, if you're trying to market yourself to others, you may want to reconsider if your ideological beliefs are more important than getting hired.
This is amazing. I can't wait to sneak this into a menu as an option to be enabled. 
I guess some some of Projects the I worked on in my apprenticeship would have been great to mention. You're right, the site not very good from a usability perspective. Thanks! I really appreciate your help. :)
I'm thinking Konami-code Easter Egg, personally. 
As others have said, lower pay. If you've got some senior developers already, you can hire some junior developers to do some of the easier work and free them up for the hard stuff. If you also have them mentor the junior devs, and you keep paying them appropriately to their skill level, you can end up with some good mid or senior developers that really know your business well. Of course, you risk losing them to another company at any time, and that risk is greater if you don't pay them well enough.
Cheet.js
&gt; They said that they were searching for someone more senior Your CV says you're fresh out of school: https://lucaschmid.net/resume-wimdu#/en/03_cv Were you applying for a senior position? If so, you need to at a bare minimum demonstrate some experience working in a team (and by working, I mean at a job). If you just sent a generic application and was hoping for a junior position, then it's probably just a case of bad timing/not being a good fit for currently open positions. In terms of content, it comes across as describing that you're someone who is interested in learning (which may be true and is fine if it is true), but you're marketing yourself here, and the person reading wants to see someone who can bring something useful to the table to contribute to their business, not someone they will potentially need to spend time to train/coach/hand-hold. UX: first page is pretty useless, links only appear in third page and there's no menu (and the dots on the side are missing title attributes...). The order of sections is very weird, use a traditional resume structure (contact/education/misc or contact/work experience/education/misc). Content density is fairly low. Highlight your work in your portfolio, and give brief descriptions of how you have overcome challenges. Also, don't highlight popularity in a project w/ only 24 stars... Explain what problems you're solving instead. 
Exactly :D
It remains to be seen. Projects often find their way to a foundation when they *mature*, i.e. more maintenance work than feature development. One patch was released in the last eight months. The previous eight months saw 13 releases of 4.x alone, including three minor versions. If it does settle into maintenance mode, there's nothing wrong with becoming a stable platform. Stable is good for maintainability. Stable is good for keeping your skills relevant and sharp. Stable is good for business. If you stand up a new Express server every six weeks, you can probably estimate the effort accurately. It might pick back up, but I won't put money on it.
Many juniors lack only experience, not talent or drive. In one to three years, the junior will be a senior with an extremely intimate knowledge of your product and likely less pay than a new senior hire. Plus, I only know very few people who came out of the womb at the senior dev level. Are you saying you've never been a junior?
Perhaps he's following the [Standard JavaScript](http://standardjs.com/rules.html) style. Although I'm sure most senior devs have their own opinions but you must agree that following a set style is always better than following no style at all. I'm curious if the lack of semi-colons triggers a code smell. Would you describe it as such? Could it be that the reason is because you and many other more senior developers have a background in a language other than JavaScript?
Yeah, if you're going to go into front-end development employers are going to want to see some ability to execute on mobile.
I did indeed follow Standard JavaScript style.
&gt; I'm curious if the lack of semi-colons triggers a code smell. Would you describe it as such? If I see one or two missing, it's a code smell of poorly-written code. If I see them all missing, I assume it's someone trying to be edgy in code and/or that doesn't (or hasn't) worked in a team environment. &gt; Could it be that the reason is because you and many other more senior developers have a background in a language other than JavaScript? I can only speak for myself, and JS is my first and primary language. My rationale is that the end of statements should always be punctuated by a semi-colon, period (I've yet to hear a compelling argument to the contrary). Sure, if you "know what you're doing" you can get away without them, but I believe that's a fool's errand to waste brain cycles on as it buys you absolutely nothing save a single keystroke.
The only thing you can listen to is **that** actions were dispatched not what changed or what the action actually was. The only way to react to something based on the action is to use a middleware like this: export default function middleware() { return next =&gt; action =&gt; { if (action.meta === 'logme') console.log(action); return next(action); }; }
Thanks!
Thanks for the concise critique. &gt; Usually Engineer titles can be reserved for more senior developers I didn't even know that. Though they did write 3 years + in the requirements. I would have actually met that requirement if you counted my hobbyist activities / open source work (2+ yrs actual work). I focused so much on flash (which ended up not being very good), that I totally forgot to write about all requirements. 
I've put clippy into projects before. I like to just hide clippy behind the phrase "dear". For instance go here https://app.simpli.fi/login and type "dear" (not in an input though). You can also type "snake". I've long since left this particular project but the team that is there now has left these two easter eggs in place.
Makes me wish I worked on a xxx site. "It looks like you're trying to bust a nut. Do you need assistance?"
I was trying to make an "I am old" joke.
&gt; Were you applying for a senior position? [Not really](http://app.jobvite.com/CompanyJobs/Careers.aspx?c=qZh9Vfw4&amp;jvprefix=http%3a%2f%2fwww.wimdujobs.com&amp;jvcategory=IT&amp;jvresize=http%3a%2f%2fwww.wimdujobs.com%2fwp-content%2fthemes%2fwimdu%2fframe-resize.html&amp;nl=0&amp;page=Job%20Description&amp;j=oGRaZfwq). &gt; not someone they will potentially need to spend time to train/coach/hand-hold. I haven't thought about it that way... but I guess you're right I agree now about the UX. It's horrible. I'll definitely structure my next application in a more traditional way. Of course I'll also leave away all the flashy shit. &gt; don't highlight popularity in a project w/ only 24 stars... Yeah, that's kinda embarrassing. Thanks a lot! :)
I think I get where you're coming from, all of the Ruby people moved to JavaScript and instead of adopting it they're slowly changing it to Ruby.
As far as the online resume: * It looks really cool and the interaction and scroll transitions work really well * The modification to the history (changes to the page address) are really annoying. Consider instead using `window.replaceState` to replace the current step in browsing history, or my old school favorite: `location.replace()` * None of the page content displays in Firefox. I only see the pretty background images. Always test in multiple browsers. As far as becoming more senior I recommend this guidance: * https://github.com/prettydiff/wisdom/blob/master/Web_Education.md * https://www.reddit.com/r/javascript/comments/4fmjgn/i_have_learned_about_context_hoisting_inheritance/d2aaw40
Ballsy title bruh
I don't understand the aggression towards me. I am a software dev student, and I was just wondering. Thanks for the answer though.