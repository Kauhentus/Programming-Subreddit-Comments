Super useful: http://youmightnotneedjquery.com
Do you prefer dart semantics to pure ES6 semantics (and browser strict-mode semantics) wherein block scoped functions are hoisted to the top of their containing block?
Thank you!
Best way is to use a &lt;link&gt; tag to link to a separate .js file, but... An easy way to do it is to just put the &lt;script&gt;&lt;/script&gt; tags write in the body of the html. Like this: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;!--html goes here--&gt; &lt;script&gt; //javascript goes here &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
In 'C' terms, this would be called `undefined behavior`, which is a code phrase for saying 'Don't do that!' The correct way is to use function expressions, instead of function statement. var func; if (true) { func = function() {return true;} } else { func = function() {return false;} } 
Yes, but don't do that. You're better off just linking to a separate file via &lt;script src="filelocation"&gt;&lt;/script&gt;
Nope.
Yeah, what that guy said.
I was done as soon as he mentioned they seriously used Angular.
Why would it not be cached? Either way neither of those things are important considerations for someone who has only been using js for a couple of hours. 
Hey thanks for the reply, The reason I wanted to try this client side is because I was hoping to show off a simple login page with working authentication by Sunday. I know that this is always done on the server side of things for security reasons but we don't actually have our server up and running yet. Since there is nothing out there, what I'll probably end up doing is just putting the authentication on halt till I get Node.js working. The reason why I thought this might be possible is that you can literally write a python script to do this with just importing the ldap library. Though I'm not 100% sure how secure that method is.
As a JS Dev who is currently doing Swift full time, I'm skeptical, but seems neat. There is a lot of stuff I love about Swift as a language itself, but JS has such incredible community support and frameworks that would be hard to utilize with this.
[I wrote it for you](http://pastebin.com/ME6mCi64) *edit* In my haste I forgot to add the following to the bottom: app.listen(3000, function() { console.log('Listening on port 3000'); });
If you don't have `classList` and you know the className isn't already on the target, you can do this quick and dirty. for (let li of document.querySelectorAll('.li')) { li.className + ' new'; // Note the space } If you an't sure if the className is there or not, or you want to remove the className, there are some pretty good code snippets that I could dig out if you want. 
Seems like my situation. I did some JS in college and the next June I'm gonna graduate. But seems unlikely travel to US to fins a new job, couple... wants to stay on our town.
[Like this?](https://github.com/yeoman/generator-gulp-webapp)
What exactly were they trying to do? Never heard of them before.
The difference in effort between node and rails depends directly on the experience of the developer in each environment. The length of time and ability for a developer to accomplish the task depends on a developer's experience building full-stack applications.
Along with what these guys said, know that if you are using console.log(), you will need to open the chrome console to see it
Which, in case OP does not know what that is, press F12 in chrome. This also works in Firefox.
It's been one for a while now, but it's still pretty much of a moving target. On every compiler update I have to modify something in my Swift code to get it to compile again.
I'm sorry, but this article is not useful for someone who has never been formally introduced to the concept of functional programming. The statement "functional programming is all about composing functions together" (from part 1) is dead wrong. Functional programming is about data and the way we interact with it. The functions are the paradigm, not the reason. Second, you just breeze through the maybe definition (which is woefully poorly constructed and does not adhere to common option type paradigms) without any discussion of data types or what an option type is. Yet you expect people to understand what you are doing and/or why. Third, instead of using the idiomatic (and debugging friendly) function definition you opt for the ES6/ES2015 arrow lambdas, which most beginners find confusing and difficult to read. This means your code is harder to follow and, worse, it leaves everything standing with anonymous functions, which is generally considered bad practice. Finally, you dive into using the functional jargon like functors and currying, but I have a strong sense you don't fully understand what the words mean or what they REALLY do. For example you talk about map taking a function and a functor. Map IS the functor. Functors map one set to another, mathematically. All of that said, I do have some more constructive criticism: Slow down. Break up bite-sized pieces and offer little bits to your reader so they can chew on it and understand what you are talking about. Option types alone could take an entire chapter of a book to explain in enough detail that the user could make sense of it. Also, make sure, as you are writing your articles, that you are researching the concepts and terms you present. It is really painful for learners to encounter articles which aren't fully researched only to discover they have to start over again because the information wasn't accurate.
&gt; Block-level function declarations were supposed to be disallowed in ES5 strict mode, but ES6 changed that. True but not the whole story. If you're curious: going back to the beginning of JS time, ECMAScript said functions in blocks were syntax errors, but browsers ignored that and said they did things. The things they did were many and varied and no one agrees. Regardless, much code was written which, for the most part, targeted the intersection semantics supported mostly uniformly by all browsers. Then, during ES5, we realized we would eventually want block-scoped functions, and since we added strict mode, we might as well make block-scoped functions an explicit error and get the implementers on board. This was successful - all browsers agreed that strict-mode block-scoped functions were syntax errors. ES6 then added a standard semantics for these functions (in both sloppy and strict), and then an effort was made in Annex B to define an interoperable semantics for these functions in sloppy mode for browsers that have long supported the syntax. ES2016 has made even more progress in defining the behavior of these functions as implementations discover new corner cases as a result of implementing the Annex B semantics. &gt; So, I basically just hate the useless ES5 behavior. As the guy who helped with the Annex B semantics and done much investigation into the various disgusting patterns people have written and various disgusting implementations of sloppy block-scoped functions, *I completely agree*. &gt; That was a good question. :) Thanks :) When I don't understand something I find it's better to ask questions than to just assume the questioner is wrong. Principle of charity and all that.
Indeed. Build stuff. Honestly anything you build, any mistakes you make along the way will all contribute to learning. Experience is really something you can only get with time. Books are a good start, but how much do you currently know? By understanding what you do know, you can identify the things you don't, then you can grow from there. Second (less rhetorical) question, what books do you have? 
For the same reason not all programmers use any other tool, I assume.
Right? I don't understand why people have hard time understanding this concept. Even versions with codename will have LTS support meaning less releases and only bug fixes and security patches with 18 months of active maintenance and then maintenance mode. Odd versions have more rapid development cycles (one or two weeks).
Individual pages along with any inline js do get cached. But less efficiently than a shared script include that only needs to be downloaded once and then gets used on every page. 
Please note that this language is very much still in alpha. I'm open to constructive feedback.
Yes, I had a chuckle but to elaborate on this. React's API is quite minimal giving you the "View" portion of MV****. Also, I think this is often less said about React but it adheres to functional approach that just seems to make sense in JS rather than have this adhoc OOP that other frameworks introduce.
It's a learning curve for some people I guess. A lot of people getting in to JS development have had a very different experience when it comes to versioning and even people who have been developing for a long time still misunderstand it - some never really encounter it, but it is helpful to understand, especially in an Enterprise environment.
Databases are a complex topic with no single answer. This article reminds me of this video: https://www.youtube.com/watch?v=JWaDa8taiIQ
http://tympanus.net/Development/ProgressButtonStyles/ Same thing without angular.
Npm I -g bower@{MAJOR.MINOR.PATCH}
I disagree. This person is obviously a beginner and using a simple script within the file is better for learning than trying to figure out how to link an external file. Having both in the same file is easier to track and make changes for a beginner. 
 &lt;head&gt; &lt;script src="directory/filename.js"&gt;&lt;/script&gt; &lt;/head&gt; This is what I think he meant, and what I presume is good practice.
if you plug your midi keyboard in you can broadcast what your playing to anyone else connected to your space
Please post a link to the site so I can see whats going on
what does the code in your html for the text box look like ?
Sorry, thought I did. FanGurus.com
Why do you say learning MEAN is too ambitious to begin with?
I had this happen not too long ago and I had to do two things: install a dependency that was missing from a package (it was tether.js) and then I needed to remove the existing bower_components folder and then run install again. This was particular to my case, but definitely try the latter.
Right, I fixed that bug, the game works again. I don't know how to simplify it well, everything is connected
You need to learn the core concepts first, before learning the technologies built on it.
An analogy: You're wanting to build a 18 Wheeler before you understand its fundamentals. Start with a go kart first and take it piece be piece.
Oh, right. I was gonna take it section by section, learning front end and then moving to the back. At what point would you recommend I learn the higher level frameworks?
I agree. His blog is one of my favorites.
[getElementsByClassName](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName) would put them in an array according to MDN. var v1 = document.getElementsByClassName('*whatever*'); // for loop here to iterate over the v1 array 
OR this is a well-established union of paradigms that engineers are realizing makes sense for systems at large scales. In an attempt to be holier-than-thou, you've just shown you don't really get it.
Fun... good work!
Well, to start, do you understand JavaScript? How far along are you with the language itself? Because if you are still having trouble working with (and understanding) JS, then you might need to focus on learning the language. If you *do* know JS well-enough to accomplish most tasks and understand how it works, then read on. The stack you are talking about is MEAN, so I'll go over that: 1. M: MongoDB MongoDB is a NoSQL database which can be really good or bad depending on the app you are building. It uses objects in collections to sort through and store things. If you want a simpler, more understandable database example (one that uses SQL), check out MySQL as it is very simple and breaks down into a nice table schema. P.S. For this stack, you'd use a module called "mongoose" to interact with the database from Node 2. E: Express Express is an amazing framework that makes routing (among other things) a breeze. This is essentially where you back-end logic starts. You'd use express to create the server and listen for requests on predefined routes (ex. `/api/posts/:postId`). However, in this stack, you really would only do specific routing for the api because Angular will handle the rest. P.S. Express will probably be the easiest thing to wrap your head around here. Find a nice tutorial online and it should be pretty simple. 3. A: Angular Angular is an MVC front end framework. If you aren't familiar with this pattern, don't worry. It stands for Model, View, Controller and there are plenty of guides out there to make it digestible. But in essence, the Model (Your mutable app) is separated from the View (What the user sees) which is separated from the Controller (What you use to change the model and perform other actions). P.S. Angular is pretty rocky to start with, but it gets better. Just stick with it and you'll get it in no time. 4. N: Node Node is the awesome thing that lets us run and use JavaScript for all sorts of things. It has its very own package management system called "npm" that will deliver you all the dependencies, libraries, and frameworks you could ever want! The only difficult thing here is getting used to how modules are linked in to your code (ex. `require('express')`) So: * Node would run the code that you've written on the backend * Express would be called from within that code and be told to listen to a port and await requests * When a request for `/` comes in, express sends over your `index.html` file * The browser then requests some things (css, js, images, etc.) and express sends 'em over * Angular makes a request for some data at route `/api/posts` * Express fields that request and runs some code we've written to talk to the db * MongoDB interprets our query and returns results (in JSON) * Express then responds to the request with our data (still in JSON) * Angular receives that data (stiiiiill JSON) * Angular will do something like update our `$scope` variable which will, in turn, modify the view and our user can sort through everything I'll give you an example of a simple MEAN web app in another comment.
Their new site doesn't even give you a demo of the software. You have to call a sales rep. Like - WTF? It is woefully hopeless.
Linters don't rewrite your code - they just call out (usually underline) portions of your code that have a potential issue. If the linter says something is a potential issue and you disagree, you can just change the config to specify that it's not an issue. In my experience linters actually save time in interpreted languages because they catch issues (like use of undefined variables for instance) that you usually wouldn't catch until runtime. If you format your code extremely well, that's great, but how do you get other members of your team to do the same and stay consistent with them? 
There are tools that all programmers use. An OS, a parser, a text editor / IDE. I think that when programmers don't use a tool, there are specific reasons that relate to that specific tool.
&lt;input type="text" id=Value1 onchange='' placeholder="$"/&gt;
I ran a test. It's not the javascript that is making it that slow, it's the server. It takes the server 10 seconds to resolve the request, and then 2-3 seconds to actually load the content. What kind of hosting are you using?
I think it's probably something else, other than that then. So my other question is, how do i set a forloop to do a calculution stored in a variable? 
What the hell, man? Why are people so talented!? So jelly.
This is awesome, gonna try it with some friends tomorrow.
Thanks for the positive feedback man! PLug and play midi capability with the google web audio API is so badass
Yep, thanks for the tip. That is probably a better place. Was posted here, since sometimes array deletion is forgotten or misunderstood even from the experienced ones. For example, Ryan Dahl asked this from the audience during his Node.js presentation. https://youtu.be/jo_B4LTHi3I?t=1957
I'm super interested in this language, I really am. I have two suggestions though: 1. Please put in some option to make the tutorial easier to read. I don't like having to click next 30 times to get to some meaningful information. An entire chapter on one page would be preferable. 2. It might be smart to descript the `in` keyword on the landing page. You describe a lot of the language, but the `in` was very confusing off the get-go 
My assignment is when the user inputs values into text boxes and those values are stored in an array, and they press a button, the button calls the function containing the for loop and should print the answers in the remaining text boxes. The for loop is being used to calculate the totals. The equation to calculate totals is given to us , but I'm not sure how to apply it to the array using a for loop. 
There are two ways you write javascript inside HTML. One ways is to include the external js file and other is to write javascript code inside the &lt;script&gt; &lt;/script&gt; tags Method One: &lt;html&gt; &lt;head&gt; &lt;title&gt;My Page&lt;/title&gt; &lt;script type="text/javascript" src="my-script.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="user-greeting"&gt;Welcome back, user&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; Method two: &lt;script style="text/javascript"&gt; // your javascript code goes here &lt;/script&gt; Here are some helpful resources to learn more about that. http://stackoverflow.com/questions/436411/where-is-the-best-place-to-put-script-tags-in-html-markup http://www.snoopcode.com/javascript
the process of adding two strings together like you are accidentaly doing here is called concatenation
Do you have code you can post so that we have a common thing to speak about? Not knowing even what arguments you need to pass to this function makes it difficult to suggest a solution.
I watched one of this guy's talks at some event he himself put on. He did seem really smart, but he said his business plan was to build this awesome framework, release for free and then worry about the money later. Seems like the investors finally came knocking. I think the flaw with famous is that it is trying to beat the browsers at their own game. Reimplenting native DOM stuff in webgl to get better performance where browser rendering engines had not yet been optimized. Similar to [Flipboard's react-canvas](https://github.com/Flipboard/react-canvas). The problem is that the browser vendors are constantly improving their rendering engines. So is it really worth it to invest so much time and lines of javascript in gaining a performance edge, only for that edge to be eliminated when the browsers inevitably catch up? 
God I remember getting a million emails from them hyping their framework like nobody's business. not surprising it fell into obscurity with a ton of financial baggage considering how much they focused on marketing instead of shipping. 
So nextgen I scala'd all over my keyboard!
1. Chapter 2 is pretty huge, so I would still need to split up stuff a bit. I think you make a good point, though. Every section should probably have at least a page of content. I definitely still need to work on organization. 2. So on [this page](http://squiggle-lang.org/) you think I should explain that variables are scoped to the expression after the word `in`?
Also please check it out on GitHub. Please check out the open issues and feel free to contribute, even if you're unsure about your JavaScript skills, or have never worked on a programming language before. * [Compiler on GitHub](https://github.com/wavebeem/squiggle) * [Website on GitHub](https://github.com/wavebeem/website-squiggle/issues)
I doubt non- Scala devs will turn to this, but I like and agree with many points in his presentation about the rise of JS as a compile-to platform and how server side rendered pages of old are falling (have fallen) out of favour. We need more of this - more languages offering good compile-to options.
It is a compiler, not a framework. Both React and FRP frameworks (there are also native ones like Scala.Rx and MetaRx) are very popular to use with Scala.Js...
Having attended a couple of the early "invite only" events put on by famo.us, I am not surprised it's all gone to shit. Newcomb seems to think he's the second coming of Jobs - tries to hype up the crowd with confusing and half-arsed announcements, followed by pause for applause. There was never really any substance there. Sadly, the devs working there were wicked smart. They just got sucked in because of Newcomb's charisma. Hopefully they can now move on to something that's actually going to progress their careers.
It's never necessary, ever. Throw those variables in data tags yo. Have you ever tried to debug or migrate a site that someone else has written, with dynamically generates inline JS littered all over the place? Absolutely awful. 
We are using godaddy premier plan. Im getting mixed comments on what is actually making it run slow. Most say scripts, etc and some are saying the server. 
dude, you are awesome.
You'll need to create a constructor for your class that takes a net.Socket as an argument and does all the necessary initialization based on it.
Because he learns a lot of and about programming and management from having to build and maintain a language.
The aproach to use the same language on both client and server without being Javascript (like Node.js), share code, classes, and have the rpc calls verified and typed I would say is next gen. 
why not a docker-compose.yml ? :-) &gt; Provide a clear README with instructions on how to setup and run the app. docker-compose up open $(docker-machine ip default):8080
No. The current syntax doesn't require you to look backwards.
The framework used WebGL to render content in the browser, instead of HTML/CSS. 
Typescript was already a popular and successful language well before Angular 2.0 was even conceived. I'm also confused why you think squiggle and react would be mutually exclusive?
Please add more keymaps. I had trouble typing with my german qwertz layout. :)
Consider using [composition over inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance). Is the telnet client *really* a special kind of socket? Like a man is a special kind of animal? Looks more to me like a client *has* a socket. Otherwise you're cramming too much functionality in the class, i. e. it has two responsibilities: sending and receiving bits *and* handling the telnet protocol. A violation of the [single responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle). 
You are not wrong. They are awesome :D
Some people just want to watch the world Learn.
I like it. One thing I found myself doing was typing 2 wrong letters, but only one shows up. I instinctively hit backspace *twice* to correct, which deletes the first wrong letter, and an additional (correct) letter. This is not the same behaviour you would see when typing normally, and might even teach bad habits around using the backspace key.
&gt;truth be told, the more recent versions of IE (meaning 9+) really aren’t all terrible. Sure, they lack a lot of common browser functionality that should be core to all browsers And, with that, we understand the writer and have no need to read any more. He's a clueless idiot at best.
it's more rewarding to learn javascript itself, rather than focusing into frameworks like angular/react. When you feel comfortable enough with JS, then go learn them. I said this because in the front-end world, things are moving fast. it could be angular today, then react tomorrow, and some other frameworks later. But they all have one in common, which is javascript. go learn callback and Promises concept, it's the base of javascript's async nature.
*sigh* at all the "learn my favorite framework" suggestions... I've turned no fewer than 5 wet-behind-the ears junior devs on my teams into JS Jedi over the last few years by insisting that they *don't* lean on frameworks and really go after the hardest parts of the language and understand them without crutches, so that when duJour.js goes out of style next week their skills don't. Learn frameworks (MEAN/React/whatever.js) *last*. Learn Node. Learn the Open Web. When you have mastered those, mastering whatever framework everyone is slavering over that week will be a breeze. My book/tuts progression reco is http://jqfundamentals.com/ (free) -&gt; "Secrets of the Javascript Ninja" (by Resig - I think it's like $30) -&gt; "Javascript Allonge" Good luck. 
http://www.payscale.com/research/ES/Job=Software_Engineer/Salary/690f492c/Barcelona 20 - 50k euro a year. Not great but then from what I've heard Spain's economy is pretty shitty at the moment.
It should work in ie10 and higher, but only adds a single class at a time. I think edge allows multiple like chrome and ff. 
There are no variable types in ES6 so downcasting isn't a thing. What you _can_ do but _shouldn't_ do is reset the prototype of your instance once you get it with something like `Object.setPrototypeOf()`. This would let you effectively change the type of the object by altering its prototype chain, giving you access to your user-defined methods, but you don't get your constructor called for the instance meaning you could end up with a corrupted state. Also this is bad practice and very bad for performance, so I'll repeat, **you shouldn't do it**. However, I mention it because its effectively what you seem to want to get by downcasting. If you're not responsible for instantiating your instance, and what does is not able to use your constructor for instantiation, then you'll most likely want to handle this through some form of association or do something more functional where you have a set of independent methods that act on a socket instance. Functional is good if you're not dealing with any kind of additional state, otherwise having your object be a wrapper for the socket instance works well.
Bitter tears and resentment. That's what it means.
&gt; [...] truth be told, the more recent versions of IE (meaning 9+) really aren’t all terrible. Except that using any version of IE requires a particular OS + Service Pack. If you don't develop on a windows machine and want to test in ANY version of IE, you need to run a VM of windows to boot the browser up. This is simply not the case for any other modern browser in existence today. I can install the latest version of Chrome on Windows XP but I can't install IE9+ ... if that doesn't scream of terrible design then I don't know what will convince anyone otherwise. The fact of the matter is that IE is still terrible for developers and will continue to be terrible until they remove the Windows requirement for using it. This tight coupling is my primary issue with IE.
I'll see what I can do. Can html elements have IDs and classes containing German characters?
&gt; IE8 &amp; IE9 no longer receive security updates from MS. IE7 and IE8 are both still officially supported [up through January 12, 2016](https://support.microsoft.com/en-us/gp/microsoft-internet-explorer). It looks like IE9 will continue to receive support [until April 11, 2017](http://windows.microsoft.com/en-us/windows/lifecycle).
Check out BrowserStack, it allows you to virtually run pretty much all browsers on a VM inside your current browser.
Hmm Safari 5 is available for windows, I guess they discontinued support.
Makes sense. Their framework looked cool but never solved a real world problem that I had.
Using babel this compiles down to: 'use strict'; var _iteratorNormalCompletion = true; var _didIteratorError = false; var _iteratorError = undefined; try { for (var _iterator = document.querySelectorAll('.li')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) { var li = _step.value; li.classList.add('new'); } } catch (err) { _didIteratorError = true; _iteratorError = err; } finally { try { if (!_iteratorNormalCompletion &amp;&amp; _iterator['return']) { _iterator['return'](); } } finally { if (_didIteratorError) { throw _iteratorError; } } } WTF apart, maybe a simpler (and ponyfillable): Array.from( document.querySelectorAll('.li'), function (li){ li.classList.add('new') }) is better?
Using Array.from for side-effects is kinda iffy. That function on the right is supposed to be a map function. Plus, you didn't include the Array.from polyfill. Core.js adds how much? 30-ish KB or so? If you don't want polyfills and if you're worried about the size of the output, use `[...qsa()].forEach` instead.
I haven't had to support ie8 in 18+ months .. until .. this last week. Launched a career site for a large corporate client and only then did they inform us that internally all their users are on XP / IE8. Normally we would charge double for that, but they're a retained client with lots of other services with my firm so we bit the bullet and I spent last week bashing my brains against my desk working on it. Still better than years ago when I had to support both ie7 and ie8 though. 
We only support the latest versions of the big 3 (IE11, Latest Chrome, Latest Firefox) at my shop, but we're an application shop that happens to have a web interface, not a website shop. Even dealing with IE11 is a pain sometimes.
The SV investing scene is absurd.
~~~~This is really trivial, it would probably be best if you put jQuery aside for a weekend and learn basic programming concepts. Neverthless, maybe this is what you're looking for?~~~~ JavaScript has a built in `Array.isArray()` function, so use it to test if the first element in the array is an array. From there you can iterate through that array doing as you wish. if (Array.isArray(array[0])) { array.forEach(function (arr) { console.log(arr[0]); }); } &gt; that's an ice-cream topping &gt; that's a pizza topping &gt; that's a car part Edit: Ignore my response, misread the question see /u/cclites
If all you are doing is searching the first part of whatever string the user inputs, you could simply tokenize/split the string and use the first result as your search parameter. var userInputString = "fleas love bees", tokens = userInputString .split(" "), searchString = tokens[0]; if ($.inArray(searchString , array[i]) !== -1) { return array[i][0]; } That should get you a little closer to what you want to accomplish.
Oh, is it ML-like? I was going for somewhere between Python and Haskell? :)
What about just a simple `Array.prototype.forEach.call( document.querySelectorAll('li'), function (li){...})` instead of using another non ponyfillable syntax construct?
Hi /u/COmountainclimber, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
There's some serious kool-aid in this article... &gt; We come from a time of object-oriented programming (OOP). A time that is dominated by imperative actions: Do this! Do that! Set this value! Remove that object! That time is over. The future is functional.
No, you'll likely still have pay insurance out of your paycheck after they take close to 40% taxes out of your paycheck. If you're employed in the US, it's usually mandatory that the employer takes the money from your paycheck to pay for your health insurance. You don't have a choice. And the insurance doesn't cover shit. You'll still have to pay $20-$40 every time you see the doctor, and once they do any lab tests you'll be paying plenty for those too - hundreds. If you have any kind of surgery you'll end up paying many thousands of dollars, the insurance covers very little. It's very common in the US for families to go bankrupt due to medical bills. 
It works, but the fact that such a solution exists only strengthens the parent's argument. 
Not yet at least. I was thinking in the eventual helper library I could expose them in a strongly typed wrapper as functions, but I almost never use JS bit ops, so they have not been a priority.
"Simple". [].forEach.call looks like ass. [...qsa()].forEach and for-of work just fine with TypeScript and Babel. I don't believe in artificially lengthening the lifespan of older non-evergreen browsers. I also don't think that writing ES5 is a good idea. One or two years ago? Sure. But nowadays? TypeScript really helps a lot and Babel is a decent stopgap solution.
While it may present itself as a solution to lack of IE support cross-platform, I think the main goal of the software is simply to switch between browsers (including all previous versions) rapidly. I'm a web developer and find it to be an incredibly useful tool :)
Sure :)
Your reply indicates that you haven't actually read the guidelines that I linked. Did you?
A couple of years ago when HTML5 was the rage IE actually had better performance than FF and Chrome on a lot of the canvas API and invented some stuff other vendors later adopted. Claiming IE isn't that bad anymore completely invalidates his opinions? Have you even used any of the later versions or are you just holding on the IE hate train? Times have changed, and the differences between browser vendors isn't as big as it used to be. At my company we don't support anything earlier than IE9, and my experience is Safari is a bigger problem than IE9. You won't learn much new if you ignore anything that contradicts your world view. Disclaimer: Haven't read the article. (Notice how I didn't call you an idiot or invalidate your opinion just because I disagree with you?)
I'm really not sure what you mean. What about `from 'module' import { thing };` requires you to look backwards in parsing? Do you mean as a human reading it, or as a JS Engine parsing it? To me if anything this is easier, because it reads more directly left to right like `module.thing`
Thank you for the recommendation, I'm going to check those materials out soon! Would you mind explaining the difference between learning Node by itself, and Node as part of MEAN? Also, this is the first I've heard of "Open Web", would you mind giving a bit more detail?
All of these things are really great, but you can get most of them using JavaScript with Flow/Typescript and something like ImmutableJS (as you mentioned it's not quite as good, but it gets you most of the way there). The downsides of using Scala for the frontend are: * Lack of developer familiarity -- much harder to hire for * More difficult integration/use of JS libraries (you can do it, but it's not as pleasant) * Poorer performance with regards to JS output size. (From scala-js.org: "In sbt, the optimizing task is called fullOptJS and is applied on the result of fastOptJS. The result optimization is typically between 150 KB and a few hundreds of KB."). This can be really debilitating especially on mobile. * Scalajs shines brightest when using Scala on the backend for shared code, but when you aren't there's less benefit.
Right now I use SublimeREPL, can you sell me on this?
Thank you! I fully intend to learn JS to the best of my ability! I'm just thinking ahead a bit. The program I'm starting teaches a framework as the very last part, so I'll have months of pure JavaScript learning before even touching it! I will definitely make sure to pay special attention to callbacks and Promises and learning them well. Thank you!
Copious amounts of booze
&gt; Because canvas is the important part of an average website... ;) No it isn't, but then again an average website is not where you're going to find the big headaches. My point is that vendor politics isn't as black and white as OP seems to believe.
whitespace is important! There are syntax errors in your provided code -- the mpayment line isn't valid mpayment=(2500-DPay)*(Math.pow(1.00416667,72)) 0.00416667 / (Math.pow(1.00416667,(72-1))) Unexpected number near the `0.00416667` var INPUTS = 2; var multiplier = ( ... ); for (var i = 1; i &lt;= INPUTS; i++) { var input = document.getElementById('data'+i) var output = document.getElementById('cal'+i) output.value = (2500 - input.value) * multiplier); } 
&gt; It looks like IE9 will continue to receive support until April 11, 2017. On Windows Vista *only*, and that accounts for a pretty small proportion of web users. I'd be interested in stats for major sites as to how many IE9 users are on Vista v. 7.
Recommended. Really like it how straight forward / simple it is.
&gt; A couple of years ago when HTML5 was the rage The rage? News flash: it's still around and the current standard. You've now shown me your knowledge and experience in this. &gt;Have you even used any of the later versions I've been developing for the web since 2004 when people would say IE7 was a Firefox killer and IE had 90% market share. &gt;are you just holding on the IE hate train? http://html5test.com/results/desktop.html http://css3test.com/ http://caniuse.com/ I've got more. &gt;my experience is Safari is a bigger problem than IE9. Your lack of experience. If you think Safari is bad, no version of IE has ever been better. &gt;You won't learn much new if you ignore anything that contradicts your world view. I was going to say that to you. My world view is the big picture of the facts as simplified by the above links and exemplified by over a decade of experience working with all browsers daily. &gt;Notice how I didn't call you an idiot or invalidate your opinion just because I disagree with you? I called a spade a spade. Anyone can have a blog or write things on medium and other places as if they knew what they were talking about. This guy is just blurting things out that he read on reddit. He's clueless and I'm calling him out on it and no one should bother reading his article. It seems it must be a real page turner for you.
A lot of us don't work on average web sites, like any kid can, and those of us who use technology to its fullest, but can't get things to work in IE that work everywhere else, have been feeling this frustration since being told how IE7 was going to kill Firefox and then IE8 was going to crush Chrome and then IE9 was going to take over the world and then ... In the meantime, IE's market share has fallen from 95% to wherever it is now in your part of the world. This I know: IE is a minor player among web developers and other technical people who know the difference.
Yep, this is truly the next step for JavaScript as far as async things go. It's so awesome. Here's another JavaScript CSP channel implementation that works with async/await: https://github.com/dvlsg/async-csp
True, it's not the same as .NET because it doesn't sync threads out-of-the-box, but rather just async tasks on the same thread. But note!: You can implement a way to synchronize Web Worker threads in browsers using async/await, which can be very much a similar effect. Plus, in Node.js you can also synchronize "real" threads (non-workers) with async/await too. So, basically, this is potentially better than .NET's! :)
I think it's pretty cool what you have done, although I have some questions: Why would a developer use Squiggle over ES6? What are the key advantages of Squiggle in comparison to other compile-to-JS languages? Why underscore ? Why in undefined ? def handler(res, res) = let headers = {"Content-Type": "text/plain"} let _ = res.writeHead(200, headers) let _ = res.end("Hello world\n") in undefined
Honestly, just start doing it. Pick a project, build the part you can, then dig through the Node manual for parts you can't. Incoming: a huge list of books and tutorials. But ask everyone you know who you deeply respect as a programmer, and they'll tell you that the best way to learn is by doing. Exception: security.
Actually, Safari is tied to the OS so the same rings true for that, unfortunately.
Bower is dead. [This is at the top of the project's README](https://github.com/bower/bower): &gt; Bower needs resources for its maintenance. Please fill Support Declaration if you think you can help. Long live npm. With npm 3, flat dependencies is the norm, and npm devs are continuing to develop it to support both frontend and backend.
I'm sorry, perhaps the guidelines aren't clear enough. I'll work on revising them to make it more explicit. The short of it is, we can't have people simply posting the end-result of whatever project it is that they worked on. Reason is, just posting the result leaves little for us to comment on. It also opens the door wide-open for flagrant self-promotion, though that's a secondary concern. As a quick example, what if someone posts _"Check out my new project! www.google.com"_. For the sake of argument, let's pretend they really did create google.com... what could we possibly comment on that would pertain directly to JS? "Nice minification dude!" ...and that's about it. As a longer example, let's talk about your post; what could we possibly comment on? * bugs * praise/scorn * feature suggestions None of those really relate to JS discussion. Bugs _possibly_ could, but really only if we have direct access to the source. tldr: if you want to post your finished (or even semi-finished) project, then we need at least **one** of the following to go with it: * project page (github.com et al., which includes unbuilt source) * blog post talking about the development of the project * comment within the post talking about development of the project I hope that clears it up.
Opposite experience, recently moved into a more front-end position, and am looking to adopt some front end tools. I love JavaScript, and love working with it, but on the front end there are so many tools and options that quite frankly I don't see necessary. Any way I could get some tips on what tools to use to help out and increase efficiency on the front end and why? 
Supporting ie8 is okay. It's the "I want my flashy web 3.0 design to look exactly the same in ie8" that'll get you. 
You do know safari is a chrome clone now, right? (Notice how I didn't call you an idiot or invalidate your opinion just because I disagree with you?)
How would you go about implementing this once Swift goes open-source? Let Swift compiler generate AST and generate JS from that, or is it more complicated? (I don't know a whole lot about compilers.) Because it seems like a bit of wasted effort to try and write another Swift compiler, if Apple's is going open-source.
&gt; You're doing something wrong if you notice a difference between safari and chrome tbh, Considering Apple have the same issues on their website I'm not losing any sleep over it. &gt; particularly if you think the js interpreter is making your dom manipulations behave differently. What do you use to do DOM-manipulation? Edit: To add to my previous comment; Google also uses it's own fork of the webkit rendering engine (Blink).
Except that OSX (or iOS users) don't hang back on old versions to nearly as perversely as Windows users.
https://slackline.io/shared_channels/javascript
Just toggle: document.body.contentEditable=document.body.contentEditable!=='true'?'true':'false' document.designMode=document.designMode!=='on'?'on':'off' Bookmarklet: javascript:void(document.body.contentEditable=document.body.contentEditable!=='true'?'true':'false',document.designMode=document.designMode!=='on'?'on':'off')
The worst part is that it's difficult even finding a developmental environment for IE8—and don't go thinking that compatibility mode solves that, because there are some odd corners of compatibility mode that don't exactly match up with a real IE8 installation. A little over a year ago I had a major project that had to run on IE8. Of course, I developed it in Firefox, to use Firebug, and tested it frequently in Internet Explorer, using compatibility mode. Then, as we got closer to the deadline I had an IT guy at work set me up with a Windows XP VM running IE8. *Surprise, surprise*—several things broke, and it was a pain in the ass getting them to work.
Oh man, that's even better. It works! Thank you very much!
Safari's support is still pretty lacking compared to Chrome though, even if it is webkit.
My company uses rails currently. As a front end developer I don't have much opportunity to work on the backend though I could if I were to learn ruby/rails. However for whatever reason rails doesn't really interest me the same way full stack js does. I would love to introduce some javascript api's in my company. A few benefits I can see from my position as a front end dev: * One language, everyone can work on anything. * Server side react rendering. * It seems easier to find good js devs than it is rails devs. * Lighter weight servers * Faster growth in the language landscape * More functional approaches to programming * Consolidate dependency management and tooling. While I have very little interest or incentive to learn Java or .NET, it seems like server security, SQL, SSL are something that would follow naturally after learning how to create production ready web apps/apis in nodejs. Learning node.js will undoubtedly benefit my career, not only can I them work full stack in js, but I wager my overall javascript skills will progress significantly.
&gt; now the dust has settled and most things work on most browsers. Your lack of knowledge of the specs is showing now. &gt;latest Safari below latest IE in scores. Which solidifies my own experience. Yes, it does solidify your experience cause Safari 8.0 is at 396 and IE11 is at 336. Now, if you mis-read it, and applied the Edge numbers, instead of IE, you'll notice that Microsoft's brand spanking new Edge browser that they rave about only edges out far older Safari by six points. &gt;Calling people clueless without providing any argument makes you look stupid. I did call him out with lines from one of his opening paragraphs. A ludicrous statement making the rest of the article come under question. Anyone worth their salt knows how outrageous his statement is. &gt;for basically stating that IE relative to other vendors is not as bad as it used to be. He said "they aren't terrible" and compared to the others, it can't keep up. Why do we have ll the polyfills, hacks and tricks? Almost all of them are cause IE can't keep up. And now, Edge. Same browser, different name (mostly). &gt;Things change, don't be stuck in 2004. Yes they have and Microsoft can't keep up. And neither have you.
People have always been very generous with their interpretation of HIPAA laws though. For example, requiring a user name *and* a password was frequently justified as "two-factor" authentication.
Hi, I'm the author. Just wanted to comment that the class is progressive, so the first few sections set the groundwork for understanding things like closures, prototypal inheritance and others that come later in the course. Also execution contexts and scope aren't truly interchangeable (at least they shouldn't be). Scope is a result of how contexts are structured, and understanding how they work make understanding things like closures *much* easier, which we go through in the course. Thanks!
Yes, the code used to color correct inputs and incorrect inputs searches for class names. These class names are set by the text itself. Let me see if I can figure something out...
+1 to Node.js being beneficial, career-wise. I dedicated a lot of time to it and got a great job doing Node and React development. 
1. One language everywhere - Invalid argument, because "pick the right tool for the job" is the correct argument here. 2. Server-side react rendering - if your react is so slow you need this, you need better front-end practices. 3. "good js devs" are, in my experience, much harder to find, although you will find a lot of people who happily shit JS code and tell you they're awesome, nowadays. 4. Lighter-weight servers.... More lightweight than what? Rack? Sinatra? Cowboy? Python's httpserver? 5. I don't even understand what "Faster growth in the language landscape" means. Take a look at languages like Elixir if you want actual language-based growth. Javascript is becoming like C++ and Perl - a cancerous, uncontrolled growth. 6. More functional approaches to programming -- from whom?! I would genuinely love to see more programmers adopt a restricted, functional approach to JS, but most people are happy enough mixing state everywhere. If we're lucky, React and Flux specifically will make FRP popular and that'll bring about some changes, but I'm not holding my breath 7. Consolidate... ? But that's the opposite of what JS is doing. It's got gulp and grunt and bower and webpack and npm and probably another couple that I don't know about. I used to think Python had it bad with easy_install and pip but that was before I tried working with node.
It really depends. On that list, you're not very likely to be implementing Authentication or Cookies/sessions without the help of some library, and isn't really that difficult other than ensuring you're salting your passwords. The other parts, like keeping sensitive info out of source code, require libraries like Vault, Chef Data Bags, or something of the like unless you want to manually copy and past values onto remote servers. Database is really up to you. There is definite value in understanding SQL, NoSQL, and even how to use something like elastic search which can all be extremely useful tools in different contexts. In most, I recommend using some sort of ORM to do the heavy lifting for you unless you really need to optimize your queries. Probably the most important part is to understand how to create routers, middleware, and write intelligent endpoints that are easy to maintain, understand, and the thing most people absolutely fail at, TEST. Finally, while learning a JS/Node.js based backend framework is a good start, if you really want to learn to do backend work, I recommend looking at either Scala or Go. Those two languages IMO are the future of real backend development. Static typing is so much faster and more effective to develop in for the long run. I use go extensively at my job, having written backends in Express, Symfony, Django, and Flask and I don't miss any of those at all.
I work with a company who until only recently demanded that all code look and behave exactly the same in all browsers including IE7, and then after too many years we got the great news that they were changing that baseline to IE9. Awesome! We skipped 8. Except they had a custom configuration for all of their IE9 installs so that they were all running in IE7 document mode by default with the hope that none of their internal stuff would break. The "Tested in IE9" tickets came for us like a raging river of blood. 
you really had something contrary to say to every point? why? just comes off as prickish especially considering that you just echoed back your own arbitrary opinions. &gt; One language everywhere - Invalid argument, because "pick the right tool for the job" is the correct argument here. every language you use requires a certain mental and technical upkeep and mixing them isn't free. the "right" tool is not to be confused with the "technically best" tool. often the right tool is the one you already spend 90% of your time working in, or the one your team already knows, etc. &gt; Server-side react rendering - if your react is so slow you need this, you need better front-end practices. huh? the React library alone takes 25ms to parse and load before it can even start rendering the page on my fast laptop. that's before it has to make a database call to fetch its state. by rendering on the server, the page doesn't have to wait for React to load, and you might as well make your database calls there, too. 
just make something, man. If you write JS for browsers already, it's mostly the same; except instead of including the file in html and refreshing your browser, you type node myfile.js or whatever. * Use node to scrape some websites and save images. * keybind some functions. * make a restful API. * make an IRC bot. * save youtube videos as mp3s * download mp3s from soundcloud and bandcamp * You know how when you're doing that thing with files, and then you have to do that other thing, and it's really tedious to do that all the time? Automate it dude. after making something like this, you'll understand more about how backend is not really so different from front-end (it's all programming); you're just not limiting your program to what browsers will let you do with javascript anymore. Then you can make whatever you want when you think of it. All that shit you mentioned is hella boring, by the way. That's what you do when you're paid to do it. Don't do that until you have to, or programming will stop being a fun hobby and skill for you.
And then there's prngs, and that's an whole other thing.
I think [nodeschool.io] (http://nodeschool.io) is a nice place to start. 
Thanks
Thanks. This is useful. I'm going to start with the koa course.
First thing I messed with when learning full-stack JS was [Meteor](https://www.meteor.com/) I thought it was a nice gentle introduction to the whole thing and it helped me transition to node. However if you want to go straight for the stuff on your list [this guy](https://www.youtube.com/user/learncodeacademy) has a ton of useful videos on creating rest apis,, using databases, deployment, virtual machines, server configuration, etc.
Is there any particular reason you want to learn functional programming vs oop (like Ruby and ES6 sort of)? I think with security on the web, there are so many different fields to learn, whether it's cryptography, server security, or application level security. Personally I would leave cryptography to the experts, and server level security is usually about the operating system the server runs on, so again while I try and get a base level understanding of that stuff, I usually leave it to security experts. Application security however, is just the practice of understanding general http(s) transactions, different breaching methods, whether it's file system permissions, XSS, SQL injection, etc.. Then figuring out which sections of your application have potential weak spots. These are usually APIs, forms, or anything that posts data to your server, and accesses your database. There are plenty of edge-cases to these too. You'd be surprised at the different, random ways people manage to exploit a web application. One of the key practices of any application that communicates with a server is data sanitization. If someone can post data to your server, sanitize it. Now all you really need to learn is routing in Node, creating response headers, accessing a database (Mongo is probably a solid choice), create a restful service, as service-based applications are the "in" thing at the moment (for good reason). You also mentioned deployments. This can be as easy or as difficult as you want to make it. I would probably just stick to using an FTP client for dropping files onto your server, and no doubt your server will come with a server management interface, which can be used to handle database management, etc. If you want to get deep into deployment, look into CI/CD, and using tools like TeamCity or Bamboo or one of the many others, but this is probably overkill. 
Playing with fire here. There's already a split in the community over classes, but now you extend built-ins with classes.. Just because you can do that, doesn't mean you should. It's considered bad practice.
Cool, let's start a discussion. Let's set aside classes for now, because you don't need them to interface with "subclassing builtins" paradoxically. You can just use symbols manually if you want, though I don't claim to understand that well. So, staying on the topic of builtins, why is subclassing them bad practice? It's not like we're adding methods to `String.prototype`, where we might have namespacing issues. 
To gain deep knowledge of interacting with the browser through React, how to manage list state, and how to use multiple component files together for a single large component, try building an "tag input" component. You know, something that looks like a regular input field, but when you type comma or blur the field, it creates an inline tag. Be sure that you can edit existing tags, add them, remove them, insert tags at any location in the list. Now make it handle keyboard interaction (arrow keys to go between tags or select them, enter to edit/confirm, etc). Now make it work like a regular input when using tab to focus or blur your field. Bonus, make it support newlines and arbitrarily long tags without breaking the flow of the field or breaking the display of other tags (hint: use flexbox). Just for fun, make your tags accept arbitrary html such as an img tag as their content (at least for the initial tags, not for the ability to edit existing tags or add html via the text field). Doing the above took about two 8 hour days last week. Though I had built a similar component a year ago in Angular.
In that case I would prefer TypeScript with a Array&lt;User&gt; notation, with type checking on compilation.
If you end up doing more of these, please don't use images. Stick some markdown on GitHub Pages instead. 
How would you run older versions of Safari on the latest version of OSX?
You want to trim the length of the search string, to that of the value you're searching to ensure it only searches the beginning of the string. http://jsfiddle.net/j77wn2y4/ Or using /u/Kriegslustig 's preferable approach: https://jsfiddle.net/reszr1xg/
&gt; Lack of developer familiarity -- much harder to hire for But much easier to find talent. &gt; More difficult integration/use of JS libraries (you can do it, but it's not as pleasant) Really? You have to do absolutely nothing, and use JavaScript from Scala as if you wrote JavaScript. (But even then, having a stable, mature, working dependency resolver is so much better than the random-tool-of-the-week as you have in JavaScript). &gt; The result optimization is typically between 150 KB and a few hundreds of KB." Not much different from JavaScript. The DOM is so terrible that jQuery and friends are more or less mandatory, too. &gt; Scalajs shines brightest when using Scala on the backend for shared code, but when you aren't there's less benefit. I have used Scala.js for web presentations, was extremely pleasant to work with, compared to JS "frameworks".
First "real" React project I've done was for a home assignment for a job application, and I'd say it was a great introduction to React. Even got the job in the end! The task in hand was to build the front-end side of a mobile chat application. The following features are required: A view to show the list of all chat rooms (a room might have more than 2 participants) A view to show a single chat room. In this view there should be a listing of all of the messages in the convesation, and field to send new messages (new messages should be kept in memory, no need to implement the chat server). The input field should have an option to add attachments (images) and should support emojis. You should also add tests and a lot of mock data. Took me a weekend or so, but it was a fun project. 
The problem wasn't that Mozilla thinks that webSQL is useless, it's just webkit uses sqlite as the backend for webSQL already, so mozilla has to use another backend, basically create it themselves. They feel that implementing a new database backend is not worth diverting time from more useful things.
&gt; t's just webkit uses sqlite as the backend for webSQL already, so mozilla has to use another backend Why does it mean that? 
JavaScript is a very big subject; CodeAcademy's course is just an introduction. There's a lot to learn. [This great blog post](https://medium.com/@_cmdv_/i-want-to-learn-javascript-in-2015-e96cd85ad225) should get you off to a good start. Also, keep an eye on the work of Kyle Simpson and Eric Elliott. They are talented educators. If you want more CodeAcademy-type practice drills, try [freeCodeCamp](http://www.freecodecamp.com/).
The books you've read are great! But now, time to stop reading, go find some projects to build, then you'll feel if you know JS or not. Contribute to some open-source projects, try to find experienced devs to advice on your code, build a library that solves a problem you've had... go write some code 😄 (also i would recommend the blog www.2ality.com and the book [Exploring ES6](http://exploringjs.com/es6/))
An [extremely detailed look into why it was depreciated](http://nolanlawson.com/2014/04/26/web-sql-database-in-memoriam/)
exactly that. :+1:
From the UK, so different tax system. I would look for fixed rate accountants. Mine costs $100 a month, which has paid for itself with the tax savings they advised me on. Most have online systems to enter expenses etc and file paperwork on your behalf. Look for one where you get an actual account manager to speak to. I'd also recommend looking to become an incorporated company (called limited company here in the UK), as there may be more savings. Eg you may be able to claim back more taxes on capital purchases, or pay yourself through dividends not a salary. Or, pay your partner through the company for further tax savings. You'll always see a return on instructing a good accountant - just make sure fees are all fixed. Mine actually specialises in IT professionals. Hope that helps. 
Thank you guys for the warm words!
I'll offer my perspective of what it means to support legacy browsers, as someone who used to work for one of the largest (and strictest on quality) web development and SEO companies east of the Mississippi. We're talking 2006-2007 though, so at the time it was IE6 that was the elephant in the room, but the concepts are still the same today. First of all, 'supporting' a browser doesn't necessarily mean that everything has to look and act exactly the same in that browser as it does in Chrome, for example. The term they used quite a lot with us was "graceful degradation". What that means is, whatever doesn't work, make sure it doesn't look *broken*; it should degrade gracefully. Anything that's critical to the user experience, such as navigation for instance, should work in some capacity that appears natural and somewhat aesthetically pleasing. It doesn't have to have whatever fancy styles and animations that it has in Chrome, but it should work and look presentable. Same thing with anything else. Elements don't have to have the CSS3 gradients, drop shadows, or custom fonts and mouseover effects on them in legacy browsers, but they shouldn't look broken, and the user shouldn't feel like the site wasn't designed for their browser. Basically, just making it work properly and look nice is all there is to it.
Express or Sinatra - Honestly I don't know why we're not talking about Koa and Hapi here as well. That would make the discussion more complicated, temporarily, and then it might simplify it. SEO will not be improved by server-side react rendering - and nowadays, is barely worth the effort. Progressive enhancement has nothing to do with technology and everything to do with the product side of your company taking an agile approach, as well as the design side of your company building the design correctly. Is "Rails" meant to be a reply to my "JS people who shit code" ? You know when I said the biggest mistake node made was to get popular? Well the worst thing Rails did for the world of developers was make it easy for complete beginners to shit a web app without any understanding of the myriad shortcuts in the presentation of Rails. It's hard to write "good" Rails code in the sense of "maintainable and changeable in the long term", and it's something the Rails community is slowly fixing. They might not succeed before Rails dies. We'll see. Erlang / Elixir -- you will not learn backend practices in Node, especially if you learn webservers. You'll learn that a request comes in and gets parsed and then that you have to do stuff before you send the response. You might not even learn about MVC or why it's the most popular choice for web frameworks today. Consolidating is a red herring. It's not a mistake OR a problem to have two languages. And what is this "tooling to support their interactions" that you are talking about? If you mean Rails' asset pipeline, that's something that arguably Rails did really really well but was solving a problem that was ten years old. Rails' asset pipeline causes trouble for some of the newer JS ideas -- but then again, some of the newer JS ideas, like Angular, are terrifying (we will read our own code and parse our own code and then determine what our own code is supposed to do and that's gonna be our magic sauce SO YOU CAN'T MINIFY THIS CODE!). One thing express brought to the table that was a GOOD idea: make many things middleware instead of bringing them up to the main codebase. In Rails, before you realize that the route doesn't exist, you HAVE to go through all the middleware. Kind of a waste of time. One thing node has which is still a major problem is bugs in important libraries. I've run into an authentication package that sometimes fails to authenticate even after it says it was successful, and I've run into an ORM that sometimes makes a query run for 7+ seconds. Both are basically known bugs, known for over a year, and neither has been solved. If you want to learn good back-end practices, then write purely back-end code. If you write JS code, you might just learn how to apply callbacks everywhere, which might not be super-helpful in the long run unless you never plan on learning anything but JS. The basic guidelines for the two major programming styles are: - Object-Oriented is about sending and receiving messages - Functional is about transforming data.
It doesn't actually matter that much when browsers are available for multiple platforms to begin with. You have the same issues regardless of your primary OS. Safari for Windows has quirks and issues that aren't present in the OSX version and vice versa. Same with Chrome across Windows, Linux, Mac and Android. You'll run into stuff all the time that works in the same browser on one OS and not another. This is something web developers have always had to deal with regardless. At least with a Mac, you even *have* the option to test in all 3 desktop operating systems - us Windows users can't even test anything in OSX without having a Mac lying around or going through the hassle of trying to setup a hackintosh (which doesn't work for 99.9% of people because you have to have *very* specific hardware, strictly follow long tutorials with hundreds of convoluted and complicated steps, download multiple third party kexts for various drivers, do a lot of praying and performing special ritual dances around a campfire during a full moon in autumn after sacrificing a goat on a specially made altar, etc.).
We're specifically building Outlearn to help pro developers (past the "learn to code" stage) stay up to speed and help learn as a team. See if https://www.outlearn.com/topic/javascript is useful.
Have you looked at loopback? They have a database generator that looks very similar to this (not for websql, for a db layer similar to waterline). 
Your functions all have the same name... that might be causing some issues. I'd do &lt;form id='myForm'&gt; &lt;fieldset&gt; &lt;legend&gt;My Form&lt;/legend&gt; &lt;input placeholder='value1'/&gt; &lt;input placeholder='value2'/&gt; &lt;input placeholder='value3'/&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;/fieldset&gt; &lt;/form&gt; --- #myForm { display:inline-block; } #myForm input { display:block; margin-bottom:8px; } --- var mFInput = document.querySelectorAll("#myForm input"); var mFButton = document.querySelector("#myForm button"); mFButton.addEventListener("click", function() { window.open("https://www.reddit.com/r/" + mFInput[0].value + mFInput[1].value + mFInput[2].value, "_blank"); });
Or being supported by all major browsers. It's not supported by *any* version of IE, Edge, or Firefox, so is really impractical for use outside of local intranets where you know all users will be using a specific (supported) browser. Being abandoned for the past 5 years and not having cross-browser compatibility are the two biggest issues and complete dealbreakers for me.
I think he was defining a length restriction for the field, not redefining the length of an INT.
The TechCrunch keynote he did back in 2012 was absolutely cringeworthy. The entire thing was just "look at this pretty and impractical 3D periodic table! Look at the raw performance we've accomplished with 2D sprites on a 3D plane! Watch the same 3 animations over and over and *over* again! No one else could do this in a browser (which was a downright lie when three.js had already been around for 2 years making much more impressive demos of actual textured 3D models *and* shaders in the browser)! Oh yeah, and here's a 2 second demo of it working in 2D mode on a website! Watch this side panel slide in and out -- jQuery totally hasn't been doing *this* for the past 6 years!!" Then he'd make frequent pauses for applause, or laughter at his lame jokes, only to be met with the sound of crickets because there was nothing impressive about this demo even in 2012, and he completely failed to explain how or why his claims of it being "revolutionary" were valid. He also made it clear, in a roundabout way, *exactly* how he planned to make money with it. "I could see this being used for Pinterest boards, or Twitter feeds, or Picasa albums, or Facebook walls..." He was hoping someone from one of those companies would hear his keynote, think "yeah! that would be awesome, we should do that!" and decide to buy out his startup. When that predictably didn't happen, he had no plan B, so it failed. It's sad because he had a lot of amazingly talented developers working there. It's just too bad it was led by a wasteful douchenozzle without a reasonable plan. When your business plan is essentially "try to get bought out by a web giant", your business is very likely doomed to failure from the start.
No, firefox uses SQLite for it's own purposes, but it doesn't use it to implement webSQL. As /u/cwmma puts it very concisely: &gt; You need 2 different implementations for it to be standardized into the web stack. The chrome one was pretty much 'sqlite bugs and all'
Oh, so an INT between 1 x 10^11 and 9.99... x 10^11 . Interesting, I didn't know you could do that in SQL.
Starter | Standard | Professional -------|--------|------------ **€0** / month | **€2** / month | **€4** / month 1 form | 3 forms | 10 forms 200 uses per month | 5,000 uses per month | 10,000 uses per month I hate to be *that* guy, but I really don't like these kinds of business models. So this is obviously a hosted solution with limitations based on pricing plans. What I don't get is the fact that the highest plan still has limitations on the number of forms and "uses"; this seems too limiting. While "uses" seems to be a somewhat valid limitation due to it being hosted and there being bandwidth concerns, limiting the number of forms seems fairly arbitrary. Another thing I don't get is how the form data is sent to *my* server. So the form is hosted by your server, submitted to your server, and then what? Does it then post the data to my server? If so, how? Via AJAX? How is the data structured? JSON or some other serialized format? URL parameters (GET)? Multiple individual POSTs? Stored on your server with the need to query yours via an API of some kind (that would be bad -- see below)? If the post fails for whatever reason (either from the form to your server, or from your server to mine), how does it handle that? Will there be a self-hosted option to buy the script without the GUI (or maybe with the GUI as a Wordpress plugin or something), and thus without restrictions on number of forms and "uses"? I'd rather just buy it as a jQuery or Wordpress plugin where I can just put classes on form fields and have it work that way instead of dealing with the limitations of a hosted solution, let alone trusting you with my users' potentially sensitive data (or taking your word that it isn't collected and/or used in some way).
The one good side of extending built-ins is that you can extend it and add new functionality there. i.e. if you want to add new methods onto the Array class. I'm not saying you should though. I'd rather make that as some utility functions and pass the object in. It also depends on what you mean by 'built in'. Historically with JavaScript's case people included anything that the browser is providing by default. So not just core data types like Array and String, but also the DOM, XMLHttpRequest, and even the Date. Putting the 'composition over inheritance' argument aside; in most other languages extending the provided classes is seen as both fine and even the norm. Java is one such example where it's normal to extend tonnes of stuff you may pull out from the JDK.
Yeah, most databases allow you to set a value length restriction. In this case he's defining a column that's going to be an integer type with values no longer than 11 characters.
We have to put a limit on the uses because we do some quite CPU-heavy stuff on the server. And I assume if you have more than 10.000 users filling in your form every month you'll have enough budget to maybe pay 10 euro's a month. The form data is sent normally to YOUR server. Form data NEVER reaches the Formazing servers. The form is hosted on YOUR server. When the user submits the form it goes to your server. Then, your server contacts Formazing about the validation, and then validation is done on YOUR server. All the PHP code that handles this is open for you to read, so there are no privacy issues whatsoever. About the service interuption, we've made sure that we always have multiple backup solutions ready for any problems, so this shouldn't be a problem. But I guess this is something people have to experience for themselves. There are no plans for a standalone solution as of yet. The whole point of Formazing is simplicity. There is no programming required for alot of unique functionality. I can talk about Formazing for hours, but the best option is for you to sign up to the Closed Beta and try it for yourself. I'm confident you'll absolutely love it.
&gt; there is no guarantee that if part of the internal subclass which dog foods parts of its own api is going to call your api polymorphically. There is no where in ecma that is giving this guarantee. It took me a bit to figure out what you were referring to here, but I finally understood what you meant. So, for example, if Array's constructor calls `push()` to add the initial items, will it call the overridden push? Or will it explicitly call its own Array.prototype.push? Or will it call something else entirely? Though, to be fair, this potential problem isn't specific to built-ins. *Any* class, even the ones *we* write, could cause problems if they specify an exact function to use rather than relying on `this` to find the appropriate one. As a rule of thumb, we may want to extend only classes that were designed to be subclassable. In fact, the ECMAScript spec does explicitly say, "The Array constructor is designed to be subclassable." I vote we try it out before rejecting it out of hand.
Thank you, I will try this out later. I am literally just starting out after discovering the amazing possibilities of javascript after I discovered a major security issue at certain site. Pretty pretty cool stuff.
Anytime! Very cool stuff!
Honestly for learning the advanced semantics of the language, I've found reading Mozilla's documentation has been the most helpful. All the topics are quickly laid out and you can skip to material you don't know yet.
Well of course. Most developers are white males and fairly young. What's your point?
Yeah, I haven't done anything with WebSQL, but this seems far more time consuming than just writing some SQL. I suppose it's slightly easier than learning SQL, though.
&gt; While I have very little interest or incentive to learn Java or .NET, it seems like server security, SQL, SSL are something that would follow naturally after learning how to create production ready web apps/apis in nodejs. Here's an incentive for you: Java and C# are the most popular server side languages by a massive margin. Knowing them as well as Node and front end JS would make you so incredibly attractive as a hiring candidate. If you're a strong programmer you can demand a very very high salary at a great company. You're honestly not going to get there with Node and Rails (and I'm sure the Rails programmers will downvote me for saying that). Source: I'm a development manager at a great company with above market compensation. We pay top dollar for good full stack developers.
Sad this comment's been downvoted because all the replies are 100% on point. WebSQL's not going to be a thing, other than for legacy compatibility. No one (particularly not Mozilla) wants to paste "insert SQLite version 3.1.19 here" into a web spec that's meant to last a decade or more, no matter how popular some particular software library was in 2010.
Yes, it's quite disaster our situation, but (if you don't live alone in BCN) with 20k/Year you can handle the lifestyle. THe minim salary we have it's 680€/month (aprox). Ridiculous. 
And it's abandoned *because* those who don't implement it have stated they won't.
Thank you very much!
HTMLElement has issues too since some browsers report it as an Object instead of Function which breaks the inheritance ability.
nope, haven't seen that before, will check it out thx!
So basically you'd trust on the server side that you're looking at an old browser instead of having the browser itself figure out what it can and cannot do? Purely back-end code is code that is not web code. More or less anything in project Euler or similar websites -- or more complex projects such as ledger: http://ledger-cli.org/ a nodejs api server has a front-end : that front-end is the structure of the data returned.
Yeah, I noticed that in the console. Wordpress adds them, because they certainly aren't in mine. I thought this could be part of the problem. Sorry, such a noob with putting js on wordpress. Thanks for checking it out!
Thanks, I was looking at how to put js in wordpress and thought it would work how I had it. Super new to this, thank you for the info!
theres several of these. look at kraken and sails in addition to loopback. 
I kind of like coffee script too, though I never did a project in it because I thought that not being able to debug the actual source code would slow development down. Also, I would prefer a language with a good type system, such as typescript. 
[This "guide"](http://javascriptissexy.com/how-to-learn-javascript-properly/) helped me a lot. It's been updated since I used it, not sure if it's still swell.
People usually bring up debugging. I've never had problems with debugging compiled JS. It's not like you have to minfy it.
Note: “[Exploring ES6](http://exploringjs.com/es6/)” only covers what’s new in ES6 (which is a lot…). But the predecessor, “[Speaking JavaScript](http://speakingjs.com/es5/)” is also free to read online and covers all of ES5, so it’s probably a better book to get started with. (Disclaimer: I’m the author of both books. Thanks for the mention!)
You still need them in ES6 code if you want to assign something more elaborate to a `const` variable. I'm in favor of using parenthesis, because using parenthesis is the most common option. Secondly, they work if you want to do something with the return value. I prefer to wrap everything including the invocation parenthesis of the invocation, because that's where an extra set of parens goes: (function() { console.log('ohai'); }()); However, that doesn't work with fat arrows. This is a syntax error: (() =&gt; { console.log('ohai'); }()); This works: (() =&gt; { console.log('ohai'); })(); I also like to call my main IIFE "main": (function main() { ... }()); Because I believe that labeling the entry point of your application is a good thing. If it weren't for Firefox ([#1071646](https://bugzilla.mozilla.org/show_bug.cgi?id=1071646)), we could use a labeled block for this. Without being able to declare some local functions, this construct is pretty useless though. main: { if (errorCondition) { break main; // instead of return } ... } Shame, really. A labeled block looks a lot less noisy. Using a named function expression is also great for rAF: (function update() { ... window.requestAnimationFrame(update); }());
There is no future in it. Any code you write now will become more and more obsolete as coffeescript inevitably loses ground. Using something like Babel ensures a developer years from now will be able to use, extend and maintain your code effortlessly. Personally, I really dislike the white space block indentation style. I consider it unreadable, and I run into weird invisible errors when a hidden whitespace character is breaking the compiler. Edit: that said, I've written a lot of coffeescript code, and I loved it for years. But I feel vanilla is mature enough now to drop cs.
it's great for developer coming from Ruby or actually no JS programming background because it's easy to pick up, but in the end it is another language. So when a JS developer comes into Coffeescript code he doesn't need "better js compilation" because he already knows the best practices and is used to writing JS not Coffeescript, thus making him less efficient programmer. And in big companies if you multiply this "slow down process" by 10 or more developers it just makes sense to stick to industry standards. Plus, unlike other precompiling languages (like SASS, SCSS) it doesn't allow writing just JS, while in SCSS you can easily write pure CSS, which in my opinion is just a way of saying "it's my way or the highway". When writing code I wanna have flexibility, not being constrained. On the other hand, it is beautiful to read coffee and it is where JS is going (ES6, ES7) anyway, so I guess it just boils down to preferences. But people tend to get emotional because someone is just pissing over their "language of choice".
Agreed, source maps make any kind of transpiler easily debuggable.
The more you program and better you get at it, the less its about writing code and more it becomes about communication.
Too much abstraction, too much abiguity, significant whitespace is less easy to read than C style syntax, source maps are a bandaid and still a pain I'd rather not have to use, 'transpiler' updates have broken functionality, and there is no future in it.
[There was a discussion similar to this last week.](https://www.reddit.com/r/javascript/comments/3qt1i9/is_es6_better_than_coffeescript/) There's kind of a consensus that "Coffeescript has been merged into master" (or at least the better parts of it) with the advent of ES6/7. Coffeescript set out to fix some of the problems of JS, but introduced some problems of its own. It's hard to parse, visually, and even for the compiler. It syntax leads to lots of ambiguities (e.g. `foo bar and hello world` -- is it `foo(bar) &amp;&amp; hello(world);` or `foo(bar &amp;&amp; hello(world));`?). Being able to use words and white space in lieu of symbols for operators and blocks and function calls might lead to "prettier" code, but personally I find it less readable. A few years ago, I was evaluating whether CS was worth it, but in the end I concluded that linters and libraries with plain JS was better. You'd avoid the pitfalls of JS, and get some of the niceties of CS, without the syntax ambiguities of CS. (Also, my team already knew JS.) Since then, linters, libraries, module systems, and now ES6 transpiliers have only gotten better and better, and CS has stagnated. The only advantage to CS is that it's more familiar to Rubyists, and it's fun to write. But you'll inevitably have to debug the JS output, and know what's going on behind the scenes, so you won't be able to completely avoid the "ugliness" of it, and will still have to be able to read and understand JavaScript.
&gt; cleaner and more readable code Quirky syntax, odd variable shadowing, ambiguities. &gt; significantly less lines of code Not actually less to type though. You forgot the biggest con: poor tooling. That's why you don't actually type less. Your machine can't properly assist you. For me, the primary reason to use a to-JS language is better tooling. Optional types are the most concise way to document your intent and they pave the way for dramatic tooling improvements. The more work my machine can do for me, the better. http://i.imgur.com/seeLpQJ.gif http://i.imgur.com/wBhFvY7.gif There is no way I'll ever memorize all that crap. And it's not just WebGL. It's any API written by a third party, a team member, or even yourself. Always checking the docs/code for everything is very time consuming and error-prone. Also, breaking changes exist. If virtually all of them are immediately identified by the analyzer, updating some dependency is much less of a problem.
Probably because you are posting introductory level questions which they're are literally millions of questions you could read through instead of contributing your slight variant.
Have you checked out http://react.rocks ? Should be some good ideas there
The problem is that Stack Overflow is a voting site, just like Reddit. Sites like these practice democracy instead of wisdom. Say anything that defies coddling shit developers and you will be down-voted to oblivion, but this is the opposite approach towards self-improvement. I recommend if you wanted quality feedback on something you are working on to go to IRC. Try ##javascript on irc.feednode.net
Ah! And to think I've been using it all this time and never knew its name. Thanks! :)
&gt; This is just how a lot of programmers are. Temperamental, judgmental, and lacking in social graces. Nice theory, but the fundamental problem is that assistance doesn't scale. Imagine all 75k subscribers of this sub would ask for some assistance 3 times a week. Do you think someone who asks that many questions can correctly answer a few? Also, you don't seem to be active in this sub and you also haven't answered any questions this week. Maybe you shouldn't judge others. For what it's worth, I probably answered about a dozen newbie questions this week, but I wouldn't suggest that others should do the same. It's a very inefficient use of time and those who get their answer learn very little. Books, Google, and persistence is all you need to tackle any beginner problem. There are a ton of resources out there. It's just a matter of not half-assing it and not giving up after 5 minutes.
Without seeing any examples, I'm left to assume that you either: **a.)** are misconstruing constructive criticism as douchebaggery **b.)** may have asked a stupid question (such as "How do I make an XBox One emulator in JavaScript?") **c.)** replied to someone's answer in an offensive manner after the answer wasn't what you wanted to hear **d.)** asked a really basic or common question, proving you did no research or made no effort beforehand **e.)** mistook the SO community as a free way to get people to do your project for you **f.)** some combination of the above I don't often find the SO community to be overly arrogant, offensive or irritable unless one of the above is true. I'm not saying you necessarily are wrong here, but the SO community isn't really known for its trolls, so if this is happening to you often, then it might have more to do with *you* than *them*.
&gt; There is no future in it. Came here to say this. This is the most compelling argument against CoffeeScript. The situation would be different if CoffeeScript was being developed as actively as the ES2015 standards are, but it's just not. They used to have a massive lead on Ecmascript, but not anymore, and it's set to start falling behind now, thanks to [Babel](http://babeljs.io/) being virtually completely up to date with even stage 0 proposals. With ES2015 transpilation, you can have most of the cool stuff CS offers in a forwards-compatible setup. That's what everyone should be working towards now, in my opinion. CS was a great influence and very important in JS development, though.
Great shout. The comments on the articles about the Pivot make for good reading.
`=` sets a value, `==` does equality comparison using type conversions, `===` does equality comparison with types as well. Use `===` in your if statements.
You're not doing tests inside your if tags, you're doing an assigment. It equals to true always so results gets the value "He throws the ball" and the results is written. It doesn't go in the other conditions as the first one was true. You should at least use == but I'd advise using === as they prevent a lot of mistakes. By the way, your french translations are a little off
Have you tried CSS transitions/animations? GSAP? you don't need some fancy framework to get 60fps
checked out pixi.js for 2d webgl rendering
Press F12 in your browser, set a breakpoint at the top of your function and step through it to see what is going on.
Debugging is exceedingly useful -- it's very important that you learn how to debug your code to identify problems. When you place a breakpoint on a line in javascript, it will stop the execution of the code at that point and allow you to step through execution one line at a time. You can check what variables are set to and even modify them. i.e., if you put a breakpoint before your if statements and press the button you'll be able to see what `results` is by hovering over it -- and you should be able to see why your if statements aren't working properly. Read here for more details: https://developer.chrome.com/devtools
Are you using a library for the console interface? It looks nice.
Back in the day it wasn't so bad. I guess programmers have just become more sinister over time. 
[removed]
Sounds like you'd be just as happy if you'd write ES6 modules.
I have a different opinion than most to the degree that it may be downvoted to hidden. There are always going to be better tools. Like CoffeeScript is better than ES6, IcedCoffeeScript is better than CoffeeScript, and ToffeeScript is better than that, and LiveScript is even better. People just can't manage the effort required to learn every new language, and until they learn it, that new language represents to them a huge tax on their time. So people will automatically rationalize reasons its not worth learning or even giving a chance, and can't admit it might be better because then they might have to pay the tax. I used to use CoffeeScript then ToffeeScript but now am using ES2016 just because it has adopted a lot of CoffeeScript, is not thay bad, and I don't have to fight people about Babel. Which btw the arguments people made about 'yet another compiler' are hilarious in the context of babel which uses plugins to basically make any syntax you want valid. But at least we can agree 'use Babel' and pretend that doesn't mean totally different things depending on who you ask.
Difficult to share knowledge when you write in coffeescript, just another level of abstraction. However, coffeescript concepts are wonderful. I originally learned most of my JS skills by using coffeescript. After a year or two, just started writing plain Js because I understood what I was creating previously. 
Needs: "Do you want to stop this asinine Q/A session and launch a GUI?"
The more and more I reason through the problem I'm trying to solve, the more a standard relational database is going to be a pain (full intermediate table joins) I am going to give RethinkDB another look (I have a 1gb instance, so perhaps it won't be so bad)
People rationalize Babel in a sense that in 2016 after es6 becomes widely supported, they'll be able to drop it and their code becomes pure JS. They tend to disregard the fact that in 2016, es7 transpilers will be all the rage. And why does it even matter if its pure JS or compiled? Perhaps it matters in situations where every drop of performance is of extreme importance which is almost never the case...
This is old but explains in detail how to debug the performance issues using chrome dev tools https://www.youtube.com/watch?v=HAqjyCH_LOE
NoSQL fad? Ok, stop. There's a use case for everything and SQL is not the end-all, just like NoSQL.
&gt; What? this is not a syntax error. Try it in chrome right now! Firefox 42.0: http://i.imgur.com/78LTrcx.png Chrome 47.0.2526.49 beta-m (64-bit): http://i.imgur.com/63mbmkD.png It works in both browsers if I move the wrapping closing paren. &gt; Better even.. drop the parens! The parens act as marker. They tell the reader at the very first line that this is an IIFE. **Edit:** Babel doesn't care. It produces the same code for either version. I guess that's a bug. **Edit2:** Traceur also doesn't like it. It works if I move the closing paren.
Weird.. I'm on Chrome 46.0.2490.80 (64-bit) and the parens work for me inside. Because arrow functions are anonymous by definition, I think beginning an expression with them should be obvious enough that it's an IIFE, so no need for the extra parens.
Yes, of course. And CSS should be handled by designers. How often do you have UX designers available to you for a basic address form?
&gt; Because arrow functions are anonymous by definition, I think beginning an expression with them should be obvious enough that it's an IIFE, so no need for the extra parens. let x = () =&gt; {...
check out http://freecodecamp.com
What editor are you using in the gifs?
GSAP is still my go to for complex animation. It gives you much more control of things like timing and controlling your animation ( it has a full timeline library ). CSS transitions/animations work better for simple UI stuff. GSAP is better suited for things like this https://www.g-star.com/en_us/raw It has nothing to do with framerate though
I think the biggest problem is that it is too different from Javascript which makes the barrier to entry pretty high, which means you won't find many people interested in your coffeescript experience, which makes it not really worthwhile. Might be different in a Rails environment, AFAIK that community prefers coffeescript for obvious reasons. Also probably makes it a little harder to find developers or open source contributors who want to work on your projects. I recently experienced something like this when looking at the source for an open source project I find interesting... all coffeescript :( Babel is also a compiler but it has the benefit of being what Javascript is going to look like in the future, so there's the justification there. Coffeescript's development seems pretty slow and I imagine will eventually become more and more obsolete as time goes on.
Based on comparison tests I've seen, GSAP is capable of the highest framerates of any js animation library, including Velocity, which is why i recommended it. http://codepen.io/GreenSock/pen/pmknI
As many have said, I've written a fair amount of production code with it in the past, but I feel like ES6 has closed enough ground for CS to not feel necessary. Especially as it adds another layer of annoying pre-compilation to the mix which becomes further complicated with things like Babel, and JSX.
Yeah you're right, I was agreeing with you. I was just saying GSAP's strengths go far beyond high framerate
I once used to canvas to capture video thumbnails. Maybe you could take one frame every n seconds using that techique and process them using canvas. You'll want to research canvas and web workers (for speed) I am guessing
args.caller?
vhost checks `req.host` for the first argument and if found, routes to the second argument. [The code isn't all too much](https://github.com/expressjs/vhost/blob/master/index.js) -- you could probably create your own middleware that [figures out the host ip address](http://stackoverflow.com/questions/3653065/get-local-ip-address-in-node-js) and does something similar (i.e. routes to different middleware function)
I like coffeescript because you can write: =&gt; Instead of: ()=&gt; Which makes me think: 8=&gt;
Oh, no offense but Flow/Typescript and Scala are in a different category. 
http://ftp.mozilla.org/pub/firefox/nightly/latest-trunk/ scroll to the bottom of the page and choose your operating system. Its a free javascript shell offered by Mozilla!
This article is fairly old (old in the JS world), and the repo's code is even older. A lot has changed since then, and if someone is considering developing a flux application, I would recommend looking into [redux](http://redux.js.org/). It's even recommended by the original flux creator over at Facebook.
None taken. I think Scala is pretty obviously better as a strongly typed language, but Flow/TypeScript can get you surprisingly far.
I've found [JSBin](https://jsbin.com) to be superior to JSFiddle.
https://www.codecademy.com/ and https://www.codecademy.com/ are quite a nice place for a beginner to learn + practice. But the best practice - choose an app you'd like to develop and do it :)
To learn the basics of the language, I've found [codewars](https://codewars.com) to be a nice place to practice JS. It encourages TDD, and I've found the katas to be pretty interesting and somewhat more practical than e.g. Project Euler.
I use the eslint rule [no-warning-comments](http://eslint.org/docs/rules/no-warning-comments) for fixme/todo comment nagging. If you make it an error and include running the linter in your git pre-push hook, you won't be able to push work into your remote that has these commit.
Object.assign({},your_obj) should do it for you. It's es6 with limited implementation in browsers however. Node, at least my v4.2.1 supports it without flags. 
This tutorial is absolutely amazing: http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html It covers TDD of node/express and React + Redux (which imo is _the_ way to build Flux powered apps)
While not really dealing with DOM I've heard good things about React Native. It's really just javascript/css with html being replaced by native components hooks. Ionic, on the other hand, is pretty lacking when it comes to performance. I loved the dev workflow but the effect was pretty disappointing. I hope Ionic 2 will be better in that regard.
I find it funny how many companies say, "we tried to make this product but realized there was no tool for the niche utility we needed. So we decided to make that niche utility our product". I played around with Famou.us' library and it just looked like they were applying css style with javascript and not much more than that. So it seems like they could have just written documentation or tutorials for which attributes to use and how to achieve an effect.
But TypeScript *is* kind of the special case here, since all JS code is valid TypeScript code. As the author of the top comment you mention, TS would actually be the one I would mind the least to adopt, since, as you note, many of the problems are simply not there, simply because TS is a superset of JS and thus quite transparent. However, I think it's important to note that all those languages come from outside influences. - CoffeeScript came from Ruby and Python devs. - Elm and Purescript came from Haskell devs. - ClojureScript came from Clojure (and perhaps Lisp) devs. - TypeScript came from C# (and perhaps Java) devs. Why? Probably because JS is the only language for the web at the moment and devs from other languages don't like JS. I don't blame them, it's not a pretty language. But asking those of us who actually do enjoy JS as it is to use these extra layers of abstraction to be able to use a completely different syntax we don't understand is kind of... silly? I mean, of all the things in the list I just came up with, the only thing you can be sure is still here and actively maintained in 5 years is vanilla JS. So, not worth the hassle.
The great comments in this thread have validated my move from coffeescript to ES6. Coffeescript has served me well but having learned what ES6 can do, I'd much rather move back to the standard. Coffeescript will come back in another form and compile down to ES6, when the advantages are demonstrated, I shall move once again.
The quickest way to practice JS is Firebug/Firefox. The native developer tools in Firefox is way better than Firebug..... but Firebug is still the only developer tools with a multiline console. There is a button you have to click to make it multiline, but there you go... a code editor directly in the browser that can be used immediately against any page.
You could always do Python if you really like the whitespace blocking syntax. Probably has more staying-power than Coffeescript.
What's wrong with regex and string matching built into javascript now? (Didn't look at the library)
&gt; c-style syntax is pretty common (C, Java, PHP and so on) so for the rest of us? Not worth the hassle. Even as a Ruby developer (coffeescript is based on Ruby), I don't find coffeescript worth the hassle.
It sounds like you're just looking for a stack trace when you throw an error. If that's the case, the `Error` object has a `stack` property that might do what you want. E.g. var err = new Error(); console.log(err.stack)
In addition to the questions asked there. Is there an example project out there somewhere that uses pageObjects in a nightwatch.js with mocha environment? Would love to learn by looking at some (good) code.
What is it about Babel that allows you to maintain code effortlessly?
&gt;Parsing `Function.prototype.toString()` seems brittle. If Angular does it, it has to be a good idea, right? /s
The reason it matters is because ES6 will be adopted by browsers in the coming years so it will surely exist for years to come. Thus, a future developer who inherits your code won't have to learn a new language to maintain the codebase. Coding in the future now is what makes Babel an exciting prospect.
&gt; beautiful to read coffee and it is where JS is going (ES6, ES7) Uh, ES6/7 isn't CS.
True, what I meant to say was - there are lots of interaction happening after the page is loaded. Animations, moving things around, searching for a particular element among thousands of elements etc. I can't take JS out - I just have to find the places where it is slow and see if there is a way to make it faster.
Here I share one of my team's recent opensource projects, hope it helps you to get started with polymer. Waiting to hear you feedback :)
Thanks. I assumed it would be much harder than this.
I cannot post the code, as -for now- it's not public, but I've been involved in getting a team to build some tests on our site and internal applications using Nightwatch. We've been introducing Page Objects recently (they're a fairly recent addition to Nightwatch) and are quite pleased. It's not really complicated, so I don't know what exactly you expect to see in code. In any case, this could be a piece of one of our tests... // given that we have... var loginPage = browser.page.login(); loginPage .setValue('@userInput', browser.globals.environment_vars.login[userType].user) .setValue('@passwordInput', browser.globals.environment_vars.login[userType].password) .click('@button'); Our `login` Page Object is defined in `src/page_objects/login.js` and simply defines the selectors for those `@userInput` or `@button` identifiers you see there. The other part, the `browser.globals.environment_vars...`, comes from one of a bunch of different JSON files, because we have a number of different environments, countries, profiles and so on. There's really not much else to it. Oh, directory structure... We have something like this... /&lt;app_name&gt;.tests |--config &lt;- Nightwatch configurations for different environments |--globals &lt;- all those JSON files I mentioned above for users, profiles, etc \--src |--page_objects \--tests |--search |--login |...etc... Ah, something not shown there: We've got a bunch of "actions" in `src/actions/**/`. They are common reusable actions we share across tests. This is not a good solution and we've been transitioning most of that into `src/custom_commands/**` and transforming them into that, custom commands. I don't know what more I can tell you. I'm sorry I cannot show you the project code, but if you have more specific questions I can try to answer some. We're still ironing some rough edges, but we are mostly comfortable with how things are lately.
Thanks for your reply. Does Firebase support Oracle Database (I found nothing about Oracle DB on their website). Or is there any CDN that supports Oracle DB?
Firebase has it's own server set up and is meant as a quick way to add two way binding to an app without worrying too much about server implementation details.
Today's search is very smart. E.g. try searching for *black science guy* or *blue people sci-fi*. You can be very vague and synonyms work, too. It's very different from the keyword-based search from the early days. If you want to learn JavaScript, you can easily find half a dozen online books and sites like MDN. If you want two learn how to write Canvas-based games, just search for that and you'll find plenty resources. Searching isn't much of a skill anymore. Anyone can do it.
Eh. I sometimes encounter problems that are just not easy to Google. I work mostly with SIP protocol, and some of the telco deployments use acronyms and terminology that are simply not easy to find. Since getting my job my Google search skills have increased quite a bit. I sometimes spend 30+ min digging for the answer to a question and I wouldn't consider it easy despite that today's search is "very smart". Yes, if you type "black science guy" you will find an answer, but only because thousands of other people have already ran that query. Anyway this discussion isn't really going anywhere at this point, so I'm just going to agree to disagree.
Lots of italicized text. Some basic info, but the page appears to mostly be an ad for more content.
There is this library that when out more than a year ago on Hacker News. https://github.com/CRogers/pun/blob/master/readme.md 
You need none of that for finding answers to newbie programming questions or basic stuff like file formats. If you now want to load a BMP file in a C program, you can simply look it up or just use one of the many libraries.
https://www.udacity.com/course/browser-rendering-optimization--ud860 
My attempt with jQuery: http://jsfiddle.net/8tekcxzp/6/ If you have any questions, please ask.
Ok, I get it. But then again, language isomorphism aside, there really isn't any particular advantage of server side rendering on Node, is there? I mean, our team has crackingly good Java/Spring/Akka/Vert.x devs with significant experience, and we'd like to remain with that setup for the server side unless rendering on Node offers something mind-bogglingly compelling. We are already doing SPA's (Angular 1.x, Sometimes ember) based on RESTFul Spring and traditional JSP views. Now the question is, language impedance mismatch aside, any "gobsmacking" benefits of rendering on Node (instead of say, Tomcat) and switching to JavaScript (instead of Java) on the server side?
It seems to have more features. More ways of sorting and also dragging.
I do have the cb function in there and it works fine in both versions. Here's the version where everything is in one file: https://github.com/brettdavis4/udacity_js_design_patterns/blob/master/final/yelp.html Here is my js file when I call it from a function: https://github.com/brettdavis4/udacity_js_design_patterns/blob/master/final/js/yelp.js Thanks!
I'd love to make some pull requests for fixing grammar in the documentation.
Yeah, I mean, it's also pretty subjective. I think significant whitespace is harder to read and work with. Putting significance on something invisible is kind of odd and just doesn't seem very robust to me. Sure, there are less visual characters but I don't really think it helps in this case.
Prominently on the home page (i.e., describes the project in a nutshell): *Gridifier rethinks HTML layout &amp; improves browser's grid layouting engine with the improved version of the Skyline 2D bin-packing algorithm.* Says so much but absolutely nothing.
Check http://jankfree.org/ if it's your js and css-based rendering and animation that's slow.
Another js file. The #sgPluginBox is part of a modal image gallery. 
Having used CoffeeScript fairly heavily the last four or five years, I've thought about this quite a lot. There has been profound distaste for CoffeeScript from the very beginning. Historically developers were quite upset when it was included as part of the default asset pipeline in Rails 3.1. I suspect overzealous Ruby developers exacerbated things over the years. These days I suspect many people continue to find it's existence aggravating because: * You might write something really useful and they don't want to deal with the potential cognitive overhead associated with using another language. * They suspect they know better than you what language will increase your productivity and general happiness. * It takes attention away from their preferred JavaScript flavor of choice. * They have some unfounded fear that it will supplant JavaScript. Complaints about the necessity of compilation, difficulty debugging are applicable to pretty much any modern JavaScript app (and less serious given better build tools, source maps, etc). Complaints that the syntax is "too ambiguous", white space indentation is too "weird" have always been a matter of taste. Arguments that ES6/ES7 are "good enough" ring fairly hollow after limited experience trying to build real things with them. Arguments that development has slowed fail to acknowledge that the vast majority of new ES6 features were playing catch up with CoffeeScript. Support for new syntax is unnecessary in most cases, in others (like with generators), CoffeeScript will produce ES6 compatible code. As far as ES7 goes, we'll see adoption in CoffeeScript of relevant syntax (async/await) in a timely fashion. I have no doubt it'll continue to evolve along with JavaScript. CoffeeScript is a very mature, simple language that still provides a more consistent, delightful environment to work with compared to ES6/ES7. For myself (and the team I work with, for that matter), it continues to make JavaScript development a pleasure.
it's right here: parameters.push(['callback', 'cb']);
It seems like they made everything more complicated. I wish things would get simpler instead.
&gt; Says so much about absolutely nothing that describes approximately 97% of all libraries posted
I've thought about this exact same issue, and am also writing my own library. Still in the works, but this was my approach, Scala-inspired. Although, I'm more interested in providing an easy way to use monads, than introducing a generic way to mimic pattern matching. https://github.com/bioball/mandolin#pattern-matching
\*sigh\* I'mma set this one out. See you in 2016.
Thank you very much, that already helps a lot. I have one more specific question. Is it possible to run one test file prior to all the others or somehow set a sequential order of the tests? I would like the first test to login and save the access token, so that all following tests can use this access token, rather then going through the whole logging in process. Or am I thinking about that the wrong way?
[removed]
For OP's research: node-oracledb https://blogs.oracle.com/opal/entry/introducing_node_oracledb_a_node
The ones which help you and the ones which you work well with :) Slightly more helpful - Angular/React are the go-to front end frameworks. Express is the go-to server.
There are object types, but not variable types. A variable has no type, it just points to a value and can be reassigned to any other value no matter its type. In typed languages you have variables with types associated with them. Variables of a certain type can reference objects that are a subclass of that type. That subclass may have an API which you need that is not available through the type associated with the variable so a _downcast_ lets you transform the known type of the variable down to a more specific type - one that more accurately represents the actual object type. Since variables in JavaScript don't have types, there's no need to downcast. The variable points to a value of arbitrary type that either works or doesn't work for your situation. The variable "type" (that doesn't exist) will never get in the way of that.
In general that is something you should not do, unless it's a really expensive operation. Let me tell you first why you shouldn't and how you'd go about it and then I can tell you an alternative way. You cannot set a particular sequence or order and it would actually be a _very bad_ idea to do so. You _don't_ want your tests to depend on other tests. Going that way leads to subtle bugs which go completely undetected through the tests. Now, there's always this special "first" test, which is usually logging in. And we tend to see that as a special case. "I need that for the rest of my tests". But it is still a bad idea. To be really trustworthy, each test suite (each group of tests in the same file) should (and will) run in a fresh, clean browser session. And it is a good idea to make each file/suite independent, so using a single suite for the whole site/app is a bad idea too. What you should do, if you want to go the _clean_ way is this: In each suite you would [add a `before` method](http://nightwatchjs.org/guide#using-before-each-and-after-each-hooks). There, if that suite needs a session, you can log in and generate your token for that group of tests. Of course you don't need to repeat all the code in the `before` method in each suite, you could just have this... var helper = require('..../../blabla/loginAction.js'); var token; module.exports = { before: function(browser) { token = helper.logInAndGetToken(browser); }, "some test": function(browser) { // you can use token here }, ... }; or something similar. Now, this is the _correct_ way to go about it. It makes each test suite solid and independent. Just in case your login was really expensive, you could instead think about having a pre-generated token. That is, if your system supports working that way, you could generate a token once, save it to a general JSON configuration file (like the ones I mentioned we use) and load it from there. But this is generally more complicated and also makes the tests somewhat less trustworthy, as they are relying on a certain initial state. (e.g. Imagine your token is valid for a one month period. You generate one, the tests run ok. The month passes, suddenly your tests fail. And they fail not because the app is not working ok, but because it is. They fail because to work they need some initial state. The tests are more fragile this way.)
&gt; Probably because JS is the only language for the web at the moment and devs from other languages don't like JS. Excuse me? What kind of argument is this? I consider myself a C# developer but I have no problem with javascript. Usually the people I see that have "beef" with javascript are junior developers trying to sound smart. Every full-stack developer I work with is *weaker* in JavaScript than their primary language, but they don't hold that against the language itself. Also there are **serious** benefits to using typescript over pure js. The main one is that it's included in the build process so developers only ever check in .ts files (which are merged and built, and will throw build warnings if there's a type error or compilation error) and the output is the .min, .js, and .maps. It makes maintaining code and being able to manage multiple developers working in the front-end a lot safer than checking in .js files and hoping for the best. The counter-argument is that build systems for native js exists, but I don't know what level of interactivity they have with MSBuild/TFS deployments.
Yup. I'm off live in the forest until this all settles down.
Yuppers. I'm surprised they didn't at least keep it so that it works for the most common use case out of the box. Babel6 feels super rushed, just to be able to show it off at a conference. It probably would have benefited from some sort of public beta / feedback period. 
You should go through all of the available photos in a loop and pull out only those that have the property you need. Then with that list, easily grab one randomly in one shot based on the list length and a random number derived from that. This way you have a set that you know to be valid and you don't have to worry about an arbitrarily long loop of failures when you need to grab an image.
Thank you so much for helping me. I've been staring at this for the past few hours (not just this problem - I had a tonne of issues before getting to this point!), and your solution worked straight away. Enjoy some gold :) For anyone in the future stumbling across this, my finished function looked like this: function getPhotos(data) { var random = Math.floor(Math.random() * 100) + 1; while(!data.photos.photo[random].url_o) { var random = Math.floor(Math.random() * 100) + 1; } $('html').css('background-image', 'url(' + data.photos.photo[random].url_o + ')'); }
I have managed to use /u/radapex 's solution below and get it working, but thank you for taking the time to look at this for me :)
I'm pretty sure that we'll get structural/optional types in 5 years in vanilla JS. TypeScript and Flow are basically the prototype of that. Also I'd say that TS doesn't belong on your list. TypeScript (and Flow) didn't come to exist because C# developers didn't like JS. JS semantics are fully embraced in both: their type systems are explicitly designed to model existing JS idioms. And if you remove the type layer, what you get is exactly ES6. Examples: * In C# and Java, interfaces are nominal and must be explicitly implemented by classes. In TypeScript, interfaces are structural: if an object matches the interface description, it automatically implements it (if it looks like a duck...) [Example][1] * In C# and Java, modules are a global namespace. In TypeScript, you get all 4 kinds of module systems that JS developers use: namespaces (objects as bags of properties), CommonJS, AMD and ES6 * TypeScript (and Flow) have union and intersection types. These allow them to e.g. better model functions that can take more than one kind of argument at the same position (a common idiom in JS). In addition, TypeScript lets you mark certain functions as type guards, which will cause the type to change if a guard is invoked as the condition in an if block. There are no equivalent features in C# or Java - this was added just to model existing JS code. [Example][2] I think these examples demonstrate that TypeScript really is designed with JS programming in mind, not for C# developers. [1]: https://gist.github.com/spion/0f3cb8cd702aaada6c93#interfaces [2]: https://gist.github.com/spion/0f3cb8cd702aaada6c93#guards
Thank you so much. You helped me a ton. The company where I am starting this student job didn't have any prior automated end to end tests and the person in charge of me doesn't seem to have too much experience either or just not enough time to properly train me the first couple of days. I'm confident in my ability to learn fast, I'm just afraid to learn the wrong way of doing things. When I do something I want to do it right from the get go :D Will your project's tests ever be available to the public and if so what time frame would you estimate? Just so that I can come back, compare and see how much I messed up ;D I appreciate your help very much.
If you had read the article, you would know that all transformations are now plugins, which are off by default. There is a preset that contains all es2015 -&gt; es5 transformations.
I did, but I don't know much about Babel. So, I'm a novice. I will try this plugin dealy, then. EDIT: and I get downvoted because I admit that I'm a novice. Boy, I'd love to work for you lot.
Thanks for the response, I'll consider these problems and try to find some solution. - About the "monkey patch": I'm aware, that's the reason that lodash and underscore do _.map(list, f) instead list.map(f), however I prefer the 2nd synthax, since it's closer to functional programming. I think that we need to assume some risks to do things cooler :) - About ES6 default parameters, same thing, I know that's early right now, but I'm thinking ahead, since ES6 is being well adopted already, and sooner Node.js will enable by default. But you can put the value comparsion inside your match if you don't want to use it right now. Thanks again for the help! 
So good man, also such a nice way of presenting the examples on your site. Top marks! 
cool!
TypeScript is unilaterally better than CoffeeScript IMO. Most of these pros are due to it being a superset rather than a completely different language. - Existing JS will work in any TS file - Readable by most JS developers - Lower barrier to entry - Static type checking is useful - Works great with autocomplete like Intellisense - Supported by Microsoft and Google
Yeah, I agree that TS is kind of unfair to put in the same category, and why I called it a special case among them. TS and Flow could easily be the next ones to bring new functionality to JS in future versions, just like it wouldn't be unfair to say that CoffeeScript did.
&gt; n things you need to know about x *sigh* we're getting buzzfeedified.
I'd assume the OP is referring to the JavaScript community.
Vice-versa. You can do things in TS that you can't do in JS. If it were a *subset* of JS, it would be more limited.
I haven't used TypeScript is a real world project but I like what it brings. I'm currently working on a trading platform interface built with JS and the business rules are pretty strict, and I know life would be easier if we could enforce certain types, as right now we're just throwing around different objects and hoping for the best. Some models are similar to others but not exactly. Some methods will work with some models and they won't work on others, but it's not exactly obvious. Some of the people who wrote some of the original methods have since left, so we can't refactor things without knowing the original intention. This would never had been a problem if we had enforced types. I think using TypeScript would help us organise our code better and create a more stable codebase. But I can't actually speak from experience. I'd like to try!
There is: Some ES6 features which are not yet supported by TypeScript. But this gap will be filled.
I don't even know what it is... Can you give me an ELI5 on Typescript and why you use it?
That makes sense. Thank you for this! I will save this snippet and try and include this into my project tomorrow. Thanks again.
JavaScript has pattern matching? I don't think so
It would give you an error. Not sure what you mean by "everywhere".
The best thing about TypeScript is that even though it's a statically typed language it still feels like JavaScript at heart. I also love that it brings a lot to the table but it's all in the compiler. No big runtime libraries being bundled along (like scala.js). The additions are also just language additions with no changes. No redefining what's a number or anything like that. It's designed from the ground up to work with the existing JS environment; not replace it. The language isn't perfect, it has some warts, but it is excellent. I highly recommend it.
Just another fad. I'm getting real sick of it tbh. It's depressing and destroying (web)developers all around the globe. 
Might have meant destructuring
Use [NodeList.js](https://github.com/eorroe/NodeList.js) to make your vanilla js DOM manipulation easier: $$('.li').classList.call('add', 'new'); it's about 4k minified, it'll literally make your vanilla js so much more pleasant when it comes to DOM manipulation
You are probably right, but flow does support destructuring.
&gt; it seems like TS's good ideas in terms of syntax/semantics are going to eventually be brought into JS anyway I've heard this in the form of rumours over the years. The idea that the type annotations might become part of ES8/ES2017. It would be nice to reduce the need for transpilation and the pain of sourcemaps. It would also help to ensure harmony of tools that operate on raw source (as opposed to AST-transformations) like linters and auto-completion. Do you have a recent source for the statement? Or is it just conjecture?
I'm so sorry... What's static typing? *yes, I'm aware I could Google it but I like conversing with people...
I've been looking for something like this to help us with /r/DestinyItemManager. I'll pull it and see if I can get it to play well with our UI.
Oh... interesting. Thanks!
CoffeeScript &gt; Typescript. TypeScript only adds unnecessary verbosity (JavaScript was designed without types and interfaces for a reason). CoffeeScript is it's own beast and at the end of the day it helps me be more productive by cutting out the unnecessary ceremony without putting more barriers and process in my way. 
* It's not just about what you've added right now, but what you might add in the future. What if you want to add slightly different match methods? Now you're further polluting object prototypes. I also don't see any way in which `list.map(f)` is more like functional programming than `map(list, f)`. * I understand thinking ahead, but on second look, I'm pretty sure the default parameters wouldn't even work with Babel, because you rely on parsing the function toString for the ="default value" part. This limits browser use until people can safely only care about ES6 native... which is gonna be quite some time from now, I think.
It has nothing to do with discrimination on the part of Github. It's like saying "I only hire people I know from my yacht club." Sure, the yacht club doesn't discriminate, but you still aren't going to be hiring a very diverse team.
how would this fit into gulp -- specifically, the gulp-babel plugin that sindre sorhus maintains? i'm imagining: .pipe(babel({ presets: ['es2015'], plugins: ['typecheck'] })) with some sort of mechanism for SyntaxError reporting?
I like static typing also but I don't like writing type definition files for third party libraries. Might as well use elm or pure script in that case...
One more point is that TypeScript's core developer is [Anders Hejlsberg](https://www.wikiwand.com/en/Anders_Hejlsberg), the lead architect of C#.
Given the look of the API, one could be tempted to use fat arrow syntax for simple transformations. Might be worth noting that doing so will result in an error since `this` will not be bound. Edit: One way to remedy this could be to add a "stream" parameter (or some better name) to the callback function, along with the current "readChunk". Or you could just forgo the whole ".push" part in the function and let the user return the transformed chunk instead - handle that in your lib?
I can't say enough good things about TypeScript. Works with JavaScript purely, but you get in returns on what you invest with it. The more type safety you add, the more issues it catches. I love that it outputs commonjs, amd, umd, or es6 modules with compiler flags, meaning i don't need to commit to one. I love that it outputs my es6 to es5. I love that i get intellisense and interfaces! Now i can produce and consume contracts properly without guessing, and I get build errors when those contracts aren't met. In any medium/large project this is indispensable. My only wish is that Facebook would drop flow and just help support TypeScript by adding the additional semantic checking into TypeScript directly. And in turn have Microsoft help with React. I love competition and stuff but web development has way too much ambiguity and we need standard tooling that works awesome, not lots of fragmented tools. 
That could be true. I don't know. All I read him to say is 'even if it's not valid javascript'.
&gt; Do you have a recent source for the statement? Or is it just conjecture? Nope, it's just a claim from anecdotes. I do think that a lot of compile-to-JS languages have been treated as "test-beds" to some extent, e.g. with fat arrows from CS. I can't imagine a future without transpilers, though, even for pure JS. They provide a nice layer of indirection that a lot of tooling depends on.
Typescript source code, in its raw, non-transpiled form, can still be valid JS. That's how close the languages are. However, all typescript source code is intended to be transpiled to Javascript by the compiler, before it touches the browser. So, even TS source code that isn't valid JS becomes valid JS via the transpilation process.
I've been using react native, but haven't really used flow in my own code. But have you found it to improve your code sanity? Looking at it, it seems to have a good amount of features to prevent bugs and too much duck typing. Though i do like a compiled language that is more strict sometimes. Like dynamic property assignment.
Both actually. 
 Something like this: &lt;button id="grandma"&gt;Add Heir&lt;/button&gt; &lt;script&gt; document.getElementById('grandma').addEventListener('click', function() { grandma.add(); }, false); &lt;/script&gt; Ideally you should be using [addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) instead of the inline onclick. You could also bind the event in your constructor. Same code as before but change the first part to: function Heir(el, elAdd) { this.el = el; this.count = 0; // This statement binds the the click event to the `add` method and binds the correct this context elAdd.addEventListener('click', this.add.bind(this), false); } // Previous code [...] // New Constructor var grandma = new Heir(document.getElementById("grandmaCount"), document.getElementById("grandmaAdd")); 
I learned js and angular at the same time and it wasn't bad. Had a lot of background in c++/php/Java/whatever so JavaScript was actually kind of a nice jump. I feel just learning js and trying to do something slick gets so daunting so fast that you might as well just jump in and learn a framework after you get familiar with JavaScript objects/variables/functions/etc. 
&gt; Most minifiers don't "get" how to minify the js after compiling ("transpiling") it. You mean uglify? How so?
So you have any examples of something that you would want to be "secure"?
Since you can have public and private fields on an object you could shorten the private properties - but this doesn't happen, which leads to hardly minified code in some instances. In JS you'd use scoped local variables. 
That's not a TS vs JS thing, that's classes vs closures. You don't have to use classes at all in typescript. You can use closures, modules and the revealing module pattern with types, it works great.
I like Coffeescript, but it solves only part of the problems JavaScript has, whereas some critical ones are left (in particular wrong number of arguments). Since ES6 came out, specially with fat arrows, the need for Coffeescript kind of faded away. Now, Typescript brings static typing, autocomplete, and solves the goddamn number of arguments thing. I'm going to use it for any new serious app I'll build from now on. 
I was REALLY REALLY hoping they would merge semantics in Flow/TypeScript, but they've been diverging more and more now. Usually Flow is ahead in terms of what it can catch and type check, and TypeScript is ahead in ES2015 support. Would be amazing to have a unified thing for an ES7/8 type proposal.
It's showing you the return value, `true`, after the log messages.
Yeah, but from what I've seen that's the default way to do things in TypeScript. It's the only thing I dislike, so it's not really a big deal. The way I code makes the rest so much easier, so it's a trade-off I've chosen. 
The first one has its prototype set to the second one, and was constructed through something like `Object.create`. That means that they will behave the same, unless you assign something onto the first one which will override the inherited prototype properties. Here's how you can emulate the behavior, it might make it a little bit more clear: // create a prototype chain var Cat = function() {}; // make our test subjects var cat = new Cat; var thing = Object.create(cat); // add a name to the cat prototype Cat.prototype.name = 'whiskers'; // observe flow of cat prototype console.log(cat.name); // 'whiskers' console.log(thing.name); // 'whiskers' // mutate cat cat.name = 'fluffy bottom'; // observe flow of cat prototype console.log(cat.name); // 'fluffy bottom', comes from object's OWN property console.log(thing.name); // 'fluffy bottom', comes from object's prototype // inspect our result console.dir(thing); console.dir(cat); console.log('Thing has own name: ', thing.hasOwnProperty('name')); console.log('Cat has own name: ', cat.hasOwnProperty('name'));
Yeah. I'm sure. But that's not what he said. And everyone tries to explain that to me. It doesn't matter to me. I don't care. I only responded to what he said.
Why not just use ES6?
Reddit is big on getting libraries/tools/frameworks/plugins. ANYTHING except using the core concepts. And no one knows why.
There's two key concepts here. In javascript, every object has a **prototype**, and every function exposes one that is mutable via `prototype`. Functions act as **constructors** when they are called with `new`. This means that `Shape`, `Circle`, and `Planet` are all constructors when called with `new`. This also means that `Shape.prototype.constructor === Shape`. An object will look up its prototype and that prototype's prototype etc. recursively until something offers it the property that was requested. If none can, then `undefined` is returned. When a property is *directly* set on an object, that property will take precedence over anything in the prototype chain. This is called an **own property**. This includes direct assignment onto `this` in constructors. With this understanding in mind, note that your code does not set any prototypes. Calling the constructor simply does the constructor work, but does not set up any prototype chains. If you wish for that to occur, you will have to do something like this: var Shape = function(x, y) { this.x = x; this.y = y; }; // some functions we want to inherit Shape.prototype.move = function(x, y) { this.x += x; this.y += y; } var Circle = function(x, y, r, c) { Shape.call(this, x, y); // set stuff }; // Set the shape prototype to be the same as the circle one so we can 'inherit' shape methods. Circle.prototype = Shape.prototype; // now let's play with a bit with it! var c = new Circle(1, 25, 1, 1); console.log(c.x, c.y); c.move(1, 1); console.log(c.x, c.y); // here's a cool part console.log(c.move === Shape.prototype.move); You can play with this example a bit. For the sake of brevity, I have omitted `Planet`, but it will work in a similar way to `Circle`. Here's some questions if you want to expand your understanding further: 1. Try omitting the line that sets the `Circle` prototype. Can you still call `move`? Why or why not? 2. Why was your earlier example, that did not set the prototypes, working correctly? 3. How could you avoid manually calling constructors with e.g `Shape.call(this)` and still get the same functionality? 4. Why does `c.move === Shape.prototype.move`? 5. In the above example, I have simplified the 'inheritance' by simply making `Circle` and `Shape` have the same prototype. This helps to illustrate with as little code as possible, but isn't realistic. Make it so that `Circle` 'inherits' from `Shape`, but adding onto the `Circle` prototype doesn't impact `Shape`. This will lead you into **classical inheritance**. 6. After doing 5, was it truly necessary to 'inherit' from `Shape`? Try to copy only the things from `Shape` that are necessary for `Circle`. This will lead you into **composition**. Remember that for 5 and 6, prototypes are just simple objects, which you can add to as you desire like any other object. Also keep in mind that every function has an exposed prototype for you to play with. I'll be happy to provide some examples if you get stuck on any bit! I hope this helps!
Babel contrib here, lmk if you have any questions. --- There's a lot of negativity throughout this thread so let me just silence some of the things being said. **Why modularize/remove transforms by default?** This was first brought up by the Ember CLI team (one of our very first major users) that they wanted to explicitly define which plugins they want to use (and remove JSX from their default). We sat on it for a while while it started to make more sense for other consumers. Tools like Ember CLI and React Native Packager both are better served by this change. Babel is meant to sit at a lower level than tools like that. The other major benefit is that explicit dependencies means our release schedule isn't tied to ES proposals. We've had to hold on releasing things because of the status of things with the TC39 committee, we've also had to bump major versions just for that as well. Now we can bump individual packages and since users have explicit dependencies we don't have to worry about people having their shit break randomly. This also means that individual projects have local dependencies instead of global ones. This was problematic before because people could bump Babel for one project and break another one in the process. **Why not have a sensible default?** This is something we've heard over and over again the last few weeks. However, it's not something we'd even consider because if you think about it for a second it makes zero sense. First off, what is the "default" state where we'd be "sensible"? When you have no plugins or preset configured? What if you just have broken configuration? What happens when you install a single plugin? Suddenly it starts behaving completely different, with a different API? Gross. Then what happens when we want to change the "sensible" default? We're back where we started with having to bump majors and tie our release schedule to the TC39. Gross. **Why are you trying to be a general purpose compiler?** Because the JavaScript community needs one more than it needs an ES-next to ES-today transpiler, and we can do both at the same time so why wouldn't we? It's not more work to be a general purpose compiler, it just means exposing internal things that we wouldn't have otherwise. **Why are you suddenly changing everything?** This isn't actually a new decision. We decided this back in January, well before 95% of people started using Babel. Back when our name was still 6to5. We made issues, and blog posts, and tweets, and conference talks. Short of making a release candidate (which is something we regret in retrospec), we did everything a project could possibly do to notify it's users and throughout the entire process it was nothing but thumbs up. I don't recall a single person arguing against these changes. I'm very sorry I couldn't reach every person individually to talk about this change, but this is what major versions are for. **Why is everything broken?** We're working our hardest around the clock to move everything along, Babel is very much a move fast and break things project. But we do follow semver religiously so you're totally safe. Also, we're a small team and we're not paid to do this, so please understand where we are coming from and don't be jerks. --- I'm very sorry if you've had trouble with Babel since 6.0. We're working our asses off to make sure everything is working perfectly again. 
Could you elaborate on the setup here? I'm a little lost on what's being attempted. You want to re-use the existing ractive instance for the tab being destroyed?
The idea is that it would load with a new ractive instance with the template for the new tab in its place
I can't get it to work. The buttons do not seem to be doing anything.
I don't think I'll mind it if I didn't have to constantly transpile it. Probably the reason why I never bothered to learn CoffeeScript in the first place too. When I'm trying to learn some language then I don't want that extra overhead. I should be able to just open the dev console and start playing with it. Now, for larger project I might consider it since I already have a build process and transpiling is just one step away. *Edit: transpiring to transpiling.*
While I don't disagree with you it would probably be more helpful to OP (and others) if you included an explanation as to why you think Meteor would be a good starting point.
Author here - thanks very much for replying! I hope the article didn't come off as having a go. Babel is a wonderful project, and I totally support your move to a platform model with separate modules for each of the transforms. Separation of concerns certainly feels like the best approach, even if it is a bit of a shock to the system at first. And despite being a huge fan of React, taking the JSX transform out of the default setup feels like the only sensible thing to do. The only thing that really strikes me as a little weird is the "sensible default" issue. While I haven't read any of your team's discussion on this, it doesn't feel like you have to *pick* between "separate es2015 preset with semver" and "es2015 enabled by default". I would have thought you could use both, but I'm sure you've got good reasons not to. In particular, a lot of runner scripts have been using Babel's `register` script to let them use ES2015 in tests, tasks, etc. While I know you can still make this work using `.babelrc`, it feels like there has to be a better way which doesn't involve a new file in every project. But on the whole, I'm sure we'll get used to whatever changes you make - the project is too amazing to do without. Thanks for you and the rest of your team's hard work!
&gt; Broke something during refactoring? The compiler will tell you! Have you tried it with Webstorm? I wonder how it works in conjunction with Webstorm's built-in refactoring and ESlint.
&gt; consistency in code style and good project organization And not documenting things, being able to flip-flop types, and having zero machine-assistence helps with that? CS also doesn't seem to support modules. By the way, type annotations aren't "unnecessary ceremony". It's optional documentation. Also, maintenance is easier with types. Upgrading dependencies is much easier if there is a checker which can identify most breaking changes. It will also tell you about affected call-sites if you change the signature of a function/method/constructor. CoffeeScript doesn't offer anything which would help with scale or maintainability.
Identifiers can contain and start with '$'. "$docWidth" doesn't make any sense though. It's a number, not a jQuery collection. So, there really isn't any reason to use a '$' prefix. It's a valid name, but there is no reason to use it.
I understand that, it's just that in many tutorials when naming variables using the '$' has become a convention, there is no problem for me leaving it off but i just thought it odd that the script wouldn't work with it at the beginning of the variable name and I don't know why?
Yeah, now your free to write crazy amounts of unit tests with type assertions (poor mans type system). Or spend way too much time in the debugger.
&gt; it's just that in many tutorials when naming variables using the '$' has become a convention Eh? No, people generally don't prefix their variables with '$'. It's done in PHP, because variables *must* start with a '$' in PHP. It's also sometimes done if jQuery is used, to indicate that the object is a jQuery collection and not a reference to a regular element. var body = document.body; body.classList.add('foo'); vs var $body = $(document.body); $body.addClass('foo'); Anyhow, check the console. There is probably an error somewhere.
/r/oddlysatisfying
 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Question 2&lt;/title&gt; &lt;/head&gt; &lt;body bgcolor="#A9D0F5"&gt; &lt;h1&gt;English to French Translator&lt;/h1&gt; &lt;form&gt; &lt;label&gt;Enter one of the 5 phrases:&lt;/label&gt; &lt;input type="text" id="EnglishToFrench" STYLE="color: #EEFFF; font-family: TimesNewRoman; font-weight: normal; font-size: 14px; background-color: #F2A4D2; width: 255px; height: 19px;" size="30" maxlength="50" /&gt; &lt;input type="button" value="Translate" onClick="translate();" /&gt; &lt;label&gt;Translation:&lt;/label&gt; &lt;input type="text" id="Translation" STYLE="color: #EEFFF; font-family: TimesNewRoman; font-weight: normal; font-size: 14px; background-color: #F2A4D2; width: 255px; height: 19px;" size="30" maxlength="50" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;script&gt; function translate() { var dictionary = { "He": "Il", ... }; // This grabs the value of the first input above and assigns it to a variable var englishWord = document.querySelector("#EnglishToFrench").value; // This checks to see if the word provided is in the list provided and assigns the result to a variable with a default value if it isn't in there if(dictionary[word]) { var frenchWord = dictionary[word]; } else { var frenchWord = "I don't know that word"; } // This assigns the value of the lookup to the value of the second text input above document.querySelector("#Translation").value = frenchWord; } &lt;/script&gt; &lt;/html&gt; There are obviously a bunch of other problems with this: 1) You shouldn't be using inline styling like this. Unmaintainable 2) Selectors such as id and class you use snake_case or hyphens (not PascalCase or camelCase) 3) There should probably be better error checking 4) Javascript should be broken into multiple functions But this should work. If you want to play around with these things really quickly and easily you should probably use something like http://codepen.io/ 
Linters are great for code style, so that problem is solved. Organization is also great no matter what language. Neither of those practices solve the problems that types do, interfaces are awesome for knowing what your classes implement and guaranteeing their usability in other places. When a change occurs, the compiler can tell you all the places that will break. 
If you're just getting started with Express, I'd recommend using the [`express-generator`](http://expressjs.com/starter/generator.html) tool (or just copying the layout it uses). It's good enough for small, basic projects, and you'll spend more time writing code rather than bikeshedding your project structure. Over time, as you get more comfortable with node &amp; express, you'll probably figure out what kind of project structure you prefer for yourself, and you'll be able to write a your own project scaffolds using something like [`yeoman`](http://yeoman.io/) :)
Basically, you'll need to do something like the following: - Add click handlers to the links you want. - In the click handler, prevent the default behavior (i.e. loading a new page) and: - Update the URL using [the `history.pushState` API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) - Render the new div Most front-end frameworks (ember, backbone, angular, etc.) will have some way dealing with routing, but there are also a few standalone client-side routing libraries that can handle some of the nastier bits for you. Take at look at these and see if they might be able to help: - [page.js](https://visionmedia.github.io/page.js/) - [flatiron director](https://github.com/flatiron/director) - [ampersand router](https://github.com/AmpersandJS/ampersand-router)
Sorry phdwannab, but you've got a bunch of related things all mixed up there. A language with static types simply means that a compiler or other tool can understand or infer the data types used in a program by analysing it directly (as opposed to having to execute the program first). How that type information is found can vary. Languages like C, C++ and Java require you to explicitly state the type being used every time you declare a variable. Other languages (i.e. ML family) can use aggressive type inference to figure out the types by looking at how variables are initialised and which functions they are passed to. Other languages like TypeScript allow a mix of static and dynamic typing, and also explicit typing and type inference. 
&gt; I hope the article didn't come off as having a go. You're good, no worries
I understand that feeling of freedom. I had it when I discovered Python all those years ago. But once the honeymoon period is over and you've got yourself some bigger code bases in Python or JS etc, then you'll long for some of the benefits that static typing brings. Try TypeScript. It's typing hits a wonderful sweet-spot in between pure JS/Python and your C++/Java at the other extreme. 
I can agree on that. Typescript just allows me to get stuff done and at the end of the day I don't have to worry about it diverging from JS all that much, if at all.
I was unaware JavaScript allowed plaintext in function call parameters? render(( &lt;Router&gt; &lt;Route path="/" component={App}/&gt; &lt;/Router&gt; ), el); Is this legal JavaScript?
No, that is JSX. It needs to be compiled to javascript. 
It's up to you. I find it important to fully annotate functions/methods. Inside functions, type inference generally works for almost all variables so I rarely have to use many type annotations. This way you can get close to 100% type coverage without trying too hard. 
It's JSX, so it will be compiled to the following (with Babel at least): render(React.createElement( Router, null, React.createElement(Route, { path: "/", component: App }) ), el);
With all factors taken into account (maintenability, error-proneness, performance, productivity ect.) I think untyped JavaScript/transpiled JS outperforms statically typed alternatives like TypeScript. From a pure performance point of view, TypeScript (and other statically transpilled languages to JS) will outperform untyped JS in most use cases. With asm.js, WebAssmbly and other initiatives, you'll really take advantage of static typing. Even if checking types in a AST is performant, this will never outperform an assembly code where no check is done, because the type is determined at compile time. What I don't understand is why people choose one transpilled language to stick with it to the death. Since everything transpile to commonjs modules consumed by webpack/browserify nowadays, you can use TypeScript for critical, isolated modules and regular babel ES6 for the rest of the code.
It is designed for some developers who sucks at writing SQL. Most of them are bad developers
Parens are not required with new. There's not much difference between `new Cat` and `new Cat()` other than a change of precedence if you were to chain something off the call, for example: var instance = new Cat.property; // &lt;- tries to new property var instance = new Cat().property; // &lt;- returns property of new Cat instance I generally always include the parens for consistency and I believe I've read places that consider it a best practice.
&gt; In the above example, I have simplified the 'inheritance' by simply making Circle and Shape have the same prototype. This helps to illustrate with as little code as possible, but isn't realistic. I think that's doing more harm than good. Circle.prototype = Object.create(Shape.prototype); Not that much more difficult and less catastrophic if someone copies the code to play around with.
Recently upgraded our app to React 0.14 and react-router@1.0.0-rc4 - didn't like how I more or less had to do both, but I really dig what react-router has become. 0.13.x was a bit of a mess but they really did a great job improving it.
It's a good idea to let type inference do its thing. Don't "over type". Literals always have a type and you also get the type information for free if you call an annotated function. So, add them to fields and function signatures first, because it's a good idea to have this kind of basic documentation. Add them elsewhere as needed. E.g. `querySelector('input.foo')` returns an `Element`, but you might want to have an `HTMLInputElement` instead, because the analyzer will then know that there's a "value" property which is a string and so forth. There is also the `--noImplicitAny` flag which will generate an error when the type wasn't specified or if it can't be inferred.
You query the DOM to get them all in a NodeList, iterate over them, create a new element, put the content inside it, copy the attributes, insert it next to the original, remove the original. Sounds like a rather silly thing to do though. If you want to change the appearance, use CSS.
Well, thats my gut feeling too. I cannot believe that it go so popular, though.
Usually, we put the source code in the version control system, not what can be generated from it.
Also stuff like this: &gt;But it has two caveats. First it has hard RxJs dependency and that is too much: if I select a rendering library then I don’t want it to constrain my state handling! Cycle.js basically just *is* RxJS with a thin layer of like 150 lines of code on top of it. I'd consider Cycle more of a paradigm along the lines of Flux. Implementing it in another reactive framework would probably be pretty trivial. On the contrary, this solution forces you to use React.
This blog post is a year old but could answer some of your question : https://www.terlici.com/2014/08/25/best-practices-express-structure.html You can also check to this [SO Post](http://stackoverflow.com/questions/5778245/expressjs-how-to-structure-an-application) get an idea of how many ways are possible 
The point is that we all know that documentation is important, and if you can add documentation that your tools can also use then it is a big win. TypeScript offer this. CoffeeScript does not. Also, what you call "hand-holding", I call "getting work done fast and accurately". Dynamic languages are very useful, but programs written in dynamic languages are still mostly static in their use of types by a large majority. The times you really need dynamic parts are quite few. TypeScript supports the static side while still fully allowing dynamic behaviour when you need it. As a developer, the personally responsible thing to do is to use these tools when you have them. 
&gt; Modules are a feature that can be had in almost any JavaScript variant (ES5, ES6, CoffeeScript) through the use of RequireJS, Webpack, or Browserify. "Modules" does of course refer to ES6's. It's the standard. &gt; Documentation is optional anywhere you go, and the lack thereof is not the shortcoming of a language but rather the shortcoming of the developer(s). Do you write lengthy doc comments? Do you think people are more inclined to write lengthy doc comments which might *eventually* be helpful in the future instead of terser type annotations which are helpful right away? &gt; IDE/Intellisense hand-holding Needlessly dismissive. You do realize that no one cares if you do it the hard way, right? It does not increase the value of the product. It doesn't make your customers more happy. You are doing this for yourself. You're taking some misguided pride in this. There isn't a single quantifiable benefit. Without optional types, there is more friction, because you have to check the docs/code more often. And you need more unit tests, because you have to exercise more lines to see if things still fit together. There is nothing good about that. That's also the reason why you can't come up with any actual arguments. There simply aren't any.
It appears you are correct, though my understanding seems to be a prolific misconception. In the interest of not spreading it further, I have deleted the comment. Thanks for teaching me something today. 
If you're using lodash, you could use _.get(a, "b.c"). 
It's possible. Whenever I learn things, I try to learn without a lot of the usual sugar, so I can understand *why* the sugar is useful and any potential shortcomings of it. I think that in this scenario, leading with `Object.create` would have made question 5 redundant, and with it, the intuition of what classical inheritance actually looks like in javascript. But if it was too difficult or misleading, I apologize; `Object.create` will suffice as well.
Javascript is a language that trends so freaking fast, you see the up and down, everything old is new again a lot in this language. I remember a few years ago when all I heard about was how types just get in the way. Typed languages were for greybeards. Now the community is singing the praises of type checking. I suspect in 2-3 years I'll be hearing the majority screaming how types just get in the way again.
Once the new instance is created with its data, a simple .detach() of the old instance and .render()/.insert() of the new instance doesn't meet your need?
Reading this I realized I don't see why you would want to use it over say, C#.
Nothing redditors do ever pisses me off. I just show it around to co-workers so we can shake our heads, do face palms, and laugh at how incredibly ridiculous people here are. 
The difference now is that people have large JS codebases. We didn't do that in the past. Typing really pays off when your codebase becomes large. Many people here have small amounts of JS which they don't have to maintain over long periods of time. So yes, in that case types just get in the way or are a pain to set up. What we are trying to do with JS is much more diverse than before. 
&gt; Why not just use ES6? 
When you say big JS codebase the first thing that still comes to my mind isn't even a recent development, the Dojo Toolkit, which is absolutely massive and has been around since 2005 though my first intro to it was in 2007. Often enough the new problems we are facing are just old problems with a new coat of paint.
Don't have to. Everyone else does.
There are many theories on why ES3 failed, but most of them do not consider its features to be the problem.
If your project doesn't include a build step yet, TypeScript probably isn't for you. For the many that do, however, this shouldn't really be a problem.
I don't think there's _that_ strong a reason to use Babel over TypeScript for ES6 support. That said, with Babel's recent developments, I could imagine it to be a relatively good idea for TS to rebase on Babel.
This has been the most boring conversation I've had all day
I think it is a useless abstraction since you can just use the [simplified constructor API](https://nodejs.org/api/stream.html#stream_simplified_constructor_api).
 ({ a: x =&gt; x * 5, b() { console.log(this.a(3)); } }).b(); 15 ({ a: x =&gt; x * 5, b: () =&gt; console.log(this.a(3)) }).b(); TypeError: this.a is not a function https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions Use shorthand methods if you want to to access `this`.
Thank you! Finished code that works.. module.exports = { GetPromoBoxStatus: driver =&gt; { //Returns true if empty driver.isElementPresent(By.id('cartRemoveCodeButton')) .then(res =&gt; res); }, DeletePromoCode: driver =&gt; { driver.findElement(By.id('cartRemoveCodeButton')).click(); }, InsertPromoCode: (driver, code) =&gt; { driver.findElement(By.id('redeemcode')).click(); driver.findElement(By.id('redeemcode')).sendKeys(code); driver.findElement(By.id('cartApplyCodeButton')).click(); driver.wait(until.elementLocated(By.id('MB_close')),10000).then(elem =&gt; { elem.click(); }); }, SwitchPromoCode(driver, code) { if(this.GetPromoBoxStatus(driver)) { //If promocode nox is empty this.InsertPromoCode(driver, code); console.log("Switched from no code to " + code); } else { this.DeletePromoCode(driver); //console.log("Deleted promo code"); //This logs right away?! } } };
For the TS compiler to become a Babel plugin.
I like what you came up with, clearly i was on the wrong track. What does the "#" sign act as before "Translation" and "EnglishToFrench"? Also, it doesn't seem to want to input a translated word in the text box, but i think it is very close.
Upvote for napa...but it's a package manager for a package manager which doesn't fix the problem OP has with the current state of package management.
You have two options: server-side or client-side filtering. Client-side filtering requires either having or downloading the entire data set. Depending on the set up this may or may not be an option. You could bundle the entire data set into an HTML file. Or if you're on a local network this might be a reasonable option as well. For server-side filtering, just about any database, sequel or otherwise, will be able to handle this. The data is small enough that you could probably load it into memory and filter it without a database. You'll generally see far better overall performance with one, however. 
Someone will surely tell me this is a mess... and I have a feeling it could be made simpler with regex, but... var bod = document.body; var bodIn = bod.innerHTML.split(""); for (var i = 0; i &lt; bodIn.length; i++) { if (bodIn[i] === "&lt;" &amp;&amp; bodIn[i + 1] === "p") { bodIn[i + 1] = "h1"; } if (bodIn[i] === "&lt;" &amp;&amp; bodIn[i + 1] === "/" &amp;&amp; bodIn[i + 2] === "p") { bodIn[i + 2] = "h1"; } } bodIn = bodIn.join(); for (var i = 0; i &lt; bodIn.length; i++) { bodIn = bodIn.replace(",", ""); } document.body.innerHTML = bodIn;
If you're going to do it client side you'll want to make use of workers and transferrable objects otherwise thats just too much to process at once client side. My recommendation if you were to use hamsters.js would be to write something that will convert the json characters into an integer based array, then convert it back to json to manipulate inside the worker itself. You can make use of multiple cores to process this client side but you'll need to get creative and make sure the json file is in pages, then your convert to array function should separate each page into a subarray inside a larger array, then pass that to hamsters.js and specify the number of cores you want to use and it can search multiple pages simultaneously that way 100% client side. 
You need a runtime environment which lets you do this. Node.js, Electron, NW.js, and so on. &gt; I can't install any program Uh... WSH? https://en.wikipedia.org/wiki/Windows_Script_Host That's a shitty JS engine though. Aaaand a shitty API which involves ActiveX by the looks of it. Well, a browser can read files which were explicitly opened by the user (e.g. via drag &amp; drop). https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications
Tell me about it. This is the reason I avoid them though, today, I'm waiting on someone else. Reddit threads are mostly beyond stupid.
If you are okay with a Chrome only solution, you can try the [FileSystem API](http://www.html5rocks.com/en/tutorials/file/filesystem/). Since the API is not actively supported anymore, it can be found in Chrome with `webkit` prefix. Disclaimer: I have not tried it personally.
Redditors are so bizarre. Not only can't they understand the question, they then make things up to so they can post about their made up ideas.
Lol wut? 
Do you have code examples?
People say that types get in the way. Other people say that creating large applications is impossible in dynamically types languages. Both may be true. However, my own experience is that I need to refactor often. My apps are large and many years old. Lastly, refactoring a dynamically typed language is very difficult and often seems to be limited to a global Ctrl-F and global Ctrl-R. :(
Union and junction types make me sad. :(
You could create a lookup var directionText = { "go east": "You find an open window, it must be night outside, it's just big enough for you to fit through. What will you do?", "go west": "A small table with bread on it. What will you do?", "go north": "A stone wall, it's very cold. What will you do?", "go south": "A locked door. You can hear the shuffling leaves and branches outside. What will you do?", "default": "You can't do that right now." }; console.log(directionText[reply] || directionText["default"]); // The || is used to fallback to "default" if reply gives an undefined
See what I mean.
&gt; https://xkcd.com/927/ ;) But seriously, why roll your own if you like Vue? I know, I know. It took me like ~20 hours to write it, not a big deal. I just love to have freedom to change any part of it however it suits me. Two huge caveats tho: I'm the only person working on frontend + we render almost everything server side so vue/react make no sense. I insert html and then sprinkle javascript over it. (I know, I'm LITERALLY HITLER). If we rendered on the client I'd probably go for vue! :-)
It means you can make huge applications easier. It means your IDE can tell you what is appropriate to use and what is available after you press the period key. It makes changing the name of a function or a variable everywhere in your huge application super easy. It makes the V8 engine super fast because it doesn't have to de-optimize your code because you are passing in letters sometimes and numbers other times.
Interesting... Thanks!!
yeah, before i put this up i had if/else within eache else if statement, but it took far too long to code, and had lots of bugs.
Well, it's helpful at least to know that it's supposed to be this difficult :) Isn't Redux a (simpler) replacement for Flux?
exactly, im just trying to find a more efficient means of doing this
No, because TypeScript is relatively monolithic compared to the JS/Flow combo. The TS type checker is necessarily up to date with the rest of the language.
Please laugh at my misery but I only have IE. "why don't you install chrome?" &gt; I can't install any program 
I'm not sure that there is...
Ha, ha! Ok then :)
This may sound a bit contrarian, but you may not need a framework at all. This is particularly true if you're the only developer working on this project. If you're new to modern JavaScript development, it may be worth it to work through some of the common pain points of the platform that many frameworks are abstracting away ad libitum — that's really the only way you won't get stuck as being just a framework technician rather than a true JavaScript Engineer. If the latter is not a personal goal of yours, then definitely feel free to disregard. You can always tack on a framework down the road if you find yourself doing too much scaffolding, abstracting, etc. yourself.
Why not validate the product first, a la MVP strategy before you go down the rabbit hole of locking yourself into any given architecture/design strategy?
My intention is to start with an MVP, but even that involves building quite a complex UI.
You could take an iterative approach to fixing things. One thing at a time. Do you have automated linting + style guide enforcement for the code in question? I find its always helpful to inject linting into the continuous integration layer so that robots constantly yell at you about fixing style/smells rather than yourself or your coworkers :) At the startup I've been part of bootstrapping for the last 11 months — we made sure all repos had automation for the following so that we avoid smells down the road: - requirement for 100% unit test coverage - JSHint linting - JSCS style enforcement (using [Idiomatic.js](https://github.com/rwaldron/idiomatic.js/) as a guide) And all changes are integrated on Github via Pull Requests, with the caveat that you can never merge your own PR. So if all the automation listed above passes, a big green checkmark will appear on the commit. This makes code review and housekeeping separate concerns for the reviewer, which tends to keep the discussion about implementation and design rather than nitpicks.
Simple !== Easy Especially when elite facebook javascript developers use it
In the examples I saw in this post, the partial application done was meant to be more illustrative than anything. In practical terms, it usually doesn't make any sense to partially apply a function if it is only used once. Instead, you can think of it in a more, well, functional, way. Imagine you had a set of DB functions like this: var db = function(connection) { this.connection = connection; this.entities = [ ... ]; this.save = (entity) =&gt; { ... }; this.delete = (id) =&gt; { ... }; }; Partial application can be used to allow functions to still be more pure without being really awkward to consume. If we did a straight rewrite to more pure functional, we might end up with something like: let save = (connection, entities, entity) =&gt; { ... } let delete = (connection, entities, id) =&gt; { ... } But this is annoying, as now we need to pass those around every single time we use them. We can solve this with partial application: let save = (connection, entities, entity) =&gt; { ... } let delete = (connection, entities, id) =&gt; { ... } let db = function(connection, entities) { return { save: save.bind(null, connection, entities), delete: delete.bind(null, connection, entities) } } In this way, we get a similar API to the more OOP-style DB connection, but we achieved it through more pure functions which can be easier to test and reuse (since they're just functions). EDIT: if you're still not really sure what bind does, [check out my explanation below](https://www.reddit.com/r/javascript/comments/3sa0pn/functional_programming_by_example/cwvzptw). This was a bit contrived but I hope it illustrates when partial application can actually be quite useful.
Dude, were you born yesterday? Bounce back harder every time you are knocked down. The recruiters who reject you when you are a nub will be licking your toes when you are at your prime. But, be kind to everyone cuz the rear you kick in your prime might be the rear you have to kiss in the decline of your long and storied career.
Maybe "basic js" wasn't a good choice of words. I know all about objects, variables and functions. I also have a good understanding of PHP (building WP themes).
Guys OP is stuck in 90's web hell.
You deserve to be banned from here too for this question.
Here is my (probably unpopular) opinion: You don't need flux / redux! Flux is overkill and is only a benefit to larger apps which have many developers working on the code. Otherwise it adds a ton of boilerplate and complexity when you can get by just fine by firing events and storing app state on a global object attached to window. So just build your SPA using React and plain Javascript and if you find it hard to manage the state of your app, *then* you can try flux.
Solved the problem. I was just stupid. :) Tnx tho!
Finder is the biggest piece of shit in OSX.
Why do you say that? In my opinion it's one of the best. The only one that I like as much as it is nautilus 
Partial functions seem to me (a non-fp-minded programmer who knows bash) as just a terrible approximation of a "pipe". I think it's a lot prettier to say: getWordsFrom $FILE | tallyElements | sort | head 10 What would this style of invocation be called, and are there any languages which allow you to go from: step3(step2(step(1))) to step1 | step2 | step3 ? 
Very interesting, thanks very much for this!
Thanks! That guide was really helpful - I reworked the module a bit to adhere to the comments. 
Might be a good idea to explain what bind does for those who are unfamiliar with partial application, especially since bind is has a specific purpose in javascript.
If you're not a fan you can always put all your exports into an object and `export default` it. 
You're describing a thing I just wrote. I wrote a set of database boilerplate functions that took a connection string and then a query, but I returned a partial with the connection string/model already applied. https://github.com/alexanderbanks/scrud/blob/master/src/scrud.js I'm only linking it because I think it's interesting that I wrote it and then you described almost exactly what I did.
Partial application isn't really the same as pipes, pipes are just composition of functions. The reason that the example has partially applied functions is so that it can take a function with N parameters and build a function that only takes 1 parameter. If you have functions that only take 1 parameter to start with you can just pipe them together, most functional languages use compose which is just pipes in the reverse direction. I think Lodash has a chain function which is just reverse compose so you can do `_.chain(step1, step2, step3)`.
I disagree on the file naming conventions but other than that it’s not bad. I thought the 1.5 GB limit you noted was interesting so I’m going to look more into that. If anyone has any good resources feel free to share.
&gt; you can get by just fine by firing events and storing app state on a global object attached to window How do you keep the React components synchronized with the global state?
I think they have some changes proposed in the syntax for es7 which make it better, but no browser is even remotely close to implementing modules anyways. I think es6/7/2015/2016/1999 modules are dead on arrival.
Actually, I have to agree it's a pain to debug CS compared to JS. If CS had some bonus, that would be one thing but.. 
This is great! Super easy to use and great documentation! Thank you! 
Some notes I wrote down from deconstructing the db: **Terminology** - Value - An immutable magnitude, quantity, number… or immutable composite thereof - Identity - A putative entity we associate with a series of causally related values (states) over time - State - Value of an identity at a moment in time - Time - Relative before/after ordering of causal values - inform - * to convey knowledge via facts * give shape to (the mind) - Information - the facts - Fact - an event or thing known to have happened or existed * From:factum - ‘something done’ * Must include time **The database as an expanding value** - an accretion of facts - the past doesn't change - immutable **Approach** - Move to information model - Split process and perception - Immutable basis in storage - Novelty in memory **Implementing Values** - Persistent Data structures - Trees - Structural sharing
what if I, for sure, know that what I'll be finding is in a div. Does this change anything? here is what I have http://jsfiddle.net/hefGK/1719/ all i want is for the button to hide and unhide
Use offsetX/Y as I did in this demo: http://jsfiddle.net/m3yw1gu7/
Firefox didn't support it until 39.0. That's probably why. All other browsers supported it since forever.
It makes sense its number 1. A lot of things on github are Web projects and they pretty much all use js.
alright, thanks a bunch
Well if you really don't have any ideas at all, you could build a "database" of all the words that you need to translate in all languages needed. Then whenever translating, replace each word with its counterpart. One way you could do this is to create a Very LARGE number of objects.
It is supposed to show up as a network error, but I imagine the error message could indicate the failed integrity check. I would like to see another error code introduced ("418: Resource Integrity Check Failed"). 
here's a really basic way to accomplish something like this: var languages = { en: { "a phrase that can be translated": "a phrase that can be translated" }, fr: { "a phrase that can be translated": "french version" }, de: { "a phrase that can be translated": "german version" } }; function translate (language, phrase) { return languages[language][phrase]; } translate('fr', 'a phrase that can be translated') // french version Of course, this has no error checking and is quite rudimentary, but it should give you a good starting point. To get an idea of how complicated proper internationalization can be, take a look at some modules that do this: https://github.com/mashpie/i18n-node/ https://github.com/i18next/i18next/ And of course, https://www.gnu.org/software/gettext/manual/html_node/Plural-forms.html 
 Document.getElementById("dayNumber").innerHTML = "Day " + dayCounter
Hi /u/zackgchase, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `distelli.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [distelli.com](/search?q=%28and+site%3A%27distelli.com%27+author%3A%27zackgchase%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|8|80%
Oops, you're right I forgot about return values.
Your keyboard should work now! Lemme know if you find any problems.
Fixed. Thanks! :)
Glad I could help.
realistically, rx.js and immutable.js for data/event management, react for view layer + libs for dom level interaction is all you really need to build a clean organized app
Javascript is undoubtedly popular, but I think all the recent JS frameworks are a significant factor here. Consider React's JSX: it's HTML rolled into JS, but the entire file is still considered JS according to GitHub.
JavaScript is the language that every web browser on every computer and smartphone on the entire planet understands. It's only going to become more popular.
`data:text/html,&lt;div id="foo"&gt;test&lt;/div&gt;&lt;script&gt;console.log(foo)&lt;/script&gt;` Load that in your browser (just copy &amp; paste into the url bar) and look at the console. I haven't tested data URIs in IE in a long time (ever?) but definitely works in FF, Chrome, Safari
&gt; It is literally the worst idea to rely on that. FTFY :) &gt; it isn't until you specifically assume it is I haven't looked into how it's implemented but I had heard that before. `'foo' in window === true` but it's not in `Object.keys` or `Object.getOwnPropertyNames`, so I guess it's somewhere on the prototype chain
Nice solution. I love how clean and flexible this is.
It's probably not a bad idea to get good at es5 before starting learn es6 since a lot of es6 stuff isn't necessarily new but rather expands on what you can do in es5. I knew es5 fairly well before I started learning es6, but this is just me. Here's what I did; it's pretty simple. I started reading [this book](https://leanpub.com/understandinges6/read). Got about 1/3 of the way through and just started writing es6. It's not enough to be awesome at es6, or javascript, but it's enough to get started. Codepen and jsbin have Babel, so you can practice without having to worry about using the Babel CLI or a build process (although the Babel CLI takes like 1 minute to set up and learn). It's a lot of fun. Just start using it. Start thinking in it. Start reading about it.
Yup, that's exactly what I am doing. However we all have to rely on OS/3rd party modules etc, which won't all follow the same pattern :/
I'm yet to give you a reply because this is the solution im pursuing. Thanks in advance... hope it works!
Just for the sake of argument.. They really should say "most widely used programming language". I love the things I can do in JavaScript, but I would really really really rather be doing the same things in a different language - if I could:)
Sure, because everyone and their dog has a few 5-100 LoC JS projects. This adds up. You won't do that kind of thing with C++, for example. Adding a C++ library to your project is more involved. So, naturally, your C++ library has to do something quite spectacular to be worth it. The barrier to entry is extraordinarily low with JS. E.g. crappy 50-line jQuery plugin you wrote in 2 hours is a perfectly reasonable open source project for GitHub. It can easily get a hundred stars and be featured in various blogs.
PHP is just like, "can't you all just stay put? god!"
Is the currying example really currying?? https://github.com/airportyh/word-count/blob/master/9.fp-currying.js#L81 Wouldn't currying form a pattern more like: step9(step8)(step7)(step6)(step5)...?
It's an object-oriented way of providing for encapsulation and controlled mutability. The primary benefit of this is that it means you can write programs that can't get into unexpected or undesired states as easily, reducing runtime bugs, and letting you be a bit less defensive about handling bad state. As a dumb example, without encapsulation, you have no way of prevent "illegal" usage of objects, like below. class Person { construtor(age) { this.age = age; } } let person = new Person(15); person.age = -33; But with encapsulation and private state, you can expose only legal behavior: class Person { private #age; construtor(age) { #age = age; } incrementAge() { #age++; } getAge() { return #age; } } let person = new Person(15) person.incrementAge(); // 16 Of course, you can *already do this in JS* using nested functions, just not with the new class syntax sugar (yet): function Person(age) { // private state var age = age; // public API return { incrementAge: incrementAge, getAge: getAge } function incrementAge() { age++; } function getAge() { return age; } } let person = Person(15); person.incrementAge(); person.getAge() // 16; Arguably the above is less elegant than proper class syntax, but it does achieve encapsulation.
Here you have a couple of excerpts from this article http://danmartensen.svbtle.com/an-intro-to-javascript-modules &gt; Isaac Schlueter, who created NPM, echoed this concern. &gt; &gt; "If the author wants [the module] to export multiple things, then let them take on the burden of creating an object and deciding what goes on it. The syntax should suggest that a “module” ought to be a single “thing”, so that these util-bags appear as warty as they are." [2] &gt; &gt; Dave Herman, the lead architect of ES6 modules replied. &gt; &gt; "If you want to export multiple functions, for example, you can export a single object with multiple function properties. But an object is a dynamic value. There’s no way to say create a compile-time aggregation of declarative things analogous to an object. Such as a collection of macros, or a collection of type definitions, or a collection of sub-modules that themselves contain static things. It’s one thing to encourage single-export modules, it’s another to require it." [2] &gt; &gt; At least ES6 favors default imports/exports, giving them the best syntax compared to named exports.
Interesting :) I have used scrolling in the past as a trick to animate, prior to the days of 3d transforms. Now I see it is bit more complex than I thought. Thanks
Considering the headline, it would be really nice with an ELI5?
I actually find deconstructing the db one the most engaging talks I've heard from Rich Hickey, but I also never finished the Apache Samza talk... although there's probably some useful info from Samza that's not included in Datomic. But there's also a good talk by David Nolan called 'Om Next' where he gives some interesting history and addresses relay/graphql/falcor relative to datomic, and I might have seen a datomic / redux stack mentioned on Twitter but I didnt investigate much further. There's also a datomic-like db implemented in cljs that can prob be ported to immutable and es6
https://twitter.com/awbjs/status/664335959396212736 Probably.
That would be composition, not partial application. Partial application would be `step(1)(2)(3)`. Or, best used as `var s = step(1); s(2,3); s(4,5);`
The hardest part (IMHO) of redux is wrapping your head around how the state is mutated. The rest is simple circular flow. Reducers/state -&gt; Selectors -&gt; Containers -&gt; Actions -&gt; Reducers/state
This is a great curation!
Disclaimer: I could be wrong. I was under the impression that you could use symbols to create private fields on objects. Therefore, I was kind of expecting a proposal like this use symbols to get private fields and to just put some sugar on it to make it more convenient. This probably doesn't satisfy the "Secure" part of the "Some Requirements", but I think we should be guarding against Murphy (=human error) and not so much against Machiavelli (=human malice). If you need to past an object into a sandbox on some kind where untrusted code runs, then this (uncommon) use case is already handled using closures. Using `private` makes sense to me but that is mostly because I'm used to it from Java and TypeScript. For JS on the other hand this is quite a departure from the past. Fields on objects haven't needed to be declared in advance. This appears to be pure optimisation. If declaring something `private` also allowed you to drop the `this` when accessing it, then it might be useful, although we would also need `public` and `protected`. (If we are going to declare fields should the JS engine also forbid access to undeclared fields at runtime?) `#` and `private` at the same time seems redundant. I'm simply not keen on `#` at all. Other stuff. Static private state and private helper functions are better solved by putting then inside a module and not exporting them. `friend` smells of C++. All up, I'm not super impressed with this. 
Why not? *Edit:* In terms of Babel not being fit for the analyser. I feel it's not likely to happen either.
Are you saying it's not the most popular programming language or that it only is due to accessibility?
&gt;Would I get confused between es6 and examples and tutorials that I'm guessing are almost all written in vanilla js? Yes. I've been writing JS for 10 years and ES6 syntax still confuses me. It's all syntactic sugar anyway. I'd suggest learning core JS/ES5 before adding ES6 on top of it.
&gt; Gaining more control about when rAF fires ... [frame timing] This wouldn't help you. The issue is around the `mousemove` event, not rAF. (just tested this by writing a few lines of pure JS to do the same thing, was curious if your framework had internal lag) Input prediction _might_ work, but you'd probably run into an issue of over-predicting fairly easily. Is there a reason you need this to be faster than it is? I'd just accept it as a browser issue and move on. My guess as to what's happening is close to yours -- the on-screen mouse is updating faster than the refresh rate of the page. The HTML5 draggable might be using a different rendering path. [edit] Considering that you can drag the HTML5 element out of the browser window, it's _definitely_ using a different rendering method.
**most used**, not most popular.
Yeah there's a couple reasons this is something I want to fix. 1. This isn't a huge problem with mouse input because there's currently (perceptually) zero lag between your hand and the mouse. But touch already has a clear inherent lag and this exacerbates it. I want touchscreens to feel like they do in this interesting Microsoft Research video: https://www.youtube.com/watch?v=vOvQCPLkPt4 and I want my framework to be able to offer that same experience if/when they do. 2. The framework's Input class is open. The mouse and touch pointers use it internally, but hypothetically someone could link anything up. Lag that feels acceptable to a mouse/desktop user might not feel so good for an Oculus Touch/VR user. I've tried WebVR and it makes me seasick, but I want to be in a position to make it viable. 3. As it'll be solved at a framework level, solve it once solve it for everyone (that uses it). That's pretty sick. Input prediction does seem problematic for the reason you stated. The approach I hypothesised in the OP wouldn't work because it doesn't account for changes in velocity. Thanks for helping me look into this though.
You're definitely not the only one frustrated by this. You've got npm, bower, napa, jspm, jam, duo, ender, volo, ringo, broccoli, browserify, component, webpack, normalize, and probably others I haven't seen or heard of. What pisses me off is that any given package may work with one or some of the above, but not all. If you decide you want to use a specific package manager and the tool of choice isn't built to work with it, or worse - has code that prevents it from working with it - now you're in fork-and-hack mode. Ugh.
Another possible approach (for future reference): your JS can create and manage an IndexedDB of the data itself, which will be stored with the user's browser. Sure, they can go and clean it all out at some point but same thing with a flat file, plus they have to go out of their way, intentionally, to do that. Anyway, yeah - store it in JSON and put it in that indexeddb (use an abstraction layer like pouchdb or something if you like, too).
Obviously my google-fu stinks—anyone have a link to a Blink home page or something? I have no idea what it is and the slides assume I do.
Not only that, pretty much every web application will require some JavaScript no matter the backend language. So other backend languages are fragmented, while js is included in all of them.
It's not necessarily because of the DOM. The lag exists in canvas. As /u/ZyklusDieWelt said, this is partly mousemove - it's also partly when the movement gets processed. I've just been looking at it and it gets calculated after 2-3ms, so there's another ~13ms before the frame actually renders.
So I "came to" javascript, begrudgingly, from other programming languages. Take everything that follows with a grain of salt and the understanding that I'm primarily a server-side developer doing DevOps on Linux and writing code in other languages for various purposes. I had a project to build an SPA. I started dorking around with javascript in browser and was *appalled* at the stuff you can do. Wait, I'm writing a function and not passing all the required arguments *and it runs?!* WHAT THE HELL? You mean I can even pass MORE arguments than its signature supports and that *works!?* Wait, wait, what the fuck, how can this be an *object oriented language* (NB: I now know it's considered a "prototypal language" instead, but there's a lot of docs on the web claiming JS is object oriented) and not even support the *class* keyword!? So with great frustration and unhealthy amounts of pissitivity, I tried TypeScript. Oh, wow. I was - and am - in love. Fixes a lot of stupid shit and adds a whole lot of wicked cool features at the same time, including support for ES6 features (to varying degrees). So +1 - a BIG +1 - for TypeScript from me. I may not be a full time or "pro" js dev, but I know that it made it possible for me to *survive* the hellscape that is front-end development. (Also, nothing against other JS transpiled languages or JS itself; I think the biggest problem with JavaScript isn't the language, it's the fucking DOM and its inconsistencies and stupidity. But that's another discussion entirely.)
You say this like its a bad thing, but I disagree.
[Blink](http://www.chromium.org/blink)
I'd welcome other languages moving in. Having one web language is a weakness.
Good point. I'd never previously heard of ELI5, but I'll give it my best go here: **About Databases:** * Databases contain a company's data. * They are operated on by application code. * These days, it's usually web application servers read and update the databases. **The Movement Towards Pure Functional Programming:** * There's been general movement to pure functional programming recently because programs written this way are easier to reason about and avoid most of the obscure bugs normal programs have. * Pure functional programs can't have any shared mutable state, and this meant the first generation of functional languages were close to useless for any real-world applications. * It's taken twenty years (Miranda -&gt; Haskell -&gt; Erlang -&gt; Clojure -&gt; Redux/React) to grow the usable domains that functional programing languages can be used for. * Redux/React finally makes it possible to have complex JavaScript SPAs (Single Page Applications) that are purely functional. * But, the database is one big shared global variable, that otherwise pollutes the simplicity of our apps. **Streaming Databases Based On Historic Immutable Facts:** * It's been pointed out (e.g. Apache Samza and Datomic) that storing the historic immutable facts that cause data change can lead to a much simpler, functional database. * Redux applications can already share the same state atom on both the client and the server, which makes the server a bit like an in-memory database. * My article shows that a few tweaks can be used to turn this in-memory database into an Apache Samza style database. * This gives you a 100% pure functional full-stack solution, all created with the same tooling, and with updates streamed all the way from the database to the screen as they occur. 
https://code.google.com/p/chromium/issues/detail?id=117032 tl;dr -- browser bug(s), move on with your day :) You might want to chime in on that thread, however, to verify that this is the exact same issue. [edit] I _strongly_ suggest you just ignore this, and I'm the type of person that is generally obsessive over crap like this. The issue is this -- It's not a consistent issue. FF &amp; Chrome both lag, but they lag by different amounts on my machine. Phones &amp; Tablets? No idea. What about once you do "fix" it, and the browsers start to fix it as well? It seems like a handful of legacy bugs from switching to GPU acceleration, and it's pretty much out of your control :(
This has the exact same issue, it's just harder to see because of the cursor and background choice :)
I would argue otherwise -- it has been a source of strength.
Also, it doesn't use rAF, so a percentage of frames are going to be reading mouse inputs from closer to the frame draw as it's out of sync with the actual framerate.
No, they won't. mouse input is queued at once per internal animation frame, regardless of when you read them. Otherwise you'd be getting thousands and thousands of `mousemove` events.
Heads-up: the html5 drag-able in your Demi doesn't work on mobile safari (iPhone 6)
All the more reason to get a good JS implementation :)
I disagree, I think it's the opposite. You can express what you want in a way that's very specific, boiled down to just the operations you want without all the boilerplate and extra wrapping. Even when something is used only once, or anonymously, the win in clarity, simplicity, and syntax is big.
They actually *do* automatically bind their this from their lexical context. You cannot re-`bind` a fat arrow function to use a different `this`. Check this out: var test = new function() { this.lexicallyBound = () =&gt; this; this.normal = function() { return this; }; } test.lexicallyBoundOutside = () =&gt; this; console.log(test.lexicallyBound()); // test console.log(test.normal()); // test console.log(test.lexicallyBoundOutside()); // window or null var reboundLexicallyBound = test.lexicallyBound.bind({}); var reboundNormal = test.normal.bind({}); var reboundOutsideBound = test.lexicallyBoundOutside.bind({}); console.log(reboundLexicallyBound()); // test console.log(reboundNormal()); // {} console.log(reboundOutsideBound()); // window or null Normal functions are the ones that don't automatically bind this, and are thus subject to the various cases where it is something you're not expecting (such as window). This effectively makes a fat arrow the same as doing `(function() { return this; }).bind(this)`.
Also with source-maps and the TypeScript-Atom-Plugin that compiles on saving I don't really see the point. You can play around with it, and what TS adds to JS isn't relevant in the dev console. 
The barrier to entry for PHP is even lower, so that's only part of the story. Right now if you order the repository search by most stars, you're going to find out that almost every top REPO is either Javascript, HTML/CSS or a non-language (like books or a configuration tool). You have to get out of the top 10 projects to get to the first project that isn't front-end. It's Rails, for the record. I think the bottom line reason it's #1 is because it's the only language that solves a web-based problem. If I need an app to run on Windows I have a hundred languages I can pick from. If I want a web-based application I can pick one language. To me, that's way more telling about popularity than barrier to entry is.
I like this Backbone-prototype idea! However I still want to recommend that your application logic must be in vanilla javascript, from there on you won't care about pulling out backbone before its too late. Not to mention unit testing a vanilla code is the easiest between all. 
Node is IMHO the main factor, the tooling just got much better and there are now considerable amount of people using it on their backend.
I've always used camelcase - never had a problem with it
It's great but I would rather they use the keyword private instead...
Totally agree that using hash-tag to reference a private field is incredibly odd/awkward.
I can't tell if this is satirical
That was Chrome, this one's Firefox http://imgur.com/cTiAlez I was of the impression you can't count on mousemove being synced which is why I wrote an asynchronous update function in the first place. It's obviously non-ideal though, I should raise it as a bug still.
How is that click bait? You know going in it is associated with Github and obviously the metric is going to be quantity of code... 
&gt; closer to the time the next frame fires. Have you tried [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) ?
I think that Java's growth is an interesting thing to look at. According to the post, the stats include both private and public repos. I wonder if Java is shooting up because of an increasing number of proprietary code bases being moved to Github.
I made [my own implementation of dragging](https://jsfiddle.net/krd1mb88/) to test if the lag might be caused by jQuery's Track. My version uses CSS transforms during the movement and only updates the actual position when you're done dragging. My version might be slightly faster, but I really don't see much of a difference. I'm guessing this is simply a limitation of the browser and how fast it renders. I even tried forcing a repaint by getting the element's offsetWidth after updating the transform in hopes that it would reduce the visual lag, but it didn't. There's only one situation I can think of that I've been able to get non-laggy rendering and that's using Canvas. Though there could still be lag and I just don't remember. It also requires a lot of work if you're already relying on the DOM. EDIT: I could make a canvas version for you if that will help.
My guess would be that the dragging API is trying to figure out where your draggable item can go on mousedown, at which time the stuff that is hidden with display: none isn't being considered. If you change to using visibility: hidden and visibility: visible instead of display: none and display: block it seems to work fine.
&gt; Having to prefix everything with "this." in ES6 is pretty annoying. Not having to do that for private fields would be a huge incentive for making as much as you can private. That's a huge part of the appeal for me. You get both internal state and more ergonomic access at the same time.
Moving the .addClass('active'); to a mouse down event seams to fix the problem http://jsfiddle.net/zyq8u38f/1/
The problem with using the regular dot-notation for accessing private slots is that you would then need to insert access checks around every dot-lookup, which would make all existing JavaScript slower. This is a problem for implementations, but it's *also* a problem for humans: because JS doesn't have a type system, it would be very easy to mess this up. Using `#` gives us a clear signal (to implementations *and* humans) that we're talking about a private field, and a shorthand form for classes (`#foo = 1` instead of `this.foo = 1`) that makes it quite ergonomic to use internal state. Win/Win.
This is really cool. It never occurred to me (for example) that the mere presence of certain scroll listeners would force scrolling onto the slower main thread because of the potential for cancellation. TIL.
I disagree. What you're describing is the apparent result, which generally looks and works the same as if you're binding "this." But the underlying behavior is just to not re-bind the "this" keyword within the Arrow function: it remains as it was without it. That's also _why_ you can't rebind it (or use the "new" keyword on it): it doesn't support a new local meaning for "this" in the first place, so there's nothing to attach things too. The "this" in this case is _already_ lexical: Arrow functions differ from regular functions by NOT messing with it. I am willing to be corrected here, but I believe the .bind(this) comparison thing is a common misconception (stated in a lot of articles, and good enough to get people coding, but not strictly true, and somewhat misleading). Regular functions have a whole host of rules that determine what "this" will refer to in the body of the function, one of which is whether there is a .bind(this) after them! Arrow functions forgo that. &amp; that's also, coincidentally, one reason why they could potentially be more performant in the future (they're not atm, though if you're transpiling them then you're basically ending up with the same result anyhow).
Just because I'm interested: why?
One proof is in the link. It happens all the time. Sometimes it takes a few years. Sometimes a few weeks. It happens to most of them. Practically nothing I used when I started in this business, in 2004, is still around today. At least half of things like this will disappear within the next three to five years.
It's the most popular language **ON** github.
Proxies works in Firefox
I don't think shirtjs is a framework. It sounds like they sold shirts.
It'll be laggy even with canvas. [Here](http://jsfiddle.net/dethstrobe/w6gtLtwc/) is a game map I made a while back for a game concept I've not worked on in months. There is still a bit of input lag while dragging, but I found it to be exceptable.
This is what I have been using for a boilerplate: https://github.com/erikras/react-redux-universal-hot-example Apart from the redux docs, this tutorial helped me get up to speed with most of the concepts: http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html The one thing I wish I knew when I got started with redux is how to properly test connected (smart) components. I'm still wrapping my head around this. The redux docs has a section on testing but the explanation for connected components didn't have a code example like the one for dumb components. Last time I took a look it only explained how to export those components for testing. As far as testing tools go, eventually ended up using karma, mocha, chai and sinon. Hope that helps
The linked article points out the problem—cross-platform issues, something I've certainly been bitten by.
Don't rely on others. Learn to make shirts.
100ms is an incredibly large window for continuous input. It's okay for an action-&gt;response interaction but way too much for mouse/touch move. Also I've given an example, I'm clearly asking how to achieve 0 lag between visible input move and corresponding element movement. As per the example. 
Its also not draggable on Chrome 46 on Linux
I like using babel, but there are certainly some costs - Introduces complexity to your workflow, and deployment. If you already have some build steps, though, it might be cheaper to add babel to the pipeline. - Debugging is definitely a bigger pain when you're using source maps. I usually end up putting my breakpoints in the compiled code, but that's kind of lame. If you're in a Node environment, I'd suggest trying the latest version of Node, which supports arrow functions, class syntax, and template strings. The main ES6 things it's missing are destructuring and default params, but I think it's good enough to justify not using babel. If you're doing webdev, you're probably tooling your JS anyways, so you might as well use babel.
Whenever you start talking about using javascript in a more functional way (particularly when discussing cleaner syntax), I always like to bring up [livescript](http://livescript.net/), a descendant of coffeescript with saner variable scoping and more functional syntax. It has things like auto-curried functions as syntax, immutable `with`, function composition and piping. # normal add = (a, b) -&gt; a + b # curried add = (a, b) --&gt; a + b So your example of reduce would be: const reduce = (fn, arr, acc) --&gt; arr.reduce fn, acc Then you can get something as simple as const sum = reduce (acc, next) -&gt; acc + next Very clean syntax for "expressing the core idea". 
Yeah, my point is that text which would have previously lived in a separate HTML (or even CSS) file is now considered JavaScript, which might inflate the numbers a bit.
This stuff: [Redux best practices](https://medium.com/lexical-labs-engineering/redux-best-practices-64d59775802e) I haven't gotten into the dynamic routing stuff he recommends, but I do all my data fetching in my containers ("smart components"), which are the only places I connect to redux state. Containers don't get styled or return DOM of their own, they just compose views ("dumb components"). Views can always be written as stateless component functions. Views never need to connect to state or call `dispatch`, since they receive everything as props from containers.
I can think of a few reasons. * Poor/limited support for ES6 in some IDEs; visual studio comes to mind * Source maps are more necessary when debugging, which might annoy some people * You'll have a build step or configuration to the building at some point * Some people won't want to learn a new thing or change anything about how they're already doing things * Typescript/Dart is more attractive to a lot of people than Babel/ES6 is Native support only matters (to me) for a few pieces of ES6, like proxies and modules. None of these particularly phase me, but I've always been open to "compiling" my javascript for the same reason I'm open to "compiling" my css, in that it makes it easier to write better code. There's been some interesting advances in the build tool community to make the workflows easier. Things like jspm can make using ES6 as painless as it can possibly get without native browser support.
This looks like the way i'd like to set it up. Higher order components holding stateless components Thanks i'll read thoroughly. 
Thanks, i'll read the redux best practices and started doing the [Handcrafting an isomorphic redux application tutorial](https://medium.com/@bananaoomarang/handcrafting-an-isomorphic-redux-application-with-love-40ada4468af4) 
Android is why Java is popular. 
I had a hard time with full stack redux tutorial as it focuses a lot on unit testing. I still have to wrap my head around many of theses concepts so i'll do [Handcrafting an isomorphic redux app](https://medium.com/@bananaoomarang/handcrafting-an-isomorphic-redux-application-with-love-40ada4468af4) first 
I don't have arguments against ES6 but against Babel specifically with ES6 - I only transpile my client code since I'm on Node latest, and in that case I'm already going to minify it so I just use Google Closure Compiler. The latest version supports ES6 in its entirety as a language input and will handle transpilation to ES5 as a compiler pass. Plus then I get typechecking and documentation built-in since I use advanced optimizations and am annotating my code anyway, and there's full support for Gulp/Grunt/whatever integration so it handles the job of multiple tools just as nicely.
would love to see a video of this talk. A few of the slides were a bit over my head
Don't rely on others. Learn to farm cotton.
https://en.wikipedia.org/wiki/Object-oriented_programming &gt; Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which are data structures that contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods. A distinguishing feature of objects is that an object's procedures can access and often modify the data fields of the object with which they are associated (objects have a notion of "this" or "self").
Gulp and Grunt have so many available plugins that you could probably have them transpile your code, minify it, move it to a different folder, take your kids to school, buy groceries, and diversify your portfolio in under 30 seconds.
Probably because nobody puts node_modules in their .gitignore file...
For #2... class AwesomeClass { definedProperty = 'something'; definedFunction(args) { return 'something'; } }
Modern build tools definitely simplify this. With grunt/gulp/etc you can even get watchers that do the compile-on-save, so the experience is almost like writing pure javascript. jspm takes this ease-of-use to another level, where it's almost opaque.
[here's](http://stackoverflow.com/questions/22528967/es6-class-variable-alternatives#answer-22986568) the link explaining es6 doesnt allow this.
Ahh there's the answer!
Guessing from "pup" it's probably trying to strip out certain powers from "potentially unwanted programs" by preventing them from running certain DOM manipulation functions exposed by Element.prototype. You'll note that if they are whitelisted, the original method is called and if not, it isn't and a "foundPUP" counter is incremented. It helped a lot to beautify the code, but it's still written in a somewhat confusing way.
niether the [babel cli](https://babeljs.io/docs/usage/cli/) (version 6.1.2) or [babelify](https://github.com/babel/babelify) npm modules compile static class properties for me. its why i dont use es6 class syntax for modules, because i cant defined propTypes with the rest of the class.. 
And here's the plugin: http://babeljs.io/docs/plugins/transform-class-properties/
/u/Kamikizzle think you might be missing this plugin
Okay, side note -- if we pretended the property declaration doesn't exist (I know it does, and I know it compiles with the right plugins), why not just do this? They're more or less the same thing. class AwesomeClass { constructor() { this.definedProperty = 'something'; } }
I have my doubts whether true privacy should be a requirement here. I don't think this should be a security oriented feature. We're all consenting adults here after all and not intent on sabotaging each other. 
given the post history here I'm going to guess not D:
I don't see much point in Java like dependency injection because JS is very dynamic. Maybe it's just me...
Also Object.observe-like functionality (since O.o is being dropped from the ES standard). I agree though, proxies will mostly be used by framework and library authors.
See that's another issue. You should use _.has(a, "b.c"), _.get(a, "b.c") will fail is a.b.c is falsey. There was actually a bug in the Chrome extension API related to that. "minimum":0 ended up being treated like no minimum.
Mobservable deserves more attention. I have struggled with flux and in particular implementations like redux, which are either ambiguous or go against much of what I consider good practices.) Mobservable really makes building react apps simple and elegant, imo. 
Might want to use integers.
The first one has bitten me a few times. Some linter doesn't support ES6 yet, or an editor balks at some new ES feature that's in stage 0, or that JSDOC completely explodes if you try to use an "import" statement... I've found workarounds to all of them, but it is additional time and effort.
.replace('node','v8');
but people are adopting ReactJs because of library itself, I don't see people migrating from HTML only just because they can write HTML that way
My team uses it. Initially I didn't really notice the benefits but since our codebase has grown quite large it's been a godsend. I've also learned more about vanilla JS from debugging the code without sourcemaps. If you already have a C# or Java background it will feel natural to code in TypeScript as well.
Well, in my opinion, anything that isn't a superset isn't worth using. 
It still can be - I actually use the 'any' type often if I need that flexibility. Edit: by often I mean 'when I need to write something dirty to see if it will work'. :)
So, let me get this straight. When a user workflow switches from one vertical to another we get a full page refresh, etc, etc? Am I also correct in understanding that when we switch verticals we have to reload (or at least re-parse) all of the SPA framework JavaScript too? In fact, the more verticals we have to create the less SPA-like the app is. Hmm, that seems worrisome. My spider-sense is tingling. Something may be rotten in Denmark.
/r/atwoodslaw 
this makes me want to puke
https://github.com/Hermanya/animatio
&gt;How can I loop through the sponsorMaterialsNeeded array and add the correct property objects to my Sponsors array? You could use 'for' loops for iterating over your data and linear searching the items array with the types from sponsorMaterialsNeeded. You can then use Object.assign to make a clone of each item for each sponsor. Note that [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) does shallow copy of properties (if properties are themselves objects [not the case here] they are not cloned). var items = [{ 'type': 'basicInfo', 'logo': null, 'companyDescription': null }, { 'type': 'keynote', 'speakerName': null, 'speakerTitle': null, 'title': null, 'presentation': null }]; var Sponsors = [{ '_id': 'abc123', 'name': 'Microsoft', 'purchased': [] }]; var sponsorMaterialsNeeded = ['basicInfo', 'foo', 'keynote']; SPONSOR_MATERIAL_NEEDED: for (var sponsorMaterialNeededIndex = 0; sponsorMaterialNeededIndex &lt; sponsorMaterialsNeeded.length; sponsorMaterialNeededIndex++) { var sponsorMaterialNeeded = sponsorMaterialsNeeded[sponsorMaterialNeededIndex]; var item = undefined; ITEM: for (var itemIndex = 0; itemIndex &lt; items.length; itemIndex++) { if (items[itemIndex].type === sponsorMaterialNeeded) { item = items[itemIndex]; break ITEM; } } if (item === undefined) { continue SPONSOR_MATERIAL_NEEDED; } SPONSOR: for (var sponsorIndex = 0; sponsorIndex &lt; Sponsors.length; sponsorIndex++) { var sponsor = Sponsors[sponsorIndex]; var itemClone = Object.assign({}, item); sponsor.purchased.push(itemClone); } } console.log(Sponsors);
There are also several compile-to-js functional languages competing for attention.
DI is one of the best tools for decoupling code, and decoupled code is essential for writing good tests.
LESS, SCSS, Babel, Typescript, and Handlebars are all examples of supersets that I would actually be okay with using. SASS, Stylus, Dart, CoffeeScript, and Jade are all examples of compile-to-use languages that are not supersets of their redirector web languages and that I would not use. Edit: spelling, clarification
Barking good explanation!
Sourcemaps are awesome
I've worked at Google, Apple, Sun, have turned down offers at Facebook and Twitter. The key to getting that first interview is pretty simple -- make yourself stand out. My résumé is very over the top. To quote the Twitter hr person I first spoke to: &gt; I can appreciate your creativity, but not sure if our internal managers will, as they have very limited time to review all the resumes we get, and to be honest, it took me a few minutes to figure out your work history. Had it not been so colorful, I might have just moved on....:) Some people hate it, Others love it, but the point is that it gets noticed, always. Exactly how to stand out is different for everyone, but basically just go shouting from rooftops and you're sure to get noticed :)
Exactly. This isn't a silver bullet. It's just a way of writing applications that works really well for us. If you were to do a new GMail, then you'd probably be better off doing a 1 vertical application. In other cases, having clear separation has provided us with a much easier workflow and less headaches. As far as reparsing the framework goes (because download is not an issue - everything except the vertical-specific CSS and JS is already cached and/or on CDN), it's not nearly as bad. Smaller verticals means smaller everything and when you're not having to deal with a large DOM tree, parsing of large CSS files, exorbitant amount of data and endless amounts of data-binding, it's really fast.
# Encapsulation This is the easier of the two concepts to understand. Encapsulation is a fancy word for "I don't want you to use me in ways I don't like" or "I'm going to limit the ways in which you can use me". class Person { construtor(age) { this.age = age; } } let person = new Person(15); person.age = -33.25; There is no encapsulation there. It's silly to let someone set the person's age to `-33.25`, as this might cause bugs and all kinds of problems if a `person` object is used inappropriately. Encapsulation is a way of ensuring that the object can only be used in a very specific set of ways. Consider this example with private state: class Person { private #age; construtor(age) { #age = age; } incrementAge() { #age++; } getAge() { return #age; } } let person = new Person(15); person.age = -33.25 // ERROR person.incrementAge(); person.getAge(); // 16 I've used encapsulation to enforce the rule that a person's age can only ever be incremented by 1 (maybe your app has a birthday feature, for example). The `age` property is private, hidden away *inside* of the class, and not directly accessible *outside* the class. Consider another real-world example: your house. Your house is an encapsulation of how people go in and out of it. You must enter and leave only through doorways. People can't just randomly enter from any side or direction. The equivalent of a non-encapsulated house would be a house that has no walls, and a roof supported only by a few pillars. # Abstraction This is a bit harder to understand, partly because it means three different things. There's polymorphic abstraction, which allows you to define the general nature of something, while allowing other classes to implement the details of it. This is easier to understand. Then there's general abstraction, which makes code increasingly describe *what* you are trying to do (declarative) and less about *how* you want it to be done (imperative). E.g. fewer and fewer implementation details are exposed as you increase in abstraction level. Then there's simple abstraction. ## Lets focus on simple abstraction In the real world, "abstract" means "represents a general class of ideas, but not a specific idea". For example, a silhouette of a person is an abstract depiction of a person. It could be *any* person, because it represents no person in particular. Meanwhile a photograph of a person is very concrete - it IS one particular person. Consider this: class Circle { constructor(radius) { this.radius = radius; } getRadius() { return this.radius; } } That looks like a concrete class, but it's still an abstraction. Why? because you can do this: let circle1 = new Circle(5); let circle2 = new Circle(10); let circle3 = new Circle(15); That one class was a blueprint that let you make 3 (or any number) of very specific implementations of a Circle. The Circle class itself didn't prescribe a radius, it merely said "I have a radius of some kind". If you did something like this: class Circle { constructor() { this.radius = 5; } getRadius() { return this.radius; } } That's no longer an abstraction. You can never re-use that class to create circles of different radii. You would need to create an infinite number of classes to support all of the possible radii that can exist. It sound very "no shit, sherlock", but it's important to appreciate that simple abstraction (really, functions or classes that take arguments) is a crucial building block of writing software. Functions are the same way: function add(a, b) { return a + b; } add(3, 1); add(65, 8392); It's the abstract idea of addition of two unknown values, rather than a concrete function that only ever adds two specific values. Now, non-abstract classes and functions have their place as well, but can still be described by an abstract idea. This is where polymorphic abstraction comes in. ## Polymorphic abstraction. Unfortnately I can't really give you a JS example of this because I don't know JS all that well, and JS doesn't have traditional polymorphic abstraction features that you find in other languages, so I can't give you a concrete example in JS. I can give you one in PHP though. interface HasColor { public function getColor(); } class BlueCar implements HasColor { public function getColor() { return 'blue'; } } class Barn implements HasColor { public function getColor() { return 'red'; } } As you can see, both the `Barn` and `BlueCar` have the same method: `getColor()`, but return different values from it. This is hugely important. When you work with code, some code needs to know how to use other code, like this: function renderTheColor(HasColor $object) { echo $object-&gt;getColor(); } Notice that we don't care what object we pass in (it could have been a `BlueCar`, or a `Barn`), we only care that it's a `HasColor` object, so that we can guarantee we can use `getColor()` on it. Polymorphic abstraction is nothing more than a way of defining methods that a set of otherwise unrelated classes, should have in common, but allowing them to provide the details of those methods. If simple abstraction is the act of making it possible for one class or function to represent an idea in many different ways, polymorphic abstraction is the act of making it possible for many different classes or functions to represent a common idea in many different ways. ## General abstraction All code you write lives on a spectrum that ranges from "micromanagement" to "big picture". The more you micromanage code and tell it *how* to behave, the more imperative your code is. The more you write code that describes *what* you want done, the more declarative your code is. Consider this series of examples ([borrowed from here](http://latentflip.com/imperative-vs-declarative/)) var numbers = [1,2,3,4,5] var doubled = [] for(var i = 0; i &lt; numbers.length; i++) { var newNumber = numbers[i] * 2 doubled.push(newNumber) } console.log(doubled) //=&gt; [2,4,6,8,10] You're micromanaging the code. You're telling it how to loop over the array, how to get the element to multiply by, and so on. Now consider this: var numbers = [1,2,3,4,5] var doubled = numbers.map(function(n) { return n * 2 }); console.log(doubled) //=&gt; [2,4,6,8,10] You've now made your code more abstract, and more declarative. Instead of micromanaging the looping behavior, and the element lookup behavior, and the array pushing behavior, you're letting `map()` do all of the work. There is LESS instruction. Let's take it further: wrap it in a function: var doubled = doubleEachNumberInTheArray([1,2,3,4,5]); console.log(doubled) //=&gt; [2,4,6,8,10] Now there's even LESS instruction. The code that wants to double each number in the set, doesn't even know or care that `map` is being used, it simply needs to know to call that method and the method takes care of the rest. It has DECLARED that it wants the numbers doubled, but has not micromanaged *how* those numbers are doubled. This "general abstraction" is another way of adding re-usability to your code, while making it more expressive and easier to understand. If I asked you what each of those three code samples does, which one would explain its intent the fastest? The third one, obviously. The function name is literally a sentence describing what it does. It's "abstract" in the sense that it hides away unimportant details from code that shouldn't care about those details. It's "abstract" in the sense that it makes the code more re-usable, because you don't have to type out the imperative steps each time. That particular example also combines simple abstraction, because you can pass in any array of values and it will double them. You can add even more simple abstraction like so: var multiplied = multiplyEachNumberInTheArray([1,2,3,4,5], 3); console.log(multiplied) //=&gt; [3,6,9,12,15] Now it's even more abstract, and more re-usable. You could even take it a step further and create a general function that lets you apply any sort of modification to it: multiply, divide, add, subtract. To do this you'd use composition, but that's a different topic I don't want to get into atm. I know that's a pretty extensive explanation, but hopefully I've shown simple enough examples and used useful wording to convey the ideas.
missing the case where the following CSS also works : a { pointer-events: none } 
&gt; getting rid of the functions and returns there makes the core idea we're trying to express MUCH clearer. How so? less characters doesnt necessarily make it more clear.
Source maps is a must when transpiling Babel, but once you got it set up, you get amazed on the magic it does. On the [HTTP 203 episode Paul Irish and Jake Archibald](https://www.youtube.com/watch?v=pLLLf1QPgoU&amp;index=2&amp;list=PLOU2XLYxmsII_38oWcnQzXs9K9HKBMg-e) talks about transpiling and such. 
The other comments are very insightful, so I just wanted to add a few practical applications. [tj/co](https://github.com/tj/co) is a very practical coroutine utility that you can use to clean up your code (see the example section). Yield is also great because not only will it make the "yielded value" accessible **outside** of the generator, but also **inside**. Meaning you can do things like this with Promises (contrived example): co(function * () { var user = yield User.findOne({ id: 1 }) var posts = yield Post.findAll({ id: user.id }) // do something with posts here }) This is a really nice way of cleaning up nested callbacks, as well as moving error handling outside. Just take a look at what you had to do when working with callbacks: function getPosts(cb) { User.findOne({id: 1}, function (err, user) { if (err) return cb(err) Post.findAll({ id: user.id }, function (err, posts) { if (err) return cb(err) // do something with posts here }) }) } If you want to read more: https://medium.com/@tjholowaychuk/callbacks-vs-coroutines-174f1fe66127
&gt; It is hard to choice the flux library &gt; There are too many flux library. Checkmate, welp, guess I go back to jquery then.
I would start by breaking the Sponsors down into a constructor function (class) then creating one for each sponsor. You can then add a methods to the sponsor that will add the items to the purchased property. Later you can make this more defensive so it won't allow duplicate items. https://jsfiddle.net/kunykydm/ 
Sass, Stylus, and Jade don't compile to JS. Since Dart has its own VM (2 VMs and an AOT compiler, actually), it's not a to-JS language. Just like Java or C aren't to-JS languages. You can compile these to JS, but that's something you only have to do if you target browsers.
Unless you're writing JS that is triggered by the anchor tag, this CSS method is the best
Can you explain what you mean by server side rendering? Serving up static HTML?
When you run code client sided, you have no control. The user can tweak/edit the code to their wills. Safety is a problem. The pro side is that there is no CPU overhead, that's all on the clients side. Server sided has the advantage that code is under your control, you just send the output. Another pro is that you can connect to anything on your server or databases on the server. The downside is the CPU overhead, you need more crunching power. 
&gt; When you run code client sided, you have no control. The user can tweak/edit the code to their wills. Safety is a problem. This is an irrelevant argument. Any user can do whatever they want on _their_ system, so what? I can turn reddit upside down for kicks, delete all the images, it doesn't matter as it only affects me. Having client side vs server side rendering doesn't make a difference here. As far as safety, that doesn't apply either. Your _server_ should be responsible for protecting against XSS, XSRF, etc attacks.
Server-side rendering is basically required for SEO. Client-side rendering makes page loads "instant", potentially even future visits as you can cache _all_ assets save data. Everything else is implementation specific. Using something like React, you can even have the exact same code base running both a client and server, which is pretty much the "holy grail" as far as this particular discussion goes.
&gt; Hmm. None of the author's demo code worked. In that case you're not using a compatible browser. All of this stuff is very new, so not all browsers support it yet. It works for me using Chrome, though.
I'm using server-side rendering not only for SEO, but also for providing clients a faster load time - they don't need javascript as long as it's a plain old simple web page with pure html/css, but it's super cool for the developers to actually build the page with client-side javascript and render it on server. No need for react or fancy frameworks, just https://github.com/kapouer/express-dom to run the page through a real web browser and voilà. Though this one needs cache to run smoothly - page load could be impacted. I'm using a smart proxy that updates its cache semi-automatically, but that's another matter.
Don't rely on others. Be a sheep.
Since you are setting a timeout and not an interval, there is no need to clear the timeout, unless you want to prevent it from happening. One thing I would suggest though is to define your function for your timeout outside of the loop, unless the function has to be unique for every iteration of the loop.
If you aren't interested in potentially clearing the timeout, you don't need the timeoutID. If you need all those timeoutIDs, you have to put them into an array. `clearTimeout` only unschedules that one task with that particular ID. So, if you want to skip a dozen previously scheduled tasks, you have to clear them all separately using their respective IDs.
Unfortunately, I think Web Components are fundamentally flawed, on a conceptual basis. I don't think it's a concept that can ever be very useful. You've already gotten a lot of feedback about how they're not ready yet, so I won't touch on that, but the concept itself is worth examining. Even if we become able to use Web Components without the precarious polyfills, it doesn't solve the most crucial problems of building an app. They also have some very serious limitations: they must be stateless, and they must be minimal. You shouldn't, for example, use React *inside* a Web Component. I believe once Web Components land and people start building and sharing them, they will end up being minuscule elements that are better off being implemented natively in whatever framework you are using to build your app, such as React. Additionally, without a native concept of virtual DOM, complex DOM manipulation in Web Components is out because it will either require significant custom code (to be replicated in *every component*) or be unacceptably slow.
I don't understand how people can't see the power of generators! been using them for a while now... you can easily iterate complex object or do recursive functions like this example I've just made http://www.es6fiddle.net/igw8bfcl/ You can use generators in combination with spread operator ([...example]) so you can do for example: `Promise.all([...generatePromises(map)]).then(/* more logic */)`
So like a "FunctionalScript" (javascript with functional features; as TypeScript is javascript with types.) Maybe what we need is FunctionalTypeScript. :)
Yes and one that is filled with content. I have around 50 Midwest headhunters in the requested connections. They are all just from local headhunting companies and want to offer me jobs in the area at companies I have no interest in. I'm sure if I was in a big market I would get looks from actual internal recruiters.
I like this idea! My resume is somewhat boring, but easy to read and visually broken up in a way that makes sense. But this sounds like a good way to do something different to get a second look. Thanks for your input!
Anytime! Yeah, customize it as you like!
It's saying that VEGAS, the name of the plugin, can be applied to any element which you wish to use as a container for the slides within your gallery. So inside the $() bit, you'd specify the CSS-style selector of the element you want to have the backgrounds rotate within, wether it's 'body', '.myexampledivclass', or '#myexampledivID', etc. In the example they show, the background for the page's &amp;lt;body&amp;gt; element, as well as the background for the element with an ID of "example" would be targeted. The code should go either within a &amp;lt;script&amp;gt; tag on the page, or in an external file within the site's file structure, with the extension ".js", which would then get included via &amp;lt;script src="/path/to/the/file.js"&gt; Be sure to have your console open at runtime to be alerted of any errors. Cmd/Ctrl + Opt/Alt + J Also, be sure you've followed the plugin installation steps properly. It could be that you missed an installation step or requirement. Since this plugin involved file paths in its invocation, it could also be that the paths to the images you want to use aren't quite right. Hope this helps.
V8 came well before node, but I would argue node was the more important technology for JS to grow.
That's a little side project of mine. I'm running Chrome DevTools Timeline panel as a standalone Electron app and feeding it with network traffic from the whole system. Think about it as a free Charles Proxy alternative. I'm planning to release it on github soon. When it's out I'll definitely post about it in r/webdev (and maybe x-post it to r/javascript), but if you don't want to miss it you can follow me on github/twitter (@kdzwinel).
IMHO, but also my sense of the general HO, is that shorter syntax with fewer forced block-level hints (brackets) is much easier to read at a glance: your eye only has to take in a single line of instructions rather than trying to extract meaning and structure from a lot of extra "punctuation" as it were. Forget even the function/return words (){(){}} your brain has to parse out, for instance: function (a) { return function(b){ return a+ b; }; } Whereas this sort of lays out exactly what's happening directly: a =&gt; b =&gt; a+b Once you translate =&gt; into "given the args on the left side, return a function that returns this result" and realize that you can nest that logic right to left, at least to me, that expresses the core concept of a higher-order function in a really clean, readable way.
Lego has a decent database of bricks on their site. Automatically building a shopping cart with the required bricks would be awesome. 
Just try it. http://jsfiddle.net/bznmhg7h/ ES6 version: http://jsfiddle.net/qzoLup8k/
Basically it's an alternative to UglifyJS which is used in Webpack. Closure Compiler requires Java, but in return it gives you more advanced compilation and dead-code removal. I'd like to have some feedback based on its usage and well if you used it and feel like there's something missed or can be improved, feel free to prepare a pull request.
I've argued elsewhere that even "which allows us to “inherit” the scope we’re in if needed." while more accurate than "it's like .bind(this)" is still too much thought put into something that's meant to save us from having to think too much. Do we generally talk about code inside a switch statement "inheriting the scope we're in if needed"? No. We just use "this" in the context of the code we're writing without worrying about the switch block itself ever monkeying around with the meaning of "this" at runtime. Same goes for Arrow functions. They allow us to _stop_ worrying about the meaning of "this" changing on us within the body of the function. So when we instead think "ok, now what will "this" mean in the body of this arrow function? oh, it will 'inherit' the meaning of 'this' from the outer scope, ok" we're still thinking too much. We shouldn't have to put any extra thought into it at all. 
How's this (under 10 lines of js): http://codepen.io/anon/pen/MaZKdV ?
Yep, thanks!
That's actually a great idea.
This is bad information. You shouldn't be exposing anything that allows the user to do unsafe things. If people want to mess around with the HTML/js/css etc... within their browser, then that's fine. As the developer, you need to make sure that you are not passing anything to the user that could compromise your server. Use the server to perform validation, db queries, sensitive processing etc... and you'll be fine. If you think client side rendering is inherently unsafe, then you are doing it wrong. 
Nope. the uglify module used by gulp in the build process does not fully support all es6 features yet. so you can compile your es6 to es5 just fine with babelify, but if you try to minify it using uglify, it breaks. https://github.com/mishoo/UglifyJS2/issues/448
Right? its literally the only negative experience i have using es6. although as mentioned above, there's a babel plugin to compensate. hopefully its passed in es7.
just curious: how can you feed it with network traffic from the system? I mean: how can you "intercept" http(s) requests inside Electron's DevTools? thanks
This is pretty neat, nice work.
Thanks!
Don't know what I would use this for, but it's fucking awesome.
I like the fact that you send the static file after the rendering middleware. THe way it's done in http://github.com/kapouer/express-dom is more convoluted.
I was encoding 'winter is coming', evil downvoters
You said Finder was a piece of shit, without explaining why. The reason I prefer Finder is because it got tabs, more/better views, way way better preview, and there is no awful ribbon menu.
Thats a fun business / novelty gift idea. Upload a picture, convert to lego, source bricks needed, sell bricks in lego set that user gets to build of their image. I would pay money to take a picture of my nephews, legofy it and send them the set to build it.
So are you re-requesting them on the frontend or does the remote debugging protocol just 'insert a timeline item'? Thanks!
It's a wonderful idea in principle. I think the only potential problem is that Lego don't have a wide enough range of colours for their bricks. [Counting the 1x1 bricks](http://shop.lego.com/en-GB/Pick-A-Brick-ByTheme), I can only seem to find ~17 varying colours.
Nothing gets re-requested, proxy acts as a middleman that collects information about passing traffic and pushes that info to the Timeline panel.
Wow, that's a pretty cool project. Probably not something I'd use often but I'd be happy to have it when the need comes.
This is atrocious. Your logic is not even close to being understandable. Break things down into smaller functions, and name them according to what they do. Then it will be more clear what you're doing. Indent consistently. Anything less is just being a jackass. Javascript should be written in `camelCase`, not `using_underscores`. `pause` is a binary state. Use booleans, not integers. These days, it is expected to use `!==` and `===`, rather than their buggier counterparts. Always put spaces around operators. Please, for the love of all things good, install ESLint and start following some code conventions. And finally, if you have to write six paragraphs explaining what your code does, you have failed. Code should be self-documenting.
&gt;more/better views? Nope. &gt;way way better preview? Nope. &gt;No awful ribbon menu Finder has its own awful menus. 
[I solved the lag problem by drawing the element directly onto the mouse cursor.](http://codepen.io/anon/pen/GpPgqa?editors=001) Unfortunately it now has a few new issues like the element not obeying page zoom and being limited to 128x128 pixels. :P
Yeah, because the =&gt; syntax expresses all those things already, leaving just WHAT you are doing (and how it differs from all the other things you could do) instead of the boilerplate of how (which is repeated over and over and over so much that your code becomes littered with many levels of nested functions and returns, all of which dominate the page when it's the specifics of what you're doing that should be dominating the page). Sure, it requires learning that =&gt; means that, but we all learned what function(){return} meant at some point...
I don't know. I do know that I ordered like 5 shirts there about a year ago but after confirmation email never heard anything back. Tried to contact the guy behind it multiple time but no luck.
I don't think this is for efficiency, this is so that bots that don't have javascript (i.e., almost all of them) can properly index your website. I think this is a competitor to http://prerender.io
Huh, I guess that's pretty cool then, thank you - I wasn't exactly sure what problem this solved (that hadn't been solved already).
"Well, it's helpful at least to know that it's supposed to be this difficult" (from a comment earlier) It's not. It can be, and there can be valid reasons for it to be, but no. it does not have to be that complicated. 
I was giving examples of languages that were and we not supersets of their respective web languages. Jade is not a superset of HTML. SASS and Stylus are not supersets of CSS. You are right about Dart, I was just looking for another to-JS language that wasn't a CS derivative nor a superset. Edit: I edited my other comment for clarification
Clever, though there are some rendering issues, like you said. Still, that's definitely a pretty cool solution.
Lol! Yeah, even easier... at least with respect to html and css: http://codepen.io/anon/pen/RWEobP
In that case I would be grateful for any hints you can provide for getting up-to-speed on these tools.
Something like Selenium or PhantomJS is the way to go. &gt; Do front-end developers write test for these very often? Most likely not often enough...
Average colour (mix-blend-mode: overlay). I don't think pictures would look too great with the limited range of colours that LEGO supply. Although LEGO being LEGO, I'm sure it'd be awesome too.
Might need to get into dithering at that point.
&gt; works really well for us. Except, the more verticals you create, the more associated page refreshes, the less it is a SPA and the more it is just a very JS heavy (read slow) site. &gt; because download is not an issue - everything except the vertical-specific CSS and JS is already cached and/or on CDN Totally agree. However, this is not at all SPA specific. &gt; As far as re-parsing the framework goes, it's not nearly as bad. Well, re-parsing all that JavaScript on my iPhone 6 Plus is noticeably slower than a traditional non-SPA that was built with progressive enhancement. Every browser on the planet can parse and display HTML with lightning speed. This just isn't so with JavaScript. It's 10-100x slower on mobile than desktop PC's. Manipulating the DOM slows it down further. In summary, for SPA's (or SPA hybrids) there are lots and lots of issues that need to be resolved. 
I was frustrated by this at first also. Then I realized that all I need is NPM. Most packages that are on bower are also on NPM. If a package is not on NPM I would encourage the author to publish it, publish it myself, or look for a better package. When you install a package with NPM, there is often a 'dist' folder that contains the final, packaged version of the library. The packaged CSS file will usually be in there also. Here are some examples: react: $ ls node_modules/react/dist react-with-addons.js react.js react-with-addons.min.js react.min.js bootstrap: $ ls node_modules/bootstrap/dist css fonts js $ ls node_modules/bootstrap/dist/css bootstrap-theme.css bootstrap-theme.min.css bootstrap.css.map bootstrap-theme.css.map bootstrap.css bootstrap.min.css 
That won't get you any cotton.
Wouldn't really work at that resolution, though.
What resolution? It's variable.
I dunno man, to me its less obscure to do this, mostly because it only requires knowledge of one method (map) to understand, and it doesn't "hide" anything through partial application. I get these are contrived examples, but even with real-world examples *any other way* seems less obscure. getThings = (things) =&gt; things.map(o =&gt; o.thing); getThings([{thing:1},{thing:2}]);// -&gt; [1,2]
ES6 Solution: function o() { if (new.target === undefined) { return new o() } } ES'16/ES'17 Solution: class o { constructor () { } call constructor () { return new o() } }
Big posters you walk up to.
Seems like if the constructor was called with an arbitrary list of arguments you have to deconstruct the call a bit more: function o() { if (!(this instanceof o)) { var obj = Object.create(o.prototype); var objResult = o.apply(obj, arguments); return (typeof objResult === 'object' &amp;&amp; objResult) || obj; } // Normal constructor stuff this.hello = 'hi'; } This doesn't even consider that passing arguments outside a function call is [bad mojo] (https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments) so you would want to iterate with a for-loop and build an args array first. While the intention is good (avoid unexpected behavior because a function constructor was called incorrectly), I think it's probably better for the developer to throw an exception and let them know they messed up: function o() { if (!(this instanceof o)) { throw new Error('Function o should be called with the new operator'); } // Normal constructor stuff this.hello = 'hi'; }
Based upon receiving offers in the past from IBM and Lockheed for full-fledged software engineering positions (one requiring TS clearance). Both offers and benefits were on the negative end of humorous compared to what many software companies are offering now.
Yeah, I think there's a balance, and especially with arrow functions, unless you're obsessed with the pointfree style, that way is still pretty clear too: if I saw that code in code review in isolation, I don't think I'd have anything complain about. But I guess I feel like once you're getting into composing a big chain of operations, it's still nice and descriptive to "pre-bake" common operations and end up with a single-argument chain that describes everything you'd like to happen. Even in your example, you're creating this extra "things" argument that's basically just a throwaway name. Why does that version of map need to know that you happened to call an array "things?" Map takes any iterable without caring what it's called, and applies a function to it. All it needs to know is that the function to apply is one that "wants" to extract a property, and all THAT function needs to know is which property. If you put your function description in the context of a larger program, and skimmed over it, "things" might jump out as something extra to have to read and digest until getting to the point where you realize it's arbitrary and not important to the operation in question. I guess it seems natural for me that if I say _.pluck('user') then I should get back a function that will pluck that prop from any collection passed to it. And that means I can chain a whole bunch of operations together so that I can pass data through and have a sort of description of what I want to happen without any extra repetition or throwaway arguments. 
edit: [same content, better message](https://www.reddit.com/r/javascript/comments/3sk7kx/javascripts_new_operator_explained/cwy0ry3)
Most JSON APIs handle schema validation thru custom code. The flexibility of JSON makes it hard to give it a ridgid schema like XML
Thanks for the feedback! I'm interested to hear more about how you build this app. What is your overall architecture? How do you manage state? Are most of your components "dumb" (receive state/instruction from their parent) or "smart" (fetch data from services, transition, etc. themselves)? React itself isn't meant to be a page state management solution. You should use something else for that. Flux seems to be the way to go in a React project, and you can use Flux without React. I'm trying to use redux and polymer in a proof of concept, but I haven't gotten far due to lack of time. Which Web Components implementation do you use? Why did you choose it? Why do you like/dislike it? Did you write your components from scratch or did you extend/customize an existing library like polymer elements? If the latter, is it difficult to repurpose the component library to suit your needs? At least one commenter suggested it is painful with polymer paper elements, for example.
Awesome! I also made something similar to this, using HTML5 canvas - you specify a block size, then a loop looks at each block of the image you load into the canvas, gives you an average color for that block, then tints a tile above it (I used it for making a mosaic out of twitter avatars). Cool to see the other ways of approaching it.
You should be able to pipe the es5 output to the uglifier plugin
- After authentication on the server send back a jsonwebtoken to your app with the payload you want - Include that token in the header of subsequent requests You can learn more here : http://jwt.io/introduction/
There was a really similar script in /r/python recently- any correlation?
&lt;3
At the very top of he's readme, its says.
hmm. I've never felt like keywords and punctuation were an obstacle, and I still dont now that I have arrow syntax available
This... this my friend is amazing!! Thanks!!
I don't understand why you think you can't use `hasOwnProperty()` or why a switch statement makes anything better. It's basically the same amount of code: if(obj.hasOwnProperty('foo')) { ... } else if(obj.hasOwnProperty('bar')) { ... } else if(obj.hasOwnProperty('baz')) { ... } But I suspect this is an XY problem — there's probably a much better way to do whatever it is that you're trying to do. For example, you could create an object that maps property names to callback functions, and then just iterate over that. Describe the actual thing you're trying to solve, not how you think you need to solve it. 
Can i see what it looks like, im interested in how you strike a balance 
This is awesome. I'm trying to npm install it, and it's tripping up at the postinstall where it is trying to do a gulp build. It seems that npm install doesn't install devdependencies by default so that doesn't work. Currently doing an npm install --dev and it's making my MBP hot, so you might want to republish without that. 
Out of curiosity, what do you want to happen when an object has both A and B properties?
This is the right way to go about it, but it's important to note that indexOf returns the index of the property passed in as an argument. If the property does not exist in the array, it returns "-1". So you would do something like: var arrayOfProperties = Object.keys(myArray); if (arrayOfProperties.indexOf('test') &gt; -1) { console.log('This property exists in the object'); }
I made this really quickly in jquery. it isn't bulletproof but gives you the general idea. http://codepen.io/anon/pen/KdbaGw
&gt;'jsonpCallback': 'cb' Looks like cb is not a function.
It might be worth publishing a transpiled es5 version to a dist folder for ease of consumption.
Right, but what if hasPropertyA is true and hasPropertyB is true? The OP code seems to suggest that if it has an A property, it will do the A thing, otherwise if it has a B property, do the B thing. Additional properties won't affect this logic, and having both A and B is the same as just having A.. Just wondering if this was intentional :)
You aren't defining the function 'cb' anywhere so.. When you use 'jsonp', it will call a function with the data. You have to implement that function.
If that is the issue, why does it sometimes work?
In an ideal world, you would spend a little time building something basic with each, and compare your experiences. If you could build a small widget that was complicated enough to require lots of nesting, a bit of state and decent test coverage, this would let you bottom out the problems to each approach (particularly the question about testability - that should actually be one of the most important of all). In practice, however, I tend to think React would be a wiser investment. Web components haven't had an awful lot of adoption, and that may well mean something - empirically, it tells us that React is doing a better job of solving our problems as an industry than the Web Components offering, at least today. Indirectly, it also tells us that support, recruitment, tooling and documentation is going to be much richer in a React world. A bigger issue is standardization. React has a stable API, whereas Web Components are still being standardized. There is _no way_ that you should build your entire technical estate on the back of a technology that's still under review, of an API that's still in flux. You would quite literally start your project with technical debt. Fundamentally, Web Components were not built for your problem, to break up an application into separate document fragments with their own viewmodels and templates. They were built to create small, stateless custom elements, like special UI elements. React, on the other hand, was built for your _exact_ use case. You know what it offers. Prior art around testing. A larger ecosystem of open source code. API stability. Server-side rendering (under Node). A mirror API for writing native browser apps. Give both technologies a spin, but timebox your experiences and make sure several developers try out each one - not just each platform's respective advocates. Speak openly about the pain points to both approaches and inform your decision by actually writing code in each approach. And have a contingency plan to turn backwards if you discover you've made the wrong choice.
I've been using them for many years, and they have many different implementations across many different languages. The biggest issue i have seen with the libraries I have seen are that they usually have very poor error messages, which makes it tricky to put into user facing code without a lot of boilerplate code to generate nice messages. The other thing is that because of it's recursive nature, libraries tend to be quite complex, and you will probably run into some speed issues somewhere along the line when doing stuff like data import with them. as for the spec itself, it's not official yet, but it's pretty safe to use (i think).
"Think like a freak" was an interesting read even if it wasn't all that applicable to real life.
Just letting you know, the jsfiddle you have doesn't work cause it's missing the google maps API. On the other hand, looks like the GMaps JS API now requires loading with the API Key from them in the URL; so meh, couldn't be arsed bothering to get one. As for the code, it looks like you need to able to sign the request with a known parameter list, including values, so you're best off explicitly making a function called "cb" - and jquery will call that when it's finished processing the response from the server as necessary.
Yes. Prefer unit tests over full on Selenium style tests. Selenium tests are slow and can have problems false failures. If you're using React you can use Jasmine + react test utils (shallow render is your friend). It's pretty easy to write unit tests this way. Jest is slow. You can do image diffing to test css, but it can be difficult to get right.
I don't know, [rtfm](http://api.jquery.com/jquery.ajax/)
Actually UglifyJS is as efficient as GCC. But still GCC does a better job. Look at this example Webpack output vs GCC output https://gist.github.com/roman01la/2bd43f55a94e726bdef7
JSON Schema is used in most of the common API description formats: * API Blueprint [spec](https://github.com/apiaryio/api-blueprint/blob/master/API%20Blueprint%20Specification.md#def-schema-section) and [example](https://github.com/apiaryio/api-blueprint/blob/master/examples/14.%20JSON%20Schema.md) * [Swagger](https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#data-types) * [RAML](https://github.com/raml-org/raml-spec/blob/master/raml-0.8.md#schema) Pretty much everyone is using Draft 4 of JSON Schema and there is a ton of tooling available around the format.
Thanks. I'm having a hard time finding any books on it which makes me wonder if anyone is actually using it.
Thanks for the help!
This doesn't really seem like a very useful interpretation of Haskell in JavaScript. A lot of the functions have definitions that are different to their Haskell versions. For example zip isn't a binary function in your interpretation, it's a unary function. Compose composes functions together in the wrong order. Head takes X number of arguments and returns the first one, which means I can't compose it with any function that returns a list, instead I have to get the list returned and then spread it into head.
&gt; ...according to JavaScript ES6 standards. and then I see this: `var ƒ = module.exports = {` You may as well go full ES6: `export default let ƒ = { ... } `
This is how you *truncate* a number in ES5. For positive numbers, it's like floor. For negative numbers it's like ceil. (It's like casting a float to int in C.) &gt; 1.3 | 0 1 &gt; -1.3 | 0 -1 &gt; Math.floor(1.3) 1 &gt; Math.floor(-1.3) -2 ES6 has Math.trunc for this: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
What's wrong with using a persistent session cookie?
Try https://www.ludei.com/cocoonjs/
This is cool, short and sweet. I probably would had never thought about doing this. Probably because it seems confusing to me. Is anyone using this patten in their code, code that they share with others? My main issue is that not all function calls return an instance of the constructor so there is no real way to understand that without prior knowledge while reviewing the code. Well, unless you come up with some sort of hungarian notation describing that a function call would return an instance of itself, but by the time you get to that point, using `new` would be a better choice. 
Not sure if this is relevant, but [this blog post is about benchmarks for some JSON Schema validators](https://www.pandastrike.com/posts/20150511-jsck-benchmarks).
Nice mini VM, good start. Deitel &amp; Deitel have (in some of their books) a walkthrough of a console-style VM with a compiler &amp; optimizer, and I think a debugger (didn't completely finish, I was just screwing around). It can do complex math (after using Reverse Polish Notation to compile it), has variable storage and manipulation, memory addressing, more I'm forgetting. There's also one in their Java book I had, but..blah - the JS version was way easier.
Try phonegap/cordova too
Those 3 lines above aren't returning anything. readFileSync returns the contents of the file, which is already a string and which is only a word if the file only contains a single word. 'readline-sync' isn't used. Is there a reason why you didn't include your actual code?
I'd point you to /r/gamedev, since your problem is not specific to JavaScript. Fast projectiles are a solved problem in game development.
I didn't know about that sub! Thanks!
I used it at my old job last year. It does what it needs to do; it doesn't need new features or anything like that.
I was trying to focus on the part that wasn't working. The map is working perfectly in my app so that is why I left it out. 
Another more robust solution would be to use `module-deps` which is how `browserify` resolves dependencies used by a file: https://www.npmjs.com/package/module-deps
I didn't include the full code because I didn't think it was necessary because I was just asking for the syntax format for these specific lines which are the beginning of my code.
I agree. However, I couldn't paste my code into reddit. I tried to, but the formating got jacked up. I'm going to making a working version because I'm no longer receiving the error message, but it still isn't working properly.
This solved my problem. Thank you very much
Your question wasn't syntax related and the syntax of those 3 lines was fine. You would have gotten a syntax error otherwise. Including the full source code isn't required nor desirable. However, you should include a minimal test case which illustrates the problem. After running: var fs = require('fs'); var text = fs.readFileSync('words.txt'); "text" contains the contents of the "words.txt" file. There is no problem there nor is there anything which contains single letters.
&gt; Errr, this is exactly how it works by default in JS class Foo{} Foo(); `Uncaught TypeError: Class constructors cannot be invoked without 'new'` Callable constructors add that crap back into the language. &gt; new Number('3.14') Number {[[PrimitiveValue]]: 3.14} &gt; Number('3.14') 3.14 Pulling his kind of stunts makes for a truly terrible API. This is extremely undesirable and even documenting it is massive pain in the rear.
I viewed the source before commenting the chess logic is minified which was the point i was trying to make https://github.com/MicrosoftEdge/Demos/blob/master/chess/scripts/libs/chess.min.js
Have you profiled your code? What's the bottleneck? The canvas (presumably?) draws? Or the code that's calculating the triangles?
doesnt work for me in chrome/win10
... and then the player just switches a thing on his local client and has full vision arround him when he shouldnt ! Besides its the calculation of the vision cone that cause the performance drop, not the sending. And since the server already did the work, the client doesnt have to do it again.
&gt; Besides its the calculation of the vision cone that cause the performance drop, not the sending. And since the server already did the work, the client doesnt have to do it again. That's _exactly_ the point -- offload this onto the client. You're sacrificing performance for no real reason. 99%+ of people can't / wouldn't hack the client code, and even if they do -- so what? They're just making the game less fun for themselves and will probably quit sooner.
As people here say it doesn't work, there must be somebody confirming it works (chromium, old ubuntu laptop). It's just not ready for anything, it just adds a 3D model of a face over your face using very very approximate estimations of its orientation and dimension.
If the server and client both had a copy (or a reasonable part of) the model, the positions or vertices could be pre-indexed, then merely the state needs to be communicated during progress. 
&gt; less fun for themselves and everyone else playing. I also need to know what a player can and cannot see on the server as vision is the most important aspect of the game. But the first reason I decided to do that was to be as easy as possible on the client device - it should run decently even on non high-end mobile devices. Besides if my desktop server struggle with it, im not sure why it should be better on the clients.
Because your server is calculating it for many users?
Python: thing = Stuff() thing = stuff() shiny_things = map(ShinyThing, params) Do you see 'new' here? No. Because it is not needed, it is redundant, annoying noise.
We aren't talking about making `new` optional or getting rid of it. We are 20 years too late for this. It's about being able to call a constructor without `new` and having that act like a static method. `Date` and those silly wrappers like `Number` are like that, for example. Using static methods for static methods is a lot more obvious. For factories, something like Dart's factory constructors, which do not affect the call-sites, are much nicer. https://dartpad.dartlang.org/6938b33d4dd49e2be61f (The leading underscore makes identifiers library-private.) From my point of view, everything about the proposed callable constructors is an anti-pattern.
not many, should be about 8 players max
Sadly `export default let` is a syntax error - you can only have an expression as a default export.
Would love to see an interactive demo with more examples. Brick laid one by one or line by line, or even same colour by colour.
Dude, I don't have issue with a code. I can't find a place to even begin with the javascript for a combobox. Seriously, every time I try to make one going off the internet's tutorials, I get code for an outdated version or something, because nothing has worked. I do have the html for the same box, if you're able to transfer it to javascript.
Like spalsh screen for web apps 
https://gist.github.com/sybarite/8ba77b9790fd036fde6f Here his sample code just reformatted for anyone who is willing to help him out. Please be kind to him, you can tell him his faults without using wonderfully expressive works like "puke" and "atrocious".
https://gist.github.com/sybarite/8ba77b9790fd036fde6f Here his sample code just reformatted for anyone who is willing to help him out. Please be kind to him, you can tell him his faults without using wonderfully expressive works like "puke" and "atrocious".
I run a free meetup in Wellington, where we learn Ember 2.x from scratch. You can find here our tutorial where you can build an app and learn about the most important parts of Ember.js 2.x: http://yoember.com/
It looks like the formatting changes during posting. If you need it posted another way please let me know. Thanks 
No. Seriously, just don't. You're "closed env, I already have access" is no excuse even if you could make this possible. Not sure why you are even worried about javascript at this point, if you're looking to build something to show your boss, create a small server that pulls data from the database and generates a static page. 
Didn't work for me on OSX + Chrome 46, just got a wireframe
I'll look into it, looks like a cool project! (your username. Wtf.)
Sorry, but where did I say anything about MySQL? And why would you presume to know how to solve anyone's problem with practically zero knowledge of it? Tech like elastic search may be great for specific scenarios, but on a highly transactional database with millions of customer contact records that are in a constant state of flux they're not really practical (at least not at a reasonable cost). Enterprise level database systems are most definitely meant to handle these types of queries (with the right indexing strategies implemented, of course). Executing the queries and having results returned promptly is not the problem, managing/maintaining a massive stored proc (or set of them) to handle all the variations in query logic IS the problem - and that's what I have found toolsets like LINQ/EF/knex to be good at solving, because I can have the statements built in a language better suited to the dynamic nature of the problem. In enterprise solutions it's also not generally possible to re-architect the infrastructure on a whim - these solutions can run hundreds of thousands of dollars when the hardware and man hours for implementation are accounted for, whereas leveraging a simple query builder for a new web API only required a few hours of my time to learn it. Finally, you also seem to discount the ability to be database agnostic, but I think you're missing the usage case there. You likely won't find end-users swapping out their databases regularly, but you will find software authors who use knex as middleware that don't want to force database choices on their end users, and knex enables them to support multiple platforms. [Bookshelf.js](http://bookshelfjs.org) for example, which uses knex as the underlying query engine.
Javascript would be the one language where I wouldn't have to deploy or touch any of the already existing servers. There is absolutely no chance of creating a server, or install any language on other servers.
Why not lowercase once? str = str.toLowerCase() on the first line Also please don't use a boolean expression to return a boolean just return the expression. function pal(str) { str = str.toLowerCase(); return str === str.split('').reverse().join(''); } Has less chance of going over a company column limit for code. You could also argue == is ok to use here as you know both values are strings. Not sure if that has any effect on speed but thats the only reason i mentioned it.
Hey, thanks for your input! I like your code. It looks like you could also do function o(arg1, arg2) {if (!(this instanceof o)) return new o(arg1,arg2);} if you want a one-liner
Hope you'll find it useful, ready to hear some critics :)
This method has the potential to get really slow if the object is big. First you're creating a huge array out of the object keys, then you loop through the newly created array looking for a property — using indexOf on an array triggers a loop. Functionally, though, this seems like it would work fine. Just be wary of the size of the object.
not properly, if you click the wheel you have mouse locked to scroll, still need to move mouse to scroll
The require thing works. Also, the while loop you edited does not let the user keep trying again, even though it says "you now have 2 guesses". Is this something on my end?
XPost Subreddit Link: /r/reactjs Original post: https://www.reddit.com/r/reactjs/comments/3sa3yy/awesome_react_native_reddit_reader/
Nope. You place the cursor in the direction you want the page to scroll and at a distance from the initial click that gives you a scroll speed you want and then you don't have to touch the mouse.
What is exactly this `drawText` method?
I'm assuming there is something wrong with this var guesses = 3; while (guesses &gt; 0) { if (response === pickaword) { console.log("Yes!! You win!!!"); break; } else { guesses--; if (guesses &gt; 0) { console.log("Nope... try again. You have " + guesses + " guesse(s) remaining."); } else { console.log("Sorry... you've run out of guesses."); } } } 
You don't need to touch any of the existing servers. If it's just a proof of concept, all you have to do is install a web server on your own local computer. As stated, Node.js is a good choice if you want to use JavaScript on the server-side as well. Another option that is easy for beginners is installing a PHP server using XAMPP. I don't know how your database is set up but is there a way to get JSON from the database? Then you can query the JSON with JavaScript. 
I already heard it was not that fast here : https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas But if your text doesn't change much (not every frame), you can use their 1st tip. It is ridiculously fast :-) 
Yeah, I might just do this.. I was hoping to get a real connection working to find the real time spent on getting it done. Getting a full stack will be a nightmare in bureaucracy, and it needs to be backed up with some nice working UI. Thanks for the idea, I may just extract the main tables into text files and use that to show some "real" data.
I could possibly install a VM on the desktop, but the VM would not be allowed in the network. That's the problem.
A lot of times I have come back to curl + text search tool after wandering off to Webdriver, phantomjs or Scrapy. Might not work in all the cases but worth a try.
You don't need a VM to run a node.js server on an iMac. Or nginx. Or Apache httpd, or Tomcat. The list goes on. All you're looking to create here is a PoC. You can do it entirely from within a normal user account unless you need to run IIS, in which case you'll need a VM since it's Windows-only.
A web browser uses http or https to communicate. The only database I know of that will take queries over http or https is couchDB. Javascript (in the browser) cannot directly communicated with Sybase, because Sybase probably does not support http or https. That said, I recommend you learn all you can about [Node.js](https://nodejs.org/). With it, there is probably a module for communicating with a Sybase database.
Oh, okay. I was trying to add the feature of giving the user more tries but I'm just not going to bother. Thanks for trying to help me!
I agree! Almost each platform has a default browser. So, it don't require from you to install smth!
There is only fillText and strokeText: https://html.spec.whatwg.org/multipage/scripting.html#drawing-text-to-the-bitmap https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D#Drawing_text You are also using fillText: https://github.com/zyklus/CanvasRenderer/blob/master/source/text-renderer.js#L62
It would have to be: ``` let ƒ = { ... }; export {ƒ as default}; ```
Thanks to you both for your responses. I'm glad you could make something of the formatted code. I will look over the "else" commands and try to clean it up a little. I'll hopefully post back on monday.
These are all equivalent: require('..') require('../') require('../index.js') require('../index')
You see the textured face though right and not just the green lines? It's working for me on OS X chrome.
There is no `drawText` for &lt;canvas&gt; ...
Author here - more details about the link: About two out of three major websites are based on the jQuery Javascript library. jQuery 2.1.4 weights about 250kb and code minification brings it down to 82kb. GZIP compression reduces the number of bytes to be transferred to 34418 bytes (official download at http://code.jquery.com). I was surprised to find that a simple gzip -9 produced a significantly smaller file (29539 bytes). Since jQuery is pretty much a textbook example of "compress once, decompress a gazillion times", I started to play around with various DEFLATE encoders. My intention was to spend tons of CPU cycles while compressing in order to save every byte possible. Google's Zopfli, especially Krzymod's fork, produces the best results, which can be found here: http://minime.stephan-brumme.com/jquery/2.1.4/. kzip and 7zip are included in my tests as well. These promising numbers gave me a push to include older jQuery versions as well as other popular Javascript libraries, such as AngularJS, BackboneJS, Bootstrap, D3, Dojo, Ember, Knockout, React and UnderscoreJS. Go to http://minime.stephan-brumme.com to get more details. Moreover, I downloaded these libraries from their original websites and from major public content delivery networks like Google, Microsoft, cdnJS, jsdelivr, Yandex and Boot. With a few exceptions they all fail to be even comparable to gzip -9. I have no idea why because smaller files would directly lead to reduced network costs. For those who feel the urgent need to take a peek inside these compressed files, I wrote a simple DEFLATE decompressor in Javascript which visualized the Huffman tables and LZ77 matches of the smallest GZIPped files (scroll down to the bottom of the page to the "Detailled Analysis" and press the button "Load and Parse Data"). 
I love number one and wish I were given that one :-D
For a real test, you need to benchmark the decompression times too. This could be non-negliable on mobile devices, and it may be cheaper to send the larger files in the long run. Would be interesting to see if there are any perf gains to be made though!
Agree to disagree. I've had no trouble getting intention across on a whiteboard, and I've hired people who can do it too. If anyone ever stuff something to me like "Your whiteboard pseudo code is missing a semicolon" then I would be annoyed. Luckily, I've never done whiteboard exercises for stupid people.
This is completely fucked, and the reason why frontend is so goddamn difficult to deal with. Imagine pulling down a project you wrote a year ago, and it stops working because CORE DEPENDENCY SYSTEM IT RELIES ON DIES. It's one thing dealing with a dependency that's screwed up, it's another when your legacy app no longer works because you can't even run the dependency manager. There was an article written on why it's so hard to find (good) frontend developers and this is a good reason why. As it stands, frontend is still a long ways away from being stable. I don't think I've ever pulled down a project that's older than 1 year and had it work when I went to go pull dependencies. Something always dies: a dependency in bower/grunt/gulp/npm/whatever the fuck else. 
Can I ask: Did you ever donate to Bower? Or contribute to their code? Because it's *really likely* that you didn't. So you're pissed off that something you got for free stopped working. Huh. Weird. Sorry, but this is just one in a long-line of examples of why open-source development just isn't the golden goose it's made out to be. 
Bower was a horrible mess and couldn't even handle deps well. I'm just glad we aren't using it here atm.
why would it stop working? it's not like the existing code is going anywhere.
Be careful, you may just automate your way out of a job here. That said, your best bet is writing a bot to do this for you. Ruby has a great library called watir that is excellent for this type of work.
My impression is that it looks a bit messy, especially the `zip`. If I'm writing haskellish JavaScript I would try to get as close as possible to the intended functionality, meaning I would not define variadic functions to start with, I would derive them if necessary and add a meaningful suffix, like `many` for example. Perhaps one exception would be `flip`, but I'd still call it `flipMany`. let compose = (f, g) =&gt; x =&gt; f(g(x)) let composeMany = (...fs) =&gt; fs.reduce(compose) let flip = f =&gt; (x, y) =&gt; f(y, x) let zip = ([x, ...xs], [y, ...ys]) =&gt; { if (x == null) { return [] } return [[x, y], ...zip(xs, ys)] } let zipWith = (f, xs, ys) =&gt; { return zip(xs, ys).map(xss =&gt; xss.reduce(f)) } let flatten = xss =&gt; { var flat = xss.reduce((acc, x) =&gt; acc.concat(x), []) if (flat.some(Array.isArray)) { return flatten(flat) } return flat } let zipMany = (...xss) =&gt; { return xss.reduce(zip).map(flatten) } I think this gets closer to the intent of OP's post. Destructuring and recursion can get you very close to the Haskell implementation of some of these functions.
Just use babel-loader with flow support in your babelrc : https://babeljs.io/docs/plugins/syntax-flow/ https://github.com/babel/babel-loader 
[removed]
Bower does more things than npm - npm 1/2 could not do frontend (flat) dependency resolution, don't know about npm 3
That is a good idea, I would recommend understanding the fundamentals of javascript to anyone using the language, however Jquery can be an excellent place to start since the underlying mechanics of raw javascript can be hard to grasp for newer programmers. So starting with a higher level abstraction allows you to learn how to use the language and be productive whilst still allowing for delving into deeper rabbit holes as necessary. 
Can someone who is against moving everything toward npm chime in with a real opinion? I'm genuinely curious. I've used Bower for quite a while, but as time has gone on (and I've used npm significantly more for other things), it's just seemed like a vestigial limb. Nothing wrong with the premise, not particularly unhappy with the execution, but just unnecessary when the tool you use to install bower also does bower's job. I'd love to know what reasons people have for preferring it.
npm 3 no longer nests dependencies, so it's nice and flat. There are some speed downsides to this at the moment though. Do you have other examples? I've been trying to figure out why I have actively used bower for so long instead of just using npm, and I really can't make the argument myself. I'm sure there are other things unique to bower, but I have no clue what they are.
As far as I can tell, the main reason to use Bower were flat module installations. Npm 3 finally supports this, too. http://www.felixrieseberg.com/npm-v3-is-out-and-its-a-really-big-deal-for-windows/#flatmoduleinstallation
Well, npm3 wasn't ready until very recently ;). I am still on bower, though will migrate to npm 3 when it's ready enough (as in production ready &amp; widely adopted, not 'Node community ready')
You keep saying referring to "newbs", but even the most skilled rockstar was once a "newb". Even a 1000 mile journey begins with one single step. When you are first learning any skill, anything that helps you grasp concepts and progress forward quickly is the best approach. JQuery helps make it easy for beginners to use javascript and be effective with initial DOM manipulations. For most beginning programmer grokking how to query the DOM and manipulate elements on the screen is more than enough to understand at first. So JQuery simplifies that and allows the students to focus on understanding and working in that paradigm. You can always make the argument that there is more to learn and you can dive deeper and have greater knowledge on any language or any computer science concept. We as software engineers and curators of our own knowledge need to decide which rabbit holes we want to go down and how deep we follow each rabbit hole. 
Cooolllll
What kind of project? Bower is mostly frontend packages
This is why you should check in your dependencies. http://www.letscodejavascript.com/v3/blog/2014/03/the_npm_debacle
This wouldn't run the type checking afaik? The idea would be to have flow as preloader so type errors would prevent the rest, similar to how we use eslint-loader.
Good. No one will miss it.
So how much software have you actually ever paid for? Because your implied mentality seems to be "free of cost is desirable and good". 
For a project that's currently using bower and gulp or grunt, what's the easiest way to remove the bower dependency altogether? What are the options?
i see, i have magic mouse, no wheel, anyway, is one thing more :D
There is no client-side math, the view field is computed on server-side. Using separate thread is what I want to try, but im not sure how to do it on the server.
You can't make this up... I was just reading about JavaScript in general and the ecosystem. Everybody is always complaining how new frameworks pop up, difficulties with upgrades because of breakage, multiple technologies for the same thing, etc. So I am playing with Ember and the book says 'npm install -g bower', etc. Cool, have everything set up. Let me check Reddit.. "Bower Development Effectively Stopped." God dammit JS world, get it together!
If you're just dropping it in and throwing in &lt;script&gt; tags to point to the files, I don't think there's an easy way to do it. I think the idea is that you're using either CommonJS or some other build process to get the appropriate files for either side of the app and package those up, so the end result would be a single or defined set of files for the frontend and the backend. 
this will actually make the javascript ecosystem easier and less fractured because it will help the continuation of getting everyone using the same package manager.
&gt; Declaring something as "effectively stopped" without any proof what so ever without so much as providing an explanation beyond a cryptic twitter post. If i was a lead developer on bower I might even consider this slander as it's going to harm adoption to a working platform. I agree that declaring something "effectively stopped" is a bit too harsh, but this is still a sign that Bower's development might not be at its best shape currently. I think it would be benefical to bring into light [these](https://github.com/bower/bower/pull/1748#issuecomment-150104311) [comments](https://github.com/bower/bower/pull/1748#issuecomment-150115483) in case people actually want to do something about this instead of abandoning the ship.
Was planning on migrating to Bower for the frontend dependencies (as opposed to just having the files in a /lib directory), but it looks like I'll just end up using NPM. Are there any resources as to how NPM should be used on the frontend? Do I just point to the files in node_modules?
Good points. But things don't look good: * [Activity fell off a cliff a year ago](https://github.com/bower/bower/graphs/contributors). * [sheerun is the only active core member](https://github.com/bower/bower/pull/1748#issuecomment-150104311) for Bower and [he contributes a fraction of what satazor did](https://github.com/bower/bower/graphs/contributors). * sheerun (the only active core member) doesn't have time to implement a feature he's [very interested in](https://github.com/bower/bower/pull/1748#issuecomment-150104311), not even [if paid to do it](https://github.com/bower/bower/pull/1748#issuecomment-154819159). * The last weekly team meeting [was in April](https://docs.google.com/document/d/1mvyvLn8gpzIjksTutNeSKzbee6HhQ01veFYdqTU4fv0/edit) (assuming the link in the [contributors' guide](https://github.com/bower/bower/blob/master/CONTRIBUTING.md) is still current).
Yup. https://github.com/npm/npm/releases/tag/v3.0.0 &gt; Flat, flat, flat! &gt; &gt; Your dependencies will now be installed maximally flat. Insofar as is possible, all of your dependencies, and their dependencies, and THEIR dependencies will be installed in your project's node_modules folder with no nesting. You'll only see modules nested underneath one another when two (or more) modules have conflicting dependencies.
So... how much software have you actually ever paid for? 
Putting aside the issue of whether or not Bower is actually dead, honest question here. If I already have an app with an NPM-based backend and a Bower-based frontend, with Grunt as a build tool for the frontend, is my only solution here to split this into two separate projects for frontend and backend and NPM-ify each? Obviously I don't want them in the same `package.json`, since they have very different requirements, right?
Right, but gulp/grunt/brunch/etc are. If you're just dropping the files in there as they come out of bower, I definitely see what you're getting at. I'm usually dealing with something that's doing preprocessing, concatenation, minification, et cetera, which means I've already got a tool that's going to handle splitting my assets appropriately.
Often. I don't get to make up my own screens and I don't care to. They should be vetted by a business analyst and designed by a UX expert. But I get that that won't be the case in small businesses.
You said: class Person { private #age; construtor(age) { #age = age; } incrementAge() { #age++; } getAge() { return #age; } } What's the deal with the # signs? As far as I know this is definitely not valid JS. [Section 7.6 of the spec on Identifier Names and Identifiers](http://www.ecma-international.org/ecma-262/5.1/#sec-7.6) says identifies have to start with: &gt; $, _, any character in the Unicode categories “Uppercase letter (Lu)”, “Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter (Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”, or a \ followed by a UnicodeEscapeSequence. (paraphrasing for readability) edit: I forgot to say what a great explanation you made though. Great work! Didn't want to come off as overly negative and unnecessarily nitpicking. I was just genuinely curious when I saw the # and thought it was something in ES6 I wasn't aware of.
not mad at it
http://jspm.io/
The markup is never truly separate. It always has to adhere to some sort of contract. With some frameworks, you do some traversal. E.g. you jump to some node with a particular ID and from there you walk the tree until you arrive at some other element. Surprisingly, this is actually a whole lot worse than what Angular is doing, because some of the structure is now implicitly fixed and you actually can't easily change the markup. `&lt;li *ng-for="#thing of thingies"&gt;` looks kinda bad, but doing it like this means that you can freely move it around. You can add/remove classes or even use a different kind of element. You also don't need to test the traversal bit because you simply aren't doing any of that. The way React does things is a bit iffy, but it's true that the markup is usually written by the same person. So, it kinda doesn't matter, I guess. Different people can still simultaneously work on different components.
&gt; You'll only see modules nested underneath one another when two (or more) modules have conflicting dependencies.
JavaScript is the language we need, but not the one we deserve right now. 
Have you considered using a genetic algorithm to find the optimum parameters?
&gt; Absence of new brings much more consistency. Adding an alternative way to do something cannot increase consistency. Ideally, there is exactly one way to do something and everyone does it this particular way. If your project contains a few of those unicorn constructors which do not require `new`, your code became less consistent. You'll of course still need `new` in a few places. E.g. when you need a Set or a WeakMap.
Why not have them in the same package.json? Many dependencies can be shared (moment.js, numeral.js, etc.) and if you use browserify or any kind of module bundler requiring dependencies is the same on front and back end code. I see no harm in sharing a package.json.
So...what don't you understand?
Well Bower will still always have the coolest logo out of all the package managers. It would be cool if NPM could steal the logo and use it for it :D
Although you could technically do that, the better approach is to use a module bundler. I use webpack, but there are many other choices. Browserify, rollup.js and jspm to name a few. A module bundler will take your code as import statements and produce a minified, optimized file for you. Here's why my team uses webpack: * Strip out DEV-only code in production builds * Automatically build a "common" bundle based on the # of scripts that use a particular module (i.e., jquery, frequently used UI plugins, etc). * Ability to use ES6 * Live reloading of your web browser when you save code with webpack-dev-server * No risk of serving arbitrary assets that could potentially be accessed in your public directory (think http://your_site/node_modules/some-package/tests/index.php)
Use webpack.
Manage your front end with webpack and it won't matter what you have in node_modules
[As I said, just two days ago,](https://www.reddit.com/r/javascript/comments/3seo32/what_happened_to_shirtjscom/cwwpr2k) and was heavily downvoted: &gt;It happens all the time. Sometimes it takes a few years. Sometimes a few weeks. It happens to most of them. Practically nothing I used when I started in this business, in 2004, is still around today. At least half of things like this will disappear within the next three to five years.
React-three-renderer still uses React-DOM though? 
You have a minor bug. If you call `pascal(1)` it incorrectly returns 2 lines.
Could you talk about why you think this is worse than the old way of doing things: &lt;!-- HTML --&gt; &lt;div id="myDiv"&gt; &lt;/div&gt; // JS $('#myDiv').doStuff(); Sure you could separate these into two different files, but you have still coupled your logic to your markup. If anyone were to change the ID for styling purposes the code would lose its target and cease to function.
&gt; Why do interviewers love algorithms so much? Because it demonstrates _basic_ skills every good programmer should have * Are you able to break a problem down? * Do you understand recursion? * Can you fold recursion into an iterative version? * Did you correctly handle **all** the _edge_ cases? * Are you able to analyze and recognize patterns? Pascal's Triangle is so trivial that if you can't get it within 5-10 minutes you're probably a crappy programmer. Of course a **good** interviewer would be courteous: &gt; Q. Are you familiar with Pascal's Triangle? &gt; A. No. &gt; Q. Ok, you have this triangular matrix 1 Line #1 1 1 Line #2 1 2 1 Line #3 1 3 3 1 Line #4 1 4 6 4 1 Line #5 1 a) Write a function that returns one line for a specified depth as an array i.e. PascalTriangle( 2 ) would return the array: [1, 1] for line #2 PascalTriangle( 3 ) would return the array [1, 2, 1] for line #3 etc. 1 b) How would you extend this to return all the previous lines as well ? 1 c) How would you optimize this -- for speed? for space? All those questions &amp; answers help demonstrate how a person _reasons_ about solving the problem. 
https://github.com/codemix/babel-plugin-typecheck
I was gonna write a long comment but you said it better than I could.
You might just as well said "Banging your *son*?"
That's a real shame. It would be nice to have a clean, elegant, and beautiful language as the de facto standard.
You're thinking of markup and script as separate entities. They aren't, they're both part of a view. You can and should separate the view logic from the business logic and state management.
No that's correct actually. One of the principles of Test Driven Development is to write test code for each piece of production code. Ideal scenario, you should not be able to change the production code without changing a test first. Is this slower, yes absolutely, but it forces the developer to think through what it is they're trying to accomplish.
As others have said, it's not that people don't care about SOC anymore, it's just viewed differently. Separation of html/css/js is just arbitrary separation of technology. You can't actually build anything (well, not anything that anyone would want to use) without all 3. Well, a lot of people do their css in js nowadays, but still, you need style, structure, and logic all together to build anything. And usually all of those are built towards one purpose in mind. So, nowadays people think in terms of components, and that seems to be a much better paradigm. I've done things the old school way, with MVC frameworks like Angular and Ember, and with React. IMO, the React / jsx approach has been by far the most developer friendly and easy to use approach to building complex websites I've ever seen. You should give it a shot: you'll see that it's a better way to think about things.
Separation of concerns is extremely important. Some frameworks do it better than others, for example the separation of concerns is very strict with React + Redux. State (store + reducers), behavior (actions), and UI (components) are all completely independent and only tied together at the "smart component" level. This proper separation of concerns manifests itself in code that is ridiculously easy to test and reuse.
Disagree—you should **absolutely** be able to change the production code without changing a test first. This is what you're doing during the refactor step of red-green-refactor: changing the code while the tests stay the same (and stay green). It's better to say that you shouldn't be able to change the **behavior** of the code without changing a test first, but that doesn't sound like what zachwolf is concerned about. If you overuse mocking techniques in your tests (bad thing), and if your program consists of small, focused objects which work through collaboration (usually good thing!), you end up with tests that don't feel super informative—they very closely resemble the implementation itself—and make change difficult rather than easier. When this happens, it often means that you're over-mocking; it's one reason Uncle Bob talks about only mocking over architecturally significant boundaries. Which is to say, I agree with zachwolf; a clear discussion of what to test and what not to test would be very valuable. (There is a lot of literature on this topic around already; see [Magic Tricks of Testing](https://www.youtube.com/watch?v=URSWYvyc42M), [this post from Chris Jordan](https://blog.8thlight.com/chris-jordan/2015/08/26/loosely-coupled-testing.html), and others)
Also, so you can easily see it in action, the author has a [video demo](http://vimeo.com/82711574) on vimeo. See also: [the official project site](http://kakoune.org/)
I don't think there's anything wrong with your example. Yes if someone changes the ID, things go wrong, but that can be said about function names, component names, and file names or any other variable/tag/attribute. If you change the ng-* attribute on an angular directive, that component can cease to function as well. 
that is exactly what im looking for. Im glad it can be done in such little code so I can see what im changing easier xD thanks a ton!
Young and employed vs. old and stuck in their ways. The best thing I got from React was Pete Hunt's plea to "Give it five minutes." Don't assume what has worked for a while is going to work forever. This is the web, there's a revolution every 18 months. Experience can help us make better choices, not close doors to what's next. What's next is going to happen with or without us. 
&gt; It's better to say that you shouldn't be able to change the behavior of the code without changing a test first This is stated much better than what I had, I did not explain in as much detail as I should have. This is what I get for answering questions on the phone.
Regarding the issue around no equivalent to DefinitelyTyped - fortunately the flow type annotation syntax is near identical to DT, so you can often just use DefinitelyTyped files almost verbatim. No need to reinvent the wheel.
Right and that's been my issue. There's no framework that I feel completely comfortable with, but I REALLY don't want to roll my own solution every time. I guess behind everything in this post I'm really looking for a community guided push toward a developer friendly framework that doesn't make me want to smash my head through my desk every day. 
&gt; You might also try programming using backbone and whatever you are familiar with, but in a component style. Not sure if I gave the impression that I've been building writing poorly organized functional JavaScript, but if I did, please accept my apologies. I'm very familiar and with building small reusable and context agnostic controls/components/modules. In fact, that was my hobby project about a few years ago when Backbone was stable enough to play around with. Each components has a layout, style, and logic/js (that I placed into separate files to satisfy my organization OCD). The JavaScript and CSS were all namespaced properly to avoid global scope pollution. While I was happy with my creation, I didn't have the time, energy or motivation to document it and build it out into yet another one-off framework. So it's not the concept of "component style" architecture I'm struggling with, rather the popular frameworks being used for that purpose. It's understanding why I need to put JavaScript functions and logic in my HTML to build a "component-style" site in Angular. It's understanding why I need to build my markup in JavaScript to build a "component-style" site in React. 
&gt; from a superficial perspective it almost seems like we've gone full circle. Yeah. we have. We thought it would be neat to have independence of js and html, and we tried it with backbone, but then we slowly realize that the independence was an illusion. Backbone views are still full of classnames that need to exist in the HTML or else they don't work. So when we took the js out of html we ended up just putting html into the js. Angular and React are basically admitting defeat, that js and html are inextricably coupled. React does it a lot cleaner IMO.
yes ng-people can be very stubborn ;)
Thanks for unnecessary general and irrelevant wisdom nugget. It's impossible for to be stuck in old ways in this industry. However, I've been around long enough to know that it's not always advantageous to jump on the latest and greatest hot-shit shiny new framework just because there's a buzz in the hipster-js circles. Considering the number of breaking changes between versions of Angular and the paradigm shift of using JSX for markup, I want to make sure I'm jumping on a solid ship, not a sinking one. &gt; Don't assume what has worked for a while is going to work forever. Never made that assumption. &gt; This is the web, there's a revolution every 18 months. So say all the tech magazines. &gt; What's next is going to happen with or without us. Are you running for class president or something? I'm not sure how this applies to the discussion. &gt; Experience can help us make better choices, not close doors to what's next. Yes, and it's because of my experience that I'm leaning on the community to help me make more educated decisions, rather than relying on ignorance and dumb luck to hope I stumble on the right choice. &gt; Young and employed vs. old and stuck in their ways. A sign of true ignorance. Well done.
See and this is a mindset I can get behind. Use it because it works, not because it's the self purported solution to everything. I guess I've been around long enough to remember the previous round of scolding and shunning and I'm hesitant to repeat similar behavior. Get's my battered developer syndrome acting up.
While I would normally agree, cleaning up code in this case also means refactoring.
I have a friend that I worked with on a backbone based app who left to work for an Angular organization. He makes sure he's off company wifi and out of the geographical area before he says anything less than exalting about angular for fear of reprisal. That's probably another reason I'm so reluctant to get into the "ng-world" because it's starting to get a little cultish! Like Scientology and the Hotel California, once you get in you can never leave....
"Not an industry standard" for one. They're all not industry standards. Also some of these are wrong. C#-the-language is free, and there are multiple C# compilers out there free-of-charge. Visual Studio Express and Community are free, with certain restrictions. You technically don't need either. The analysis of the "language" is really an analysis of DuoCode. C has a crap ton of unit testing frameworks. http://stackoverflow.com/questions/65820/unit-testing-c-code Meta-programming in Ruby applies across many languages. F# is cross-platform. "AppStudio BASIC" isn't a language. Babel "No syntactic sugar added" makes no sense to me. The point is to use ES6, that's it. LiveScript "Strong functional lean" why is this a con when that's the point? TypeScript "too similar to JavaScript" also the point, being that it's a superset of the language.
That's exactly what I mean.
Dude, thanks for your thoughtful reply. There's a lot of good stuff here. &gt; The fact that HTML and JS (and in some projects, CSS) might live in the same file isn't a separation of concerns; the core concern is "making a widget with great UX", and they can use PropTypes to make it explicit exactly what data and event handlers they'll need me to provide. Right and I think folks are getting hung up on the separation of files rather than way the components are composed. With angular's "markup first" or React's markup generating scripts, it's two very different approaches to to the same problem, both of which differ from my personal approach. &gt; I would suggest to the extent you have done so you will have done so despite Backbone's awkward architecture, not because of it. This point is exactly why I made this post. I started yet another project for a contract, and I began by pulling file after file of personal project boilerplate code that I have cured over time to allow me to achieve this type of functionality. Backbone and Marionette exist somewhere underneath it all, but I've done it all with ES6/Babel, there are wrapper classes for most of the the framework components, a custom implementation services and so on. The problem is that it's loosely tested, only partially complete, probably needs better logging and error handling, and I will never be bored enough to document it to any level of community satisfaction. This means the next guy to work on this app is boned. So then I launch into my obligatory framework hunt to find something that works the way I do. Angular has some neat stuff, but it's got some things I really dislike. &gt; Eg, it's currently strongly encouraged to write "dumb" or "pure" components, which are then wrapped by "smart" container or Higher-order Components (HoCs). One well regarded writeup of the concept is here. The last time I had a round of framework surfing, a professional opportunity hinted me more toward the angular path. At that time I didn't give React any more attention than I would a drunk fat chick in a mini skirt, but the overwhelming response in this post leads me to believe I need to suck it up and dive in. Thanks again for your post. React is my homework for this weekend. 
It is, but Angular also has Views as a core feature. So mixing them does not make sense to me. It will only make you application heavier.
I agree with you. RiotJs is slightly better than react at this, but still has the same issue. The current state of js frameworks makes me pine for the days of "augment with jQuery". To me the issue is around dynamic injection, just because that's really where the violation of SOC is happening 90% of the time. ShadowDOM isn't helping either. Is there a way forward without forfeiting those two, IMO, helpful technologies?
Is one of the tips learning not to use jquery in 2015?
Re: the two links at the end of /u/davwards reply, the video featuring Sandi Metz is fantastic --- like every talk she gives --- and is a must watch.
I'd wager that you'd spend more time coping with and fixing the countless clusterfucks caused by Angular than it would take you to rewrite the entire thing in React. I'd also wager that you'd spend more time debating "how you should structure your Angular application" than it would take to rewrite the thing in React. Take any Angular job and you'll either be doing a rewrite using your company's latest Angular style guide or dealing with performance issues or fucking with `enterpriseTranslusionServiceFactoryProviders`. If you don't want to switch, then look into preparing your application for Angular 2.0. Look into Angular's new router and the [upcoming component() method](http://toddmotto.com/exploring-the-angular-1-5-component-method/).
I've worked in large multinational corporations... work in one now, even... and UX is still a rare commodity to me. It isn't just small applications, UX is not always the top priority - functionality wins every time IME.
certainly interested in the idea. whether or not I'll have time to contribute is another question.
How stupid I was! Why would I repeat doing something when it doesn't change? With a little tweaking I managed to draw my text on a different canvas that I only redraw when the text changes. Drawing this canvas on the main canvas is, sure enough, "ridiculously" faster.
The first tip already made a huge improvement in performance. So much that right now it's running perfectly smooth. I will dive into the 2nd tip, it makes a lot of sense but I don't think any further performance will be needed. Thanks!
How will you ensure you don't end up with a React mess instead of an Angular mess? Clean up your angular code. Bad code shouldn't be a reason to switch framework.
Works well in Ubuntu on relatively current laptop in Chrome (in Chrome you need to manually enable WebGL so if this uses WebGL, you have to enable that in Chrome settings first)
Refactor, but do it in stages. switch from $scope to ControllerAs syntax. Then look for any major areas you are using ng-repeat, and this is a place you can possibly utilize reactjs if you wanted to. ReactJS should only be used within Directives, where you are given immediate access to $element. Refactor your ajax calls into service providers. Improve your build-process &amp; code organization. Often times build &amp; organization problems are very messy and benefit immensely from fixing these workflow issues.
SO i have the onload="function", and i am doing tests at the same time so i have normal p with the id of the get element And the if statement is working but the one within the table that php outputs isn’t working. "&lt;/th&gt;&lt;td&gt;&lt;p id=\"p1\"&gt;" , I’m sure it’s right though
What is it about your Angular code that is a mess which can be cleaned up by moving to React? Why would your React code not be a mess?
I would like to see some elaboration around modules, and how they, in my opinion, often are an antipattern for testability. The first problem is that an exported module in Node.js is essentially a singleton in hiding, so if you are not careful and strictly export instantiable (this is important) code, you can end up with code with global state, that is hard to test. The second problem with modules is that by importing modules and using them directly, you are hard-wiring potentially stateful dependencies into the code. The calling code can later not easily provide custom dependencies with mocked parts etc. This can sometimes be solved with monkeypatching, but that requires convoluted sandboxing solutions and makes parallel testing (for quickness) much harder. With a simple instantiable API object with injectable dependencies you can easily run many tests in parallel. So, I would like to see included a discussion on instantiability and its importance for testability and speed of tests.
You can definitely do it, but you should know exactly why you want to do it. We had a use case where we need to improve long list performance for scrolling and updating. We tried many optimization steps such as "track by", "one time binding on few element of list item", "virtual scrolling", but none of them came close to better performing scroll behavior. Virtual scrolling was the worst among all, I had quite high hopes with it, but it failed. So, we finally decided to give React a try, and we were very much happy with it's performance and component update mechanism. You can do it too. We used ngReact (https://github.com/ngReact/ngReact) to put React component inside Angular view and pass data from Angular to React component. Suggested strategy: - Start with lowest level component, for example: pick a date field and convert this to react and then move up the component tree. You can use all existing styles and HTML structure by following component tree. - Try to separate services and filters from Angular. This is one the aspects that I don't like in Angular now. With ES6 modules, there is now no need to put services/filters in Angular, keep them in modules. You can do this step gradually as well. Move one single service/filter in a module at a time and keep all other dependencies via angular DI way. - Stop relying on Angular DI, because there will be many services/filters that you would need to use inside React components and you can not inject them in react the same way you do in Angular. The common way for using them is ES6 modules. With ES6 module system, there is no need for Angular DI anymore. - Next big shift that will be need is routing which will be a bigger change and should be done in big change. We have not done it, you can decide on our own, if you want to do it or not. After integrating React with Angular, we found that we are tightly coupled with Angular, even our business logic which should be independent from any framework is tightly bound with it. By moving our business logic out of it, we can have a thin layer of "view" which can be easily replaced in future, we can easily move to Angular 2/React native/React.
Aside from sniffing the traffic, this also lets you change the DNS response so you could make reddit.com resolve to localhost for example. I imagine this might be useful for testing since it isn't the easiest thing to test different DNS failure scenarios.
Looks like a dnsmasq with less friction, but it's in JS and OS independent. Nice, now I can apply ublock filters at a lower level.
I have done it now, thanks for everyones help.
If you're going with UML/flowcharts, check out [BPMN](http://www.omg.org/spec/BPMN/2.0/). 
&gt; Whatever - I suppose you know better about the costs of implementing services in my environment than I do. &gt; Y'know - I truly regret sharing my opinion in answer to your post - you're not looking for actual answers, you're just looking for an argument. Exactly why I stopped contributing to the discussion – your whole argument against what I have described as an expected setup is "the costs of implementing services in my environment". I know perfectly what you are talking – I have worked on setting up infrastructures for units of some of the biggest corporations. And yes – in those environments the cost of licences and hardware is phenomenally overpriced. However, since moving to a startup environment, leveraging open-source software, not running for a blue chip companies, we are able to deliver equivalent datacenter at the cost of a single server in a corporate environment. &gt; And why would you say that? It's not like the schema itself is dynamic, there's expected values and I can control the order in which they're used (if used) in my query generation routines just fine. It's the same indexes that would be used if the query were using dynamic SQL, it's just writing the query in a language that's far better suited to it. Sounds like you have very simple query requirements (which is good).
Why edit your hosts file when you can simply install and configure a local DNS server, and then manually update your network configuration to use localhost as its DNS server, and then when you're done, manually restore your network configuration to its previous settings? /s
Nice! Anytime!!
I think you should start over rather than try to implement things gradually in the current app. It will help you clean up your code quite a bit. Doing things gradually is going to make you want to reimplement features the same way you did in the messy Angular app. I do also support getting out of Angular, or at least moving to Angular 2.0. Since it's my first experience with a framework I didn't realize how borked certain aspects of Angular 1.x are. 
I hope you tell interviewees this beforehand as someone very dyslexic with a pen but not a keyboard I'd not travel to a whiteboard interview as it would be wasting everyone's time, however if I had a choice to use a keyboard I'd be fine. I'd feel discriminated against to turn up for a coding job and being told to write code with a pen, I'd be totally useless and leave
Gulp serve is the command that starts my server. Before it starts the server, it will copy content from node_modules to my www serving directory. Not too complicated.
Such as?
You are ill-informed. Well-structured code has very little to do with your framework of choice. The only framework-specific code you write is glue code to bring your libraries and business logic into the framework. &gt; Take any Angular job and you'll either be doing a rewrite using your company's latest Angular style guide or dealing with performance issues or fucking with enterpriseTranslusionServiceFactoryProviders. Really man? That's an old *Java* joke (however true) and not pertinent to the discussion.
After spending time on Brunch, Yeoman, Grunt, and Gulp, (and `make` of course) I have to admit that I'm not exactly enthusiastic about Yet Another Build Tool - I really wish they'd work on rolling new functionality like what Webpack offers into existing libraries. But I guess that's not the "javascript way". All that aside, it's not the issue of resolving the dependencies so much as mixing concerns. Throwing everything for front and back end into one `node_modules` folder and saying "well, it's all Javascript!" just gets my hackles up. There *has* to be a cleaner way to separate concerns.
Perhaps you think you're being helpful. I'll give you the benefit of the doubt. But of course I know they install conflicting versions in a nested structure, because that is in the comment I was responding to. I'm coming from the perspective of PHP, where it's literally impossible to install conflicting versions of a library within the same namespace.
I know this is just syntactic sugar, but sharing it in case anyone else thinks it makes for more readable semantics. 
It sounds like this is how it works, from the above statements. Instead of each module having its own jquery in side its own node_modules you might have a folder in the root of your project called node_modules with a jQuery folder inside it. That folder has a folder for each version of jQuery like /2.1.1 and /1.9.0 and /3.0.0, etc. Then when you require jQuery it looks at your package.json to know which version to get. I'm not sure how that works with client-side code though. I guess client side code is off limits since you don't have require syntax or you need a build process to copy your needed client resources to a dist folder.
Nothing to do with each other? The way I see it, there are 2 scenarios: 1) You're using express to render views and serve them. In this scenario, front-end and back-end have a lot to do with each other, as they wouldn't work independently. It makes sense to keep dependencies together. 2) You have an SPA. In this scenario, you should create sub directories for the projects and keep them separate. The API does not at all depend on the front-end.
In case you're wondering what the hell 'debouncing' is, read this: https://davidwalsh.name/javascript-debounce-function
I've been using Charles for that purpose for some time now. Charles is like DNS+Fiddler, but it also gives you the ability to edit requests or responses, or apply rules per-URL.
A great first step is to completely decouple all of your business logic from your framework. 
Pretty cool!
Good call. I'll update the README with a brief explanation of what it is :)
Definitely what this guy said, but I moved from Angular and did a boat load of research into React before diving in. I fount the real value in it is using a flux implementation like Redux, which will make it hard to not just start over, but not impossible. 
You are absolutely correct, and it bothers me very much that whiteboard coding discriminates against a portion of the candidate pool. Definitely working at employer to expand the way we interview, to include a laptop as an option when doing the technical interview. That said, we are very up front that it's a whiteboard coding interview, so hopefully we wouldn't end up with the bad feeling of putting you in that position!
Keep in mind that this will share the debouncer across class instances, which may not be what people expect. If you create two instances of a class, I would never expect continually calling a debounced method on one to block a call to the other instance. I'd have expected this to return a getter instead that would create a debouncer per-instance.
They're totally unnecessary... except when they're not. Like if you ever start a line with a `(` It shouldn't even be a question -- adding them is an afterthought after a while and removing them can lead to errors. Why would you intentionally use an error-prone pattern over a safe one?
&gt; That is insanely stupid code. I am not going to dumb down JSMin for this case. Comments like this are a large part of the reason why JSHint was initially forked. Crockford is such an ass towards the community as a whole. My favorite was I submitted a bug saying commented out pseudo-code that was _example code_ was failing linting. He refused to acknowledge it as a bug.
"Over 3 years ago" 
Oh, I know, I just have a strong opinion here and wanted to chime in. Thanks for contributing :D Your capitalization of non-class functions irks me too ;)
I rarely use prototypical inherence, and it's not necessary to program anything in JS (in contrast to classical OOP languages that force you to use their class objects). Obviously there's some prototypical inherence happening whenever you create on object / array / etc. but you rarely need to extend the prototype because functional programming can encapsulate the methods in a functional style that's not OOP style programming, persay. The syntax of JS is based in C, but the semantics are based on scheme and it has [first class functions](https://en.wikipedia.org/wiki/First-class_function). JS is like a half-assed OOP / functional language, choose your path :P
thanks :)
Oh I know except some special cases as you stated. I come from a Java background so semicolons are a must for me. :)
Haha... you're easily irked ;) I think my naming choice here goes back to Java meta annotations. Otherwise I would not have capitalized it. (Honestly it doesn't matter, because you can name it whatever you want when you import it anyway.)
Yeah. Regardless of whether Crockford was on the right side of the argument, his comment was _totally_ out of line and sparked a huge flame war that could have probably been totally avoided with a little diplomacy.
I think what he is trying to describe is that your code is a mess because of your first iteration. Until you're able to organize the code in a framework you presumably already understand you're only adding more debt to the project. First understand your problems on a platform you know well. Once those problems are dealt with you'll have a much better time learning react as you'll have a baseline to compare your new code against. I'm actually in a similar boat to you where we want to convert our next development iteration into react, but our current angular code is a bit of a mess.
Follow what you preach.
No problem! [Here's a list of Rich Hickey Talks](http://www.infoq.com/author/Rich-Hickey). My favorite talk is [Are we there yet?](http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey) - that sets the tone for everything IMO. 
What's the point of that quote? "Include" doesn't meant that what follows is an exhaustive list. JavaScript is functional, imperative, and object-oriented. &gt; JS is minimalistic Compared to what? ES6 is a very complicated language. I actually can't think of many languages which are more complicated. Dart is quite a bit simpler, for example, but I certainly wouldn't call it minimalist. It sure does a whole lot more than the bare minimum. &gt; [Crockford] also hates es6 classes, and I feel the same way. That's very nice, but it doesn't make JavaScript not object-oriented. Almost every project out there used ES3/5 pseudo classes and many already switched to ES6 classes. The vast majority of developers really like classes. &gt; I try to avoid [objects] b/c they fuck me with their mutability. Objects aren't necessarily mutable. Strings are a good example. In Dart, integers, doubles, booleans, and Symbols are also immutable objects. Primitives don't exist.
That's the beauty of ReactJS. It's compatible with pretty much anything!
Thank you for this observation! I've updated it so that methods are debounced per-instance. :)
I'm not sure why you wouldn't want a `createReducer` function, I use one on every project. The weird part is his reducer uses a `switch` statement instead.