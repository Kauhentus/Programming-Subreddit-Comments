Eek. Ajax with binary files is very tricky because ajax doesn't play nice with downloading files to the client machine. There are some complicated JavaScript tricks out there, but I have struggled with them big time. My advice: if the call is a GET, do an anchor tag. Server side content disposition and content type in the HTTP response should be enough to get that link to download to the computer. If it's a POST or PUT, use a form with the same approach. Basically just let your browser do all the work for downloading the file, rather than trying to deal with ajax. If you need to do any postprocess stuff (Ie, an action after the download) have the server return a cookie, and then have a setInterval() function checking for that cookie and when it sees it it does the postprocess. Clear the cookie after you see it, in addition to your postprocess action. Hope this helps.
Never used it, but this claims to do what you want: [Pica](https://www.npmjs.com/package/pica)
Yes, const doesn't prevent mutation of the value. Just like final in Java doesn't prevent that. But ever bit of immutability, IMO, improves the quality of you code. Yes, it's not even close to true immutability, but it's closer. And what it does provide is a guarantee that the variable is never reassigned, which is also very valuable. So no I don't agree that let is preferable at all.
 &gt; chewieQuote.replace(/^(R)a+([^a]+h).*$/, '$1$2') 'Rrrrgh' 
Primitive values never have constructor functions, only objects do. Compare: * `number`: a primitive type with many elements (types are sets of values): `7.4`, `15`, etc. These are created via number literals. * `string`: a primitive type with many elements: `'abc'`, etc. These are created via string literals. * Null (only exists in the spec, not accessible from JS code): a primitive type with a single element: `null` (a literal!) `NaN` and `Infinity` _not_ being literals is the weird thing.
They're very, very similar libraries. Vue is easier to pick up for some backend and Angular devs because of the familiar and simpler syntax e.g. `v-if`. On the flip side, React is arguably less magical and closer to core JS as the conditionals are typically `{condition &amp;&amp; &lt;MyJSX /&gt;}` or `{condition ? &lt;MyJSX1 /&gt; : &lt;MyJSX2 /&gt;}`.
There are plenty of free courses and tutorials are available for JavaScript. I highly recommend checking out Udemy and Coursera. If you are confused where to start, refer [this list](https://digitaldefynd.com/best-javascript-tutorial-class-course-training-certification/?kar). It has courses from the beginner level.
There are numerous libraries, addons, and proposals out there to tackle the issue of multithreading in node. You're re-inventing the wheel here, and apparently without experience.
&gt; `let chewieQuote = "Raaaaaaaaaaaaaaarrrgh!";` First match the thing you want to match: &gt; `let chewieRegex = /R[^a]*h/;` This doesn't match, because the ^ in a character class means "not anything in this class". So this would match "Rrrrgh" but not "R**a**rrrgh". First match the whole string: let chewieRegex = /Ra*[^a]*h/; Then pull out the bits you want with saved groups: let chewieRegex = /(R)a*([^a]*h)/; Now look in your matches result, and you should see: * The whole pattern you matched * An entry for each separate substring you saved in a group From that you can just concatenate together the substrings to get "Rrrrgh".
This looks really good!
Hmm, I don't think you need to JSON stringify the body. Maybe try just sending the object, instead of JSON stringified. 
&gt; let chewieQuote = "Raaaaaaaaaaaaaaarrrgh!" but I kind of liked the ! for emphasis :-) ``` chewieQuote.replace(/[^rgh]/ig,'') ```
Right now as far as I know there is 0 support for threads in node.js . You could use a seperate process but IPC and extra memory are things you have to deal with. The thing I wrote doesn't seem too far from reality. The code base is less than 40 lines. Just have a look once.
You could try building jpegoptim with Emscripten or something.
Hoppla: Simple scaffolding tool for the automation of directory structures with custom templates. https://github.com/hopplajs/hoppla
They were literally just added under an experimental flag in 10.5.0
Holy shit I didn't realize it. Can you point me to a link?
The example you are using to compare character count is literally the simplest possible situation and not at all representative of what Promise chaining actually ends up looking like the majority of the time. Typically, anonymous functions are passed to the Promises with additional inline logic.
Please google `console jpeg optimizer shootout`. ImageOptim, the top result, is almost certainly what you want.
Sure, if you give me a reason as to why it's better than: - child_process - web workers - cluster api - napa.js - jxcore - whatever strongloop is doing these days I'm not trying to discount your idea, but as I said this has been discussed a *lot* and there are numerous implementations out there of various ways to do this. The only thing you've said so far hints that you haven't even looked at the existing solutions.
Was there supposed to be an actual reason to learn Haskell in the article?
But modules ARE closures
I am storing JWT as a cookie and fetch user data during server side rendering (redux state).
I highly recommend watching FunFunFunction on YouTube. MPJ is a great guy and he teaches very well. I don't know much about courses for I've always tried to learn by myself, but I know a lot of people who say Treehouse is great.
 const chewieRegex = /([^a])/g const chewieModified = chewieQuote.match(chewieRegex).join('').replace('!',''); 
&gt;Async/await almost never improves clarity. It usually just adds noise. Well that's absurd. How is the word "await" *more* noisy than promise chaining? &gt;The one place that I can think of where it might be a little clearer is how async/await is used in the Hapi documentation (starting with v17), since there are a lot of setup functions that have return values we just don't care about. I'm starting to wonder about your experience as a programmer, because there's nothing special about the code in Hapi's documentation. That's a pretty typical use case for asynchronous programming. Again, your argument is using examples that simply don't occur in most situations. Very rarely does one have to make a succession of function calls, each of which *only* cares about the produce of the previous call. Of course, one could split their logic into individual functions, however *that* would be the worst implementation of all, as it would obfuscate flow of logic in the algorithm. As I mentioned before, at 90&amp;#37; of the time, people are going to be passing anonymous functions to the then methods to perform additional processing before calling the next asynchronous function. I use asynchronous programming often in my code, and the example you are using as the basis of your argument has never naturally occurred. 
;)
can you send me a link please?
They're a subset of closures, with a bunch of additional semantics and limitations (eg, the fact that JS modules are singletons, etc). The answer to data-hiding in JS is to use OOP encapsulation, which in JS is achieved using function closures. Using modules as a *general* solution/answer to data-hiding is a totally inappropriate use.
[removed]
I'm just adding extra discussion here OP, I don't know of a lib that does what you ask. But could you also specify file size constraints to improve the upload times?
Just use canvas, I write this library myself
[JavaScript: Understanding the Weird Parts](http://com-course.online/understand) is the best course that anyone who is looking to learn all the advanced and weird things that JavaScript has. Recommended even for advanced programmers in JS.
http://www.dropzonejs.com/#config-resizeQuality
paywalls and FOSS doesn't mix and match very well. Consider posting on a platform where people are not being excluded.
I am pretty sure that Webpack-dev-server will auto reload itself. Whenever you change your code, webpack-dev-server auto reload. There is no configuration for that. Sources: https://survivejs.com/webpack/developing/webpack-dev-server/
For the life of me, I never understood why Array.prototype.sort() and Array.prototype.splice() had to be mutators. I'd love to add a proposal for Array.prototype.sorted() and Array.prototype.graft() that does the same thing as sort() and graft() but which return a new Array instead of mutating the old one. ``` Array.prototype.sorted = (...params) =&gt; { return this.slice().sort(...params); }; Array.prototype.graft = (...params) =&gt; { let copy = this.slice(); copy.splice(...params); return copy; }; ```
YES.
While I appreciate Vue, I would say that it would be better to try to learn React first. I actually wrote up a blog post about this - observables *can* make your life easier, but they also introduce a whole bunch of "traps" you have to be aware of that can make debugging difficult because it can be difficult to tell whether or not a "simple assignment" is in fact executing arbitrary code. https://brianboyko.github.io/onCoding/blog/react-before-vue
you can do that with pure vanilla js.
i don't know why this is downvoted. hes right
For the purpose of my application, only 500 kb JPEGs will be enough. My goal is thus to reduce any input image (let's say the phone camera has very high resolution, and gives 6 MB images!) to ~ 500 kb. ~ 2000x3000 maximum.
I'd strongly recommend that you learn React. It has an easier learning curve than Angular and lets you make really nice criss cross browser compatible web apps
That would be cool... Could you post some code?
I didn't downvote, I just upvoted ;)
Could you post some code or pastebin it if too long to share here?
&gt; Believe me it will be fun right at the beginning mate
Lol just zlib it with pako: https://npmjs.com/package/pako Very easy to use.
Using lossless compression (which is what zlib does AFAIK) on JPEGs is counter-productive. Sharp on the back-end is good, but it is very easy to get your server non-responsive if it processes big files. 
Totally, because React can now also be used to build desktop apps (electron) and mobile apps (React Native). So many birds with one stone. Source: have been doing React for 4 years and about 6 months ago switched to React Native. I now build mobile apps. It’s dope.
i only know of this one - http://overapi.com/javascript no idea if it meets what you are asking
 The primary benefit of JavaScript is that it runs in the browser.
Affiliate advertising link. 
Dude this is awesome! Cheers! This will be great to teach people JavaScript in an awesome and interesting way. I've been looking for something like this. 
Literally nothing of value in this article if you are a JavaScript developer.
So the two features you mentioned are both ways of looping through iterables. JS has some great built in methods for that, `array.filter`, `array.map`, `array.reduce`, and `array.forEach`. Look them up on MDN to read more. All of the those functions take a closure are an argument, which is generally the big difference between JS and Python (I don't really know Ruby). In JS you will be passing functions into other functions all the time, and functions often have bits of their environment attached (are closures). JS is used for asynchronous programming a lot more than Python or Ruby, so many times your programs will involve a sequence of functions that take other functions as arguments containing the rest of the program.
glad you like it!
Js runs in browser, build a server , you can make cross platform desktop apps using electron and cross platform native mobile apps using react/nativescript and more.
Haha yea setting up sharp is also bumpy, it requires libvips dependencies. &gt; Using lossless compression (which is what zlib does AFAIK) on JPEGs is actually counter-productive; they will actually get bigger. Curious about this, any benchmarks / numbers to back this mate? I tried googling but I can't find any. The reason I mentioned pako was because last week I used it to compress image Uint8arrays client-side before sending it to another client using WebRTC.. bloody hell I think I should test pica.
If you'd like to never mutate arrays I'd recommend using an immutable list instead. That completely avoids the mental overhead of having to remember which functions does and does not mutate. I've created a library with an [immutable list](https://github.com/funkia/list). It is blazing fast and has an API similar to JavaScript arrays (plus a lot of nice extras).
I'm guessing it's because it's a lot easier to implement a pure `sort` on top of an in-place one than the other way around.
I agree with grasfahrer on this. MPJ's videos are fun to watch and he explains concepts in a detailed and example oriented manner
I’ve written three; more will be included in my upcoming book: * Strings: https://gist.github.com/rauschma/c46fc10f671ed5bf14021bc14f101c8d * Arrays: https://gist.github.com/rauschma/f7b96b8b7274f2e2d8dab899803346c3 * Math: https://gist.github.com/rauschma/fa21795493fcf0dc5211dcc6b1fa3073
It's way smaller, ~2kb with core and react against something like 30kb from Apollo. This makes a huge difference if you are targeting mobile.
Affiliate advertising.
Ah damn I wrote basically this from scratch about a year ago :(
Affiliate advertising.
This is why I wrote a Telegram bot that returns a random saved reddit post/comment on request. When I have a little bit of spare time, I can check out those old bookmarks and decide whether I finally want to read the article etc or delete the thingy :) My obvious goal is to get rid of as many bookmarks as I possibly can.
Affiliate advertising.
**Avoid clicking u/kstankovski's link** This user SPAMs their linksynergy redirecting referral links all over. For those genuinely interested in seeing what's behind the curtain, here's a direct link to the content: https://www.udemy.com/understand-javascript/
Just finished the tutorial :) Added CSS plus an improved CheatSheet for those who don't want to read all.
Wow, thanks for taking the time, this is awesome. I did have a TypeScript definition for a program in one revision of the README. Based on feedback in initial impressions, I removed it. I think Flow/TS definitions is something Raj should have.
Something comprehensive may be too huge to be much use, tho I like the links here thqt focus on one specific js class!
What’s wrong with posting links that redirect in order for him to get some sort of monetary compensation if he’s helping contribute?
I used the iterator example for python vs ruby because ruby has the great example of condensing code like this: for x in (0..10) if x&gt;5: print x end end to this: 0..10.each{|x| print x if x&gt;5} But js looks like it offers a range of options for different applications, I'll have a look :)
Because it's spam
Because when you allow that then people spam them endlessly and so will others. Also their motivation is purely money, not if it is relevant, helpful...etc
I'm not sure how basic is too basic, but I have been starting to learn javascript and I found this video super helpful : https://www.youtube.com/watch?v=CLEd8Gph9hw. He goes over how to create an object that is a deck of cards, complete with a bunch of methods that deck of cards would have, like shuffling the deck, or dealing cards. It goes over some the fisher-yates shuffle a little bit, and imo really helps tie everything together. Once you make your deck of cards, turn it into a simple game. For example, I took the deck of cards and created a super simple war game, where each player draws a card and the higher of the two cards wins each round. Then I had a realization that the face cards don't exactly translate to a numerical value, so I had to build a switch statement for the face cards. Finally I added score tracking to each round, and added a final results so you can see who won out of x amount of rounds. This is super basic, but as somebody who is actively learning, I can wholly attest that this little project has helped me get a better grip on things.
Sorry for the long delay, don't get much time on weekends. Thanks for the great examples. I can't seem to find the thread where I'd read that now, or maybe I'd misinterpreted what I'd read, but it was on S/O. I understand your examples and they do seem to work, though I'm thinking the namePromise in the second example was just a holdover from the first example because it doesn't seem to do anything? Anyways, my original question definitely showed a lack of understanding about the whole thing in general. I've been playing around with my original code that prompted this question and I have since vastly simplified it, and seen where I was erring. Thanks for the help. 
&gt; Curious about this, any benchmarks / numbers to back this mate? I tried googling but I can't find any. Just trying it out on a random photo I have, I get about 0.25% compression. That's pretty typical in my experience, since it's convenient to stick a bunch of photos into a ZIP file. The reason they can't compress much is because the last step of JPEG encoding is lossless compression with RLE and Huffman encoding. zlib's DEFLATE algorithm also uses Huffman encoding as its last step, instead of a more fancy algorithm like LZMA, so it can't really do much better.
Thanks for the link, but I am afraid that one is out of date.
These do look very cool, but I am afraid they are not formatted to be printed, and they include a lot more details than I am looking for on a 'cheat sheet'.
Thanks, i’ll take your thoughts into consideration. You are correct, this is a work-in-progress.
[removed]
It does cover async iteration, which is new!
Also: I don’t mind articles about older features. It’s a good way to learn.
Fair enough!
Username checks out 
Thanks a lot. I always thought the spread operator or the assign method do deep copies. Great explanation! 
&gt; provide is a guarantee that the variable is never reassigned In practical usage I don't find that so useful. I can't think of a case when a variable is reassigned without my knowledge. Whereas values can be pushed into arrays or assigned to keys in objects all the time, and const doesn't protect me from that. On the other hand, const can be a nuisance const a = []; a.push(1); // legal a = a.concat(1); // illegal the two statements above do _the same thing_ but one is illegal for no good reason.
FilePond (a file upload library) can do this if you add the image resize and image transform plugins. -&gt; drop image -&gt; resize input to certain size -&gt; save as jpeg with certain compression -&gt; upload to server You can add the crop plugin as well if you want every image in the same aspect ratio. https://pqina.nl/filepond/ Disclaimer: I’m the author of FilePond :-)
I recommended course I studied from. The course is good and worth. You have to tried and you will start recommending it.
I recommended course I studied from. The course is good and worth. You have to tried and you will start recommending it. I highly recommend it to you
you might also take a look at [https://threejs.org/](https://threejs.org/) i think a combi of thoose 2 can create massive games
I hope you know your logo looks like a swastika when scrolling quickly!!
it's not spam. the problem is some greedy people like you having more accounts are trying to destroy people who are recommending something that tried and think it's worth sharing with others. if you go on your shity profile you will see how terrible person you are.
So? 
been a while but a few years back i wrote a from-scratch image cropper that did image scaling with an image tag and the onload event listener. the trick is to incrementally scale it, instead of doing it all at once. scale it down in one step and the result looks like junk, but scale it in little steps and it comes out okay.
Yes, or find packages on npm! Rails would be something like Sails or Meteor. But both never reached the fame of Rails got, full stack MVC framework were already dying when node came out. 
I don't follow your "greedy" argument. Expand?
/u/TJSomething already answered your other point so I'll just respond to this &gt; The reason I mentioned pako was because last week I used it to compress image Uint8arrays client-side before sending it to another client using WebRTC If those Uint8arrays were uncompressed bitmaps, compressing them with zlib would be helpful. You are basically converting them to PNG's.
I finally managed to add zooming to my D3 reusable chart library d3-ez: https://github.com/jamesleesaunders/d3-ez See the results here (simple NPM download graphs): https://beta.observablehq.com/@jamesleesaunders/npm-downloads-counts-with-d3-ez Pinch in and out to zoom. The great thing about this, is that I enlisted some help through fiverr crowdsourcing to help me solve an issue I was having with zoom.
enough with the emojis in github
you should read this: [https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript](https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript)
What you mean exactly by hot reload? I have a feeling it reload your entire browser page, that's not the same as webpack HRM.
Interesting! 
Hi, I split the code to many smaller functions (as it should have been done). I haven't yet split the big code to multiple files (I should do that as well, and planning to), but I believe the code is even now much easier to understand and maintain. Could you take another look please?
Check out Tyler McGinnis' short React bootcamp on YouTube (he has some short articles too as pretending to help too). Highly recommended! And free! 👍
Looks very nice, great UI design!
I do imagemin inside a gulp task as part of Middleman workflow. npm gulp-imagemin
Don't you have anything more constructive to contribute?
Yeah, got any screenshots?
Can you add a screenshot? I'd like to see what it looks like, before going through the process of installing it.
Oh my god, this is amazing. Finally.
You're missing a = there when assigning the value to the products variable.
Unpopular opinion, but if you like Python/Ruby, take a look at CoffeeScript. It compiles into JavaScript and gives you a lot of stuff familiar to Python/Ruby devs like -- list comprehensions, whitespace-delimited blocks. You'll learn JS variable scoping is pretty screwed up, but CS tries it's best to take care of it for you in a manageable way. Like I said, not a popular opinion (most would advocate for ES6+ and a transpiler (Babel) , but it might help with learning.
its fixed now but im broke my script with this "="
My next guess would be to take a look at *ArtNrText* you're trying to assign to the object of *product*. It's declaration seems to have a typo *aArtNrText*.
Just a thought: if you are lucky, the site might load the usage detail via an AJAX request. Did you check out the network inspector when looking at the site? If you could find an endpoint to get the data, you could drop puppeteer and the hard-coded selectors.
fixed :D 
I was asking because I think I need js for college so idk if I'd be able to implement cs but thanks anyway
While I agree with its message, it's not very helpful. Gotta give a little more info. Write the image to a canvas, then use `canvas.toBlob(function(blob){/*blob's ur file*/},'image/jpeg', 0.70);` //quality!
Everyone is learning react so when companies need angular developers, they can't find any 🙃
Also Angular creates more work to be done. In React everything is so easy that it just doesn’t take as long. 
Far ahead in the hype train yes. It will pass.. as did Prototype, jQuery &amp; Backbone before. The OP neglects “right tool for the job” might take priority over flavour of the day.
So far quite liking your framework and it does feel a lot like Elm comparing it to Elm 0.18 web interface model which I had tinkered with a good while back, I have yet to decide if I want to go that way in a real project though. I have used redux a fair bit with redux-thunk, redux-forms and reselect and find it of value, but I am always interested new ideas. I have yet to work through unstate which I stumbled across recently and I have only briefly looked at hyperapp which looked interesting but havnt tinkered with it yet. I like strong types, I really enjoy working with Elm and have been working through a recent Haskell book. I cant say I was keen to learn Typescript a few years ago but the project lead was keen for it so ended up using it seriously. I did the learning curve 2+ years ago painful. Today there are better resources around, the tools have improved and the quality of type defs for third parties has also improved, but learning is still harder than it seems from the outside I think. To use typescript for its quick wins can be good value, but to nail down types is far from trivial. In Raj I changed a type because it eased the typing, I am not a typescript guru though am comfortable up to a point nowadays, possibly I could have kept the data model you had for state and effect but I got stalled on types and knew I could achieve it with an object with 2 fields. I had thought about writing just typedef's but in some ways it would have been harder in my opinion, also rewriting let me learn the design more directly. Once I got past the initial hump of setting up the types it took a few iterations writing the examples up and getting them working to restructure them to get the types to feel right and not to in your face. Though for anyone not familiar with a type system the types will be very much in your face and look and feel like a lot of extra overhead. I want to try and create another example that leans on something like [npoint.io](https://npoint.io) to demonstrate interaction with with a back end a bit, just to get a better feel for the pain points. I have yet to go through the raj-spa library. Some other notes. 1. I think examples of react that use inline jsx lambda's are a simplification that lead to bad habits and bear traps down the path. I am not sure yet if inline lambda's inside the RaJ programs have a similar over head that they are re created each render or equivalent ? 1. Which is why i create a helper app in counter example to see about teasing out the lambda's to named handlers. 2. Is there a way to do tease out handlers like this in current Raj, I could not see an obvious way to do it, possibly switch from a an object of fields to a class might allow this sort of addition with low pain but then you'd end up doing something like react and require properties on this so that class methods had access to the parameters I think. Couldn't see reinventing part of React's behaviour to do this being a good choice long term. 2. Have you thought about how React life cycle properties interact with Raj programs, is it just a case of introducing properties on a React Help component that gets passed call backs do stuff in response to life cycle events ?
Those are certainly more readable. This is purely my own preference but as a last piece of advice: use vertical white space. All of your functions and declarations and comments and everything else are all crammed together vertically. Again, I'll admit this is somewhat down to preference but this: // store declaration var store = {...}; /* state handlers */ function getUser(...) { doAThing(); } function changeUser(...) { doDifferentThing (); } Is far more readable than: // store declaration var store = {...}; /* state handlers */ function getUser(...) { doAThing(); } function changeUser(...) { doDifferentThing (); }
1) many angular legacy apps 2) angular is actually growing
I've recently been searching. I would say its about 10 to 1 react jobs. Are you searching specifically for angular?
There are lots of legacy apps and I imagine they're harder to fill because people can see the industry moving towards React.
https://github.com/as-com/mozjpeg-js 
I hear its a regional thing
Nope, searching for “front end developer”. And most jobs literally have “Angular” as the framework of choice in the job description or many even in the job title.
a lot of mistakes were made in the past
I've found here its mostly companies developing large (hundreds or even thousands of files) enterprise applications that prefer Angular over React (And in my personal experience.. I think that's the right decision) React seems to be used more in software agencies with fast product turnarounds. Also worth mentioning that Vue has gained traction on the job market last time I looked.
To improve React performance, you are going to want to leverage `shouldComponentUpdate`. If you are looking to save on allocations, you'll need to rework your views have something like `&lt;Perf valueForShouldUpdateComparsion={model.myValue}&gt;{() =&gt; ...}&lt;/Perf&gt;.` Notice the use of child render props so that everything under the `&lt;Perf&gt;` component does not get created unless needed. This optimization is much easier using immutable data structures. You can use React lifecycle hooks like normal. You will call callbacks passed down. I try not to involve lifecycle/state but there will be those exceptions. I have not seen performance problems in my Raj projects using the views like I have in the examples. I think the Raj/React performance story will become more clear over time as needed.
Angular in the enterprise is still pretty popular. You won't find many if any angular for public facing stuff. Not even new development on customer facing. There's a fair amount more angular experience out there (such as it is) and so I'd expect that companies make decisions based on availability and comfort level. Legitimate. For what it's worth, I see a lot more React jobs on LinkedIn than angular jobs and my search is for JavaScript. 
I looked, there is some serious redirection and obfuscation going on. Not sure how they’re getting the data to the page but I have suspicions it’s a server side rendered page. Puppeteer is a bit heavy for something like this but I didn’t find another solution 
The same reason there are tons of J2EE/JEE job postings when I search for Java jobs: no one wants to work with a bad tech stack.
Angular gets a shit load of hate, but it’s an extremely powerful framework. I don’t know why everyone keeps thinking React is easier to learn or noticeably faster in performance (some versions of Angular are even faster than some versions of React). That being said, to answer your question, React is all the hotness right now, so everyone is jumping on the React bandwagon. If you threw a rock at a thousand developers, you’d probably hit someone that used React, so Angular devs are harder to come by. I’ve coded in nothing but Angular for my entire professional career, and I’m glad React is all the rage right now, because I get paid a lot more money than I should.
Because it works, has a decent following and has Google behind it. Companies don't necessarily know that React is better (subjective, but I think so), they have a plan and they're hiring for it.
Some technologies are evolutionary steps, not flavours of the month.
You should add a screenshot to the [ReadMe.md](https://ReadMe.md) and a binary to the releases tab. 
I still see loads of angular positions, especially since I'm a c# dev. For some reason if a company is looking for a c# dev that has javascript framework experience, they're usually looking for angular to go with it. React is starting to become a bit more popular, and I think that's because of the push for typescript and React, but maybe i'm wrong.
Looks like .md is a valid TLD
No, the point is that the authenticating server handles the request. So you send them there with a redirect URL, and if successful they'll be redirected. Normally you'll get a token and a refresh token in a JSON response, although it could be header.
Which means one day either we will find a better way of working (obsolesce) or it will get built into the JS engine (evolution) Either way eventually we will stop using it and people will remove it from job specs.
Yes that's how life works, 20 years in anything will tell you that. What's your point, don't learn?
Kind of fail to see why you would be using rxJs for something like Axios http call. It wraps a simple API into a more complexe one. I try and use RxJs observable for web sockets because then i can have this API for continuous calls and operate on the stream of continuously firing events. Thinking of using it as well for things like mouse events. I guess at some point you may want the same API everywhere then you'd convert http calls to rxJs as well. 
You likely need to override key bindings within Draft or set up an onChange handler to keep pages with a maximum length. The general idea is that when a change is about to happen (or just after it happens though that means you’ll probably need to play some games with the undo stack) you check that it won’t make a page too long using whatever method to measure how long a page is (possibly measuring block size?). If the page is too long you slice some data out and across the page break block.
&gt; For some reason if a company is looking for a c# dev that has javascript framework experience, they're usually looking for angular to go with it If they're looking for C# it's because they're heavy in the .NET environment, ie: they like that "all encompassing" solution to their needs, and on the frontend side of things, that's Angular. 
So dumb question but am I right to assume Angular jobs pay more because Angular devs are harder to come by?
When I said React is starting to become more popular, I meant in the c# .net world. 
This for sure. It’s like asking why are there still legacy ASP apps.
Yes, imports will still import even if they're not used. The act of importing will automatically run the code in the imported file even if there are no exports (some imports function this way). If you reference the same import more than once in different files, that import is only imported once and the same instance of that import is used in both files. They share the same memory space.
It is unclear if MySubFile.js is imported in MyMainFile.js. If it is not imported and is not a part of your application then of course nothing that is imported in it matters. If it is imported, then it will be parsed and compiled and will take memory. Duplicate imports should not take double the memory (given that your runtime can correctly identify them as duplicates). Unused imports will indeed be parsed and compiled and will take up memory, mostly because it is impossible for a compiler to know beforehand if your imported module does not contain side effects like modifying global variables. 
Angular at this point is really more of a brand - 1 vs 2 are _very_ different frameworks. I'd say angular2 is probably closer to vue than it is to 1. To your original question, this kind of pattern is quite common for any tech. You don't see jobs posted as often for tech that's newer (not that React is very new anymore), because the people working on it aren't hired as "_____ developers". My team's all React, but we hired JavaScript devs who learned React. Companies hiring on angular are often dealing with larger codebases, and established teams seeking to add/replace a few members. A lot of the angular2 jobs are for currently angular1 projects that the dev lead wants to "someday soon" migrate. One fairly unique distinction is that Angular is unambiguously a framework, and locks you in to the `ng-` way of doing everything (microlanguage in the templates, that godawful $injector thing that makes your variable names actually trigger functional code, etc.) You really must be an "angular developer" (or willing to become one) to work with it. React is simply a virtual DOM with a few lifecycle methods on the components. You never need to google anything like "how to write an if statement in React", because you write an if by writing an if, same as in ecma. Strong ecma fundamentals, functional programming, composition vs inheritance, etc. are the skills I look for in a hire, not "knowing React".
Pretty much ya, the problem these days is companies and even some devs believe in the 1 size fits all solution. Angular is great at what it does, so is React, but the 2 are not comparable, the applications you would build in Angular you would probably nor build in React. They designed to fulfill 2 very different needs, and if you so chose it is possible to build an app using both Angular and React. React is a tool, angular is a toolkit, it comes will all the bells and whistles which in my experience is best used for large scale applications. React on its own is purely there to out stuff on a screen, it does not include anything like services or controllers, api handlers, it's pure dom. That is not to say react cannot be used for large scale apps, but it is just one tool, so instead of grabbing Angular and getting every conceivable tool you may or may not need, you would have to select each one separately. You build up your own tool Box. You want to manage data flow and control you look at Redux or mobx. You want to handle APIs you look at fetch or axios, you want to Connie t the data too the state you look at mobx or Redux. The choices are all yours. Compared to react Angular would be way more difficult to learn, but again it's a tool vs a toolbox. You start throwing in all the extras you may need, the complexity increases. In South Africa where I stay react jobs are big, angular was a few years back but we somehow developed a national hatred for it after Google went and fucked it up the arse at v2, now all the way to 5 they have improved on it quite a hit and fixed a lot of what people hated, hell some just hated it for typescript, I was not really a TS fan, but I do see it's value and in the massive react based app we are building, we added in typescript. However, as of this national hatred and developer migration over too react companies had the choice of having no staff or moving to what the people wanted, so at that point the angular jobs began drying up, and I still get contacted by recruiters as I worked in angular struggling for 6+ months to find anyone willing to take an angular job. That us sort of part of the problem, many developers only know one tool, but that should never be the deciding factor, if a project is best served by being built in angular, then fuck react, its that simple. Don't force the wrong tool on the job just because it's all you know, as developers the core of our job is learning, adapting. If you have actually worked with it, and have valid reasons for not wanting too, fine, still don't go and use the sledge hammer to hang a painting. I have seen the work of these 1 trick ponies, building a single page, literally one of those newsletter sign up pages, 4 or 5 form fields, built in angular with bootstrap. A 1.5mb sign up form, that did nothing other than send your details to a newsletter server. That did not need angular, or react, bootstrap, jQuery, it needed no tools. It needed some css and some and an xhr request.
Lots of finance enterprises (banks, insurance, asset managers) have more or less settled on the angular train. I am guessing NYC has a disproportionately high number of those employers.
Jump is overkill
Can pizza scale?
Because some companies can’t afford to rebuild their entire app on a different stack. They either lack the resources or no ones stupid enough to put their neck out on the line to own such a huge project (high risk with almost zero return.) its the nature of tech. So companies that continue to use old stacks will continue to duct tape their system. 
Yeah I agree with this person. I went to a bootcamp and still found watchandcode extremely helpful.
You’re holding yourself back. It’s time to pick a project and make it, that’s the only way you’ll be able to level up from beginner. While you build your project youll get stuck like all of us, then you’ll google/YouTube it and have a better understanding of the solution rather than just going though tutorials. 
OK, I think I missed that step of what you were doing. What you'd want to do is make a `FormGroup` component or something, which would manage a state for its child components (in much the same way as `CompanyForm` does for its children). Then whenever any of those change, push the changes up through the `onChange` handler as an object (one property for each child). Just attach `onChange` handlers to each child and you can write your form element inline, just giving them each a name, and the state will handle itself. This would work for nesting groups as well, since the child group would push its object state up to the parent group, which would push that up as a nested object to the top of the form. You could even have the `FormGroup` change whether it renders as a `&lt;form&gt;` or `&lt;fieldset&gt;` (maybe depending on if it has an `onSubmit` property?), and then it's just `FormGroup`s all the way down. Here's a [CodeSandbox](https://codesandbox.io/s/48wj48j164) that demonstrates a basic pattern. If you want to do something _really_ fancy, it's probably a better use of your time to learn Redux and something like Redux-Form, rather than to reinvent that wheel, but they're often overkill for simple forms (plus, this stuff is neat). 
Secure cookie
Memory is taken up and it is best practice to never leave unused imports, vars, consts, lets etc. 
There is some truth in this. 
Lol wtf affiliate links are usually banned and generally a dick move, why'd you go and attack this dude???
Angular is much easier to learn compared to React. 
Again with the "OO language". My whole point is that if you want a discussion around particular features of a programming language (like dynamic types, single vs multiple dispatch etc.), then use the correct words for it. You seem to be equating OO with a language that has types. C has private/protected members (effectively, through not putting them in headers), and has pretty good type safety to boot, but it's not a OO language. The whole point of C++ was after all to introduce types to C.
&gt; The example you are using to compare character count is literally the simplest possible situation... Please, feel free to provide a specific example that we can discuss. &gt; ...and not at all representative of what Promise chaining actually ends up looking like the majority of the time. You're obviously not that familiar or comfortable with promises. And I'd guess that you have _no_ experience with even basic functional-programming techniques? That's going to account for a lot of your problem right there; maybe all of it. &gt; Typically, anonymous functions are passed to the Promises with additional inline logic. I know that's the only pattern you see because that's all you're going to get in little throwaway tutorials, but that's a very narrow lens through which to view promises. Or are you really so new to JavaScript that you think this sort of pattern isn't "typical"? ``` const double = (x) =&gt; x * 2 const arr = [1, 2, 3, 4] arr.map(double) // [2, 4, 6, 8] ``` Let's be _super_ clear here: 1. You're way too hung up on this "character count" nonsense, which is a poor metric regardless of which way it shakes out. 2. _Your_ premise is that character count is _literally_ everything. iambread already explained to you, in far too patient and diplomatic terms, that this is nonsense. I'm not nearly so patient nor diplomatic. If you think fewer characters is _always_ superior, as long as the result is the same, then you're an idiot. There are _many_ reasons that a more verbose implementation might be preferred, but readability and testing would be some of the more important ones. 3. Even if promise chaining _were_ to require more characters in a particular instance, it's more expressive, which is a much better reason to use it. Even if async/await _were_ to require fewer characters, it's less expressive, which is a very good reason _not_ to use it. --- Here's a quick test for you to fail. Which of these is the "superior" implementation, and why? ``` // implementation #1 const fetchUser = (user) =&gt; fetch(`http://someapi.com/users/${user.id}`) // implementation #2 const fetchUser = (fetch) =&gt; (user) =&gt; fetch(`http://someapi.com/users/${user.id}`) ``` 
That describes my area very well. Seems like 5 years ago, every company around here all built their products on Angular 1. The majority of the "Angular" jobs I see, are all just maintaining legacy codebases. Especially with financial institutions, they seem to never want to retire "old" tech, and would much rather hemorrhage money into maintaining and patching it. Sometimes come across a company that's in the process of migrating from Angular 1 --&gt; Angular 4/5, but that's super rare in my experience. The vast majority of the migrations I've seen hiring postions for are Angular 1 (or Ember/Backbone) into React. All of the new development projects around here are using React (and starting to see Vue pop up more and more). Haven't heard of anyone lately kicking off on a greenfield with Angular.
In bigger organizations (like, Fortune 500) -- the HR department tends to have copy/paste templates of job descriptions for postings. If IT requests another "Front-end Developer" , they will dig out their good ol' trusty "Front-end Developer" job description, and post it right up. Pretty easy to spot these, and pretty fun to try and guess what year/month they were written. Keywords might include "jquery" , "LESS" , "dhtml" , "grunt" , "ruby on rails"
Why is it you think you can do string.toLowercase()? Because a string is an object! I swear the level of competence here at here at times.. And yes not EVERYTHING is an object, but basically everything you can assign to a variable is. 
I'm using hackerranck. Has lots of excercises should keep you busy for a while.
Are you refering to typescript out of the box? If that’s the case then you should probably elaborate on that
The only devs that would say this havent used React imo. I have 8 yrs in the game and worked react/ang/vue. Angular is typical over engineered google shananigans. The component api is horrible and dependency injection in js is completely unecessary. That and the frameworky things that make angular appealing are probably better replaced by micro libs. React component ecosystem is far more mature. What makes angular easier to learn? Even their docs are subpar.
Hackerrank is a great resource, it'll give you more abstract problems rather than just "how to make X".
If you are a beginner, I would suggest freecodecamp. They have thousands of interactive coding lessons and you can earn certificate by doing projects. 
Visual studio code and google chrome
AngularJS supposedly huge in India
I woudlnt say this is the case in sweden. Most companies here sit on a react stack regardless of their size. I’ve never seen a vue ad here, would be fun to hear how companies work with it
In what world were Prototype, Backbone, and especially *jQuery* flavor of the month? Pick the right tool for the job definitely, but you make it sound like there's almost no jobs that React is good for.
I dont think the component api is horrible, can you elaborate? I think the global namespacing in DI is the biggest flaw i encountered. 
I can't force an opinion on you, that's correct. But these arguments aren't very strong, in my opinion. If you've typed the entire app with interfaces, adding a new node on an object is very simple, it'll probably say something like: function test(arg: IArg) { ... } Then you simply CTRL+Click at the IArg, and the file containing that interface will open, and you can add a node. It literally takes 10 seconds. If you're reusing the same node from (particularly) the backend, it's also very easy to forget where else this object is used, typescript will automatically notify you of all the places this interface is used, if there's problem, such as removing, or changing a node. What strikes me on this thread is that nobody, even though pro-dynamic-typing seem to accept the positive features of TS, to clarify, I can't understand what's wrong with type hinting, how a programmer can deny it's pleasing to get help when, for instance, updating a really old component where you don't remember all the steps, updating usage of an object will be so easy as TS will tell you what nodes exist under that object. I can't understand how anyone couldn't appreciate this. 
Angular comlonents do not feel like just plain ol functions like the way react can. It also doesnt feel like you are coding js when dealing with angular components state and even creation. Its so much configuration like borderline ridiculous to just make a button with some style. Also there are abstractions for inputs and outputs whereas its more natural to work with a state map or props in react. In angular I also find composition of components to be very wonky as well.
&gt;Please, feel free to provide a specific example that we can discuss. Here's a snippet from a project I'm working on: let results = { id: activity, children: [], time: await this.derivation.timeSpent(activity, frame, agent) }; let children = await this.derivation.children(activity); for (let child of children) { let time = await this.derivation.timeSpent(child, frame, agent); if (time.current || time.running.length) { results.children.push(await this.derivation.hourBreakdown(child, frame, agent)); } } return results; The structure of the code should reflect the structure of the underlying algorithm. If I'm using a procedural language, I want to structure my code in a procedural fashion. We are not comparing procedural programming to functional programming, we are discussing various techniques of handling asynchronous operations in a procedural programming language. &gt;You're obviously not that familiar or comfortable with promises. I'm as comfortable with Promises as anyone could be. &gt;And I'd guess that you have *no* experience with even basic functional-programming techniques? That is also incorrect. I use functional techniques fairly often in my code, although I do not force my code into a functional structure unless the particular problem lends itself to a functional solution. &gt;I know that's the only pattern you see because that's all you're going to get in little throwaway tutorials, but that's a very narrow lens through which to view promises. My exposure to Promises hasn't been through "throwaway tutorials". I spent years working with asynchronous programming via callbacks before Promises were introduce into JavaScript, and a long while with Promises before I started using async/await. Not that it's relevant to the discussion, but I've been a programmer for \~15 years. &gt;Or are you really so new to JavaScript that you think this sort of pattern isn't "typical"? Not sure how you derived that from what I said. I use map functions quite often. &gt;You're way too hung up on this "character count" nonsense, which is a poor metric regardless of which way it shakes out. That is only a fragment of my argument. My initial statement was that if all else is equal, less characters is better. I stand by that. &gt;*Your* premise is that character count is *literally* everything. It isn't my entire premise, I was just getting lazy with my rhetoric. My previous comments expanded on my arguments. As I said *if all else is equal*, less characters are better. However, my argument goes beyond that. await/async does not interfere with the procedural flow of the code. Again: this is not a procedural/functional debate. The context of this discussion was within the procedural paradigm. If your argument is that Promises when strictly employing functional techniques -- fine, but that's not the discussion we're having. &gt; If you think fewer characters is *always* superior, as long as the result is the same, then you're an idiot. Please reread my comments. My statement was *if all else is equal, less characters is better*. I have never made the claim that fewer characters is always better. &gt;There are *many* reasons that a more verbose implementation might be preferred, but readability and testing would be some of the more important ones. I addressed this in an earlier comment. If fewer characters results in less information being conveyed, then all else is **not** equal. My argument isn't simply that await provides better clarity because it uses fewer characters, however, the fact that the are fewer characters does aid in visual parsing. And in this case, the additional characters used in Promise chaining are *not* conveying additional information, it's merely more syntax to read and write. &gt;Even if promise chaining *were* to require more characters in a particular instance, it's more expressive, which is a much better reason to use it. Even if async/await *were* to require fewer characters, it's less expressive, which is a very good reason *not* to use it. You've lost me there. How is promise chaining more expressive? Simply because it implies a sequence events? &gt;Here's a quick test for you to fail. Which of these is the "superior" implementation, and why? Huh? Is this supposed to be a trick question? Neither is superior, just different implementations for different purposes. If it is necessary to implement the fetchUser algorithm in such a way that the delivery mechanism of the request can be reconfigured as needed, one would opt for the second variation. If such a requirement does not exist, the second implementation would be needlessly complicated. A situation like that has never arisen for me, but I suppose it could occur. 
that logo looks a LOT like Bear’s. :(
Good idea, thanks!
There's a bunch of reasons I can imagine. 1. Many legacy (Angular 1) apps need maintenance because many people flee those projects that refuse to update; 2. Web projects in general are still growing strongly, Angular is one of the popular ones just like React; 3. Many companies realise that with Angular as your package of choice you can have back-end developers work the front-end, too, so it's more widely adopted; 4. I see a lot of Angular developers (front-end specialists) switching to React and never looking back, leaving a gap for the aforementioned back-end specialist picking up what they leave behind. But other than that, the web-industry is simply growing. I think all popular frameworks/libraries have a steady growth. Angular is amazing, and so is React. It's a good time to be a coder :)
Companies are more likely to trust a google technology than a facebook one.
In Ur browser &lt;3
1. There are a shitload of Angular 1 apps in maintenance, from before React existed 2. Angular is still very popular in big companies, enterprises/IT services etc but not in the startup world
Imports are run at the time they are imported - which generally is at the start of the program. Imports are only imported once - so both MyMainFile and MySubFile will refer to the same {A} from fileA. The code inside fileA will run regardless of whether or not A is referenced. If you were to put a console.log inside fileA outside of any functions or classes etc - you would see when it is run.
Hey alex! My apologies for late reply. I'll take note of your suggestions. Thank you for the help!
There's a looooot of legacy Angular 1.x apps out there.
And not so big in the UK.
&gt;it is possible to build an app using both Angular and React I think your core message is good here and I agree. But if **anyone** ever considers trying to use both angular and react on the same project just stop what you are doing and don't. You will have just an awful experience.
I'm so saddened that I can't use most of these awesome new browser features without having to rely on an external library.
Please take a look at the list: [https://medium.freecodecamp.org/the-10-most-popular-coding-challenge-websites-of-2016-fb8a5672d22f](https://medium.freecodecamp.org/the-10-most-popular-coding-challenge-websites-of-2016-fb8a5672d22f)
I’m from India. React Developers are harder to come by here. The shift is still happening. And people are moving to React, but a lot more Angular devs are available than React. Primarily because React enforces a pattern. I see a lot of Angular devs using jQuery to get some work done because the Angular way is apparently harder. Currently, React pays way more than Angular in our market. 
Nice!
These numbers refer to Angular versions, not an enumerated list of reasons. Good show!
Totally agree. Indian myself. Angular devs still use jQuery, even when it’s not recommended. They want things to be done the jQuery way, they see the new frameworks as a nuisance. React requires an tectonic shift in the way you approach front end development, something pre-framework devs don’t feel like breaking their heads on. 
&gt; I don’t know why everyone keeps thinking React is easier to learn I'd argue it is easier to learn since there's no custom syntax for templates. The barrier for entry is much lower for someone who already knows html/js 
Replicated WhatsApp web UI in JAvascript check it out here guys [https://dorochat.net](https://dorochat.net/).
As much as I’m happy to see variables come to CSS, it honestly feels like far too little, far too late. Preprocessors like Less/Sass are already in the toolchain for many (if not most) web-apps/sites, and have been for many years. And very few people will be dropping them to use “native” CSS variables when they still have to rely on preprocessors for so many other valuable features like nested selectors, functions, mixins, etc.
That's an awful idea, by no means does being possible === good. 😂
Don't be sad, it wasn't that many years ago that browser vendors only updated every year or two these days new features are being added every month so it doesn't take long until they reach mass adoption. 
Thanks for sharing this detailed article about the usage for css variables! I'm looking forward to use them in my next pet project. :) 
i really like https://www.codingame.com/
Please remove that scroll highjacking - can't read the article :(
Which is what we will be saying when there are loads of over complicated React apps that could have been written in 1/10th of the code in Angular.
I purposely wouldn’t allow Bootstrap in my most recent Angular rewrite, because I didn’t want jQuery as a dependency just to avoid that from happening. I can’t stand it when people do that.
It’s exciting to see these land. We’ve been using them for years with postCss, but now they show up nicely in chrome dev tools. 
&gt; and dependency injection in js is completely unecessary What is it about JavaScript that makes this design pattern unnecessary ? &gt; That and the frameworky things that make angular appealing are probably better replaced by micro libs Maybe for a startup or app that wont exist in a few years this holds true. But large organisations that tend to write software that just works, and plan to exist for more than 5 years will value knowing the framework will still be supported. Micro libs are subject to community fragmentation, and if you chose the wrong one, you need to switch a few years down the track.
React is 'popular' because most of the developers with time to blog, and evangelise come from startups, and 'tech' companies. But these developers make up a teeny tiny fraction of all the developers in this world. Keep that in mind. Most apps that get written are not public facing like Facebook, Insta, Gmail or your favourite startup. It is applications that drive and support non-tech businesses, government departments etc. These organisations have different needs, and value different aspects of libraries. Start ups are less likely to care if the library is likely to be supported in 5 years, whereas large organisations are very concerned with that because they like to write software that works and focus on their core business. Not spending time updating to use latest micro lib that is now defunct. If a company was making a large but simple CRUD app that was for internal use on a predictable operating environment, choosing React would be a poor choice compared to Angular in this case. I guess the point I am making is that Angular is still a great choice for certain scenarios; and I suspect those scenarios are more common. FWIW: where I work now, React is 100% the correct choice. Have used Angular for 3 years and React for 2 years.
But apparently pretty big in Japan 
&gt; What is it about JavaScript that makes this design pattern unnecessary ? A component is a function, therefore DI isn't needed: const A = () =&gt; &lt;div&gt;hi&lt;/div&gt; const B = &lt;A /&gt; transpiles to: const A = () =&gt; createElement('div', null, 'hi') const B = () =&gt; createElement(A) // A as a reference In Angular the template is a string, and everything inside it, from components to other references or locals has to be injected, which *is* completely unnecessary.
Do you own the iframe content or is it on another domain? If it's from a different domain, you're basically out of luck - iframes are sandboxed for security reasons, so you're not going to be able to just run your javascript (the parent frame) in the iframe (child frame). If you are serving the iframe's contents, then just add references to those two scripts to the frame contents - no need to inject anything. The one hack I think you could do to bypass the iframe sandbox would be to leverage a browser extension that has visibility and control over the source of child frames. An extension could inject JS into the iframe for you if that solves your problem.
Awesome, waited a long time for this, can't wait to give it a try.
The first code is an assignment and is evaluated "all at once". The order in which you define the properties does not matter, and the scope in that assignment is not the object but its parent scope. This means the this in the first example (this.a) is not referring to the object you are defining. In the second example, even though you are using a comma, is assignment is a separate statement, wrapped inside a function. The first assignment is evaluated and then the second, and therefore this.a has already been assigned.
&gt; posted on: 25-jun-2018 &gt; &gt; Right now, only Firefox supports CSS variables out the box. However, versions 49 and up of Google Chrome will also ship with the feature enabled. lol
There is some push in my organization to drop CSS preprocessors, which I am against, but the only problem I have with CSS custom properties is browser support. IMO they have a different use case as these can actually vary at runtime, while e.g. SCSS variables are constant after compilation. 
Yea, but for no reason other than name. If google maps or their seach engine used angular that would be one thing but as far as I know they dont. Facebook actually has heavily used web code using React.
&gt;Angular at this point is really more of a brand - 1 vs 2 are &gt; &gt;very &gt; &gt; different frameworks. I'd say angular2 is probably closer to vue than it is to 1. Angular 2 is *not at all like Vue*; if anything, *Angular 1* and Vue are similar.
Yeah that stuck out, given we're on 67, either copied from an old article or misinformed? I've certainly been using this in chrome for about a year with no issue.
But not so big in Sweden
Looks like they reskinned the cluster module and called it threads.
At some level there are people who can judge frameworks not simply on popularity, but informed engineering aesthetics.
For op for clarification, if you have let i = 0; export const aaa = i++; each `import {aaa} from "file"` will result in aaa === 0. It will only be run once.
You should read about `this` and what it means. You have an [explanation here](https://www.reddit.com/r/javascript/comments/j2j8b/the_this_keyword_is_extremely_simple_and_doesnt/) (be sure to read the comments for additional insight) and, of course, [the MDN article on the subject](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this). IF you still need more explanation, or for similar questions, visit /r/LearnJavascript
I suspect this was a little tongue in cheek but seriously, if you're new to web development one of the most powerful tools you have is the degugger in your favorite browser. Right click on things and "inspect element", then work on targeting that element with js and modify it somehow. You can execute JavaScript right from your browser's console. Online courses will help a ton with learning how the different logical operators work but debugging in your browser is something you're going to have to get good at.
Thanks, I added some spacing as well. Still, my main interest is what I should do to get early adopters / contributors, as I feel that further cleaning up the web page is not enough. I plan to make it much more interactive to demonstrate the possibilities of the framework. The interesting part of Reactive Relations is that the more complex the application that one wants to write, the more advantage RR gives over other frameworks. 
Thanks for a great resource! (And hope you commit yesterday's results before too long! :-))
Thanks. Assuming on the first example the scope is the global scope, why is something like this not working though: const o = { a: 1, b: this.o.a }; 
What is the reasoning behind the push to drop preprocessors?
This article doesn't do it much justice at all, everything demo-ed here is already possible with the cluster module. There is however a major difference: threads support shared memory, and cluster does not. 
I was about to be all negative, but &gt; Workers, unlike child processes or when using the cluster module, can also share memory efficiently by transferring ArrayBuffer instances or sharing SharedArrayBuffer instances between them. So apparently they do have some form of shared memory semantics, albeit seemingly pretty limited.
Angular is hard to come by because no one wants to write it.
css variables can be used together with preprocessors though. for example you can use less/sass/whatever for the styling but use css variables for colors and fonts for easy theming if you have several mandants that have the same page but different colors and font.
`o` doesn’t exist yet, it’s still being instantiated. think of it as the value/content is being created but it hasn’t been given a name, or more accurately it hasn’t been assigned a reference in memory, until it gets to the left side of the equals operator. Therefore you can’t reference `o` yet. Since this is JavaScript (and const is referring to the object, not the properties of the object) you could set the value of `o.b` after `o` is instantiated. `o.b = o.a;`
css var has [quite high compatibility](https://caniuse.com/#feat=css-variables) by now though. unless you need to support IE 11 and under
also &gt; Variables can be combined with another recent addition to CSS - the calc() function. calc is not exactly brand new... 
Oops! Yes that's what I'd meant. Edited. Thanks.
But you have to learn all the separate tooling as well, which isn’t necessarily always going to be the same, so you may end up having to know multiple other things as well.
Hi /u/jscraft, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Atuoboxing. The non-object string primitive gets temporarily wrapped in a String object allowing you to use it as though it were an object. Here's a little snippet that lets you get those objects: // non-strict mode function getThis () { return this; // boxed } var myStr = "hi"; var boxedA = getThis.call(myStr); var boxedB = getThis.call(myStr); console.log(typeof myStr); // string console.log(typeof boxedA); // object console.log(typeof boxedB); // object console.log(boxedA === boxedB); // false
Thanks for sharing. I would love to learn more about integrating JS and AI.
That's cool. Definitely saving this one so I can refer to it later.
For people wondering why this is useful, I am working on a module bundler and it needs to parse thousands of JS files, parsing is a sync operation. It performs terribly when done in a single process. Spawning a worker process pool works but the IPC overhead can quickly weigh you down (a file's sources + compiled contents + sourcemap can be multiple Mbs easy). This solves the problem because we can do the sync file parsing and transforming in separate threads and make "shared array buffers" and transfer their ownership
IE11 is a big unless...
but that argument applies equally to angular as well(or anything really). At the end of the day the syntax for react is just html/js + a few rules and the syntax for angular is html + a templating language. 
Why would one care? Is it a React thing?
Are there people who don't think threads are useful? To provide another example: I'm doing lots of number crunching on data sets with tens of millions to billions of points. Filtering numbers with certain properties, filtering numbers within a certain region, or just transforming arrays from the binary disk format to a another binary format that is more suited for processing in memory or rendering. This kind of tasks benefits enormously from parallel processing and it keeps the main thread responsive until the results are available. 
Not really. Angular is a complete framework, so your app is just all Angular. React is just the view, so you could have anything else running with it. It's basically always Redux, but I've seen other things being used with it.
many enterprise companies (a bank in my case) use angular because it is fast for their c# and java developers to understand it. it is less opinionated so code maintainability is good
Which would be an argument as to why react is simpler, you can use existing tools with react, with angular you need to learn how angular works. You don't need redux or anything to write react code, if you already have a webapp with good seperation of concerns it becomes pretty easy to rewrite some components in react, the same can't be said for angular. 
It's a functional thing, or even less specific, a way of reducing bugs.
React encapsulates the framework internals while Angular is constantly bleeding its guts everywhere. I've spent hours crawling through Angular code to find why some weird behavior is happening. I've only needed to do that once with React in 5 years. It'll take you longer to learn the $digest cycle and all the common bugs it causes than to learn all of React. After learning React, I architected several projects in Angular using React patterns (one-way data with flux at the time). Those projects were regarded as super-easy to work on by the other devs and it usually wasn't too long before they jumped ship to React.
React, by itself, is simpler, yes. But you can't just build an enterprise React app. You will always need more tooling. So you will always need to know other tools, whereas with Angular, it's always Angular. I don't know why it would be difficult to rewrite a component in Angular.
i think this is very biased by your personal experience. i haven't seen a single angular job in nyc, and have only seen react jobs.
Throw this up in a jsbin or codepen so you can get some help ;)
I don't think there is anyone that doesn't doubt the usefulness of threads, I think there may be people that wonder what the benefits are over spawning a worker pool as /u/aneesiqbal went on to explain.
they're just functions the same way a sandwich is just a bunch of ingredients. if the functions are not arranged properly and with the correct intent, you'll have a sandwich that looks like [this](https://cdn.foodbeast.com/content/wp-content/uploads/2012/05/state-sandwiches-prints.jpg)
The actual point of this article is to learn how we can use any library (not just HTTP) and warp it with RxJS. This articles also teaches how to clean up resources when an observer unsubscribes. Wrapping anything with RxJS is very easy and I haven't found any articles which explains that. Hence, using Axios with RxJS was a simplest example to convey that message.
Keep in mind, most applications are already written this makes it easier to rewrite in in something like react since you are just swapping out a single layer instead of needing to rewrite an application. If someone already knows a state management container or a way of making requests they can use this with React. With angular they need to learn to do it the angular way, which is great for consistency but also increases the learning curve. To be honest this makes it unfair to compare the two since one is a way of rendering HTML and the other is an Framework. It's also why React is easier to learn, there's less content.
Hi /u/Fasyx, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/Nicksil, this comment was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/dummyuser2, For javascript help, please visit /r/LearnJavascript. Thank you!
Supposedly, we don't need them anymore (but would still be using postcss for autoprefixing and minifying). I'm all for cutting useless build steps, but I think the utility provided by these tools (in the form of structure and mixins/functions) is still invaluable, even if we elect to replace compile-time variables with runtime ones.
Hey, I don't mind posting the direct link for courses as well. [https://www.udemy.com/the-complete-javascript-course](https://www.udemy.com/the-complete-javascript-course) [https://www.coursera.org/specializations/java-programming](https://www.coursera.org/specializations/java-programming)
I understood some of those words!
I see this argument for Angular all the time, it's a single framework therefore it's somehow superior, yet continually saying "oh they're both good in their respective use cases". It's really simple, Angular is liked by large companies because your choice is limited, there's cohesion between code bases, and performance on the frontend is (generally) not super important (large bundles are usually ok for apps behind the firewall, user experience isn't driving sales, it's helping internal employees). React is liked by freelance because they know their own stack, and can quickly turn around features.
Oil &amp; Gas too. Exxon full on angular. 
[https://media.giphy.com/media/1M9fmo1WAFVK0/giphy.gif](https://media.giphy.com/media/1M9fmo1WAFVK0/giphy.gif)
Why have two electron apps when you can work with just one :) Seriously though, the new VS Code web view API really opens up possibilities, and I wanted to give it a shot.
Relatively few of those Angular 2 jobs are Angular 2. Most are "we use Angular 1, so we're going to move to Angular 2 some day". The real reason is bad demand to salary ratio. If you're going to work a soul-sucking legacy maintenance nightmare using a poorly-constructed framework, you are going to do it for one of two reasons. The first is that you cannot get another job. The second is that you are paid a huge amount of money. If you know Angular 1 well, the chances are good that you have at least 5 years of JS experience. With the move to web apps and JS everywhere, experienced devs are in high demand. Most Angular devs have moved on to other (better) frameworks like Vue or React. In order to learn Angular 1, you're going to be devoting a month to learning and a few more to all the edge cases. Most of the stuff you'll learn is specific to Angular 1, so it's not a great time investment considering the framework's days are numbered -- and unlike Java, web projects don't usually have a multi-decade shelf life. Because of this, few new devs want to touch Angular either. Nobody's forced to take an Angular job and nobody wants to. The companies *should* be offering large pay incentives, but a surprisingly large number of companies still believe that front-end devs should have super-low salaries. They want senior devs, but often don't even offer that amount of pay. If they want someone to get on their project, they need to offer 15-20% over market rates. note to companies: market rate for senior web app devs isn't the market rate for last generation's front-end designers and it isn't the median rate of all "front-end" people. It's the market rate for web app developers (2x that of median for all front-end) with senior experience (another 0.5-1x over median for all front-end devs). I've interviewed for a ton of web app jobs paying "market rate" and wondering why no decent dev (let alone good ones) were interested.
There is many solutions already wrote, I didn't think that it so difficult to find it https://stackoverflow.com/questions/10333971/html5-pre-resize-images-before-uploading
I must be really awesome, because I can use var without its tragic reassignment flaw even causing me the slightest difficulties!
I see what you're saying. Yeah, I've done quite a bit of upgrading Angular versions, and there are times where I wouldn't say it's so much learning curve, but more work has to be done, because you're dealing with multiple layers.
If V8 is the engine for Chrome, then the runtime would be the default libraries that are available to the engine - the Window object, the DOM API, etc. 
I develop new verision of WhitestormJS framework :) https://github.com/WhitestormJS/whs.js
[removed]
Sell Prettier and eslint to your team. Format on save and tadaa, no more vars (and let only where needed) in the codebase :)
Sorry, not a fan of const everywhere https://jamie.build/const
The 90s called
then it could have been done in 1/20th of code using proper React ;)
I am on my third multi million usd react based enterprise project in the finance industry, one for banking, another investment and now insurance.
Just my 2 cents: Angular is a more complete solution than React (out of the box). React intentionally left out routing, advanced state management, and other things. That means your developer have to manage upgrades on all of those things. Of course you can sub out any of the Angular solutions as well and be in the same boat, but I would wager a guess that most Angular shops don't do that. I think that is really appealing to a lot of places (in fact I know it is because I interviewed for senior level positions at places using Angular and that was exactly what they told me). I personally prefer React but they are a lot of similarities between the two now. I wouldn't mind doing either (or Vue for that matter). 
And? Multi-million USD project just means you're working in corporate. What does project cost have anything to do with what frontend framework you're going to use?
Uses beautify and vue-beautify for my code, what is the difference between them and Prettier ?
Are they green threads or native threads? Are we going to get the Atomics API that Mozilla started building in Firefox?
&gt; Are there people who don't think threads are useful? &gt;I'm doing lots of number crunching on data sets with tens of millions to billions of points. Filtering numbers with certain properties I think there are people wondering why you would do that in Javascript.
The on*XXX* attribute is the oldest legacy method of assigning an event handler. `addEventListener()` is the current method. It's not a requirement to use the latest method, but if you use the legacy method and web browsers have dropped the legacy method, your website would be broken.
Hi /u/Jimyos, For javascript help, please visit /r/LearnJavascript. Thank you!
Instead of posting the code here, we strongly advice you to post it in e.g. a codepen. That way, people get a better idea of what you're trying to solve without having to go through your logic immediately.
Much easier and faster to build stuff in JS than, say, C++. And now it becomes much easier and faster to build multithreaded stuff in JS than, say, C++.
Primitive values do have constructors. e.g. the `Boolean()`, `Number()`, `String()`, etc. constructors. As pointed out by the `constructor` property of any value. e.g. `(9).constructor` is equal to the `Number()` constructor, and `("").constructor` is equal to the `String()` constructor. Keep in mind that in JavaScript, all values internally are objects.
I would not touch corporate with a 100ft pole, those people have entire vegetable gardens growing out their arises.
 &gt; The user might click the button much later after the code was executed. The catch with this code is that the data from the outer scope is still available in this function and therefore can’t be garbage collected – even if it is not needed anymore. It is interesting that while in other browsers this is true, in Chrome, it isn't any more. Chrome is now far more aggressive in mark-and-sweep than other browsers. This can be a bit maddening when you are trying to debug a script via some asynchronous callback: any variable from a parent scope often becomes undefined when viewed from inside the callback. To view the variable, you often need to explicitly reference it inside the callback and drag it into scope. For example: function foo() { var x = 1; setTimeout(function () { debugger; }, 1000); } foo(); In Chrome, I get a ReferenceError if I try to inspect `x` at the debug breakpoint. In FF and Safari (and I presume IE), I see it is `1`. Even arguments get purged.
That's such a terrible argument, and its suggested alternative usage for `const` is objectively less useful than how `const` is normally used.
I think you already are...
Thank you for the tip! I edited now :)
This is a caracterized shit load. Please stop developing for the web right now.
Why would you limited to sharing immutable buffers? That would obliterate performance in many use cases.
Python? ¯\\\_(ツ)_/¯
Build something small like a calculator. Facing real problems is the best way to learn.
As someone who went from Angular to React, I can say that without a doubt React is vastly superior to Angular. 
[removed]
Less opinionated? 
Does Python run in browser? Then its better to write it in something that can, and work on platform to be faster than Python.
But Google abandons projects all the time. Having google behind a project should give very little assurance on the projects future 
yup. in other frameworks, u have a lot of choices to implement things (like routing) which can cause fragmentation. in angular, u have the default and preferred way of doing things (but you are still free to insert other libraries) 
One is Prettier... I'll see myself out.
Browser argument is valid but speed really isn't. I've seen both benchmarks proving javascript and python are faster. It's just a matter of what you benchmark. In my experiences, python (with numpy) is faster for things like crunching data points etc. which is why I would recommend it over javascript. Python also has much wider support for any math/data science related jobs, so you're more productive and need to write less code. You can still output your results through html+js but that might be overkill depending on what you are trying to achieve.
Not a fan of Python. Besides, Python is quite slow [1], so doesn't make much sense for me to do performance critical tasks in it. Yes, there are some C bindings to do some things fast, but the same can be done in JS. I tried to do some point cloud processing in Python in the past but the performance was abysimal. [1] https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/node-python3.html
Agreed, I have Angular on my resume since I used it for a couple years, but I refuse to work with it again. Opening up old legacy Angular-1 apps feels like opening a drawer filled with tangled cables and wires. A lot of code needs to be unraveled in those unwieldy beasts 
You're so cool. Thanks for the kind words.
1. Avoid using **non-arguments** Things such as "because it's the new `var` are non-arguments, i.e. they hold no argument in themselves. They are fluff. What's more, they are _self-evident non-arguments_, meaning that everybody that reads it, automatically sees it contains no argument and it's just fluff. Using this type of non-argument ("it's cool", "it's the new thing") actually works **against** you when trying to convince anyone of anything. Other arguments you may have, it makes them appear weaker by association. 2. Your TL;DR fails to make an argument and fails to be short enough Your TL;DR such be first of all short enough so that people who won't read the whole thing because it is _too long_ will instead read this. If the TL;DR section is too long in itself, they won't read anything. Also, TL;DR shouldn't really give you a summary, but the **conclusion**, the argument that explains (in a few words) why should they care. Also, having a "TL;DR for the TL;DR" is just absurd. 3. You give information that is too technically detailed but fail to mention why it's relevant (and it is not, to be honest) You mention too much the `VariableEnvironment` and `LexicalEnvironment`. How `var` creates variables in the first and `let` and `const` in the second. But you fail to explain what those mean and why they are relevant at all. In fact, mentioning these technical details is unnecessary. It feels like trying to appear more knowledgeable by mentioning technical details, but serves no other purpose. This, again -as with the fluff arguments-, will actually work against you and make your arguments appear weaker, not stronger. 3. Remove the line that says: "This should be enough for you to stop reading here." 4. You simply repeat things too much I'm at 1/3 of the whole thing and I must've read at least 6 times the **same explanation** about what can be redeclared and reassigned and what is hoisted or not. This repetition, once again, does **not** help you drive your message but actually detracts from it. You're not giving arguments but just trying to convince through repetition. That doesn't work, no matter how clever you think you are by trying to do it. 5. Remove the whole thing on "learning a natural language" It doesn't really present any interesting argument. In fact, the part of that that actually mentions `const` does not really make such a good argument **for** `const`. What is the point? That some new features have made the language more familiar to those coming from other languages? "Oh, but then again, beware! `const` only _looks_ familiar; it is actually different!". I really don't see that such an argument can be considered as positive or _in favor_ of `const`. 6. Do _not_ use "Detours" when presenting your arguments. 7. Do **not** use a fictionalized, imagined, manipulated dialog where you put words in the mouth of the people you're trying to convince. Just **don't**. 8. There is a FAQ in the middle of your explanation. Bum. Right in the middle. For no reason at all. 9. Now there's **a whole section** named "const is the new var" and I just don't want to read anymore.
Shared mutable buffers is an anti-pattern in much of the distributed compute industry. If that's your performance bottleneck, you've likely got the wrong tools in place, or you don't need distributed computing.
 Hi guys, i love me too Atlaskit. I found it really complete and powerful, so i decided to develop an Atlaskit like UI kit, based on Bootstrap. If you find it cool and give me thumbs up, you can check the repository [https://github.com/lucaros97/bootstrap-atlaskit](https://github.com/lucaros97/bootstrap-atlaskit) 
We are literally in Reddit thread about article which will give node thread support and to be as good as python for those tasks. Both python and js are very easy, python won because of performance, and node now strikes back. You always want to present your data as scientist. And IMO, tabs instead of braces are helluva ugly and weird.
Yeah, I said "limited" because it wasn't clear to me how mutex works.
I imagine they're green threads using separate stacks and context switching. Haven't checked it out yet though so take what I say with a grain of salt
&gt; Not a fan of Python. This is indeed the most important when choosing a language! Choose whatever makes you happy/productive :) 
I think I understood the sharing part wrong. What I'm usually doing is transfering ownership so that a thread can work on it, without having to allocate a new buffer or copy things. Mutable buffer but only one thread working on it at a time. 
The whole idea behind writing this article was actually making javascript developers aware about functional programming because it can actually help us write better code. But I think I certainly failed to do that. HAHA Instead of reading my article just read this [https://github.com/getify/Functional-Light-JS](https://github.com/getify/Functional-Light-JS) far much better value. Thanks
:)
my code so far :( &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;DOM&lt;/title&gt; &lt;script&gt; function bold() { var paragraph = document.getElementById("a2"); var bold = document.createElement("b"); var replace = replace.replaceChild(bold, replace.firstChild); bold.appendChild(replace); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id="a1"&gt;Paragraph 1&lt;/p&gt; &lt;p id="a2"&gt;Paragraph 2&lt;/p&gt; &lt;p id="a3"&gt;Paragraph 3&lt;/p&gt; &lt;p id="a2"&gt;Paragraph 4&lt;/P&gt; &lt;p id="a5"&gt;Paragraph 5&lt;/p&gt; &lt;p id="a2"&gt;Paragraph 6&lt;/p&gt; &lt;p id="a7"&gt;Paragraph 7&lt;/p&gt; &lt;p id="a2"&gt;Paragraph 8&lt;/p&gt; &lt;p id="a9"&gt;Paragraph 9&lt;/p&gt; &lt;p id="a2"&gt;Paragraph 10&lt;/p&gt; &lt;p id="a11"&gt;Paragraph 11&lt;/p&gt; &lt;p id="a2"&gt;Paragraph 12&lt;/p&gt; &lt;p&gt;&lt;input id="idBold" type="button" value="bold"&gt; &lt;script&gt; document.getElementById("idBold") .addEventListener("click", bold); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
my code so far &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;DOM&lt;/title&gt; &lt;script&gt; function bold() { var paragraph = document.getElementById("a2"); var bold = document.createElement("b"); var replace = replace.replaceChild(bold, replace.firstChild); bold.appendChild(replace); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id="a1"&gt;Paragraph 1&lt;/p&gt; &lt;p id="a2"&gt;Paragraph 2&lt;/p&gt; &lt;p id="a3"&gt;Paragraph 3&lt;/p&gt; &lt;p id="a4"&gt;Paragraph 4&lt;/P&gt; &lt;p id="a5"&gt;Paragraph 5&lt;/p&gt; &lt;p id="a6"&gt;Paragraph 6&lt;/p&gt; &lt;p id="a7"&gt;Paragraph 7&lt;/p&gt; &lt;p id="a8"&gt;Paragraph 8&lt;/p&gt; &lt;p id="a9"&gt;Paragraph 9&lt;/p&gt; &lt;p id="a10"&gt;Paragraph 10&lt;/p&gt; &lt;p id="a11"&gt;Paragraph 11&lt;/p&gt; &lt;p id="a12"&gt;Paragraph 12&lt;/p&gt; &lt;p&gt;&lt;input id="idBold" type="button" value="bold"&gt; &lt;script&gt; document.getElementById("idBold") .addEventListener("click", bold); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
my code so far and I know its not a loop.... &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;DOM&lt;/title&gt; &lt;script&gt; function bold() { var paragraph = document.getElementById("a2"); var bold = document.createElement("b"); var replace = replace.replaceChild(bold, replace.firstChild); bold.appendChild(replace); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id="a1"&gt;Paragraph 1&lt;/p&gt; &lt;p id="a2"&gt;Paragraph 2&lt;/p&gt; &lt;p id="a3"&gt;Paragraph 3&lt;/p&gt; &lt;p id="a4"&gt;Paragraph 4&lt;/P&gt; &lt;p id="a5"&gt;Paragraph 5&lt;/p&gt; &lt;p id="a6"&gt;Paragraph 6&lt;/p&gt; &lt;p id="a7"&gt;Paragraph 7&lt;/p&gt; &lt;p id="a8"&gt;Paragraph 8&lt;/p&gt; &lt;p id="a9"&gt;Paragraph 9&lt;/p&gt; &lt;p id="a10"&gt;Paragraph 10&lt;/p&gt; &lt;p id="a11"&gt;Paragraph 11&lt;/p&gt; &lt;p id="a12"&gt;Paragraph 12&lt;/p&gt; &lt;p&gt;&lt;input id="idBold" type="button" value="bold"&gt; &lt;script&gt; document.getElementById("idBold") .addEventListener("click", bold); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
Nah bra, nothing corporate about my company. If it were, I would have been fired on day 2.
Ah, yes, "functionally" immutable is often considered good enough! I've worked with frameworks that technically had shared mutable buffers, but it was very difficult for the wrong thread to mutate buffers that weren't assigned to it while the parent thread is embedded in the framework itself. I think a lot of people would love to see deeper language support for these patterns that completely prevent the mutability without copying buffers left and right.
To me let is the new var because pretty much everyone uses var where they mean let. This is not true for const. I feel like const is not intuitive because it suggests immutability but... it's not. Definitely remove this argument. I suggest you ban var, tolerate let everywhere, and (strongly) encourage the use of const without forcing everyone to use it. 
You should really show an example where you have a large applicatiebeheer where this is implemented. This seems like an insane amount of overhead. I get you want to keep the components small. But there is such a thing as too small. 
Bravo 
I’m not a React dev by any means, but 1) you might want to post some code, and 2) you might want to look into utilizing asynchronous code.
Your company, maybe not, your clients, totally 😉
[I'm just gonna save us some time](https://www.youtube.com/watch?v=IDtdQ8bTvRc)
This is cool! I will mimic the "but why" gif, because I don't think I've been in a position when I've not got 2 screens.
Introducing suck-my-dick-im-not-learning-another-design-pattern.
its easy to write 1k lines of javascript in a day. it takes real mastership to write only 100 lines of javascript in a day
I do maybe like 50 lines a day and then browse reddit.
&gt; I'm actually closer to being IO bound [...] on a SATA SSD NVMe SSDs might be a way forward for you. Their speed is amazing (7x SATA). 
Your code pen doesn't seem to work for me. It appears there's no HTML to hook into. Update your pen so we can see what you have
this makes me not feel so worthless. thank you.
Yeah, got an M.2 at home and it's amazing. Won't bet getting one at work anytime soon, though. :(
Ye, but we building directly for them, white label App pre production so they have zero impact now. Later, who knows.
Its a cycle. They start a project hire cheap devs or the devs on the project pick a new toy to "learn" or because it is "popular" and they standardize on it. Project goes a while and then gets to a legacy stage, the framework is learned to be shit by that stage, or doesnt scale. They have to rewrite the app. Bosses say no because they dont know how software development works, burn out their staff and they quit to go work somewhere else on some other new bright framework. Then they call for new devs that know the old stuff. Angular was easy to standardize on and it feels a lot like older techniques so people use it. React likely will be the same way one day.
This is just my opinion on the slack desktop app for windows: it _sucked_ the last time I used it. Notifications sucked, when they worked, which was intermittent at best. Maybe it's gotten better, idk, but running slack in a browser window works way better for me. And personally, I really like Chromium's notifications over native Windows notifications anyway.
Quality not quantity. 
If I were to be blunt, I'd say the writing is so bad that it'd make people hate const out of spite. 
This is a pretty junior way of thinking, don't you think? 1k lines? How much of that is boilerplate? How much of that is actual logic? How much of that is setting up views/HTML? Number of lines isn't at all what I care about, so I don't count them. What you should be focusing on, is that your code is of decent quality and does what it is supposed to.
One of the projects I've inherited is AngularJS and Vue, wired together with a smattering of jquery...
Without code I can't give you a definitive answer, but here's an educated guess: 1) Because you are loading in React and ReactDOM, which are huge. 2) You aren't minifying/uglifying your react code 3) Whatever you're using isn't tree-shaking your modules
The number of lines is irrelevant. Sometimes it take hours to understand a problem which is solved in a few lines of code.
Try printing the whole todo-list before and after you do a change, like just `console.log(this.todos);`
Looks like this might be homework so I'll point you in a direction. Look at todoText.
www.practity.com/582-2/
Massive demand for Angular devs in france (salaries are still terrible compared to other western countries though).
you should probably read a book on design patterns, [this](http://www.blackwasp.co.uk/gofpatterns.aspx) seems to be pretty popular. look into linters that tell you the complexity of your code. my linter yells at me if any of my functions exceed 5 lines.
I applaud your efforts to continuously improve. Taking a look at OOP, OOAD and SOLID in particular, will be beneficial to reasoning about code, structure, responsibilities and interactions. You might be better off learning (class-based) OOP in a different language first. However, for JavaScript, I think it is more beneficial to learn how to break up functions in modules and learn to compose higher order functions from other functions as building blocks by injecting them as dependencies. 
Of note: in a similar situation (a forEach loop, I think), I recall that nodejs 9.11 kept `arguments` intact. Can't remember whether I was forced to go to the parent scope to access `x`, however.
I feel like I'm doing way too much in my job lol
This is great. Thank you so much for the advice and nudge in the right direction.
Nice, will look into a linter (have been putting it off). Thanks for the resource!
What does running in the browser have to do with threads in NodeJs?
native, has atomics * where node allocates and starts a thread: https://github.com/nodejs/node/blob/master/src/node_worker.cc#L362 * libuv provides actual thread integration: https://github.com/libuv/libuv/blob/v1.x/src/unix/thread.c#L25 * example w/ Atomics: https://gist.github.com/bmeck/7b43e9dffa114f658563a0e9e0f694ce
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [nodejs/node/.../**node_worker.cc#L362** (master → 95205a6)](https://github.com/nodejs/node/blob/95205a61251aca0af3f1c8663caaffb03a5f5c3a/src/node_worker.cc#L362) * [libuv/libuv/.../**thread.c#L25** (v1.x → 07955ed)](https://github.com/libuv/libuv/blob/07955ed3737cc59bc4d586b34222669ca87de755/src/unix/thread.c#L25) ---- 
You'll probably come across a fair amount of important stuff, and one of the most important (to me) is this: SRP and DRY (Don't Repeat Yourself) are two often conflicting things to a lot of eyes, and SRP should usually win out over DRY. Got a Garage and a Fridge and they've both got an _open_ method that looks exactly the same? Leave them separate! DRY would say &gt;they do the same thing, just extract the logic out into a _door opener_ and you only have one place to change if you ever need to change how you open a door! Whereas SRP would go &gt;Woah there, we're renovating the house and adding a side door to the garage, now the fridge has to change! That's not _cool_ man! This applies to FP, OOP, and everything else - don't couple _this bit over here_ to _that bit over there_ just because they look similar! I'd also thoroughly recommend Martin Fowler, Woody Zuill, MPJ (FunFunFunction), and Uncle Bob's talks on youtube. Plus the books too: * Clean Code * Clean Coder * Refactoring * TDD By Example * Extreme Programming Explained
ELI5: Whats the difference between a thread and a promise?
Linters are great - it's often great to understand _why_ a linter tells you something - like why is `const` better than `let` which is better than `var`? I find linting a great way to learn how a language is meant to be used, as opposed to how I've been torturing it. Also, for the love of god, never _ever_ manually format your source code. To me, it just takes up too many brain cycles for something that shouldn't matter. I like format on save, and I save all the time thanks to TDD, but really any point when you stop is a good time. I think MPJ advocates doing it on commit instead of while working.
The best way to think if `this` is “the thing to the left of the dot”. It’s like an extra function parameter for methods. If you have no function, you have no `this` (at least not one you are actually interested in using). People overthink `this` because it gets reassigned (such as in a constructor using `new`), and it has a dumb default value, but it’s not actually anything that complicated. 
the question should be how many lines do you delete one day?
time to read this [The Pragmatic Programmer](http://210.240.189.214/gamedesign/type_exercise/00_9615_reference//5.%E5%AD%B8%E7%BF%92%E6%88%90%E6%9E%9C%E5%8F%83%E8%80%83/23/books/1999%20-%20The%20Pragmatic%20Programmer;%20From%20Journeyman%20To%20Master%20-%20Pearson%20Education.pdf)
Promises are just a way to handle asynchronous behavior, but only IO (network, file operations) are asynchronous in NodeJS. Sure you can send out 10 network requests and do something else in the meantime, but you can only parse 1 of those responses at a time once they get back. If you have two functions that do number crunching, only one of them can run at a time, even if they're done in promises. With threads, the CPU can run both of those functions at the same time.
Threads take advantage of multiple cpus. Promises maximize a single cpu.
Writing code is easy. Deleting code is the hard part.
You should consider functional programming. Each function does one thing and does it well.
Set it up so you change a todo, then, in the console, type todoList.todos and hit enter. The todo you changed is not an object, it's just a string. If you are using Chrome browser, open https://run.plnkr.co/DhdmpZM6gzfvLXJx/ in a new browser window, and open the developer tools. Go to the sources tab in the developer tools. Look at the source of script.js. Go to line 69, do not laugh, and click the number. It should put a blue thing on it. That is a breakpoint. Click Display Todos button, and the code will stop executing on that line. To the upper right of the sources code area, click the downward pointing arrow. It will step to the next line, which is the first line in viewTodo. Stay there a sec, and hover over this. Then hover over this.todos. Then hover over this.todos.length. You see the same stuff from before in the console when you evaluated todoList.todos. Use the down arrow a couple more times to the line 15. With our cursor, select the text this.todos[i].todoText. Right click it, and hit 'Add selected text to watches'. This adds a thing to the right in Watch that shows you the value. You can keep using the down arrow to loop, each time seeing the value, and when it is 'undefined' you can go back into the source, and hover over the parts of this.todos[i].todoText to see that, when it is undefined, this.todos[i] is just a string with no todoText property. 
I often look at my larger code files, grab a piece of paper, and start charting out what each of the functions do, who calls it, why it’s needed, and then once I have a nice little tree, I try and break up the functions into a smaller set of sub functions that handle everything that was going on originally. It causes longer files, but it’s much easier to maintain and upgrade as necessary.
Personally, I found [LearnCode.academy](https://www.youtube.com/user/learncodeacademy/playlists)'s [Modular Javascript](https://www.youtube.com/watch?v=HkFlM73G-hk&amp;list=PLoYCgNOIyGABs-wDaaxChu82q_xQgUb4f) playlist particularly helpful. 
/r/iamverysmart
I have update it now!
Depending upon how you define `reassignment` your table maybe misleading. Consider: ``` const a = 42; a = 30; //error const b = { a: 42 }; b.a = 30; //works b = []; //err const c = [{a:42},{b:'foo'}]; c = 30; // err c[0] = {a:30} //works! ``` `const` does not mean immutable and does not solve the immutability problem.
Shared language. Learn one to crunch numbers. Learn one to present them to the world. Scientists are no programmers, they pick easiest and most performant one.
I thought my spaghetti code was normal until I watched that series lol! This series was truly eye opening for me and introduced me to design patterns in JS. Definitely recommend!
One piece of really quick advice - start writing tests. It will indirectly effect how you code more than any other single thing. 
Kent has a really practical approach to code and testing. He is an awesome guy and super nice. I got to meet him at Frontend Masters workshops. If you're not already following him, I highly recommend doing so.
On the other side of the coin, people might try to use them for everything. I know there have been time in my distance past where I was like "Man, I need threads to do this task.", but ended up just making a wrong turn in Albuquerque while looking for a solution. =)
Amazed we haven't got anyone yelling R yet.
check out [cheerio](https://github.com/cheeriojs/cheerio)?
&gt; like why is const better than let which is better than var? const is not strictly better than let and I'm sure there's a case where let is not "better" than var.
Non-blocking code is just code that gets added to an event loop - it doesn't stop you progressing, but what it is actually doing is diving CPU cycles between tasks, and using event driven ideas to call the next bit of flow when something happens. If you have two non blocking tasks going, the event loop is essentially going "tick task one", "tick task two", and "has task one finished", "has task two finished" etc. so it all runs in a CPU core. Threaded processes actually run event loops in separate CPU cores, and a CPU core is basically just a CPU - we just put a lot of CPUs into machine nowadays, and they share some hardware, and have their own of other bits. It has it's ups and downs - on the one hand, you can do \[number of cores\] times as much work without increasing CPU load, but on the other, you can end up fucking shit up by processes in cores breaking the data they share. If one core is working out that your answer is 42, and another is working out that it's 43, then that can really screw things up. That's why shared data is often immutable - you can add to it, but you can change what's there.
Here's the codepen however this jump action doesn't happen here [https://codepen.io/Inuwashi10/full/dKjPVd/](https://codepen.io/Inuwashi10/full/dKjPVd/) You can also view it on Thimble where I originally created it, and it happens here. [https://thimbleprojects.org/inuwashi10/499253/](https://thimbleprojects.org/inuwashi10/499253/)
Yep, that's exactly the point! Linters point to best practices, and once you know what those are (not suggesting you don't OP) then you can start to understand when they're not best in some situations. Also, could you please outline an example where var is better than let, and one where let is better than const please? I've not found a good one yet
let is better when you need to mutate the variable (obv) var could hypothetically be better if you need to do some hacky stuff that ignores block scoping. 
Wait what... 5 lines? I have some refactoring to do.... 
Agreed - OO is not the best term for what I was trying to say
ARRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR. Wait, you mean the language? Hope I never see it in my life, ever again. 
I’d prefer if prettier has less opinions and more options. I don’t want the jshint eslint posturing bs all over again.
You'd be better off by delegating this task to an external python or bash script, and use Node.JS for what it does best: the async/await event dispatch model. 
Learning about OOP is a good thing to do, but a smaller (and I think better) step is to think functionally. To start, simply break your big functions down into smaller functions, each of which have a single responsibility and is named well. (Function names should be verbs.) This way, even if you just have a lot of functions calling other functions, with no real OOP concepts or design patterns, it will be readable and understandable. When you learn more advanced OOP or functional principles, you have the necessary building blocks to compose more complex structures with.
&gt; I can't understand how anyone couldn't appreciate this. That's precisely the point. Different people think in different ways when developing software. The problem is that the typescript fanboys believe they are "correct"; they simply _can't understand_ how anybody could think differently. But people do. Consider duck typing - you don't _need_ a complete definition of every member of an object, you simply check if the member you're concerned about is present at the time you're concerned about it. If it's there, regardless of how counterintuitive it may feel, you can usually assume it's what you want. This allows for programming in a mindset such as "if this object has a `name`, add the name to my list" - and you can reuse that code to get a list of the names of literally _any type of object that has a `name` field_ without requiring some class author remembers to add your `iHasName` interface to it.
Aye, reassigning makes plenty sense. When would you reassign instead of using a different variable? I'm having trouble finding a good example and would appreciate the help to better understand this. Doesn't const also let you mutate the variable, it just blocks reassignment? So `const car = { model: 'ford mustang' }; car.model = 'tesla model s'` would work fine.
That could be much lighter and faster, if it can be done with just the HTML and then hopefully not getting cors rejections if I clone the requests. Ill give it a shot
Ignore advice to go digging through OOP and FP. They are ways to reason about and structure logic and they have nothing to do with writing good code. Excellent and useful topics for sure, but not for the reason you've asked. There are three aspects to good code: 1) it works, 2) it is easy to read, 3) it is easy to change. We are going to talk about 2 and 3. On readability: fundamentally good code is a love letter from you to the next programmer. The more you think about writing your code as if a *human* has to execute it, the "better" your code will get. In this case we mean better as in more understandable. Use your normal, human language skills to assist with this. There are also very useful disciplines and techniques for helping with achieving this. To be a good author, you must be a good reader. Read others' code. TDDs Red Green Refactor method is also good for taking you from 1 to 2. Which leads naturally into 3! On maintainability: Anything by Martin Fowler (his code smells are about maintainability moreso than communication). The golden rule of 3, i.e. if you have to change it 3 times make it configurable, this exists in many forms and variations. Testing is the most important discipline here IMO. Learn jest or mocha or whatever and test test test. Practicing this discipline alone will make your code infinitely better, and counterintuitively will make you go *faster* (once you are good at it). Resist the urge to learn too many "patterns" before you learn good testing practice, IMO. This is a huge question I could write a whole course on, but fundamentally it is about those two goals (2 and 3). And remember sometimes all 3 of those goals oppose each other, that's fairly common actually, so you have to prioritise. And I would always do it in the order I said: working code &gt; readable code &gt; changeable code. Good luck! This is the hard part. And it will take years of practice and learning. But honestly it's the most rewarding part!
Nice, this is super helpful. So let's say my goal is to find the oldest person of an array containing a bunch of folk's names and ages. `const people = [` `{name: "Bobby", age: 22},` `{name: "Sally", age: 31}` `];` So it would be best archive this with two functions, right? `function getAges(arr) {` `const ages = [];` `arr.forEach(person =&gt; ages.push(person.age));` `return ages;` `}` `function getOldest(arr) {` `return arr.reduce((a,b) =&gt; a.age &gt; b.age ? a : b);` `}` `getOldest(getAges(people));`
The article and a lot of comments here point out how useful threads are. I think someone needs to warn people that threads are dangerous and they lead to all kinds of bugs that are both hard to avoid and hard to find + fix. JavaScript has very good support for asynchronous code so for most things you do, you do not need threads. I would advice people to only use threads when they absolutely need to and make sure you know what you're doing if you decide to use threads. 
Clever use of default values, but I think simply using TypeScript communicates the intent much better and has no runtime overhead.
 The article and a lot of comments here point out how useful threads are. I think someone needs to warn people that threads are dangerous and they lead to all kinds of bugs that are hard to avoid, hard to find and hard to fix. JavaScript has very good support for asynchronous code so for most things you do, you do not need threads. I would advice people to only use threads when they absolutely need to and make sure you know what you're doing if you decide to use threads. 
Personally, I'd rather go for something like this: const getOldestPerson = (persons) =&gt; persons.reduce((acc, val) =&gt; { if (acc === null) { return val } if (acc.age &gt; val.age) { return acc } return val }, null)
For sure, but then aren't you giving a function more than one responsibility? Getting ages + getting oldest? I guess I'm just unclear of when the cutoff should be in making them into separate functions.
- I would have to rewrite all of the libraries I'm using to parse / process / generate back with source map support in Python - The language itself is not slow, it's the modules that are not as optimized as they could be - Adding an external dependency on a completely new language would make users hate me because my module won't be `npm install` friendly anymore. You have to manually install Python on Windows in case you were not aware. I think worker_threads are what I would go with since I get asynchrony as well as the npm ecosystem
I would highly recommend reading [“The Clean Coder” ](https://www.amazon.com/dp/0137081073/ref=cm_sw_r_cp_api_P3wmBbMMN9JTM) 
Imo, not really. Hardcore FP advocates might see this differently, but I'm not sure that extracting the age is somehow beneficial, especially since it divides the rest of your data from the age, even though they are associated. By extracting this much code you also get possible problems - your code, for example, doesn't work. By the way, you are mutating an array. You would never do that in FP. Instead, your `getAges` function would look like this: const getAges = (persons) =&gt; persons.map(person =&gt; person.age)
Node uses an event loop and will keep on running even if those 5s requests are waiting. This is why Node is referred to as "non blocking". Here's a low level article on how that works: https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c Node is faster than Rails simply because most of it's internal logic is actually in C++. This was a big thing back in 2009 when Node was released but these days even Node's creator (Ryan Dahl) has repudiated it and now uses Go for web servers.
Hah, I had the same reaction, but following it helped clean up my code and really decoupled development. Of course sometimes you have little to no choice, but it does influence you to write more functional pure code
There's a graphviz plugin for Vscode that is great. I use it for quick diagrams all the time. Makes it easier to build a nice looking diagram than pen and paper, and I often find that a diagram that looks bad implies that the underlying code isn't clean. 
Came here to say this as well. SRP and DRY will clean up your code immensely. When compared to something like Java, JS is substantially harder to really write cleanly, but it can and should be done.
&gt;your code, for example, doesn't work. Bah, was calling ages on the mutated array which just had the numbers. Thank you. Regarding mutating arrays: even though I was pushing to an array specifically for the purpose of housing the ages, it's still bad practice?
https://github.com/ryanmcdermott/clean-code-javascript
&gt; “The Clean Coder” /u/oopssorrydaddy this and "Clean Code" from Robert C. Martin, or "Uncle Bob" as he's known, are excellent resources for understanding how to structure your code so that it's easier to maintain, easier to reason about, doesn't mix up its responsibilities, and "reads like well written prose". He'll also evangelize about unit test coverage and Test Driven Development, which are other things you should be doing.
Different coding styles lend themselves to different approaches. JavaScript is well suited to functional style, which is why const is so popular. However, your example is a good one. On my team, if you _intend_ to change the state of a variable, you use let, even if the object reference is not going to change. This is reasonable, since you could always change a const to a let if you needed to mutate. Choosing between const vs let, on my team at least, is about communicating your intentions.
A lot of the advice in this thread is great. There is one, pretty small but important thing I would like to add. Make code throw-away-able. No matter what you do. No matter the architecture, the framework. You are _never_ going to make something perfect. So, instead of going for perfection, go for throw-away-able. Basically - Make things as simple and dumb as possible so if you have to throw it away / replace it, you don't have 90 things references the same, say, subclass that now need to change. - Separate your own self worth from the code. Look, I've been a senior developer for a while now but when I was much earlier in my career my code _was *me*_. "How dare you say this sucks or should change!". Make it throw-away-able. "Oh, there is a better way to do that? Okie dokie then! _throws code_". Hope that's helpful. Good luck either way!
Not sure I agree here. Your code is kitschy and short, but much harder to read and debug compared to OPs code.
Yeah, 5 lines is a bit extreme. Most suggestions are that a function should easily fit on one screen (and a normal screen at that--no fair setting the font to 6pts). But seriously--I always suggest beginners start using a linter as soon as possible. A) really helps to start with good habits/code style; B) probably helps in understanding the language and why some things are the way they are; and C) linters tend to be the easiest external tool to start with and make learning things like unit testing and profiling easier.
I’m so glad I started using typescript. 
I think you've made a really, really important point - a lot of this is context sensitive between people. A linter might, by default, report that `let car = {}` should be `const` because it's not reassigned, while in your team it has a different meaning - it's a mutable variable, not an actual constant. I think it was Kent Beck (maybe Uncle Bob?) who said that the number one priority of code is to communicate the author's intent. We write code to do something, sure, but if you don't know what it's doing - if you can't reason about it - then you can't change it. If you know the intent, then it's easy to reason about, so it's easy to change.
Hey, indexOf returns the position in the array rather than the item. There is a built in array function that can be used rather than having to do a for loop. Something along the lines of this should work. const matches = myArray.find(item =&gt; item.indexOf(‘xyz’) !== -1); This will check every item in the array to see if it contains the text ‘xyz’ and store them in a new array. Hope this helps!
Yeah i have the clean coder as well... and i must say its mostly discouraging for he suggest some sort of insane discipline. Clean code however is a great read for anyone. 
I took a quick peek at the network while logging in; it's a bit of a mess. It looks like you need to POST to `https://idm.east.cox.net/idm/coxnetlogin` with the following form data: onsuccess=https%253A%252F%252Fwww.cox.com%252Fresaccount%252Fhome.cox onfailure=https%3A%2F%2Fwebcdn.cox.com%2Fcontent%2Fdam%2Fcox%2Fresidential%2Flogin.html%3Fonsuccess%3Dhttps%253A%252F%252Fwww.cox.com%252Fresaccount%252Fhome.cox%26&amp;targetFN=COX.net&amp;emaildomain=%40cox.net username=yourusername password=yourpassword You'll need to use a request library w/ a cookiejar to keep all the session stuff. Then you should, maybe, be able to request the page that has the data and scrape it with cheerio
I really enjoy Uncle Bob's (I think) style of "it should read like a story". To me that's something like this: function startCar(car) { if (car &amp;&amp; car.battery.amperage &gt; 25 &amp;&amp; car.key.found === true) { car.engine.start(car.starterMoter.engage()); } } Becomes something like this: function startCar(car) { if (canStartCar(car)) { start(car); } } function canStartCar(car) { if (!car) { return false; } const hasEnoughPower = car.hasEnoughPowerToStart(); const hasKey = car.keyIsInCar(); return hasEnoughPower &amp;&amp; hasKey; } function start(car) { car.start(); }
I find this a bit confusing. Does that mean a rails server will sit and not send any more requests until it receives it resolves the request it had sent out?
I guess you could replace your getAge() by a getProp(arr, prop) function... For this example I'd do : GetOldest = arr =&gt; Math.max(...arr.map(person =&gt; person.age))
by default yes. I am not a ruby versed programmer, but I suspect there are also "async" libraries which make this possible in ruby as well, but it's certainly not the norm. In node.js it is the norm. All the libraries implement any IO async by default.
Just no... Seriously. This might be fine for simple presentational components. But for complicated event driven controls or even views this would be either dominated by passing down props in a massive element tree and producing a ton of overhead or abusing context way too much. Also: what's the gain? Extract reusable components where it makes sense and keep lifecycle/stateful components as tight as possible, while keeping out purely presentational stuff...
Angular is more a framework with mature / built-in support for forms, validation etc etc. React is a view library. There are apps right now being created with React that if they were using Angular would be much much simpler and smaller. In case of fanboi-ism; here is someone else who agrees... https://twitter.com/dan_abramov/status/906610201201180672?lang=en https://twitter.com/dan_abramov/status/907031776475918337 
Sorry, I don't really know how Ruby on Rails works. I imagine RoR uses a new thread for every request which is very heavy memory wise. If you add that to the low speed of Ruby I assume this is why RoR isn't used in big applications any more. In the case of PHP, Apache will launch a new process for every request which is also very inefficient compared to the Node approach. Go in contrast uses a very lightweight concurrency model. Instead of using thread it uses Goroutines, which are super memory lightweight. Here is a nice article that might interest you on the topic of Goroutines: https://www.toptal.com/back-end/server-side-io-performance-node-php-java-go
For the lazy / forgetful, SRP = Single Responsibility Principle - this basically means, do one thing and do it well.
Sick! I want to tinker with this when I get home. Maybe use for future project with raspberry pi.
I’m going to go against he grain here by suggesting that you pick up a framework (like React or Vue) and build an application with it. It’s one thing to read about software design patterns, and something completely different to actually put them into practice. Starting with a framework will make you think differently about structuring your applications, and in general the popular ones implement proven and effective patterns. This is not to say you shouldn’t explore the theory behind designing software - you should definitely always be doing this - but in my experience, hands-on learning is the best way to improve.
That makes alot of sense , especially abstracting the canStart into a function. This is the problem I have, being self taught more or less, I find myself lacking these fundamental principles. 
This does help! Much appreciated, thanks. Quick question, if my substring is ‘x’ and I’m trying to find this in a string ‘xyz’, will it find the x in xyz and return the position of the xyz? 
Here's yours answer. https://developers.google.com/web/tools/polymer-starter-kit/ Google tech
Yeah. It might be a bit much for such small functions and one could argue that it's not optimal/perfect or whatever, but it's easy to understand, and if it turns out there's a better way, it's easy to refactor.
Yes. That’s why the de facto way to deploy ruby/rails apps is behind an application server like Passenger / Unicorn / etc that spawns multiple processes or threads. 
Check out my new package, sidecar, that allows you to easily require modules outside the node_modules folder during development! [](https://www.npmjs.com/package/sidecar)
OP. You’re looking at the wrong languages. If you need concurrency you’re best learning Elixir. Elixir is built for this type of thing. 
Good bot
thanks for the response. can you link to any documentation proving this?
I really like hackerrank but anytime I mention it in sysadmin they all laugh and downvote me :(
[removed]
Source code? 
Is it just me or does calling a function prior to it's definition just feel.. wrong. I know about the hoisting but personally it just seems more natural to place canStartCar prior to startCar. Also, that way the functions near the top of a file are called by the functions later in the file, so when refactoring I have a pretty good rule of thumb: changes later in the file are typically safer to make than those earlier in the file.
After learning a bit of the MVC paradigm, my code changed from water to wine. It's really about having functions that are only concerned with a bit of your system. It's pretty easy to learn (I think I got the gist of it in an afternoon) and will make you think about what your code should be doing. However, my test bed for that was PHP, which is very different from js in many ways. Still, my js code readability and reasoning became a lot better after that, so if you are going to code in PHP anyways, give MVC a read, it's nothing out of this world.
Awesome job! Did you use the canvas API?
Horrifying thumbnail
I can’t recommend Code Complete enough. It’s a language agnostic look at programming best practices and patterns. https://en.m.wikipedia.org/wiki/Code_Complete
nope purely from scratch
yes, fair enough. I've been wanting to find a better way to collaborate over code in real time - and toggling between files and slack is painful. Will see how it turns out with this
Needs a bit more CPU than a RaspPi can handle. But I’d bet an Asus Tinker Board would be enough. 
If I understand correctly, you want an array of the indices in the starting array that include 'xyz'? If so: const startingArr = ['foo', 'xyz', 'bar', 'i contain xyz', 'baz', 'qux', 'hello xyz goodye']; const indicesWithXyz = startingArr.reduce((acc, value, i) =&gt; { if (value.includes('xyz')) { acc.push(i); } return acc; }, []); console.log(indicesWithXyz); // [1, 3, 6]
One thing I wish they did was have an option to ignore a whole file without writing a .prettierignore. Or they would just stop messing with my markdown files in general.
Prettier is deterministic. No matter how your code looks when it started it will always end up looking the same. It tokenizes your code and then re prints it. 
Opinions, schmopinions
I needed to learn how scrape a page requiring a login in javascript for another project, so I went ahead and tried it with this: https://github.com/imjosh/fetch-cox-internet-usage 
One of the reasons for popularity is lesser options. You get the advantage of not discussing everything again and again or deciding if the config value needs to be changed
Great explanation!
I know what you mean, it took me a while to get used to it. I personally find it really useful because you can see right at the top what this file does. I open up the file and can see, straight away, this is for starting cars. I don't need to understand how to start a car, or when I can start a car, let alone anything about alternators or keys. Imagine reading from a file, and the first thing you see is `convertUTF-8ToUTF16(inputBytes, reader, soundingBoard)`, compared to `readFile(name)`. I'm really impressed though, I'd never considered that sort of safety mechanism! (That's not sarcasm, it's a good though!)
I mean, there's not really any reason to mutate, if realistically all you do is map, is there?
Of course that would have to go with a comment. But I didn't read OPs comment quite right, it doesn't even fulfill what it is supposed to do.
Unfortunately u/geraldbauer seems to be busy with other things. I've found more immediately updated results at https://worldcup.sfg.io/matches
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Just curious, but is this module bundler you mention going to be something that could compete with other bundlers such as webpack and rollup? Or is it perhaps something else?
How long before an extension that replaces all faces on the internet with Nick Cave? Paging /r/OneTrueGod 
I'm pretty firmly in the "No comments" camp. Comments can lie over the years of auto-refactoring tools being run, or just general laziness. Readable, resuable code never goes out of style, and is always easier to support over the years.
thanks
How can I watch YouTube inside VS code?
I do understand that, and I usually like self-documenting code. But in a case like this it can help (even though the function name normally ought to be enough).
Don’t mind at all, I was just throwing requests at the cox site in postman to see how I could get the cookies and login. Glad it sparked some interest
Nick Cave is a musician, you mean Nick Cage :)
Cool, I had to do the login from Chrome with Postman interceptor turned on to figure it out. The cookies alone were not enough, there are some headers set by one of the redirects that seemed to be needed as well. 
Opinionated library code/style creates samethought which is toxic to intelligence and problem solving. It’s fine if you want to take a sample config and never change it, but I want all possible options and I don’t care for your opinions.
lol oops Just saw an article headline with his (Caves) name so it must have stuck :-)
the styles are not applying to the div..can u please help??
Great write-up but don't agree with this line &gt; If you don't want to go with typescript, then you're left with runtime assertions and unit tests. There are a lot of great options out there, the best of which I believe is purescript. here's a good write-up on the failings of Typescript. https://www.reaktor.com/blog/fear-trust-and-javascript/ As the author states, there are tradeoffs no matter what direction you choose to take
Just start writing tests. This will greatly improve your architecure
Definitely, you're right. I meant it more along the lines of "if you want to stay with vanilla js..."
Whether or not you agree, it’s a damn good post. 
There is no such thing as a “Rails server”. Rails is a framework. The rails code is called by a server. That server can be single threaded / single process or multi-threaded multi-process in which case the server may spawn multiple instances of the rails framework, one for each request. It all depends on the serve you run Rails within. 
This. I can't agree more. I wrote this in response to a similar question awhile ago. Start with TDD, you will be forced to refactor early and often. There is no much use in reading more if you're not putting in the practice.
nice, some suggestions: Try implementing autocomplete and/or add also a list of pokemon you have data on. Since I have no idea how Pikacthu is spelled :D 
Great advice!
Why isn't it secure enough? We usually store tokens in local storage / cookies in websites. Should be fine.
According to their docs, they explicitly say ["Confidential user information should not be stored! The storage area isn't encrypted."](https://developer.chrome.com/apps/storage)
Would that not be, Usernames/Passwords or other personal information?
getElement**s**ByClassName Notice that there's an "s" in the function name. It means something.
I'd imagine the token to be just as confidential as a username and password. If an attacker got a hold of the token they could start authenticating calls to the API to get further information of the users, or change their data on the API. 
If you want to secure the token, store it in your website, and make your website serve as a proxy for the API call.
Highly adviced to follow Kent's newsletter [https://buttondown.email/kentcdodds](https://buttondown.email/kentcdodds), great insight from a great dude.
How does this compare to loterally just loading the slack url inside the web view? Is that even possible?
You can add it as an eslint plugin. It basically just makes all the prettier rules eslint rules. Then you can use eslint ignore etc. 
I tried loading the slack url with an iframe tag, but they have set X-frame-options[1] to disallow that. I'm not sure if there are other ways to do this though [1] https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
A BroadcastChannel that works in New Browsers, Old Browsers, WebWorkers and NodeJs https://github.com/pubkey/broadcast-channel
imgur has a js api and a limit of 12500, that may be worth a look [https://apidocs.imgur.com/#intro](https://apidocs.imgur.com/#intro)
Affiliate advertising.
Give https://cloudinary.com a look, nice api. There's plenty out there that are CDN based if you go that route.
I actually do agree :-)
Yes, i choose cloudinary!
Sadly imgur is not working in my country, Turkey. Choose Cloudinary.
Hi /u/Evangeline10025, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Agree totally but usually spaghetti coders don't know what to test. It's not enough to say: "write tests" they need to also be taught that good unit tests cover use cases, not structure.
Hi /u/fsblemos, if you wish to submit a link, please use the "Submit a new link" option. Thank you.
Hi /u/names_duck, For javascript help, please visit /r/LearnJavascript. Thank you!
try highcharts?
Amazon S3 is another option
$(this).parents('#Comments') this referres to inside the anonymous function why aren't you used using $('#Comments .card-text').html()
Humm... Jimp looks nice indeed: var Jimp = require("jimp"); Jimp.read("lenna.png", function (err, lenna) { if (err) throw err; lenna.resize(256, 256) // resize .quality(60) // set JPEG quality .greyscale() // set greyscale .write("lena-small-bw.jpg"); // save }); https://github.com/oliver-moran/jimp
Learn functional programming
Direct link here: https://www.dropbox.com/s/ai7j5ei0f24aoz6/The%20Vue.js%20Handbook.pdf?dl=0
I would caution your about OOP. for 25 years it has been the go-to model for software design, but it is not the final evolution. JS itself is not very objected oriented compared to other languages, you also have access to more versatile methods as well, including functional and stream oriented design. Unlike many languages, JS is weakly and dynamically typed. This means you can write your code in a generic way without depending too much on the type of objects you are working with. This lets you write more concise and reusable code. 
There's a lot of different comments on the page. So I need to identify the specific one that was clicked on to get the text I need (I think). 
We needed a kinda-declarative sticky table for React which didn't tear while scrolling. So I created [sticky-react-table](https://github.com/samrith-s/sticky-react-table/issues)! Very excited about it, and would love the community's help in documentation and improving it, getting it to a stable release!
Yeah but #Comment is an identifier which should be unique in the document. Either enrich it to make it unique or change it to class. 
I think d3.js is probably your best bet for charting! https://github.com/d3/d3/wiki/gallery If your charts are non-interactive, another approach could be using your R code to render the charts into images, and having the website just load the images!
Hi /u/Gubbbo, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/doctor_haos, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/lesha39, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
Hi /u/AjeebChutiya, For javascript help, please visit /r/LearnJavascript. Thank you!
This is some efficient code, thank you very much. I do not understand the .reduce function in this case, if you would like to explain. What exactly would be the accelerator and value when searching for a string?
`acc` is short for accumulator, which is what you're building out as you iterate through the items in the array. `Array.reduce` basically lets you iterate through an array and create _something_ out of the values inside. This something can really be whatever you want; a string, an object, another array, a number, whatever. `Array.reduce` takes a callback for its first argument, and an initial value for the 2nd argument. In our case, we want the initial value to be an empty array, where we're gonna put those indices. If you don't supply an initial value, it'll use the first item in the array as the initial value of `acc`. The callback function gets the accumulator as its first argument, the value of the current item in the array, and the index as the third argument (it also gets the entire array as the 4th argument, but I didn't use that here). So basically, this says, "Yo, I wanna start with an empty accumulator array. I'm gonna go through each item in the `startingArr` where my strings are, and if that string includes the substring 'xyz', I wanna push the index into my accumulator array. Then I need to return the accumulator so that I have it on the next iteration."
It should be noted that Moment is a pretty heavy library for date manipulation. There are lightweight alternatives such as [Day.js](https://github.com/iamkun/dayjs) or [Luxon](https://moment.github.io/luxon/) (by the Moment team) which are good enough in many cases.
This is super helpful. Thanks so much
 Object.keys(subscriberData).forEach((key, i) =&gt; { if (subscriberData[i]['subscriber']['id'] == subscriberId) { var year = subscriberData[i]['vehicle']['year']; var make = subscriberData[i]['vehicle']['make']; var model = subscriberData[i]['vehicle']['model']; let vehicleName = year + ' ' + make + ' '+ model; } }); You can read the [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) to learn how it works.
This is how I’d do it – I’d use a `for-of` loop: let year; let make; let model; for (const entry of subscriberData) { if (entry.subscriber.id === subscriberId) { year = entry.vehicle.year; make = entry.vehicle.make; model = entry.vehicle.model; } } const vehicleName = year + ' ' + make + ' '+ model; Alternatively – use destructuring to extract `year, make, model`: let vehicleName; for (const entry of subscriberData) { if (entry.subscriber.id === subscriberId) { const {year, make, model} = entry.vehicle; vehicleName = year + ' ' + make + ' '+ model; } } 
The free plan is super generous.
Regular for loops are faster, give you an index, and allow you to break early, but a forEach can look a little better if you don't need that stuff.
Observations about your code: * `obj.foo` is better than `obj['foo']` * Avoid `Object.keys(arr)` for Arrays, use `arr.keys()`. Also: Object.keys(subscriberData).length // no subscriberData.length // yes
I think OP is trying to find a specific subscriber (via their ID) and create a vehicle name for them.
But what does it do ? Could add a motives part in the readme or put the demos on a github page would give a quick glance at it. 
Not sure why you're using `keys()`. Is `subscriberData` an object or an array? Would it be an object using consecutive indexed key values but with no `length` of its own? Also it looks like you're finding more than looping. In that case you can use find. Assuming `subscriberData` is an array: let vehicleName = 'Not found'; const data = subscriberData.find(data =&gt; data.subscriber.id === subscriberId); if (data) { const { year, make, model } = data.vehicle; vehicleName = `${year} ${make} ${model}`; }
 &gt; Is it true that for is faster than forEach? No, for is faster. 
Hey, it’s basically a fixed header/columns table with custom renderers. We are actively working on it to get a demo out. For now, one can just clone the repo and run: yarn install &amp;&amp; yarn start 
Super cool!
Hmmm, I tried the above code but vehicleName is coming back as undefined. I'm making an API call to go through a list of subscriptions and return the vehicle name for a specific subscriber
Alternatively, instead of `if` one can use [ternary operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator): const data = subscriberData.find(data =&gt; data.subscriber.id === subscriberId); const vehicleName = data ? `${data.vehicle.year} ${data.vehicle.make} ${data.vehicle.model}` : "Not found"; It’s not as pretty-looking (all those `data.vehicle` repetitions), but now logic for constructing vehicle name and fallback for it are in one place.
Hi /u/HighResolutionBot, For javascript help, please visit /r/LearnJavascript. Thank you!
Ah I see the purpose of the code now. In that case I would suggest what [\/u\/senocular](http://reddit.com/user/senocular) has suggest, using the `.find()` method. ***** Unless `subscriberData` is an object, then I'd use what I made but with this change: let vehicleName = 'Not Found' Object.keys(subscriberData).forEach((key, i) =&gt; { if (subscriberData[i]['subscriber']['id'] == subscriberId) { var year = subscriberData[i]['vehicle']['year']; var make = subscriberData[i]['vehicle']['make']; var model = subscriberData[i]['vehicle']['model']; vehicleName = year + ' ' + make + ' '+ model; } }); In this case though, I'd stick with using a native `for` loop, adding a `break` statement after setting `vehicleName`, like so: let vehicleName = 'Not Found' dataLength = Object.keys(subscriberData).length; for (let i = 0; i &lt; dataLength; i++){ if (subscriberData[i]['subscriber']['id'] == subscriberId) { var year = subscriberData[i]['vehicle']['year']; var make = subscriberData[i]['vehicle']['make']; var model = subscriberData[i]['vehicle']['model']; vehicleName = year + ' ' + make + ' '+ model; break; } }; or if you want to keep it functional, use `.some()`: let vehicleName = 'Not Found' Object.keys(subscriberData).some((key, i) =&gt; { if (subscriberData[i]['subscriber']['id'] == subscriberId) { var year = subscriberData[i]['vehicle']['year']; var make = subscriberData[i]['vehicle']['make']; var model = subscriberData[i]['vehicle']['model']; vehicleName = year + ' ' + make + ' '+ model; return true; } }); Of course you could also go for `.reduce()`, but I'd go with one of the above methods first.
In this particular case, is it bad to be mutating the array? Probably not, since it's scoped to the function, which isn't doing anything else with the array. However, you're making a one-liner into three for no real benefit. ``` const getAges = (people) =&gt; people.map(p=&gt;p.age)) ``` As a general rule, the only time you really want to use `forEach` is if you're creating a side effect based on the data in an array and don't care about the return value. Even then, it's usually better to map the data into the shape that you want and then produce the side effect using that data. This probably isn't something you'd want to do, but let's say you have an array and want to log each value to the console on its own line with the index number. ``` // you could do this const logArray = (arr) =&gt; arr.forEach( (val, idx) =&gt; console.log(`${idx}. ${val}`) // although, I'd probably do this instead const makeLogFromArray = (arr) =&gt; arr.map( (val, idx) =&gt; `${idx}. ${val}`).join('\n') console.log(makeLogFromArray(whateverArray)) ``` I tend to see `forEach` as a bit of a code smell. There's almost always an option that is both more expressive and more terse. For instance, if you have an array of people and want just the adults. ``` // not so good const adults = [] people.forEach( person =&gt; if (person.age &gt;= 18) { adults.push(person) } ) // much better const adults = people.filter( person =&gt; person.age &gt;= 18 ) ``` Or if you want to split the people into two lists, one for adults and one for minors. ``` // not so good const adults = [] const minors = [] people.forEach( person =&gt; { if (person.age &gt;= 18) { return adults.push(person) } return minors.push(person) }) // much better const { adults, minors } = people.reduce( (people, person) =&gt; { if (person.age &gt;= 18) { people.adults.push(person) } else { people.minors.push(person) } return people }, { adults: [], minors: [] }) // or maybe this const { adults, minors } = people.reduce( (people, person) =&gt; { people[person.age &gt;= 18 ? 'adults' : 'minors'].push(person) return people }, { adults: [], minors: [] }) ``` 
I pasted that whole code into chrome's console, and it outputs: &gt; oops, global undefined The reason it outputs undefined is because bar() returns undefined, and the console will always try and output the result of the last command.
Is there a way to do this better? I’ve seen a lot of good content get lost, because people delete their posts in reaction to this notice. Ideally, there’d be a simple way to move such posts to /r/LearnJavaScript
Here's a sneak peek of /r/learnjavascript using the [top posts](https://np.reddit.com/r/learnjavascript/top/?sort=top&amp;t=year) of the year! \#1: [If you're looking to learn javascript, a professor at my college made a really cool free to use online textbooks that includes: exercises, clickable links, and lots of example files.](http://profsamscott.com/javascript/) | [4 comments](https://np.reddit.com/r/learnjavascript/comments/7xd7x0/if_youre_looking_to_learn_javascript_a_professor/) \#2: [To everyone currently enrolled at a college: don't forget to get your Github student developer pack. It contains a free domain name, digital ocean credit and much more.](https://education.github.com/pack) | [13 comments](https://np.reddit.com/r/learnjavascript/comments/8b81be/to_everyone_currently_enrolled_at_a_college_dont/) \#3: [Algorithms and data structures implemented on JavaScript with explanations, examples and links to related YouTube learning videos](https://github.com/trekhleb/javascript-algorithms) | [6 comments](https://np.reddit.com/r/learnjavascript/comments/8l09o2/algorithms_and_data_structures_implemented_on/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
You change the function context when assign obj.foo to variable bar. The variable bar is in the global context. What you did is the same when you assign foo to the obj. Take a look: var obj = {}; obj.foo = foo; // The this in foo is has the context of obj; var bar = obj.foo // is the same as window.bar = obj.foo
Use the extracted attributed of faces to train a KNN classifier. Check this out [https://github.com/mljs/knn](https://github.com/mljs/knn)
I haven't seen a Ruby on Rails framework that isn't at least an approximation of "one thread/process per request." Node is more event driven, so a single thread/process can handle multiple requests at the same time. Both models have different advantages and disadvantages. The thread per request model tends to be easier to think about because you can invoke synchronous functions without worrying about what other threads might be doing at the same time. The event driven model means you don't have to have 100,000 threads to handle 100,000 concurrent web requests, and sharing information between requests (online messaging/chat, multiplayer games, etc) becomes much easier, because they are (or might be, you can have multiple threads in Node) all handled within the same thread. At a low level, the difference is that a thread per request model will issue an I/O statement, then pause the thread waiting for the results. An event driven model is more like "OK, do this async function, and when you get results, pass them to this function." Then, while the I/O is in process, the same thread goes and does something else, the current request context only comes back into focus when that function is called. The end result is that if your server process is I/O bound, the Node server is less impacted by context switches. On the other hand, if your server process is compute-bound, the single thread for multiple requests might not work as well, since you may need more compute time than you'd get from a single process. As an example of how Node can be efficient, let's consider a simple online chat room. Let's say we're either using WebSockets or Server Sent Events. For SSE (and optionally WebSockets, but usually not), you'd have new messages posted via a separate POST request. With RoR, you need some way to communicate the new messages to the multiple processes feeding the WS/SSE data feeds. You could do this with a shared communication bus or a shared database. In either case, there will be context switches involved, and probably disk I/O. If you're using a shared database, then every thread responding to a WS/SSE request will be polling the database to see if there are new messages. A shared communication bus could eliminate the polling, and some are memory based to reduce the disk I/O, but all will still involve context switches. With Node, the POST request can directly queue up the outgoing messages in the WS/SSE feeds, since these are all controlled by the same thread. No context switches and in the simplest of models, no disk I/O. This is actually viable, many times I wind up with Node applications which treat the databases/files as mostly-write data that only gets read back in when the application restarts and needs to know the previous state. If you've got enough computation that needs to be done (say for an online game rather than a chat room) that you need multiple threads, then things get a little messier, but you still have the potential for dramatically reduced context switches and polling since you need to synchronize fewer threads, since each thread is controlling multiple requests. Ultimately, it comes down to: * How much effort is needed to switch between contexts. * How often you need to switch between contexts. * How easily can you share information between contexts. Last note: Ryan Dahl did start focusing on Go as opposed to Node, but has kind of come back to Node, though it sounds like it depends on the project. He also announced [deno](https://github.com/ry/deno) a few weeks ago. Basically, it uses typescript as it's language and avoids some of the things [he thinks Node did wrong](http://tinyclouds.org/jsconf2018.pdf). 
\`bar()\` will return undefined as there is no "context" when invoked. In JavaScript, a function only know "how" it is called, not "where" it lives. So, if you were to do: \`\`\` [obj.foo](https://obj.foo/)(); // returns 2, as "this" points to \`obj\` bar(); //returns \`undefined\` as "this" points to the global scope/window \`\`\` There are three ways "this" is set: \- [obj.foo](https://obj.foo/)() -&gt; DOTCALL, eg: a "." then "()" \- call/apply - \`new\` If none of those rules are met, as in the \`bar()\` example, "this" points to the global. For reference: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)
Deer is currently in a very early stage. Until now, only the basic structure is complete, and the welcome screen. We will upload screenshots as soon as version 1.0 is out.
Deer is currently in a very early stage. Until now, only the basic structure is complete, and the welcome screen. We will upload screenshots as soon as version 1.0 is out.
Glad you noticed that! We initially intended for Deer to be like an open source alternative to Bear.
Great response! Thanks!
&gt;let vehicleName = 'Not Found' Thank you for the help. It works now. Why did declaring the variable outside of the forEach statement fix the problem? 
If you read the guide, it talks about running this snippet in strict-mode or not-strict-mode. It sounds like you're running this snippet in strict-mode, which is why you're seeing `undefined`.
Unfortunately we're between a rock and a hard place. Almost a year ago, a post bubbled-up to the top of the sub, [Do we need a JavaScriptHelp subreddit?](https://www.reddit.com/r/javascript/comments/6waspe/do_we_need_a_javascripthelp_subreddit/), and the consensus was that /r/javascript was tired of all of the help posts (especially the more mundane ones). Sure, there's some that fall into the `help` category that are interesting, but for the most part, people are tired of users begging for homework/job help or not even bothering to google for help first. Another point is that reddit is a poor substitute for a Q&amp;A site; SO has it's problems, but for the majority of questions that we get, it's much more suited to providing help than we are. So, it was decided that instead of just removing the posts, leaving no remedy for the poster, we'd refer them to /r/LearnJavascript. Unfortunately, due to the way reddit works, there's no means to _move_ a post. We can remove, and the user can repost, or I guess now they can use the newish reddit feature of cross-posting, but that's all we get.
It's because of a concept known as variable hoisting, I don't think I could explain it better then the official [var](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var) and [let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let) documentation.
Nice and simple. Configuring webpack is not as difficult as some people claim it is.
Hi /u/JorgeBucaran Thanks for your interest, the Module Bundler in reference is Pundle (https://github.com/steelbrain/pundle). It's in Alpha (aka I can change internal stuff whenever I want, there's also no external dependencies so it's CLI can be considered stable). It's running https://relationshiphero.com/ right now and supports everything that Webpack does, It's super-fast (multi-process, super-cached and all that). Here's a test package written in Pundle https://github.com/steelbrain/pundle/tree/rewrite-ng/packages/test-package I intend to write the docs and launch it soon
Converting a color from RGB to CMYK can be very complicated if you take into account color profiles and such. After solving that, you have to figure out if your system that generates the images dynamically can insert color profile metadata into the images. I think it would be a lot easier to use ImageMagick to do that for you on Node. Generally ImageMagick needs to be installed as a command line utility. Some server environments already have it installed such as Google Cloud Functions.
Because most of those projects have been abandoned by repentant developers who have moved on to greener pastures. Companies are desperate to get people in to keep bolting on features rather than invest in a rewrite. The word 'rewrite' in itself is exceptionally dirty to any project manager. The Angular shit storm rages on.
no
This is about as good an example of a production-level configuration as "hello world" is for how programming languages work.
OK, got it! Maybe you can signal to someone who can make this happen that this would be a nice feature to have(?) Thanks for your work, BTW. As appreciated as ever!
This looks nice! Will give it a try!
Prototypes are used in property lookups when the object itself doesn't have its own version of the property. Because `shop1` is never assigned its own `street` property, when you try to access `street` from `shop1`, it notices that no `street` property exists and instead goes to the prototype object and pulls the value of the same name from that. `shop2`, on the other hand, was assigned its own `street` property. Whenever you try to access `street` from `shop2`, its able to see that it has its own property and can use its value without ever having to refer to the prototype. If you ever re-assign a prototype value, only instances that don't have their own versions of that property will show that change because its only those instances that will look to the prototype to get that property's value. Generally speaking, all instance variables are set up in the constructor per instance rather than being set in the prototype. Only methods (functions that don't change) would be in the prototype object. This prevents confusion around things like this and makes mutations in object properties less dangerous.
Redux is used for state management. As far as my Angular knowledge is concerned there isnt a framework around state management in Angular. When I used Angular 2 initially it was common to use ngrx. Is this now baked into Angular 6?
Whenever I want to drill a rusty nail directly into the pain center of my brain I just try to yarn install an angular/webpack/typescript project onto a different machine than it was developed on. It's more painful but cleaner. When's Angular 9 coming out? I think they need a few obscure config variables they need to make a version breaking change for so they can rename them. Also switch back to Angular-cli, just for fun. That whole ecosystem is more rapidly becoming a joke everyday. I'm pushing management at my place to get rid of it. 
I disagree. This Webpack config could be used as is for simple projects. A hello world example has no practical purposes.
Hi guys, I'm launching v1 for a project I've been working on for two years now. Please check out the article and let me know what you think :)
Depending on the scale of your problem. Using euclidean distance as a simple metric work very well, plus you don't have to train a classifier. In a large scale scenario, euclidean distance does not scale anymore, that's when you would train a classifier :)
A deep fakes chrome extension? Challenge accepted ;)
I think it's great, although it would have been more relevant 3-4 years ago. These days it seems a lot of people are moving from the classical Node RESTful APIs to cloud functions, Firebase, AWS App Sync, GraphQL, etc, and also moving away from Mongo.
Simple projects, definitely. Production-level, no.
'Production' is not really a measure of complexity. We have production cloud functions that consist of 10 lines of JavaScript. ¯\\\_(ツ)\_/¯
Thanks for the feedback! I agree that the technology is moving in different directions, however I believe REST is still the current standard by far. The goal of this project isn't to provide the latest tech, but rather to provide tools and a workflow that minimizes overhead and is optimized for quick MVP development so that ideas can be iterated and tested as quickly as possible while still being founded on quality code. Mongo/NoSQL is great for that and as far as I know is still rising in popularity (at least [mongoose]((https://npm-stat.com/charts.html?package=mongoose&amp;from=2010-01-01&amp;to=2018-06-26) is)
 &gt; shop1 Bank {employees: 10} &gt; shop2 Bank {employees: 15, street: "Manhattan"} &gt; Bank.prototype {street: "Bronx", employees: 20} Prototypes are pretty simple. If you check for a value in the current object and it's not there you check the parent prototype. So `shop1.street` doesn't exist, so it checks `Bank.prototype.street`, and returns `Bronx`. `shop2.street` *does* exist, so it returns `Manhattan`
you are full of shit haha
Do you have any Vanilla JS implementation?
Nativescript is making a push too.
I love this title. I have nothing constructive to add, but I love it.
Sadly there are no real stats on DB market share, but there is a website that has a [popularity ranking](https://db-engines.com/en/ranking_trend). [Mongo vs Postgres.](https://imgur.com/PjZI0KC)
here's a very rough example of how I'd do it const people = [ {name: "Bobby", age: 22}, {name: "Sally", age: 31}, ] const getAges = ((arr) =&gt; arr.age); const getOldest = ((a, b) =&gt; a.age &gt; b.age ? a : b); const oldest = people .map(getAges) .reduce(getOldest); console.log(oldest)
Fair enough, I don't have much experience writing 10-line cloud functions. For sizeable web apps, though, Webpack gets really tough to configure unless you choose an out-of-the-box solution.
Very interesting. Thanks for those links!
I wouldn't call this "functional programming". There are a lot of idioms and common utilities present in most FP libs. Take https://github.com/ramda/ramda for example, one of the more popular FP libs out there.
Until you start getting into `call`, `apply`, etc: obj.method(); ^-- `this` inside `method` method(); ^-- invisible `global.`, or `window.`, so `this` is the global
Have you looked into React, Angular, or Vue?
What platform let's you write cloud functions in JS? I've been writing Lambda functions in Python but wouldn't mind having an alternative.
I have. It seems really heavy to implement those for something like this. I thought there might be a light JS framework (like Handlebars) that could do it. 
Oh God, this "REST" song... So lame. **So lame**. Make it stop, I'm about to throw up.
Without even opening this, I'll take a guess that this is yet another misguided CRUD-over-HTTP framework inappropriately sold under the "REST" moniker.
Those tools that you mentioned have no need to implement what you asked, because they don't need to. The vanilla javascript provided is the tool that you need for this task. const exampleTemplate = (dataToBeShown) =&gt; `&lt;div class="content_to_be_inserted"&gt;${dataToBeShown}&lt;/div&gt;` const exampleHolder = document.getElementById('example') exampleHolder.innerHTML = exampleTemplate('Hello World!') I used the template strings from the ES2015 but the templates from handlebars would do the same thing on this example. The key thing is to set the innerHTML to be the string generated from the template.
mustache/handlebars will do that. mustache way: `Mustache.render` to a variable, then insert that into your markup, either with vanilla js (`append`) or jquery, or whatever else you might be using. surprisingly, theres examples in the documentation (gasp): [https://github.com/janl/mustache.js/](https://github.com/janl/mustache.js/)
All cloud functions providers have JavaScript runtimes. * AWS Lambda * Google / Firebase Cloud Functions * Azure
OP, good luck with your CRUD project and everything, but unless you want your readers to throw up uncontrollably while going to your blog, please tone down on the lame meme images and that terrible... *horrible*... **seizure inducing** "REST" song you embedded.
There's where the hype is moving. Whether most people are moving along is another story.
What's tough about configuring Webpack? What features do you think would be needed for a "decent-sized web app"?
In our case we've moved away from Node to Go, but we still use REST and won't be using GraphQL for the foreseeable future.
Congrats on your project. As an FYI, Facebook has an editor known as [Draft.js](https://draftjs.org) as well.
So do you think the move to Go was worth it in the end, and how?
If the data that’s being inserted is controlled by the user this method can be pretty dangerous since it opens you to XSS.
I agree with the recommendation of mustache! It's easy to use and lightweight. Already used it in a few projects.
If you don't need to support IE11 or lower this is the easiest way to go. Should work almost everywhere already. Though I don't like setting up markup by JavaScript.
I can only speak for Webpack 3, but for a web app (React experience here, mainly), there are a lot of loaders to keep in mind. Not only js and css, but file loaders and font loaders as well. Loaders each have special options, and integrating those with your project's directory can seem awkward at first. You also have to have a plugin for the CSS. Our bundles for dev, qa, and prod all produce different outputs for api keys, source maps, and optimizations like chunking, minification, etc. Keeping track of the right babel configuration seems really arbitrary, as well as all the presets for the babel loader. Figuring out why and how to use [chunkhash] in the filename took a bit. There's a wonderful free book-like website online that helps with this--and thank god, because except for the more recent webpack releases, documentation and best practices are very hard to find. We also integrated bundling with our test runner, and the integration there had some gotchas involved. If my webpack configs looked remotely close to this blog post's, I'd be singing its praises. It's been extremely powerful for us, but it takes a while to learn the ins-and-outs. 
You need to provide some code or details. This sounds like something that should be async. 
I just joined, but it feels pretty spammy to me.
yeah, this is true
Looks good! I had to look at the source to see what the "ON/OFF" switch was (it gets rid of the tooltips, which actually are a bit annoying).
What is worth it? For our use case yes. We obviously saw an increase in performance and memory consumption, but our main motivation was to move to a statically typed language and a more stable platform (as in one that doesn't reinvent itself every couple of years). We all started to use Node with callbacks, then Promises, then async/await, then maybe TypeScript, then... whatever. We have enough suffering that kind of dev experience in the front end.
There does seem to be more linking to external blogs and videos and less discussion the past few months..
There definitely has, I think it's because there are so many junior devs coming in to such a saturated market and they're just trying to market themselves the way that multiple sources are telling them too. It's good to employ the Feynman technique while learning stuff, but it also leads to a lot of redundant crap that may or may not even begin to use good, new, current or working techniques, let alone make it easier for other new developers to understand. A lot of it also has to do with how often the myth is perpetuated that there are ton's of jobs out there where you can make $80,000/yr developer after spending three months of copying the code from Colt Steele's Udemy course. 
I recently did something somewhat similar to what you're doing with Vue. It was an old ASP.net app and confusing, so I just did my external API call via the client. You basically write your template in html, give it `id = App` then `new Vue({ el: "#App, data: ... })` It was a good experience. 
Haha, I can definitely relate to this. One of the most recent updates to rest-hapi was a major switch to async/await. I will say the updates were definitely worth it. Hopefully the language as a whole will settle down eventually. I personally really enjoy the freedom of javascript. I resonate with Eric Elliot on that one: https://vimeo.com/69255635
I'd still be interested to hear your thoughts, regardless whether your assumption is true or not ;)
Personally I don't see any problem with the issues you've mentioned. Adding loaders is basically configuration with javascript objects. Some loaders have their own idiosyncrasies, but you figure it out once and you're done. Most likely you can copy and paste all those things from a starter kit or examples on the loader's readme. As for environment configs and modes there it's really no that complicated either. Just use different configs for each mode (build, build for debug, serve, etc) and `webpack-merge` to merge a base config file. Then you can pass env variables for smaller adjustments, and finally `webpack.DefinePlugin` for environment configs passed to your web app.
You're totally right. That's all it is. But in the blog post, those parts aren't even mentioned. Most blog posts don't, actually. They just try to start you out. And that's why so many people think Webpack is complicated--it's harder to find out how to do anything beyond the basics, thanks to blog posts like OP's
Why don't you deploy to GitHub pages or Netlify instead ...
&gt;the myth is perpetuated that there are millions of jobs out there where you can make $80,000/yr as a junior developer after spending three months copying the code this.
What would be the kind of content you'd like to see here?
&gt; It feels like everyone is peddling their "How to use async/await" blog or Left Pad package or what-have-you. It's too bad you feel that way. I, personally, don't mind the mix of content here because JavaScript is a _really_ general subject. The sidebar links have better domain-specific subs if you're not getting the interactions you want from this sub. What sort of content do you want to see here? I think the best chance you have of improving this sub is to post stuff that gets votes.
All these async/await blogs and I still don't know how to use it!
Use the setTimer function call in JS
&gt; Hopefully the language as a whole will settle down eventually. It won't happen. EcmaScript is designed and approved by committee and it will never satisfy a single vision. Some people want classes, other functional stuff, others types, etc. All sorts of programmers are forced to use JavaScript and will try to make it better for them. This doesn't happen with other languages that usually satisfy a particular vision. &gt; I personally really enjoy the freedom of javascript. I think Go, while not perfect, hits a really sweet spot between the JavaScript jungle and the more bureaucratic languages like Java. Swift is also really nice in this respect, alas still only useful for iOS and Mac dev. I'm no Microsoft fan but I will say that C# is also a great language, and it's a great move to make .NET Core open source and compatible with Linux. In fact async/await was first implemented for C#.
 const noItsImpossible = content =&gt; document.getElementById('main-container').innerHTML = `&lt;div&gt;${content}&lt;/div&gt;`;
How to write blazingly fast REST APIs? 1. Learn Elixir 2. $ mix new api —no-brunch —no-html 3. Reap the benefits. How to use your new blazing fast API? 1. Rollup.js (using Buble not Babel) to bundle. 2. $ Yarn add mithril 3. Reap the benefits Results? An 8kb SPA framework that ships with XHR utilities and routing out of the box and a concurrent API that can handle millions of requests per second that’s fault tolerant and faster than node not to mention 99.999% uptime built on top of Erlang and BEAM. That’s how I do it kids. 
I don't mind people promoting their own packages or blog posts *if they're original or useful*, but I agree that there's a lot of useless stuff posted here that's been done to death. The other day there was a tutorial posted for writing a todo app...like seriously?
Sadly blogs and videos are being used as resume material.....and some of them are not very good.
But there are hundreds, probably thousands of starter kits out there from where to get more in depth info. I should probably write a series of articles on how to configure Webpack beyond the absolute basics...
&gt; ...that there are millions of jobs out there where you can make $80,000/yr...after spending three months... I think this is a result of how many people there are in the industry that are self-taught. New developers feel empowered because they know how to use Google, and don't fully understand just how much work it takes to actually go from self teaching to getting a job. I worked a lot of shit jobs before I finally got one in web development
This is true of basically all web development as a whole.
In my experience, the starter kits are great until something breaks and you gotta figure it out anyways. Or if you want to add something it didnt come with. Or if your project directory structure evolves. Sticking with create-react-app is the way to go, IMO. Anything but rolling your own.
On average, self-promoted content will be lower quality than content posted by other people. 
Yes, articles need more novelty. It's way easier to come across articles with basic tips than fascinating insights from clearly experienced developers. I like niche and loosely useful, like the \[script tag article\]([https://eager.io/blog/everything-I-know-about-the-script-tag/](https://eager.io/blog/everything-I-know-about-the-script-tag/) 
Do you have source maps set up? 
Thanks! Extremely helpful. So no matter what, there would be a requirement for me to handroll the HTML in the JS? So if I had a big HTML block, I'd have to assemble the JS to inject?
I'm using Django as the backend, and was trying to figure out a way to do it there for the exact reason, but wasn't finding a way to do it so started looking at JS
Awesome, thanks! 
What “people”? Can you name a few big companies (aside from those moving to GraphQL) that are doing this?
Same situation for me and moving into a developer job was several steps up from writing my own projects even after practicing for over 4 years with even more years developing in the desktop space (but it taught me the discipline that is beyond the code).
Like I said I'm not entirely sure. Javascript is one of the most popular languages there is, surely there we can do better somehow. I do realise that without a proposed solution this amounts to senseless complaining
Absolutely. If it needs to be sync, such as application initialization, then there should be error handling that didn't use timers (because that is a poor and unreliable way of handling problems). If it's anything else, it should be async.
I did but this is what I get right now. [https://imgur.com/a/Wq9nqDH](https://imgur.com/a/Wq9nqDH) Did I set it up correctly?
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/ZCyI57m.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20e1cp4z1) 
That seems fair. Doesn't require someone be impressed and then share.
&gt; I don't mind people promoting their own packages or blog posts if they're original or useful Likewise, but we'd need a more specific criteria than a vague, qualitative self-evaluation. 
Yes absolutely and this is a general problem in this industry - everyone writes a vaguely useful lib and an introduction to React article and waits for the job offers and back patting to roll in - it’s hopelessly narcissistic and disturbing! 
I think what we really need is an Angular vs React article. Haven’t seen one of those in a few hours.
Well, like you pointed out, discussion can be useful. Your post has generated some.
Agreed. It's hard for the author to gauge
 someAsyncFunction(param1, param2, function callback(asyncFnResult) { doAnotherThing(asyncFnResult); }); becomes const asyncFnResult = await someAsyncFunction(param1, param2); doAnotherThing(asyncFnResult); It basically makes async functions run in a synchronous looking way. Now, if you imagine you want to do an async thing in the result of another async thing, you get "callback hell" where you have a bunch of nested callbacks and the indentation becomes obnoxious.
Yep
Yep
It was not intented to be a real world and production example. I was more thinking about writing a simple introduction to webpack and modern js environments, to make more complex articles afterwards. If you have suggestions on how I could go more advanced, I'm open to discussion :D
Angular vs React has been done to death. It's all about that React vs Angular now. /s
Now make a blog post 
Can someone explain why self promotion is a bad thing? Like if five people are learning the same thing and they blog about it, it's just coincidence that they're posting about the same thing?
10 things you didn't know about async/await!
This is reddit. Use it like reddit. Downvote what you aren't interested in. Upvote what you are interested in. It'll sort itself out.
Wow, that sounds intense! I'll have to give it a try! :)
I don’t know what’s worse, the self promoting or the fact these tech tards think their content is worth self promoting. Stick to show off Saturday you bunch of virgins. For everyone not chasing code clout: /r/programmingcirclejerk
Great point! Yeah I used to use C# back in the day and it was my weapon of choice. I haven't tried much Go yet but I've heard good things.
What are you referring to?
Elixir is a functional programming language and has only been around a few years but it’s built on top of Erlang. Erlang has been in the code game since the mid 80’s. It’s a somewhat steep learning curve but once you grasp it you won’t look back. If you’re looking for speed, elixir is where you’re going to find it. Regarding Mithril. Mithril is the fastest SPA you’ll find. It beats React, Vue and angular I’m speed comparisons and It’s been around for several years, so it’s mature. While a lesser known framework it’s still going to serve you graciously. It’s tiny size, extendability and programmatic approach makes it poetic.
The post I responded to
Yes, those are utilities which are using from project to project. FP libs have common utilities, this is not same :)
the handlebars way actually sanitizes the output to prevent this kind of injection
You might want to look at [lit-html](https://github.com/Polymer/lit-html) It takes advantage of a couple regular JavaScript features like tagged template literals and HTML &lt;tempalate&gt; 
I'm the author ;)
Haha, woops yeah traced that wrong. ;)
Might want to check out [https://www.reddit.com/r/JavaScriptHelp/](https://www.reddit.com/r/JavaScriptHelp/) instead
If you read [our guidelines](http://www.reddit.com/r/javascript/wiki/index), and follow all of the relevant links, there's a lot of food for thought on this subject. But on the whole, reddit [has always maintained](https://www.reddit.com/wiki/selfpromotion): &gt; _"It's perfectly fine to be a redditor with a website, it's not okay to be a website with a reddit account." - Confucius_ Though sarcastically attributed to Confucius, it's a pretty powerful maxim. Give it some thought. In general, there's nothing inherently wrong with self-promotion; however, the types who abuse it, are generally not very good redditors (they just abuse reddit for profit/notoriety/other selfish reasons, and don't care to be a contributing member of the community).
Confucius say, man who drop watch in toilet have shitty time. ***** ^("Just a bot trying to brighten up someone's day with a laugh. | Message me if you have one you want to add.") 
you shou
you should use the /u/MrrGrrGrr answer instead, it is a safer way to do what i explained. 
&gt; I just joined You, and everybody else! Just a few hours ago I was [looking at our metrics](http://redditmetrics.com/r/javascript), here's how our subscriber numbers break down: * 1/25/2008 -- /r/javascript created * 1/19/2017 -- 100k users * 1/27/2018 -- 200k users * 6/26/2018 -- 300k users Like, wow....it took us 10 years to hit 100k, then a year for the next 100k, and then 6 months for the next 100k. That's a pretty astronomical growth rate.
LocalStorage. Always LocalStorage. 
Buddy, you need to stop ✋ it’s 2018 and jQuery ain’t something you should be playing with no more, let it die. Learn React or Vanilla. Be normal and stop bringing shame upon your future self. 
Is it a today app? Bin it
Of course, as a college student (with 2 years to go), I don't have much idea of _how_ to set myself apart, despite the fact that I have moderate scale projects using a few different languages, even though some are open source. The majority of my code is either for personal use or an organization. The largest example (~10k lines and counting) is still closed source, as it has some functionality, but nowhere near the end goal. Don't get me wrong, I'm not all that, and I have tons to learn, it's just that even when I do apply, I'm quickly tossed in with everyone else because I don't _really_ have anything to show that's public.
It is easy?
I can tell you how to use `this`. How able some information about what’s new in ES6?
author here: can answer questions here as well (also posted at https://twitter.com/left_pad/status/1011622065189814274).
Perhaps, but how would anybody find it? We'd just end up with a circle-jerk of the top x% of authors. If content sucks, downvote it. Who submitted it doesn't affect the quality.
that's nice. not everything needs to be a handlebars advertisement.
Damn. This does put things in perspective. Cheers.
it's just "use a library to sanitize because i don't know how to do it in vanilla" that's actually a very bad way to engineer
if you take the time to look, a whole lot of the xss flaws in real life are actually the result of sanitation libraries, rather than flawed code for example, the django mess (people are recommending django for this) was because of a fault in the yaml portion of the serializer which let urls run commands in shell (ffs) sanitation engines are more dangerous than people appreciate yes, they solve risks, but they cause other risks, and they encourage programmers to stop testing because "we have a trusted way to serialize" only use them when they're actually warranted, and penetration test them
django's sanitation engine caused that giant local execution mess i don't really understand why people trust engines like django. they have a long history of holes
Oh, it's totally fine. I just hear people say "Configuring webpack is not as difficult as some people claim it is" and it blows my mind. 
Big companies rarely use a single technology (database, language, framework, etc) so I doubt you will see a headline saying "Big Corp is moving away from X to Z" in the server side space. There are lots of blog posts about individuals and companies leaving REST for GraphQL, or adopting a serverless architecture, or moving away from Node. [Netflix adopting AWS Lambda](https://aws.amazon.com/solutions/case-studies/netflix-and-aws-lambda/). [TJ creator of Express leaving for Go.](https://medium.com/@tjholowaychuk/farewell-node-js-4ba9e7f3e52b) [Ryan Dahl creator of Node leaving for Go.](https://www.mappingthejourney.com/single-post/2017/08/31/episode-8-interview-with-ryan-dahl-creator-of-nodejs/) [Koding leaving Node for Go.](https://www.quora.com/Why-did-Koding-switch-from-Node-js-to-Go) Etc.
1) see above 10) this list is binary
So regardless of programming language, parsing strings sucks. If your input is well structured (always follows the same pattern) learning regular expressions (regex) will get you pretty far. For example, the regex `(?!#)\d+(?=#)` will match one of more digit characters, followed by a # and preceded by a #, but not including the #'s. Another thing that will come in handy working with javascript and string processing is the unary + operator. +string will parse to a number. `+"10"` === `10` Putting those two concepts together, we can see that `+NPS.match(/\d+(?=#)/)[0]` is what you are looking for. Here's a great resource for testing (and learning) regex: [https://regex101.com/](https://regex101.com/) And here's the documentation for what String.match did: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/String/match](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match) For learning JS, MDN is an indispensable resource. As for averaging the array, there are multiple approaches you could take, look here: [https://stackoverflow.com/questions/10359907/array-sum-and-average](https://stackoverflow.com/questions/10359907/array-sum-and-average) The examples in the stack overflow post assume you have an array of numbers, not an array of objects, so you would use `map` to change the array you have into an appropriate array to get an average from like so: `npses = masterTable.map(function(row) { return row.NPS; });` \-- now npses is an array of numbers! Here's how map works: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) Good luck!
If only there was a way for redditors to qualify content as good or bad. I don’t know, maybe some type of rating or voting mechanism. Maybe like stars or up and down arrows. Just throwing random ideas out there.
I am just a designer with strong html/css/wordpress lurking here because every authority is telling me if I don’t learn JS soon I am toast 😐
r/learnjavascript is more active
I don't think the problem is the spam. I think the problem is the lack of delivery on a contribution to javascript. Sure tell us the cool stuff you've made but deliver on how, why, what. 
I'm okay with it. I have something like two years subbed and just recently the sub has started to get some life. I'm good with the content, many useful articles other not so much but that's okay with me.
I have no problem with vagueness at this point.... something please.
This. 
Yeah, I just wish there was more flame baiting. I love watching people argue about frameworks. /r/programming has more of that so I spend more time there. 
Ember can knockout vs jQuery vs native
Is this an API you are writing, or a third-party API?
Yes, I found this deeply annoying because 8 out of 10 their explanation is vague compared to, say, MDN.
Third party. 
Some subs implement a blogspam policy that fairly aggressively polices blog posts / uninteresting self-promotion. Works really well IMO. The small amount of people that probably get anything out of those posts would pretty easily be able to search the sub or google for the same thing though. Seems like the community here would be pretty torn on something like that though.
I’m not sure if you’re new to programming but the most appropriate response seems like ‘hello and welcome to javascript!’ I think it’s a great language but it’s forever going to attract bandwagon hoppers in a way that’s healthy for the development ecosystem but offputting to someone looking beyond that/for some foundations to latch onto. I’m also new and had to check out more ecosystems to start to understand this. There is a lot of really cool stuff going on in JavaScript, but there is a lot of it that seems like people have know idea why they’re applying it the way they do. At least from my perspective. If you get burnt out on it, check out another language or just try to understand and put up with the people that hate JavaScript unconditionally. Trying to rationalize that attitude is exhausting. It’s worse! It seems to me the reason that people gravitate towards self promotion in JavaScript is because it’s understandable resume fodder. Of course people are going to keep posting this kind of stuff; every time you are considered for a job this might be he type of thing that distinguishes you from someone else or gives you an angle to get your foot in the door. I don’t really think that’s a good bing but I also don’t necessarily think it’s the worst thing. It makes you want to pay for quality instruction or at least learn how to filter the good or the bad, right? Like it’s an equalizer in the marketplace. There are so many places to learn whatever you want but the quality matters so people like us start noticing when things get noisy. If a resource is busted for you, you have to find another one or make it better (or comment to gauge whether other people are noticing). If remarking on the poor state of content makes it better that applause hell yeah. If a specific resource isn’t doing it for you, look somewhere else! It’s r/learnprogramming! Maybe you graduated. There are plenty of good resources out there. I don’t think you are, but if you’re upset about the content here just use it as another resource and contribute meaningful links to what might help people to make it better. 
You need a proxy server.
I feel like there's more people trying to teach JavaScript in the world, than there are actual JavaScript coders
I get really annoyed by the repetition of the words "free". Like that's even a selling point at this point? Don't even get me started on how every video series is a "bootcamp".
Do you mean `setTimeout()`? 
What happens when you click one of the links in the stack trace? 
Yup, that's the one
For the curious, this poll comes out of a TC39 discussion on the expected behavior for optional-chaining operator: https://github.com/tc39/proposal-optional-chaining/issues/65
Syntax error
Hehe, probably should've expected that as an answer
That's interesting. It isn't very intuitive at first glance, but I'd use the hell out of that operator for the amount of time it'd save me checking if objects exist
Thanks /u/left_pad! --- &gt; After all, seeing "stage-0" says nothing. My hope is that in making the decision to use proposal plugins explicit, people will have to learn what non-standard syntax they are opting into. More intentionally, this should lead to a better understanding of not just Babel but of JavaScript as a language and its development instead of just its usage. This. SO much. I had no idea what any of these 'stages' meant until I dug deeper into babel, albeit that was a good thing for learning in the long run, but I didn't really know what I was signing up for. Excited for the future of Babel! Thanks for all the hard work you do.
Yeah, cool huh? Regardless which behavior ends up chosen it'll be pretty damn useful, especially for Relay users.
I’m aware of that, and that was more or less my point: companies certainly use various technologies, but that doesn’t necessarily make an article about RESTful Node APIs outdated/irrelevant.
Well frankly, you are, unless you want to get into management or become an analyst. I'm sure there's some demand for static websites but usually the people who want a static website aren't willing to pay much.
Not at all! I've written a blog about this here same subject, check it out: medeeeum.com/cliiiicckeeeee
&gt; Downvote what you aren't interested in. Upvote what you are interested in. That's not what downvote is for though. &gt; Vote. If you think something contributes to conversation, upvote it. If you think it does not contribute to the subreddit it is posted in or is off-topic in a particular community, downvote it. &gt; Consider posting constructive criticism / an explanation when you downvote something, and do so carefully and tactfully. 
I was _really_ hoping you had a link to your blog post about this topic on medium. Am disappointed.
Combining the Feynman technique with Pournelle's Law ("90% of everything is crap") is Useful. I've noticed, too, the recent prevalence of Medium.com links. Since the site itself is implacably hostile to code publishing/discussion (and is itself increasingly spammy), take that for the Gibraltar-sized grain of salt it is.
Whatever as long as it is falsy.
I raise the stakes: React vs Vue
I am really a visual designer, I learned html/css so I knew had to build realistic layouts for the web. As my skills got more refined I started to view html/css as its own design medium, especially given (in my experience) the disconnect between the design and development process. I think learning javascript will inform that as well, though it’s much farther removed from my true expertise than html/css. I know a lot of people don’t like it, but WordPress was a great tool for someone like me. I can build a very capable, proper, customized (in form and function) theme in WordPress, but would never dare call myself a developer. Learning javascript seems like a necessity with the recent changes they are making. My main goals are to be a visual designer that can work seamlessly with development teams, be able to build/maintain my own portfolio site and have the ability to build solid custom WordPress sites for freelance clients (I have no illusions about building “the next Facebook” anytime soon). I like learning this stuff but have always been wary of falling into the rabbit hole and the further along I get in javascript the more that concern comes into focus 😬 But at the end of the day I find learning this stuff fun and I make good progress day by day. Just looking to ascertain the natural line in the sand between “front end design” and “front end development”!
Number zero, empty string, boolean false. Those are pretty terrible default values for non-existing properties.
React? Never heard of it. I wish this sub would mention these things every now and then
Can't even count how many resumes I've seen with YelpCamp claiming to be their own creation. At least change it up somewhat, copy-and-pasting code shows employers nothing except laziness.
If you’re a good designer with a strong emphasis on UX, transitions and animations, there’s no need to code too. Just look how bad usually coders are at design, it’s two different jobs and that’s ok! You can’t be specialized in everything, but you need to need really good into something. To me id’be Smarter to leverage marketing skills to be able to better advise your customers on a « global strategy ».
Well from my perspective, many ES6+ features have been inherited from CoffeeScript (destructing, splats/spread, classes, etc), and in CS it's undefined, so let's stick with that :)
UPDATE: I thought it was a floating point bug, but I'm trying with regular integers and things aren't looking great for Array.sort - maybe an algorithmic bug?
This looks really interesting. Is it possible to use lit-html instead of react for view layer?
jsfiddle would help
Perhaps you should strive into the UX/business direction? If your true passion is the design/usability then that’s where you can find that power.
Likewise, I worked a lot of shit web design jobs before I earned anywhere close to 80k. My first full time job as a PHP dev in 2007, I earned a whopping 30k.
Good point - I'll update this with a link
I agree with that to an extent, though learning html/css has made me WAY more competent designing for the web. People malign the term “web designer” (“front end designer”?) but it is a very real distinction. Almost every (talented!) designer I know has no clue... they build shiny beautiful layouts that crash and burn come development time. When I build something in a design program I am thinking ahead in html/css and my development handoffs are immaculate. My client will never sign off on an unrealistic expectation and the development team has no excuse not to produce a site identical to the design. Now, if you were to say “no need to learn programming” that seems right on, the deeper I get in javascript the more that comes into focus. BUT, I still want to learn enough about “presentational javascript” to keep reinforcing my ability to design for the web.
I think it is indeed intuitive that it is `undefined`... once you understand that it is _not_ "about `x`" but "about `y`". That is, the question `?.` asks, the _check_ it executes is applied on `x`, sure, but the **result** of the `?.` operator must always be about `y`. Given that, `y` "is" `undefined` (non-existent), and clearly not `null`, (present but empty).
”You can read more about this on my medium post...” 😏
I can't tell if this is a joke or not... You know async/await is based on the Promise spec and not callbacks, right?
You mentioned the word 'joke'. Chuck Norris doesn't joke. Here is a fact about Chuck Norris: &gt;Chuck Norris once lost the remote, but maintained control of the TV by yelling at it in between bites of his &amp;quot;Filet of Child&amp;quot; sandwich.
`Array.prototype.sort` compares, by default, strings, not numbers. So see: https://jsfiddle.net/z5hq0wnx/6/ And then see: https://jsfiddle.net/z5hq0wnx/7/
Its a good suggestion. Though I very much keep the user experience in mind during design, true UX seems to involve a ton of stuff that I am far less interested in devoting my life to. I would much rather spend my energy building complex and unique responsive grid layouts than conducting interviews to generate user profiles etc. :) I am a graphic designer, just trying to give the process of designing for the web all the attention to detail I have given to the intricacies of designing for print. I don’t need to know how to run the printing press but I absolutely need to know how to build the mechanical file to spec in order to achieve the highest quality results. Not really looking to change my career path so much as reinforce my core skill set. I also enjoy being able to build/maintain my own site 100% solo... super fulfilling and a great vehicle for learning. Also, I enjoy it.
That would be groundbreaking.
Ooh, great, thank you! This caused me a ton of confusion
Hm... happens right around 8e-7. 
The default sorting comparator first converts all members of the array to string, then sorts by unicode code point. If you want to sort by numeric value, you will need to do: numbers.sort(function(a, b) { return a - b; }); It's documented in MDN: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Array/sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
See ugwe43to874nf4's response - it's a lexical sort, not a numerical sort. That's why we run into this - the e is lexically after everything else, hence that issue.
I knew someone would cry about Promises. I didn't bring them up because they aren't important for understanding the problem async/await solves. I am perfectly aware that async/await is implemented with Promises. But I imagine most people who understand Promises aren't struggling to understand async/await.
Bottom of post: looking to hire a 1337 ninjavascript hax0r? Contact me! I'm definitely not desperately unemployed!
You can pass a compare function into sort to get the behavior you are looking for: `numbers.sort(function(a, b) { return a - b });`
Well a sub wiki, with all essential links to resources, must read books and other sorts of must know data can be created.
Tough to replace good ole fashion hard work...unless you're a genius I guess ;P
&gt;The other day there was a tutorial posted for writing a todo app...like, seriously? in jQuery no less 
Hi! How do you justify the need for trying to imitate such a low level data structure? I think linked lists are useful in C because they don't have data structures like maps, queue etc implemented in them. But in javascript we have objects that are very easy to work with. If I am missing something please ligthen me up! :)
In theory, perhaps. But in practice downvotes are a useful to limit content one doesn't want to see. Most everyone uses them in this way. Even though there may be rules written down somewhere saying that "one oughtn't downvote in such-and-such a way" doesn't mean that one actually needs to adhere those rules. It's a very convenient tool.
I'm guilty of providing such "How to" posts. However, I also know that I would never post something here unless it had content that I felt was valuable to the community. That's the cool thing about reddit though: bad content can be downvoted an good content can be upvoted, regardless of how it's presented.
I'm not "crying about promises", but thanks for the charitable interpretation of my comment. I only brought it up because, contrary to what you've said about it not being important for the problem, I believe it's pretty fundamental. Promises are the asynchronous abstraction that the community, rightly or wrongly, has settled on, and now it's being built directly into the language in the form of await. For someone new to the language it's not a detail you can just gloss over. 
Please someone put an end to it! Literally I’m so close to unsubscribing. I might as well just read medium everyday! 
It's up to you to decide how far you want to go protecting the user from themselves. Users should be using full disk encryption, prevent physical access to their computers, and have a strong password and short screen lock timeout, however.. what users SHOULD do is never what they actually do. :D I see a couple different directions you could go with this: 1) Just store the token in [chrome.storage](https://chrome.storage). As an analogy, if I log into my Facebook account and someone steals my unencrypted, un-password protected laptop, they have access to my Facebook account via the active cookie my browser stores (in plaintext!). 2) Require login to third party API each time your extension starts. 3) Host your own backend, store the users' API key in your backend, and require a username/password to use your extension, only hold the API key in memory. As a caveat- do you trust yourself to store ALL of your users credentials safely? 4) Have the user create and enter a local password each time the extension runs, and use that password to encrypt the keys prior to persisting into [chrome.storage](https://chrome.storage). [The Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API) has been in Chrome for quite a while, and delivering your JS bundle via the Chrome extension site, as opposed to over HTTP alleviates a lot of the "don't do crypto in the browser" paranoia.
I don't think there has been an increase, no. At least, not in quantity. There _is_ a lot of self-promotion, that is true, but I believe that the _ratio_ of such content is similar to what it has always been. The "problem" is what kenman mentions: volume. The sub has grown a lot and so, with a similar ratio the _quantity_ of self-promotional content is now larger. You probably remember ~3 years ago (maybe it was more, I don't really manage time too well, sorry). The sub was _much_ quieter and IIRC we did have some temporary increase in self-submitted content and it was clearly noted. Then some people which produced excellent content and submitted it either made an effort to signal it was self-submitted or stopped submitting their content, which was unfortunate IMO. ---- Having said this, I _do_ think there has been some qualitative change in the subreddit. For one, even if the ratio of _self-submitted_ content is IMO similar, the **quality** is clearly much worse. That is, nowadays self-submitted content is sometimes but _rarely_ good. It has become more and more common that self-submissions are just spam or _low-quality_. Maybe in that sense it has indeed gotten _worse_. I'll add that there is also a noticeable increase in submissions that ask again and again the same questions. Questions which I would love if they migrated to /r/LearnJavascript. (I once offered to keep a FAQ, to help with this a bit, but nobody ever reads that and with the redesign, the subreddit's wiki is all but ignored, so... *shrug*) But even so, I don't think the _ratio_ of this content is too different either. There's more of it because the subreddit is more active. I do, however, feel like the subreddit has indeed changed substantially. Lately I've been thinking frequently about just leaving it. I do not know exactly what it is about it, but I do not enjoy it as I sometimes did before.
Ya'll were upvoting posts about CSS the other day so....
Burns the stakes: Wordpress vs React
It's a modular, ergonomic, agnostic, granular, flamboyant and pragmatic tool for writing SPA's, that's all you need to know really.
Clean code is code that you or anyone else can come back to in 6 months, take a look at it, and figure out what it is doing. Personally, for an application that does a lot of transformations of data like this, I always include lodash and use chaining extensively. With lodash, you could succinctly represent this data flow as follows (this example doesn't even require chaining) `const oldestPerson = _.maxBy(people, "age")`
What is this, Facestagram?
Hahaha wow how do I be cool and say cool words like tard and virgin hahahaha losers hey !! you and me are super cool tough guys tho right?
Need more active mods, or just more mods. Also better automod - any post with 'react' and 'angular' in the title can be automatically binned
solved using getElementsByClassName("Area")[0]
You can learn JS my friend. I don't have a programmer brain at all and struggle with basic programming challenges such as the FizzBuzz challenge. I come from a Photoshop background, and for whatever reason people today come to me for JavaScript help. I've found that a creative brain helps a lot with structure and architecture and solving problems in a pragmatic way, compared with a typical logical programming brain.
We could go all /r/polandball and have a specific list of forbidden tutorials that gets updated every now and then. "What's new in ES6", "How to use `this`", "React vs. Angular/Vue", "how to write a TODO app" have all been mentioned in this thread already, and would probably already spare us quite a few of those articles.
Alright! Presentational websites will never go away so i don’t think you’ll disappear with your current skillset. Unless all your clients suddenly decide they want intricate SPA’s instead. I have a heavy JS trunk and am currently developing a monolith SPA. We do get design suggestions from business side, but we always have the last word (within reason). So that freedom you seek design wise, tend to also exist for us gritty JS developers. If you want to have it.
It's still the wrong mindset to have even if everyone else has it. Voting should be used to help the community as a whole, not to make things slightly more convenient for yourself. But hey, I guess this is how we ended up with Trump as president.
*`event.target`
What does Trump have to do with any of this?
"How I have created my first react component" 
Should be pretty evident from the context of my post. We're talking about how people should be voting, and the results we end up with through those choices.
Set yourself apart in what way? Applying for jobs?
Have people no shame!
but then how will i know that to-do app tutorials are on my to-do list of things to do?
It probably hasn’t loaded by the time you’re trying to play it?
Didn’t know the Fiesta ST could make fire. 
Another thing I hate is blanket hate for jQuery. jQuery did an fantastic job back in the day and is still in use in many of *the modern javascript tools you guys cream your pants over*. It's just that it is hidden in the resources for those tools instead of you using it directly. In 5 years React Native or whatever might me out of fashion and have been replaced by something better, but don't hate on RN then, because right now it solves a problem we all need solving. This sub is spammy, but the bandwagon hipsterism is what irks me most. 
It may have a backend for something which isn’t possible on GitHub pages?
2 whole days since the last "Lessons learnt writing my *first* react app" post. 
Am I the only one that wants `undefined` to get removed/replaced by `null`? Speaking of "intuitiv" undefined is such a non-intuitiv construct for me.. I get it.. it's a level beyond null, since you can manually set a variable to null and it's actually defined at this point, while undefined means that it's not defined, but do we REALLY need this seperation? In PHP the only time you want to check that is when you want use `isset`, which checks if a variable is set OR is not null! Otherwise you can simply check for empty. Small example: https://3v4l.org/nNPbg I probally missing something otherwise I can't explain another use of undefined. Maybe it's just how it works in Javascript? I always asked why there is no isset check within Javascript. It's very forgivin yes, but sometimes not. The optional chaining operator is a welcome implemenation and I would expect in to return "null" on default. I actually would also expect to get "null" on an optional parameter that wasn't set, instead of checking if it's defined or void 0. If you all disagree with me and think that undefined is a wise thing and should stay, especially in optional parameters, then I would expect the "optional" chaining operator to behave the same and return undefined, since it's really not defined instead of beeing null, which seem to be a valid setted state in Javascript. 
hmm, gonna try storing the audio in the session storage.
It’s every single fucking post literally. Spam, spam, spam and probably some bacon and eggs. 
Now while you’re at it, get rid of all the shitty blog promotions so that stays at 300k or what ever it is. As I can see it going down pretty quick if someone doesn’t do something about it. 
I’d try putting the play command into an oncanplaythrough handler: https://stackoverflow.com/questions/8256915/javascript-audio-onload
Hey guys, in this video I'll be discussing why PHP is the greatest web framework ever and why you should be using it instead of React or Ruby on Rails. \*talks for 5 - 15 mins without getting to the point\* So without further a do here is how to install node and npm \*talks for a few minutes more before actually starting\* ... later that day ... in the next video we'll learn how to make a hello world app in PHP, HTML and CSS using node as our backend \[?!?! wut ?!?!\]
undefined
What you are talking is a form of [Session hijacking](https://www.owasp.org/index.php/Session_hijacking_attack), and is a rather hard to solve problem, but rarely one that you'd have to worry about in practice. As long as the key is long and unguessable, and the communication is done over HTTPS, you're more than likely to be fine. That said, there are some ways to help mitigate it you can find on google, but these aren't directly related to where to store it, but rather with how to authenticate that it really is from the appropriate user and not a hijacker. More in regards to the topic at hand, namely how to store it: Storing the token in local storage or cookies is the way to go. It's how everyone does it. The warning you mention above really is in regards to things like username and passwords. The token in itself is *not* confidential, as in the string itself does not contain sensitive information.
I agree. Please vote or comment in the Github comments accordingly to make your voice heard, so we don't end up with the nonsensical and illogical semantics that the OP in the Github thread proposes.
Medium is part of the problem, so much so that if I'm looking for a 'how to' something I now avoid medium links, the quality is too low. Seems like everyone and their dog jumped on Medium to let the world how to write bad code that isn't tested and doesn't work. 
BOOM! This is what other subs do when they want beginner-level repetitive content off the front page. Or maybe it's time for a js-up-and-running own sub, where tutorials and resources are the primary goal of the cub? Maybe I'll go make it now. There is already /r/learnjavascript that covers much of the same.
Thanks for the encouragement. I really just want to learn the basics and then pull back from the rabbit hole :)
Thanks for sharing!
 You're looking for HTML templates. They look like this: &lt;template id="row-template"&gt; &lt;div class="row"&gt; &lt;b&gt;Row&lt;/b&gt;: &lt;span class="content"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; That's "inert DOM", which means that the browsers parses it and figures out the DOM tree, but it doesn't do things like load images or run scripts in it. In other words, it's parsed, not run (yet). You use it like this: const tpl = document.querySelector('template#row-template'); const node = document.importNode(tpl.content, true); container.appendChild(node); Each time you import it, you get a new copy. Once you have the copy, you can fill in the data with normal DOM manipulation: node.querySelector('.content').textContent = 'JS &lt;3'; Use `textContent`, not `innerHTML`, because you want the string to be interpretted as text (all characters are shown as-is), not HTML (tags, etc, get parsed). Complete, working example: &lt;div class='container'&gt;&lt;/div&gt; &lt;template id="row-template"&gt; &lt;div class="row"&gt; &lt;b&gt;Row&lt;/b&gt;: &lt;span class="content"&gt;&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; const container = document.querySelector('.container'); const tpl = document.querySelector('#row-template').content; function main() { for (let i = 0; i &lt; 10; i++) { container.appendChild(renderTemplate(String(i))); } } function renderTemplate(content) { const r = document.importNode(tpl, true); r.querySelector('.content').textContent = content; return r; } main(); &lt;/script&gt;
It's definitely a very useful tool to learn and skill to have. Also consider that even if you weren't toast (I'm not suggesting you will be), adding JavaScript to your tool belt could land you a much better paying job.
As a general rule I strive to constantly be learning and making more money 😎 Though I am sure there will be more than a few eyerolls from people fed up with the recent “javascript n00b stampede” into this sub and the workforce in general 😉
&gt; many ES6+ features have been inherited from ~~CoffeeScript~~ [**ECMAScript 4**](https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_(abandoned) FTFY 
If object A has prototype B, that means that B is another object that A refers to sometimes, including as I'll describe. When you write `shop1.employees`, what that means is "read the employees property of shop1 if that property exists, otherwise read the employees property of shop1's prototype if that property exists, otherwise read the employees property of shop1's prototype's prototype if that property exists, and so on". When you write `shop1.employees = 15`, what that means is "set the employees property of shop1 to 15". Note that it doesn't touch shop1's prototype. So, after you do that, you have a structure like this: { employees: 15, (prototype): { employees: 10, }, } You can test this by then writing "delete shop1.employees", which means "remove the employees property from shop1" - again not touching the prototype. So, instead of becoming `undefined`, `employees` will revert to `10`.
Like this? var x = document.title; var tc = sessionStorage.getItem("tc"); var sound = new Audio("NewTicket.mp3"); sound.addEventListener('ended', function() { // document.title = document.title + " playback ended"; alert('ended'); }, false); sound.addEventListener('canplaythrough', function() { sound.play(); document.title = document.title + " sound playing"; }, function() { document.title = document.title + " couldn't play sound"; }); if (tc == null) { x = x.substring(x.indexOf(" ")+1); x = x.substring(0,x.indexOf(" ")); sessionStorage.setItem("tc",x); } else { x = x.substring(x.indexOf(" ")+1); x = x.substring(0,x.indexOf(" ")); if (x &gt; tc) { if (sound.canplaythrough); sessionStorage.setItem("tc",x); document.title = document.title + " PLUS"; } else { if (sound.canplaythrough); sessionStorage.setItem("tc",x); document.title = document.title + " MINUS"; } } 
(\([0-9]+\))? That matches a number surrounded by exactly two brackets
I don't particularly like the _need_ for both `undefined` and `null`, but to better understand the difference, let's forget for a moment the `?.` operator. Traditionally (i.e. at a theoretical level), the idea is that `null` is "about the value", and `undefined` is "about the property". That is, when you ask if a certain property is `null`, you're asking something about its value. You _assume_ that the property is indeed defined, but even being defined it may not hold any particular value. So it's `null`. On the other hand, when you ask if it is `undefined` you're not really checking the value, but the property itself. You're asking "Does such a property exist?". On the other hand, there is some confusion because you _can_ assign `undefined` to a property. You can even define a variable and assign `undefined` to it. This certainly produces confusion and quirks... but this comes from _a certain usage_ and so the discussion is different. If you don't do this kind of thing (i.e. you assign `null` to signal "no-value" and, generally, only use `undefined` for comparison, not assign it), then it should be clear what the difference between `null` and `undefined` is about. The comparison with PHP's `isset` is not completely equivalent. In PHP there's also `defined` for constants and `function_exists` for functions. But these (`isset` included) are about _variables_. You have `property_exists` which is about properties and [behaves](http://php.net/manual/en/function.property-exists.php) like comparing strictly to `undefined`: &gt; As opposed with isset(), **property_exists()** returns **TRUE** even if the property has the value **NULL**. ---- P.S. It _could_ be argued that there is one particular quirk. When you do `let someVar;` instead of becoming defined and being assigned an empty value (`null`), it gets `undefined`. Oh, well, we all know JS is not perfect xD
enroll yourself on a course like this. [https://www.codecademy.com/learn/learn-jquery](https://www.codecademy.com/learn/learn-jquery) Reading the source code to jquery and understanding that pretty much means you can understand javascript syntax. Start to build things with it and use it is a great introduction to it
Outrage culture has ruined most things. The sheer fact you fail to see the comedic flow in that comment is a clear indication that you’re both a cuck and a little bitch not to mention a little socially awkward.
It doesn't work. I don't want them to be matched as a must. I only want them to be optional. Like 333 333 3333, this won't get matched because it isn't surrounded by two brackets which is sadly, not what I did want. I changed some of it and it still doesn't work correctly ):
You have to escape the parenthesis. Yoshi gave a good answer, notice the / before the ( or )
The [Live Chat Widget](https://www.joleadosystem.com/features/) on the webpage helps engage the visitors directly into supportive chat sessions without having to scroll all over the site. 
Oh my code is only for the bracket case, the case without brackets you have to add. If the bracket part is always at the start and the numbers are separated by a single space or a minus it would look like this: (\([0-9]+\))?(( |-)[0-9]+)*
Thank you so much
It doesn't work as it is right now. I had to make a boolean(|) to differ between the formats which is something I tried to avoid.
[gron](https://github.com/tomnomnom/gron) is very helpful if you want to grep something with JSON path.
None of these comparisons are totally fair. Javascript's trend towards OO did not make it "less functional", it made it more scalable. I've worked with great Javascript developers who have precisely 0 idea of the memory management involved in C and C++, and I've written tonnes of C so I'd say I understand memory management. The second question is based on an implication that functional programming is "newer" than OO programming. Older ones here remember when OO code the new fad that was supposed to replace the old functional code. You never really switch away from Javascript because it's the only real frontend choice. I use Erlang where it's an applicable choice.
I completely agree that I would expect this to be `undefined`. However, I do think OP's use case does have merit and could see some other operator working like that. Whether it's worth actually adding that other operator is another question, but probably not. If you want to check for null vs undefined in the intermediate objects then you'll have to do so via another method.
Go would be a pretty awkward choice for GraphQL anyway, right? You'd have to write out bomb loads of schemas to cover different results?
`(1)(\\s+)(\\()(\\d+)(\\))(\\d+)(-)(\\d+)` I believe this is what you want. [JSFiddle DEMO](https://jsfiddle.net/kuao2j0q/)
Maybe add few megathreads with topics every weak. For instance mon to wen - vanilla js, wen to fri -angular etc etc, and encourage people to self promote there, but forbid it in normal threads?
There _was_ a link to /r/LearnJavascript in the sidebar. There _is_ at least the _beginning_ of a FAQ compilation with a handful of very common questions. But, alas, with the redesign the links in the sidebar are nowhere to be seen, and if people already paid very little attention to the sub's wiki section, now they don't even have a link to it. So... it is a good idea, sure, but it doesn't seem to work _that_ well.
As mainly a DB person, null. Any operation upon NULL other than the identity comparisons (`IS NULL`, `IS NOT NULL`) and equivalent functions (`COALESCE` for instance) should result in NULL. From a JS point of view I would accept `undefined` as making sense too.
That's the quality of JS ecosystem in general.
It's okay, I found a solution, by using the boolean | to differ between formats. I know that it's a horrible solution but that's all what I got: (1\\s)|(\\(\[0-9\]{3}\\)|\[0-9\]{3})(\\s|-)?\[0-9\]{3}(-|\\s)?\[0-9\]{4} Anyway, a new problem has appeared, now it matches any thing even with anything other than the optional 1, even if it was 2 or 3, it will still match it, as you see here: [https://regexr.com/3rkr1](https://regexr.com/3rkr1) I want it to match only if it is 1 or not. I don't want it to match 2 xxxxxxx or 3 xxxxxxxx, either with 1 or not match any other number in its place. Any solution please? I'm almost going crazy because of this regex thing, when I fix something, a new problem appears.
Just don't stop learning! Step by step you'll expand your knowledge continuously, that will result in better and **conscious** **decisions** **taking**. Here's what I mostly do - start learning and using a new framework, because most of the time, the frameworks comes with their good practices and the key decisions are already taken for you. Once you feel comfortable with the framework usage, then it's important to understand its main principles and concepts. If so, then you're a one step ahead. This is a great way for learning the programming principles, because you have the right context. Otherwise, just reading without having the right examples / context - you can get lost easily. Some time ago, I wrote an article about [how to organize JS / jQuery spaghetti code better](https://notes.devlabs.bg/how-to-organize-our-js-jquery-spaghetti-code-better-78224ab0137). Both here and there, my accent is on the conscious decisions taking. In the article I rely on some main programming concepts, while I'm refactoring the spaghetti code. So I'm sure you can take some inspiration from the refactoring I did there.
I understand, well that makes it a bit better to understand if it's consistent at every point. Let's take following code: var test = function(a,b) { console.log(typeof a, typeof b); } // or function test(a,b) { /** same as above */ } if you execute `test(2)` it will return "number undefined". Is the reason behind this, because it is checking for the property `test.b`, which is then `undefined` or is this some sort of inconsistens? &gt; Oh, well, we all know JS is not perfect xD I think that fits to every language out there :)
"Fundamentally good code is a love letter from you to the next programmer." I love this, great advice.
I _think_ the rationale there is more like "you didn't pass anything", as in, you didn't pass a value which was empty or undefined or anything at all. So `undefined` represents that better. These, however, are places I personally think one should not have a very strong opinion on the subject. I mean, being more strict, you could think about the expectations of your function and then decide accordingly. Is it reasonable to _demand_ some sort of value for `b`? Do you not mind if `b` even exists? If you need a value, the "correct" value should be `null`. If `b` is really optional (as in not required for most operations), then you don't really care whether it is `null` or `undefined`. I don't see it necessarily as an inconsistency but I also don't think it is something you should care _too much_ about in your function if the function is well thought out.
`foo?.bar?.baz()?.quux` should be the first falsey value in the chain. Alternatively, if you’re using the value as an expression, I’d be happy if the standard insisted the last term is always `?: someDefaultVal`
Mp3 file path correct? Anything in console logs?
Mp3 file path correct? Anything in console logs?
I respectfully disagree, but mostly because of my mental model of `A?.x ` as sugar for `A &amp;&amp; A.x`, which would be `null` if `A` is null.
Hahaha yeah you and me cucks for life hey man !! We should hang out you can make me less socially awkward I wanna be cool like you
That was extremely useful as an experienced engineer. I feel like I understand a lot more about how the DOMParser works now, thanks 
Local host is weird with cors. There’s a chrome extension you can get to allow cors bypass on localhost 
That's a valid way to see it, of course. But according to the proposed spec, that's not the idea. Other than that, my opinion is not very strong about how it _should_ be, but I do _prefer_ getting back `undefinded` instead of `A`.
If the server isn't sending a "Access-Control-Allow-Origin" header, then there's nothing you can do. You can check that in the network tab along with the rest of the information about he transfer. If it is sending it, then follow Endorn's advice.
`/^(1\s)?(\([0-9]{3}\)|[0-9]{3})(\s|-|)([0-9]{3})(\s|-|)([0-9]{4})$/gm` this one works as you expect using the global and multine flag [JSFiddle DEMO](https://jsfiddle.net/tiagovit/c7emgkrx/)
I found the issue. It is searching for the mp3 on the url. How can I make sure it tries to load it local?
Here's a nice long [thread](https://www.reddit.com/r/webdev/comments/8rum5u/is_there_a_job_market_for_css_experts_with_weak/) that you might want to look into that discusses that very issue. 
I'm guessing this will be the main differentiator between people who expect `undefined` and people who expect `null`. I do not see it as sugar for `a &amp;&amp; a.b`, I see it as a different solution for the same problem that `a &amp;&amp; a.b` is usually solving. 
And \`''\` if \`A\` is the empty string? 
Your comebacks are poor and ineffective, much like your grammar. You’ll never be as cool as me anon and you will be lucky to yield a girlfriend who doesn’t dye her hair purple and weigh less than 90kg. Don’t be a social warrior buddy, know your place.
Specifically I would like to see a few code along tutorials that use typescript and/or testing for small-medium projects. I also wouldn't mind a little more material on the fundamentals of programming and by that I don't mean things like strings, arrays and algorithms, I mean articles and videos that explain the part about understanding requirements and parameters, then working out the logical steps the will be required to accomplish the requirements all before writing a single line of code. I wonder how many self taught devs even know what a flowchart or process map is. Maybe I'm just an old fart, the first tool I ever used to make programs was [this](https://www.amazon.com/Rapidesign-Computer-Flowchart-Template-R54/dp/B000GOWAGM).
Cors is a limitation by the browser, so it is normal that the server still sends the data. 
Javascript uses `undefined` as a way to avoid throwing exceptions. var foo = {'a': 1'}; var bar = foo['b']; In Javascript, `bar === undefined`. In something like Python, you'd get a KeyError exception because 'b' does not exist in foo. var test = function(a, b) { /*...*/ }; test(1); In Javascript, inside of test, `a === 1, b === undefined`. In Python, you'd get a TypeError exception because test takes 2 arguments, but you only gave it 1. Personally, I prefer Python's way of doing things. Failing fast makes it much easier to track down mistakes. Javascript was designed to be very lenient and to accept imperfect code.
There are a few points I don't really understand in the article. First : "This means you don’t need a tool like Redux to manage state properly". Does Hyperapp really provide more tools than React 16.3 to manage our state ? I mean, today if you need Redux, it's because you need to access the same data from several places with significant preprocessing. And I would be surprised if a very small library provided more tools than React on the subject. Second : I always tend to be skeptical when someone just says "the API is way simpler" without talking about the trade-offs. For instance, in React you can keep the API very simple if you use only stateless component, but you loose a lot of features. Maybe Hyperapp has a way better API in term of ease of use with almost the same flexibility as React but I would like to see the trade offs, not just the "it's easier". Third (and last) : From my point of view, React is quite hard to get used to, more than Angular. But I don't see a lot of additional complexity when you worked with it for a few months. There are some advanced patterns (HOC, Render Props, Compound Components...) but it's not a library with a very large spectrum of features and I find the "I certainly feel like an absolute beginner, even after about a year of using them" quite strange. The fact the Hyperapp uses JSX is pretty cool since it's probably my biggest crush of the React ecosystem.
Well, no offence to those who hang out here, I do it too, but it has gone full noob. I have felt the last resistace of experienced voices go silent recently. People just want to post blogging rehashing they just learned to establish relevance. Low grade brand building. That just can't be deep, sage level content, because you only do this early in your career. It's kindof a kid thing, too, becoming ensconced in the online community, like it's a real place, because you can't tell the difference yet.
My friend put me on a boot camp at a similar timescale, and even I would say it's too early. However, it's still possible to look into frameworks, but less likely to make an impact for what you are working on since having strong knowledge of JS alone is arguably the most important. So go back and try to learn key JS topics, especially es6 like other posts have mentioned
Oh true 
Another badly put together shitty self promoted article. 
Thx I do remember that one. Seems to me like CSS is more of a prerequisite than a specialized skill these days, having been supplanted by JS. No doubt there’s a place for pure CSS somewhere but just less than in the past.
Justin this sounds wicked! 😱 I'm using a booking saas for a small project I'm working on and if it was to go live it would cost me $145 a month! I thought about rolling my own as my requirements are very small and launching an MVP doesn't need the bloat that it has. So this is perfect! Will look into this over the weekend and let you know how I get on :)
So I guess you don't bother giving a side by side comparison or any examples of what hyperapp is doing. This is nothing but an opinion piece with no content or useful information. 
Rule zero: it’s never the compiler. 
Check out my poorly thought out Redux alternative!
I think this is becoming more and more the case for reddit as a whole. Facebook quality content everywhere :(. I remember talk about changing the algorithm for what becomes trending. Could that be whats causing this? Or maybe marketing betting on content marketing on reddit? Or maybe a lot of new users on reddit?
[Hyperscript](https://github.com/hyperhype/hyperscript) is a good lightweight solution as you wouldn't be limited by any template language syntax or need any kind of template preprocessor or JSX compiler. document.querySelector('#main-container').innerHTML = h('.container', items.map(item =&gt; h('.item', item.title) ) 
&gt; an opinion piece with no content or useful information like 80% of the posts on this sub lately
This post was removed. Please see our guidelines on job postings and the likes.
I think we should consider restricting Medium articles or something, I swear all I see anymore are Medium posts with no useful information talking about why their “framework that’s existed for 47 minutes” is going to be the new React
Undefined - the argument being y does not exist. But if you're relying on the difference between null and undefined you're probably having a sad time anyway...
No, it would be undefined if A is the empty string, because my mental model is a flawed abstraction :) `''` is falsy, but `?.` only cares if A is null-ish. So `A?.x` will determine that A is not actually `null` or `undefined` and proceed to give you the value of the x property (undefined). Otherwise stuff like `''?.split` would return the empty string instead of a function. I should also state, for the record, that the question was about what was *intuitive*, and for me that is to return null. What is desirable is less clear and I don't feel particularly strongly either way.
I've been using `hyperapp` for quite a while now (and participating in the discussions on the repo), so I'll try to address your points. &gt; Does Hyperapp really provide more tools than React 16.3 to manage our state ? On the contrary, it has less tools. In React, you can manage state locally in your components, have it passed in via state or context, or connect up to a global store. In hyperapp, you just have the global state that's built-in. Then you pass it down via props as far as you need. The components are all stateless functions that transform their props into a view. &gt; I always tend to be skeptical when someone just says "the API is way simpler" without talking about the trade-offs. For instance, in React you can keep the API very simple if you use only stateless component, but you loose a lot of features. Maybe Hyperapp has a way better API in term of ease of use with almost the same flexibility as React but I would like to see the trade offs, not just the "it's easier". The trade offs are similar to if you used React w/ Redux and only connected your top-level component to the store, and used stateless functional components everywhere. You have to explicitly pass down data via props to whatever view function needs it. I wouldn't call it easier to code (boilerplate!), but it is easy to debug and think about. In the current version, there is a way around some of the prop-passing, with a feature called "lazy components" (which should probably be called "connected components"). Instead of `(props) =&gt; &lt;div&gt;&lt;/div&gt;`, you return a function that accepts the global state &amp; actions objects, like `(props) =&gt; (state, actions) =&gt; &lt;div&gt;&lt;/div&gt;`. I believe this feature is planned for removal in version 2, but it is pretty handy for now. Let me know if you have any more specific questions!
Probably because they get asked at interviews from time to time
Thank's a lot for your answer. The \`(props) =&gt; (state, actions) =&gt; &lt;div&gt;&lt;/div&gt;\` pattern seems quite nice. The React team is talking about removing the class components in a distant future. I'm curious to see how they will manage the internal state (because I don't think they will leave it, it would be to drastic) and the approach could be nice.
It's almost as bad as the Medium articles that are just selling their tutorial.
What are they and will they make me money?!?!?
We are in the process of adopting it at Carnegie Mellon for our online course authoring platform. We have a typescript/react/redux codebase in place, but the additional type safety and 'built in' reducer / state management along with backing by Facebook sold it for us. We have some components already written in Reason and consider it to be successful so far.
So `null?.y` should also be `undefined` ?
Eh, make it `NaN` and call it a day /s
Are you trying to match phone numbers? If so, this problem has been solved a million times. A quick google search comes back with this: \`\^(\\+\\d{1,2}\\s)?\\(?\\d{3}\\)?\[\\s.-\]\\d{3}\[\\s.-\]\\d{4}$\`
Maybe a system where the user base itself could somehow determine if the content was good 🤔 some type of voting system if you will 🤔🤔🤔 
/r/misleadingthumbnails/
It's bad for learning. If you come here to learn, you may get a crumby education.
I dunno, if you look at the top posts, on here and similar subreddits, the subject matter of the most recent highly upvoted posts is pretty yikes.
To be fair, that thread does have some pretty convincing arguments for returning `null` over `undefined`. I'd strongly suggest reading over both sides of the argument before you decide.
This subreddit is not as bad as /r/webdev yet, at least. Have you looked at the top posts on there? It's not even about programming, its like a schlocky tabloid.
But that’s a short circuit, which is a different form of logic. `A?.` is more a sugar for a `A != null ? A.x : undefined` ternary. `A &amp;&amp; A.x` is saying “Keep chaining this truthy check until a value is falsy or I reach the end, then give me value.” `A?.x` is saying “Give me `A.x`, but please don’t freak out if `A` is undefined.” A short circuit is asking for one value in the chain, but`A?.x` is all about getting that `x`. Right now I tend to suffix `|| undefined` (or `|| null`) on a lot of my short circuits *specifically* to guard against unwanted `A` return values. Short circuits are awesome, but they have dangers like their namesake implies! 😉
I think it's because of all the great options we have on the front-end now. I wrote about this on my [React blog](https://i.imgflip.com/vy0v2.jpg).
Rocks did a fantastic job back in the day, before humankind discovered bronze. 
`?` has been adopted to great effect over in Rust, and it is there to allow you to program the happy path and eject early otherwise. I like this analogy a lot, and it fits `Result` types very naturally. Through this line of thinking, `null` is the first "error" value, and so evaluation in the conceptual chain would stop there - though, honestly, without result types, I'm not sure it makes as much sense for JS.
Speaking with experience from other languages with actual option types, I'd have expected it to be the equivalent of something like: x.map(_x =&gt; _x.y) which would be null.
Personally, I'm fine with it. Its common knowledge that 90% of original things produced are junk, its reddits job to sort out the rest. I'd rather sift through a bit of junk than miss something that genuinely interests me. 
I dunno if you can ever effectively curate a wiki site. Mod became a bad word when people tried.
`null` is a value, `undefined` is the absence of a value. They’re very related and equatable (I use a ton of `== null` checks), but semantically different. i.e. `{ target: null }` is a choice to target nothing, where `{ target: undefined }` is when a choice hasn’t been made yet. The rocket UI might only need to care if `target != null` to know it’s been fired, but the button UI might need the distinction for when the “nothing” button will be lit.
There are people who want to call themselves JavaScript devs, because it makes them feel smart and cool. They love to bloviate online about it, and spout the canned facts they remembered, mistaking rote factual knowledge for conceptual understanding and true cunning. Then there are real ones who just build websites.
Can you paste here an example of your string please ? Because \`JSON.parse\` should indeed be the way to do it
I don't think you can effectively curate social media/wiki type user generated content. The word 'mod' has a negative connotation because people tried.
Hey guys, check out my new maaath.js library that simplifies adding 11 to integers. I know it needs more unit tests and documents but I’m excited!
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Ik that’s what I read everywhere. Idk what I’m missing when I console.log the xkr object this what I see: response: “ \[“Earthy”,”Chemical”,”Pine”,”Spicy/Herbal”,"Pungent","Pepper".... and I did console.log(typeof xhr.respone) and the output was string 
I was just illustrating what would happen if you actually used `A &amp;&amp; A.x`. Discussing what \_feels right\_ is very subjective and, in that case, depends principally on the languages you have learned.
Yes
Why do people write plural using 's though I see it everywhere. People write API's. People write Todo's. Imagine writing framework's. Sounds stupid, right? Just like API's or SPA's.
You played yourself by accepting 30k. I made 36k in 2007 as an admin asst with no skills, no work experience and no industry experience
That's amazing!
function runCmd(cmd) { tcl.queue(cmd', function cb() {}); } runCmd(cmd1) runCmd(cmd2) So the way tcl.queue works is it opens one shell command and runs all the command entered in tcl.queue in that. However, if cmd1 hasn't responsed then cmd2 doesn't get executed.
Maybe, but I definitely don't regret it. I got paid 30k to *learn* PHP from a mentor. I only knew HTML, CSS and JS at the time. Within 5 years I was earning over 100k.
ANd what are you using to make the request?
&gt;function runCmd(cmd) { &gt; &gt;tcl.queue(cmd', function cb() {}); &gt; &gt;} &gt; &gt;runCmd(cmd1) &gt; &gt;runCmd(cmd2) &gt; &gt;So the way tcl.queue works is it opens one shell command and runs all the command entered in tcl.queue in that. However, if cmd1 hasn't responsed then cmd2 doesn't get executed \^\^ that is the issue. One work around was to have the import statement in the method itself, so it creates a new shell each time for a new command, but that seems inefficient and unnecessary. Any better ways?
Would you mind pasting the full response without the ... truncation? What's at the end matters. Does it end with ] or } ? Does your console log actually have the word "response"?
I dont like that when you go up the box rotates around and changes all the angles, i would expect the left and right to stay the same.
It might not be ideal, but the best way to get around CORS is to separate your concerns of front-end and server-side code. What I did with a recent project that had the same problem was run a Node Express server that solely exists to listen for a call from the front-end application; I put the **fetch** call there. With Node, you can install **cors** and apply it to your Express application easily. I'd do that if you want an easy fix. Only thing is that you have to start a server just to get around it, but Express is easy. Hope this helps.
It ends with a closing quote bc it’s a string. But inside the string is and array and I need the data in the array so I’m like wtf. Is this why the API is free? Should I try a different one?
Ajax Get request in Vanilla Js. 
Why don't try fetch api also from vanilla? https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
But then wouldn't you need another token to access the proxy?
Can you copy and paste the exact response you get to pastebin or tell us which API you’re using? Can you also post your code to make sure there’s not a simple error there?
appreciate the feedback!
Logically I believe it should be `undefined` as I don't think it makes sense to pass information on from the parent object, but I don't see the harm in it being `undefined | null`, which has the following benefits: - Keeps the logical distinction between `null` and `undefined` in case the original object is null - Is just as simple to check against (`val == null` checks both)
You’ve discovered monorepos. There’s a lot of information online about the pros and cons of such setups but that’s pretty orthogonal to npm. npm is there to help get libraries on to your machine and the complexity of the system you build on top of that is up to you.
Now trending on GitHub: https://github.com/trending/javascript?since=daily
not to mention the author admits he's a junior to intermediate skill range. I don't get why everyone needs to be writing medium articles... is it for resume building? If I admittedly don't know the best way of doing things, I'm for sure never going to write a Medium article thats just going to be contribute to the tons of outdated javascript fluff for someone to stumble upon that contradicts a solid foundation.
It's not really about the article, but the library.
In high school you mash some preexisting thing and regurgitate it. Example: Here's my book report on Moby Dick and what the book is about. In college you create something new that contributes to existing content. Example: Here's my report on Moby dick and how it relates to post-modern cucumber farming. I'd like to see this sub with articles that contribute vs regurgitate.
Honestly, I've never considered GraphQL and Go, but I'm sure there are solutions around that problem.
Nothing new here. Privates have been at stage three for months (since sept-oct of last year).
I feel like a LOT of the posts should actually be in /r/LearnJavascript This sub feels like a better place to ask questions, share news, etc. Just my opinion - at least the titles are fairly descriptive, so those posts are easy to ignore. I despise Medium and feel it’s partially to blame for the delusional state of people like me trying to change careers. Going off Medium articles; programming is easy, frameworks can be learned in 3 easy Hamburger-style examples and I should be able to pose as a mid-level developer with no experience and negotiate a $100k salary. 
Two writers of the shitty self promoted blogs down voted me. Awww, yeah they’re still shit. 
I didn't realize this was [possibly] being added to js! This operator is awesome. I'd prefer it to return null since I'm just simply used to using it in groovy where undefined doesn't exist the same way it does in js. Though u/ugwe43to874nf4's comment above admittedly makes a lot of sense for javascript. 
Thanks for the tutorial, i just read the first part and it is a pretty understandable tutorial, even though im just a beginner that wants to learn JS..
I agree they are semantically different, however, not a lot of js dev seem to care. So when you're working on a team, the principle of reality dictates to treat them the same way.
Definitely resume building. I've written a few myself (never promoted them though) just to put on my resume. 
https://stedolan.github.io/jq/
I made a codepen with a screenshot of the console when I log the xhr obj and my code.
I made a codepen with a screenshot of the console when I log the xhr obj and my code. [https://codepen.io/UntouchedDruid4/pen/RJeJJE?editors=1111](https://codepen.io/UntouchedDruid4/pen/RJeJJE?editors=1111)
This looks great! Fantastic job. Although, it's a bit hard to keep up with where you're going when going off an edge. Maybe reduce the speed a bit? But wow!
Did you try setting `no-cors` mode? Example: `fetch('//google.com', { mode: 'no-cors' }).then(function(response) { console.log(response.type); // "opaque" });`
Thanks a lot. I guess there could be some sort of difficulty setting to see how you fair against different speeds.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Here you have a working example. http://jsfiddle.net/a3591cmf/3/
Where's the best resource to become a Cors master? So many sites have Cors issues.
Ugly in your opinion. To me, it's a nice way to expose more information just by reading the variable's name (e.g. for code review) while also being the only realistic solution because of javascript's dynamic property creation.
Hi /u/UntouchedDruid4, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/bjmay, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/indjoi, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
okay sorry
right in my opinion, but not only mine. Im sure (or hope) they know what they do, but still wanted to make sure as many as possible people know about this upcoming change.
Got it. Was a misunderstanding. Thanks
+ “vs vue” sees appropriate
Look-out-here-come’s-an-s-syndrome 
&gt; I'm not even sure I need CI come to think of it. what does NPM have to do with CI?
&gt; I respectfully disagree, but mostly because of my mental model of A?.x as sugar for A &amp;&amp; A.x, which would be null if A is null. Arguably that's a problem though. `null` is a valid value, so for non-existent `x` to return `null` is kind of weird. So one could argue that `A &amp;&amp; A.x` is the *wrong way to get the value of `x` in the first place* since it effectively coerces an undefined identifier to `null`.
I think one benefit to having a project broken out into modules is that each module is now versioned. Of course this can cause problems down the line when there are conflicting versions used indirectly; however I find it incredibly useful to know which modules/function exhibit a breaking change. In a single, monolithic repository, it only has one version (unless you manually version your functions, but this doesn't show up when using NPM/Yarn). It also allows you to pull in only what you need. This is particularly useful in front-end development where, if WebPack's tree-shaking decides to ignore a branch, you could end up including more code than is needed in your final bundle.
Can you point to where jQuery is used anywhere in the React or Vue dependency chain?
Whoever it was who entered "raise exception", please stand up xD
Reading this made my heart jump. We share the same first and last name.
I don't find it to be that ugly. I actually like how the hash makes the variable kind of stick out a glance. Even if you didn't know the newer syntax feature, you would know that something is up with these particular variables, which is kind of the whole point. 
how do you write async code in Reason? Promises? Is it pretty ergonomic? I walked through the docs a while back, and remember really liking the language.
I think most people do think it's ugly as hell, but that has nothing to do with usefulness. Not sure what you mean by it being the only realistic solution. Currently people do one of these: function Foo() { const private = 'hello'; this.greet = () =&gt; private; } class Foo { constructor() { this._private = 'hello'; } greet() { return this._private; } } const wm = new WeakMap(); class Foo { constructor() { const private = {private: 'hello'}; wm.set(this, private); } greet() { return wm.get(this).private; } }
Found an ES6 version: [https://codepen.io/dissimulate/pen/eZxEBO](https://codepen.io/dissimulate/pen/eZxEBO)
This operator is really **only** about _ignoring exceptions in accessors_. It doesn't really reach the same level abstraction and doesn't offer the same control having a generic option type may offer. In any case, if you were to have an option type, I would expect it to return something more controlled (a "nothing" type) rather than directly produce either null or undefined.
Don't mind if the OP is also taking part on reddit / answering questions / etc - but if it's just posting a link and no engagement in the community at all, boo :(
I expect it to be `Uncaught SyntaxError: Unexpected token .` Stage 1 is not Javascript. Don't use it.
**Uncaught SyntaxError: Unexpected token .** Fuck the ridiculous mangling of javascript with syntactic sugar overload. 
It's been 14 hours since this post, are you at 400k yet?
Something like http://geektyper.com ?
So what are you defaulting state properties to in e.g. React before a fetch? state = { account: {} } Is gross.
I mean, this works if you are designing a specific library or one off thing that requires absolute isolation, but the "realistic solution" I had in mind was something that developers can use in their everyday code and others can read and reason about it.
Move runCmd(cmd2) to the callback. 
&gt; Hey guys, in this video I'll be discussing why PHP is the greatest web framework ever and why you should be using it instead of React this but unir- &gt; or Ruby on Rails how dare you
I don't know how tcl works, but if it's somehow blocking the thread, that's bad practice. Check if it has a timeout option. The way the code is now, the two commands should run one after the other, without waiting. 
If you look at the [static side of this spec](https://github.com/tc39/proposal-static-class-features) they do a little sneaky thing where the have an [example](https://github.com/tc39/proposal-static-class-features/#use-case-1) using color keys mapping to hex values that make you think, "oh, yeah, that makes sense!" ;) class ColorFinder { static #red = "#ff0000"; static #blue = "#00ff00"; static #green = "#0000ff"; static colorName(name) { switch (name) { case "red": return ColorFinder.#red; case "blue": return ColorFinder.#blue; case "green": return ColorFinder.#green; default: throw new RangeError("unknown color"); } } // Somehow use colorName }
Is the callback never called, or is it called with err as argument? If its never called, then I'd say there something wrong with the tcl class you are importing. If it gets called with an error, then you could wrap the queue function in a promise and use its exception handling: https://jsfiddle.net/a0qhgcmb/3/
GTA 5 in JavaScript?
I honestly feel like backwards compatibility is going to end up killing JavaScript, I really wish private variables could use the private keyword or an underscore prefix like in Dart.
Not sure we understand each other. I'm just stating that I can't make difference of treatment between `null` or `undefined` when I'm on a team. So for instance, in your use case, when I'm alone, I can use `{ account: undefined }` to say "I haven't checked the account yet" and `{ account: null }` to say "I have checked and I'm not logged in". But when I'm working in a team, I'd make both `null` and `undefined` to mean the same thing (not checked, for instance) and I'd make up a `{account: 'anonymous' }` to express the fact the user is not logged in. Hope it's clearer :-)
That's so cool!
Formatting tip: indent your code by 4 spaces to get code blocks &lt;-- 4 spaces // this is now a code block (&lt;-- also 4 spaces) As for your question, assuming `somecall` is asynchronous, you'll need to wait until all the calls are complete before you can see the changes in the `list` object. This means allowing `f` to take another argument that would be a callback function that it could call when all the recursive calls are complete, or by having `f` return a promise that's resolved when they're complete. None of the code that directly follows the `f()` call will be able to access the modified list because it would all have run before the calls in `f` are finished.
Sure! Teams that have people writing UI components then having the Frontend team inject these into their into the react components. This is more common than you think. It's not a good process but it's the established workflow at many agencies, companies, products, and codebases.
Welcome to the critical mass that some subs reach. Quality drops off a cliff by the way.
Please, any Lang can be used for making GTA clones. JS is for running heavy games, like tetris.
But why is that any better than just using a convention, like how python has _foo or __bar?
Very impressive! I think this is super inspiring. I like how you put all the request and logs on the left side of the page. Makes me want to create my own when I get some time.
Something like this might work: async function f(i, list) { if( i &lt; list.length) { somecall('input', async (r) =&gt; { list[i] = r; await f(i+1, list); }); } } f(0, list);
Wow awesome work.
So, in state, you would initialize the value to undefined? That seems like an anti pattern. The state is initialized to `null` because the property exists, it’s just empty. When the account is retrieved it becomes an object, on logout it becomes null again.
Promises, yep. The pipe operator makes it about as nice as JS. https://reasonml.github.io/docs/en/promise.html
By using this you get an official convention that by itself is also a neat solution to JS issue of not being able to support the private (or any other) keyword.
In your text, you stated that they are _hidden in the chain the tools use_. I’m not asking how people misuse the tools, I’m asking _where in the dependency chain can you find jQuery_. My point is that those libraries/frameworks do not rely on jQuery.
Speak for yourself. I want answers to the BURNING QUESTIONS of jabbascript development * Just what is \`this\`? no-one really knows * How many ways should you feel bad for using \`class extends\`? * Why won't Eric Elliot hire me for some stupid opinion of his? * hey did u know \`const = object\` only makes the binding immutable not the contents??? wild eh * What Ten Lessons can you learn porting your startup codebase from React to Vue? * What Ten Lessons can you learn porting your startup codebase from Vue to Angular? * What Ten Lessons can you learn porting your startup codebase from Angular to Ember? * What Ten Lessons can you learn porting your startup codebase from Ember back to React? * Six great ES6 features, number #3 will change the way you bind functions forever! * How ashamed should you feel for writing your shitty CRUD app in Knockout.js? * What is the total number of atoms in the universe, and is it larger than the collective sum of half-assed Redux replacements on Github? * \`async/await\` explained via cats / burritos / dialectical materialism * YO check out my Todo app with no side effects! It doesn't even fucking render! * Eight Ways you should be Actually Thankful for JavaScript's bizarro type coercion rules * All the ways JavaScript prototype-based inheritance is the best when it clearly, clearly isn't * My Three Year Journey to become a Senior Webpack Whisperer * HEY have you heard the GOOD NEWS about PARCEL JS?
You are making me nostalgic. I used to do pet projects like this all the time. The struggle of working around browser limitations of that era were real. Awesome work, my friend. :-)
I really like your project, and think you should repost it!!! Just add one of these to your post, and you should be good! * A link to a project page with unbuilt/unminified source code -- sites like GitHub are perfect for this. * A write-up about the development of the project. This can take the form of a blog post, a README.md within the project, or a comment on the post itself. The details are up-to-you; you can write from a high-level about your architectural decisions, or you can write on a lower-level about the pros &amp; cons of specific libraries and frameworks you used. The main point is that you're discussing your code -- or your approach in creating the code -- in some way. * A working codepen/jsfiddle/etc. of the code.
I prefer to think of them as jailed properties, the `#` as jail bars. Especially since much of the spec focuses on securing access of the properties to a specific scope (the class), more so than many other languages which allow some way of accessing and even setting a private field from outside the class.
Not really. The OP argument basically boil down to "we didn't bother reading the spec, and we tried to blindly codemod `a &amp;&amp; a.b` into `a?.b` and it broke our shit because we do stupid stuff like Number(null) coercion, what's stage 1 even lol". The argument of `f() and f(undefined)` etc being ambiguous is also pretty weak. The language has things like arguments.length, rest params, and the `in` operator to disambiguate if you really need to. 
1) I don't think javascript has changed too much over the years. I was doing object oriented javascript over 10 years ago, probably closer to 15. The more recent "class" additions are syntactic sugar on top of javascript's prototypical inheritance. Generators, promises, and async/await would be bigger changes, but even then, really just a different way of managing your callbacks. If you don't believe me, write some code using them and then use babel to transpile the code to ES3. 2) I prefer functional for smaller projects, object oriented for larger projects, much the same way I do in other languages that can go either way. As /u/disclosure5 said, OO in Javascript is about being more scalable. 3) I think it's great for building SOME large scale projects. Much of the things that C# would use multiple threads for, Node/Javascript would answer with event-driven programming. Really, unless your project is going to be compute-intensive, a single-threaded event driven solution works quite well, in some cases better than multi-threaded solutions. Still, it's a tool, not a universal answer to everything. I do find that large Javascript projects "crumble" a little easier than more formal languages if you wing things too much. 4) I've done, in order: BASIC, Assembly (Z80 early on, later MC68000, and a few others after that), DBASE II (and derivatives), C, RPG II, Pascal, Lisp, Fante (there's probably less than 1000 programmers that have ever heard of that one, and less than 50 that still use it), Perl, Javascript, SQL, and PHP. That's just the ones that I used enough to remember, there are other languages that I used on occasion. Typescript (a superset of Javascript) is probably going to be my primary programming language soon, but not exclusive. And no, I don't consider myself to be comparable to a native senior C++ developer, mostly because I've been trapped supporting a very outdated system (seriously, the OS a necessary part of the platform runs on panics if it sees anything more recent than a local-bus interface). I'm working on replacing the system with something much more modern and less at risk of blowing up and never running again, but until that happens, anything resembling modern programming happens only at the fringes and isn't a primary job concern. I have a rather unique skill set, that while it doesn't help me find kidnapped people, ensures that I have near-absolute job security until I finish the replacement platform. On the other hand, there's no other job in the world that would require this particular skill set.