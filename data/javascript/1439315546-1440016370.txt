Still a Java backend, but Node is what can be considered the front of the backend. 
Did they actually drop it or did they drop it from rendering HTML but kept the service APIs Java-based? Because if they did the former, that would be idiotic. The latter makes a ton of sense.
This specific action won't. 
&gt; dependencies that are comprised of compiled binaries will most likely not work between different machines If you're using compiled binaries then your own product needs to be compiled for a target machine. Make choosing the right compiled dependency (or actually compiling the dependency) part of your build process, and accept the target machine as a parameter rather than forcing compilation for your current machine. &gt; Also committing every single dependency will result in unnecessary files such as documentation being added into your repo, making your history cluttered. A dependency update is still going to be a single commit, the number of files changed doesn't affect your history. And if documentation really is unnecessary (arguable), the library you're depending on should be distributing a built version without it. &gt; rather than commit an entire huge dependency tree I see this a lot and it's never added up. If you have a huge dependency tree, you have a huge project, whether or not you commit it. I get the impression people don't think whatever's in the `node_modules` folder impacts the size of their project, and that's not true. Another con to not checking in dependencies is that you're making npm a hard dependency for everybody who uses your library. Imagine how annoying that would be for a project written 5 years ago when a different package manager was in vogue. Check in your dependencies and your project stands by itself.
Can I ask why? Our APIs are all in node.js right now and they have scaled fantastically. Is it just "it wasn't broken, we don't fix it"? I'm assuming whatever they changed was "not good enough".
You can always put in a script that disables right-click, but there are still tons of ways to get to the code.
Ack, yes, thanks... Too many video games for me!
isomorphic has specific mathematics meaning that doesn't quite match what is going on, but the same JavaScript is being run on the server and client in Universal.
Does this mean Netflix is now 100% scripted content? ^^^I'll ^^^show ^^^myself ^^^the ^^^door
Almost everything about your comment is wrong.
Javascript isn't the same as Java? /s
JavaScript typically runs in two environments, the browser or the server via node.js. At the end of the day, if you want to execute your JS you need to run it through a JS engine, like Chrome's V8 engine. Both node.js and a browser do this. One easy way to execute a file is to use node.js and simply run `node file.js` on the terminal. If you include an `console.log` statements in the file they'll be printed to the terminal. Most good IDEs allow you to do this, and you can include breakpoints to debug and step through the code as it runs (I use WebStorm, which supports this with a "run" button like you describe and a debug window to step through the code). Here's a random example of doing that in WebStorm [video](https://www.youtube.com/watch?v=mVYJy3C63fw). Another easy way to test your JS file is to just include it in an HTML file with a `&lt;script&gt;` tag, then use a browser's debugger tools to inspect and debug it, such as Chrome's Developer Tools or Firefox's Firebug extension.
Thanks for the explanation! I hadn't considered architecture-specific binaries. 
Still failing on the getImageData(). "Uncaught SecurityError: Failed to execute 'getImageData' on 'CanvasRenderingContext2D': The canvas has been tainted by cross-origin data."
So now they have to learn Script, big deal.
I would think the "it wasn't broken, don't fix it" would apply here. The list of issues I can think of with moving it all to Javascript: You'd have to retrain all the Java devs to Javascript, you'd move a massive codebase to a language without static type checking (done wrong this is a disaster waiting to happen), and performance wise Javascript isn't going to beat Java by any significant numbers. None of the cons I list above affect the rendering/frontend side because most Java devs on the front know javascript, rendering HTML in Java is not static type checked typically, and its not crazy fast.
They just came up with that new name. Fresh off the press ;)
idk then sry, i would just right a script on the server side that pulls the data via a curl command and sends it back to ajax. i ended up solving mine by using a file upload widget.
oh i see the api's and all are still java, but the templating and etc is going to be done in js. sorry just making sure i have a clear understanding of this 
Yeah, the rules of the challenge state only using HTML / JS. If I can't implement a feature, explain why. So I think this was a test.
They dropped it from the server rendering of their frontend website. No mention of anything else. That part is the tip of the Netflix iceberg, I'm sure there's still boatloads of Java making the service happen.
Lol DRM on Linux? As if it works :/ Worst case screencap and reencode the whole thing. Silly, silly people...
one year later: &gt; why we moved from javascript to go
Tell that to a good half of the recruiter spam I get.
The evolution of JavaScript is a new language under development named Web Assembly. The goal of this language is to be a low level and independent technology and not to compete with JavaScript, which will retain its place as a high level language. Web Assembly with have static typing and a static compilation mechanism, but will otherwise parallel JavaScript as closely as possible.
When I started, I pulled apart scripts at javascript.internet.com to figure out how they worked. Eventually, I moved on to dynamicdrive. The first doesn't exist anymore ... it looks like all of those scripts are now on jsmadeeasy.com
Which is kinda the point of the article.
Javascript is very limiting for writing backend services like APIs, even with everything available from NPM. You hit one blocking call, you're done. I generally dislike Java, but it makes a lot more sense for those things than Javascript does. It's not just an "it isn't broken", it's a better tool for the job.
One more year later: &gt; why we moved from go to butterflies.
I've noticed no such issues. Most of our calls are handled by the db, not the app. We're using two servers and have incredible load tests. We had plans to 5+5 cluster against our load balancer for scale, and discovered no need. We calculated our product would scale 5x again before we bottleneck on the app itself with these two threads , at which point we would already have clustered mysql servers. You have to be smart with your code using node, but then the scale comes incredibly easy The answer to a for loop issue for us was just to add bluebird into the mix. We scale with less work than the company's scala apps
Anything you do to protect your code is just as likely to cause you more work than it's worth. It will make debugging harder. It may impact functionality if done wrong. And then at the end of the day if it's really great/amazing code someone will find a way in short order to decompile it and share it under their own name. The best you can do is document it, copyright the pieces that make sense to copyright and defend that copyright vociferously if you are able. Otherwise people are going to leach it and reuse it regardless of what effort you put behind making it secret. 
Stopped reading after this &gt;An API takes a weekend to learn... Does the author really believe that all frameworks can be learned in 2 days? 
It also has a special meaning in sociology. And in math it has multiple meanings. Word have multiple meanings. "Isomorphic" in the context of Javascript frameworks refers to a rendering approach.
I don't like it as much as any other Linux user but the goal of DRM has never been to keep people from ripping the content but make it annoying and require technical skill. The whole industry is built on control and exclusively. It's a slow process to change that mindset.
If you're on Mac then you are looking for CodeRunner --&gt; https://coderunnerapp.com/ Does exactly as you described &amp; supports multiple languages for fast protyping.
Link 404'd. Does someone have an archive?
I get the value of consistent code, but something seems off. Why was code repeated on both the server and the client? Why were sections the user wasn't going to see rendered in the first place? As written, this sounds like shitty legacy code.
I think the post is trying to be semantic but for-loops are so ingrained in any programmer's mind that it isn't really an issue.
Great post! Settled on most of these patterns myself. A problem I never figured out though was mocking es6 imports. Rewire won't do it. Babel-rewire-plugin injects all code with getters and setters, which is problematic and error prone, especially in cases of using an index file to gather deps and export a single bundle. Was playing with partial AST eval of Babel-rewire before switching from mocha, chai, sinon to Jest, which worked out fine
the fuck is this
Well, it keeps getting more and more features added to it, it's evolving, and has pretty much become the end-all of languages. I think a skynet self-aware javascript is soon at hand.
Forgive my ignorance but I didn't really think you hired or were a {language} developer. Is Java that unique that you hire people that know Java rather than people that know various programming principles and practices and if they don't have to spend the 3 weeks ramping up on Java, that's just a bonus. I love Python, but sometimes NodeJS is better suited, so I jump into that, gaining pleasure that I'm paid to learn more stuff. Or maybe some Java, ActionScript (shudders) or whatnot.
Nah, it's just getting shorter runtimes.
Might wanna take another try at posting there, chief. I'll let you call a mulligan just this once.
Fewer round trips, fewer and bigger cache entries Probably though, it's because building big SPA's without frontloading everything in one big JS file is challenging. If every page request has to get a new template and script package, you're defeating a lot of the point of using a SPA framework.
If you haven't read their [culture slide deck](http://www.slideshare.net/reed2001/culture-2009), it's worse than you think. NetFlix is really mercenary about their employees. They pay top dollar, but there's very little loyalty expected in either direction.
&gt; They are worried that you bypass the app store, but they like to pretend that it's about security. That's a bit excessively-cynical. It's not necessarily true that they're pretending it's about security. They probably actually do believe that requiring native code to go through the store improves security. You might well argue that that's not true, or that a JIT is no more inherently-insecure than an interpreter (which they do allow), but that's a slightly-different argument. 
If you write blocking code in JS you're doing it wrong. If you're running Node, it's expected that absolutely everything is done async.
I've stopped visiting websites for doing this
Only one that is true is this: "JavaScript hurts your SEO"
wat? can you speak English please?
Once you've installed Node.js, you can just run your script in the console via: node foo.js Node.js provides everything you need for writing small command line tools.
It's also extremely important to realize the use cases. For simple db operations, sure, node scales well. But if you need to start doing heavy processing before or after your db calls then java will destroy node.
Currently this is pretty new, I'm likely to do a TODO mvc example or something soon :).
Explain?
Sorry, I didn't mean for my comment to recommend doing it, I actually meant to discourage it. 
For at least [this set](http://benchmarksgame.alioth.debian.org/u64/javascript.html) of benchmarks, JavaScript is, on average, *2X* slower than Java. JavaScript is *5X* slower for 75% of tests. So, while I appreciate your humor, the opposite is *generally* true.
You're wrong.
Exciting! I've been spending some free time sketching out how to generalize React's principles to interactions with *any* external service, so I'm excited to hear that they think it's worth investigating, too :o It really is lots of fun to think about.
It's not that coffeescript isn't any good. It's that there are a [metric ton]( https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-JS) of languages that compile to JS. Why choose coffeescript when you could choose any of the others or just coding in JS natively? With the compile-to-js languages the code path becomes: some language -&gt; compile to interpreted js -&gt; interpreted js is executed in the browser The biggest problem is that you aren't coding in the language that is actually executed in the browser. Your &lt;name_the_compile_to_js_language&gt;code is converted into an implementation of javascript. So, it's difficult to figure out if the problem is with the language, the implementation, or the outputted javascript. How do you fix a language issue? How do you fix a javascript implementation issue? How do you fix a outputted js issue? What if something doesn't translate so well? How would you represent a java bytestream in js for example? What part of the coffeescript code do you check when the javascript debugger reports an error on line 87? Meh, I'll keep my javascript. 
JS is no longer the simple scripting hack it was intended to be, and hasn't been for a while. The future is the same future that happens to all languages (C, C++, Java, C#) - features get added every year, everyone has their own little style/idioms/libs they prefer using, it has become very hard to interchange code. The thing which makes JS special is its ubiquity, and how so much effort is spent on adding more stuff to it. Even with ES2015, it'll take years to get adopted, by which time there'll be more stuff on the horizon. As it is, JS libs/frameworks come and go every few years.
Is this wishful thinking or do you have a link to information that all the browser makers are actually working towards this? Because if all the major browsers don't implement the same vm then this won't be any more popular than active x was. 
I think both are important. It's necessary to be able to pick up different languages and know the basics of static vs dynamically typed, compiled vs interpreted, etc. But just because you can pick up a language in a month and write a program doesn't mean you'll write it well. And that's why you see "&lt;insert language&gt; developer". The nuances, the shortcuts, the gotchas, how to debug quickly, how to tune... Those are learned from experience - even after several years you will still have more to learn.
Look up asm.js and web assembly.
asm.js allows low-level programming using JS as a form of bytecode/AST. WebAssembly is going to initially target asm.js as well. The idea of a high or low-level language isn't extremely clear. * Is Java low-level? It has static types, but compiles to a VM and JIT. * Is C++ low-level with it's templates and classes? * Is C low-level with it's structs and loop constructs? * Is assembly low-level with it's labels and memory assigners? * Is binary low-level with it's ISA abstraction? * Is the ISA low-level with it's VLDL or Verilog designed hardware JIT? * Is the inner computation architecture low-level with it's controller? * Is the controller low-level with all it's latches and logic gates? * Is a logic gate low-level with all it's transistors? * Is a transistor low-level without it's fabrication process? * Is a fabrication process low-level when it's created with a high-level language?
Very fair. So if you know you'll be focusing on one language, you can get veterans of that language. Now I'm curious how common a job sticks to a language or two vs. how often it changes over time.
Many of the rest of Netflix's services are still in Java, but a lot of those services are also open-sourced and very solid. The Node.js apps communicate with the JVM-based libraries over HTTP through [Prana](http://techblog.netflix.com/2014/11/prana-sidecar-for-your-netflix-paas.html), which is also open-sourced. The [Netflix GitHub organization](https://github.com/Netflix) has the rest of them, as well as a lot of the tools built on AWS that are being used in production today, so definitely check them out! 
I get what you're saying, but there is a specific reason for moving to Javascript. You're not going to see Go running all the places javascript is currently running in a year.
depends on what your goals are. i've used most of them at one point or another....in the end they are all pretty similar once you get the gist of it. I like aurelia now....and also leaning towards doing an app in meteor, but I'd like to hold on rethinkdb support. if you need a job...like tomorrow, then you should learn angular and react. those are the jobs these days....but in a year or two it will be something totally different....aurelia is leading that charge but who knows. 2 years is a long time in javascript land.
Great post for starters!
Your best bet is to learn plain old JavaScript. Once you know the basics of the language, all the various libraries and frameworks and such are basically just learning specific APIs. Stick to tutorials on the vanilla language and you'll be off to a great start.
Relay makes total sense from a Facebook point of view. I really like most of the concepts and will be happy to try them out. However, there is one thing which I'm worried about. It looks like Relay is tightly coupled with Graphql. What if I have a solid backend written already that has a REST API.
Take a look at https://github.com/facebook/react
It's a more accurate name according to some https://medium.com/@mjackson/universal-javascript-4761051b7ae9
Shameless plug :-) https://underthehood.myob.com/changing-of-the-guard-in-web-technologies/
YAAAYYYY!!! Been waiting for this for about 6 months :)
YAAAYYYY!!! Been waiting for this for about 6 months :)
Wow, this is a really great post. I'm not a math expert, so thanks to the author doing every smallest calculation step-by-step really helps me understand it. I would like to know though why the activation function is necessary? I can understand from the results that it is - leaving aside the choice of the different functions - but I don't understand why.
&gt; Will it be in the browser or on the desktop? Or something else? It's already in both.
Security and privacy is a huge concern. *First - At all times, NO content in web page is ever recorded or sent to the server. *Error Reporting - An extension user has the control of turning automatic reporting of errors ON/OFF at any time. When on, it only sends anonymous usage data including (1. app settings, 2. URL and search query *BUT only when* a user searches in the extension (not search engine or anywhere else, and 3. if there was an error). When this setting is turned OFF, NO app settings, NO URL, and NO search queries are reported. *Search Operation - When a user searches a single word, the extension in your local browser already has all the information needed to find related paragraphs. However, when a user searches more than one words, my server is needed to generate semantic (word-meaning) distances and find the common topics between the words. So when multiple words are searched, the words are sent to the server and the server returns related topics and words. NO URL is ever sent because it is not needed for the essential search operation. *Secure Connection - All connections when sending search words, OR when sending anonymous error reports are sent over SSL connections to prevent sniffing. I hope this helps clarify thing. Please let me know if you have any more questions! Thanks for trying it out. Edit: Yes, the shortcut was intentional to distinguish difference between browser native search and the related search. However, you can change the shortcut key to whatever you want, such as overwriting Ctrl + F.
Very interesting. Have you seen my minimalistic and very performant virtual DOM implementation [Snabbdom](https://github.com/paldepind/snabbdom)? 
Serverside rendering should die. 
Somewhat related, I had to solve the kind of problem (not on Netflix's scale) at one point in the past. It can be ugly in any web engine. New versions of express have promoted router to a first-class citizen, so dynamic route-rebuilds can be done more cleanly now, making it less likely to create a middleware leak. That said, it's a lesson I intend to take to my team because it may be relevant to use sometime. Repeatedly adding the same middleware is bad because node doesn't know to magically collapse the repeated middleware.
Because "agnostic" was obviously too contentious a word that wasn't already in use regarding JavaScript /s
You should take a look at [this one by AirBnB too.](https://github.com/airbnb/javascript/)
No. "Isomorphic" JavaScript is simply JavaScript that doesn't care if it runs on the server or the client. What it is used for is irrelevant.
Trouble is, isomorphisms in the mathematical sense are already a thing in computer science: https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence
Yeah, I already worked with databases few times (to make a leader board system on a small game) with Firebase. And I also understand MVC frameworks. Correct me if I'm wrong but, MVC frameworks are like AngularJS?
Dealing with Internet Explorer.
Thanks for your comment, I didn't know about SDLC.
XPost Subreddit Link: /r/node Original post: https://www.reddit.com/r/node/comments/3gplve/mdast_markdown_processor_powered_by_plugins/
It'd be nice if they'd work on making click events for playing videos a bit more responsive, I often have to click multiple times to get videos to start in Chrome when hovering over items in the showreel.
tip #1: maybe node is a good place to focus. pick a skill that is gonna be around in 2-5 years (i would have said php or jquery a few years ago) tip #2: become an expert at one thing. everybody has jobs and needs some kind of expert. things that got me hired was first time: perl expert, second time: php expert, third time: jquery expert. so even if your a html or ruby expert, there will always be a job for you (and imo its faster). tl:dr; just pick something that will be around in 2-5 years (go js node python are all good suggestions) :)
I've really been struggling lately to make my front-end appealing and easy to use for my users. My back-end is very appealing and beautiful but nobody sees that except me really so it don't matter diddly squat. UX design basically I guess.
Regret.
The problem I have with the TodoMVC - is that 'Todo' is inherently a very simple problem to solve. When looking into frameworks/tools/libraries/approaches/architectures to solve complex problems - when applied to simple problems, makes it seem a bit pointless and 'why bother?' Then on the flip side - some things that are all 'Look mom, TodoMVC in 10 lines of code!' - don't scale up to more complex problems, but can win the praises of others for how simple it is. Not saying Relay is good or bad (don't know enough about it yet), I'm just a bit skeptical of TodoMVC being the baseline of evaluation for things. 
Added some more examples here: https://github.com/MattMcFarland/SUq/tree/master/recipes
While your post isn't a popular one, I agree with you. Java's asynchronous capabilities just don't hold up to JavaScript's.
Thanks man, same for you!
Maybe it's a more flushed out example? Your rant is like saying "I can build an online code editor in one line: `&lt;textarea&gt;&lt;/textarea&gt;`! Why is Atom 200,000 lines of code?!?"
In my address box it says github.com... how weird.
&gt; Relay is a JavaScript framework for building data-driven React applications. How many more frameworks can we pile on top of each other?
lol ok
no -- the web services from client to server are node.js -- the internal web services from server to server inside netflix are java being called by node.js...
Don't.
You realise that coffee script is a tool to generate JavaScript right? I'm sure people wouldn't complain if I was using sass stylus or less.
The Student constructor is lacking the `name` and `age` parameters. And I'm not sure its really a "required" keyword. Typo? I know "deceleration" (x2) is. That should be "declaration".
It was a question, not a statement. And I don't see any mention of overlap which in turn seems to make your statement even more nonsensical.
+1 Redux is by far the best flux implementation I've seen.
I never asked a question. But it seems apparent you understood the original question to be snarky rhetoric, and yet you replied the way you did anyway.
https://github.com/nightscout/chrome-uploader app/datasource/dexcom.js is a fairly discrete piece. I went Promise-mad while writing it and it now suffers the problems that it A) Works, which discourages continuing to alter it B) Does too much (half that code really ought live elsewhere)
&gt; Also that benchmark is very vague. One-click to the source code of each program. &gt; your link is biased In what way is it biased?
The project variables. There are a million things to consider, to learn, to research, to know. The more the developer learns, the more he knows he doesn't know.
Postbacks and network latency.
Providing data, getting results, querying databases. Then you probably need to build a RESTful API, this is boring.
The person you are replying to isn't the OP for this comment thread
Volvo pls. 
&gt; Future Node.js releases will be from this repo. Meaning releases will be at https://github.com/nodejs/node rather than https://github.com/joyent/node
Yeah, that term comes up *all the time* in the context of JavaScript development. That would be truly confusing. /s
Can you show an example? Maybe a [pen](http://codepen.io) with what you have so far? I'm not sure if you're asking a JS question or how to lay out the results in HTML/CSS.
Surely a view must know about the model. You pass a view a model to render. Or am I mis reading
Honestly start looking at companies around were you are and see what kinds of software they develop. Learn to build the kind of stuff they sell.
Its a Typo for sure. I would go ahead and correct it. Thanks a lot for pointing that out. I have fixed the above and updated the entry. Thanks.
First impressions: looks overcomplicated
Yeah that's what I meant all the back end servers are java nd server to client is node.js
I've always used `minimist` because it had the simplest API (compared to nopt and commander) while still packing a decent number of features in just 200 LOC. Poor docs, a growing number of unresolved issues and it does not adhere to the [UNIX utility conventions](http://pubs.opengroup.org/onlinepubs/7908799/xbd/utilconv.html) very well (see [here](https://github.com/substack/minimist/issues/50)), but it's lean and has no dependencies. Parsec's API is more succint, it has a well documented README, and still no dependencies! I also fixed the issues I was having with minimist and other problems that were still unresolved in its issue tracker at the time of this writing. It's also 53 lines of code :P
Your back end could be immaculate, but it doesn't matter because folks only want to look at, and play with, your front end.
Seriously. I don't even pay attention unless it has already gained traction. I don't have the luxury to be an early adopter. I'm just now taking a look at react and will use it for my next personal project. Screw the flavor of the week
Well put. I agree with your comments and agree that node is definitely very capable for many things. If you have a small team and want to do everything in JS, that makes a lot of sense. Plus in most applications, that extra performance usually isn't needed. And if it is, its way easier to just throw another server at it vs rewrite the whole app in a different language. That said, in my experience, working on a large javascript code base with ~15 devs has been a nightmare, while its been pretty easy to do the same with a large java project. Keeps things fun
This is from a book about IoT and Robotics programming with JavaScript, but I can't link to the book because it would be self-promotion (even though none of the authors are paid for book sales).
( ͡° ͜ʖ ͡°)
Hey, thanks for the advice! Do you know a place where I can find people to make a community project?
Direct link to the sheets: http://theghostin.me/you-must-be-so-good-at-math/#/ 
It's free for 30 days right? The license is worth every single penny and a great investment for any developer. I use PHPStorm, Webstorm, RubyMine.
You're missing some subtle but important differences with this one. There is more that separates let and var. Globally they're not supposed to be the same. let will create what effectively is a "local" variable in the global scope but it does not (...guarantee, though I believe current implementations might do so) that the variable is assigned to the global object ([ref](https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/)). // (in browser with global window object) var x = 1; let y = 2; console.log(window.x); // -&gt; 1 - var declarations defined in global object console.log(window.y); // -&gt; undefined - let declarations not in global object A big one is the temporal dead zone. This is the area within a block before a let declaration where the let variable is inaccessible. Its not like var, where the variable is hoisted, existing but without its initial value. This is an area where if the let variable is accessed, you get a Reference error { console.log(x); // -&gt; undefined - OK, hoisted, but no value console.log(y); // -&gt; ReferenceError - Not OK, dead zone var x = 1; let y = 2; } You also can't redeclare let variables like you are allowed to with var... actually the ref link I referenced earlier goes through all this stuff so I don't have to repeat it here. Also, as far as your examples go, I think it would be helpful to have a non-loop let example prior to the loop since loops are a special case where the let declaration isn't even within the code block ({}) in which its scoped.
&gt; It was a question, not a statement. You really think he genuinely wants to know how many more frameworks we can use together? It was a statement that we're using too many frameworks. &gt; And I don't see any mention of overlap which in turn seems to make your statement even more nonsensical. He was implying that using A shouldn't stop us from using B if we're using them for wholly different things.
Go? Doubtful. The whole reason to switch to JavaScript is you'll have the same code on both the front and back end, not because the language itself is so nice. Some nicer language that compiles to JavaScript/WebAssembly? That's more or less a given. They even wrote that they're looking into it now.
Angular is a great place to start, but it can be a bit misleading when you start looking into MVC methodologies. Angular introduces controllers in javascript. Are they really controllers? Are they part of the view? Who handles data parsing and logic? Angular introduces directives containing their own views, which can contain their own views... but where in the simple MVC hierarchy do these fit? Pretty gray areas... I recommend creating a .net project from a template (shipped w/ visual studio) to see the 'standard' structure of MVC since it's stuck in the mindset of a lot of programmers and employable positions, but if you enjoy the structure of angular, async/api calls, and node send/emit, you probably wont go back. Personally I dont have much experience with json 'databases,' but I read/hear lots of bad things about them performance and security related. Would recommend getting SSMS / MySQL running and experimenting with some CRUD, because the SQL overlords rule many domains. (Also be sure to say CRUD as much as possibly, because it sounds funny.)
Just buy it.
My sweet summer child. That's what you see after it's processed, not the original source. 
&gt; You really think he genuinely wants to know how many more frameworks we can use together? Now you're just leaping off the literal train. Who really thinks that? Hands? &gt; It was a statement that we're using too many frameworks. And you agree that such a "statement" makes no sense? _Sounds_ like you understand what it means. &gt; He was implying that using A shouldn't stop us from using B if we're using them for wholly different things. And at no point did anyone say "Why do we have A when B already does that?" So why point that out and then accuse OP of making no sense? I mean I guess you could get picky and say "pile" implies redundancy, but I think of it more of a "stack" (pile of dishes, stack of dishes - same thing, right?) which makes more sense in this context. 
30 days for each build. In practice, it's free until the RC comes out, after which it doesn't reset the trial clock. Totally worth buying though, once you get used to it, everything else is stone knives and bear skins.
Cool. I'll look into it at some point.
I think it's a reasonable point. It's not easy to optimize matrix multiplication in JavaScript. I've found that with the implementation I used for Mind, things get pretty expensive as you add more layers and units per layer. It might be possible to to get huge speedups by performing those operations directly on the GPU (WebGL?), but I haven't looked too deeply into it yet.
Slides: http://thedrearlight.com/iterable
WRT SQL databases. I would consider mysql or postgres. There are arguments for either, but for basic tasks they are essentially equivalent. Unix was invented around the commandline. This is precisely why I recommend it. C# is a great language. It's been sort of a corporate silo because of microsoft's owner ship of the tools. Now that microsoft is opensourcing many of the tools around it I think it may have a good life ahead. At this point in time the eco system around the JVM languages ( java, scala, etc ) is far stronger, but we may see that change going forward.
Yep. Also, to add to it, _this_ EAP may not have bugs, but it doesn't mean that all won't. Just get a license.
Webstorm (and all JetBrains products) are great. If you're a VIM user, get IdeaVIM and you will be right at home. Don't be afraid just because it's an IDE.
Your code looks really well organised and thought out for someone with relatively little experience so well done! The only thing you need to do to progress is keep reading and practicing, it's generally acknowledged that it takes around 10,000 hours of coding time to become an expert but you could get a junior level job with much less, and your code is better than some I've seen written by "experienced developers". I took a quick look at the code for your bring-me-colors app and would say you should look at the following: - Separation of concerns - e.g. your colourlovers class is handling both business logic and presentational logic (html) - you could look at frameworks like react or angular to help with this - Data storage - you've used palettes.js as your "database" which is fairly verbose and nasty, you should find some other way to scrape and store this data - Tests - you have none! - Dependencies - you've committed all your dependencies (jQuery etc) along with your code, it would be better to gitignore these and pull them in with bower which you're already using - Descriptive commit messages, you've got just one commit commented "added everything" Good luck!
Okay, thanks you for the response!
That's gotta be a violation of their terms
Yea that's one I totally agree with
My beef with WebStorm is that they spent 90% of their resources on new features and only the tiny rest on fixing bugs. I submitted about ten bug reports the last month alone, all acknowledged and assigned, and commented on and watch a few others. Some have been open for a year, but even with lots of people (more than 30 - IMHO that's a lot relative to how few users would be active on the bug/issue pages and even search existing reports) commenting in support and that issue being *easily* fixable (on the "how difficult is it to fix the average bug" scale) there is ZERO movement. And all the ones I submitted are very easy ones too I suspect. For the price it's okay - given their competition's state. But this hunt for features, features, features should occasionally give pause to a session of fixing the many open bugs in the queue.
Yes. My gulpfile.js looks like var gulp = require('gulp'); var sourcemaps = require('gulp-sourcemaps'); var babel = require('gulp-babel'); var watch = require("gulp-watch"); var plumber = require("gulp-plumber"); gulp.task('default', function () { return gulp.src('src/**/*.js') .pipe(plumber()) .pipe(watch("src/**/*.js")) .pipe(sourcemaps.init()) .pipe(babel({ blacklist: ["useStrict"] })) .pipe(sourcemaps.write('.')) .pipe(gulp.dest('extapp')); });
While I agree, I think this argument highlights the shit that is the app store rules.
ya https://twitter.com/amasad/status/631251607422787584
according to their faq they don't believe this to be a violation: &gt; Does Apple permit this? &gt;Yes! Section 3.3.2 of the iOS Developer Program explicitly permits this. here's the [pdf](https://developer.apple.com/programs/ios/information/iOS_Program_Information_4_3_15.pdf) they link to.
Nice! I'll definately make use of this one :)
Thanks man, I know that to learn and understand more, you have to train by making your own project! :)
more info found here: https://www.talentbuddy.co/blog/building-with-node-js-at-netflix/
My team dumped Webstorm for VSCode. We develop on ReactJs. 
Check the source! The property setters are being overridden and simply throwing an exception when in production.
Every time i come into this sub looking for interesting discussion about the topic at hand and i always leave disappointed by a bunch of "DAE think 2 many frameworks?!" circlejerk comments and absolutely useless drivel that isn't even about Javascript or development in general. Seriously bums me out. 
[Off-topic] &gt; The official name is io.js, which should never be capitalized https://en.wikipedia.org/wiki/Proper_noun &gt; especially not at the start of a sentence https://en.wikipedia.org/wiki/Capitalization#By_context English doesn't work that way. A name can be stylized in some way, but your "PeNgU1N oF d00m" unique-snowflake bullshit does not apply to regular text.
Hey, no problem. Of course this was just a hobby project but as you said to work on a team you need to follow good practices. To answer your questions: - Yes it is confusing especially as things move fast and there are new tools coming out all the time, one of the most important/difficult things is keeping up with changes in the industry. There are so many different tools and techniques you just have to find your speciality and make it your business to know everything about it. Get involved in the community too, a good place to start is http://www.meetup.com/ where you can find events around your subject in your local area - You'll need to know about testing if you want to be a serious developer, my speciality is PHP so I don't know a lot about JS testing tools but Google is your friend - Yes you can use gitignore to ignore files. You also need to know about version control and specifically git which is the industry standard, again Google it! - Bonus: use jslint and other static analysis tools. You should be able to get a plugin for your editor to lint your code in real time, you'll hate it at first because of all the errors it shows up, until you realise it's teaching you to write better code - Bonus 2: as others have said learn more than just javascript, it's a bit of a quirky language and might give you tunnel vision if it's all you know. Take a look at Python or PHP for example, or TypeScript, a strongly typed superset of javascript which eliminates some of it's weirdness
I hot reload with meteor all the time, Apple does not mind.
You would intentionally use plumber?
&gt;3.3.3 Without Apple’s prior written approval or as permitted under Section 3.3.25 (InApp Purchase API), an Application may not provide, unlock or enable additional features or functionality through distribution mechanisms other than the App Store or VPP/B2B Program Site. Once someone makes a big enough change to their app through this method, I would anticipate a terms change to clarify this.
Tons of other frameworks have been doing this for a while now including meteor.js and phonegap.
I'm someone who never used `jQuery` but know the basics, I've always used vanilla-js which is awesome, but I've created this library [NodeList.js](https://github.com/eorroe/NodeList.js) which makes my vanilla-js wayyyyyyyyy easier. The awesome part is I'll never have to update it'll do it on its own, because whenever the browser adds a new `API` to the `DOM` my library will as well.
A valid point.
If you want to use modules you'll also need browserify, or just use babelify which combines the tools.
Plumber is what keeps gulp from dying after a syntax error isn't it? Is there a better way? Having to restart every time I errantly saved was really annoying.
Yep! That's the biggest difference between this and things like seamless-immutable and freezer-js. I want to know when I try to mutate the object and where I was trying. Makes debugging easier!
People need a service or API for this?! What is the world coming to?
So it can shitify all over your system? Jeez. 
Webpack works a little bit better with babel than browserify for me, but ymmv. (Hot module reload is a great boon to Dev efficiency)
I've played with something like that in the past. For example, you can do interesting things with loop unrolling where each unrolled section is one array in the linked list and you fetch the new section at the beginning of each iteration. I'm not sure how common it actually is in practice (though garbage collectors often do this if you realize that a contiguous memory section is actually an array of bytes). In general, I think you're more likely to see a binary tree where the leaves are arrays. For example, this is how they tend to implement strings in JS ([ropes](https://en.wikipedia.org/wiki/Rope_%28data_structure%29)). The biggest part of these kinds of optimization are actually heuristics (perhaps closer to art than science).
Can you elaborate? Genuinely curious. Do you have a prefered tool? 
Hmm, with gulp and babelify I'm getting auto reload. Never seen webpack before though, will look at it.
By autoreload I mean you don't need to refresh your browser to see changes. If webpack is doing your CSS for you, too, that'll update as well. It's rad to make a change in your file, save it, and almost instantly see the change in your browser without having to touch a thing. Webpack also makes it easier to split your spa up into multiple packages, so the entire app does not need to load on the initial page load.
Mostly just using chrome dev tools for rendering and cpu performance and comparing to other frameworks. I've made sure there are no deoptimized functions and have generally squashed any lengthy operations. If you use it be sure to let me know if you notice any slow usecases :).
Oh ya, I'm getting that because I'm using yeoman and gulp and it's set up to watch for file updates and auto refresh, so I get the same functionality. I guess webpack also does that for you.
I love how it went from Bash -&gt; Grunt -&gt; Gulp -&gt; Bash... haha but I use gulp for watching the files change and reprocessing them (with sass and other things too)
We've successfully used it for a handful of small games and it works great (even the es7 features like sync/await seem to work very well). We're using WebPack too which works like a charm. My only caveat would be setting up unit testing is quite a pain, you can wire karma to run the babel preprocessor but we've had issues with the base path and module loading. 
aha! thanks for that. 
It's just running the bash (or whatever shell) command for that particular program.
Oh rly? http://imgur.com/WZcRar0
It does so through using WebSockets and JavaScript that it includes in your concatenated JS files, if anyone is curious. It watches your files, detects if the modified time changes, and then sends a message which the included JavaScript receives. I'm not sure how it technically manages replacing and re-evaluating the changes, though.
You may enjoy TypeScript more.
Full stack dev here, with a focus on Front-end. Honestly you are well on your way to turning this into a career. I would continue what you are doing now and keep hacking on side projects in your spare time. What separates job candidates is their personal portfolio and having a number of deployed apps is really going to set you apart from others. Get familiar with setting up your own servers and deploying your code. Aws (amazon Web services) is somewhat of an industry standard for that and their micro instances are free for the first year I believe. PS - learn React it's the new hotness
Wonderful, a contrib section. Also known as "the code that we aren't quite sure should be here and definitely aren't committed to maintaining."
Eh, this is cutting it close to an appeal to authority. Yes, Facebook is a hugely popular website and it could make a great case-study for Babel, but that doesn't necessarily make it the correct decision. Anyway, aside from that, I experience *a lot* of issues with Facebook, so their use of Babel tends to steer me away from it rather than toward it. I'm also hesitant to use React for the same reason.
// TO DO: Invent a newer, better framework 
what? you have an issue with facebook so it must be babel. some great logic going on in here. 
What about Aurelia....you can't discuss frameworks without discussing this one.
Yes.
Plumber + gulp notify keeps my watch running while still bailing the compile on error (and giving me a nice loud error).
It's also pretty easy to just roll your own Gulp plugins or use any Node.js module if you need to :) 
People are already hot loading apps with Meteor and Phonegap.
We're using it in production as well, totally agree! Cool to see that Facebook is using it :)
Babel contributor here, we don't receive many reports about crashing but if you open an issue we're happy to help!
If you have any trouble setting up Babel with any other tool, feel free to drop by our support chat! http://slack.babeljs.io/
It's considered a staging ground. Plus, you can just check out the source [here](https://github.com/documentcloud/underscore-contrib) if you're skeptical that the code may not be written well. Many of the functions seem to solve very specific, unusual issues, but I gained some valuable knowledge just reading through the source and considering the reasoning behind each function. I might contest that there is no such thing as too many utility functions.
Dang, that file is huge. No worries, I'm on it. Would a single PR work for you?
Someone deleted their comment from this morning. Don't be shy, stranger, we all write bad code :)
No he isn't. That's why he's being downvoted. Since we're going with wiki (in-which /u/x-skeww's links mention brand-name capitalization), let's also examine this page: https://en.wikipedia.org/wiki/Capitalization_in_English &gt; 1. at the beginning of a sentence. ... with the exception of proper nouns. &gt; 2. with some nouns and adjectives, usually if a noun indicates a proper noun. &gt; * brand names: "Toyota", "Nike", "Coca-Cola", unless the brand itself is purposely not capitalized: "iPhone", eBay". So, in fact, that *is* how the English language works, which is far from a simple language.
fuck you very much asshole.
You got it but, in this case, it's about this whole installer to install an installer to install a framework or library or tool.
What is advantage of this over JavaScript? I cannot see one. user = (u) =&gt; { return { id: u.userId, userName: u.userName, firstName: u.firstName, homePhone: u.phones.find(p =&gt; p.type === 'home'), mobilePhone: u.phones.find(p =&gt; p.type === 'home'), address: address(u.address) }; } address = (a) =&gt; { return { short: a.street1 + '\n' + a.city + ', ' + a.state + ' ' + a.zipCode, street: a.street1, city: a.city, state: a.state, zip: a.zipCode }; }
My point is he's saying "ya" which sounds like the German Ja when he really wants to say "yeah" which is the English bastardization of the word "yes" but only cretins who can't spell type it as "ya". And it doesn't make me a liar.
I think the list could be a bit longer than that.
You'll notice there is no reference indicating a source for that assertion, which is due to the fact that one does not exist. What you (and that line in the Wikipedia article) are describing is a colloquialism, and is not part of any accepted standard within the English language. Using a stylization is nothing more than a courtesy to the brand.
Aurelia is the only forward thinking next generation framework that is near production ready.
Haromony isn't released yet, nor is the spec final. Using it in production is probably not the best idea. Also, kale will eventually run in the browser as well.. which definitely does not support that type of syntax. When you fall back to "old" javascript, your terse example becomes far more bloated. Enter kale. Also, kale doesn't work on just objects.. it also works on Arrays, which adds more code to your example. Beyond that, kale also provides a bunch of high level wrappers around standard operations: mapping, plucking, etc. Which, again, saves you from writing more code. The templates also provide a clear separation from your data and your view. They allow a frontend team and a backend team to work independently, and let these templates do the heavy lifting. They could easily be updated and redeployed completely separate from your application (much like a "visual view" could). They also support easy importing (API changing to be easier) of other templates (much like address above). I also plan to add in a transparent way of handling versioning. You could achieve all that in JavaScript, I suppose.. but again, if you're not using harmony it's going to be much longer than what you provided above. Lastly - it was a fun little project / learning experience, which is so much more valuable (to me) than writing a few ES6 functions. tl;dr: Cut down on the amount of you have to write. Plus, it was a great learning experience. 
Ahh. Webpack/browserify are more for using actual npm modules (external dependencies in ./node_modules). Not sure how it'll do with yeoman - I leaprogged that.
&gt;In what way is it biased? Every test includes print statements and setup code which are calculated in the total run time. Not necessarily a big performance hit but in benchmarks that type of stuff should not exist. Some of the benchmarks use code that was proven in other tests to perform poorly in JS and good in Java. (binary operations, shifts, etc). Even in JS itself, there are ways to write your code to be much more performant. Scanning through a couple tests showed areas where the JS could be improved significantly. It's comparing heavyish algorithms where the topic being discussed is using the two languages as serverside languages. Tests related to handling requests under different loads would be more relevant. Not saying that JS is a fast language at all. Without strict types and having a dynamic compiler, it isn't going to be fast. I'm just saying that showing one person's benchmarks isn't going to convince me that Java is a better server language than Node. Similarly Go often performs much better in benchmarks than Node. However, under normal server conditions (simple rest calls, etc.) their performance is about equal.
they keep upgrading their UI which pisses me off.
Last time I was complaining about Webpack documentation, the person I was complaining to pointed out that I could improve it and put in a pull request. So I stopped complaining. But I should probably try to help out.
Why do you want to use ES6 so much? Can't you wait for the major browsers to implement it first?
Every little bit counts! If you see a typo or error in the docs, or feel like another example would help, it only takes a few minutes to edit it and send a pull request :) You can even edit it directly through Github's site. It's a great way to get into open-source if you've never been part of an open-source project before.
Well, it's free. 
besides that? $49/year is nothing for me. so cost isn't really an issue.
Thanks! Go for it. I tried to add as many meaningful tests as possible, but if you find any bugs please report them in the issue tracker. :)
How bad are the bugs though, are they breaking? While there are some annoyances, I've found that the features that are present are pretty solid. With that said, I'd really like for them to implement some kind of [project management](https://youtrack.jetbrains.com/issue/IDEA-139038) (if you follow the [linked issue](https://youtrack.jetbrains.com/issue/WI-1432), the request dates back to 2010). I'm not sure what to make of the `Fix versions 14.1.X`, since the EAP is v11, and the build number is 142.x. Anyone on the EAP notice anything new with regards to project management? About the only other feature I'd like to see is better theming support -- and before someone says, _"it's just colors!"_, the colors have a huge effect on usability. As in, under the dark theme, it's damn near impossible for me to tell which tab is active... supposedly there's a plugin or two that can help with this, but they've been removed from the official repo, and I'm not real comfortable installing random .jar files downloaded off internet forums.
My favorite is when "yea" is substituted for "yeah", all I can think of is CSPAN.
To name the most useful in my opinion, these code/time savers. Arrow functions // ES5 function Person() { var self = this; self.age = 0; setInterval(function growUp() { self.age++; }, 1000); } // ES6 function Person(){ this.age = 0; setInterval(() =&gt; { this.age++; }, 1000); } Default params // ES5 function multiply(a, b = 1) { if (b === undefined) b =1; return a*b; } // ES6 function multiply(a, b = 1) { return a*b; } String interpolation // ES5 var name = "Bob", time = "today"; 'Hello' + name + ', how are you ' + time + '?' // ES6 var name = "Bob", time = "today"; `Hello ${name}, how are you ${time}?` Then destructuring, classes, get/set properties...
Yeah we're using it with webpack right now and it's cool except the first build, before everything is cached and it does incremental builds, is quite slow. Like 35-45 seconds for ~200 React components. 
Recent projects on the main dialog? I just create empty projects in the same root folder and add modules to them. That way, all my projects are in the same area on disk. 14.X is IDEA's version, not Webstorm. Consider IDEA as the core project and Webstorm as a preloaded plugin with a Webstorm icon and title bar. https://github.com/dmalch/ColorIde Used to work, haven't used it in a while. It's still available in the plugin repo. Takes the editor colors and uses them in all other panes. http://ideacolorthemes.org/themes/ For themes
React injects a lot of that stuff, if you get react developer tools, you can see the code they wrote.
Depends on my mood.
The value npm scripts provide is that you already have npm installed. And it's a good starting point even when you're most likely going to use gulp later, because when you make the switch, the "API" stays the same: "scripts": { "compile": "gulp compile" } This also doesn't require you to have gulp installed globally. Win-win :)
If this looks good to you, I'll submit a PR
Wait so views can't be pure functions, right?
as it turns out, most of the times i'm defining functions I explicitly don't want to set the 'this' context to the place it is defined, so fat arrow functions (=&gt;) are kinda useless to me. i wish they also supported the skinny arrows ( -&gt; ), so I could use the short definition in places such as node.js transform streams, or event handlers. Doesn't jquery also use $(this) in it's .each? Template strings are almost worth it though.
Of course I did, it's great. But it's no only for es6,and didn't describe in depth.
1000x yes. Avoid the es7 stuff for now though. We do at least. 
Where does it say per year? Thought for $49 you get permanent license + 1 year free upgrades. Edit: Why downvotes? You pay $49 you get Webstorm X version till you die. You need X+1, you need to renew. Just saying $49 may come for like 3 years..
all that does is add a zero to the end. so its treating the 0 as a literal as well. 
700 modules here, 20 seconds. With big modules. What cpu and config are you using?
Sebastian Mckenzie (creator of Babel) actually started working at Facebook recently :)
It might not work depending on what you're using, it's mostly used with React.
Don't students get free access? I paid for it in school, and I ended up going with a ton of JetBrains products. I love them. WebStorm is downright essential to me on projects that are decent in size. I do enjoy VS Code, but it's my quick script go-to more than a day to day use. For JS development, WebStorm is the best I've used. The only issue I run into is it being a pain when I want to make a quick edit, and that's why I have a backup.
It is completely baffling as to how you believe any of these represent evidence supporting your claim. You have provided the following: 1. A thesis not pertaining to language. Of course, even if the thesis did pertain to language, it is far from being an authoritative source. After all, a PhD thesis is not even written by an individual possessing a doctorate, but instead someone purporting to be worthy of one. 2. A blog without sources. You also freely admit that this partially refutes your own claim. 3. A blog referencing an individual organization's styling guide which, again, you freely admit contains no information to back up your claim. Also, it should be clear to you that this source is irrelevant based on the fact that the organization itself refers to it as a styling guide. Style does not trump conventions of language, which is the whole point of this argument we're having. 4. A completely random person on Stack Exchange, which is about the least authoritative source I can imagine. If you would really like to use that site as a source, [here is a related](http://english.stackexchange.com/questions/2903/how-should-trademarks-be-written) Stack Exchange thread in which the accepted answer is childishly inflammatory, at best, not to mention based entirely on fallacy, which is subsequently pointed out to him. The second answer on that page, however, is an articulate voice of reason. You'll notice that the takeaway from this person's comment is that you can do anything with any words, but personal usage is irrelevant to the English language. All of these non-sources admit that there are no written rules specifically regarding this topic, which means you fall back to recognized and accepted rules, which do not allow a sentence to begin with a lower case letter in any situation. Therefore, ignoring these rules is purely a colloquial convention and a personal preference. It does not magically change conventions of the English language. So, once again, matching your capitalization to a company's branding is purely a courtesy.
require.js !== common js (fyi) - also babel supports like 4-5 module systems (maybe all of them) so no - you don't have to use browserify which is literally the antithesis of require.js
it just comes with more options out of the box that are really good. I'm not opposed to the idea but IMO it's antithetical to the 'nodejs way' that modularizes everything (call it modular if you want but browserify really is, literally). if web pack moved from a config file to a gulp / browserify style streaming - programatic API, i'd use it in a heartbeat. I know it's 'the best out of the box' - but it's not standard and imposes some standards that'll probably never take hold. 
within a month of using gulp - i switched to a random library written by somebody in Eastern Europe that doesn't speak English who made it in 4 hours on a plane ride. I included 'vinyl-fs' (which maps 1-1 to gulp.src and gulp.dest) - instantly all my files began running twice as fast, errors were handled easier, i had direct access to the command line programmatically to mix / match gulp / bash - in node - to watch files all I needed to do was write `-w` in the terminal when running the scripts, I could pass in random parameters at will '--dev=true' and then I further customized the library to include vinyls by default, allowing you to separate the 'gulp' files into modules by passing vinyl-fs into the argument object of function, and then I added better stream handling and gulp still hasn't released their new task manager.. I like told them about this shit almost a year ago and helped write some of gulps docs.. gulp plumber it's hacked up reflection of something wrong - just don't return streams and wrap them to notify when it's done and callback.
this is great. thank you as well.
Is there no audio?
Not sure that's the best way to market your refactoring abilities? ;)
Why not? 
&gt; some special / weird syntax what are you refering to? Only thing I am aware of is the ! that you use to invoke systemjs plugins.
&gt; i wish they also supported the skinny arrows ( -&gt; ), so I could use the short definition in places such as node.js transform streams, or event handlers. Exactly, major omission in my opinion as well.
Yay for /u/sebmck ! Related thread: https://www.reddit.com/r/javascript/comments/3d7jli/author_of_babel_announces_hes_joining_facebook/
Yes, this is actually the way Redux does it. My impression is that this works fine for simple projects, but as soon as the project grows in complexity it becomes easily unmanageable. The reason why, is definitely the logic duplication. It's quite often that you have to do some logic even for producing a side-effect and this is inevitably part of the domain. I like the idea of keeping side effects as part of your domain logic (Reducers). Besides, it's really easy to test, just assert the effects reduction. It was actually the reason why I decided to figure out a way how to keep that in one place.
Ha, nice burn to what people make Angular 2 out to become.
Sourcemaps aren't the issue. I'm using a language feature toString on the functions that reference the variable by name. Since that toString also gets the rewritten variable, my code breaks when I use it outside of where the rewrites happened. Sure devs will call it a bad idea and I shouldn't do that, but that's just lazy. It's incredibly useful for sharing code to WebWorkers, and will work just fine with real ES6.
is it even updated to use babel ? looks like its using 6to5
 Major releases of most libraries try to do two things. They introduce new APIs, and remove deprecated ones. Our release focuses on doing one thing well: Instead of introducing new features, the goal of Ember 2.0 is to remove accumulated cruft. I really like this.
Nice work.
While it's technically true what they're saying, what they don't mention is that they're removing the “cruft” they accumulated over the last **year**… I'm working on various ember projects, and the ones that have been sitting around since August 2014 are completely outdated and probably need a rewrite, because so much has changed since then. They're switching the most basic concepts all of the time, and most of the time the reason is just that some core developer thinks that it doesn't look that nice the way it's currently done. It's a highly moving target, and stuff you considered best practices literally last week might be deprecated this week. It's easy to keep current if you're keeping track with every minor version (which comes out about every two weeks) and fix all deprecations immediately. Of course, this gets worse and worse the larger your project is (one of these deprecations a few months ago required a major rewrite of the basic data flow of my app, and I still haven't fixed all the bugs that were created by that transition). If you're on a deadline and can't keep up with the updates, you're SOL.
Still not sure I agree with you on cutting down the amount you have to write, but learning is always awesome :) 
English?
Thank you! I'm open to any constructive criticism, if you have any, let me know!
That's valuable information. Will this volatility continue or are the developers convinced enough of their current code base to not change core concepts from this major release on?
I can assure you that this is not due to a forgotten .gitignore. I don't think you really "got" the idea behind this. This is an experiment. I don't want to "compete" or "replace" npm. On the other hand, it seemed rather pointless to me to write a simple (but working) *alternative* to npm **install** that relies on npm to install its dependencies. I wanted this neat little thing to be fully-bootstrapping. Therefore there is no other way other than to check in the dependencies into the repo. You could argue that Node ships with npm, but it just didn't make a lot of sense to me to rely on it. Other than that, checking in `node_modules` has been pretty common for a while (especially before `shrinkwrap`). There are good reasons for it in some scenarios (e.g. version locking, not relying on a registry, keeping things predictable). In fact, **the old npm website itself has `node_modules` in it**: https://github.com/npm/npm-www/tree/master/node_modules 
Thanks.
I didn't ask any questions, nor did I state Facebook sucks.
they don't always think it be like it is but it do
Nice! I was just looking at [Select2](https://select2.github.io/examples.html) yesterday for an upcoming project, and I've looked at it before, but it seems too over the top when all you need is a no-frills JS autocomplete. I might end up using yours.
Broccoli is worth a rant on its own. It's a very complicated build system with lots of customizability at various points in the pipeline, but it's completely undocumented. However, you absolutely need to customize it sometimes. The only way to find out anything about how to extend it is to look into other components or its uncommented code. One thing I found out about it is that it always assumes that you have an input and an output file. If you don't (for example, I wanted it to download a file during building), there's no clean way to integrate that. At least I found no other addon that does that, so I assume that there's no support for it.
Or.. choose the right JavaScript project boilerplate for the job :) For example [React Starter Kit](http://www.reactstarterkit.com) or [Babel Starter Kit](https://github.com/kriasoft/babel-starter-kit) etc.
Not saying webstorm is essential at all. Just their preferred Text editor or IDE is.
&gt; While it's technically true what they're saying, what they don't mention is that they're removing the “cruft” they accumulated over the last year… That's right. Any project has technical debt, and clearing out old APIs enables us to continue progress. Those 2014 apps that you have could be rewritten in any new framework. What Ember provides is an option: By following the workflow of upgrade, refactor to address deprecations, upgrade, those codebases can migrate forward to the new framework of Ember 2.0. Is it exactly the same as 1.x in 2014? Of course not, we've learned a lot from our own apps and from competing frameworks like React. Plenty of apps from pre 1.0 are on 1.13 today, and will make it to 2.x. It isn't zero work, but happens successfully. My experience is that iterating codebases forward (at any pace, it doesn't need to happen right away) is a better path for maintainability than a rewrite, and is preferable to using a legacy platform that never provides new opportunities. &gt; It's a highly moving target, and stuff you considered best practices literally last week might be deprecated this week. That something is deprecated should not mean you *must* stop using it. This was a major fault in our 1.x release workflow, and we're taking steps to change that in 2.x. If something is deprecated in Ember 2.5, you should be able to keep using it until 3.0 without console spew. You should be able to move at your apps pace, not the framework's pace. That you and other users have felt "churn" is a failing we've already been working hard to improve. I'm confident it is a challenge we can address with improved tooling, and is not a critical flaw in our release strategy. If Ember stood still, it would be dead. Other frameworks, better suited for new users, would supplant it. If it dies, so does the upgrade path for all our existing codebases. IMO, upgrading should definitely *not* be painful, but statis would be terrible for both the framework and us as current users. There is a balance.
Yes I know them But if I did myObject + ' offical status'; it magically calls my object's toString method. It would be nice if a future version of JS could do var value = myObject + Math.PI; and automatically use my object's toFloat method instead of me having to write more code around it to get a float.
What particular use cases are you considering here? To me it sounds like unnecessary bloat/obfuscation.
im terrible at UX design, my main project is literally nothing more than a bootstrap dark theme :(
One of the new things they're now introducing is LTS builds, so there will be a much longer pause between them.
You can override an object's valueOf method to do that already. Not that you should do this anyway because it's confusing.
Pulls source directly from Github? Uhh... No thanks. Looks like it just handles package management. Webpack isn't a package manager, you just use npm packages with it. 
You can accomplish what you want in `ES6` with the future [`Symbol.toPrimitive`](http://blog.keithcirkel.co.uk/metaprogramming-in-es6-symbols/#symboltoprimitive)
Looks neat, matches my stack perfectly too (webpack, babel, scss). Will keep this in mind for future projects.
type coercion - can lead to strange things. var x = 1; var y = 2; var z = ''; var result1 = x+y+z; // "3" as a string var result2 = x+z+y; // "12" as a string console.log(result1,result2); console.log(typeof result1, typeof result2); // both strings console.log(result1 == 3, result1 === 3); // one is true, one is false
You spent those 3 weeks well. I'm impressed! Great job and keep it up.
The proper way to convert a string to a number is `Number('3.14')`
There's a project that lets you easily separate out html from js in react https://github.com/redexp/react-separate-template#jsx-tpl I don't know why react tries forcing you into this pattern when it's supposed to be a simple view library. Let people choose if they want to mix html and js. I prefer one way bindings like React, but this article is short sighted (I **like** having no choice of where to put my templates). Also the degree at which you're mixing code into html is way less severe with a traditional template library.. the point about other templating libraries being embedded js is weak. People wouldn't be in a huff if jsx weren't such a severe mixture of template and code. JSX = EVERYTHING mixed, templates (something like handlebars) = as little control statements and value accesses as possible. You can't even write arbitrary expressions with many of them. Look at blaze for a simple implementation of one way bindings with clear template separation from code. https://atmospherejs.com/meteor/blaze It also separates events out of the templates. I guess it's not so evolutionary if people are already copying it but departing away from this feature.
Messy and powerful; but once you get the hang of it you feel like a fucking God
Wat. Guess you don't buy into the whole "shared mutable state is the root of all evil" stuff. You probably haven't written any significant amount of code.
Yuck. I fail to see the benefit of separating JSX that way. From the project you linked: "First problem of react is HTML inside our JS files and there is no way to make them separate." I'd argue the problem is the illogical desire to *physically* separate intertwined concerns into separate files. There's some clear benefits to the entire React component being composed in a single file, as the article discusses.
ftp://c-bc9de555.018-278-73746f44.cust.bredbandsbolaget.se/disk2/N2/LIBRARY/REF%20LIBRARY/English%20writing/The%20Chicago%20Manual%20of%20Style,%2016e/16/ch08/ch08_sec153.html TIL: copy their capitalisation, possibly try not to have it at the start of a sentence.
The illogical desire to not use a jsx transpiler? It seems to achieve its goal pretty nicely and as I said I don't think the industry is in love with jsx I just think the alleged magic and love of two way binding has worn off at the perfect time and most have said "good enough!"
Thanks! I was worried adding music would be annoying if it came out of nowhere, but maybe I'll add a toggle for it in the navbar?
Enjoy it while you can, before it becomes a chore ;) Out of curiosity, where did you struggle the most? Was there anything that didn't make sense at first or was hard to work with?
I really don't think it's as good an idea as the rest of React, and in a lot of ways I think the mental effort expended on JSX is wasted. It's a shorthand for doing a bunch of `React.createElement` calls, big whoop. React rules because of how it actually works, not how you express the markup of components. I still prefer HTML templates in a separate file. Which is absolutely doable with React, but you wouldn't necessarily know it because people focus way too much on JSX and the aesthetics of mixing angle-bracket-stuff and curly-braces-stuff in the same file. Stuff like this, and semicolons and all that shit, it's just not important. What matters is how things work.
Blaze is nicer than most, but I'd pick JSX any day. * Blaze depends on jQuery. * Things get extraordinarily messy after a while due to context. * The cost of creating new components is higher than React, and the components aren't very portable. * I don't think it's possible to instantiate Blaze components in JavaScript. * Using custom helpers is a pain, and those helpers exist in a global namespace. * No lightweight method to have helpers return HTML. * The "reactivity" of templates likes to cause subtle problems. It's hard to debug this and fix any problems caused by it. Most solutions require hacks with annoying trade-offs. * All of the arguments against artificial separation of a singular concern still apply. Templates are only useful if you have designers who need to read and write HTML. Even then, the majority of them pick up JSX without much fuss. The benefits in power, flexibility, performance, and ease-of-componentization far outweigh any benefits you might get from using templates. &gt; clear template separation from code By and large, the choice is either: * Code in your templates, or, * Templates in your code. There is no such thing as "template separation from code" in modern JS apps. &gt; People wouldn't be in a huff if jsx weren't such a severe mixture of template and code. We all reacted negatively to JSX initially. Why? Because we've been told for years that putting HTML into JS is evil. The reasons *why* this is evil don't apply to JSX. This is something most people quickly figure out after using React. Describing your UI in code is something that people have been doing for a very long time. 
Yup, and I wanted to chime in and say it works very well. Especially in conjunction with Browserify's standalone option, I think it's one of the best ways to author a client-side library now. Now if only browserify could fix the bundling of browserified `--standalone` bundles, that'd be great!
I have to admit, I am rather skeptical. In three weeks... just 20 some days... you went from zero knowledge of web development to knowing how to write html5, mobile responsive css3, hundreds of lines of javascript as well as jQuery (including prototyping, timing functions, DOM manpipulation, etc)? I suppose it's possible... I'd say highly atypical though. You're a prodigy, it seems.
Haven't watched it yet, but I completely agree.... why use CSS3 instead of something like Velocity.js or GSAP if you are targeting 60FPS animation?
Prince? Also there's a clear difference between punctuation marks and letters. Writing Yahoo! would break the sentence (&lt;-- like that), it's pretty clear that. iPhone is the start of a new sentence.
First off, I like JSPM. It's actually the only module system (system.js that is) I've worked with extensively. However there are some pain points: * Configuration as far as paths and where you want to house your jspm_packages and config.js file can be a little confusing if you don't use the default settings * working with packages that aren't jspm/umd friendly can be a really pain in the ass. The shim configuration is something that I still haven't grasped yet * it's still a work in progress and as such, documentation is lacking. However, the creator Guy Bedford is very responsive to github issues and on their gitter All in all, it's really not that bad to work with once it's wired up but when you run into a problem, it can be very frustrating. I would highly recommend looking into it though. It's a forward looking approach to application design and architecture. This [javascript jabber with Bedford](http://devchat.tv/js-jabber/115-jsj-the-es6-module-loader-polyfill-systemjs-and-jspm-with-guy-bedford) is pretty good as he explains his motivation for the project.
Doesn't webpack use the same syntax?
Well, like I said, it seems you're a prodigy. I can't even imagine what you'll be doing a year from now. Five years from now. Go out there and change the world (wide web)!
youre short
Sorry about that! Thanks for the tip. Still new to linking projects and all that. Should I link directly to that page instead of the github.io page in the future, or is the fork-me badge preferred?
I'm a firm believer is not over-engineering things. That's quite a complex set up.
The dealer's face-down card number is in the DOM at run-time :)
Your next step is to find and fix your two HTML errors and two CSS errors, all of some significance.
Really? I thought I saw somewhere they were developing a new rendering engine.
Sorry if I'm a little slow with these replies; this is a new account and reddit is restricting me from faster ones. Thanks for the encouragement; I'm souped to learn more! But for now, I'm trying not to get ahead of myself. After struggling to find employment with a liberal arts degree, it's more than enough for me that I finally have something to sort of show off in a portfolio :)
They did :) It's called Glimmer, and it dropped in 1.13. Here are the patch notes for you! http://emberjs.com/blog/2015/06/12/ember-1-13-0-released.html
Still being worked on, apparently: https://github.com/souporserious/velocitytransitiongroup
Unrelated to the animation parts of this video, does anyone else wonder why they limited their choices to just Backbone+jQuery vs. React? I feel like there are a lot of other healthy competitors out there...
I find having HTML templates in a separate file just forces constant window (or tab, whatever) switching because the DOM and component logic are tightly coupled. Much prefer having it in the same file.
That's actually a really good point re: "the real challenge for bootcamp grads" that I haven't heard before! I'll start taking better notes. Thanks!
im assuming this is why its best to use triple equal signs instead of double right?
Not sure if this is a joke about how there are always errors in code or if you're pointing out four specific ones, since there's definitely FAR more errors than that. But a friend did just point out to me that I hadn't set any responsiveness for larger screen sizes (I'm working on a 13-inch MacBook Air), so I guess I'll have to dive back into the code later tonight....
It doesn't really matter, some people like the badge since it encourages others to participate in their project, whereas for something like yours (a game) a badge might interfere with gameplay. The idea though is that your average redditor can find the source without having to track it down with your github.io subdomain. A lot of people don't do either, and it's not a new requirement -- just a request :) Though I'd like for it to catch on just to make it easier for our readers.
Ah, that's the term! Thanks!
I know, that's why I talked about claims and "what people make it out to become", as opposed to what it's actually going to be.
Basically, it means you load two versions of Angular, and if you use the router that Angular is going to release _any day now_, you can use that to specify which parts of your app need to use which version of Angular.
\*Me on a passing ship\* Me: Congrats for all your hard worrrrr.....
ewwww
Thanks for the tl;dr - that's pretty cool.
You're not considering the introduction of all the technologies that go into those one-or-two-lines-of-code just to use Babel. What does it gain you and your team, and what trade-offs are you making for them? Engineering isn't about simply picking the hottest technology and going for it. If it's not necessary, it's over-engineering.
&gt; Doing "new things" doesn't mean breaking old things. You are looking back in history how far to come up with that statement? Case closed. Ridiculous. Especially in IT. And **nobody prevents you from remaining on Angular 1!!!** I'm sure we could have built incredibly stable and easily maintainable systems on MS-DOS 6.0. We have overwhelmingly chosen a more difficult path of eternal change, for more uncertain but hopefully much higher benefits, and so it is.
Nice! I dig it. From a JS point of view, it's a neat little tool. JS advice: Wrap the entire thing in an IIFE (just good practice to not pollute the global scope) You have two function declarations called toArray - might want to remove one Perhaps instead of using the 'onclick' attribute in your HTML, add an event listener in your JS file (I'm just personally not a fan of that kind of JS) Here's some non JS advice: Choose a different font, something more 'code legible' (some monospace font). I'd also add some padding around the list items to make collapsing/expanding a bit easier, and perhaps disable highlighting and change the cursor. 
JetBrains give students discounts and for valid open source projects they give out free licenses. This isn't a good argument.
Please don't be insulting. I am considering it... if you're introducing typescript you are introducing transpiled code anyways. I already outlined what we gain.
Why VSCode over Atom? It's built on Atom.
Why not just use your fork of the addon until it's merged in?
Thanks for the suggestions! I think you're definitely right. I've been thinking about dropping a tutorial over the page before the game starts, rather than hiding a bunch of functionality for no real good reason. If you didn't know, you can actually change your starting bankroll (only before the game starts), your name, and the background color! And I should add definitely add a Game Over screen! It's been on my list of to-do's forever! Sorry about that. I spent so long fixing all the small bugs that I admit I haven't actually played the game myself in a really long time!
I think he meant that it's a burn. The burn is to what people think that Angular 2 will become. Or something.
I haven't kept up with the newest CSS, but if you want to reset the DOM from all jQuery inline changes, you can do something like this: $('#modal *').attr('style', ''); That will remove all the inline style attributes of all elements inside the #modal element. Naturally this will screw up your page if you're using inline styles (which you shouldn't) and won't reset classes that have been added/removed.
There's no `google.maps.addListener` method. As of version 3.20 at least it's all namespaced in `google.maps.event`.
I like to write in Python, transpile to C++, include JS, and then compile to Java so I can run it on JVM in WINE on Gentoo.
Yo dawg....
No. You have four errors, one I saw right off the bat cause it stood out like a sore thumb when I looked at your markup. The other three I find using another method you should have used yourself. These are markup errors, not errors of omission.
Those numbers just scream: *move to Texas*. You can make almost that much here and houses cost 10% of what you would pay in the bay area, no state income tax, food and gas are cheaper, and we may be getting gigabit home internet soon http://www.bizjournals.com/austin/blog/techflash/2014/08/at-t-expands-gigabit-internet-service-to-dallas.html. There are plenty of jobs here too.
It's still not free for commercial users (and it actually costs twice as much, $99, for commercial licenses). That was my main point.
Not being able to do direct disk I/O is pretty annoying.
It's a little annoying that having a critical opinion of JSX means you're "freaking out." It's _really_ annoying that the article is ignorant of the fact that **plenty of people hated two-way data binding** and it's no surprise that we're now moving away from it. I don't think JSX is a "wild" idea, I just think it's a dumb one. _doingnumbers' comment is moderate and tolerant of JSX. Go ahead, downvote all the people presenting their experience in this topic. Squelch the disagreement and pretend it doesn't matter. 
So... PyPy + Emscripten + LLJVM + well regular WINE? Solid toolchain ;)
It's PHP not javascript. Try /r/php or /r/webdev
I am well aware that many hated two-way binding. The article isn't about two-way binding. Downvotes aren't "squelching disagreement". They're a statement about the merit of one's argument. I'd enjoy reading a post that explores why JSX is "dumb" and x is "smart".
the stuff that gets downvoted in this sub can be pretty amazing.
Is the Gentoo a container running on a virtual machine ?
Yeah, VMware player inside Parallels Windows environment on a Mac Pro.
You forgot the "Split" option for pairs.
How old are you and what was the name of the bootcamp you attended?
I love JSX. The react philosophy is that components should encapsulate their own state and logic. So why should they not also encapsulate their view, and even styles? This is perfectly intuitive to me. Personally, I love not having to bounce all over my codebase trying to figure out where a template is, or where certain DOM element is being used. In React, you go to the component, and everything is there. 
&gt; I'd enjoy reading a post that explores why JSX is "dumb" and x is "smart". You probably know most of the reasons already. This article didn't present anything I hadn't heard before. It's a difference in opinion. I'm commenting not particularly to change anyone's mind but to make sure the difference in opinion is represented and not shoved to the gutters. Mostly, perhaps, I'm trying to point out that React's currently the popular choice--with all of the hyped thinking that implies. 
&gt; Things like ember or angular have to be moving targets at this point. They are trying to do new things. No they aren't. We're just trying to serve web content here.
They can do it, I have faith in their ability to pointlessly change everything, then change it again. Also: I'd like to introduce you to someone... steveklabnik1 meet Sarcasm. Sarcasm, meet steveklabnik1.
My "we" is obviously a reference to my general perception of the response. Of course it's not a universal. Nothing is universally accepted. That said, Angular, Ember and Knockout's vast popularity and quick uptake certainly represent a broad and rapid acceptance of the two-way binding pattern. I'm merely arguing that the broad acceptance of two-way binding makes accepting JSX easier.
Sorry, I mulled that over for a LONG time, and ultimately decided it would be way too difficult for me to put that together with my current style in the seven or so days I had to work on this (instead, I decided to spend like three full days on mobile compatibility, haha). Maybe if I get a chance to come back to it soon, I'll look into doing something like Double battles in Pokemon? Or if anyone has any better ideas? Just felt a little too constrained in this style :/
First off, don't use requireJS for medium to large SPAs. Not only do you have to wait with each refresh while your browser loads hundreds of js files in your development environment, your environment will load in a significantly different way to how an optimised build for production will load.
I'm interested! Demo projects: http://codepen.io/ForScale/popular/
Meh. I am done with it entirely. In fact, the whole Angular 2.0 thing turned me off to learning any more languages until they have been around for a few years. I just don't have time to invest in learning, then completely re-learning a language. I don't want to re-live ActionScript. 
Keeping the pedantic-asshole programmer stereotype alive are we?
If you keep using these skills intermittently in either your personal time, or professionally, regularly, you will retain it. Congrats. Your hard work is already paying off. Doing a great job man. 
It's clearly marked as off-topic. You are free to ignore it.
you can still do two way binding with react if you really want to.
It wasn't in my signature? Sent from my Moto X (2014) using Tapatalk. Tryin to make a change :/
Pretty interesting talk a about the why's and how's behind Netflix new UI, which is all really for the sake of UX and Design. Something I don't think I've always given the respect it deserves.
I think /u/Magnusson means that OP did not write jQuery (as in __the library itself__), which you included in the list of scripts in your post.
It's impressive that you learnt all the skills in such a short time. Nice job. My feedback would be UI design related. To me this is related: http://i.imgur.com/6zg2WS6.png it took me quite a few rounds to notice that those are not mine cards. It's a good practice to group things together that are related. Keep up the good work
i have framework fatigue
Ah... oops! Didn't realize that was *the* js library. OP has jquery in his code though, right?
&gt; Yahoo's name is Yahoo, and their logo looks like "YAHOO!", there's no conflict there. [https://en.wikipedia.org/wiki/Yahoo!](https://en.wikipedia.org/wiki/Yahoo!) "Yahoo Inc. (styled as Yahoo!)" "It is globally known for its Web portal, search engine Yahoo! Search, and related services, including Yahoo! Directory, Yahoo! Mail, Yahoo! News, Yahoo! Finance, Yahoo! Groups, Yahoo! Answers [...]"
Github with the demos: https://github.com/desandro/practical-ui-physics Slides: https://speakerdeck.com/desandro/practical-ui-physics
Yeah, I need a better dummy sprite for the idle position. thanks for the suggestion! I think I'll incorporate a delay for the player sprite. I haven't made separate states for orientation: hence, he'll keep looking right in idle state.
thanks for the bad news. made me feel better
Fortuitously, there's an article on the semver mismatch issue: https://medium.com/@kentcdodds/why-semver-ranges-are-literally-the-worst-817cdcb09277 
It uses the same basic technology, but since Handlebars is more delcarative, it can theretically be faster. But I think React is going to be taking those ideas and incorporating them somehow as well. (as always, exact benchmarks depend on you and your app. See https://www.isemberfastyet.com/ for more details, including a demo)
Most of so-called ES7 features won't get into ES7. Moreover, some of them are on very early stages or not proposed at all yet (like bind operator).
It's up to you where you want to draw the component line. You can put several small components in one file, or combine them into one big component, or spread them across a few different folders.
Thanks :)
Oh my god, you're right. I dealt with all money related things in one crazy hazy Saturday night, and completely mixed up those rules. Thanks so much for pointing that out! I'll have it fixed as soon as I get home.
311 KB of minified/compressed JS to generate a document which would be 13 KB gzipped. I'd just use a static website generator.
Really? You think someone can go from zero knowledge of html/css/javascript to writing over 1000 lines of error free js/jquery code that contains timing functions, animation, and DOM and css manipulation... as well as writing over 500 lines of error free css code that includes mobile responsive design... all in just 20 days? That seems crazy to me. Sounds like it seems crazy to some others here as well. I guess it's not though...
&gt; Does Javascript come with an in-built file/text reading function? JavaScript is meant for embedding. Its standard library contains nothing for communicating with the outside world. Every JS-based runtime environment exposes some APIs for doing some kind of IO to scripts running inside it. Node, for example, lets you read files via "fs" and modern browsers support the Fetch API for downloading resources. Anyhow, I recommend to use JSON. var o = JSON.parse('[{"foo": "uno"},{"foo": "dos"}]'); console.log(o[0].foo); // uno console.log(o[1].foo); // dos Simple, right?
Should be fixed now! Thanks for pointing that out; I spent so long working on the minor details that I totally let this one slip!
Oh no! Out of all of my code, I probably had the **most** trouble with making that score number increment on a timer; I really thought that had all been fixed. I just checked it out, and eventually had the same bug. Thanks for pointing that out. I guess I'm diving back into the world of timing events for at least one more night....
This is something I can get behind.
Oh, thanks! It wasn't really necessary, I did it because I thought it might help. But well, thank you very much :)
I like how Netflix has thrown everything behind Node and React, and they really seem to be reaping the benefits. My favorite part (paraphrasing), "We tried to beat React in performance and speed in this one area, and every time React was faster."
Yes. Not only do I think so, but I know so. I've done web development tutoring for graphic designers who have zero prior experience. When taught properly, anyone can pick up these fundamentals rather quickly, even in just a few weeks. Take a look at the code (and even CSS). Nearly all of it looks as though it was copied from examples in tutorials. You really don't think someone could hack this together from tutorials after 120 hours of legitimate schooling?
Or in this presentation, 5 fps.
edit : reworded for clarity. Netflix is using Facebook's ReactJS, but is not using Factbook's Relay/GraphQL. Instead, Netflix decided to use their own home grown FalcorJs. I'm interested to find out why they chose FalcorJs over Relay/GraphQL for their specific use case. What was their thought processes and decision gates?
Man, I read your post three times and I still am not sure what you are trying to say.
Yeah, a little unfortunate that they were having such issues with the recording. Good talk, though.
Went from 200 loc to 50. That's pretty massive.
Ajax?
The technical details of what "JSON" is can be found here: http://json.org/ In short, you can store Object Literals (http://www.dyn-web.com/tutorials/object-literal/) in an array in a text file (*.json) which can be loaded with an AJAX call (XMLHttpRequest for vanilla, or jQuery.getJSON if you're using that library). The advantage is that you can store your static data in the same object structures being used in your application (which has a number of advantages for initialising your application). (If Local Storage is an option - see: http://www.w3schools.com/html/html5_webstorage.asp) it's possible to keep the object cached between sessions. You may need to refactor your code to take full advantage of storing your data in an external json file, but it may be worth it. Also, if you happen to have access to Node, PHP or similar on your server, you could create a relatively simple RESTful API to update, edit, delete, etc. entries in the JSON file.
&gt; Did people complain this much when HTML templating Yes, and they still do. &gt; Can someone explain why they don't like JSX I don't like it because it's a devolution, in my eyes. We've had HTML-in-a-language before, and now we have it again. In addition, I'm not a fan of many web development approaches because they never seem to learn from what works very well on other platforms. JSX is just another example of that.
React/Flux is amazing, GraphQL not so much. Its use case is too specific to facebook's needs.
The size of a framework's API isn't what makes for framework fatigue.
You mean like dividing the box height by the line height? http://codepen.io/anon/pen/QbPxPe
Just wanted to thanks for sharing. 
Bind isn't simply a replacement for closing over variables. There isn't anything wrong with your first example, in-which you are closing-over the variable `context`.
I'm sure Falcor was used because they already use it and is already in production. Falcor seems like it'll work with any framework. 
It interprets it as something that should be linked to a URL, just as it does a URL (usually), `/r/this`, `/u/this`, and `[th](is)`.
&gt; Yes, and they still do. I was around when JS templating took hold, and I don't recall that being the case. Certainly not on the same scale. Back then, it was a no-brainer that you would want to do put code in your HTML. Some people dissented, but they went largely unheard. Some in the Rails community and the [Lift community](http://www.liftweb.net/) come to mind, but those weren't even client-side, mostly. And, of course, many people would still rather do window.notice.innerHTML = '&lt;marquee&gt;&lt;b&gt;Welcome&lt;/b&gt; &lt;blink&gt;to&lt;/blink&gt; &lt;font color="blue"&gt;our site!&lt;/font&gt;&lt;/marquee&gt;'; &gt; In addition, I'm not a fan of many web development approaches because they never seem to learn from what works very well on other platforms. JSX is just another example of that. In fact, JSX is *more* like other platforms. Other platforms don't force an artificial separation between inherently coupled view and view logic. Swift: let button = UIButton.buttonWithType(UIButtonType.System) as UIButton button.setTitle("Hello world", forState: UIControlState.Normal) self.view.addSubview(button) If somebody were to write a declarative wrapper over this, it might look like this instead: View( UIButton('Hello world', forState: UIControlState.Normal) ) Or &lt;View&gt; &lt;UIButton forState={UIControlState.Normal}&gt;Hello world&lt;/UIButton&gt; &lt;/View&gt; Basically, JSX is just declarative sugar over function calls. Now you might protest and say that "well, you could create UIs with drag-and-drop!" Indeed, [JSX paves the way for this](https://github.com/ipselon/react-ui-builder). I'm tired of all this "other platforms have it right and we're doing it all wrong". The web platform is unparalleled in its flexibility, innovation, and developer experience. This is why React Native was praised so much.
&gt; what do you mean by "using another method you should have used yourself"? https://validator.w3.org/ https://jigsaw.w3.org/css-validator/ http://jshint.com/ Validate and lint your code. A good text editor like Sublime will allow you to do this sort of thing as you code (Don't get off-track with your bootcamp, but later on down the road, you may want to try working with things like JSHint and Emmet or code snippets in your text editor). There are at least 2 errors in HTML and CSS, depending on the validator and how strict you want to be. The Javascript has 6 undefined variables, 8 unused variables and 23 warnings. That's not necessarily bad, by the way. One of the "undefined" variables is $ which obviously is used by jQuery, but JSHint doesn't know that, so you have to take the warnings with a grain of salt. JSHint also gives you an idea of what /u/g3bj45hg34857 was talking about with organization and not having one big file. You have 114 separate functions, the largest of which has 68 statements in it. Neither of those numbers is optimal. Don't get me wrong. This is an impressive project for three weeks in. Keep up the good work. Hopefully you can use these tools to fine tune your code.
What he said was pretty straight forward. What did you have a hard time understanding? Or did his edit clear things up?
below should do var sum=0; for (var i= 0; i&lt;why.length;i++){ why[i]= prompt("give me a number"); sum+=parseInt(why[i]);
62 is the number of lines of code you see in the file, but 54 is the number GitHub tells me. I am not sure how they calculate this, but think it skips blanks lines and statements that you break in multiple lines. So, the total is actually 50 something. It matters because the algorithm I am using is much more efficient than the one used in `minimist` which is the defacto favorite in the community and while that library is still pretty lean when compared to nopt, yargs, etc., it is 4 times as large as Parsec with the same feature set. Actually parsdc is compliant to the UNIX utility guidelines, where minimist ends up failing in a few occasions and which is what prompted me to write this in the first place :) 
Haha. Yeah, his edit *drastically* changed the message. It was originally one line long and looked like it might have been written during a stroke. I'm going to assume he was on mobile. ;) 
&gt; it is 4 times as large as Parsec with the same feature set This is nonsense. - You're using es6 and requiring the babel runtime - It's been out for _much_ longer and has had to address numerous bugs - I could write one in ~20 lines of code. That doesn't make it better
Again, as far as Reddit's Markdown parser is concerned, u/X is accepted as a root-relative URL while www.example.com is accepted as an absolute URL. Therefore, "u/X" is the same as "/u/X". It's a root-relative URL which refers to a specific Reddit user. In the same vein, "www.example.com" is the same as "http://example.com/". Both are absolute URLs (as far as Reddit's Markdown parser is concerned). Anyhow, your original statement was that you don't capitalize these root-relative URLs for no particular reason. My point was that you should not capitalize those because paths are case-sensitive. "/foo" and "/Foo" may refer to different resources. Even if it were a relative URL (it only looks like one), it would be still case-sensitive.
Using Relay means that you have to rework your backend to support GraphQL. Not a trivial task for some organizations.
no. both are built on electron. 
Now that it's available, who will win the performance and usability cage fight? 
Welcomes
Aw man, that seems a little harsh. My code is super messy, but I wrote the vast majority of it myself. The only things I borrowed from the Internet were a check for mobile device, some standard mobile queries, and the shuffle function. Can't think of anything else off the top of my head, but maybe one or two other lines. I didn't copy examples from tutorials, and frankly besides an obvious refactor that this code desperately needs, I'm not exactly sure how it looks like that. Definitely hacked together though. This project was done in five days, from last Wednesday through Sunday night, and since then I've just been tinkering with mobile responsiveness in the hour or so before I go to bed every night. Sorry, I agree with you that this isn't super advanced code, and I realize this is a little ironic since you're arguing with someone who's skeptical about my timeframe anyway, but if there's something clear about why my code looks like it was "copied from examples in tutorials," I'd be interested to know why. I spent a lot of time writing this on my own.
Absolutely agree with you 100%. This is exactly how things SHOULD be done, in my opinion. But as the XKCD saying goes, every change breaks *someone's* workflow.
thank you! sad that i cant recognize this by myself..
surely you meant 24fps right?
I really don't know. I haven't learned enough about FalcorJS to judge its merits over Relay. It isn't released yet so I guess that is a downside.
Did he stutter?
big woop
Nothing! Just pure CSS and a bit of JS! :P I built http://marble.clientsite.me about 4 years ago (load on a phone and it's tilt sensitive). It was a prototype for a game that I never got around to actually building. Serious answer: three.js is probably your best bet.
check out [livereactreload](https://github.com/milankinen/livereactload)
sorry i was in a bad mood :(
As you noticed, I made these comments in defense of your ability. It wasn't meant to be a knock against you, so try not to take offense. The reality is that you're still a novice, though perhaps rapidly approaching an intermediate level, and the code reflects that. You should be proud of getting this far so quickly, but also recognize that in as little as one week, you will look back at this code and laugh at yourself. Even after 24 years of programming, I still look at code written six months ago and wonder what I was thinking. It's a constant learning process inside a constantly evolving environment, but you're off to a great start. Aside from sheer verbosity, there are two big reasons why your code currently looks tutorial-like. 1. You haven't yet learned about [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principles. This is easily visible in functions such as `changeBet()`, which you seem to already be aware needs some work. The reason why needless repetition reeks of tutorial, is that tutorial authors are typically trying to keep things as easy to understand as humanly possible, and DRY principles are typically outside the scope of what they're trying to explain. So, instead of creating lean code, they will copy and paste the same code several times to handle identical functionality, even if it's just to process similar data within different variable names. 2. You haven't yet learned about [separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns). For example, the majority of your script is just modifying the styles of elements and handling responsiveness. The same functionality can be achieved with far fewer lines of code and significantly less complexity by purely allowing CSS to handle nearly all of this. For another example, until you are working with templating libraries, HTML has no place inside your script, and instead belongs in the document. If your concern is that you don't want the table to be visible until the script is ready, you can just hide it with CSS until you have initialized everything (which would be an example of a good reason for using JS to modify styles). This will change, of course, as you progress in your learning, and I suspect you might progress faster than most. If you have any questions about how to implement either of these principles, send me a PM. I would be happy to provide some guidance and set you on the right path.
I thought this was a pretty good slideshare on refactoring a large spaghetti app into backbone with modules. It talks about both requirejs and commonjs near the end. http://www.slideshare.net/stacylondon/refactoring-large-web-applications-with-backbonejs
&gt; You're using es6 and requiring the babel runtime 1. But that's just because I _wish_ to write in ES6. It's not like I am using any hidden ES6 feature. I could come up with the same in ES5 in maybe 10 more lines :) &gt; It's been out for much longer and has had to address numerous bugs 2. True. It still has several bugs unaddressed (check the issues) and it's not compliant with general [UNIX utility guidelines](http://pubs.opengroup.org/onlinepubs/7908799/xbd/utilconv.html). Also, the code although just 200 lines it's a [ball of mud](https://en.wikipedia.org/wiki/Big_ball_of_mud) :( &gt; I could write one in ~20 lines of code. 3. Sure? Go ahead and ping me when you are done. I will buy you a coffee if you ever drop by Tokyo and spend 30 minutes having an excellent chat with you over your favorite video call software at the best of your convenience to show you we can treat each other with less contempt and more respect :) &gt; That doesn't make it better Sigh. When it comes to software, what matters **is** the algorithm you use. Parsec's algorithm is simpler and efficient which results in very few lines of code. That's a fact.
you can and should write require(); in your code. You just need System.import(); once for the main file. With any loader solution, you need to specify the main entry file. This is just the way systemjs does it. I have the same index.js for all my apps, so I don't really mind. Also System.import comes in handy when you want to load something conditionally in your app, saving bandwith for some users.
I'd swap the dealer and player card location. Also, split the screen by altering 50% of the background 20% darker: http://imgur.com/jcANxMl (but I thing a vertical splitwould be better)
Since the IEFF its purpose its scope creation, using any of those operators, does not affect anything to the actual function. ! its a negation function, which converts any value it returns into an bolean, + converts the function return into an integer which if its a string, will be return either NaN or a number, the same for the negative operator, which will return a negative integer or NaN. I believe they are safe to be used, but of course the best way in my opinion is using the brackets notation, and also as Douglas Rockford said, put the dog sacks inside the brackets: (function () {}());
&gt; nor is the spec final It was finalized back in June
Example in 13 LOC: var args = process.argv.slice(/\.js$/.test(process.argv[1]) ? 2 : 1), rx1 = /^-(-(no-)?)?(\w+)((?:=)([^=]+))?$/, rx2 = /^([^-].*$)/, out = {_:[]}, res, val; for(var i=0, l=args.length; i&lt;l; i++){ res=args[i].match(rx1); if(res){ val=res[2] ? false : res[4] || rx2.test(args[i+1]) &amp;&amp; args[++i]; (res[1] ? [res[3]] : res[3].split('')).forEach(function(varName, ix, ary){ out[varName] = (ix===ary.length-1) &amp;&amp; val || (val === false ? val : true); }) } else { out._.push(args[i]); } } console.log(out) I'll re-iterate: being short doesn't make it _better_. There are probably plenty of bugs, but it mostly works ;) And I'm not trying to be an ass, I was just bored and curious if I could actually write it in 20 LOC :P It should be mostly feature complete except for allowing defaults.
Y'all are so nices 
&gt; what matters **is** the algorithm you use. Parsec's algorithm is simpler and efficient which results in very few lines of code A) Fewer SLoC does not mean an algorithm is more efficient. In fact, the naive approach to a given problem is often much shorter, in terms of total SLoC, than the optimal solution. B) How often in your program do you parse CLI parameters? How many CLI parameters do you typically have for any given program? I'm guessing that if the answers to these questions are anything other than "just once" and "fewer than ten (or even twenty)", you're doing something very, very wrong. This is not a problem that, as far as I can tell, can ever be expected to scale up in any significant way, and it's not an area where performance or efficiency are going to be important in the slightest. I would be very surprised if this program--or minimist, or any other CLI parser--ever took more than a few milliseconds of execution time during the lifetime of any given program, so it doesn't seem like it would really matter. But, since you have made the claim that your library is faster, and that its speed and efficiency are its main selling points, I would be interested to see a benchmark demonstrating your claim. Could you post a JSperf?
&gt; spam Didn't mean to. But I'll admit I "overposted" this. I was too excited about it, my bad. &gt; LOC does not make a better library Agreed. The *algorithm* does. "Often", a simpler algorithm means less LOC, but this is not written in stone I guess. Woah, you found a bug, I **really** appreciate this dear stranger. [I went ahead and patch, push and re-published](https://github.com/bucaran/parsec/commit/d11038c9d338b9a974cd7679974888ee3febc6f4). &gt; BTW `parse` will slice starting from 2 by default, but you can bind the function to your own array of argv (like when testing) and it will not slice anything. 
Nope, you're not alone :)
i hate Netflix's new layout
Awesome. It's more difficult to read than minimist, but illustrates your point about LOC as a bad indicator for code quality ;) Ping me if you ever come to Tokyo! My email is displayed on my [GitHub profile](https://github.com/bucaran). To be fair though, the set of features is very different, so this is _not_ a fair match. It was very hard to pack more features than minimist in 1/4 of the code and still write readable code without strange hacks or regex porn: + no defaults, no aliases, no shorthands + does not handle repeated keys `-a1 -a2 → a: [1, 2]` + does not handle `--key=value` pairs + does not handle values that are numbers or special characters (`-a123`) + does not honor the end of opts character `--` + does not handle unknown keys (no defaults so this one is obvious) + bugs + `--foo --bar` + `-a1` Still pretty amazing, for 13 LOC. This has been a lovely exchange :+1: 
I completely understand shipping node_modules in a predictable environment and operating system, where you have control over. However, as a personal rule of thumb, when you do want to contribute to open source software, it is advised **not** to commit the node_modules directory, because you may have dependencies that require a building phase (building on windows !== building on linux, in some cases), hence possibly making your module not work on all platforms.
I feels what you're sending my way!
Competition is always an awesome thing. Can't wait to see the fruit it bears!
&gt; If you start developing and your thing grows, you have to rewrite. Eh? You've never used a static website generator, have you? The popular ones are *very* powerful and extensible. https://www.dartlang.org/ (Jekyll, [repo](https://github.com/dart-lang/www.dartlang.org)) http://komodoide.com/ (DocPad) &gt; Why not use a technology that scales by default from the beginning ? As far as traffic spikes go, nothing scales better than static HTML.
A) Yeah, presenting web content is "a new thing" B) Since you fuck horses, would it be a stretch for me to suggest you go fuck yourself?
The junior market is saturated but companies are always looking to hired talented people as long as you can stand above the general junior fold. That and SF is much more junior friendly than NYC.
Beautiful ride indeed :) Well, do come back, Japan is full of hidden gems :+1:
To the person that reported this for "vote manipulation": us mods have zero insight into anything that could confirm or deny that vote manipulation has occurred. If you believe something like that happened, then [contact the admins](https://www.reddit.com/message/compose?to=%2Fr%2Freddit.com).
I plan to! I'm fairly close right now (in Australia, heading to Bali in 2 days). I'll probably hop over there when it gets warm again around April
I hate that there's a startup sound now. 
Java and JavaScript are 2 completely different things.... Java is to JavaScript as ham is to hamburger
Well I would LOVE 30fps. Max I get in HotS is 3~7... :(
Thanks a lot. I'll check them both out.
Hey man good job, I will probably use this at some point. One thing I would say is you could move all the AMD/global cruft to its own separate file, and compile/distribute that, but use the ElementDataStore file itself as the Node entry point. That way NPM users don't have to download/compile the cruft.
Nice!
Gyp is the build system, nan is a C++ library to aid in compatibility between Node and V8 versions by providing abstractions. So if you want to write a compiled module, you should use the nan library. 
Something like that. It's actually compiled into a shared library (.dll on Win or .so on POSIX, or .node, or whatever sounds good at the time), with exposed functions for hooking into the Node process and exposing the functionality. Node then loads that library in, runs those hooks and everything is good. [Here](https://github.com/bnoordhuis/node-heapdump) is a good example of a binary module. 
Your question is hard to follow and if I'm interpreting it properly it could be solved with a quick google. You also seem ungrateful when /u/fjekfkk attempted to provide a solution for you. I don't like you as a person.
That's not how this works.
&gt;&gt;"I want to have the dropdown menu to close when i click outside it and the **arrow turns grey after i clicked on it once** , I want it to be **same color all the time (black)**." What?
You might also think about systemjs with jspm. System has the benefit of reading multiple formats including commonjs, amd, requirejs, and ES6 modules. https://github.com/systemjs/systemjs
Original Post referenced from /r/aureliajs by /u/Davismj [Aurelia Authentication: Multiple shells](https://www.reddit.com/r/aureliajs/comments/3gzebn/aurelia_authentication_multiple_shells/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher)
&gt; Our web needs better primitive libraries. We’ve been relying for too long – far too long – on jQuery. Amen!
&gt; Is NAN different from gyp? No, neither are numbers
I you look in the lower-right, the screen in the actual conference room seems to be working at a much higher framerate. Which really confuses me, because he's apologizing, live, about the framerate in the screen-recorded video. Was the talk streaming too maybe?
This is part of my strategy to ditch jQuery, I needed this bit of functionality so I built it as its own module
Yeah, I've been working up the courage to rewrite the event handler. But that is such a massive job unto itself, I don't get very far.
Ok so basically, there is such a huge gap between .10 or .12 (many people still on .10) and what will be announced as a new Node.js release in September that everyone who plans to try to upgrade to the new Node version should try io.js 3 ASAP to see what breaks. Especially if you have ANY native modules in your project. I can foresee like 10,000 people acting like they had no warning and sending angry tweets when they try to upgrade and stuff needs to be tweaked to install/run. I guess just make sure you schedule time to port/upgrade things to the new version in case they are any gotchas.
Yep! The graphql video from react Europe talks about how they layered it all over existing systems, really neat stuff
I think the difference comes from the fact that the OP is getting real schooling, and is forced to work on it full time. Also, while sites like Codecademy and Khan Academy teach the fundamentals of programming (e.g. variables, conditionals), they do a *very* poor job of preparing you to produce your own code or product. Having a solid foundation to build from is great, but if they're not going to tell you how to build an entire project, they're doing nothing more than covering the very early basics of a computer science curriculum. People love to talk shit about jQuery, but the reality is that it can help a complete novice create something functional very quickly and easily. Diving into the world of development through the eyes of jQuery may not help with the fundamentals (as is clearly portrayed by the OP's very messy code), but I would liken it to picking up a guitar for the first time and learning Metallica songs instead of Mary Had A Little Lamb or general music theory. You might not be able to name the notes or chords or scales that you're playing, but once you can play Metallica, playing Nirvana covers convincingly becomes incredibly easy.
Yeah, you're totally right. I more meant that they're not dragging their feet with new tech, but that wasn't clear. They really care about finding the best solutions, which is rare these days. 
If you're still taking on some refactoring requests, here are a couple snippets. They should be pretty easy, but I'm lazy. http://pastebin.com/uT7EPgM6 http://pastebin.com/Bc641JuR Let me know if you need more context. 
 &gt; NaN == NaN false Checks out.
To be fair, they say they compared backbone+jQuery vs React. That's not exactly exhausting all options...
The dev loading process has never been a problem for me, and I've been working on a long-term large SPA (hundreds of files). In fact, I prefer the dynamic loading, because it means I don't have to re-build a concatenated script + sourcemap every time I make a minor tweak. If your modules require all of their dependencies, there are very few instances where you will run into differences between dev (unoptimized) and built (optimized) behaviors. A good strategy (for me) has been to run unoptimized in dev, optimized+sourcemaps in QA, and optimized+no sourcemaps in staging and production (to preserve license comments). Assuming you've got a decent QA process, and possibly automated functional / integration testing, that difference will be caught long before you get to production. Browserify and webpack both have watch processes and incremental builds, but they encourage you to use npm. Unfortunately, some clients legal departments simply don't have time to review 600-2000 licenses for every. single. dependency installed via npm. I love small modules, but finding out that a dependency of a dependency is using a release of a dependency whose author forgot to include a license is an absolute showstopper, and keeping track of all of that simply isn't worth the overhead. Your experience and needs may, of course, vary, but sometimes it's so much simpler to go with require.js + bower, so you have actual control over what code goes into your application.
&gt; return dragula.apply(this, atoa(arguments)).on(...) There is no need to convert `arguments` to an actual array via your little helper function. `Function.prototype.apply` works fine with array-like objects like `arguments` or DOM collections. (You also forgot a ");" at the end of that `return` statement.) I assumed this was about ES6 modules. I'm kinda disappointed.
I was referring to the specific scenario where the browser loads each js file individually via AMD in development as a separate HTTP request. It very quickly saturates the browsers 6 concurrent connection limit and bottlenecks the dev environment workflow.
You don't need to upgrade though. If it isn't budgeted for by management then you can't. Its not like .10 and .12 are end-of-life or something. They will still work fine.
I agree that being able to work without jQuery is a huge plus and having more small single-purpose libraries is beneficial. However, jQuery provides a promise of being well-tested across browsers and devices, and it's difficult to reach the same level of confidence with a large number of smaller libraries that use the browser APIs directly. Also, while there is a need for plain JS modules, many developers aren't familiar with the native API and wouldn't be able to write a library without it.
You're checking for `items[i+1].name != undefined` but what you should check is that you have a next item (`items[i+1] != undefined`) or stop the index `i` before ( `i &lt; items.length -1` ). In any case, I'm not really sure you have your algorithm correctly fleshed out. Are you aware that you're only removing duplicates that are next to each other?
What you're asking doesn't seem to make sense. CoffeeScript is a language that compiles to JavaScript but is essentially just some syntactic sugar over JavaScript. jQuery is a JavaScript library written in JavaScript. &gt; would it be possible to write jQuery code and export it to vanilla? You can call jQuery functions from JavaScript or from CoffeeScript. I'm not sure what you're trying to do.
Removing duplicates is easy with ES6: &gt; [...new Set([1, 2, 1, 4, 2, 1, 3])] [1, 2, 4, 3] If you can't use Set, you can just sort it and then just iterate over it and check if the current item is the same as the previous one. var a = [1, 2, 1, 4, 2, 1, 3] var prev = null; var u = a.concat().sort().filter(function (i) { // Edit: You can skip sort, see RReverser's comment below if(i !== prev) { prev = i; return true; } }); console.log(u); // [1, 2, 3, 4] Something like that.
I am. This is working off of an API that's pulling filtered and sorted results (thankfully). I changed the For loop. I don't get an error now but it only pushes one out of what should be two object results from the array. for (var i = 0; i &lt; $scope.allVersions.length - 1; i++) { if(typeof $scope.allVersions[i + 1] != 'undefined' &amp;&amp; $scope.allVersions[i+ 1].name !== $scope.allVersions[i].name) { $scope.filteredVersionsByName.push($scope.allVersions[i]); } }
Interesting. Never heard of or used sets before.. looking at them.
Cool, but it's sort of unreadable. Constructing a bunch of objects instead of using actual mathematics is confusing. Why not develop a [shunting yard](https://en.wikipedia.org/wiki/Shunting-yard_algorithm) parser on top of this?
Right, and all software should have an upgrade plan. The software industry is all too familiar with what happens when products are not updated. Ergo, that upgrade will happen soon or not at all.
maybe if you use emmet livestyler it will export the changes
&gt; Object.create is inheritance incarnate Not really. `var o = Object.create(null);` gives you an object with no properties. That's even less inheritance than `var o = {};`
I think he's saying that you're not using HTML to reinforce your semantics but relying on class name alone. That gives a lot to be desired. HTML has natural semantics built into the language and helps provide context for devices other than the browser (i.e. screen readers, braile devices, etc.,.) By making everything a div/span with a class you lose those cues along with the natural structure and hierarchy of the document (i.e. section, header, article, paragraph...)
Note: I used concat there to create a copy of that array since sort is in-place (i.e. it modifies the original array). If you're fine with modifying the order of the original, you can skip concat. However, if you put it into its own function, you shouldn't omit concat since changing the order of the input array would be rather bizarre side-effect.
Can we just make NAN be the official native API for node instead of a 3rd party module?
Yes, the second problem in your algorithm is that the last item never gets in the results. I thought you might see why this happens. Anyway, you're better off following /u/x-skeww advice below.
I don't get the jQuery hate. It's a wonderful toolset and only if you plan to use such a small component in isolation it can be considered too much overhead. But a full app, consisting of many small components, can benefit hugely from all the plumbing jq provides.
Ah, good idea. :)
Typescript is javascript, and can compile to es5 or es6 .
Consider suicide. **EDIT:** In all honesty though, **debugger** seems like something I'd start using a lot. That and using developer tools in browsers to go through code line-by-line if it isn't asynchronous as all hell.
I think you don't really understand what jQuery is. jQuery is merely a convenient wrapper around several JavaScript APIs like the Selectors API or the XMLHTTPRequest API. jQuery calls the same functions under the hood that you can call directly. This has nothing to do with CoffeeScript. You can write your own little utility functions to select DOM elements. var divs = $("div"); could be implemented like so: function $(selectors) { return document.querySelectorAll(selectors); } Boom, you have your own jQuery-like selector functions. Granted, jQuery gives you a lot more, but nothing's stopping you from extending this function any way you see fit.
Throw it away. Code written without testing in mind is typically garbage and spaghetti. Start fresh with tests first, looking at the choices made in the old project.
jQuery (AJAX calls) + Backbone (data bound HTML templates) + topcoat.io (css) is simple and a good place to start. Don't use routing unless the app will become moderate size. It's unneeded complexity. A blog doesn't need that level of complexity.
That's definitely a valid point you make. I'm not against ES2015 classes btw! I just think it's good to understand the underlying techniques before using them. That being said, Object.create does have a use in my opinion, but it's difficult to compare to class oriented programming. The best read about it is by Kyle Simpson, especially this chapter, in which he gives a thorough example on Object.create, and makes a very good comparison: https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/ch6.md
Node.js a browser web site: jsfiddle.net 
The performance benefits are not that huge. It depends on the size of your resources. One solution does not fit all. 
I haven't actually done interviews with people going over github repos, but if I had to go through them with you, I'd ask _some_ of the following questions. Which ones would depend on how bad/good of a mood I had... ;p Nah, actually it would depend on the position. I gather is an entry level position, right? So maybe some of the questions are too harsh... 0. Questions common to all projects: What's this about? What's interesting about this project? What did you struggle with? What parts are you not satisfied with? Why isn't there any documentation? Could you get a demo running? Rock, Paper Scissors: 1. [Lines 65 &amp; 90 in rockpaperscissors.js](https://github.com/kotojo/wdi-fundamentals-rps/blob/student/app/js/rockpaperscissors.js#L65). You have `playToFive` and `playToX` functions. Explain why I'm asking you about this. 2. [Line 75 &amp; 76 in rockpaperscissors.js](https://github.com/kotojo/wdi-fundamentals-rps/blob/student/app/js/rockpaperscissors.js#L75): getWinner(playerMove, computerMove); var winner = getWinner(playerMove, computerMove); Why the two calls? 3. [Line 43 to 61 in rockpaperscissors.js](https://github.com/kotojo/wdi-fundamentals-rps/blob/student/app/js/rockpaperscissors.js#L43): rewrite this function with less repetition. Smoothies (there's not much in this... no doc, no explanation, no js... So, only one question): 1. [Line 5 in index.html](https://github.com/kotojo/smoothies/blob/master/index.html#L5): Why so? What happens if you don't do what the comment says? Meta-tic-tac-toe (not much info here either... hmm...): 1. [Tests! Ooouh :(](https://github.com/kotojo/Meta-Tic-Tac-Toe/tree/master/test): What happend? 2. [Line 34 in main.js](https://github.com/kotojo/Meta-Tic-Tac-Toe/blob/master/app/scripts/main.js#L34): Tell me about recursion. Tell me why you used it here. 3. [inside and outside in main.js](https://github.com/kotojo/Meta-Tic-Tac-Toe/blob/master/app/scripts/main.js#L163): What's this about? Piece a PC: This one does have at least a readme file, but it doesn't seem to have anything interesting in the frontend part (i.e. just Bootstrap). I won't comment on this because I don't know if this is relevant to the position you're applying to or not. In any case it looks like a pretty standard Rails tutorial project. The rest are angularJS projects. Judging from a quick first look, the code is much cleaner here than in the non-angular projects. This might make me suspicious or at least it might make me ask you about this.
It's just a library. It's as plain as using the DOM APIs directly. The only different between code which uses jQuery and code which uses the DOM APIs directly is that the former has a ~30 KB dependency. What you get in return for those 30 KB is a nicer API and better browser compatibility. Modern browsers aren't nearly as bad as IE6-IE8, but some things are still really cumbersome and the APIs which try to address those issues have spotty support. E.g. Element.matches or Element.classList.
You really need to consider your read/write access to this thing before you choose how to do it. Will you populate this list once, then check for duplicates and you're done ? Or will you be adding and removing elements while all the while trying to maintain the uniqueness ? I ask because perhaps you actually want to store this in a more traditional set, and then only convert to a list if you have to on read. 
Do it in the server.
Why do they have to be different pages? 
As nice as it would be sometimes, that's rarely an option.
It breaks modular definitions. The library and its plugins intentionally inject themselves into the global namespace, `window.jQuery` and properly importing them into your modular application is a huge pain in the ass -- a common solution is to break modular definition and allow globals to creep into your module. Furthermore, it's a monolith library, where a lot of the code will get unused and yet still loaded on to the client's browser. Using massive libraries on the client bloats the codebase, slows load times, and is ultimately not very efficient, most of which is actually unnecessary. Also, it's the mentality of someone who only uses jquery that can be grossly misguided. Speaking from experience, I used to use jquery as a crutch, it would be the first library I load into any project, even if all I was doing was _simple_ DOM manipulation. To me, if all you're using jquery for is to select on class names, $.ajax, $.extend, or event handling, then you should just go vanilla and save yourself the bloat. Having said that, I still use jQuery in production, but more modular drop in replacement libraries are starting to be built, such as https://github.com/webpro/DOMtastic 
&gt; Also, while there is a need for plain JS modules, many developers aren't familiar with the native API and wouldn't be able to write a library without it. Developers should use whatever tool is necessary to get the job done, because at the end of the day, that's what we are paid to do. But when someone wants to master javascript, follow best practices, to be able to weigh the pros and cons of any library used in production, using one library as a crutch is only going restrict their potential.
&gt; you don't need to know about Function.prototype.apply But they are using `apply` in that very line. I'd also argue that `bind`, `call`, and `apply` are bits of the standard lib you really should know. For one, they are very important and secondly, they make for *very* confusing code. So, this is really something you should be 100% certain about. Otherwise, you'll have trouble taking this kind of confusing-looking code apart. I do agree that array vs array-like is a rather small implementation detail and that this pointless no-op doesn't actually hurt. It's a very minor mostly cosmetic issue.
The point is to maintain the symbolic representation of the mathematics. Of course if you don't care about that then this isn't the right tool for math; might as well stick with the primitives and the Math object.
I don't think you understand what jQuery is entirely. It is simply a javascript library. You *are* writing in JavaScript, there is no pre/post-processing. You should know how to perform the actions that jQuery makes simple, but without the aid of the library. If you can't do this, then you shouldn't be using the library. For example, selecting an element: //jQuery $('.selector'); //Without jQuery document.querySelectorAll('.selector'); If you want things like `hide()` and `show()`, extend the object to include a function like: function hide() { this.style.display = 'none'; } If you miss the `$.forEach()`, try using the actual JavaScript `Array.forEach()` function. If you don't already have a node list, but instead an html element collection, try `Array.from($elementList)` where `$elementList` is your elements. You don't need jQuery, but it can in some cases speed up the development process. Though, **by no means** should you *only* know how to use jQuery.
Mathematics *is* symbolic.
Ah! The reddit phrase for "I don't know how to code so do it for me!"
Thanks, perfect timing, this is exactly what I need right now. Started googling for similar solutions earlier today, tried so far: - https://github.com/fivesixty/quickdiff : Often replaced unnecessary nodes - https://github.com/kof/diff-renderer : Had problems with some kind of attributes (eg. checked, disabled) and html comments - Now switched to Morphdom and no problems yet. Also 2-3x faster than diff-render and almost 3x smaller
Ah! The dhdfdh phrase for "I think I'm really intelligent, but I'm not, that's why I have to be a condescending dick on Reddit, to make me feel better about myself!"
Is the version of V8 that will ship with 4.0 known (or guessable) at this point? Hoping those sweet, sweet ES6 arrow functions will make the cut.
Are you already batching your requests? I dunno what webserver you're using but I often use this in Angular: https://github.com/jonsamwell/angular-http-batcher
Awesome! I've been building a framework for a long while that's component-based and somewhat similar to React -- but it uses real DOM. This could be really cool to incorporate! Thanks! :) 
Sounds like a classic [XY problem](http://meta.stackexchange.com/a/66378).
Ah! The typical reddit response when one is caught without an answer. Here's the thing. I already feel great about myself. I just slap my forehead when I read the comments on this place as I scan for links to the rare thoughtful article. Then I see comments like yours that are so outrageous that you meet my one failing, the inability to call a farcical idiot for what he is.
&gt; You really think Nicolas Bevacqua (who is a published JS author) doesn't know about bind/call/apply? Given that I referred to the author with the gender-neutral "they", I apparently didn't bother to figure out who wrote it. It also doesn't matter. It doesn't change anything. You don't have to convert that array-like to array if you hand it to a function which would have been fine with an array-like. That step isn't necessary. &gt; The point is not to be ignorant of everything Heh. Yea, you mean like `apply` doesn't need an actual array? &gt; and just use packages Or, y'know, language features. ES6 got this covered. You don't have to use `apply` in the first place. Spread would work. No point in using a library for this.
1. Make a component that can render as one of two types of elements based on attributes passed in WITHOUT using multiple returns or css-based hiding in your render function. For example, a 'TextInput' component that is either a text input element or a textarea element depending on the truthiness of a 'multiline' attribute. 2. Create a component that takes a list of data, and a 'template function' and renders the list as one li per datum in the list, contained by an ul element, where each li's content is the result of the datum passed to the template function. Now do the same in two dimensions as a table. Now change it so the component accepts the generated tr and td elements as children, yet generates the table head internally. Now accept the tr and td elements as attributes. 3. Create a component that systematically wraps every child in a div with a different color. Create a component that assumes that the first child is the panel title (a complex element, not just some text), and the second element is the panel body. Think bootstrap's panel. 4. Implement a component where the state contains a list and two level deep object, which are displayed via the render. Have buttons that change the deep state when clicked, and make sure the data is reflected in the render. Now add the PureRenderMixin and get it to work again without forcing an update when changing the values. (Hint: use functional style concepts) 5. Using react's standard features, no animation libraries, create a component that contains many colored boxes in a grid. When any box is clicked, change the color of the boxes in a ripple pattern outward from the clicked box. (You will have to either use requestAnimationFrame or additively precompute a transition style to every box.) All of these are difficult or impractical (impossible?) using a traditional template-based framework.
I agree with your comment but on point #2 he's doing this to convert a truthy value to a Boolean value. You probably know this already, but the ! sign closest to the variable converts it to the opposite Boolean value, so that "hello" becomes false for example. The first ! sign furthest from the variable inverts the Boolean value again. To address your point, he doesn't need to convert the truthy value because it's within an if statement. If he were returning a value then he may want it to be absolutely true or false, in which case this trick is nice.
Start writing tests using the code that you have. They're characterization tests. 
I'd say there's about a 100% possibility you're going about this in the wrong way. I have never seen such a use case in which websockets wasn't the obvious (and only) choice. To me, this reads a bit like: &gt;So for personal reasons, I want to dig a hole with a depth of 50 meters and a diameter of 30 centimetres. It's not that I run out of dirt and my shovel works fine but somehow it just seems like my arms can't reach any further after reaching a depth of about a meter. How do I get longer arms?
&gt; Crockford, the man who created Object.create, has disavowed its use. He's brilliant, but he's also one of the most nitpicky programmers I've ever seen. He stopped using `new` for `Object.create`, then stopped using either because he decided that Objects should only be created via closures, and as such, didn't need `this` anymore. He also dislikes generators, thinks we should all use `undefined` instead of `null` and thinks that `for` statements aren't necessary any more. Immense contributions or not, he's in an ENORMOUS minority in the direction he believes Javascript should go. Which is good, because his Javascript looks awful. 
If your project is command line driven I have started a project to help with unit testing from the command line: https://github.com/prettydiff/cliTester
I'm doing it in person right now, so I can't speak about the quality of the online program, but Jeff actually gave my class a lecture yesterday, and I found him very energetic &amp; engaging. I just looked into it, and I think this is what you're looking for: https://generalassemb.ly/education/web-development-immersive/boston I'm doing that Web Immersive program right now, and while it's fairly pricey, I've found it worth the price so far. You should give them a call and see if you can get a tour of their campus! I had a really good experience meeting with a recruiter, actually. Fair warning, you might find the first week or so a little slow since it won't ALL be new for you, but the course goes over a lot of languages and is full-stack, which I personally was daunted about learning independently. I don't want to make any big life decisions for you, but I do encourage you to check it out!
Ok everyone here has a "nuke it from orbit" attitude. Let's get real. Is the code at least set up well? Is any sort of framework or methodology followed? (MVC/MVVM/MVP/etc) If not, start there. Separate the pieces out into those modules. Create a folder/file structure that mimics your app. Create tests for the existence of classes. As you build new features, build new tests. As you refactor old features, insist on tests. Create tech debt tickets for sections that are higher priority or that are about to have features added. Leave your router(s) for last. You already know if it(they) are working. Overall, don't give up. And don't let anyone tell you it's not worth it. 
It's *logic*.
It's a cute little library, I'm not sure where I would use it, but good work nonetheless. My only gripe is the lack of comments in your code, always comment your code!
That's a stylistic decision. eslinter is quite comfortable with ES6 classes, since the context is quite clear. If you want to save keystrokes and improve code readability just use PyJS. Besides, IMHO `this` greatly increases code readability since I can easily tell the scope the variable is in. 
I agree with the first sentence but not the second. &gt; It's good form to use it this way, too. why? if (!!foo &amp;&amp; foo.bar()) {} has no difference in behavior from if (foo &amp;&amp; foo.bar()) {} The former is just having `!!` do the coercion instead of `&amp;&amp;`
I wouldn't alter String's prototype, but that's just me.
What's the !! do? Force it to be evaluated as True or False and not just Truthy or Falsey? What's the case that's trying to be avoided here? Disregard. I see it's talked about in another comment.
Right now all state mutations are pushed to the server. Eventually I expect that I will need to have a client-side store that will merge in the server-side one. Not sure how that looks at the moment. I consider it a premature optimization at this point. 
Carry on with my normal job in consulting 
&gt; Code written without testing in mind is typically garbage and spaghetti. We can tell by his comment that he's most likely not a real developer. There'd almost never be a situation where just throwing away the code base would make sense.
I've been curious about it for a while, I like the direction that the project's moving in
NAN really shouldn't be necessary. It's just a facade over the V8 API. Instead, Google should just stop breaking compatibility in V8, or include shims. Sometimes they even do breaking changes to the API in *minor* releases 
The documentation is fantastic. Great work! I've been really confused about which Flux (or Flux-ish) library to use for personal projects, because there's so many of them. A lot of the libraries were really heavy and so I just went with vanilla Flux. Redux looks really promising - it's extremely lightweight and has a bunch of good ideas. I'm looking forward to trying it out :) 
Another typical reddit response. Learn to code, kid. Your "but it's too hard and I don't want to think" will get you know where as well as your lame ass excuses. Quit being a pretender and grow up. Be a man and quit your crying. If you have to use other people's code to get your work done, why are they paying you? There are so many babies on reddit it makes me sick.
Mixed feelings on this. On one hand, having reusable modules with as few dependencies as possible is great. This is especially true when the module unnecessarily pulls in other modules, like the jQuery cookie plugin used to (why should a cookie parser require jQuery?!). Utility methods are definitely things that should be small, light, and self-contained. On the other hand, reinventing the wheel all the time is not really ideal. A lot of libraries do DOM manipulation for example. Having a dependency on another library that handles the DOM (such as jQuery or React) is fine if your app is already using that library, and helps reduce the amount of code that needs to be written for the module (and thus the amount of code that needs to be maintained, and the number of bugs). Too many people think their code absolutely must depend on jQuery. I used to take jQuery plugins and rewrite them so they could be used without jQuery. Usually the rewrite was not significantly bigger than the original, and it removed a giant dependency. 
guys this is my first article and I'm not native english speaker, I tried to focus in people with zero knowledge in functional programming and keep the explanation simple and avoiding complex terminology, hope you enjoy it and please let me know if it requires any fixes, thanks!.
I've used Redux for about 2 months now in a new app that has server rendering, real-time updates, and client side caching, and it's been a pleasure to work with. Having used Flux since it was announced, I can say confidently that Redux is a major step forward for me. The "Thanks" section in the docs is a goods starting place for exploring the ideas behind it. Things I like about it - - tiny amount of code - not coupled to React - pure reducers and actions, which are incredibly easy to reason about and test - encourages all of your components to use an optimized `shouldComponentUpdate`, which is a huge perf win (and it's an enforced behavior for "smart" components) - lots of potentially awesome stuff falls out of the architecture - see the [dev tools](https://github.com/gaearon/redux-devtools) for a good example
&gt; INSUFFICIENT DATA FOR MEANINGFUL ANSWER. Incomplete means, almost certainly, undocumented and untrustworthy. First off, how much was even done? The parameters of your hypothetical allow for a few lines of code to qualify as the remnants of the project's first attempt, so technically the answer might be completely evident the moment you open the first js file. If there's anything substantial to work with, identifying any useful and complete components would be a good approach, maybe, depending on the quality of the work. Then again, if the person bailed halfway, they might very well have realized they were in way over their heads, in which case their code might be completely useless. In other words, why try to carve a beautiful table out of some hacked up beach logs when you can go to the hardware store or lumber yard and start with some quality materials which you can almost certainly rely upon?
Websockets or Socket.io would have this issue fixed in less than hour, if even that. That said, why even ask if you don't want the best advice? There's a reason that the advent of websockets coincides with a wave of flashy new real-time features everywhere. This is exactly what it was built for, and frankly, it would be infinitely easier to pull off. It'd literally be as simple as an "change" event emitting the update when needed instead of just spamming requests like you're experimenting with your first DoS attack. If you want it in near real-time, you need to use websockets. Otherwise, you need to dramatically re-engineer this solution to have the heavy lifting done server-side with the client script only referencing the all of the updates in one request on a more reasonable update loop. If these aren't your sites, you need to use a headless solution like Phantomjs to scrape these sites and update from your server. There are really a ton of ways for you to do this that are much more efficient and much more battle-tested, and you're ignoring it all to try to pull off something you have already called "impossible" yourself. There's a reason the limits are in place. Take their advice.
Troll elsewhere, idiot. 
you got it though, exactly.
I just skimmed the documentation and it's incredibly well written. The ideas being the project blew my mind a little. I can't wait to gradually implement this for our current app that has way too many flux stores and way too much boilerplate. 
My advice is to leave things better than you found them. When you pick up someone elses code, it's natural to think it all sucks since you weren't there when it was written and it's hard to be sympathetic without understanding the history of it. Often times it does suck, but don't assume it's because the person before you was stupid or anything. In many cases they would tell you themselves that it sucked, and that may have contributed to them leaving. The conditions and situation, time constraints, management priorities, laziness of developer, team culture etc often get reflected in the code. But now you own it. So just OWN it and don't complain about how bad it is (not accusing you...just saying it's a common occurrence). Every time you think something sucks, file a task to improve it. And pick up these tasks bit by bit until you have a hard time finding them. Don't use the fact that your predecessor had poor engineering principles become and excuse for you having poor engineering principles. You mentioned lack of unit tests. Did you file a task to add unit tests? Maybe file several progressive tasks: 1) setup basic unit test infrastructure 2) write a few dozen tests 3) setup code coverage reporting infrastructure 4) get to 50% coverage 5) get to 75% coverage 6) get to 90% coverage 7) get to 100% coverage (because fuck it, you're that good) By writing the tests you will both learn the code and fix your main complaint about the state you found the code in. If/when you leave the next guy won't have that complaint.
https://www.reddit.com/r/javascript/comments/3fpis9/creating_a_clock_with_setinterval/
They should at least take a better approach with deprecating the APIs, and put more thought into the original design rather than constantly breaking it. I don't know any other library that has breaking changes as frequently as V8 does.
... what the? How have I never seen this before? It's not often I learn something new about JS, I'd give you 100 upvotes if I could ;) [edit] and hey, it's fairly uniform! http://codepen.io/zyklus/pen/RPOmXJ
I am probably going to use redux on my next project in a few weeks. Do you initiate your websocket connections as middleware or do you have it exist outside and dispatch events that then get picked up for the state? 
Refactoring this slightly, let's say you have: function bar(){ return "sad face"; } Now I assign that to a variable instead, keep adding code: var myFn = function bar(){ return "sad face"; } // some comments // yada yada (function(){ // ... })(); // Uncaught TypeError: (intermediate value)(intermediate value)(...) is not a function Especially during the variable assignment of an _existing_ function, it's extremely easy to forget the semi-colon. And the error message -- wtf?!? The fact that the error can be dozens or hundreds of lines away from the cause can be a huge pain point. I'm pretty sure everyone would first check the contents of the function to figure out what's going on, and only after eventually ruling that out realize the issue. I've literally had to comment out 500 lines of code before before I realized what was going on.
DONT STASH DATA IN THE DOM
Nice! &lt;3 Redux
* add tests to critical parts
But can someone explain what you would use Redux for? How does Redux impose a strict ordering of changes on the state? (I'm familiar with Clojure and its immutable data structures. This sounds related.) 
Same goes for node_modules, commit your package.json, leave out node_modules.
A couple of small/medium details, not yet mentioned by others... - Naming is hard, but the effort really pays off. You have this `lightbox.box` property with a name that really doesn't mean anything at all, `box`. It's looks like a pseudo-id set into the `class` attribute to use as identifying selector. The name `box` does not give any hints on its purpose at all. - I see a problem with `lightbox.target`. Actually, two problems. The first problem is that you have coupled yourself to a particular HTML structure unnecessarily. You've tied yourself to an HTML like this `&lt;article&gt;...&lt;a&gt;&lt;img/&gt;&lt;/a&gt;...&lt;/article&gt;`. This is, of course, your current HTML structure. But this is something that can (and will) trivially change. You will want to put a lightbox on an image which is not in the article but in a sidebar or someplace else. Or maybe you will want to add a lightbox on a _text_ link. Clearly that `target` selector should be external to the lightbox itself (i.e. an argument). - The second problem with `lightbox.target` is line 23 (`$('article').on('click', 'img', lightbox.show);`. And the problem here is that you've accidentally split the same value (`target`) into two pieces. Let's say I did want to use a lightbox outside of an `&lt;article&gt;`. I naively go and change the `lightbox.target` selector and think I'm done. But, alas, it won't work. Clearly, the selectors on line 23 and the value of `lightbox.target` are directly related. One should be derived from the other. 
Is there a preview somewhere? Maybe a sample chapter or something?
All documentation and examples seem to be in ES6. How do I go about learning how to use this in current browsers?
I just read about Babel. Is this the "standard" atm?
http://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/ String.prototype.foo = 'bar'; for(var c in 'abc') { console.log(c); // 0 1 2 foo }
I see now why it can be a problem. Isn't using "foo in bar" itself also frowned upon in favour of .each or other higher level array functions?
Since I don't know ES6 I find it hard to translate the example code into ES5
Well Angular is built on jQuery. So if you do learn Angular you should already know jQuery for maximum effectiveness. edit: Yes, I realize angular's minimum dependency is on the minimal jqLite library, but the jqLite API is the same as jQuery's. My point is if you want to write directives that do DOM manipulation in angular (and any non-trivial app will require you do this) then you should know that API.
Neat.
Angular (and frameworks like it) are definitely the way the web is going moving forward -- and with server-side template rendering and the likes, there is no SEO impact. Using Angular, Ember, or React does open your site up to being used as an offline app, and opens up loads of new interactive options!
That's pretty good feedback, but for my own site at least I do not have any plan to expand it outside of articles. I can (and will, probably tonight) take steps to decouple this for future portability. I'll likely give it a selector to watch for clicks. 
&gt; I see nothing wrong with your last example. That's inherently different from sticking HTML in the middle of your JavaScript. In fact, you and I are in complete agreement here. It's the arbitrary placement of markup in application code that I take issue with. I see your bet and increase, we should also stick Styles into javascript. Because our current method is not separation of concerns, it is separation of technologies. React views gives you a strong individual modular and testable components, you do not have to dig through 3 different files to work on some feature. Just find its component file, and do your changes on that single file. 
&gt; That's a common misconception about this. this has a dynamic scope in JavaScript, it's bound to the parent object or function. That's because `this` is a context, not a scope. But I'm not sure why you are telling me that. This conversation is specifically about using `this` in the context of an class, so unless you are going to have a call back as a method of a class (why?) `this` will always have the object context.
&gt; Generators are immensely complicated for a language like JavaScript. I can guarantee you that only a very small minority of JavaScript programmers will ever truly understand what they do. Being hard to understand is an insane reason to avoid putting something into a language. Yes, generators aren't easy to understand, but they are extremely valuable. &gt; for statements are much less necessary when you have forEach, map, etc. I don't believe he ruled it out altogether, though. Every language has access to similar control structures, and yet, I still find myself using a for loop. &gt; but if the creator of Object.create disavows his own work, then there's probably something there. He didn't disavow it, he decided it wasn't necessary since closures solve all problems and avoiding context was the real answer. So he simply prefers closures over classical and prototypal inheritance. I'm not saying that's horrible, I'm saying that not very many people happen to agree with him.
Try look at some posts at /r/adultgamedev
Whoa, I wrote the first one. It was designed for updating a markdown preview, where you'd expect changes to be localised to one area, it'd be pretty bad for general DOM patching. There weren't many options around when I wrote it. I'll update the repo to point to morphdom I think.
Does anyone have the answer to the "my name is rex, Woof?" question?
For your next project I highly recommend setting up a CI system that runs all tests upon merge into master. It can email you, the offender, and their manager if the build goes red. That way if/when you hand it off to another department it won't rot. If you make the CI fail if &lt;100% coverage then you are good to go. It never turns to shit while you aren't looking.
In an isolated codebase, it's _tolerable_, but barely. In a library, it's flat out forbidden because it can conflict and prevents _ever_ modifying the API or interface. Let's say you have a library that adds `Array.prototype.foo` which does whatever. Great. Now you publish it to npm, patch some bugs, yada yada. Now you decide that it's useful for that function to return something: Array.prototype.foo = function(){ // do something to the array return this; } Guess what? You _can't do this safely, ever_. Why? Because you published version 0.1 that didn't have this functionality. So if your npm include structure looks like: - module - your lib v0.1 - another module - your lib v0.2 And your basic code is: if( !Array.prototype.foo ){ Array.protoype.foo = function(){ ... } } You have _no idea_ which one is loaded first. So you can't count on your function returning anything. Further, let's say browser vendors like your idea and 5 years from now decide to implement it. Guess what, _your_ `Array.prototype.foo` probably won't perfectly match with what the Vendor implements, and now _all your code breaks_. Or let's say some other library that you've never heard of implements a function with the same name that acts _completely differently_. Now what? ## Polyfills Polyfills are an isolated use case. Your code is _only_ hit in a situation where you know you're on an older browser, and you're adding _globally agreed upon functionality_. The only caveat here -- Make _damn sure_ you're polyfilling according to spec. _Never_ write a partial polyfill "because I don't need the other functionality" because some other library that you include might. tl;dr -- It flat out prevents code isolation
They've coupled themselves to a jquery which could reasonably be replaced by zepto or another implementation. Or even their own implementation. That's cohesion. Your suggesting complete coupling. What benefit do you see? It's not 'coding style'. You are presenting a very different architecture and one that has a big downside.
Thank you for being the first to actually post something useful
Yes TypeScript. I went there for large projects and will never willingly go back.
TIL
why not post it here? i'd like to see it
*curiosity intensifies*
At Crypti your application can run decentralized, making it a "decentralized application" aka "dapp". It might not be the best choice for you right now, but take a look. You might want to code your next app for Crypti. ;)
Do you store a reference to your websocket in the state? How do you determine if the websocket connection exists? A global variable? 
Oh baby gonna play around with this
jQuery is a convenient set of DOM manipulators and some other nice stuff wrapped up in a cohesive syntax. Angular is this quasi-scaffolding thing I'd best describe as a front end manager. They're completely different, but can be used to achieve the same ends. 
When you're writing C, you're relying on operating system standard libraries available on the operating system and the C standard. These work with system internals, IO, etc. throughout a wide range of interfaces to a wide range of systems. What these people are talking about is needing jQuery to interface to one standard on one system (the internet) that occasionally varies from browser to browser but more often not. On top of that, many can no longer write code without jQuery and think jQuery **is** javascript. With C, continuing with that example, you can write your own standard library, modify it yourself, and any C programmer worth his salt knows how to do that if ever needed. Just like the oft asked question on reddit, "What do I need to build a web site?", is always met with "Learn jQuery and PHP and get a database" but 80% of them couldn't explain to you why you should only use PHP or why you need a database even for simple beginner sites. Lame. With a sprinkling of genius here and there, 80% of reddit is oh so lame.
Thanks for all the info. I was super busy after I posted this yesterday, but I just started cleaning up/making read me files for all my projects. One thing I definitely am working on now is testing. I didn't know anything about it during these projects, but I've spent the last two weeks learning jasmine and selenium. The angular projects definitely look suspicious from an outside prospective when I think about it, but it was literally just picking up on the learning curve. This stuff is all from a 12 week bootcamp that ended three weeks ago, and before that I didn't know anything about web development, so after the rails project the idea of how to organize and structure everything became a lot more familiar. Thanks for all the insight though, I'll be working on all of it!
I just updated that for all of them. No node_modules, or bower_components!
Just wrote some basic documentation on technologies and description, but I'm gonna be working on the rest today!
Thanks for all the info. I just pushed up what I've been working on with the kotojo.github.io page. It's not finished, but definitely a lot more than hello world. Do you think I should hide the repo until I'm completely done with it? FlashStack - Those commits are all by another guy working on the project, he just really likes to explain what he is doing (which is awesome), but I'll look at maybe shortening them. Meta-Tic-Tac-Toe - This was the first project I ever did that I put online, and am definitely aware it is a mess. I've been going back and worth deciding whether or not to go fix it, or use that time to keep learning new things. Thanks for all the info though!
Completely right! :D
I'm probably in the minority when it comes to this, but I like the method outlined here: http://toddmotto.com/data-js-selectors-enhancing-html5-development-by-separating-css-from-javascript/ of using data attributes for javascript interaction. Css classes and the dom can be easily changed on a whim, but the data-js attr should only touched by developers, and should work regardless of page structure.
I see what you mean, but to me these are theoretical issues that never actually pose any real problems. And it's just a 30KB (gzipped) download, so the size too is a bit of a non-issue. So from a pragmatic point of view I don't see the point of foregoing the ease of use and programmer happiness that jQuery brings. But I also have a similar opinion about React. Since I have zero issues with my browser's rendering speed when building apps the whole virtual dom thing doesn't solve any problem for me and all that's left is ugly new syntax and a conflation of concerns that severely undermines productivity. So maybe I am a bit conventional that way.
&gt;Trailing commas in function syntax &gt;Trailing commas in parameter and argument lists. var meow = function(cat1, cat2, ) {} Math.max(4, 2, 0, ); I know this is not a finalized set of features yet, but can somebody give me a use-case for this? It just feels like a relaxation of syntax rules, which will just cause headaches and fruitless debates.
I would learn vanilla JavaScript well first. That way you will be able to use jQuery, Angular or any other framework that you want/need to. To the specific question, I would learn the basics of jQuery first, you will need to know the basics of DOM manipulation for most things you work with.
I agree with you as well. My primary argument is to not use a library as a crutch and to weigh the pros and cons no matter how useful a library could eventually be.
Hello! I just started playing with Dedalus, it is really cool. Are you still updating / maintaining it? I might have a few questions...
I started a game a long time ago that has horses racing. [Repository is here.](https://github.com/agroff/HorseQuest) The relevant code for movement is [here](https://github.com/agroff/HorseQuest/blob/master/src/components/HorseMovement.js), I think. It's built on crafty.js so you may need to learn that if you want to re-use any of this. The game itself is super buggy right now and not very good JS overall, but if you want to just see the horse racing to see if it is what you're going for, you can clone the repo, serve the index file (I just use `php -S localhost:8080`) and then visit open it in a web browser. If you want to race, go to the yellow buildings on the right, otherwise, go to the white buildings. Hope it will be helpful. 
If they said you can use any language, use the one you like best. What they want to see is how you solve the problem. Doesn't sound like learning something new is a good idea now. With that said, I'm not sure what you mean by pure OO JS... The latest version of JS which was standardized recently has support for classes but to run that in browsers you need to use a "compiler" of sorts because I don't think any browser today supports all of the new standard. Babel seems to be the most popular compiler for that. Another alternative (among many) would be TypeScript which also supports classes as well as static and strong typing at compile time.
[hmm](http://starshipinanna.com/gallery/shot1-ts1434527918.jpg)
Any errors?
Did you compile the code yourself, or just visit the jfiddle link?
Check out this 2 part tutorial for developing a game like you want is Phaser, one of the popular game Dev frameworks. http://davidgoemans.com/blog/2015/04/game-dev-with-phaser-part-1-setting-up/
This sounds like a CSS issue. Try the data-width attribute. 
You can write Javascript right into your browser, if that's what you're asking. Just hit F12 and click on the "Console" tab. You could also get something like node.JS to execute javascript files in the command line.
Refactor it to TypeScript.
It's a Node Server that runs eval() on URL query strings.
It's valid ES6, which allows shorthand properties for functions and keys in objects. I actually use a variation of it a lot, e.g.: let value = getValue(); return {value}; is the same as: var value = getValue(); return {value: value}; Although I wouldn't necessarily call using JS objects "Object Oriented". Classes are more for OOP stuff.
&gt; In ECMAScript 6, a shorthand notation is available, so that the keyword "function" is no longer necessary. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer
&gt; var o = { wow() { console.log('oo') } } It's an ES6 short hand. You could call `o.wow()` after declaring that. He/she could have made it a lot more readable than that, though.
I'm on my phone so I can't go into details, but you can in fact use key frames in CSS to do transitions from one gradient to another
Gotcha. That makes sense. I'm definitely not that up to date on ES6. Still though, your code was much more readable than the code I was questioning 
Do you mean that you want to have an animated color cycle? Or that you want a horizontal hue spectrum, with the whole spectrum fading to black? ## Animating Gradient For the former, you can use CSS Gradients + CSS Animations to handle it completely within CSS (you can use JavaScript to make it dynamic, though that will be much harder if you are using CSS animations). You'll need to animate the `background-color` property, while laying a alpha-transparent gradient overtop. [An example is here.](http://jsfiddle.net/mc0uk8Lr/) .background { background-color: #FF0000; background-image: linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,1) 100%); animation: rainbow 10s infinite; } @keyframes rainbow { /* set your colors and when they should occur here */ 0%, 100% { background-color: #FF0000; } 16.66% { background-color: #FFFF00; } 33.33% { background-color: #00FF00; } 50% { background-color: #00FFFF; } 66.66% { background-color: #0000FF; } 83.33% { background-color: #FF00FF; } } ---- ## Static hue gradient For the latter, it can be done with just CSS Gradients + multiple backgrounds. First set up a vertical gradient that fades from `rgba(0, 0, 0, 0)` to `rgba(0, 0, 0, 1)`. Then set up a second, horizontal gradient as the second background that fades through your hues. Something like this would probably work (you'll need an autoprefixer to handle the vendor prefixes): background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 100%), linear-gradient(to right, rgba(255, 0, 0, 1) 0%, rgba(255, 255, 0, 1) 15%, rgba(0, 255, 0, 1) 30%, rgba(0, 255, 255, 1) 50%, rgba(0, 0, 255, 1) 65%, rgba(255, 0, 255, 1) 80%, rgba(255, 0, 0, 1) 100%); [Rainbow Demo](http://jsfiddle.net/3ag1kpg1/) ---- I also just found this great article that might be helpful: http://www.nixtu.info/2011/04/css-gradient-fun-rainbow-overlay.html 
So it turns out you can! Thanks for the correction.
Could be. The syntax itself is useful. The following two bits are (more or less) equivalent: var o = { wow: function() { console.log('oo'); } }; var o = { wow() { console.log('oo'); } }; Feels more natural with the `class` syntax than with a standard object, though.
Check out Michael Feathers book "Working effectively on Legacy Code" and his white paper for objectmentor which is freely available. To summarize his general legacy management strategy: * 1. Identify change points * 2. Find an inflection point * 3. Cover the inflection point a. Break external dependencies b. Break internal dependencies c. Write tests * 4. Make changes * 5. Refactor the covered code. HTH
(I just re-read what you wrote, sounds like it's obviously the animated one!)
It means you publish it for this decentralized platform written in node.js that nobody will ever use instead of a site.
You're on the right track: } else if(gas &gt; 60) { I really don't think you need anyone's help with this, I just think you're confused over some weird thing. It's a simple problem, you just add the cost below for the gas below 60 to the gas above 60.
&gt; It doesn't log anything, because "bar" looks like this Haha, I think this is my favorite example ever of why `with` is confusing
Maybe the parseInts were only there because the example was prompting for numbers, my bad, thought I'd play it safe and just put them wherever an equation was needed haha. Anyways, thanks for showing me the light Mr. Sr. Software Engineer at Google, much appreciated.
The best if you start here: http://reddit.com/r/Bitcoin You can also read Crypti's whitepaper: http://crypti.me/crypti.pdf
Yeah it didn't really explain that at all in my learning guide so thanks for clearing that up. And the code is returning the correct numbers, so hurrah.
I see it at Flashstack/server/.sass-cache 
Well to each their own. I don't see a problem with pulling stuff from github though, npm pulls packages from github as well. It's more than a package manager btw. It handles bundling, just like webpack. But better in my opinion. But that's just like, my opinion man.
I honestly don't see the point of React. The virtual dom is a non-feature that solves zero real world problems and all that is left is new, ugly syntax to learn and a conflation of concerns that kills programmer productivity. I wonder if they brought the same novel approach to the model layer (Relay) too. edit: wow, such downvotes. I guess that's what happens when you think for yourself. Much safer to go with the herd, right? So long dudes.
I'm productive with React and really like it. The JSX-syntax is pretty much html but with className instead of class. It is also excellent at separating concerns but others have written so much about it so if you disagree now then you will probably not change your mind.
What approach do you use to sync your data to the DOM?
I don't know why I am bothering to help you, most people end up hating me around here...but I'll tell you what I did. I thought I knew javascript pretty well until I started building single page apps. I took a week off (unpaid) and read 4 books a day. Its amazing how many books you can read in a day when you put your mind to something. I bought the top books on javascript that were written in the past 2 years and read them all. A few of them sucked, but I learned something from every one of them, and seeing the same material explained 10 different ways really helped me understand it. One limitation I put was the book had to be less than 200 pages. ES6 is the next version of javascript. Its still a ways out, but through transpiling you can start to build apps with it today. I wouldn't say these tools are production ready but there will be an explosion in a year or so in ES6 support (node 4, browser vendors, babeljs). I think its important to learn ES5 because that's where the jobs are right now...but you can also see ES6 and how easier things have become. As far as IDEs I would use WebStorm. It has a built in node debugger and is targeted at single page app developer....so there's a lot of support for javascript tooling. Node is just javascript on the server side. Just like PHP or Perl, but its javascript. This gave rise to the Full Stack Developer that is so trendy now because people think "oh javascript...lets make them write both FE and BE code and hire one person" (this is why people hate me around here). As for frameworks, you can always learn them....but I would spend some time with react, angular for now....perhaps aurelia down the road. Anyone who does FE and js these days will be in demand if they know these frameworks. 
lol, are you doing FE and BE - is that why people hate you? Ok I probably won't have time to read 4 books a day, which were the best ones? 
We use CanJS, which contains can.Model for the data layer. edit: oops I misread your question. CanJS has several options for automatically binding your data to you view (one way or two way). Very, very simple to do, puts the verbosity of e.g. Angular to shame.
npm optionally pulls from Github, normally you get packages from their repository. Pulling directly from Github doesn't really work well any more since a lot of libraries have a compilation step of some sort. You don't want to be running Babel on all your third party libraries every time you build your site. Packages on npm have usually been compiled to vanilla JavaScript so they're ready to use without being forced to add some build steps to your own site. Each to their own though. If jspm works well for your workflow, then that's great :) 
I've never used it...I think crockford says not to use it. I forget the reasoning. heard him talk about it....something about being errorprone and causing confusion and there was an easier way.
He is putting several classes in the same file which is not something that is done when you actually code for real. It is similar to putting all your Java or C# classes in the same file. What you see as separation of concerns the React-folks see as a separation of technologies. Let us take a shopping cart as an example: - If it is empty it will display a text. - If it has items it will show those items and a sum - It will have a button that can collapse/open the shopping cart With most libraries/frameworks the two first one will be in a template (even though it is loops/ifs, i.e. logic) and the last one will be in a different file somewhere. The difference in thought here is that with React you would think that these all belong to the same file as it is all concerning how the shopping cart is being presented. I can go into ShoppingCart.jsx and see everything about its presentation in one place. However there is still no business logic. I don't do any ajax requests or anything like that from the jsx-file. You don't have to like or use React but I disagree with it being "bad practice". 
I am used to putting all such related parts in a 'cart' component, which is represented by a folder, containing the necessary html/css/js files. Everything in one place, represented in its native format, bound together by CanJS's can.Component. Much more elegant, much easier to navigate, integrates well with other toolchains and pretty much zero learning curve. Also I can have different people working on the view vs the presentation logic. Good luck with that working with React. Or using slim/haml/jade/coffeescript/tyepscript or whatever preprocessor you like. Say goodbye to all of that because of React's weird syntax.
Really? Can you give an example? All the examples I have seen have been a static semitransparent gradient overlaid on a solid animated fill colour. As far as I'm aware you can't have for example a blue-&gt;red gradient animate smoothly into a yellow-&gt;green gradient.
Here's the talk by Resig involving the use of the with statement in Khan Academy, about 8 min 30 seconds in: https://www.youtube.com/watch?v=H4sSldXv_S4
jQuery basically exists because in-the-wild implementations of vanillaJS are so inconsistent and buggy across different browsers, and the DOM methods in ES3/5 were/are so limited and clunky. jQuery standardizes a lot of these apis as well as providing its own very convenient chainable method syntax. You could do the standardization yourself... But if you did, it'd probably end up looking a lot like what jQuery already does. As better functionality rolls out in newer browsers and you stop needing to support old buggy ones, some bits of jQuery may become less necessary. Though the chainable methods for dealing with DOM nodes remain a neat pattern (used by other libraries, like d3). I love ES6 Promises, for instance, but until they and fetch become supported in the versions of IE enough people use, jQuery's $.Deferred and $.ajax are powerful polyfills that work on all browsers, today.
You could just the lodash method, unique, which is for exactly this, then call it a day.
There's an example above using one color hex values in key frames. Just change background-color to your gradient code, and presto!
Does it render on the Fiddle page?
Do folks actually use `with()`?
Because bad things like [this](https://groups.google.com/a/chromium.org/d/msg/blink-dev/Aw4IheXVc3U/7WuuBNa9eOgJ) happen. &gt; Does anyone know whether the property "x" on Element.style was intentionally added? document.documentElement.style.x returns an empty string rather than undefined, breaking pages that use the DHTML Menu Builder (http://software.xfx.net/) and perhaps others. &gt; The error is there (http://software.xfx.net/menu/iexpmenu.js) - function ShowMenu2(mName, x, y, isc, hsimg, algn) { &gt; // skipped some lines with (Menu.style) { // with = trouble :( if (SM) display = "none"; // Here, "x" is the empty string (Menu.style.x), instead of the value of the "x" parameter left = FixPos(x, pri(width), pWH[0], 0) + "px"; top = FixPos(y, pri(height), pWH[1], 1) + "px"; } 
I'm in the same boat as OP, perhaps a little further along. That's a good list of books. I used to like PluralSight who do online training courses, but more recently I've been watching YouTube video tutorials, there are some really brilliant ones and fortunately they tend to be the higher rated ones. The good thing is you can scan through the video and get an idea if you're going to get on with it or not. I download them and watch them on the way to work. I'll add that in my experience, the best way to learn is to do. I usually start by trying to duplicate an existing application and then break the project down into steps. There are also sites like Plunker or JSFiddle which give you a very simple online environment to immediately get JS code running (with html and css). The frameworks I've focused on are: Angular Node KnockOut Three JQuery BootStrap Babylon And because I'm corporate I have Microsoft stuff in the stack like ASP.NET MVC, SignalR, Azure. One other tiny bit of advice, which I struggle to follow myself; It's hard to go from being an expert to being a beginner again. Your previous programming experience will provide you with insights and an almost insurmountable number of questions about "doing it right". It's ok to write bad code initially, just get stuff to work. You will refine it as you learn more. You don't have to go from 0-hero in one step. 
The virtual DOM does also have the benefit of allowing other targets than HTML, like in [React Native](https://facebook.github.io/react-native/) or [react-canvas](https://github.com/Flipboard/react-canvas). But really that could be accomplished with any templating system that split up its output from `state -&gt; HTML` to two stages of `state -&gt; IR` and `IR -&gt; HTML`. But yes in normal usage virtual DOM is just an implementation detail.
The point is that what KA does with `with` serves the particular purpose of watching what you're coding. You should not need it at all to simply run your code "in regular pages".
&gt;React is just Facebook's answer to Google's Angular, introduced with a lot of clever marketing so people now think it's something revolutionary. No, React is pretty cool in the way that it actually tried to do something different and bring in new ideas instead of doing yet another MVC-framework with data-binding. Like I said before you don't have to like it of course but others do and it is not because it comes from Facebook or because of buzz words. Declarative components that you compose together and uni-directional data flow makes it easier to reason about and debug in my opinion. 
Like almost all code exists? Like the operating system you use?
This one is all about context. What does **this** refer to in the calling context? When called as rex.bark(), **this** refers to the object rex, which has rex.name defined as 'rex', so all is well. The function setTimeout lives in the global scope, so when it calls rex.bark, the context of **this** refers to the global scope and this.name will be equal to whatever **name** is in the global scope. Try executing var name = 'fido'; before the example code. Then the second log will be 'my name is fido, Woof!'. var Dog = function (name) { this.name = name; }; Dog.prototype.bark = function () { console.log('my name is ' + this.name + ', Woof!'); }; var rex = new Dog('rex'); rex.bark(); setTimeout(function () { rex.bark(); }, 1000); You could also achieve the same effect with: setTimeout(rex.bark.bind(rex), 1000); But as others have mentioned, there are some problems with bind(), so I would stick to the lambda function.
Nah, I think it's good. It's just the vast majority of people seem to get as far as learning all the different drawing functions and then *choose* to spend *months* just drawing things with basic shapes instead of moving on to basic logic, loops, arrays, objects, and design pattens. It's a free course and the students get to choose what they do and when. For many it seems the only reason they look into the html/css course is because they want a way to showcase their drawing code without Khan's branding on it or they want to draw something that will get them banned. Which then leads to the question of "how do I run khan code outsid of khan?". Which leads me to looking up "with()" which leads to infinite articles saying it must never be used ever and it's deprecated and sometimes even "don't rely on this because the browsers are going to remove it soon". Which leads to my question here in /r/javascript.
`{{myScopeVariable}}` is _so_ verbose.
Which to me, still, feels like a failure in learning. Drawing in KA is drawing with ProcessingJS. The only relevant thing that `with` does is allow you to write `stroke(255);` instead of `processing.stroke(255);`. Nothing more. In fact, ProcessingJS includes a `compile` function which does in fact transform Processing code into JS prepending the `processing.` before each call (calls to processing functions, of course). You could easily either use `Processing.compile(...).sourceCode` to create a simple tool to translate the code, or you could use `Processing.compile` at runtime. The author of the linked answer in SO decides to do neither of those and instead use `with`. Sure, it _can_ be done that way, but it's not a good way. But going back to what I said before, KA's usage of `with` (as explained in the video someone else linked) bears no relation to running your code. It's done for the very specific purpose of allowing KA's environment inspect and watch your code (and then give you hints or messages or whatever). You don't _need_ that to run the code and you certainly don't need to use `with` either.
This is the most difficult part, because it is a real game-changer. Modules change how web pages load JS. Same thing happened in Java 8. Modules were deferred to 9 because it is such a hard nut to crack.
You have mispelled "choice 1" and "choice 2" (spaces).
Oh my god I'm really dumb, thank you!
Now you are quoting mustache to me. Are you really that myopic that you think this is something Angular-specific? I am talking about event bindings, which are pathetically verbose in Angular (even 2.0).
That was my original intention, however, the breaking changes in my module are unreconcilable with gulp. furthermore i mentioned some of the ideas in threads with dev's on the team, and they had reasons for not wanting to support some of the features (like command line args) The speed argument I'm referring to is just the initial load time when it initially launches and indexes tasks - it has nothing to do with vinyl-fs (that's what I use). Their command line utility / orchestrator are the main issue I have with gulp - and orchestrator has been a problem for over a year and they've been actively rebuilding a task manager from scratch for gulp 4 - but my command line initialization only concerns unix. I'm not building some cross platform app that needs to run on every machine - so I don't care about polyfil / boilerplate code. And I still have no idea why this lib catches errors better... so I'm not much help in that department. I did help rewrite a small section of the docs. (because I don't believe returning streams is a good idea) It was just an experiment. considering how easy it is to just implement your own gulp, or use bash scripts, or npm scripts, i don't even know if I want to use a task manager anymore, the vinyl-fs works fine for me. But the biggest change was that I applied the philosophy of 'plugins' to 'tasks' - which makes 'tasks' reusable. Having vinyl.src / vinyl.dest coupled within tasks is an anti-pattern and makes it difficult to re-use those tasks when the fs changes. My philosophy was to compare a task with a transducer. And although I like piping - it's difficult to handle errors if the stream isn't wrapped. They mention this in the repo - but it's not like included in the lib by default or encouraged to as standard protocol.
Thank you!
 // Deprecations deprecated.field('gulp.env has been deprecated. ' + 'Use your own CLI parser instead. ' + 'We recommend using yargs or minimist.', console.warn, Gulp.prototype, 'env', gutil.env );
With would be fine if javascript objects weren't so polymorphic and conformed to a type mandatorily. If you had a guarantee of what keys and values an object of a particular type had, and knew that it would have others, with would be fine (although, tbh, a code smell). The issue is, you can't safely call with() on: --any object passed into a function (are you sure your coworker didn't add something to it in another area of your code, perhaps in a function modified in a far off module you don't keep close watch over?) --any object provided by the browser environment (what if a browser maker add a key that breaks your code later?) --any object that is being used as a map for arbitrary keys The fact that dealing with those sorts of objects is most of what you do in javascript is the biggest problem. Even with an object built directly from the constructor you're asking for maintenance issues and hard to analyze code.
Just wanna take a quick moment to say that you seem like a huge loser, and if you think that react is facebook's "angular", then you're a tried and true retard. React isn't framework, but a view library, and judging by your consistently downvoted replies in this thread, you're pretty new - and VERY ignorant
Hi /u/zombiecodekill, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `zombiecodekill.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [zombiecodekill.com](/search?q=%28and+site%3A%27zombiecodekill.com%27+author%3A%27zombiecodekill%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|21|70%
&gt; "judging by your consistently downvoted replies " Always go with the herd dude. Safest place to be.
Almost all frameworks have a mini-language in them in the form of a template.
Javascript the good parts. Javascript patterns by stoyan stefanov [ydkjs series](https://github.com/getify/You-Dont-Know-JS) Javascript being so loose and forgiving, frameworks are generally the way most people get any work done. I would take a look into react over angular (having used both I can't ever see myself going back to angular hell) There are also things like mithril/mercury etc you can write a quick demo apps in to help get up to speed. es6 brings a lot to the table so maybe invest a little bit of time learning how to get transpilation running. commonsjs modules or es6 modules if you get es6 traspiling will be the the best way to modularize your code. Browserify/webpack are your best options there.
Dude, why even participate here if you don't even know what event binding is?
Dude, you never talked specifically about it: &gt; We use CanJS, which contains can.Model for the data layer. &gt; edit: oops I misread your question. CanJS has several options for automatically binding your data to you view (one way or two way). Very, very simple to do, puts the verbosity of e.g. Angular to shame. I don't see the word 'event' in there anywhere, nor was it implied. Why even participate here if you're not going to articulate your thoughts clearly? Especially because you were talking about data binding specifically.
Write lots of JS. It is easy to read too much and code too little, which makes you forget most everything you have read within two weeks. Write lots of code, spend lots of time understanding prototypical inheritance. Look at good that others write. Find a popular JS framework and read their code. What are they doing differently? Figure out why they are doing things that way and decide how you can adapt that. IDE is not a huge thing at first, use whatever you are comfortable with. If you know C#, why not look into Xamarin?
The rerms of service clearly state that what you are trying to do is in violation of their terms of use and that by doing so you would be violating copyright. So don't do it, because even if it is possible it is illegal and they can probably hire better lawyers than you
Didn't seem like a particularly valuable or well-thought out comment to me. Name calling and "Everything about React sucks, there's literally nothing good about it!" As for "engaging in actual discussion," it might be the whiskey, but I see quite a bit of discussion going on.
Well when the guy calls everyone sheep right of the bat any hope of discussion is already lost at that point.
good advice, thanks TranculentOcclusion!
This would be the easiest I guess: http://codepen.io/eaglefsd/pen/LVoGgY Have a look at window.prompt: http://www.w3schools.com/jsref/met_win_prompt.asp
You need some sort of templating for that. Mustache is quite simple: https://mustache.github.io/#demo https://github.com/janl/mustache.js E.g. you'd write something like: var template= 'Hello, {{characterName}}.'; var data = { name: 'Steve' }; console.log(Mustache.render(template, data)); // Hello, Steve. A more elaborate exmple (you can run this in the console on the demo page above): var data = { player: { name: 'Steve', money: 55 } }; function say(template) { console.log(Mustache.render(template, data)); } //... if (data.player.money &lt; 100) { say("Sorry, {{player.name}}. {{player.money}} gold isn't enough. This sword costs 100 gold."); } Output: Sorry, Steve. 55 gold isn't enough. This sword costs 100 gold.
I don't get you to be honest. So, what's your plan? Let the JS show the user 'Hello, username', then let the user enter his name, then show the user 'Hello, Foo'? Or do you just want the user to input his name and then show him "Hello, Foo"? If you want to output the string "Hello" together with the entered username, you can just go with ` alert('Hello, '+ variable) `
CanJS? 
Why even post content like this? A simple google search will tell you that jQuery is a library, and not a preprocessing language. Also, to add a little. Using jQuery isn't as cumbersome as some people put it. If you load it off their cdn, it's probably already cached for most users anyways. Personally, I'd recommend you to avoid using libraries like underscore, lodash, and jQuery for personal projects because it'll be a better learning experience to be as minimal as possible.
It seems like OP is at the beginning of JS, maybe he should learn to use normal variables in strings first before starting to use more and more libraries...
Homie just straight up ethered `with`
Or *maybe* using a library and a small helper function will make for a more entertaining learning experience with more dynamic dialogues. I just provided some information for doing that. They are free to ignore it.
Nope, that example is using the semitransparent overlay method. It doesn't let you do actual gradient animations.
The nice thing about TypeScript is it only adds types. You need not rearchitect anything to use it. If, in fact, my response were serious, the purpose would be to use it as a tool to inform the developer about much of the interior workings of the code being examined.
YES! You got it!! Oh man, visual examples help so much. Perhaps you're right about it being too complex though. Edit: As for &lt;%, I've been using Twine 2. For whatever reason, that symbol works. As does &lt;script&gt;.
You'll have to download and install [NodeJS](https://nodejs.org/download/), a JavaScript interpreter and library that runs JS on servers/computers. Then follow the instructions in the README.md, which is just Markdown text. Pretty much everything about the bot is on the README.
Right. Not trying to call you out on it or anything. Just trying to say that may be part of the reason why they thought it was really weird.
I used [Angular 2](https://angular.io/) (Dart flavor) for the example above. The simplest library for this kind of thing is probably [Knockout](http://knockoutjs.com/). However, even with Knockout, it's still fairly advanced stuff. You need a solid understanding of the basics before you can use a complicated library like this.
&gt; I honestly don't see the point of React. The virtual dom is a non-feature that solves zero real world problems and all that is left is new, ugly syntax to learn and a conflation of concerns that kills programmer productivity. I wonder if they brought the same novel approach to the model layer (Relay) too. he's brash, but doesn't call anyone sheep. 
People usually vote based on their opinion, particularly if the comment is opinionated. Even on HN. Most people understand this. Regardless, his comment was ill-informed and didn't contribute anything. Sure, it's a JavaScript subreddit, but that doesn't mean that I should expect to get upvoted if I go to every React-related submission and give a poorly-formed, condescending diatribe about why React is awful, absolutely pointless, and conceived of by terrible engineers. As an aside, it seems like heavily downvoted comments often get *more* attention.
&gt; implying that the only problem React solves is rendering speed. lol
/r/javascript ?
No problem. It caused me to learn something new :) I've been stuck in ES5 land far too long. I'm trying to learn TypeScript/ES6 along with ReactJS but work has me crazy busy right now.
Definitely. This list is something to shoot for, not something to be expected. I found it useful myself on occasion though.
I haven't use D3 in some time, is this easier or more flexible?
Why are they changing it so much? It seems like that would be more effort on their end as well.
it says from the command line i need to run "pip install TwitterAPI" I open up the cmd and type it in and it gives me an error 'pip' is not recognized as an internal or external command, operable program or batch file." What am i doing wrong?
pip in the Python package manager, which is weird because there are no dependencies on Python in the project. Have you accidently downloaded the Python version at the end of the README? I got the source code from [https://github.com/raulrene/Twitter-ContestJS-bot](https://github.com/raulrene/Twitter-ContestJS-bot)
he says "go with the herd", implying people are sheep. 
People here are overcomplicating things, you don't need any libraries, you can do this easily without one. Here are 5 lines of code that do exactly that. While you may not be familiar with what exactly is happening here, it is really basic JavaScript and html, far from complicated as the others claim. All the code does is copy the value of the input field over to the output field every time the input field changes. [You can find the code here](http://jsfiddle.net/ez3guent/3/) I'm very certain that you'll be able to understand what this is doing. Good luck! :) Edit: This exact code wil work with Twine 2, cool program!
HI
So why don't you provide him the basics like /u/Combinatorilliance did?
i am really having trouble, am i overcompicating this thing? is there any easy way to run this bot that im missing?
Stuff like NodeJS and Python. Cause Window's likes to do things differently
I figured out what they actually wanted. I wrote a small demo app and recorded a GIF of that. That wasn't good enough? Could you possibly be more demanding? With "basics" I was referring to the basics of the language. They should learn those from books. Also, doing it imperatively like as /u/Combinatorilliance did does work fine in simple cases like this. However, it gets rather complicated very quickly. There is no model. There is also nothing which would keep the UI in sync with said model. This will inevitably lead to spaghetti code. Unless you write your own framework, that is. Also note that the "input" event is rather buggy in IE9.
I'm sorry, I have no clue. I work on Linux so I'm not aware of how to deal with this.
Is it declared in multiple places? I see one var declaration near the end, but many references before that. If I had to guess, I'd say you're accidentally creating a global customerid that is being used some of the time, and a local var used in other places.
Try posting this at /r/learnprogramming
Is there anyway I'd be able to get it to utilise the already prompted for input and use it outside of the while loop? That's what it feels like I need to do without re-prompting specifically for the end part.
Hey man np,thanks for ur help tho
Do realize you just replied to me with four rambling paragraphs that didn't even touch on my comment?
This is my first try at javascript man, I only just know what I'm doing based on what I've been taught so far. I only deleted my other thread because I was gonna ask another question and didn't wanna bombard the subreddit. Thanks I guess.
The look on the dude's face is priceless
Or neither, if you're using Meteor! (FTW)
I've added some generative tests recently for some parsing/calculation engine tests which caught some edge cases, though I used [jsverify](https://github.com/jsverify/jsverify), which seems to be more active. Is there any particular difference between gentest and jsverify?
it's a function declaration, this code is going to throw a syntax error. You need to wrap it inside parenthesis to make it an expression. It's not just a trick question about syntax, it shows that you understand the difference between the two and might know a thing or two about hoisting and how the compiler works. Now this is pretty advance javascript imo. I would only ask this to someone that showed interest into the subject.
I've never used react, I don't claim to understand it and I'm certainly not a fanboy. But I wish I could downvote you more based on the way you are handling this conversation.
http://i.imgur.com/hoxBPP1.jpg
A 99% discount is a ridiculous marketing gimmick which usually means the original price was stupidly high. Which then tends to make me suspicious of the actual _value_. Then again, I could be wrong, of course. After all the course comes from the most prestigious "1337 Institute of Technology", so...
google object.observe() tl:dr; is you can get events from an object (also arrays and variables, i think), when items change, are added or deleted... which lets us do reactive programming.
First dip into programming as well, figures they'd give us a hard one.
not even, they need .md
You're looking for https://github.com/Reactive-Extensions/RxJS - start with googling 'rxjs' see also https://egghead.io/technologies/rx for some videos 
* your second loop ("customer ID: X has gas usage"): * the gas and total variable are already deleted here, except the last one they entered! * what you probably want to do is add an array to the prompt loop: `var usage = [],totals = []`, and `usage.push(gas); totals.push(total)`. this way all your variables are available later * on my browser (chrome) prompt() returns null if they hit cancel so you should add `while (customerid != -1 &amp;&amp; customerid != null)` * consider using `parseInt()` on any input variable before doing math with it using a div, not a for loop: https://jsfiddle.net/qjdezrhw/ and using arrays and for loop: https://jsfiddle.net/f1qey0uf/ i had to use document.body.innerhtml instead of document.write cuz of jsfiddle. gl
Maybe they stop developing new node versions and write a website. Trying to use cutting edge features in node is turning into a joke.
I'm working in browser based exercises, opened in chrome. The console itself is empty unless I console.log something myself.
You should be getting the line number information in your console when it spits out the error (whether you're in the browser or Node). Failing that, though, you can insert console.log statements at various places and see which ones get executed until you pinpoint the problem. Be aware that you might be trying to read this property in an if condition or something.
usually its from a func returning `{} or [] `when you expect it to have real results, or a loop doing one too many loops. ex: fiveItemArray = [ {x:1}, {x:2},{x:3}, {x:4}, {x:5} ] for (var i = 0; i &lt;= fiveItemArray.length; i++;) { // should be length -1 //console.log(i, fiveItemArray[i]) // uncomment this to debug it console.log(fiveItemArray[i].x) // this errors on the 6th loop } you can find it in your code by finding `.x` or `[x]`
crockford rah rah rah !!!
in china they hang you!
Hi /u/baneccloud, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Blatant [plagiarism](https://books.google.com/books?id=Wmfr1Zp7d5EC&amp;pg=PA261&amp;lpg=PA261&amp;dq=JavaScript%27s+interaction+with+HTML+is+handled+through+events+that+occur+when+the+user+or+the+browser+manipulates+a+page.&amp;source=bl&amp;ots=U6rXRL67wK&amp;sig=2P8Q1GOFlydeUGAMWp_jU5UnCIg&amp;hl=en&amp;sa=X&amp;ved=0CC8Q6AEwA2oVChMI5o_i1ZWwxwIVCkySCh1oGAHf#v=onepage&amp;q=JavaScript's%20interaction%20with%20HTML%20is%20handled%20through%20events%20that%20occur%20when%20the%20user%20or%20the%20browser%20manipulates%20a%20page.&amp;f=false), banned. 
This is kind of a blah reason now that you can define non-enumerable properties. I agree that others exist. But I disagree that this is one of them anymore.
Don't Make Me Think is a really good book. At least the 2006 edition was -- I haven't read the revised edition yet.
I'll stick with tool that give me an easy to use UI to build and run unit tests, but thanks.
In the JavaScript world what tools are you referring to? Mocha/chai is a pretty common testing framework combo. In addition the WCT does give you a nice UI when it runs the tests. As for unit testing Polymer, what would be the alternative?
Literally just load yargs. What's difficult about that? It's a task runner, why would it deal with the environment? Read up on the unix small module philosophy
Is there any reason you couldn't use any JS unit test tool with Polymer?
You're missing the `draggable: true` option on your markers. Can I just make one code cleanup suggestion? var layers = [ 'alok_010115_01_nc', 'alok_010315_03_nc' //... ].map(function(name) { return new google.maps.KmlLayer('http://mojaloss.net/maps/Fibre/' + name + '.kml', { preserveViewport: true }); });
Looks pretty cool, I like the concept of extending Mocha to be slightly better for Web Component testing. I think there's much to be desired though, since the `&lt;test-fixture&gt;` element doesn't seem to do all that much. The same goes with the `context` function. "The context function is not mandatory, but it is a convenient way to group up our tests." Isn't that exactly what `describe` is?
[**@wesbos**](https://twitter.com/wesbos): &gt;[2015-08-17 15:36:35 UTC](https://twitter.com/wesbos/status/633301405445427200) &gt;🔥 Use Lodash's \_.has\(\) to easily check for nested property existence [*pic.twitter.com*](http://pbs.twimg.com/media/CMnwQJdU8AAeEei.png) [^[Imgur]](http://i.imgur.com/TWqTQ2E.png) ---- [^[Mistake?]](/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3hbso1%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Sorry, I'm completely new to js. I'll remember that for the next time I run into a problem.
Thanks for the cleanup suggestion, I will implement it soon. As you can see my code is rather bloated and ugly inside. I wanted to add another marker, which is draggable and gives lat/long info in real time on the side [like this example](http://gmaps-samples-v3.googlecode.com/svn/trunk/draggable-markers/draggable-markers.html). I don't want to make the existing markers draggable. I hope I could explain it properly.
How is the performance compared to gif or video? Any information on that?
Also forked to remove dependency on jQuery: https://gist.github.com/caligin/022e2996ab7691dc25ac kept main logic as it was, only swapped jQ with document.querySelectorAll + Array.prototype.reduce (this means that requires modern browser instead of jQ)
What iPhone are you testing on? Like I said works fine on the 4s which is like 5 years old.
Cool library! But it does not support negative exponents or variables in the denominator. An expression like 1/(1-x) is impossible to generate. I was puzzled by seeing 5/2x (5/(2x) or (5/2)x?), but it isn't ambiguous if there's only one possible orientation. Another example: 4/3x^2y + 8/3xy + 16x + 32 Is it 4/(3x^(2y)) or (4/(3x))^(2y) or y*((4/3)x)^2 or (4y(x^2 ))/3 ? LaTeX support for everything is awesome!
Shouldn't the testing tool handle that though?
[Netflix doesn't seem to think so.](http://www.infoq.com/news/2015/08/netflix-universal-javascript)
I am interested to know this as well.
For real-world applications, SEO is the number one concern. I work as a developer for an e-commerce platform, and I'd love to use something like React to build a store-front, however whatever server renders the HTML for the page HAS to have product / category / search information on the page, I can't just blissfully ignore the state of data on the client. That data MUST be on the page so that google will rank it.
Netflix doesn't have SEO concerns. Their users don't come from organic search results.
SEO is a #1 concern, and apps which don't offer it will always be at a disadvantage in the marketplace. 
If SEO is the number one concern, why don't you simply delegate the server-side rendering to a SaaS like [SEO4Ajax](http://www.seo4ajax.com/)?
How? all the documentation I've seen says that React components are for inside the body ONLY.
Test fixture is mostly a convenience wrapper for creating, testing, and disposing of blocks of DOM elements. It makes the timing of certain life cycle calls like `created` and `attached` easier to test.
Even better: [Lodash's _.get\(\)](https://lodash.com/docs#get). Not only does this check if the property (or element) exists, it also returns it. It even works for objects within arrays within objects. _.get(nestedObject, "foo.bar.someArray[5].baz"); You can also pass a third argument, which is what is returned if the property does not exist.
For my clients, they can't sell their products if they don't get organic search traffic. SEO determines revenue. It's the same for any sites that generate revenue from advertising, like blogs- if people can't find your site you won't have any revenue. I don't know what industry you're in, but I'm jealous that SEO doesn't matter to you, because it's the ONLY thing that matters in ecommerce. To this end, server-side rendering is the only reliable way to get indexed by google. Hash fragments are a mess, and require server side rendering anyway. Google can't index React components. And they say they run javascript on your site, but what is in the initial HTML payload is 10x more valuable than any asynchronously loaded content, I can tell you from personal experience.
Because systems like that don't work? I've been running our own copy of prerender.io and have to restart it multiple times a day because it crashes, and it didn't accomplish the intended goals. I moved over to server side rendering of our own content (non-react homebrew framework) and saw 2-4x increase in organic traffic over the course of the first month. Same content, just using server-side rendering.
same here, I am interested if anyone can answer this!
Do you use phantomJS? I've found that to be problematic in every way that I've tried to use it. In the case of multiple asynchronous data loads, how can you tell when a page has "finished" rendering? That's the major issue we've run into.
I give my opinion, some reasoning behind it and a few examples, staying polite while being verbally abused. Meanwhile nobody actually disagrees with me ( strange but true) or explains why React is a valuable tool for them. Instead they just downvote anything I say because I dare question the validity of what they have been told is the next big thing. But don't worry mr Style Police, I have already unsubscribed from this sub. 
Without proper IDE support, using strings for stuff like this is pretty nasty. Makes it really difficult to refactor. I would say use sparingly only when it makes sense. Off topic, not sure if I'm okay with having a post for a single method in a library's API. 
Woah, those look good. Thanks a lot
Presumably you're bound to the standard rules and any posts have to be sent to the same domain. 
I was able to solve the problem using this example, worked perfectly. Thanks for your help! http://jsfiddle.net/kjy112/QvNUF/ 
Converting ES6 Maps to and from JSON is what killed my father. Don't do it.
Because React is a library, so the scope of the React documentation limits to it. If you're playing with it or just making 1 simple component, using componentDidMount is useful.. but in the long term, components shouldn't be fetching data. It's architecture stuff. Components should be as dumb as possible in order to be easily reusable and testable. You can read more about it here: https://facebook.github.io/flux/docs/overview.html 
👍 Super handy since you if you are testing for it, you probably want to use it! 
thanks, going to give mithril a try and create a quick prototype. maybe I'll convert that to mercury and see what happens.
I know ES6 is supposed to fix all these problems that I learned to work around and/or live with a long time ago so therefore it's "better", but is anyone else not stoked about having to learn basic shit like this again? Like again again?
Is this framework what they use to construct their app frontends?
And [its homepage](https://netflix.github.io/falcor/).
I see. Wow, their devs are fast. I feel like I was just reading about how they did their frontend a little while ago (before React existed).
Refactor it a bit so the strings are vars. Go all ES6 and declare them as const if you want. I like the post because I'm not a lodash user and I was trying to think of of efficient ways to do this kind of search. 
BTW, book being referred to is available here: domenlightenment.com
To learn JS? Are you a JS beginner, or a beginner programmer all around?
I agree somewhat. But the alternative can also be not too nice. E.g. what's a good alternative for his last example? _.has(thing, 'images.sizes.large.url')
It's a trivial method to write, if you think about it. Using lodash solely for this purpose would be a waste.
I said to use it sparingly. My guess would be that if you require nested access of properties to the degree where a function like this would help, you should probably refactor your schema or approach to the problem. While your example doesn't make much sense anyway (why is images an object? why is sizes an object?), it should probably be coded in a way where sizes is never null, so the only null check you need is if(images.sizes.large). It strikes me as most useful when dealing with JSON responses from 3rd party APIs, selecting only a subset of the data.
I use a single directory for js (public/js) and concat everything with grunt (or gulp if I'm using Laravel) into a single file, even in development context. In production context, I concat everything as well but uglify it as well. Why would you mess around with symlinks if you can just simply concat your required js in development context as well?
Completely agree. Do you think each of those deserves its own post?
Well, there's your problem. Those are objects, not arrays. No idea why though. If I throw the output of `preg_match_all` at `json_encode`, I get nested arrays. http://3v4l.org/rLOcS preg_match_all("/[\w]+/", "one two three", $out); echo json_encode($out); Output: [["one","two","three"]]
That's not what I said. &gt; not sure if I'm okay with having a post for a single method in a library's API To which I said I found the post to be interesting, even if it was about one feature. It was a feature I was working on independently, and so its interesting to see how other people do it, too. I also explicitly said "I'm not a lodash user", hence not giving any argument that someone should use lodash just for one feature. 
Christ no. I downvoted this shitpost as fast and as hard as I could.
Yeah they had a segment at React Conf I believe where they was talking about how quickly they managed to get a working prototype going and then actually build it. I really find the fact that their apps on TV are also now using React (albeit a modified version that works on their custom "DOM" for TV) amazing.
I didn't downvote you or GP but I hate those bot posts. 
&gt;what job do you have that allows you to work with straight up, low level javascript? The only gigs I see are kind of scummy, as in popup blocker work arounds, cookie stuffing, etc what are you actually even talking about here? 
Yep totally this. Refactor support should not be the issue here. Hanging strings are, however.
If you have PhantomJS 2.0 working, why would you ever bother offering 1.9?
Even *with* IDE support, using strings in general is pretty nasty.
`thing &amp;&amp; thing.images &amp;&amp; thing.images.sizes &amp;&amp; things.images.sizes.large &amp;&amp; thing.images.sizes.large.url`
Odd that this supports XDomainRequest (IE8 + 9) but assumes Promises are available...
It amazes me to no end how people can in one breath say "oh, we NEED to start using ALL the new HTML5/CSS3 goodness and browser vendors need to get their shit together so we have all of it working in all browsers because that's the only way we move the Web forward!" and in the very next say "Oh, we've got to do PE because some people may have JS turned off, or maybe they have a bad network connection, or they're on less feature-rich devices, or CDNs may fail, etc." Oh, I'm saying fuck you to someone, but it's not who this article thinks. Look... either we trust the network we're building our lives on or we don't. Either they work 99.99% of the time or we've got bigger problems then whether to do PE or not. Either we want everyone using all the newest and best Web stuff or we don't. Either we want real standards that we can apply in ALL cases and ignore the rest of the very minor cases, or we don't. Enough of this PE crap, it's time has come and gone. Look, I get it: there are sometimes things out of the control of some users. I know the scenario all the PE evangelists love: you're viewing a web site on a train and you roll through a tunnel just as the JS is downloading and now the site is broken, but if you did PE you'd at least have a BASIC functioning site. To which I say: SO FUCKING WHAT?! Of COURSE it's broken in that situation! Guess what? My damned car ain't goin' nowhere without it's engine either! And yeah, great, I can always push it up a hill and make it kinda/sorta go somewhere... that's great... but that's not the experience I want or expect when I own a car. I want to get in and drive 25 miles to the big mall by me, and if the car won't start, well, that certainly sucks but I'm not gonna suddenly be okay with having to ride my bike 25 miles and I'm CERTAINLY not going to be okay with PUSHING the car 25 miles! And I'm CERTAINLY not going to pay Hyndai an extra $5k for a car that will allow me to pedal it, which is what happens when you do PE. Anyone who says PE doesn't cost anything extra is bullshitting, period. Sometimes it may not cost all that much extra, but it'll always cost SOMETHING extra. And the justification for that extra spend is, what, so the site will be, in a very crippled way, still basically functional for the .5% of people who will ever run into that situation. Give me a fucking break already. PE was a great idea when people were just starting to get the Internet on their phones and those phones could barely handle it, let alone the networks. There was a place for it then and it kept us going until the technology caught up with what we wanted to do. Well, guess what? Now people expect A LOT MORE from the Web... and as designers and developers we're all too happy to give them all the fancy they want... but we're going to try and claim that it's okay to give users less in some rare circumstances because it's better than nothing? No. It isn't. Nothing is better. It wasn't always, but it is now because the delta between what the modern Web is and nothing is a hell of a lot greater than it was when PE was a good idea. Back then, the difference between a site that basically worked with JS and one enhanced with JS wasn't all that significant. Now though? It's night and fucking day! It's about time we stop fighting for the night and get on with the bright, bright sunshine of day that is the modern Web. A few vampires here and there be damned.
Yeah, I get all that but it just doesn't excite me.
(Weak)Map and (Weak)Set are very useful. Being useful is as exciting as it gets, I'm afraid. Well, the good news is that you'll probably never have to do this because the things one wants to pass around are generally simple objects.
You can do this: _.has(obj, ['firstDepth', 'secondDepth'...]); Which makes sense... you just save a .split('.');
Related: You don't have to load *all* of lodash if you use npm. You can npm install lodash.has and get just the parts you need.
Why are you using `var` in ES6 code (for-of)? Why do you create a new regex from the source of regexes? You already got a regex. Just use that one. "o" is an implicit global. Random semicolon omissions. Those two functions are identical except for a bit of data. "myFunction5" etc is a terrible name. Anyhow, instead of replacing some strings with other strings on the markup level, you could just set the contents of spans. Alternatively, stick the data into a template and render the template. So, you don't really need a way to undo the change. You just have to do it in a non-destructive manner which can be repeated as often as you like.
https://github.com/iam4x/isomorphic-flux-boilerplate
setTimeout would be a terrible solution. Because the API you're using is async your really should use some sort of async pattern for your code. You could try mucking around with variations of wait loops... but no one is going to thank for that down the road. The easiest approach is probably jquery Promises. Initially this will seem like a lot of work... but mostly it's just rearranging code (wrap your async API calls in a bit of code that returns jquery promises and shift dependent code into a .then().
When I merge regex for the top input fields and bottom input fields the whole app doesn't work anymore and I was unable to pinpoint the cause. Secondly, I am not so savvy with javascript, css and html is ok, but javascript is driving me mad. "myfunction5" is a generic name as any other, I had no time to format and plan the names, it was the functionality that was my prime concern. 
That's literally what I'm doing - I'm running meow (lightweight wrapper on top of minimist) on top of vinylfs as well as a bunch of sindresorhus modules (who maintains countless gulp / grunt / atom plugins and small util libs) and chokidar and other stream utilities. It's fairly easy to roll your own task runner. I just don't like gulp's default settings - like global install, cmdline utilities, and internal stream handling utilities baked (or not included) in source. They can't change those features because it would confuse the user base way too much - I wouldn't even suggest changing those defaults if I was a maintainer - hindsight's 50/50 and I like what I'm doing better and I know what I'm doing - I'm not trying to shit on gulp i use that ecosystem
Sorry I'm on mobile right now so formatting will suck. // save p var savedP = document.getElementsByTagName('p')[0].innerHTML; // modify p ... // restore p document.getElementsByClassName('p').innerHTML = savedP; You'll have to alter this a bit to select your elements and create variables accordingly, but that's pretty much it! 
Template or spans: http://jsfiddle.net/hdee5sfj/ Element.dataset isn't supported by IE10 and below, use attributes['data-whatever'] instead if you need support for those. The "input" event is buggy in IE9.
Wouldn't it be even smaller by using a 1-bit PNG character map? You could even encode it in base64 if you want to keep it in the js file. 
The method(s) accept an array.
Ok, actually, I'm really confused as to what you are trying to accomplish, even with looking at the fiddle. You might want to consider giving your functions logical names and explaining what you're trying to do in business terms to help people understand your problem.
Does Netflix use the this in production? 
Your trivial implementation doesn't handle ["foo"], doesn't work if there are Array.prototype extensions, returns an inconsistent fail value (null or undefined), doesn't check if the property exists before treating it as a path.
Is this marketing speak from the heart? My experience doing this for a living is that if SEO is your primary marketing channel you are likely very small and too poor to spend on other sources of traffic.
I created something similar that did this but was safe enough to use any properties with eg `a[""]["\ntest\n"].YOLO` : https://github.com/kolodny/nester
Fuck yeah. This is a lot more impressive than Relay.
Yes. My comment was partially facetious.
You aren't a master unless you read and understand the specs themselves. 
 for (var i = 0; i &gt;= 4; i++) this loop won't run because i is never greater than or equal to 4. just reverse that to: i&lt;=4 
I think it's usually called "safe navigation operator". "Existential operator" seems to be CoffeeScript terminology.
Another alternative for this is [react-helmet](https://github.com/nfl/react-helmet), which I'm working with now.
Really nice solution. I had no idea about `createTreeWalker`.
Yes, across all platforms (web/mobile/tv).
Things similar to this work with lodash too.
Thanks!
Better yet... Make it &lt; names.length
Yep, and this is a logical error, not a syntactical one. Syntactically, it's fine. It just doesn't do what you want it to do. By the way, ES6's for-of does make simple iteration easier: const names = ["Joseph", "Hero", "Reece", "Stocke", "Ben"]; for (let name of names) { console.log(`I know someone called ${name}`); } If you don't need the index for anything, for-of is the far less noisy option.
I'm puzzled by the downvotes, this is a VERY valid point!
I also use Vagrant, I'm using Ubuntu set up with shared folders to the Vagrant box and Gulp/Grunt runs on my local Ubuntu (so not on the Vagrant machine) and it runs much instant whenever a file changes, no lag at all. This also works great for source control integration with PHPStorm.
How is it hard to prevent XSS attacks? Letting anyone run arbitrary JavaScript on your domain has a lot more problems than the fact that they can read your localStorage.
The way your code currently works, each iteration of the inner loop is pushing 3 new items onto the outer loop. This might be a little more obvious if things are renamed a little: function inventory(currentInv, updatedInv) { var currentItem, updatedItem; for (var i = 0; i&lt;currentInv.length; i++) { currentItem = currentInv[i]; for (var j = 0; j&lt;updatedInv.length; j++) { updatedItem = updatedInv[j]; if (currentItem[1] === updatedItem[1]) { currentInv[i][0] = updatedItem[0]; } else { // As only one item in the inner loop can match the current item in the // outer loop, all *other* items will now be pushed onto the outer // loop (and then looped over later, again.) currentInv.push(updatedItem); } } } return currentInv.sort(); } Whereas you really only want to add the item from newInv if it isn't in the currentInv: function inventory(currentInv, updatedInv) { var currentItem, updatedItem, updatedItemExisted; for (var i = 0; i&lt;updatedInv.length; i++) { updatedItem = updatedInv[i]; updatedItemExisted = false; for (var j = 0; j&lt;currentInv.length; j++) { currentItem = currentInv[j]; if (currentItem[1] === updatedItem[1]) { currentInv[i][0] = updatedItem[0]; updatedItemExisted = true; break; } } if (!updatedItemExisted) { currentInv.push(updatedItem); } } return currentInv.sort(); } But it feels like you'd be better to store your inventory in an object, not an array - as then you don't need nested loops: var curInv = { 'Bowling Ball': 21, 'Dirty Sock': 2, 'Hair Pin': 1, 'Microphone': 5, } var newInv = { 'Hair Pin': 2, 'Half-Eaten Apple': 3, 'Bowling Ball': 67, 'Toothpaste': 7, }; function inventory(currentInv, updatedInv) { for (var name in updatedInv) { currentInv[name] = updatedInv[name]; } return currentInv } Or if you can use ES6, with object-based inventory, the whole thing is a one-liner: var inv = Object.assign({}, curInv, newInv); Then all you need to do is write something to alphabetically order the inventory list.
They have built in cache invalidation. You can basically set a timeout for any piece of data and after that if your application needs that data it will go get a fresh copy behind the scenes. You just continue along as if you always have all the data you need and it handles the specifics.
What makes you say that? It actually seems to me like a much less fully featured and simpler system. So like... if you define impressive as KISS then yeah, but if you look at features GraphQL and Relay wins hands down. Just the fact that GraphQL is a schema based system with introspection built in mean that tooling built around it will likely win out in a huge way.
beginner all around
Kinda sums it up in one of his many video presentations on it. It's rather impressive if you've considered going with a pattern like Flux/Relay with GraphQL from the FB camp. https://youtu.be/hOE6nVVr14c I think one of the big takeaways is developer productivity at scale. One of the points he also notes is: The client usually knows what it needs so it should supply the request indicating as such, and one shouldn't always need back-end code to structure the data for us and is how we sometimes or often-times, depending on where you work, end up with more data than you've requested (client-side)/over-fetching.
On the other hand the vast majority of websites use schema driven databases. The alternative to which are NoSQL like MongoDB which... I mean they have their place, but there's definitely a reason for the schema. For example in PHPStorm they do code completion based on connected databases, which is possible because of schema introspection. But they have their reasons. You can read more about that here: https://github.com/Netflix/falcor/issues/349
It doesn't appear to be using WebSockets or polling no, though it'd be interesting to see whether it can be extended to do so, and how easily.
You would want each client.readFile as a separate promise and then do a $.when(..each promise..).fail(..).then(..). A bit easier to understand than a bunch of chained callbacks (and avoiding long chains of callbacks is kinda what promises is all about). Something like (typed but not tested): var prefsRequest = new $.Deferred(); ReadDropBoxFile('prefs', prefsRequest); var anotherRequest = new $.Deferred(); ReadDropBoxFile('another', anotherRequest); $.when(prefsRequest, anotherRequest) .fail(function () { console.log('At least one request failed'); }) .then(function (prefs, another) { // // prefs and another are from their respective ReadDropBoxFile result // - probably need to test to ensure the order is always respected // }) ; function ReadDropBoxFile(Filename, Deferred) { client.readFile(Filename, function (error, data) { if (error) { console.log('File not found: ' + Filename); deferred.reject(); } else { deferred.resolve(JSON.parse(data)); } }); } 
Oh I see. So when I push the second array item it then loops all over again with the new item thus creating an infinite loop. Thanks!
&gt; schema driven databases. The alternative to which are NoSQL like MongoDB LOL, somebody who hasn't got a clue.
I disagree with that. In a flux architecture, there's no reason why you need a component to be mounted first to fetch data. You could just initiate the request in the same file where you mount your root component. 
How would that work with an SPA with routing and several pages? 
What's wrong with XML and SOAP? XML doesn't make sense for the web, sure, it's heavier than JSON, but it's designed to be human editable and readable. SOAP is just a standard to make XML strongly typed in a sense. 
Isn't mongoose still popular? A lot of people add schema layers to NoSQL. 
The React series on Laracasts is a great intro. https://laracasts.com/series/do-you-react
Ha, thanks for the effort ;). Seriously though, I'm not *anti*, I'll end up learning the parts I need to learn to stay current or I'll just continue my slide into the backend and infrastructure stuff that's been way more fun for me since Angular. I'm just speaking from a place of front end burn out, and now this is at the language level, and now they're already talking about ES7.. Thank you for the examples though. Cheers..
With hardcoded procedural 4-level + transparency palette: http://jsfiddle.net/1mgrtnen/ Gzippes to 1,803 (w/o minification). The two strings gzip down to 1,355. A ZIP which only contains sprites.png (1,276) + fixedsys.png (369) is already a bit larger (1,943). The problem with ZIP is that each entry adds two headers and that each entry is compressed on its own. Inlined strings don't have this downside. Also, since PNG and ZIP both use Deflate, the "uncompressed" pixel data is about as efficiently stored as if it were in a compressed PNG. **Edit:** 4-level palette = 64 (4³) colors. Plus transparency = 65 colors.
Well, I said there's no reason for a component to be mounted first, so technically you can use `componentWillMount` (it'll get fired before it's mounted, a lil bit faster). Extra bonus is that `componentWillMount` gets executed on the server so it makes the whole server side rendering easier too.. but it's still reeks. Ideally, we'd use Relay/GraphQL or Falcor. It was kinda made to counter this problem. In the meantime, there's no solution I find good for this. Maybe put some logic in the route app handler to execute the actions, but that stinks too. 
[Tyler McGinnis' React.js Tutorial](http://tylermcginnis.com/reactjs-tutorial-a-comprehensive-guide-to-building-apps-with-react/) isn't finished yet, but I find it to be the best resource I could find for free. If I remember right there are React Router changes coming and he is waiting for them to release before he starts on that part, but this is a great place to get started.
I would recommend the O'Reilly Head First series for any topic they cover, including JavaScript. http://shop.oreilly.com/product/0636920027065.do
The same way everyone else said the last one hundred times this question was asked ... on reddit ... today ....
It gives a great overview of Asynchronous JavaScript. Thanks for sharing.
I recommend buying a JavaScript audio book, and just listen to it with headphones on while you sleep. By morning you should be an expert developer, but be careful because some people find that afterwards they can only speak JavaScript. That's temporary though and should pass in a few days.
Client side JS actually does allow for multi player using WebRTC. If you want to go a bit further, Node.js supports UDP sockets and other things you'll want for a multiplayer game. The module pattern is a great pattern to use if you're trying to organize your JavaScript code. There are many frameworks, libraries, and other systems that will do this for you. Choosing one can be hard sometimes, but since you're doing everything from scratch, you could even roll your own. My personal favorite is browserify. It lets easily define your dependancies for each module, and each file is a separate module. The downside however is that it needs to be "compiled" for the code to run in the browser. I'd start by looking up the module pattern in JavaScript. It's used everywhere nowadays. Also I've never made a hex grid game myself, but I loved reading through this: http://www.redblobgames.com/grids/hexagons/
I've used SEO4Ajax a few years back -not impressed ended up writing my own. User agent detection is a cheap hack to work around a problem that can be solved *properly* using server side rendering the first page. I'm not saying SEO4Ajax isn't a handy tool, just it's a hack. Also not suitable for deploying/managing on thousands of websites. 
The animate function of jquery gets a forth parameter which is on complete function, you can use it to see which fires first. Here's an example using your code http://codepen.io/yuvalsaraf/pen/zGQLWz
Here's a good place to start: https://github.com/enaqx/awesome-react
&gt; For e-commerce these days Amazon is the most important channel, Adwords is second, SEO is a concern -- for most store owners it's seen as FREE money. A vanity front for Amazon and EBay may actually be a viable business, but it is not a representative of a major brand that can grow independently. This screams of mom and pop store. Major brands sell their own products directly. They often own their own physical storage and sometimes even own their banks. &gt; Incidentally explaining to pissed off clients that SEO isn't important anymore simply because my JS framework sucks donkey balls at SEO is the least favorite part of my day. That is putting the cart before the horse. The means to access and interpret content of the final rendered result is irrelevant to the technology behind it so long as it is written correctly. A major failure of weak architecture is to over emphasize the importance of the web application. Content is king. Smaller and distributed applications better achieve this.
I don't like jquery. Why not use pure javascript to do something like var horse1 = document.getElementById("horse1"); var horse2 = document.getElementById("horse2"); var h1 = 0; var h2 = 0; function race() { h1 += Math.floor(400 * Math.random()); horse1.style.left = h1 + "px"; h2 += Math.floor(400 * Math.random()); horse2.style.left = h2 + "px"; if (h1 &gt; 1000) { alert("Horse1 wins!!!"); reset(); } else if (h2 &gt; 1000) { alert("Horse2 wins!!!"); reset(); } } function reset() { h1 = 0; h2 = 0; horse1.style.left = h1 + "px"; horse2.style.left = h2 + "px"; } ?
If you want to make that for the experience of making it, go ahead and do it. Every bit of code you write is a learning opportunity. Understand that it's probably been done better than you could do it, and learn from those existing resources. Put your code up on Github and release it regardless, it's always good to have more example code out there and it'll give you the opportunity to get feedback. Then, when you see a hole, fill it. Find something you truely see as difficult, abstract it, and make it easy.
I second this, the chapter on Flux is very nice and is where I got it to click.
I don't think it was ever claimed they were the first. And I would agree they're not. I'm not a big fan of: &gt; Asynchronous programming, as we know now in JavaScript, can only be achieved with functions being first-class citizens of the language: ... "only" is out of place to me. Its not the _only_ way to do it though it is common for functions to be passed around this way in JS.
You can manually tweak the cache using your own live data update implementation (websocket, push notification etc) but out of the box falcor won't change the data out from under you if you're just using the HTTP data source adapter. You can set reasonable TTLs/expirations on each data path so that when you try to access something that has expired it will go over the wire.
the cars drive around corners with the same speed like on the open road, they need to slow down there
Netflix has been using it internally for at least two years.
You are maybe talking about another service? Indeed, we don't rely on User Agent sniffing for bots that support the Google Ajax [specification](https://developers.google.com/webmasters/ajax-crawling/docs/getting-started#3-handle-pages-without-hash-fragments) (i.e. Google, Bing, Yandex, Seznam, Qwant...). From my point of view, I think that server side rendering is overkill to solve the SEO problem, whereas a service like ours can solve it for a modest price, compared to the price of an engineer trying to render its SPA on the server. Moreover, as far as I know, a library like React was not primarily designed with this use-case in mind, and it also sounds like a hack. For your thousand of websites, I am pretty sure we can find a way to simplify their management with our solution ;).
Thanks Kotojo! You're correct in that I'm waiting for the router. I'll get the next post out once they're out with 1.0 (which should be very soon).
Probably because this bit is wrong: $.when(prefs, drafts, snippets, config) it should be $.when(prefsFile, draftsFile, snippetsFile, configFile). Here's a working sample (substituted setTimeout for readfile): function read(file, Deferred) { setTimeout( function () { if (file == '1config') { console.log('failed'); Deferred.reject(); } else { Deferred.resolve({ data: file }); } }, 100); } var prefsFile = new $.Deferred(); read('prefs', prefsFile); var draftsFile = new $.Deferred(); read('drafts', draftsFile); var snippetsFile = new $.Deferred(); read('snippets', snippetsFile); var configFile = new $.Deferred(); read('config', configFile); $.when(prefsFile, draftsFile, snippetsFile, configFile) .done(function (prefs, drafts, snippets, config) { console.log('prefs', prefs); console.log('drafts', drafts); console.log('snippets', snippets); console.log('config', config); }); 
Oh... and you probably want to do a .reject if the readfile fails with an error. Could your app/code proceed without the requested data? Supplying an empty object smells wrong to me... but maybe it works for you.
I feel I should point out my library [bluebird-co](https://github.com/novacrazy/bluebird-co), which uses the [Bluebird](https://github.com/petkaantonov/bluebird) Promise library to handle coroutines much faster and easier than tj/co can.
&gt; Please let me rant just a bit. Sure, all you want. Just don't expect me to read it.
Pretty nifty.
Only problem, is what I want to make somethimg truly useful. Just to get enough challange, so I can keep myself motivated. ( it sounds stupid, I guess, but, whatever )
How on earth does array.map blow people's minds?
Not at all! Wanting to contribute back is a crucial part of the open source philosophy. It's very possible you build something superior to that's available. Is there some shortcoming you see in the current offerings that you can fix?
I m also really glad, and it seems even easier than in C#.
Same here, and it's mostly "straight-up low level javascript" since the enterprise companies all seem to have legal departments that haven't figured out open source licensing, so it's a pain to get frameworks approved.
The sound is horrible :(
&gt; I love JavaScript okay, I'm with you. &gt; it has a beautiful syntax, it’s intuitive. HAHAHAHAHAHAHAHA
Then I guess I'll drop [Promises: The Extension Problem](http://blog.getify.com/promises-part-4/), which the author referred to, and which argues (successfully, in my view) that you shouldn't use Bluebird, among others.
The code's on [GitHub](https://github.com/DBMods/forum-extender-plus) if you're curious (the .user.js file), and the rest of the code is a mess of unorganized-ness that needs to desperately be rewritten. Thank god that's what I'm working on over in the development branch.
Looks great, but is it open-source? Can't seem to find anything on the website.
It took me quite a while to realize "Flux" was what people called it when their apps were simple enough when they could get away with stuff like this.
Boo hoo. Javascript programmer must earn his pay. Story at 11.
It's not open source at this point. 
Martin Kepple's is ok _if you haven't seen it before_. Sound is specially bad in this one, though. Lea Verou's is good. Maybe a bit too specifically focused, but interesting in any case, imho.
Cory house has a really phonomenal video series on pluralsight. I learned react in 3 very long days. [Building Applications with React and Flux](http://www.pluralsight.com/courses/react-flux-building-applications)
Awesome work!
I'll look into browserify; at first glance it seems like the tool I need. I'm using PHP for backend so I don't have any experience with node.js or any other backend JS library :( They are on my TODO list, but I'm not sure this is the project for it, though it might as well be... 
You might be interested in the D3 library: http://d3js.org/ 
I wouldn't be so sure about the stock ticker thing. Falcor is based on RX observables, and in the [tutorial that Netflix made for bringing new developers up to speed with RX and observables](http://jhusain.github.io/learnrx/index.html) they actually use a real time stock ticker as an example. The guy who wrote that tutorial is the #3 top contributor to Falcor, so I'd think that the same ideas present in that tutorial would likely be represented by Falcor as well. This is just trying to put 2 and 2 together though, I haven't really worked out how you'd do that with Falcor...
Elm is a really nice language to work with. Pretty much everything works out-of-the-box, and has a great developer experience. Static typing without the problems of Java is really nice too.
Will check it out, thanks. When did Ramda start to go downhill? Just started using it myself and I don't see much discussion about it. Any links would be great.
To be fair, as someone who doesn't write C++, I have heard a lot of bitching about Boost.
It frustrates me to see generators described as "asynchronous." Stop it.
Is there a way to use compilers such as Coffeescript? 
This is misguided. .NET isn't so much a framework as much as it is an official collection of libraries. I'd even call it a "standard library," although it is huge. It's not *really* a platform, but what is a platform anyway? Now, if we're talking about the .NET Framework as branded, then we're talking about much more than this; now we're talking about things that don't make sense for JavaScript to have, and things that JavaScript already has. Node.js has a standard library as well, though it is much smaller. Browsers have standard libraries. Node.js is a runtime (contrasted with the .NET Framework CLR). JavaScript has multiple runtimes as well. JavaScript doesn't need language interoperability, which .NET has for C#, F#, VB, and others. If anything, in this regard, that JavaScript is lacking, it's a standard set of practices that can guide this standard library.
Seems that problem mostly goes away if you do var BPromise = require('bluebird'); rather than var Promise = require('bluebird'); IMHO, Bluebird is so much better than native promises in so many ways (performance and sane error handling are bigger wins than the syntactic sugar) that it can't be ignored.
This is a good point that should be clarified. Although Falcor does use Rx observables, it doesn't give you updates on the model. With that said they've left the door open to adding this kind of thing in the future without needing to change much of the api. Currently the observables coming back from the falcor model are cold. To be clearer, stock tickers change so often that caching like Falcor provides has a bit smaller benefit compared to other apps which might be more static.
There should be the opposite of gold. Like so you can pay money to reddit to worsen someone's experience. There are situations where that feature would be a nice addition to the site
I mean, I have all of my controllers in one file now in my "jQuery spaghetti" code. I looked at what it would have taken to switch my web app (large, I think I'm close to 3mb of bundled javascript, non-gziped) to React + Flux. It looked like it would have been a HUGE time expenditure, resulting in 1.5x-2x more code, using big, bloated libraries. Only thing I would have gained was virtual DOM diffing, and my app is mainly table based. I wish I was wrong so I could use all of these new cool technologies.
The 'XML all the things!' movement seems to be back in full swing (only difference is that we now call it JSX) Guess we never learn as an industry.
Smooth animation can be achieved by simply using transition:1s; css property:value, or similar. And yeah, just saying I don't like it; not saying he shouldn't use it if he wants to. :)
I hope something turns up for you because I've found the webpack documentation to be pretty lacking, currently. I really do like webpack and am using it in my largest production app, however, I am still very in the dark on some of the more 'advanced' uses such as hot modules.
Apatche, MySQL aren't part of PHP. They are separate tools that can be replaced, or used in other environments. These tools can also be used with Node.js, or any other language that has the ability for the api to access them.
1. You wrap the element you want to link in a `&lt;a href="#seemore"&gt; ... &lt;/a&gt;`. 2. You add an element `&lt;a name="seemore"&gt;&lt;/a&gt;` where you want to go. Btw, you're probably better off asking this stuff in [/r/html](https://www.reddit.com/r/html). This is not even JavaScript related.
See also [Meteor.js](http://meteor.com).
&gt; well js is interpreted You're wrong (when it comes to v8 and most modern js engines) https://developers.google.com/v8/design?hl=en#mach_code
Well still, as of now the native Promise kind of sucks. I mean, it's not special in any way just because it's bundled with the JavaScript engine. In V8 it's actually defined in JavaScript, before user code is ran. Why they didn't just port Bluebird over to the native library I'm not sure. Also in my example, even `Array.prototype.sort` is defined in (mostly) normal JavaScript. You can see the source in the V8 repo. It's basically the same insertion sort and quicksort combo as every other standard library uses. I guess it just comes off to me as silly to want to preserve the "purity" of a JavaScript engine instead of just doing the simple thing and overwriting native stuff with better implementations when they are available. Granted, I know exactly what I'm doing with those. Heck, I read the V8 source code for fun. So maybe it is good advice for normal people to keep that purity. 
Why is JavaScript sub-reddit speaking about another programming language?
Hmm, that's a good point. That was already seen with ES6 a little bit. I mostly work in Node/io.js, and almost everything on the browser is taken care of by Babel beforehand or, using React.js, very declarative and without any complex async stuff. It's only on the backend that I go really crazy with things, searching for the fastest way to do everything. I know ES7 is proposing native async/await syntax, but you would only be able to await a single Promise, not any complex stuff like my lib or even co does. Coroutines using generators and yield are a hack anyway, so I highly doubt it would become standard. 
I have the exact same thing. I sort of liked the Spartan basics... 
Or any browser. Why does it have a spinner?
Github says the last update was december 2013.. Anyone know if a newer variant of this exists?
actually that minimum 4 ms timeout is only according to a spec. In V8, setTimeout(fn, 1) works as expected only with 1 ms timeout.
# connectemall.JS Coming soon to Node.io.min.js - connect all your stuff using pure javascript. Want your TV and fridge to greet with each other? It's simple! var fridge = connectemall.addDevice('fridge','BrandName Fridge pSux-null'), TV = connectemall.addDevice('TV','NoBrand TV 3'); connectemall.connect(fridge,TV); connectemall.listen("hello").response(x=&gt;this.send("oh hy there").to(this.sender)) connectemall.device(TV).send("hello").to(fridge);
Only shortcomings are l10n / i18n - and whenever I find something what needs contribution, I do that, but I guess what doesn't count, or does it?
Uglify had something similar iirc, but it slowed down builds quite a bit.
⌘Z is simply undo, so it will only reopen it if that was your last action (if you filled a form after that, it will undo that). 
I'd say give [Redux](http://rackt.github.io/redux/) a shot. https://www.youtube.com/watch?v=xsSnOQynTHs 
👍The docs answer a lot of questions most people have about Flux when they first start out, too, which is nice.
It's just like real life. That's how people drive where I live anyway.
Which TBH is often more than enough! However I have been spoiled for using Chrome and I wanted infinite tab undo for Safari.
Whenever a recruiter calls me about a COBOL job it always pays over $100K because it's so hard to find someone who actually wants to do it. :o)
I actually have tons of javascript library ideas that I just don't have the time to implement. Next time you build an app, try to notice what is particularly annoying or time consuming. Write that down and try to see if other people are having trouble with it as well. Have you ever released an open source codebase before? If not, I wouldn't worry too much about it becoming really popular. I would just focus on genuinely fixing your own problems.
Apache is still very much a good choice for any webserver regardless of which language the site is written in, just as PHP is fully capable on running on any other alternative to Apache. Yes, the famous LAMP stack is what most PHP devs are probably using, but there's no reason you can't swap any of those letters out, or even use multiple ones in parallel (e.g., using multiple languages for the back end).
As an update, adding a single 5 line component (in it's own file) adds about 2kb to my babelified minified bundle. Tried Browserify with babelify and it jumped to 9kb total instead of the 5kb with web pack! This are huge file sizes for such a simple codebase of 2 React components. Does anyone else have experienced this?
"I explore the possibilities and try to envision a future where the front-end developers are in charge of the servers that serve their own front-end code." You mean full-stack developers? That exists now.
My understanding is that hot loading is intended to be enabled by webpack loaders, not something that you put in your application code. style-loader and react-hot-loader are the two I use that definitely support it. CSS and React components will reload without refreshing the page. Enable it by adding --hot when running webpack-dev-server and including react-hot-loader for your React component files. I'm not sure if there's a way to enable it for regular ES6/CommonJS modules or arbitrary code. You can see the hot loader code in these source files. [style-loader](https://github.com/webpack/style-loader/blob/master/index.js) [react-hot-loader](https://github.com/gaearon/react-hot-loader/blob/master/index.js)
1995 for me.
I have this odd feeling that this JS framework/libraries thing is getting out of hand
I was making a oblique joke regarding your the value I felt your comments and attitude brought to the discussion. And I think /u/irrational_design already [covered it](https://www.reddit.com/r/javascript/comments/3hfs9c/the_evolution_of_asynchronous_javascript/cu7gp9h). But we're on a coding forum, so let me elaborate further. Let's suggest, for the sake of argument, that I am, roughly, at the same skill as you as a programmer. Again, for the sake of argument, let's say you and I would be judged as equals. However, let's say we know different things. There are programming things and techniques you know that would blow my mind, and there are things I know that would blow your mind. It doesn't benefit either of us to allow distain for the others lack of knowledge enter the discussion, we are two of differing knowledge and posturing and attitudes only distract from the purpose of information exchange. And opinions and feelings are an important thing in this information exchange. My feelings and attitudes about a technology are relevant. If lay out an enormous rant and say all sorts of bad things in all sorts of colorful ways about visual basic but treat you with the utmost respect, you may file away that piece of information and correlate it with what others have said, and thus form important opinions on your own as to what the community at large feels about a particular technology. If I say all sorts of bad things in colorful ways about visual basic, and about you, and your lack of knowledge, your likely to conclude I'm an asshole and stop engaging in conversation. Which benefits neither because now we don't learn from one another. Perhaps I had some really useful valuable insights to offer but why would you listen if my attitude was offputting? There's lots of other people on the internet and it's generally preferable to deal with nice ones when possible. The same logic works with people of asymmetric skill levels. When I learned to check my ego at the door and deal with the person as I found them. Their a junior developer out of school and I've been doing this for 30 years? *shrug* so what, statistically they probably have more to learn from me, but that doesn't mean I can't learn from them. They know somethings I don't but if I'm an arrogant fellow then they'll not bother with me. Or perhaps they will, because I'm their boss, or I'm the only one who understands the device driver code. But I gather a reputation, both IRL and online, and it follows me around in various ways. 
If the two things you want to have "in an order" are actually independent and unrelated, I'd argue you make code more confusing by artificially forcing that into a flow control mechanism like Promises. flow control is when step 2 is dependent on step 1. The thing most people seem to miss is that ordering itself doesn't actually guarantee a notion of dependency. There are many independent things which are not actually appropriate to be racy in their ordering. &gt; Least Astonishment, people! How is saying "let 1000 and 999 randomly order themselves" less astonishing than saying "999 should always come before 1000"? That's like saying "1 + 1 = 2 ... well, actually..." Anything that follows is, by definition, going to be more astonishing.
Man that sentence is full of webscale words that /r/programmingcirclejerk would have a field day. 
As much hate as nodejs gets, its really easy to build *small* applications that have 5-10 restful endpoints for single page applications. Things get up and running SUPER FAST. (like 5 lines to get a static file server running.) I do a lot of .NET stuff lately, and the context switching totally gets me, especially because C# supports type inference using the var keyword. 
I did read what you wrote, I was simply saying that nodejs isn't a webserver. I think you have a miss understanding of what that actually is. Yes, nodejs can process http requests as part of its API, but without actually programming an http server first, it is not a webserver. Hope that helps, and is a bit more clear.
Oh cool I just started writing React + webpack and friends. Thanks for the link!
Vue is great, it's a very unopinionated, and purposefully under-featured framework for creating simple databinding with lots of options. I like it because it can be slapped onto a existing application, or you can wrap it in other tools and create a full-fledged SPA. I'd say the closesest thing to is it Knockout, but Vue is much simpler to write for, has less gotchas and better featuresets. Check it out if you just don't have a good reason to use something like Ember, Angular, or React, or if you just don't buy into their architecture decisions.
I find it very interesting to think a bit further than the technologies we have today!
It is stuck indeed, not scrolling. Besides the jquery is logging an error.
Edit 2: works again.
well.... Javascript (JS) is the language in question, jQuery is a library for the language. Learn as much vanilla JS as possible and dive into jQuery once you understand common JS patterns.
Meh, almost every single "full-stack" developer I've ever met is back-end developer that does some front-end. I've rarely met anyone who can do the whole stack incredibly well and almost always they're lacking on front-end experience.
Don't put a space after "Java" when you are talking about jQuery or Javascript. It's like fingernails across a chalkboard. Java is to Javascript like Ham is to Hamburger. Here is a great resources either way you decide to go: https://www.youtube.com/channel/UCVTlvUkGslCV_h-nSAId8Sw 
Good thing Vue has been around a while!
I did not watch this video, but the answer is obviously: it depends. You can build an API that is meant to be consumed by a single application. You will get lots of efficiency and control over it, but you lose flexibility. It's up to your project to determine the nature of your API, and the expected consumption of that API. I'd reckon that almost always, you'll want loose coupling, not tight coupling. You'll want to build a backend that is not concerned at all about any one specific consumer. And this is why you'll often have front end and back end teams. Separation of concerns!
I imagine all these major systems written in this. How can you run a financial system on these arcane incantations?
Lots of front-end devs pretending to be full stack now thanks to Node too. Nobody is going to be an expert at both, there's just too much to know and keep up with. But the reality is, you very rarely need someone who is incredibly good. Few businesses live or die by having a top notch developers or not. The value in a solid full stack dev is they tend to have a better big picture of things, especially if they're decent at UI/UX.
Nice, thanks for introducing me to that sub.
Sure, but not everyone uses Chrome. Besides, 10 seconds to go through only 10,000 items is way too long.
He wants to fudge pack a full rack of full-stack.
Is this as massive a change as from 2-3?
Ok there, this story of my pain in the ass ended without glory: found [this](http://alvarotrigo.com/pagePiling/#page1). Enjoy.
Maybe you should try using [Rubber duck debugging](https://en.wikipedia.org/wiki/Rubber_duck_debugging) in the future, I find it a nice tool sometimes. It can be used for finding the solution to problems like this as well, its just the act of formalizing the needs of the task.
Yes, but not in the way your code is written in the main. Most classes haven't changed etc, notably the grid is the same. There are some small changes, e.g. .input-lg is now .form-control-lg. and form-group-* is now form-control-*. http://v4-alpha.getbootstrap.com/migration/ has more info, of course, this will change as time goes on, but the aim looks to be that you can just drop in Bootstrap 4 and things will work fine.
The idea that setTimeout(fn, 1000) means 1s from start of turn (which might be in the past depending on workloads) not 1s from now seems questionably useful. It certainly does not seem safe to replace the global setTimeout with this implementation - it is not unreasonable to assume that setTimeout(fn, 1000) means that there will b at least 1 second for other computations to take place. I bet there is lots of code that depends on this.
Since you're using JQuery... jQuery.camelCase("hello-world") // -&gt; "helloWorld"
I only need to fetch the JSON once. I need to convert the output to camel case so I can do something like this: $(appHeader).addClass('test'); As naturally this doesn't work: $(app-header).addClass('test');
That's probably true, and the removal of IE8 is a big step forward. But serious question: does IE9 have *that* many compatibility issues that are solved by jQuery? (Speaking in the realm of jQuery exclusively, so basically DOM, animation, and ajax.)
= is assignment, == is equality check. Your `if (arr[0] = "HELLO")` means "if the string 'HELLO' was successfully put into into arr[0]", not "if arr[0] is the string 'HELLO'"
Your mistake is the "=" instead of "==", which is assignment instead of comparisson. What you need to consider is that: - the title may have spaces, so instead of checking if the inner IS equal to a string, check if the innerHTML CONTAINS a string. - the equality operator for strings is case sensitive, so "Hello" is not equal to "HELLO". There are more things to talk about, but I figure you are at the biginning, so it's not yet important to know all the details. 