Learning and growing is all about getting out of your comfort zone. Nowadays pure functional languages seems to be the golden star that many programmers chase to reach a higher level of expertise. However I find very hard to push my boundaries looking just at the technical part and things aligned with my taste. One could say, for example, choosing a language which represents a culturally and historically different point of view. Something which I do not really like but I do understand it is different and important. What could be the "culturally" opposite to Javascript? Enterprise! Something like for example, plain old Java. If you believe that studying a language which has failed so many times and people keep using is amazing, then it might be a good shot, but only if you feel with experience to be critical and learn from the experience of those failures. 
First identify a tool or project that you use and are interested in, and then see if there is some way that you can contribute to it. Writing some docs or a blog explaining how to do something are low entry but useful ways of contributing. 
ITT: The two languages I use because they are the best. I know this because I of course wouldn't use bad languages. Doesn't matter if they are unpractical for anything OP will do in his webdev work and don't really provide OP with any useful except passing the time learning a language they'll never use.
Indeed. Reminds me of this saying: "If you don't understand recursion, go back and read this sentence again". I'll go edit my "map" definition to be more clear. I really just wanted to push the reader away from just thinking of "map" as iteration over arrays. Thanks for the input!
Yes, I was a bit pushy with the ES2015. Now that you've played with the code and grasped it in different ways, do you find the ES2015 to be nice though? I think it's a question of habit and time with it, and I love that's it's more compact. But I will add an ES5 version of `Maybe` in the blog post. To be clear for others, the `val =&gt; ({});` just means the function takes `val` as a parameter and returns an object. Furthermore, you don't need to describe a property as `val: val` in ES2015, just `val` will do without the redundancy. Thanks for the feedback!
Sooo … That's exactly the same tutorial as the one on angular.io …
A professor in my college used to say a good programmer must know 3 languages: * C * Java * LISP If you know these three, all the basics are learned and you can very easily learn any other language. 
Interesting solution. I've been using webpack with the define plugin (https://github.com/webpack/docs/wiki/list-of-plugins#defineplugin) to achieve the same!
Another example: &gt; tab = [2,3,4,6,1] [2, 3, 4, 6, 1] &gt; Math.max(tab) NaN &gt; Math.max.apply(null, tab) 6
Disclaimer: i already know SQL, PHP and Perl so will ignore those. Of them SQL is very nice but alone won't make you more employable since it typically works as part of a backend stack. Definitively one of Haskell / OCAML / Scheme / Elm etc to learn a native functional language well. They are used a lot in the finance industry. The other I don't know. C++ or Java because I encounter them all the time in my work and a lot of concepts come from there, plus mobile. Python or Ruby because they are useful in doing all sort of stuff. F# Go Elixir Erlang or Scala to see what the fuss is all about.
Awesome, I was more suggesting it to you directly than OP. You're spot on for OP though! 
That's not the actual source — jQuery is not maintained as a single giant file / big ball of mud. [You want the actual source repository](https://github.com/jquery/jquery/tree/master/src), which is far more modular. The file you're looking at is a generated file. Most jQuery functions hang off of the `jQuery` prototype, which is also `jQuery.fn`. Anywhere that you see something using `extend` to add something to `jQuery.fn`, that's exposing a public function. For example, if you look in [`event.js`](https://github.com/jquery/jquery/blob/master/src/event.js) you'll find the event handling stuff. `on()` is defined as a private function, and then made public toward the end of the module: jQuery.fn.extend( { on: function( types, selector, data, fn ) { return on( this, types, selector, data, fn ); }, ... 
Okey, so to find the answer to this question, we have to know how it works in the specific engine we're working with.
You're right, I did miss your point. Thank you so much for clarifying.
You could also look at [the first version of jQuery annotated by John Resig](http://genius.it/5088474/ejohn.org/files/jquery-original.html) Not all what you see in there is best practice and lots of it has most likely already changed in current versions, but I think it's a great place to see that the library we use so often also began as something smaller :)
[Secrets of a JavaScript Ninja](https://www.manning.com/books/secrets-of-the-javascript-ninja) is a book co-authored by Resig which goes into a lot of the thinking *behind* some of the decisions made in jQuery with examples. It is very good.
C# is a nicer I agree, but dealing with VS, so infuriating.
If it's not too much hassle, could you provide JSFiddle example?
not my area but could you expand on the last statement? why are big data database systems unsuitable for large online applications?
You've admitted you're a beginner, so honestly you shouldn't care about the answer to this question but you're ignoring advice that says that. The only people that should care about this are developers within Google, Mozilla, Apple, etc.
I disagree with your comment, and strongly disagree with this community's tendency to use these two concepts ("micro-optimization" and "engines are improving") as excuses to disregard a train of thought. How much time something saves does not tell you if it's a worthwhile optimization. It's how much time it saves, relative to how fast the piece of code needs to run. What we're talking about here isn't a single invokation, it's potentially a significant fraction of *all* invokations. That's extremely low-level and likely to be an extremely hot code path. You may as well say going from a calculator to a computer is a micro-optimization because they can both perform a single computation in a negligible fraction of a second. And while it's true that engines are changing, you're mistaking this for an engine hack. It is not, it really is less work. `apply` causes the engine to create an Array-like object and iterate over it, while `call` does not create the object and unrolls the iteration. Engines may, in the future, get smart enough to make `apply` *as* fast, but no faster. And even if we're dangerously betting on this hypothetical future, it's still not preferable to rely on non-standard engine optimizations rather than write fast code.
To each and their own. I'd take VS over eclipse anyday. Not familiar enough with intelij to make an opinion.
The way it was explained to me is that the code is interpreted in two passes. The first pass reads variable declarations and functions and then the second pass executes the rest of the code. So it seems like the second explanation is more correct, but the two passes concept was (for me, at least) a lot easier to digest.
Your wild guess shows your total knowledge of these things comes from reddit.
I wouldn't worry so much about which language to learn as focus on learning core concepts of systems designs for the back end. TBH your answer was kind of vague but if what you want is to expand deeper into the stack, you should worry more about learning things like object orientated programming, restful conventions, relational databases, object relational mapping, the nuances of http, etc. The next part is 100% subjective and is a personal choice. I like Ruby and Ruby on Rails as an intro to these things. Especially if you come from JS which is super similar to Ruby.
I know when someone doesn't know what they're talking about when they bring up Mono.
When Netflix is 40% of traffic, and that's a fact, your guess at how things work doesn't add up. But as one who guesses at things, you're pretty bad at it.
I'll just say everything you said about me (cause you're trying to make it about me) is false and I'll leave it at that cause responding to people on reddit is one of the stupidest things I do and I don't know why.
Apologies if what I'm saying sounds offensive, but if all you're doing in the other languages you code in could just as well be done in C, then *by definition* you aren't taking advantage of the unique features of those languages, and hence are wasting your time using or learning them. I appreciate that's not necessarily complimentary to you, but it's a direct, natural, unavoidable consequence of your own statement.
The main reason is to call a function with a different `this` argument. `apply` is also nice because you can pass it an array.
Embrace homoiconicity: Assembler + Lisp
That's really strange reasoning. How do you consider Rust having "just too many conceptual leaps to overcome" and not think the same for C, and ML. Second, why can't you overcome those? Are you really afraid of venturing out of JS? 
I'm not saying that big data database systems in general are unsuitable for online applications. I'm specifically saying that there's only one currently existing system that preserves normal DBMS query functionality, and that system has fairly high latency, and that latency tends to vary quite a lot. I'm talking about Hive specifically here, but I understand that redshift also cannot guarantee low latency if you use it like a fool for huge datasets. It can be optimized to provide better performance, though. The reason why is twofold: (1) standard DBMS semantics allow a lot of inefficient operations; and (2) Hive is built on top of Tez/MapReduce/Spark + HDFS, rather than being a dedicated distributed query and storage system of its own. On (1), the basic problem is that joining on arbitrary columns is expensive, and joining on arbitrary columns of tables which are not even stored on the same machine is doubly so. Some kind of restriction has to be made. One trade off (made by impala and other systems) is to only allow joins between tables held on the same machine. Another might be to only allow joins on replicated indices. Another is to basically not perform joins at all, just allowing queries to be filtered, and allowing clients to solve the join problem. On (2), Hive exists and deals with unlimited datasets. Making it an integrated, optimized engine requires much more effort. It would require a custom execution and data storage engine. 
Because R doesn't really have many advantages over Python at this point, but it lacks the library support and wide user community of Python. 
You're right, I probably phrased that wrong. My point is that from what I'm reading the OP seems to think it matters (for making his/her code faster, etc) and is ignoring that we're saying it doesn't.
[removed]
&gt; Anything can be done in C Of course but that's a pedantic non-argument. The point was: &gt;&gt; could **just as well** be done in C You can write an entire OOP system or runtime macro system in C, but that doesn't mean that either can be done in C *just as easily* as in a language with first-class support for them, or *just as well* by any random programmer as by the guys who design such languages for a living. When we're discussing the *relative* merits of programming languages, the fact that in the limit case they're all Turing Complete is a complete non-argument that people use to muddy the water and imply that all languages are *pragmatically, usefully* equivalent, as opposed to merely "technically". &gt; My point was that, too often, people claim the wonders of another language that only have a few extra arrows in their quiver which doesn't make it worthwhile learning or using. That's a valid point, but it's not what you initially said, so you can see how/why I misunderstood. My counterpoint would be that if a language even offers a *single* additional arrow in your quiver it might still be worth learning, and in my experience many languages actually offer significantly more than a single new trick or way of conceptualising a problem. Obviously (for example) if you know C++ then Java isn't necessarily going to teach you much, but if you know C then learning *Javascript* will teach you a lot (dynamic language, weak typing, prototypical inheritance, etc), as would Ruby (strict classical OOP and inheritance, message-passing style, blocks/comprehensions, etc), a Lisp (programming directly in an AST, functional programming style, runtime macros, etc) and plenty of other languages (Prolog, Haskell, etc) that I simply don't know well enough to enumerate the benefits of.
&gt; With Node.js, when you require('xxx') Node will return the same 'code' any time you require it. Not strictly true. While there is a module cache, you cannot *rely* on it - for example, a usecase where this would break would be having different versions of the same sub-dependency being required by different dependencies. I don't believe the cache behaviour is guaranteed either, so it may spontaneously break across updates. The only purpose of the module cache is to... cache. Don't try to use it as a state container - true singletons are not desirable anyway. [This](https://www.reddit.com/r/javascript/comments/3hucob/how_to_structure_nodejs_applications_with/cub5siu) solves the problem without causing those issues. EDIT: And hot-reloading development tools will destroy your state.
Haskell is used a fair bit for web development, which is one of its strengths. Erlang is not so common, but still has a pretty strong niche when it comes to massively concurrent and reliable systems. 
&gt; Key-Value stores are a bit of a different beast because they're so limited in the style of data they hold This is more apparent than real. There are systems where the key is a single value, but the value is a row. This means you can still join on primary keys efficiently, for example. Yes it's more restricted than a standard DBMS, but it's not a million miles off what you would do with an optimised database layout in an RDBMS. &gt; regular old RDbMS systems will not go away, and will continue to improve along side these document based systems. That's true. The reason why NoSQL is "the future" is really just that RDBMSes aren't optimal for a lot of common applications. You can basically always get more optimization by supporting only specific use cases. 
Your professor was clearly not very familiar with programming languages. Although Lisp is awesome, it's not the cutting edge of functional programming. Although Java is widely used, it's definitely not the cutting edge of imperative OO (Common Lisp, Python, Smalltalk, and C++ all have richer OO systems). C is not even a great instantiation of a low level language. Unless you're super old, C++ was already a better C; now Go and Rust are both much more interesting.
Sure, and it's always good to understand what happens "under the hood" when you're interested. However, in this case you've moved from asking questions about "Javascript" to asking questions about "the precise implementation details of any one of a wide range of javascript interpreters/precompilers"... all of which are completely transparent and irrelevant to the practice of writing good, efficient javascript. As a javascript developer there's absolutely no point in understanding this, because it will never, under any circumstances impact on your code in a meaningful way, by about an entire order of magnitude. As a browser developer or *javascript runtime* developer, sure - it might be useful to know the implementation details of competing JS runtimes or precompilers.
Yup! In favour of RDBMS systems though, most applications work well if not better on them I think a big thing about NoSQL dbs initially was their api support. It was a priority, the older dbs have caught up now. 
But it's MY point with the included point that C does it faster in a smaller space.
&gt; If I were to not stay current, there is no way I'd be able to apply my years of experience as a heuristic to any of the things my team suggests. You still have to evaluate naturally, but I would challenge the suggestions as to showing explicit benefits to the issues we are trying to solve. I am not saying ignore everything just that keeping up to date can be a huge time sink. Solve the problems of your customers, breakthrough technology is not always around the corner as it sometimes seems to be.
We agree on things more than our words may show.
&gt; most applications work well if not better on them I actually don't think that's true. A lot of what I see is tools that are built on RDBMSes, but don't really use them properly. Case in point: ActiveRecord pretty much never uses the database to perform joins. It might as well be using a key-value store. RDBMSes are great for lots of things, but there are relatively few cases where you need all of their features. 
Nice!
75% of web jobs aren't for porn either so where your number comes from can only be guesswork.
 &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt;src="https://raw.githubusercontent.com/goldfire/howler.js/master/howler.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function() { var sound = new Howl({ urls: ['c_note.mp3'] }); $('#test').click(function(){ sound.play(); }); }); &lt;/script&gt; &lt;body&gt; &lt;p id="test"&gt; CLICK ME! &lt;/p&gt; &lt;/body&gt; &lt;/html&gt;
For general programming I would learn: C: you learn how memory management, structs, arrays, and pointers work and these concepts will be applicable to how all languages work at the system level. Paradoxically, not having any OO concepts in C also helped me understand OO concepts, because you see all the difficulties that OO is supposed to solve. Clojure: a fairly easy intro to functional languages, and gives you an entry point to the JVM (including all of Java), which is an extremely versatile and powerful tool to have in your toolbox employment-wise. But it depends a lot on where you want to take your career: Enterprise business apps? Java and C# Scientific/big data analysis? Python + C Mobile? Swift + Java is the way to go. Games? C and C++ Stuff that may be useful concept-wise, but doesn't have a big employment impact: Haskell, Scala, Erlang Stuff that's pretty worthless both concept-wise and career-wise: PHP, Ruby, Perl 
No, I don't think it really matters. I'm just the kind of person that loves knowing about stuff on a deeper level. Since so many people are saying contradicting things about hoisting I found it difficult to see which explanation was true. People are explaining their version as a fact, but they're all saying different things. That's what got me confused.
thats not a language
It was just an example, I'm not actually worried about this. :) Just trying to figure out why people are contradicting eachother when talking about hoisting.
This may not be a satisfying answer, but the phrasing in the ECMAScript spec goes like this: * Let varNames be the VarDeclaredNames of code. * ... * Let instantiatedVarNames be a new empty List. * For each n in varNames, do * If n is not an element of instantiatedVarNames, then * Append n to instantiatedVarNames. * Let status be varEnvRec.CreateMutableBinding(n). Here's the [full nitty-gritty](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation) for the curious. As long as a browser fulfills this essential logic, then they can implement this however they like, and it may even be that Chrome/FF/IE/others each implement it slightly differently. Though, I highly doubt any of them do so by physically rearranging the source code.
http://benchmarksgame.alioth.debian.org/u64q/rust.html
Can you be more specific, it's not clear what you need 
&gt; What do you mean with "It works as specified."? There is a language specification which explains how it's supposed to behave: http://www.ecma-international.org/ecma-262/6.0/index.html#sec-variable-statement As far as the language's semantics are concerned, "var variables are created when their containing Lexical Environment is instantiated and are initialized to undefined when created". So, from the perspective of a JS author, those variables materialize out of thin air as you enter the function. If they are declared somewhere in this function, they exist. Variables are a bit more abstract than you think. In your code, they are rather concrete and refer to something very specific. However, they don't necessarily have a 1:1 counterpart in the generated native code which is actually executed. Even some objects might not actually be created. E.g. if you do some vector math, the compiler may decide that all those objects are a bunch of bollocks and just replace it with the bit of math you're actually doing. As long as the result is the same, you won't be able to tell the difference. A variable is a handle you use to refer to things. Declaring one of those is not an instruction to allocate anything.
Reason #9146 why I slap my head in disgust of most redditors. [To quote your own link:](http://benchmarksgame.alioth.debian.org/why-measure-toy-benchmark-programs.html) &gt;We are profoundly uninterested in claims that these measurements, of a few tiny programs, somehow define the relative performance of programming languages.
VS is the best IDE out there. I don't think this person ever used it professionally.
I'm curious if you work in sillicon valley. A lot of companies don't use bleeding edge technology. I have been looking at job ads a lot recently, here in Canada, and there are so many .net jobs out there. Not so many for linux. You absolutely have a point with linux running the internet, but there's a lot more to programming jobs, even webdev jobs, than just the internet.
You can add class names by adding { className: '' } to aoColumnDefs.. Don't know if that's what you mean?
The answer is both, the initialization happens during the hoist. If that initialization depends on other variables it will cause an error.
What benefit does learning objective c have other than the platforms it targets? If its to learn OO, Java or c++ would be a much safer bet. 
Right. But it does show that C is not always the fastest, which was your claim.
Yeah, my company was originally built on php and java, but we have been switching everything over to node for the past 2-ish years. I don't hear as much (in my area) about python in the way you describe it. Then again, my area is dominated by JS (home of ng-conf and react rally).
No I don't. It's my first time using it and I'm not that proficient in javascript. 
Haskell would be a mostly academic pursuit. Learning Haskell can make you a much better developer overall, especially when you primarily write javascript. Nodejs can handle most simple server tasks, erlang fills the gap when you need to build something like whatsapp, or a game backend.
Here's a decent mental model. Before the function is parsed, an object (closure) is created which contains things like a pointer to the function object's prototype, the `this` value, a pointer to the containing closure, etc. As the code is parsed the first time (before any of it executes), all variables beginning with `var` are added to the function's object/closure. All function statements like `function foo() {}` are compiled and classes are instantiated (function statements and classes are also added to the function's object/closure). After this, the execution starts at the top of the function and runs as expected. This model also explains how closures work and how they relate to garbage collection. When you have a function that returns a function, the invisible object (closure) of the inner function has a pointer to the invisible object (closure) of the containing function. Because of this, when the inner function is returned, the outer closure stays the same (the pointer doesn't change). When the inner (returned) closure doesn't have a variable, it follows its pointer to the next closure (object) and so on until it either finds the variable or reaches the global object/closure (or null if in "use strict" mode). The containing closure (object) continues to exist and isn't garbage collected because there's still a pointer to it in the returned inner function. Thus we understand that closures are special object and objects are special closures.
Is that the first error or last? I was reporting my first error. After the first error, everything else is a symptom. Don't pull the file raw off of github, use a local version and see if it works.
I love that I have a career in which "sweet trig, bro" can be said without it being a joke.
Yes it works now. Thanks!
 class MyClass { registerResizeHandler(){ window.onresize = this.onResize.bind(this); } onResize(){ console.log("Window did resize."); } } I don't know enough about your code to give a great example, but this is how I have been allowing methods within my classes to act as event handlers. Calling registerResizeHandler will bind onResize to the windows resize event.
Well you are right, I don't do ASP, but AFAIK Mono on Linux is generally [considered faster than Microsoft's .NET on Windows](http://stackoverflow.com/questions/2397700/mono-project-why-is-mono-faster-than-net).
Not sure if it's best way, but pretty simple to set up and reliable. Basically, you can set up a shared onLoaded() callback that the framework notifies once it's loaded. I say shared since typically you also need to wait on the DOM to be loaded as well. Inside the shared handler you could increment a load counter, that once it reaches the expected value, executes the remaining logic (i.e. your dependent code ) It's not a good idea to guess at a magic time value in which everything might be loaded, since that's not deterministic and can lead to all sorts of bugs. Also, it's not good for UX since most of us are impatient when waiting for a webpage to load, and a even a half-second can feel annoying.
Just beware, the arrow function only automatically returns if it's on the same line. let foo = () =&gt; 3; foo() // 3 but let foo = () =&gt; { 3; } foo() // undefined you need to `return 3;` in the 2nd example. Happy coding :) 
This might be a daft question, but if this isn't how you would do it on production (ie you're not trying to replicate production 100%), why don't you just load these scripts synchronously instead of async on dev? 
What I'd do is to iterate through the row ids and look for an id that's bigger than the new one, if you find it [insertBefore](https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore) the node, if not you can just [appendChild](https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild) to the table. Example code: function insertNewRow(id) { var table = document.getElementById('divTableId'); var newRow = document.createElement('div'); newRow.innerHTML = "hello" + id; newRow.id = id; var i = 0; while (table.children[i] &amp;&amp; id &gt; table.children[i].id) { i++; } if (table.children[i]) { table.insertBefore(newRow, table.children[i]); } else { table.appendChild(newRow); } }
&gt; There are far more web jobs in .net than there are for desktop apps. Now you are showing you are clueless.
That you think non-Windows firms are chicken feed companies shows you are clueless.
I've been following Mono for a long time, longer than I have worked in C# actually. Never once I have met someone who has production applications running in Mono. It's an interesting project but it scratches an itch that enterprise developers likely do not have.
Thank you for writing this incredibly insightful article. Javascript tooling should be discussed more often, and in greater detail. /s
&gt; If you want to write fast software, use a slow computer I've actually noticed this since I use a VM for all of my development. It's very restricted in memory and processing power, and I've noticed that a lot of stuff I've been working on is pretty slow with it.
Do you mean to say that this behaviour is not specified in the ECMAScript document? I hope you are not offended, but I do not like this sort of answer; you aren't the only person who answered like this. It sounds like you are saying "I do not know, I just know what happens," which is fine --- I myself don't know --- but you're wrapping it in the defence that the answer isn't relevant, which might even be true, but it casts a bit of derision back at the questioner, and isn't actually the answer. The answer is either (A) this is not specified in ECMAScript, or (B) the ECMAScript specification.
Can you elaborate? I don't do ASP, and I've only used C# in Xamarin and Unity3D.
Ah ok. I thought you were just trying to solve a problem you were having... Not experimenting :) 
Why would I be offended, it's an open conversation :) I answered like I did because getting into technical details of ECMAScript for someone new isn't really appropriate, but yes, it's not defined in ECMAScript. ECMAScript defines the language and _rarely_ touches upon implementation details (basically only when there are likely side effects of implementing it differently). Source: Have been on TC39 for 2 companies
you're asking whether it's acceptable to add 0.5s to every single page load when a developer is building the application? The answer is no. You want to reduce the time between writing code and seeing the results of those changes as much as possible, you are adding 0.5s of pain to something your developers do thousands of times per day. Solve this problem properly, then look into tools like browsersync which show changes almost instantly.
Thanks J-Ro - I will give it a try
Exactly. https://datatables.net/reference/option/columns.className
That's a lot to cover in 3 months. First, I'd probably decide between client/server. If you choose server, I think you'll learn more about vanilla JS - especially if you retrieve/transform data. If you choose client, of the stacks you presented, I'd probably choose React + redux (+webpack/browserify). Angular, while popular is not what I'd call idiomatic. While redux (&amp; flux in general) is a pretty idiosyncratic start point, again I think it's one of the cleanest architectures so you should be able to stick close to pure JS.
Well, if it's about employability, sure. But I'm subscribed to a plethora of language subreddits. Don't get me wrong, I LOVE JavaScript. I think it's an incredible language both for practicality and interest, and it's tied with Ruby for my favorite language at the moment. But if I'm going to recommend someone to learn 3 languages to learn programming, JavaScript would either be the 3rd or not at all. It's an extremely quirky language that bears only a passing resemblance to most languages that one could want to learn today. In my opinion, it's much easier to move from Java to JavaScript than it is to reverse that process.
OK - PART 2... also working with different code from here on another project http://www.javascript-coder.com/html-form/javascript-form-validation.phtml Now I just need to figure out how to = add post code *AFTER* the form has successfully validated. BTW: sorry for all the needed hand holding... laymen version... 1 - test here 2 - if success.... alert ("success"); - then add more code like... $.post('https://mysite.com/test.php', { password: pass, ...... etc. 3 - if fail - then alert ("fail"); Any Idea how to set this up with this code from this site? 
I think I'll write something about ng2 + ES6 soon. This one was aimed towards people who feel overwhelmed by all the change coming with Angular 2, and trying to pare it down to the bare essentials.
I can only really speak from my experience with optimizing pieces of code. And so far, `.apply()`, `.bind()`, `.call()` etc have never been the slowest parts. More often it's DOM manipulation, excessive looping (eg; `.map().forEach().filter()` vs `.filter().map()`, etc), or large garbage collection events due to excessive use of closures, etc. I guess if you're writing library code to perform lots of calculations, etc, then I could see it being an issue. &gt; engine hack Like I said; "it is *impossible* to tell if these types of optimizations will still be applicable in just a few short months." They may still be applicable 10 years from now. They may not be applicable with the next version of V8. Can you predict the future? No. That's why I prefer to stick with the optimisations I know cannot be helped by the engines (a different algorithm, reducing garbage collection events, etc).
I'm curious: why don't you also concatenate files for local development?
I'm excited about HTTP/2 too, but it's not quite that straightforward. If you're authoring a library as a bunch of ES6 modules, there's little benefit to shipping each file individually – and in fact there's a cost, because you don't know which additional files you need until you've read the `import` statements from the package's entry point (at least until you're using a server smart enough to push those additional files, which excludes all current CDNs as far as I'm aware). If you're developing an app, the equation changes – I agree. In any case, no browser currently has a built-in module loader, so you need to package your modules up so that they can run! Rollup is currently the most efficient way to do that.
I think it's important to understand more of what's going on under the hood. Specific frameworks are good to know and will help you more at work for sure. They come and go though. Understanding javascript will give you knowledge that endures longer imo and can be applied to places outside of client-side web development. 
I think you mean [this one](https://angular.io/docs/js/latest/quickstart.html), and it did indeed influence this post! That tutorial made me go "wow, angular 2 isn't that bad." But it's written as if you've never done JS before. Installing npm, setting up live-server, explaining how IIFEs work... All good stuff, but I wanted to write for people who'd been doing Angular 1 and wanted to try out v2 quickly and easily. I also tried to offer some exercises more meaty than just "change the text."
You're probably starting a scroll event by dragging. All JavaScript stops while scrolling on almost all touch devices. Put a touchmove listener with `event.preventDefault()` on the parent of the game board or the body to prevent the scroll from starting.
It's a solid write up! I'm just in that "learn es6" mindset
Neat
I've written my own little view library, it's really simple and you might learn from it: https://frzr.js.org Whether to use frameworks or not depends on the project. I have such projects, that I need full javascript approach and HTML templating (or JSX) isn't good enough. Having 100% control is also more flexible and tracking bugs is so much easier.. There is of course a learning curve, but learning frameworks is also a bigger process than many think. Getting started might be easier, but after you have a real project and get your hands dirty, things can get complicated.
Only good answer here Every language has good and bad use cases. Language hate or love makes you not see other languages in a good light. I use PHP for fast prototyping and quick sites. I am not a backend developer, but when I need that is my go-to language. And although I am a JavaScript developer, I don't understand the nodejs appeal. Anyways, choose the language for the job. Don't change the job for the language
Why obj-c instead of swift. Serious question, I don't use either
Some JS functions that I use all of the time: map, filter and sort. Sometimes useful: some, reduce, concat. 
this is the right answer/question leading to an answer and doesn't require any code hackery, should be higher up
True.
&gt; Installing npm No it doesn't explain how. &gt; setting up live-server Where? &gt; explaining how IIFEs work If the reader doesn't know what IIFE's are, he probably is too inexperienced to use Angular. Plus you don't provide anything else to learn Javascript. &gt; I also tried to offer some exercises more meaty than just "change the text." Such as "Show your name"?
Sorry, I was on mobile! https://egghead.io/series/how-to-write-an-open-source-javascript-library
He told you literally everything you need to get it working, and instead of saying thanks or asking follow-up questions because you didn't understand it, you just want him to do the work for you too? Lazy, dude. Here - I'll give you an additional clue: If you look in the HTML, you'll see several elements with the same "id" attribute - `forcecentered`. That's a problem because you can't have multiple HTML elements in the same page with the same ID - it's just not allowed, and will cause weird problems like bits of your javascript not working properly exactly as you've found here. This same ID is used in the javascript. If you change the ID of the second HTML element to something else in the HTML, then copy and paste the javascript that refers to `forcecentered` and change `forcecentered` to your new ID, you'll have both sliders working in the same page. There are cleaner/nicer ways to fix it, but this is the *simplest*, just to get you on the right path. Once you've got that working, feel free to ask follow-up questions... but people are here to help answer questions that are stopping you learning, not to solve your problem for you.
&gt; immature language. By your definition, every language is immature. Its different. It looks like C but behaves like scala. Its functional. It will trip you up. But its not immature. Its probably THE most used language. If anything, its ahead of its time.
Javascript is a very popular language and has a ton of libraries and frameworks. If you are at all interested in the future of pretty much anything to do with the web(and lately even expanding into the native realm), JS should be on your list of languages. With things like node, phonegap, and appcellerator coming out, JS is reaching further and further into hardware and becoming more relevant. At least learn Node, MongoDB (or any other noSQL database), and Express. You could probably survive without Angular. I am totally biased though(backend dev) so I don't know if id take my advice if I were you.
&gt; By your definition, every language is immature. I didn't give a definition, but there can be no argument that the library of commonly used javascript libraries has been exploding over the last five years, which is very rapidly changing the libraries, design patterns, and general coding skills that are needed to be a javascript developer. Here's a great recent thread on this: [https://www.reddit.com/r/javascript/comments/3pvpsw/throwaway_because_im_curious/](https://www.reddit.com/r/javascript/comments/3pvpsw/throwaway_because_im_curious/) Obviously the core language of javascript is well defined, and mature, but my point is, as someone who has been a web programmer since the early 2000s, any javascript programmer needs to be constantly learning new packages to stay on top of "modern javascript." This is due to the fact that the core js language doesn't have much of a library that allows us to quickly do the higher level things that most programmers need to do on a day-to-day basis. &gt; Its different. It looks like C but behaves like scala. Its functional. It will trip you up. But its not immature. Is this web programming 101? None of that has to do with a language's maturity. &gt; Its probably THE most used language. Since every web browser supports it and every web site uses it, this is pretty obvious. But that explains why developers are so interested in evolving the way we use it with newer, more powerful libraries. &gt; If anything, its ahead of its time. It was definitely ahead of its time in the mid 90s.
No end; we're literally just messing around and trying different things. 
Did so, compared "normal" situation where I just move the player in a straight line, and "buggy" one where I try moving in circles. Main differences spotted is a "v.handle" from jquery.min showing up when I move the finger arround, taking 700ms out of 4s - its much less that the actual freeze time (as long as I move the finger the screen is basically frozen, so I thought /u/sakabako had a good lead). 
Im not sure what Phaser, Cordova and Crosswalk are. What are the benefit of using those ? Im just using Notepad++ and doing all my stuff by hand because I kinda like it.
Build a dev tool that also loads the files in the right order and starts them properly. Or, if you use AMD or anything close to it, then this is a solved problem: find an existing dev tool that loads modules and calls them in the right order. Really there's no reason to hack your dev workflow with 500 msec delays for something that there are so many tools for!
 Here is the correct way to write it (This is possible ES2017 syntax. It may never be approved though) class demo { onResize = () =&gt; { console.log("weeeee"); } registerHandler() { window.onresize = this.onResize; } }
But this is not vanilla right ?
Ah okay... not too beautiful, but short and should work fine.
Not sure why this question is always framed as a "this or this" situation. You should learn both. Learn enough JavaScript to understand what your framework of choice is doing, then learn more about your framework, and then learn more JavaScript. Repeat until mastered. TLDR; Learn JavaScript &amp;&amp; (AngularJs || React || Ember || whatever)
It's vanilla ES6, but it does assume that a "debounce" function was imported. I added it for the sake of having more unrelated stuff which would muddy my class even more. http://jsfiddle.net/8b6uyw3m/ Kinda like that, for example.
What I don't get is why all the effort on these new tools rather than focusing on improving existing tools? What is so special about Gulp that justified an entire new project rather than submit improvements to Grunt? Plenty of other tools out there change their config formats over time and maintain backwards compatibility for some time. 
Likewise, I don't want to have to clutter my system with 2 or 3 different package managers and countless build systems and libraries just to do some javascript development. The tools never have time to mature before someone goes and reinvents the wheel again and everyone hops on the bandwagon. 
hm, I don't see one for me.
Some things to consider: * Assigning the `window.onresize` callback prevents others from using it, or if they do, you're either overwriting their handler or they're overwriting yours, depending on who sets it last. `window.addEventListener('resize' ...` is a safer way to handle the event without others stomping on yours or vice versa (with only a small possibility of `stopImmediatePropagation()` but that's not really something to worry about). * Though you can easily remove the `window.onresize` callback by deleting it or setting it to null, to remove a handler defined with `addEventListener`, you'll need the handler function reference given to `addEventListener` to unset with `removeEventListener`. If you define the handler inline using something like: window.addEventListener('resize', () =&gt; this.resize()); // &lt;- can't remove you won't have that reference because its an anonymous function that doesn't exist outside the the `addEventListener` call. This makes the listener permanent for the session and could potentially result in a memory leak, especially when dealing with objects like `window`. You can address this by saving a binded version of your handler to itself at the instance level (an instance member is created that is an this-bound copy of the function reference that was originally (presumably) coming from the prototype. this.onResize = this.onResize.bind(this); ... window.addEventListener('resize', this.onResize); ... window.removeEventListener('resize', this.onResize); Note: jquery does some extra hand holding to make this possible and event handling safer in this respect In the end, you basically three options: creating a this-bound version of your handler, working with the original scope of the call (`window` for example), or relying on scope inherited through closures. With this-binding your function has the context you expect, and `this` is what you specify such as your instance. This is generally most preferred. Working with the original scope is not always possible (and generally not recommended) but if your instance is defined in window, such as `window.myThing = new Thing()` and the Thing is what is defining the resize, then in the resize handler, whose context will be `window` you can access your instance through `this.myThing`. Closures let you get to anything within scope of the function when its defined. You'll see code that does this with something like var _this = this; // or... var self = this; // or ... var that = this; // ... yuck window.onresize = function () { _this.operation(); // etc. }; if not just the references needed within the handler itself (which might not extend to include `this` directly at all). This is done a lot for the simple stuff and is usually ok. Arrow functions will give you your `this` as well as a closure for local data. But you still may need to be careful about a persistent reference to let you remove if needed. With ES7 you'll probably mostly see the bind behavior facilitated through decorators. class Thing { @autobind onResize() { // this is always the Thing instance } }
I've been doing web dev work since there was a thing called the web and if you think there are more jobs for the web in .NET, I'll agree with /u/dhdfdh. You're totally clueless!
I think the difference that matters is how two values are compared: by reference (by comparing value identities) or by value (by looking at the contents of values). There are plans to add immutable value objects to JavaScript, but it isn’t clear when that will happen, because there isn’t even a formal proposal yet. * More information on value objects: http://www.slideshare.net/BrendanEich/value-objects2 * All ECMAScript proposals are listed here: https://github.com/tc39/ecma262
Thanks, very informative post :)
ES6 has [const](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/const) otherwise follow the convention of declaring a constant variable with all caps. E.G. const HEIGHT = 100; var HEIGHT = 100;
Seriously bad.
jQuery is [*meant to be used as*] a DOM manipulation library. It's not a framework by itself. You can use its syntactic sugar for CSS transitions, ajax requests, promises, and of course array and object manipulation. However, not all of these use cases are straightforward nor standard in a way to provide interoperability with other libraries, so using jQuery extensively might hurt your capability to design tight apps. There might come the day in which you need to replace your promises with a Promises/A+ compliant library and will find out that you need to rewrite any use of jQuery Deferred objects, or you might want to switch to lodash to manipulate objects and find out that parameters and scopes are inconsistent in every loop where you used jQuery's each or map methods. And so on. Regarding the knowledge of core js, you'll seldom use any, but since your use case will probably not match 100% with any example or tutorial, you'll need to code some to bridge things or patch edge cases. If you don't know what's going on under the hood, you'll depend on sketchy workarounds scattered around the web. When you want to declare your own objects to reuse them and abstract or encapsulate your business logic into them, you'll need to understand prototypical inheritance (or ES6 classes for that matter) or you'll waste a lot of time repeating code in several parts of the app, which leads to unmantainable code. Even worse, you might build your objects upon jQuery believing you'll benefit from inheriting some methods, when all you'll get is actually leaky objects and unexplainable behavior due to race conditions and inconsistent abstractions. I started pretty much in this way, learning jQuery and using it extensively. However, with time I discovered more libraries (and it becomes addictive to find new ones) that could perform specific tasks better than jQuery. I'm currently using lodash, backbone, handlebars, requirejs, Reactjs, threejs, d3, socket.io, less, jed, topojson, etc. Most of these tools provide functionality that could be achieved through jQuery (with heavy use of plugins) but would be less than ideal. Also, most of my business logic relies in my own models and classes, which use pure prototypical inheritance and then dependency injection to provide reutilization. Also, I try to encapsulate everything (using factories where needed) to avoid exposing unnecesary properties or methods to other scopes, because leaking things to other scopes lead to unknown parts of the logic modifying things they shouldn't. And jQuery has a lot of this. **tl/dr** learn core concepts, use the appropiate library for each task, don't rely solely on jQuery. 
no. this was them giving up. 
Maybe I'm misunderstanding the original question. Isn't the essence of the 'hoisting' behaviour (for 5.1 at least) in [section 10.5](http://www.ecma-international.org/ecma-262/5.1/#sec-10.5) of the ECMAScript document? I'm looking at list item #5 for function declarations and list item #8 for variable declarations. Variable declarations in item #8 seem a bit simpler to make sense of: if the variable name is not already bound, it looks like the variable is initialized to ```undefined```, regardless of any assignment that might occur in the variable declaration. This would seem to quite clearly specify the behaviour described in the second case: the whole declaration, as code, is definitely *not* 'hoisted' to the top of the scope. (For previously bound variables, it looks like absolutely nothing is done, so presumably that can't be regarded as 'hoisted' either, which makes intuitive sense.) In item #5, which specifies how to handle a function declaration, it looks like function declarations *are* effectively hoisted, because rather than specifying that the function name should be initialized as ```undefined```, it tells the reader to consider the "result of instantiating the function"; if there is a configurable (i.e. not declared or at least not frozen) available, it should be assigned the function as a value. So this behaviour is somewhat as if the declaration had been 'hoisted' to the top of the page. This would be in line with the results of the following tests: ``` (function(){ var a = false; return (function(){return a;})()})() // returns 'false' ``` ``` (function(){return a;})() // if a is undeclared throws error ``` ``` (function(){var a = true; return a;})() // returns 'true'``` ``` (function(){return a; var a = true;})() // returns 'undefined'``` ``` (function(){ var a = false; return (function(){return a; var a = true; })()})() // *also* returns 'undefined'``` whereas: ``` (function(){ return a(1); function a(c){return c; }; })() // returns '1'``` and ``` (function(){ return a(1); var a = 5; function a(c){return c; }; })() // returns '1'``` I suspect that the function declaration probably *is* literally equivalent to the code being physically reordered, and that this can be proven from the specification, but I lack the time to do so, and perhaps the intelligence to succeed. My point is, in both cases, the behaviour seems to be quite clearly specified. Neither case has anything to do with the implementation. So what am I missing?
This advice is like saying "Learn ASP.net but don't bother with C#". It doesn't make any kind of sense.
I think we're looking at different versions of that page. The first 1/3rd of the one I see talks about installing npm and editing package.json. And yeah! Adding 2 new components, even though they're simple, is more difficult than changing a string ;)
Why do you want or need const? Const is in the es2015 spec, [but it's not been implemented in all of the browsers](https://kangax.github.io/compat-table/es6/), so you will need to use an es2015 to es5 compiler which may or may not work correctly. Also, const will allow you to do this: const foo = {}; foo.bar = 2; IMO const is another case of people trying to shove unnecessary Java principles into JavaScript when no one really needs it (like 'new' or 'this'). At the end of the day do you really need it?
famous is one of the best of example of vaporware to date. Do a random demo that wows people -&gt; get funded 2 millions ( for what? i dont know ) -&gt; under deliver -&gt; pivot to some crappy stuff. 
Disappointing, I tried it before but it just didn't feel finished and there weren't enough actual complets usage demos Imo. 
There are two ways in which you can enforce that a static property always has the same value: class Point { static get ZERO() { // Caveat: returns a new object every time Point.ZERO is accessed return new Point(0, 0); } constructor(x, y) { this.x = x; this.y = y; } } Object.defineProperty(Point, 'ZERO', { value: new Point(0, 0), writable: false, configurable: false, enumerable: true, }); However, as others have mentioned, ensuring that the properties of `Point.ZERO` can’t be changed requires more work: class Point { static get ZERO() { return Object.freeze(new Point(0, 0)); } constructor(x, y) { this.x = x; this.y = y; } } Object.defineProperty(Point, 'ZERO', { value: Object.freeze(new Point(0, 0)), writable: false, configurable: false, enumerable: true, }); 
I agree with what a lot of other people on here have said but I got a fair way through and didn't see anyone mention c#. I personally only use c# for game programming (Unity3D) but if you want to get into the Microsoft ecosystem or might find yourself going into it or considered mobile development using something like Xamarin. Reasons it would be a good language to learn imo: 1.) Microsoft ECOSYSTEM friendly language. 2.) You'd learn an Object Oriented language which I think you should if you already know a functional programming language. 3.) You're learning a web language (ASP. NET) as well as a language which can do many other things. 4.) The IDE (Visual Studio) makes coding so ridiculously easy to write and debug. 5.) C# has seen a growth in popularity recently. 6.) Fantastic documentation and online resources. 7.) After you've learnt C#, learning Java takes only a few days to be up and running they are so similar. (or visa versa). 8.) It's easy. 9.) Did I say i mention it's easy? (only Python is easier imo). All that said and done pick a language you enjoy. Hell I learnt Google Go just because I was curious, same with erlang (well elixir ;)) 
&lt;script&gt; tags are loaded concurrently and executed sequentially if presented in the original response html. If you're able to do that, it's the simplest and best solution.
I've been preaching everything you said here for years and get downvoted into oblivion. What's your secret?
But what happens when AngularJs &amp;&amp; React &amp;&amp; Ember &amp;&amp; whatever fall out of favor in three years for XXX || YYY || ZZZ?
You're right. No one should bother with asp.net either.
Wow, I just realized vanilla JS isn't a framework.. o_O
Can I add a book? Build your own AngularJS. It's a great intro to some REALLY complex concepts (think writing a compiler) in JavaScript, as well as testing code. Plus, if you're learning Angular, it'll help you better understand it. 
Gross. Don't do it, there are so many great build tools with ecosystems of plugins for giving you a nice dev workflow (webpack for one)
Steve Newcombe is compelling as any snake-oil salesman in the Old West, because that's exactly what he is.
I noticed my JS and overall web development skills improved a lot as I became intimate with Chrome's dev tools. Step-by-step debugging in the Sources tab, a REPL in the Console tab, a full view of what's available on the page (e.g., cookies, local storage) in the Resources tab, and an amazing DOM inspector in the Elements tab that lets you live edit HTML/CSS. You can inspect the request/response of all HTTP requests in the Network tab and watch as resources load into the page. You can also use it to throttle your network speed to see how slow your site would be on wireless networks. I've also used the mobile device mode to force user agents so that sites don't automatically redirect you to their desktop version. This is really useful when you need to debug a mobile site without having to link up your phone to Safari, or worse, use an emulator. I still haven't even had to use the Profiles or Audits tabs yet so I'm sure there's some other cool shit that I'm missing.
That's a big pivot. So curious about what went on behind the scenes here, because the entire thing feels like a train wreck. Investors don't give you money for nothing, they want returns. Famo.us received 31 million in funding and they were never going to earn that back with an open source JS framework. What's sad is that they probably could have made a really great engine that unifies the DOM and WebGL. There haven't been any commits to the project in months, likely because their engineers have needed to focus on a way to monetise this thing. 
Shit is super broke at famo.us. I expect the next post about them to be about them closing their doors completely. I spoke at a conference they put on earlier this year where they launched their new famous framework. Only to lay off a bunch of their staff shortly afterwards. Now they are abandoning everything they've done for a CMS. *Shrug* there were some fantastic people at famous, hopefully they all do much better at their next gig.
The way they originally introduced their CSS 3D-based engine says it all. It was presented like a revolutionary new in-browser 3D thing, but they didn't want to say how. Exactly like that Euclideon Unlimited Detail thing that seemed like a perpetual cash grab to turn voxels into government grants.
* Build up your github. * Make things to show off what you can do. * Contribute to open source projects. * Practice making simple MEAN stack applications in 60-90 minutes for coding interviews. * Consider making your own boilerplate code, or getting accustom to using a specific yeoman generator to speed up your short coding sessions. * Be able to explain every line of your boilerplate and why it needs to be there. * Eventually you'll impress someone and land a job. * Look for JavaScript / Node.js and general tech meetups in your area. Generally they're sponsored by recruiting agencies, or recruiters will go to them that are looking to fill positions, they will help you get a position. These steps worked for me, and my job is helping me pay to get my bachelors / masters. I'm not sure where you're located, I've been impressed with Philadelphia's meetup scene and developer community, and it's less expensive than SF/NYC. Anywhere that has a decent JavaScript/Tech meetup should do tho. It's important both for networking and for seeing what other people are doing. Here are some links that I've found helpful for dev interviews: * http://ashleynolan.co.uk/blog/a-guide-to-front-end-interviews * http://www.toptal.com/nodejs/top-10-common-nodejs-developer-mistakes * https://blog.svpino.com/2015/05/07/five-programming-problems-every-software-engineer-should-be-able-to-solve-in-less-than-1-hour * https://gist.github.com/TSiege/cbb0507082bb18ff7e4b * http://ditam.github.io/posts/fizzbuzz.html * https://github.com/kolodny/exercises 
Physical code is almost certainly _never_ re-ordered, there's no sense in it. The reason I said "it's irrelevant" / "depends on engine" is that there _might_ be edge cases where it makes sense. The only example I can come up right now is if you're de-optimizing a function and need to re-interpret it, but the performance gain is so rare and minimal that I don't see the point. Or maybe an eval'd function where most of the body is a static string (but there's no sense optimizing this either since it's bad practice to begin with). There might be other cases I'm not thinking of though, so I don't want to rule out the possibility. However re-ordering code introduces it's own complications -- you need to be 100% certain that _every_ edge case functions exactly identical to the original code. As for the internal representation of a function, you can almost be certain that it's "re-ordered", but a more accurate statement would be that the code is "re-structured" -- e.g. there might be a list of variables that are in-scope whose declarations are removed from the code tree. That part of the spec is about how compilers should be reading JS code. In other words it's not at the level of JS it's at the level of the C/whatever language interpreter.
I live in the Bay Area with no Bachelor's degree working as an independent contractor writing software and make 120k+ per year. Come on in, the water is great.
jesus christ the entire website looks awful. how sad for an ambitious project like famo.us.
I don't know how things are in other countries but in Brazil only big global enterprises like Walmart etc give a fuck about college degrees. Startups, intermediate enterprises, software development agencies, ad agencies, design studios etc don't give a fuck about college. I never set my foot at a college class and I'm working as a technical team leader. Planning on moving to the US, by the way.
This One Weird Trick. 
Oh boy. 1. They're loading two different versions of jQuery (2.1.4 and 1.11.1). I'm tempted to email them and suggest loading at least four versions of jQuery. Two just doesn't suffice in this Web 2.0 era. 2. All the images are loading from uploads.webflow.com. Going to https://webflow.com/ brings up some *completely different* CMS thing. Seems legit. 3. They wrote "it's" instead of "its" and the font for their "learn about micro-apps" link is way too thin and looks ugly. You think with $31 million they could afford to check their grammar and use proper fonts. The fonts seem fine on retina screens, so thankfully the 5% of the world that use Apple hardware and no external screen will be able to read the text fine. tl;dr: wat.
It's often easier to explain things as fact as it gets the point across without confusing the person learning. - The atom is the smallest thing in the universe. - Nevermind, we lied. It's actually Protons, Neutrons and Electrons. - Wait, that was a lie too. It's actually quarks, leptons, and bosons. - Nope, ignore all that, it's just fields of energy. Tangent aside, most people don't have a clue what's actually going on in a JS engine, and they don't need to. They explain things that work at the level a JS dev needs to understand. From that point of view, hoisting work exactly as if the declarations were moved to the top.
Looks interesting. Any way to use it with promises and thus async/await? That would be super neat. 
Try iterating through that object instead of accessing directly.
If you've already started a bachelors why quit now? A good computer science degree will teach a lot of fundamentals that you just won't pick up self teaching, unless you start doing online degree courses. Is any of it necessary for a job in webdev? No, but it'll help and make you a more rounded developer.
I like a good data grid, but the demo seems to have some issues on iPad/chrome. 
Yes, good point. The parens to return an object could trip people up. But it makes sense, because how would the parser know if you are opening a code block or an object literal at that point in the code. One thing I found surprising is that this works too: let foo = () =&gt; 3; foo(); //3 without any curly braces you can still go to the next line and get an automatic return. JS ignores whitespace so I suppose it makes sense. Could be handy if you are returning a long function and want to avoid the `return` keyword.
please raise the issues on the ag-Grid forum and give details :)
[{ name: 'Test' }][0].name
My dog went nuts hearing the sounds :o
I think most of the engineers were retrenched recently. 
Like the others have said, that is a JavaScript object not JSON. It looks like something node PostgreSQL would return from a db query. To access rows, you need to use result.rows[0].name Change the word 'result' to match whatever your parameter name is. 
In the same 48 hours, I made $1000 doing real work.
Learn to think on your own and things become obvious.
But you're not, in the code you're posting, your'e doing friends.id in your res.send method. friends is an array of objects, theres no "id" there. So if you did friends[0].friends, you would get the list of friends. 
I've just supported promises in theon, but it relies on native support, so in order to use them you have to run in a modern JS engine. Implementation details here: https://github.com/h2non/theon/commit/7cbc7d0d4ff819ffbc9905feaedb9235cde1ca0d#diff-96d9811cb2296e877edf463c6cfc57bdR343
Can you explain this? I'm not sure I'm following.
UTF encoding is a beast in itself so I'll keep things as high level as I can. In UTF-16, the maximum value of a code unit used is 16 bits, or 2 bytes (0xFFFF). Values in this range are in the Basic Multilingual Plane. In order to achieve values higher than this, two code units are used, which is called a surrogate pair and these values are in the astral planes. The problem arises when in javascript, you attempt to get the length of a string that is encoded via UTF-16 characters outside the basic multilingual plane (BMP), those are encoded in surrogate pairs and would return a double length than those that aren't. Using JS string.length on a string encoded in UTF-16 outside the BMP would return double it's length. E.g. a string with 10 characters would return a length of 20. This is quite a good resource and it explains about the planes too https://mathiasbynens.be/notes/javascript-encoding. Here's a JS fiddle example http://jsfiddle.net/p90hpkr7/3/ I'm not 100% up on UTF so if I've made an over simplifications please let me know. EDIT: Added more info about the planes and an example.
lol. You're a dolt. You must be in the valley where McDonald's workers need that much to survive.
Yeah it's better than chocolate JS
Was trying to remember why I had you tagged as "troll" now I remember.
dhdfdh is a troll account, ignore it.
Even if this is all honest, do you see how you come across as an insecure professional by degrading another's work? Just to give some context to the down votes. 
Good work! It took a little while to figure out how to control the ship, maybe add a visual prompt for the first few seconds after spawning. It also took me a while to figure out that the red dots are enemy location indicators. Maybe make them into arrows or something?
Application cache is another way to do it. But there are issues - http://alistapart.com/article/application-cache-is-a-douchebag . But caching images in indexed db is another option. You are correct - These things are not made to cache images. But if you want to cache small set of images then this a simpler way. 
So you have 3 years in, and want to quit now? That's a terrible return on the investment of time and money you've put in. Have a little patience, finish your degree. The jobs will still be there when you get out, and you'll generally make more money with a degree than not. 
Common practice is top of file for clarity and to ensure bundlers and static code analysis can pick it up. You don't need to wrap CommonJS modules in a IIFE. It is already doing that for you under the hood. Edit: see here for example: https://github.com/Jam3/quat-from-unit-vec3/blob/master/index.js
Very close ;) Except that JavaScript actually predates UTF-16 and it really exposes UCS-2, which is very much like UTF-16, but it doesn't handle Unicode points larger than 16 bits, which is one of the basic roots of the problem. (Note that I say it *exposes* UCS-2, because it may use UTF-16 internally.)
Oh damn yeah, turned 20 this year. Super immature language.
I vote for learning Angular. You can become very good at JavaScript WHILE learning a framework, but knowing a framework will make you a lot more productive. Unless you have a special case, it's extremely inefficient to solve a problem using vanilla JS. (See /u/secesh's comment about the rise of Angular.) Be forewarned, there's a hard learning curve for Angular. 
I've always felt that you should find a framework based around your project's need. If you learn angular first, then everything you do is going to be an angular app (if that's what you want, then go for it). When you're a hammer, everything looks like a nail, as they say. That being said, I'm a fan of vanilla js, but that may be because I don't know any frameworks. Some of them kind of go over my head. I use a lot of jquery because it makes DOM manipulation and events really easy. I don't really do a lot of really complex apps, so a framework would be a little overkill and a time waster since I'd have to learn the framework before I could start. However, if someone could make a compelling argument as to why I should use a specific framework for a specific project, I'd probably go with it. To answer your question, though, I'd say that if you're just learning it to learn it, go with vanilla. If you're learning it for a job or just want to learn a framework, go that route. Just my 2 cents.
&gt; result.rows[0].name it says cannot read property 'name' of undefined :(
I don't think I could have done this in a week let alone 48 hours, so kudos! Seems like an awesome exercise. As far as the gaming goes I would agree with the other comments about the ship controls. When coming across other players we would just rotate wildly trying to pinpoint the other player, even if we weren't moving. Too twitchy! Great job though.
I really like Vue. Small footprint, not unnecessary opinionated, flexible and powerfull. Great library.
 &gt; [{ name: 'Test' }][0].name "Test"
I created a function to build the array (load method), created a processing function that would perform whatever calculations are required, and finally called the process function with the build function as a parameter. I did actually drop my mic and walk away, away, but you can't see that on the interwebz :D 
To Do lists are tired. 
&gt; As for the internal representation of a function, you can almost be certain that it's "re-ordered", but a more accurate statement would be that the code is "re-structured" -- e.g. there might be a list of variables that are in-scope whose declarations are removed from the code tree. I think I'm understanding this, but I'm working at my limits here and I want to be sure. My point of reference is a SpiderMonkey / Esprima style AST. It the example you're giving that the variable declaration node [VariableDeclaration] would be replaced by it's 'variable declarator' [VariableDeclarator] rewritten/transformed into an expression statement [ExpressionStatement]?
I know you can do this for the body //body in to variable var bod = document.body; //contentEditable value in to variable var bodCE = bod.contentEditable; //body style in to variable var bodStyle = bod.style; if (bodCE === "false") { bodStyle.background = "red"; } else { bodStyle.background = "blue"; } I'm not so sure about how to handle `designMode`...
Where do I say it's a high rate? Or are you making things up like most redditors do. Of course you're ignoring the fact that we're under contract on our rate, and don't know about the up front on this, but I'm sure you think that doesn't play into it.
Customer screwed up code cause they don't know what they're doing and was told not to venture there. Can't degrade them enough. Can't care less about reddit down votes.
It's an important rabbit-hole to know -- its not just trivia, at least if you are coding for an international market. At least ES6/ES2015 has some new support for handling UTF better, but none of my coding projects have gone that direction -- yet.
This version of lodash is starting to have more stars on github, its a version of lodash where the functions receive the data as the last parameter and not the first. Also the functions are auto-curried meaning that if the last parameter (the data) is missing, you get back a function that is ready to be invoked just by passing the data with only one argument. Otherwise the function gets invoked. This allows to truly combine functions together in order to build new functions, store those functions in variables and use them when the data is available. This is one of main points that FP is all about - the ability to seamlessly build a complex program by combining simpler functions. 
 document.designMode = document.designMode == 'on' ? 'off' : 'on';
they closed signups to the slack channel, stopped committing to the repos. etc.
Yeah is super sad. I was so hyped at the beginning, went to their super fancy meetups and was looking forward to use their product. But the constant delays and the shitty performance made it impossible. Feel bad for the people involved. 
Vue has been around for a while; it predates React. I don't think it's a virtual DOM style view library though. If you like the MVVM paradigm, this falls neatly into that category. 
Thanks! This code is bizarre by my standards (javascript noob here), but it does work. Google says it's a ternary conditional operator, whose syntax is like this: boolean statement ? true result : false result; But I can't understand the first line in your code (boolean statement part). Like why do you set *document.designMode* to itself, and then check if it's equal to *on*? Do you mind explaining how this part of the code works?
It's been around for quite some time. I think the author works at google. A few months ago I went through virtually every MVVM library there was and chose to go with vue. I found it really powerful given its light-weight nature. Gave me an easy learning curve and a fast implementation. IMO perfect for small projects - although I have no idea how it scales.
My mistake, I just assumed by your bragging to a college kid / Rando slam. So you're the kind of guy that brags about middling-low. "Hey baby, I've got 5.25" for you. Motion ocean boats bus references"
Prototypes, inheritance, yes. async io? No. And thanks for replying. 
Called a ternary. * `document.designMode` - this is the variable of assignment * `document.designMode == 'on'` - condition (exactly the same as if/else) * `?` - condition true value * `:` - condition false value It is basically a shorthand for if/else conditions.
How do I move on mobile? 
It feels like marionette, with inline event listeners, maybe I am wrong? It feels like a step backwards to me, but I didn't dig too deep. Are there some features I am missing? 
I'm getting a 'Server Closed' error
Heh, reminds me of XPilot back in the early 90s 
I got 8 kills, 0 deaths and turned it off out of cowardice. 
Upvoted. If you don't know JavaScript's quirks and fundamentals, you're going to have tough time doing anything non-trivial with jquery or frameworks. Especially when (not if) you try doing something that isn't already baked into said framework/jquery.
Yea, I've gotten the impression too that tech is one of those fields that really cares more about skills than a degree (as they should). This is just a wild guess but I think your priorities are: #1 Skills (which is evident from Github or a portfolio), #2 Ability to work on a team, #3 Work history (mostly to prove #2), and finally #4 Degree. But what do I know; I'm still just learning, myself. That said, college is fun and you'll probably learn a lot that you would never learn in the real world. I think of college as more of a learning experience than a stepping stone to a job. 
It says that the server is closed
I would concat for dev but if minifying takes too long for development then skip that part and make a separate gulp or whatever task for production bundling. In my experience it's the minfying that drags out the bundling process.
It's pathetic that a company with endless $$/manpower can't developer a better one.
Same here
Yeah that's better on the eyes, you could also do something similar to the phase to update the other properties so they still change over time, but slower. 
And again it's the reddit amateur hour. Can't read but boy can they write. Pretenders among pretenders.
Hmm. Who be askin'?
*In Chrome/V8. In Firefox, assigning is a little fast, reading depends on the length of the string. Also, I bet performance is a wash when you re-use set of keys many times and the engine converts the object to a struct internally.
It's what happens when your entire team uses exclusively retina screens.
&gt; Also, I bet performance is a wash when you re-use set of keys many times and the engine converts the object to a struct internally. Doesn't JS perf account for that by running the code thousands of times? Or you mean at 'compile' time detecting that it's used in multiple parts of the code?
Same. Somebody jump the gun?
Ooh yea, it was up earlier but I guess taken down?
Just found the post source: https://github.com/vuejs/vuejs.org/blob/master/src/_posts/1.0.0-release.md Maybe GitHub is derping?
What a dumbass. He's saying that, rather than wasting time building these dumb games redditors are so enthralled with, he put his time in to good use and made an easy thousand bucks! And you guys berate him for that? Talk about losers.
I prefer to do it at the top by convention. ES6 importing can only be done at the top level, so I think you should stick with that.
&gt; it predates React Well, it predates React's first *public* release at least. I've used it for a small project and it was really straight-forward and easy. I was pretty much ready to go after scrolling through the documentation for couple minutes. It's really powerful yet very tiny and light. I've read about people having successfully built large apps with it too.
JSPerf actually makes some attempts to prevent optimizations IIRC. However, when I change the samples to run everything 1000 times, the performance characteristics are the same: http://jsperf.com/hash-access-with-symbols-vs-strings/2
BTW in lodash v4 fp will be included in the primary package so you can do var _ = require('lodash/fp')(); to get auto-curried, iteratee-first, data-last, immutable methods.
This isn't free, but you can take [this course](https://www.udemy.com/understand-javascript/) for $10 (they're doing $10 deals, almost daily if you subscribe to newsletters). I can't really vouch for their other courses or their website, but Anthony Alicea is a great instructor, and I've learned a ton from this one and from his AngularJS course. 
Sure, no problem.
I really like Vue; the entity / event system is simple but powerful, it's lightweight but capable of doing some pretty cool things. It's nice to have a framework that focuses on conceptual simplicity.
Yea, I'm thinking the Vue folks might have accidentally pushed that blog post before they meant to. I saw that release candidate up on the website too.
It's very early days. it might even be famo.us itself doing that. The community sat down and went through the existing codebase in a really really deep dive, and basically nope'd their way out of it too. Because the problem has such a big surface area, they are collaborating to build several different prototypes, and then they are going to merge them into a solution that has the best features of all of them. http://forums.infamous.io/t/infamous-intro-news/80
As far as I can tell, Vue.js is conceptually similar to Angular.js, but with a simpler API. As far as I am concerned, this makes Vue great. Disclaimer: I have user neither of these frameworks/libraries.
There are a lot of options when it comes to learning JavaScript, and web-development in general. This is a recap of some stuff that I have talked about before, but it is worth going over and summarizing again. *Learn the basics first* That means learn HTML5. Learn CSS. Learn to totally separate presentation from content and wrap your head around those ideas. Write a web page that works on a wide screen, a narrow screen and when printed. Make sure that you're CSS can be easily changed to accommodate the color blind. Once you can make a good basic web page and you've got some good CSS, then you can learn JavaScript. Not frameworks. Not jQuery. JavaScript. Learn how async programming works, what call backs do. Learn Promises -- they are the new thing. Learn what prototype-based inheritance means. Learn JavaScript objects and how they differ from JSON. Learn the limits of floating point and why it isn't accurate. Learn the DOM. Not jQuery. Learn the raw DOM. Learn what DOCTYPE does, learn how to add and remove elements, mess with class names. Learn event handlers and how to handle event delegation. Then you can learn jQuery, which wraps around things. jQuery *is* JavaScript, so when things start to go wrong, if you understand what is happening under the engine, it is far easier to fix it. Then, ONLY then, learn a framework. There are LOTS of them, and worse, new ones come out all the time. Don't bother learning the flavor of the month.
XPost Subreddit Link: /r/webdev Original post: https://www.reddit.com/r/webdev/comments/3qbgyb/rendering_flatmaterial_design_parallel_long/
Like this: http://codepen.io/anon/pen/pjLqav
Thanks for the feedback. I'm confused about your point that it automatically wraps them in an IIFE. In the example I see `dot` required on line 4 but its not invoked until line 15. Is there something I'm missing? As far as my actual code is concerned (not above) I return a public API from my module (revealing module). I want the export to return the public API object from my module not the function itself.
Was it too difficult to make the bullets different color than the stars? :/
I like it too. It's very easy and clear. It works like a charm with both Webpack and Gulp/Browerify, and I can write all components in CommonJS. It has some very nice plugins, like vue-router, vue-resource, vue-strap and vue-validator. For me, personally, stands somewhere between Angular and React, while still being lightweight.
I share your feelings regular ding Angular and React, do you have any experience with Backbone and how does Vue differ from it?
This would be much more compelling if it used custom elements and `&lt;template&gt;` tags. Otherwise it's just another framework that will have interop problems with all the others.
I guess someone from famous read this thread, they changed the Webflow hosted images to a different host and fixed the spelling mistake. They still have a reference to the Webflow JS library, I wonder if they'll leave that in.
Please look at http://vuejs.org/guide/comparison.html . Vuejs also has some pretty big players using it too. Like Expedia/Badiu and Nintendo. And personally I think the optional [.vue](https://github.com/vuejs/vue-loader) syntax is much nicer than react. // app.vue &lt;template&gt; &lt;h1 class="red"&gt;{{msg}}&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { msg: 'Hello world!' } } } &lt;/script&gt; &lt;style&gt; .red { color: #f00; } &lt;/style&gt; 
Well, a constant value is also a static value, since it's not stored per object, but per class. That means the value is defined within the class declaration and is accessible through the class name. If I have a class called "Mesh" and declare a constant "const MaxVertices = 65000", then I can access this value through Mesh.MaxVertices, instead of new Mesh().MaxVertices, since it is not bound to the object.
I used View a couple of years back before the major rewrite and it was a pleasure to dive into it. I remember feeling like it took the best of the best from KnockoutJS and AngularJS at the time. I was impressed and wanted to keep using it but when the rewrite started happening, I just didn't want to learn it all over again. I'm glad the project is still alive!
Just to dump useless factoids, the first javascript raycaster was written in 1997. It looked quite a bit like yours, which is what reminded me of it. It used columns of &lt;layer&gt; tags to draw its walls, and as such only worked in one browser (which was the best browser in the world at the time, for a few months.)
Do you think it's worth learning as of now?
&gt;API-wise, one issue with React (or JSX) is that the render function often involves a lot of logic, and ends up looking more like a piece of program (which in fact it is) rather than a visual representation of the interface. For some developers this is a bonus, but for designer/developer hybrids like me, having a template makes it much easier to think visually about the design and CSS. JSX mixed with JavaScript logic breaks that visual model I need to map the code to the design. This is the part of React I've been struggling with too. I'm probably more of a designer/developer too, so it's been pretty difficult to get into JSX (and doing everything with Javascript would obviously not be any better). React-templates is a pretty good solution but it's still not as perfect as a framework that works with templates from the ground up. Thanks for the link. It's actually made me even more interested in digging into Vue, especially compared to Riot which I've also been interested in.
Sounds interesting, I don't think I ever saw that one. That reminds of this [one](http://www.arguingwithmyself.com/demos/raycaster/) that I came across. It has some of the more advanced features like stairs and variable height walls implemented. Even more impressive is that it's rendered using &lt;div&gt; tags where as I'm using the &lt;canvas&gt; element.
I'm not sure but I have a lot of reservations Would I use this for a production-level app? Probably not. There's not enough information on performance, not enough big apps to properly vet it. Would I use it for prototyping? Sure thing. It's great for simple prototypes but a lot of major MV\* frameworks are already prototype-friendly. 
Even so, isn't it still good to know a bit about C++ or Java? I assume there aren't many Google employees who only knew JavaScript when they were hired. I only have time for one new language at the moment. 
Right. Apparently he left Google in Oct 2014.
&gt; I only have time for one new language at the moment. Unfortunately that's not how Google works. You might as remove that phrase from your vocabulary. Anyway, I can recommend you stick with Java and read Head First Java and then Head First Design Patters. Both great books to learn Java and OOP. They look silly but they are really helpful if you do the exercises. They helped me greatly to understand Object Oriented Programming.
Use GitHub man, aint nobody got time for source code in Dropbox. 
https://github.com/cibonaydames/CIM640/tree/master/weather_appv2
Hmm, how does this compare to Ramda? Also wondering why the competition. Since all the function parameters are different, converting to lodash-fp wouldn't seem to be significantly less work than to Ramda.
I never got to deep into knockout so can't say how Vue compares to it. From my understanding there is a bit more going on behind the scenes with Vuejs. Vuejs.org use to have a FAQ page that goes over the difference. The page is still up on Github. https://github.com/vuejs/vuejs.org I'm guessing the big difference has to do with Vue's component system. Which is another reason why I like working working with Vue. Here's an example of what a child component might look like. I tried including examples on how components communicate with each other. ` require('insert-css')(require('./chameleon.css')); module.exports = { inherit: true, data: function () { return { chameleons:[] }; }, created: function() { // Listens for event from parent this.$on('chameloeonsLoaded', function() { // Do something when data is loaded }); // Load Chameleons and notify parent // ... }, methods: { // Function could be attached to a click event on the template reloadChameleons: function() { var that = this; $.ajax({url:'/chameleons, dataType:'json', success:function(data) { that.chameleons = data; // Notify the parent that.$dispatch('chameleonsLoaded'); // Parent component will then use $broadcast to notify all child components }}); } }, template: require('./chameleon.html') } ` 
Actually... I'll offer an answer to my own question. I have a TypeScript project on the go, and I tried out Ramda. Unfortunately its type inference was not on par with lodash (callback parameter types.) If lodash-fp has quality TypeScript definitions, I'll give it a try.
you need to select which friends of friend you want. friends[0].friends will return another array of friends so you need to specify which one you want. friends[0].friends[0].id
Symbols
I don't like jQuery for a good number of reasons. * In it's early years, it was badly coded and promoted what I could only call downright erroneous behavior by intermixing `properties` and `attributes`. This existed for years. * By hiding the DOM beneath its own layer, many jQuery coders never learn about the DOM or DOM object attributes and are often totally confused when things go wrong. * See how many Stack Overflow questions there are about someone trying to do `$("#input").html()` when they mean `.val()`. That kind of mistake shouldn't even be *possible* if one understands what is going on and is a PEBCAK error because one is learning the (bad) abstraction without learning the underlying concepts. * Although this isn't strictly jQuery's fault, much of the jQuery code and examples show and promote inefficient coding, such as repeating `$(".selector").doSomething()`. Var-caching the result of the `$(".selector")` is far better. * At the time I was first learning it, jQuery promoted inlining HTML into the code, thus mixing concerns and bypassing the HTML validation checks at the HTML level. * things like `$("&lt;div&gt;This is HTML&lt;/div&gt;")` * Template systems separated concerns and allowed HTML validations to also validate the HTML inside of templates. * This isn't just a rant for rant's sake -- before HTML5 standardized error correction, browsers could all react differently to malformed markup and debugging with html inside of jQuery had to be done manually. * At the time, jQuery often took over CSS's role. It was common to style objects or move/size them in jQuery rather than letting CSS handle that. I still see this a great deal in site code when I look. At work, I use what I'm paid to use, jQuery + knockout. For all of my own projects, I use plain-old JavaScript with just a very small, cherry-picked library.
It is sound advice. Knowing a decent amount about Java, c++ or something else is simply a side effect of learning computer science. 
It's always good to know C++ or Java. But learning a bunch of languages isn't going to help you on this quest. Your question is a good example of an [XY Problem](http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem). I would suggest learning Java, because learning C++ from JavaScript is going to be like learning how to walk for a second time. Java is a lot easier and if you ever feel the need to dive into C++, going from Java to C++ is probably a lot easier than JS to C++. But, that's really just my opinion. 
When you write a CommonJS file, it will get wrapped in a closure. So in my example, the `dot` and `set` variables won't be attached to the global (window) object or anything. It would be redundant (and ugly) to wrap the file in *another* closure like you are doing in the original post. You can export an API like this: module.exports = { foo: function () { ... }, bar: function () { ... } } 
JavaScript, through closures. Yes, it's not important that private properties be 100% private. But there isn't much upside to using symbols for private properties compared to just prefixing with `_`. Lots of syntax noise, added filesize, and reduced debuggability. All of this could be avoided with built-in privacy.
And it's now live again.
Good start. Never stop. Enjoy JS!
JavaScript is prone to "intelligent type conversion", or " type coercion" of variables in logical comparisons or operations, when trying to make two variables of different types interact. Sometimes the results are unexpected. An example from Eloquent JavaScript that illustrates this well is, &gt; Console.log("5" - 1); &gt; // 4 &gt; Console.log("5" + 1); &gt; //51 There are rules, but they're not always going to be easy to understand. It is recommended that you use the triple-symbol operators("===" and "!=="), which explicitly prevent type coercion to produce a result, defensively if you know what comparisons you're allowing.
JavaScript double equals does type conversion. So in JS world `1 == "1"` is `true`, which is nonsense. Triple equals does what you would expect, so it's mostly used everywhere. In fact most linters will complain about `==` and Coffeescript flat out didn't have it at all.
A few comments: - Nice! Itwerks! - You put the entire thing inside a loop. You might try encapsulating some of that in functions and call the functions from within the loop. - I wouldn't hijack console.log. You could create another object of your own to print out to the result panel without hijacking what is alllmost native browser functionality at this point. - Your variable names are nice and small, but when you're working with other developers, nice and small are not the same thing. Theoretically this would all be minified anyway, and userChoice is actually a better var name then uc because another dev looking at it immediately knows what it means. Look at it this way: deciphering acronym-style var names is just another mental process, so while using them might seem more efficient, it actually adds more processes (less efficiency), mentally, for other devs working on your code. - You might want to create helper methods for some things you do a lot, for example a helper method for spitting out your %s, or doing your logging. - Most of your logic is covering one of three cases. Every time a conditional is evaluated, it takes up processes, so instead of: if (foo) { a++; } if (bar) { b++; } if (baz) { c++; } maybe you could do: if (foo) { a++; } else if (bar) { b++; } else { c++ } might save you a little bit - especially in a case like this where the third option is fairly straightforward. You could keep the comments to make it clear what the else case represents. - You define some vars right at the top but then others in the midst of your code. Defining them at the top is usually easier for others to read. - Instead of var a = 1; var b = 2; you can do var a = 1, b = 2; etc. Anyway, those are just some thoughts, not trying to nitpick, you asked for thoughts, those are my thoughts. Congrats on writing your first simulator and analysis! It's a great feeling for sure and you should be proud. :)
Looks cool man, once you learn case statements you'll find its way easier and more useful! I still love my rock paper scissor game too, it's my first project I actually enjoyed!
Nice, but you should comment your code for OP
They are very similar and will both give you a good introduction to object oriented programming. However, C++ does a little more with memory management and references, so there are more concepts to learn there.
Python (or Java; or Go; or all three) [Google released a few press statements just a day or two ago](http://www.pcworld.com/article/2996620/business/google-reports-strong-profit-says-its-rethinking-everything-around-machine-learning.html) about how it's exploring machine learning techniques more and more. Besides Google's own [Big Query](https://cloud.google.com/bigquery/), a lot of big-data machine learning is centered around a few languages; notably, R/Java/Python. You can use Matlab, but you'll pay an arm and a leg. Java has some big data machine learning solutions (Mahout), but it can be kind of annoying to prototype things as there's a lot of boiler plate. I still recommend Java, as it out-weighs most server-side technologies 3:1. Also, maybe Scala? But Python is a great functional language to explore coming from JavaScript and it has a vast number of uses. https://www.codefellows.org/blog/5-reasons-why-python-is-powerful-enough-for-google Not too mention, the guy who authored Python (Guido van Rossum), works at Google. Also, there is the Go language, which has been shown to be an extremely powerful and efficient language, also designed at Google.
I mean no offense, but your question is way too broad. You're asking us to do it for you, not asking us a question on a problem. Happy to help, but not happy to do your homework.
It's a cool little lib. Not nearly as revolutionary or powerful as React, but was pretty neat for its time.
Author here. I happened to write a blog post that might answer your question: http://blog.evanyou.me/2015/10/25/vuejs-re-introduction/
I find [mpjme](http://youtu.be/BMUiFMZr7vk) quite entertaining.
I've used it on three projects I've lead since January, performance has not been an issue at all. It's actually faster than Angular and React for some things (e.g. [state-based attribute animations](http://jsfiddle.net/kqyz1cku/)) These were projects for large clients (multinational corporations) and had a lot of traffic (one was for Discovery Channel, check it out [here](http://bloodsweatandtools.discovery.ca/gamebench/) (you will unfortunately need to register an account to do most things), another one is under NDA, and the third is launching soon!) One advantage it has over Angular 2 is that the documentation is already fantastic, and the API surface area is much smaller and is now stable (I do love Angular 2, but their api is changing so often it's kind of frustrating)
You may be on to something there with machine learning. Take Andrew Ng's Machine Learning course on Coursera. (should still be free). He teaches Machine Learning in Octave with is a free MatLab work-alike. Plus Andrew Ng has strong Google ties.
I'd start off here -- hopefully most of these links aren't stale. While I don't agree 100% with Crockford, I'd rather see people follow his advice rather than ignore it completely. http://stackoverflow.com/questions/11246/best-resources-to-learn-javascript 
Download a bunch of the js talks from youtube, just the audio part. Throw it on your phone and it let it play in the car ride.
This is all cool stuff but I'm wondering what's important or beneficial about keeping your variables and methods private? If you keep to a simple naming convention and name-space things correctly there shouldn't be any collisions. What am I missing?
I took it ~3 years ago, definitely would recommend.
Please check the GIFs I added above. They illustrate why option objects are the least desirable option.
This is fascinating. Would you mind explaining a bit more about the underlying framework, such as source of randomness &amp; operation selection? As a developer myself I can see some interesting uses for this in the Javascript world if the data and decrypt functions were separated by time &amp; a p2p network. Recommendations: Give an option to save the decrypted data in a separate variable. This may seem small, but will save time on the find-replace likely to be done on the decrypt function.
Very interesting, thank you.
Actually I have been. Clojure was my gateway and now I've been reading on functional JS, it's pretty sweet.
I understand what you're saying now, but what I'm passing on is not an options object. It's just an object. If I were to give you just `{}`, are you going to call it: object, options, object literal, null, json, etc? The context matters here. An options object lets a user change properties of a js object that already has **predefined** properties. I am not giving the user that choice, the user passes in what's needed to create a `Human`, if they miss something then its simply `undefined`. The object created is also entirely immutable, hence `Object.freeze()` there's no adding or removing to it. My understanding is that you're thinking of this in terms of web development (jquery reference) while I'm thinking of it as just objects at the language level. If that makes sense at all.
Restricting visibility is primarily about black-boxing the inner workings of your classes. With a smaller public API, you can change a lot more of your code without breaking anything. That's why the leading underscore convention works about just as well. It shifts the blame. I'm still allowed to remove/rename any of my wannabe-private fields and methods. If your code breaks because of that it's your problem and also 100% your fault.
As someone who has wanted to do something with this exact stack, can anyone tell me why I shouldn't use this boilerplate?
hey, i had the same doubts. ended up choosing lodash because _.merge works like i wanted, _.find is very clean/declarative, it provides various "language" related features that are simple to undertand and make development more productive to me.
&gt;With your example, someone who wants to call that function has to read that function's code/documentation to figure out which kind of properties can be used here. Your function's signature doesn't contain any usable information. And they should as JS is not a strongly typed language. In fact you don't just go around using functions that you have no clue to what they do. Whether or not the design choices of a language specifications are good or bad is an entirely different topic. So the way I'm seeing it is that you argue for strongly typed language as it helps programmer out. No harm in that. 
Thanks for your write up. I live in Flint Michigan for school. I will check for Detroit meet ups. 
Why quit now? College is really expensive. And from what I have read, and been told, I will end up in the same job regardless of whether I have a bachelors or not. Also, I really don't like school. Most topics that are beneficial to front end dev I have already learned. I know that what I want to do is not the best idea. And if I quit school, it won't be until I have already found a job. Even then I'm not saying I would never finish. But I would rather earn money now, gain savings. Then one day maybe finish, if I need to, when it's more affordable for me. 
&gt; And they should as JS is not a strongly typed language. In fact you don't just go around using functions that you have no clue to what they do. I can assure you that 99% of the people who use some function from some library or framework do not read its source. E.g. you auto-complete or navigate to the "contains" method of a "Rectangle" class and this tool-tip shows up: contains(x, y) Checks whether this Rectangle contains the given point. You can tell what this method does, right? Or a "Random" class with this method: nextInt(max) Even without the description, you can obviously tell what it does. Types do of course make things even clearer (and the provide a ton of other benefits), but the function's signature already provides some very useful information.
Thanks!
&gt; his version of lodash is starting to have more stars on github Not sure what you mean by this? It's a few hundred vs 11k+ for lodash, do you mean the rate of stars on this repo over time? [It's been fairly steady, no recent burst](http://githubstats.com/lodash/lodash-fp) I appreciate the explanation though, that makes much more sense to me than the technical description on the repo readme :) /u/jdalton might want to throw that in there?
Yeah I have been taking advantage of their free offer. Pretty good, informative and what the other guy said about Kyle Simpson's Advanced JavaScript is right on.
It's a fine boilerplate. That said there are many things I would have done differently. I personally feel that building these boilerplate for yourself is worth its weight in gold. By picking up this far in, you are inheriting a lot of architectural choices that you may not be fully aware of, or if you found yourself making the choice, you would have chose differently.
m(_ _)m forgiveness
Get rid of your 'mode', and store your GPS data in one object, and ZIP data in another. EG: var zip = {}; var gps = {}; if (userInputZip) { ajaxRequestLocationFromZip(userInputZip, function(data) { zip = data; }); } else { getGPSData(); } Then into the event handler for your form submit: if (zip.length) { useZipToSearch(zip); } else { useGPSToSearch(gps); } 
So, not tm?
&gt; passing in an object for destructuring is nicer. Yes, but you should do the desctructuring in the parameters, not in the function's body. If you do it in the parameters, it's part of the signature which means there is a chance that it's visible in call-tips and things like that. &gt; [TS] only has partial support for ES6 and no ES7 It's currently at 51%, but it gets better with every release. http://kangax.github.io/compat-table/es6/ The score goes up in ES6-supporting envrionments, because then stuff like typed arrays or TCO may work, too. &gt; The downvote It was actually at -4 when I edited it. Well, I probably wasn't clear enough. Some people might have been confused by the term "option object", it seems. The term isn't very unusual though: https://youtu.be/pLLLf1QPgoU?t=5m12s
It's actually really hard to find use cases where linked lists perform any better than array-backed data structures. Whenever I tried them (when I thought there were a ton of inserts/deletes), they were worse. Anyhow, you should be able to find some implementations on npm or GitHub.
I heard that the main difference is about immutability: lodash will always mutate the data to the benefit of speed. Ramda always creates new collections and does not mutate the input data. Probably for most operations the difference cannot be measured, its more of a philosophy thing. 
yes it does
Here are [the slides](http://blog.vjeux.com/2014/javascript/react-css-in-js-nationjs.html) for the talk.
Man, I am so not looking forward to relearning all my code habits, _again_.
I thought this was /r/programmingcirclejerk for a second. 
Immutable has a ton of nice data structures, but might not be best if speed is your main concern.
Any method which isn't exported is essentially "private". Note this assumes you are dealing with pure functions. If you have state and side effects that need instances, see here for more examples: https://github.com/mattdesl/module-best-practices/blob/master/README.md#api-best-practices
The sound on this video is awful. I literally can't understand what he's saying.
Hi ho, I usually get my fix of audio resources via podcasts. Here's a few of my favourites: * Adventures in Angular * Angular Air * Javascript Jabber I use Podcast Addict for Android, download the podcasts at home via the app and then consume while driving to work (my commute time is around 20 minutes, so it takes me a while to get through the content) A link with a big list of podcasts: http://simpleprogrammer.com/2014/03/10/ultimate-list-developer-podcasts/ 
Only 150 lines of code. Compared to other TodoMVC implementations this is pretty small.
unfortunately, nothing=/ it was like pulling teeth 6 months ago just to get them to buy a lynda.com account for one month for us to learn Bootstrap=/
In my current project we simply import a CSS file in every React component. Because Webpack bundles the CSS and injects it into the page, we specify that it transforms every class and id into &lt;ComponentName_ClassName_Hash&gt;. No more collisions in the namespace and truly modular CSS.
I like this video much more, but its suggestion is based upon a false and very foundational premise. It starts (after all the JS preamble) by talking about unique classes as a means of specific targeting and how its so bad. That's right, but you shouldn't use classes for that anyways, its what id values are for. I agree with the rest of the points in both videos as they are still valid and there is a lot of opportunity for improvement. Avoiding (or overusing) ids is just as insane as all the other flaws they pointed out. The reality is that semantic and accessible HTML absolutely requires the use of id values appropriately anyways, and a well reasoned CSS module system would account for this.
yeah, maybe i can talk them into buying another lynda.com account for a month, and clear my workload
&gt; Let's leave aside the gaping credibility gap of anyone holding up W3Schools as their "favourite website to learn JS", and look at the arguments I'm assuming you read the slides. The w3schools comment was clearly a joke if you watch the video.
Are there any downsides to doing this? It seems like you get the best of both worlds.
True. A lot of people also have a terrible habit of myopically focusing on their own single use-case and saying "because X isn't designed to cover my personal edge-case, it is therefore a bad solution that nobody should ever use for anything". CSS lacks isolation/encapsulation and variables, but aside from that it's actually a very well-designed rules-based, consensus/overridable styling system. It's just not a synchronous, imperative definition language, and that makes some people overly used to programming in synchronous, imperative languages *unbearably* butthurt whenever they have to work with it.
Beside the "gramatical" improvments that /u/Neaoxas and others have highlighted, it can also be interesting to look at the theory :) In game theory, Rock Paper Scissor is call a [Zero-Sum Game](https://en.wikipedia.org/wiki/Zero-sum_game) and is often represented with a [Payoff Matrix](https://en.wikipedia.org/wiki/Normal-form_game). Rock Paper Scissor Payoff matrix can easily be found online, for exemple [here](http://www.princeton.edu/~rvdb/522/Fall12/lectures/lec8.pdf). If you want to improve your game and add IA for exemple, it could be a good starting point as most solutions rely on it ( see https://en.wikipedia.org/wiki/Nash_equilibrium , https://en.wikipedia.org/wiki/Minimax ). A basic not commented enough version would look like this : function game(def) { var rules = [], items = [], i; for (i in def) { items.push(i); rules.push(def[i]); } var outcome = function (a,b) { //outcome possible results are // -1 =&gt; Player 1 won // 0 =&gt; tie // 1 =&gt; Player 1 lost // undefined =&gt; no rule can be applied var row = items.indexOf(a); if (row === -1) return undefined; return rules[row][items.indexOf(b)]; }; var randomMove = function () { return items[Math.random() * items.length |0]; }; return { randomMove : randomMove, outcome : outcome }; } /** Rock Paper Scissor game init with corresponding matrix **/ var rps = game({ 'rock' : [ 0, 1, -1], 'paper' : [-1, 0, 1], 'scissor': [ 1, -1, 0] }); /** * rock paper scissor lizard spock payoff matrix * var rpslk = game({ 'rock' : [ 0, 1, -1, -1, 1], 'paper' : [-1, 0, 1, 1, -1], 'scissor': [ 1, -1, 0, -1, 1], 'lizard' : [ 1, -1, 1, 0, -1], 'spock' : [-1, 1, -1, 1, 0] }); **/ function simulate(game, times) { var games_results = { counts : {}, P1_wins: 0, tie : 0, P2_wins: 0 }, i, p1, p2, gr; for (i=0; i&lt;times; i++) { p1 = rps.randomMove(); p2 = rps.randomMove(); games_results.counts[p1] = ( games_results.counts[p1] || 0) + 1; games_results.counts[p2] = ( games_results.counts[p2] || 0) + 1; gr = rps.outcome(p1,p2); if (gr === -1 ) games_results.P1_wins++; else if (gr === 0 ) games_results.tie++; else if (gr === 1 ) games_results.P2_wins++; } return games_results; } var res = simulate(rps, 100); console.log(res); 
It's a classic polymorphic engine just translated to PHP backend with separate code generators for all different kind of programming languages. Source of randomness mt_rand() - http://php.net/manual/pl/function.mt-rand.php Operation selection works like this: 1. Get a bucket of all available encryption commands for the selected output programming language (some supports more encryption commands like bit rotations). 2. Select random operations from this bucket. Make a list. 3. Check overlaying operations (so two additions won't be added after another) 4. Check other conditions to prevent over optimization 5. If something is wrong goto 2 What do you mean by "separated by time &amp; a p2p network" please explain, maybe with a code sample. About that separate variable, let me think about it, I intentionally store it in the original variable :), string immutability is the feature of some languages, but others doesn't suffer from this "feature" like C/C++, Pascal, Python, Ruby. StringEncrypt wasn't designed only for JS so there might be some small trade-offs. Anyway thank you for you comments :)
We did come across some issues with duplication in the compiled output when we were trying to import mixins in the component files (we use Less). Every component would for example have a class for every single font-icon. We solved it by using a feature in Less which allows you to import files without adding them to the compiled output unless they have been referenced. (http://lesscss.org/features/#import-options) In Sass, you'd have to rethink that a bit, it works a little different and I'm not sure how you'd solve it.
So... CSS is good for normal websites, but it's "quite intentionally not designed to cover well" (aka sucks) for web apps.. so if you do happen to work on a web app, don't complain about CSS cause it wasn't made for it.. but the only way to style a web app is to use CSS... hmmm. Sounds like a good philosophy to stop progress. =|
I initially removed this post, because just an end-result web page isn't acceptable. However, I poked around and found a write-up they did around the development of the page: [Discovering Gale Crater: How we did it](http://graphics.latimes.com/mars-gale-crater-how-we-did-it/) In the future, please either post the end-result as a link in the comments, or be sure to post the supporting post in the comments (like I did here). Thanks.
*most* people end up making more money with a degree. Just saying. Having a bachelors degree also opens up more doors down the road if you ever want to switch careers. It's also nearly impossible to go back to college after you leave it unfinished. 
Anytime! Tell your company to hire me! :)
He's also clearly never used a preprocessor it seems either. SASS kind of blows several of those points out of the water. I don't think most people write plain CSS anymore. Most people use postCSS, Less or SASS anyways 
Thanks for the post! I'll probably be trying Vue out for the first time later this week, so should be helpful.
Sure, download it, play with it, learn from it. But once you got some better understanding of the tech, build your own. I used many boilerplate as inspiration to build my own.
"Ultra Premium Thought-Provoking Mindblowing Video You Won't Believe! #7 Got me!"
Awesome; I just love this solution. Is it based on a particular approach to game design, or somethign you came up with yourself? I would love to know more about the theory that's informing this. Thanks!
&gt; Let's leave aside the gaping credibility gap of anyone holding up W3Schools as their "favourite website to learn JS" Judging from his tone of voice and his reaction to the audience's reaction, I took that to be sarcasm.
I dunno ... I doubt you'd get a job at Facebook as a frontend engineer if you've never used a preprocessor
Yes, this does seem to be another frustrating example of someone on the React team not really understanding the basics but diving in with their new approach anyway. They did the same with a video shown prominently on the main React site about its advantages over MVC, where what they started with as a straw man was nothing like MVC and in fact completely went against some of the fundamental principles that made MVC a reasonable basic design. The more frustrating thing is that the *problems* identified here with applying styles in large-scale projects are mostly fair and do actually cause trouble in the real world. (Edit: And to be fair, this is true of React vs. various old-school architecture as well, they just did an awful job of making the case in that intro presentation.) Sadly, some of the problems are more fundamental than the presenter acknowledges, and on closer inspection their proposed alternatives are just as susceptible to analogous problems and they either didn't realise yet or glossed over it. For example, suppose you have a button, a disabled button, and a button-on-overlay, and your designers want to apply an arbitrary set of styles in each case. In general this isn't unreasonable, but it's quite possible that things like colours and shadows would be adjusted in both the disabled and overlay cases. Now, if it's valid to have a disabled button on an overlay, then someone needs to decide what the styling for that combination should be, and *in general you can't just automatically reconcile conflicting CSS rules*. It doesn't really matter whether you're using vanilla CSS with ordering and specificity, or something like BEM where you use a systematic naming convention, or programmatic merging of styles as in the examples in this presentation (which is still order-sensitive and difficult to co-ordinate at scale). Sometimes, you just need a real human to make a context-sensitive decision, and the only way we're going to help with that is to develop tools that can implement reasonable automated merging in useful cases and tools that can identify possible but unspecified combinations that require manual intervention in the general case. Programmers have been struggling with these problems in many different contexts for decades and we haven't yet solved them -- look at the pain caused by significant merge conflicts in basically every source control system and diff tool ever -- and with due respect to the impressive and useful contributions made by the React team, I don't think they've really solved the CSS version here either.
I was going to comment that exact same thing since SVG is XML and thus has its own DOM or can be appended to any HTML/XML DOM element. The package does appear to do some handy things though like * fetch the file and parse it on the fly * convert it to a data URI * auto-associate to an element via CSS style To be honest the project seems handy from looking at the examples on the readme file, but it could really do a better job of selling itself by proclaiming its strengths as bullet points.
Yeah - as I said, my comment was based on the slides, rather than the video (where, in retrospect, the sarcasm was clear).
It depends whether "frontend engineer" means "someone who builds websites" or "javascript programmer". I know plenty of great javascript developers who know dick-all about building websites, and plenty of guys who are amazing at building accessible, usable and attractive websites who know comparatively little about javascript.
There is no need to signup, the code is open source and is on github. This starter kit has authentication and authorization built in, hence a signup button.
It's great they open sourced it but it seems very niche. Seems it's only good for refactoring. I also think your standard tests should be what allow you to deploy production code quickly.
I wrote the entry on my blog a few months after the slides were released. At this point there was 300k views on the slides (this is insane!) and it already spawned hundreds of controversial discussions all over the internet. So it is a fair statement that it is "very thought provoking". For context, I did this presentation to prepare the public for the announce of React Native a few months afterwards. I did not want the announcement to be tainted by discussions around the way we do styles the same way React announcement was tainted by discussion around JSX. I had no idea that it would be such a big deal. I still can't believe that the slides have been read 500k times. To me, it's a proof that CSS is not well suited for what people are trying to build today.
Have you considered https://github.com/gajus/react-css-modules?
add debugger; to your code and open chrome dev tools. You can step through the code.
I'm not sure if this is true of other languages, but in .NET you have what are called can flags enums which are a list of pre defined values of which you can have a selection of any combination. The first value in the list is assigned "2" and each value after that is double the previous. This way any combination of options arrives at a unique value. For example: [Flags] Public enum Colors { Red = 2, Orange = 4, Yellow = 8, Green = 16, Blue = 32, Indigo = 64, Violet = 128 } Colors favColors = Colors.Blue | Colors.Green | Colors.Violet; //Essentially equals 176 (More info: http://www.dotnetperls.com/enum-flags) This inspired my approach, although I'm sure it's not a unique one. /u/ProfessorTag came up with an even more condensed version using a modulus operation. I had considered that but my math brain isn't as quick and I could quite figure out the equation while I was at work. It seems so simple when you look at it. Good work /u/ProfessorTag. 
Nice work! I had considered using a simple equation with a modulus operation, but my math brain is terrible and I threw mine together at work so I couldn't quite wrap my head around the logic. It looks so simple when you look at it. Good implementation. Obviously it doesn't lend it self too well to expansion (adding lizard, spock for instance). But its a nice compact version!
You can do that with react-css-modules too (https://github.com/gajus/react-css-modules#styles-property). The added benefit you get is being able to extend component styles when using them in different code-bases (https://github.com/gajus/react-css-modules#extending-component-styles).
Your "extremely sturdy foundation" doesn't work. Regex should probably be /{{([^}]+)}}/g
I think when you watch a talk it's important to check out who the speaker is. If you did, you'd see that it's pretty unlikely that someone like vjeux would be ignorant of these things. &gt; Moreover they aren't necessarily "global" - they can be effectively namespaced at definition time with prefixes (.btn-mybutton instead of just .mybutton), or can be used non-globally with preceeding selectors (.myloginform .mybutton instead of just .mybutton). Prefixes work, but you're wrong about using descendant selectors. If someone writes a `.mybutton {...}` rule, it will also match those with a preceding selector `.myloginform .mybutton {...}`. Because it's easy to write the former rule, this is not a reasonable modularity abstraction. This is a huge misunderstanding of how CSS works and I think is why most CSS preprocessors are abused. &gt; It's a language where you specify rules, and the interpreter styles a DOM according to those rules. CSS already provides a mechanism to address conflicting and mutually-exclusive attribute setting, and it's called selector specificity. The point being made is that you need to need to look at every single style rule in your application to prevent specificity conflicts. In addition, it's often impossible to know if there's a specificity conflict since it depends on the runtime configuration of the DOM and the order stylesheets were loaded. This was solved at Facebook with naming conventions, strict rules on what selectors you were allowed to use, and an advanced static asset loader, but it still sucks and is not a good feature. &gt; a whole slew of totally wrongheaded ones by a developer who doesn't understand the fundamental nature of CSS, and happens to be working in a framework/corner of the industry that CSS is quite intentionally not designed to cover well You have got to be kidding me.
I agree. Hadn't heard of it until yesterday but it looks super lightweight and simple. Seems like you can prototype something faster than in Angular or Flux+React.
Thanks for the the feedback, I've created an issue on github as a reminder. 
If you're building a library intended to be consumed by other JavaScript developers, it's probably best to author it in JavaScript. When I'm consuming a module/library that is written in a foreign compile-to-JS language (like TypeScript or CoffeeScript), it becomes much more difficult to contribute to it and debug problems that it might introduce in my code.
thanks! it's definitely good to think about it from this angle. however, what do you think is more important, the team working on the library being more comfortable in the language of choice, or the community that consumes the library digging into compile-to-JS code?
there is also [this](http://robflaherty.github.io/jquery-annotated-source/)
I'm not sure about other browsers, but Chrome already detects alert loops and has a button to prevent all future alerts from that page for your session.
Firefox has it too. "Prevent this page from creating further popups". Also, Firefox's alert window contains a scroll bar. So it can't ever be longer than the height of the window (or even match that height). Not sure if Chrome is similar. 
This is a really cool project. Very unique and one I didn't think was possible. That being said, the only way I'm giving up Inconsolata is if you pry if from my cold, dead fingers.
[New expression](http://regexr.com/3c2qr) link, and [Old expression](http://regexr.com/3c2qu) link for reference. (via Regexr) --- *^(I'm a bot! Send a PM for inquiries.)*
Cool!
Or just carry on with your existing habits, if they work for you.
Porn problems.
&gt; the team working on the library being more comfortable in the language of choice If the authors aren't comfortable writing JavaScript, they shouldn't be building a library intended to be used by JavaScript developers. ;) 
This is really well presented and makes a convincing case for at least giving Vue.js a try. I'll definitely think of this the next time I start something new.
The nesting is actually there for good reason (dealing with different versions of the same module). What do you hate about it? If you want less folder nesting, you can use npm@3. Going the npm/modular route brings some new concepts like semantic versioning, modules, and bundlers. [Here](https://github.com/Jam3/jam3-lesson-module-basics) is an introductory guide for client-side bundling. You can use Webpack, Browserify, JSPM, Rollup.js, or another tool to bundle the modular files together. My preferred choice is Browserify but they all have their pros/cons depending on your application and coding style. Often, you can avoid Gulp/Grunt entirely, and just work with [npm scripts](http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/).
Jspm is a package manager like bower. jspm includes systemjs which is a module loader like require.js only it works with es2015 imports. You can also bundle all dependencies in one file like browserify. Actually it is the swiss knive of dependency injection tools.
sure. the authors are comfortable writing vanilla JS, but at one point or another, more people on the team will have to contribute to the source, not just "authors". as a side note... not being comfortable with JavaScript shouldn't mean "don't write JavaScript". additionally, if the team is really small, someone will have to do the work (which would be a good learning opportunity if JS experience isn't extensive)
Probably should have tested that, good news is, Peach is tested. So... you know, have a nice day I guess. Did you even visit the GitHub or were you just looking for something to criticize? You know what. You stopped by so thanks. This project represents the end of something, last week I left another project (something successful, sort of) and I used this to construct the prototype, it could be used for any purpose. It's pretty flexible. This client was not reciprocal, I coded this and it goes used exclusively on his project and I did it for free. The best thing he did for me, was buy me a plane ticket to fly down to Kentucky and be part of some kind meeting thing, you know where they have tables. I turned down the offer 2 months before the plane ticket and the guy couldn't get a refund because his secretary forgot to get insurance on the ticket. I worked extra hours on this and really went the extra mile on a lot of things (I'd often punch out to add that extra touch of flair because I knew he wouldn't care about it). And I release this thing to nothing, not even 'Thanks'. It says a lot doesn't it? He didn't pay for it, and you won't use it. I bet you didn't even click on the GitHub link. Well, makes me just want to give up on giving things away for free. Maybe I'll become one of those capitalist guys who pads his hours and charges the client $100 for 5 minutes of work (because we round up to the closest hour here). You know how many times I've been part of projects and I put my heart and soul into them... only for their owners and founders to just not care about me or to denigrate my work? Or straight up ignore it? To many. I don't even know man. I mean, this is the first time in my life I'm writing something like this on the internet. I'm 31 years old, and I feel like a has been. I feel like I put in all this work, my whole life trying to be the best I can be... For this moment here. It's sad man and now I'm just sinking, becoming part of the problem, thinking that it's the money or the attention that I wanted. Well, you know what, I had a good time making it. But I still feel drained and tired and depressed and unappreciated. And this big one here, 'Unloved'. It's a killer. Check this out: https://www.behance.net/SeanJM and this https://github.com/SeanJM?tab=repositories... https://www.behance.net/gallery/12018681/Sculptris-UI-Redesign &lt;-- see this project here. This project almost killed me. https://www.behance.net/gallery/14325627/WiiM &lt;-- See this thing, look at the trigger ergonomics, they fit so you can grip the device in a neutral position. This is not easy stuff. And it's hard, working hard day in and day out to give something good away and have someone make a joke about your RegExp which you just slapped together for a post without any consideration for the struggle that went into it. But that's life right? And the worst part... The worst part is that there are like 25,000,000 guys out there working their asses off like me. And I'm not even unique. And they don't feel appreciated either man. And they're tired just like me man. And they put the tires on your cars, and build the bridges in your cities. And they need love to do a good job. Because without reciprocity and keeping that motor running, the love runs out. Well, that feels better. Kind of like jerking off. You can only rub it in for so long until you orgasm right? Man, the next time I see someone release something for free on Reddit, I am going to thank them.
So I get that this bothers you. But did you study the problem enough to make a recommendation or are you just complaining?
I've used Sequelize. Its getting better all the time(promises were a big step forward), but still feels sloppy and cumbersome to me compared to SQLAlchemy.
I am not a massive fan of this whole "setup some schema for your models", I get why its needed as otherwise it wont know how to setup your tables etc in relational DBs, but with document DBs it is not as important. I have recently been looking at Massive [massive-js](https://github.com/robconery/massive-js), its not an ORM as such but it kinda gives you a nicer way to talk to Postgres, as since it got JSONB its a great DB for all purposes, just scaling which is a pain.
Dang. I just got pretty comfortable with React + Flux. But this API looks so damn pretty.
Just published v3.7 with a focus on making it easier to implement threading in your applications. More abstractions will be available in future releases but this should cover some of the most common javascript actions in a typical web application. If you have any questions or any other abstractions you'd like to see please let me know, thanks. 
Babel without a blink of hesitation. If you plan to release to the community, with Babel you stick to Ecmascript standard without adding all the extra "noise" of typescript idioms, tooling and artifacts. You get better chance of people picking your project and contributing by sticking to Babel. In term of IDE support I really don't get where the problem lies. If you use something like Webstorm, Babel support is very good. For linting you can rely on ESLint. Again tooling and third party are overwhelmingly supporting Babel not Typescript.
Alert loop detection is in all major browsers that I know of. As far as sizing issue I could see that being a possibility maybe but it is kinda weak still imo. It is more important to educate people of how to use the web than to try to limit developers tools for creating a better web experience. 
&gt; However you cannot access an array element like myArray.0, it would have to be myArray[0] || myArray["0"]. You cannot.
eh, it's good in theory but really sometimes you just don't have time to find that one commit to git diff against. imo it's fine to keep in commented code if it helps the next developer or your team to understand why you came to the conclusion you did, or to see a small history of some parts so you can where the current solution came from.
Sequelize is awesome, im doing a pretty big project in it, and the performance is great :) i haven't tried any of the others though. I think that the sequelize documentation is next level and the api is pretty logical when you get a hang of it. 
Only if the history is at all a relevant warning to future developer. If it's just history, it doesn't belong in production - otherwise you may as well just remove source control altogether and just have terabytes of commented files.
Oh, well then fair enough. That's a smart solution.
Use the [Youtube iFrame Api](https://developers.google.com/youtube/iframe_api_reference) and you can specify a custom poster image on an arbitrary div the will trigger the video on press
This does look easier and more organized than React + Reflux. How does it compare in support and long term viability I wonder? React is used in Instagram and Facebook production websites. I won't go Angular again bc honestly I don't trust them to break compatibility again and this is promising saying it won't. Google doesn't even use Angular. But I have been looking for a new js web components library. React is complicated as hell, Angular 2 is untrustworthy and ugly as well, Ember just doesn't seem right, but this does have promise. Anyone using this in production?
Expedia, Badidu, Nintendo, and others from their git page
Bookshelf.js is a good option! http://bookshelfjs.org/ It's a nice wrapper for Knex.js http://knexjs.org/ All happiness!
&gt; If someone writes a `.mybutton {...}` rule, it will also match those with a preceding selector `.myloginform .mybutton {...}`. Of course - the onus is on the dev not to do that, in the same way the onus is on the dev not to use global variables. My point is that CSS selectors are not *necessarily* global variables - it's perfectly possible to "namespace" them (eg, in the `.myloginform .mybutton {...}` example). Conversely, there are situations in CSS where it's extremely useful to be able to do that sort of "global" style change (eg, to theme an existing UI by changing background and foreground colours), which the React method makes difficult or impossible. &gt; The point being made is that you need to need to look at every single style rule in your application to prevent specificity conflicts. That's a symptom of writing bad CSS, though. In the same way you should establish coding conventions and good practices so that you don't have to consider every single other line of code when you change a line of Javascript, you should "namespace" your CSS with descendant selectors and avoid using overly-general CSS selectors unless that's really what you mean for the same reasons. As I said, this is more someone who doesn't have a good grasp of how to write non-spaghetti CSS code than it is an inherent, unavoidable weakness of CSS. After all, it's just as possible to write spaghetti javascript, only the developer has *learned how not to do it* so the possibility doesn't bother him. &gt; In addition, it's often impossible to know if there's a specificity conflict since it depends on the runtime configuration of the DOM and the order stylesheets were loaded. Not really - if you really need to you can relatively trivially statically analyse your code and spot if there are selectors with the same specificity that share classnames or IDs. Admittedly you might have one element that has two selectors targeting two different classnames on the element and two different sets of ancestor elements, both of which are responsible for setting conflicting attribute values, but that's a pretty unusual edge-case in normal practice.
Why?
author is mistaking repository code vs built/deployed code. edit: s/repository code/code documentation
I have a few lines of commented out code that make developing easier. For example, one project I develop for can either be run on a simulator or be debugged remotely on the actual hardware, and the way to change this is a single line of code. So depending on how I am testing I may comment or uncomment this. There are other solutions, but it's quick and easy and does no harm. I'm not sure how relevant this is to /r/javascript, I expect people here have similar situations.
One could argue the mental overhead of finding the referenced commit also takes you out of your work flow. In contrast, my IDE with syntax highlighting let's me easily skim over the commented out code. 
My point was not that it's impossible to write component code that doesn't bleed into the page - it's that it's *impossible to make it impossible* to write code that doesn't bleed into the page. You're completely correct when you say &gt; This works great as long as you aren't working with legacy code, have every team member on board, and don't need libraries that break it ... but that's the whole point - in Javascript you can use patterns like CommonJS modules or self-executing function expressions to encapsulate code to (reasonably) forcibly prevent leakage. In CSS you *always* have to rely on the dev not to fuck it up, and it's far, far easier to do so by accident/omission. Edit: It's also worth mentioning that putting IDs at the left-hand end of the selector is really bad if you're trying to write efficient, performant CSS selectors, but that may or may not actually be a problem depending on your use-case.
"smell" is not an attribute of code. Anyone can call anything a "smell" that they don't personally like.
+1
Often there's some code that may be in-progress or related to the code but not ready-for-prime-time quite yet. It's not a sin to commit commented-out code. Some people just complain about any code they didn't write, no matter what it is.
Ha damn. It is the new face of moron.js
And npm 3 reduces the nesting just to support this case.
I so badly want to believe in a framework like this, but without a big cat it's just hard to imagine it catching on. What I'm saying is the logo should be a big cat.
Nice, did not know about that! Although sometimes it could still make sense to leave a comment
&gt; Bits and pieces of commented out code are great. Especially if you're doing something like not showing a value on a report or if you remove a field on a form. Comment it out, put a date and why. Then in 2 years you're not digging through version control logs looking for why you did that. No, in two minutes you're digging through old code looking for the current code. Keeping track of changes to source code is literally the entire point of version control systems. If you're just going to keep years of old code littered around in the current revision, then you're doing the same job as the VCS, except it's more work for you, your code is far less readable, and you do a much poorer job of it than the tool designed to do that. Working with people who do this is a nightmare. You don't need to keep all the stuff you deleted visible in the current version. You deleted it for a reason. If you need to refer back to it, that's exactly what the VCS is for. It's quick and simple to step back through previous versions, if you aren't comfortable with doing that, then your goal should be to improve your VCS skills, not to try to avoid it with commented out copies of old code. 
The author would call that documenting
Reviving old unused code is a regular part of your workflow? It isn't for me, not even close. The vast majority of time, even if the feature is needed again, the actual code to accomplish it will be different because the surrounding code has changed radically.
&gt; For example, one project I develop for can either be run on a simulator or be debugged remotely on the actual hardware, and the way to change this is a single line of code. So depending on how I am testing I may comment or uncomment this. How is that quicker or easier than simply having a boolean with a descriptive name? `var remoteDebugging = true;` is much more readily understandable than having two lines of code that do the same sort of thing with one of them commented out. 
I'm not disagreeing with commenting working code. I actually think comments that explain something difficult is a good thing. However, referencing commented out code in a sha is an issue. If you can't explain the current code without looking at old commented out code, then that's a maintainability problem.
And then you forget about code in your stash. Also the stash is only on one machine. The commented-out code may have value that would get lost for various reasons. Complaining and worrying about commented-out code is a fetish of people who think their code is "beautiful". 
why not, what?
What do you mean by too much in a codebase? The depends entirely on the size of the project and scope. There's nothing wrong with large codebases if maintained well. Cleanliness for the sake of fetish is not a thing. Good clean code should be the goal for every developer. That makes the code easy to work with, easy to maintain and easy to test. It's not a baseless standard, it's the way to ensure you're clean code doesn't get messy. I've been in the industry over 15 years and have seen my share of horrible code where developers didn't care about maintainability. I realize this is not in the startup, ship now fix later mentality, but if a dev team has the bandwith and runway to do this, they should. It will pay for itself over time.
&gt; You might be thinking: “But Kent! What if that ‘good reason’ is no longer true, and we need to do it the old way again later?” The answer, my dear reader, is git diff How does `git diff` inform the developer that previously we *used* to do it a different way? Especially when it was three years and two developers previously? "There are tools and git commands to help you look at the history of a file" doesn't really answer this question for shit - if you go back hundreds or thousands of commits or months/year into the past for every line of code you ever want to change (just in case there was ever a previous version that did things the way you now want to do it), you won't ever *commit* more than a couple of new lines of code in the average week. It's a completely non-functional suggestion, and as there's no difference between "code that was replaced and is never needed again" and "code that was replaced but might be really, *really* useful at some point in the future" it merely shifts the cognitive load from (trivially) skipping over a few potentially-important commented-out lines to (*enormously* time-consumingly) completely comprehending every single previous and now-useless version of the code to see if any of them ever did anything like what you now want it to do. &gt; Focus and cognitive load Let's be honest here - unless we're talking about a page of commented-out code between two lines you care about, who even *notices* comments after the first time they ever read it, when they're reasoning about how the code works? IDEs colour comments in a non-eye-catching colour for a reason.
It's not a huge difference, but I think removing the comments is slightly easier. Adding or removing comments is faster than typing "true" or "false". If you're just going to follow that boolean with an if statement then I think a comment and a commented out line of code is no worse. 
I agree. I love CSS, always have. People want it to do to much. That is how good things go bad.
Agreed, it's the exception and a too much commented out code is indicative of a larger problem. The point I was making is that needing commented out to explain something , to me at least, is a similar thing. You shouldn't need commented out code to understand uncommented out code.
&gt; Adding or removing comments is faster than typing "true" or "false". A fraction of a second of typing is insignificant compared with having more readable code. A boolean indicates your intent far more clearly than the alternative. 
Honestly, Safari in 2015 is like IE in 2008. It's an awful browser. IE10 is a world better these days. It's right up there with Firefox/Chrome in my book, as a developer. The only reason I still use Firefox/Chrome is extensions. 
yeah, it is pretty bad. I don't think apple cares too much about it. All of apple's best and brightest are developing the OS X software. 
I agree 100%
Agreed :-)
https://formspree.io/ is awesome. Just add their URL to the post action, it sends the form data to their servers, and then they email you the data.
If you have 15 minutes instead, put `document.querySelector('video').playbackRate = 2;` into the console to play at double (or any) speed
I believe that @bitttttten is saying when you deploy the application (at least in a JavaScript app) you should uglify your code which removes comments.
One of the things about the JavaScript alert box is that it blocks and all code stops running while it is up. As annoying as it is, this behavior is "baked into" the web and how the web and browsers work. Quite simply put, it is too late to change that behavior now or other things not only can -- but *will* -- break. As others have said, modern browsers give you a chance to keep any more popups from a page from appearing. This is the best compromise that can be made between the delicate balance of **not breaking the web** and **usability.** As others have said, `Safari` is behind the times in a large number of areas. `iOS` users need to band together and encourage Apple to update their products.
Can argue a boolean switch for debugging is more problematic in the sense that it's harder to notice if it's enabled or not before going into production. At least with a comment your editor/ide should make comments stand out from code so you'll know.
I don't know - it's possible to understand some technologies (or some aspects of some technologies) very well while being surprisingly ignorant of other areas. For example I know of some Angular JS developers who are like Javascript gods, but couldn't give you even chapter 1 on why single-page javascript applications are a questionable choice for accessibility or SEO reasons. Similarly I know some very smart Javascript guys who aren't very good at all at general web-dev - they're hyper-specialised at writing javascript code, but know surprisingly little about writing good, semantic markup or well-organised, maintainable and efficient CSS, or dealing with browser rendering pipelines to avoid layout-thrashing and ensure 60fps UI animations. I've been doing web-development since the web became commercially accessible, passed up a front-end job at Amazon and worked for companies with a comparable level of in-house technical expertise, and theone thing I've learned in all that time is that no matter how impressive these teams and companies often look from the outside, they aren't infallible *at all*. Moreover, just because someone's very good with a tool or technology doesn't necessarily mean they have a *complete* understanding of the tool or technology. And that goes double when you might be talking about teams or individuals in two entirely different *departments* in a company the side of Facebook. Just look at how many "experts" used to wax lyrical about Flash websites, or how the guy who wrote Bootstrap was dumb enough to omit semi-colons from his javascript for no reason at all, or how Twitter (primarily a content-heavy web *site* with limited interactivity) went all-in on a pure client-side javascript SPA because it was trendy and new, and were forced into a [humiliating climb-down and complete re-implementation of their entire front-end architecture](https://blog.twitter.com/2012/improving-performance-on-twittercom) less than two years later when all the obvious problems emerged.
I have come across this behaviour more than once throughout my professional career. Tragic. 
I branch more than anyone I know. That's not the point. 
exactly. Commented-out code should get removed by your build process, it's shouldn't be shipped at all. The author is just being nitpicky because he "loses focus" when he sees commented code. It's really more about the author's fetish than anything. commented code shouldn't stop anyone from working on the code. remove it as needed, but it's not always useless or "noise". Often there's times where there's more than one way to achieve something with varying performance, sometimes it's worth having code commented out that might be an alternative to the current production code. If you put it in a branch or otherwise remove it from the code there's a good chance nobody will ever know about it or find it, or care, or whatever... it's not always a 'best practice' to remove all the commented code in every single case, and to say so is just a fetish for 'remove all the things!', and it's a stupid case to try to make. 
Maybe I misunderstood? It sounds like your goals are to 1) save unfinished/in-progress code and 2) have that code available on multiple machines. --- Reguarding commented out blocks of code: A real-world analogy would be if instead of throwing something away in the trash bin someone put it on the floor. That's fine if it's one person and they only do it here and there, but when they have more people involved it sets precedence that it's okay to do. Eventually the floor is covered in things that could be thrown away, but no one really remembers who put it there or why it might be important.
You should never have more commented code than real code, there should never be more stuff on the floor than in the trash. To say "never ever ever commit commented out code, because it hurts my eyes" is just asinine. There are MANY ways to code and not all of them lead to problems. A few blocks of *somewhat important* commented-out code should be allowable, and should not cause anyone to complain (except the author). 
oh yeah, that is quite true it's thee most annoying part of web development. 
Maybe the better way to say it would be "never commit commented-out code *to production branches*". Branches are workspaces and the other devs on my team can do whatever they please as long as it's cleaned up by the time it gets merged into master. *Edit:* Obviously if you run a team or project you can dictate the style rules however you please! Nothing development-related is ever written in stone.
:Glog in fugitive is the bomb.
I wouldn't know. Now, if you'll excuse me, someone's been trampling on my lawn and I need to go clean up their mess.
Move it to the documentation under an "Errata" section or something. 
I picked up the Vue Router today and have to say that it's outstanding. No other SPA router comes close to providing what it does. Tell me this isn't awesome: var router = new VueRouter({ hashbang : false, history: true, saveScrollPosition : true }); I haven't even really dug into what you can do with transitions yet. 
&gt; An ability to be undistracted by noise in the code is not what makes a good programmer; it is the ability to express your ideas via noiseless code that does. I'm not sure *that* is what makes a "good programmer", either. 
because debugging! /s
Same here, for ember users there's https://github.com/ebryn/ember-component-css
Isn't that the point of using version control? So you can take the speghetti mess and slowly refine it until you have the whole bit of old code commented. Then, once the program passes tests, the commented out code is deleted and the commit is made. What is the point of using a version control system if you are effectively keeping an old version in a comment?
Why aren't you working in a branch that doesn't matter if the code is in non functional state? This is probably the worst argument I've ever heard for comments in code. Committing WIP code to a master branch commented out. Best use of version control ever. Wait, are you using subversion?
the only reason i comment out code is for my own learning process. on a production level i would imagine it looks hideous. 
I agree with what you just said.. but there's also the experts who hated flash websites from the beginning, the guys who started the point out the lack of semi-colons in bootstrap, and the guys who thought that the Twitter SPA move was pretty dumb. There's 2 end to this spectrum... yeah, some people were wrong. Doesn't mean everyone is wrong-headed. I'm not asking to instantly believe anyone neither - but I encourage everyone to discuss and argue about it. I really believe that's how we progress as a community. My initial beef with your comment is: - you pretty much blamed the dev without even doing the basic homework of watching his talk instead of just reading his slides (w3school thing). Maybe there's other stuff you missed on it too? - you said that he missed the fundamentals of CSS but failed to explain what's the fundamental of CSS - If the fundamental of CSS is limited, should it stay the same or evolve? Maybe he understands the fundamentals but doesn't agree that it should just stay like that? 
I tried really hard in the post to not have a ultimatum voice, but more of a suggestive voice. The first QYMAM: &gt; Q: Are there exceptions to this rule? A: Yes. But they’re rare. And there are several other QYMAMs that explain there are cases where commented out code is allowable (though I generally call those cases documentation).
Commented out code is either simple enough that you don't want to distract a reimplemented with how you wanted to do it all the way back in days yore, or its complex enough that they'll just look at past commits. 
If you read the post, you'll see that it's not an ultimatum at all like I think you're insinuating. The first QYMAM: &gt; Q: Are there exceptions to this rule? A: Yes. But they’re rare. Also, if you put code in a branch and people forget or never use it, then was it really all that important? Also, this isn't a misunderstanding of repository code vs built/deployed code. Sure the comments are removed from the build process. Nowhere in the post do I mention anything about the problem being related to shipping comments. This is all about the software development process.
thanks 😊
If it's as recent as a few weeks someone is still using it. If it's older then remove it. Ask them first. I don't see why you wouldn't be able to focus past grey text in your ide unless you weren't really working on anything.
Welk, this is great general advice. Of course there are valid exceptions. If you are working around a compiler bug, or have added some hand-tuned optimization in bottleneck code, then it can be very nice to keep the original version of the code (as close as possible to the production code, for comparison). In the comments, clearly state *why* you are preserving the old code and why the production code differs from it. You will appreciate later that you have done this, and others who have to maintain your code will also appreciate it. This is much, much nicer than hiding the original code in some commit. You are leaving the original code in as an explanation either of how not to do something or of how you wanted to do it but couldn't (due to a compiler bug or code runs too slow, etc.). It's a thin line between doing it right and over-doing it, though. Use clear judgment and common sense here. If it's not clear to another reader why you are preserving the original code, then... off with your head!
Alternatively, if you're using C or C++, and you are replacing an entire function, you can actually leave the code in (i.e., not commented out), and give it a different name (like suffixing the function with "\_obsolete"), and mark it as "\_\_attribute\_\_((\_\_unused\_\_))". This way, it's not actually commented out, but it's still there for comparison. The compiler will still parse and compile it, but emit any object code for it, and won't complain that it's unused.
Please, don't listen to random advice on the internet about how you should organize your code.
Well, you are lucky to have not worked on 10+ year old projects (I'm looking at you, e-learning &gt;.&gt;)
Yeah I was, there are a lot of node packages that can prune your code of comments. I was talking about production-ready code, which does include creating bytecode, not branched for release—if that helps clear that up.
&gt; Q: Are there exceptions to this rule? A: Yes. But they’re rare. From the article. And the example I described above was one of the two examples I've found in 20 years of software development. It IS documenting, and not usable as code. It helps explain what's going on.
We actually allow shipping unfinished code to production using flags that only allow the code to run if the flag is enabled. But that has *nothing to do* with commented-out code getting checked-in to the production branch, which is still allowable in many cases. Code is fluid, it's never "finished", it's *always* a work-in-progress unless you aren't doing anything interesting with it. Wait, are you using sourcesafe? 
use a transpiler like Babel or Typescript, or use prototypical inheritance. function Parent(){} function Child(){ Parent.apply(this,[].slice.call(arguments)) } Child.prototype = Object.create(Parent.prototype) &gt; and interfaces a library won't give you that. How could it ? only a third party language that compiles to javascript will.
Typescript without hesitation. It will be much much more easy for new comers to get familiar with your library knowing what is what, no question about it. and you get so much stuff for free thanks to the type system(auto completion in IDEs, doc generation, ... ). At first I hated it, but then I wrote a 100 000 lines app with it and no question , it would have been so painful without it. 
heh, I am the author, should have made that more clear. But I think that the topic is a bit subjective, which is why I tried to have more of a suggestive tone with data backing my suggestion.
It might be documenting, but it is *also* commented-out code. By definition. Excellent example of a legitimate inclusion of commented-out code. Bravo!
File a bug. https://github.com/atom/electron/issues
How so? Safari is my default browser for personal use. It works great, is seamless across all devices, and I can't rember the last time something didn't work just because it was Safari.
TypeScript is what you are looking for.
I still think you're spreading programming dogma. &gt;"the main problem is commented code adds confusion with no real benefit" This is just not true. The examples you cite are extremely weak. You are also being disingenuous because you don't show how the comments *actually look in a text editor* - almost all modern editors show commented-out code grayed-out by default, so that it is *far* easier to read the code than the examples you show. Also the code you show is very simplistic and it's not very interesting. There are plenty of cases where *interesting* code could be kept commented-out, so that it's easy to A/B test, possibly switching between commented-out code blocks every other week, or any good reason that doesn't include deleting the code. It really depends on the problems you are trying to solve, the team you have, the business you are in, and *many other factors*. Commented-out code should include a brief note about why it's there, what it's for. Documentation is documentation, it has nothing to do with commented-out code. You can have both, and it won't ruin your codebase. 
&gt; I’ve long held the opinion that the only thing that can tell you the truth about the code is the code. The instant you add a comment, it’s out of date. Documentation comments are beneficial enough to justify their existence (though you should try to make your code self-documenting for people other than yourself). I find myself having to explain this to almost every manager when they say that they like developers who can "comment everything". I simply do not trust comments; especially since I quite often browse code with git commit history turned on. So when I look at the commit date of the line of code that the comment is on, and see that it was from three years ago, or better yet, an ex employee who I have never heard of, I take it with a grain of salt. Reading the code is the only way to get the real picture.
And *test*, *test1*, *test2*, etc...
In my experience there is only one good reason to leave old commented out code in the code base, and it is a very good reason. It is to show an old and bad way things were done, and to explain how important it is not to go back to doing it that way. Because there are times when someone comes along and say, "I know a better way we could do this" and rewrites the old dangerous way from scratch. Yes, this happens.
webpack configured to dedupe correctly, plus npm scripts.
Who said anything about "reviving" the unused code? A frequent use-case is someone refactoring legacy code (or reading new code), needing a quick point of reference and not wanting to disrupt their workflow by: switching windows, finding the commit hash, remembering the source control command to bring it up, then splitting windows to do a side-by-side comparison. I'm definitely against **permanently** leaving commented out code, but during a **transition period** it can be **very** useful. Eventually, however, it should be cleaned up.
Then use a branch.
I'm amazed someone had to write an article to say you shouldn't do this. This should be the baseline default like learning to indent your code correctly.
Still better than no history :( 
Branching is not always a cheap operation
I agree. And if OP wants to know **why** Vim is a fantastic IDE (not only for javascript but for __everything__) watch the video. It's really gold. It talks about Vim's extensibility, flexibility and power as a tool.
+1 for the Atom quip. Slow loading for large files in Atom I think is what's holding them back.
Yes, you are right. I will update README with more info.
Yes you can, but this is bad - it's increase size of html, no caching. And what if you need a lot of same icons on one page?
Worked with a guy who did this years ago (pre VC admittedly). He worked on one program, and it was contained in one 250kB .c file. Of that 250kB, about 80% was commented old versions of the code, only about 40kB was actual live code. Later he had a variation of that program, so he copied the entire source file and made changes, retaining all the ~210kB of commented old stuff.
What do you mean by "using it". If it is being "used" why the fuck is it commented out?!?
You can get a history of a single file. Which really shouldn't be THAT long unless your code is the least modular code on the planet. I mean if it is a 20 year long non-modular codebase then sure. But at that point you are in hell anyway.
under what circumstances is branching expensive?
I lose my shit. My blood pressure goes up. I don't understand it all. It is the easiest best practice to follow. You automatically clean up your code. Some people will comment a change, comment the change of the change, comment the other change that they were going to change. The code is fucking mess of horrible commented code. Why wouldn't any human being do this. That is the whole point of source control management. And then there is the argument, well we really need to change this module back and forth because of testing or something...so we haven't completely decided if we need the commented piece. FUCKING GREAT, refactor.
The problem is that working in a codebase with commented code is like looking for something in the home a hoarder. Sure, there might be something in there that you need, but the chances of you finding it are slim, and in the meantime, you're surrounded by piles of shit. There is no middle ground. What's the worst thing that happens if you can't find those 20 precious lines of code that you misplaced? You have to rewrite them? Is that so bad? How precious are those 20 lines? And for that matter, how do you know which 20 lines are the precious ones? How much other cruft do you need to keep around in order to make sure you save the *right* 20 lines? If there are bits of code that you think you might need later, save them in a branch, make a gist, or just save a file to your desktop. The master branch isn't a junk drawer.
What's wrong with explaining the issue in plain English?
Seriously, what the fuck. Don't commit commented out code, it's easy.
&gt; but the chances of you finding it are slim, And your chances go down even further if you hide it in source control. 
Firstly, thanks for the hard work. Originally, I was just curious what happen if I sign up. (not blaming)
yes, by definition you aren't looking at code if you're looking at a terminal prompt typing in git commands.
Best comment here.
I would consider that documentation. You wouldn't just comment that out without adding a note about it. If there's a note that explains what you're saying, then I wouldn't have as much of a problem about it.
That's legit. Very cool idea!
Says you. 
Please don't commit conflicts. Thank you.
I can't believe I actually used to do this before I learned version control. 
[The "middle ground" doesn't always have to be the best.](https://en.wikipedia.org/wiki/Argument_to_moderation) In the situation you described above, commented out code _also_ won't help you to find that previous way. It might even be worse: the commented out code might not even have moved along with the new code, and you no longer know what you're staring at. If you're that far gone, it's best just to write it anew. The "previous way" was removed for a reason.
People do this? 0.o
Been doing that for ages ! Also using Makefile ! Yeah !
Thanks!
I've never felt the need to keep commented out code around during a refactor. Can you give an example?
Why do you care about past versions of a file when you edit it?
[Babel!](https://babeljs.io/repl/#?experimental=false&amp;evaluate=true&amp;loose=false&amp;spec=false&amp;code=let%20searchDetails%20%3D%20%7B%7D%3B%0D%0A%0D%0AsearchDetails.filter%20%3D%20doc%20%3D%3E%20doc.type%20%3D%3D%3D%20'person'%3B)
copy of copy of new folder(1)(1)
Thanks.
Wait, are you working at Etsy?
So... do I listen to your advice because it makes sense I shouldn't listen to strangers or should I reject your advice because you are another stranger with random advice? /headasplode
Alright gents, a date to mark on your calendars. October 28th, the day Peach died. Perhaps it was a head of it's time, or behind... A thing out of time.
I keep it in for a few a days. Once time moves on and nobody misses it, i remove it for good, with a proper commit message why and what. **EDIT**: downvote is not a "disagree" button.
Nothing at all, that's also a way to resolve the same issue I was describing. It's probably even better to do it with plain English..
I was really actually only replying to your statement that reviving old unused code is a odd or rare part of one's workflow. In the e-learning projects I work on, this is often the case :p (I can try and briefly explain: each elearning course gets a new rebrand and often clients want a slightly different interactivity each time. The client often knows how each slide/course can be different through working with us before. So they'll ask to change some of the slides around a bit, ask to change how the score is calculated, or change it to how it was again 5 years ago, or switch back to the colour scheme of 4 years ago .. it's not my call to leave it as uncommented as I'm not a senior, but in these situations yeah, reviving old code becomes part of my workflow.. hope you now see :p )
What project are you looking to build? Often, with a smaller project or one that doesn't need the complexities of what these frameworks have to offer, you are better off just creating your own.
To be fair, just because it's somewhere in your git history doesn't mean you're ever going to find it again. I've tried that. Doesn't belong in the code, either.
That works except for Windows. I am interested in React's style of pathless requires as well. Hopefully it will be available as a standalone library in the future. https://github.com/facebook/react/blob/master/src/React.js
Putting your title in all caps is pretty obnoxious.
From a user's perspective it looks pretty good. About time FCKEditor etc gets some real modern competition. Basecamp's Trix Editor is also pretty nice. http://trix-editor.org/
It's not dead, it's out there. It's difficult to get traction on open source projects - personally I would call it a winner just by open sourcing it. If someone other than you picks it up and start using it - even better. Maybe someone just reads your code and gets inspired to do something else or even learns something. I have been inspired by many small "dead" open source projects, as you put it - this is the beauty of sites like GitHub. I saw your other post by the way - to me it seems like you should get a new job. Join a team of developers and not lone range it for a while. It's hard to carry all the weight on your own shoulders. This is coming from a CTO w/30 employees now, who started the company as a one man shop 10+ years ago. I know how it feels like to carry it all. People work better together. :) Thank you for open sourcing your library.
How about when you're in the middle of some messy code and its time to go home?
Sticky notes on my monitor it is then. 
I'm sure you've been flooded, but PM me if you are still looking, and let's talk on Skype and let's see if we can work together!
If you're doing TDD, you'd have this already.
Javascript is built around the *behaviour delegation* pattern, thus it differs from most of the currently used programming languages which embrace *classical inheritance*. Behaviour delegation is a powerful pattern for any kind of logic your application may need, you just need to understand how it works. Take [a look](https://gist.github.com/getify/d0cdddfa4673657a9941) at the [OLOO](https://gist.github.com/getify/5572383) pattern ;)
Yeah, I've no issue with commented out code as (part of) some documentation - I've done it recently when converting documents from one type to another to indicate fields not yet present in the source type that would be soon. Dead code should be left to version control, but that's not the only reason to have code in comments.
&gt; The instant you add a comment, it’s out of date. Please stop repeating this nonsense. &gt; Documentation comments are beneficial enough to justify their existence (though you should try to make your code self-documenting for people other than yourself). Documentation doesn't tell you what the code does, it tells you why it does it. Writing code that is easy to read or understand (what you call "self-documenting") is not the same thing as documenting your code.
It is better to ask this kind of question in one of the other subreddits like /r/learnprogramming or /r/LearnJavascript .
Didn't even know they existed thanks :). 
It works fine on most sites, but is starting to fall behind. Particular to Chrome: http://caniuse.com/#compare=edge+13,firefox+44,chrome+49,safari+9,opera+32 Scroll down.
downvoted for using the @ sign
I'm open to this being a thing but the fact that he doesn't fully address the issues at hand makes it less believable. The main problem with diffing is that... why should there be a cognitive overload there? So I see a piece of code I don't understand and my reaction should quickly be to diff it? Diff it against what? Who says the diff is going to be of help? Commented code helps me out all the time personally... often times you write a function or a piece of code that CAN be used in many ways but it's original intention of how it was to be used is obscure, and this becomes a problem when you have multiple functions all based around this one idea. The idea that the first thing you usually see when you look at a github page is a README with an api and explanations, along with issues explaining things not said in the documention to me seems like an admission that some handholding sometimes is necessary and comments fit that bill. I'm open to the possibility that they are useless but I don't feel like this articles goes enough in that direction for it to be crystal clear.
Me too. I was more advanced, though. I did it with zip files that had the date in their name. Those who fail to learn version control are doomed to repeat it.
Line 67 made my day.
&gt; What should I do, copy and paste it into a text file I keep on my desktop for quick reference? As he says in the post, work on a branch and have all the commented out code you want. Then clean it up before you merge it into master. 
Here is a JS Fiddle. http://jsfiddle.net/cuvj816L/
Slightly off-topic, but if you're going on that road you might also mention or somehow connect Node streams to the topic (basically the same idea on the backend).
some interesting resources on Node streams: - https://github.com/substack/stream-handbook - https://github.com/maxogden/mississippi
I use tagging for this. I know it was in some release. I find the release it was in (far less of those than commits) and then work my way. Pretty straight forward to find information IMO
Just a couple weeks ago, I commented out some HTML because it got shuffled out in a partial redesign, but I knew it was coming back. I uncommented it two weeks later. Was much easier than trying to find that diff. But, in general, yeah, it's just confusing running across this stuff.
It is not going to be feature parity with devise. It's very different. There is also strong loop's version of an Auth provider as well if you want a TON of enterprise-y things. https://docs.strongloop.com/display/public/LB/Authentication%2C+authorization%2C+and+permissions Usually, these days, you can decouple your auth provider from your resources and use any programming language or auth service. For example, you could use Google's Auth system for sign-in's. Just all depends on what you're doing.
Probably better to key testing code off of some sort of flag. I like to add `debug_mode` as a class to the body and then have my functions key off of that
Yep, the two are very similar in terms of features and how they work: both are middleware and they both offer a plethora of authentication strategies.
Whelp. I don't know about the rest of you but I have something to do when I get home.
It looks like you are missing a &lt;/select&gt; ending tag http://jsfiddle.net/cuvj816L/3/
See this right here, I commit to save my work so far. And it's not always "finished" when I commit so I keep in some commented out code for ease of changing things. Then I clean it out at a later date when I'm sure i wont have to swap back to the other way. and not all code gets that treatment I do lots of changes and removals without comments, its all dependent upon how certain I am the change is final.
Commit new changes with a comment pointing to the previous commit hash explaining why it is bad. Done and done.
*you* may know, but others may not. Then the others may re-invent the same code that you hid away in source control. I'm not saying you should be 'hoarding code', far from it - but to say that every instance of commented-out code is bad, is just stupid.
How there are still people out there who are not taking Meteor seriously is beyond me. With that said, this is absolutely wonderful! I've been getting super pumped up with the changes in ES6, but being a Jr. Dev, the fact that there was so many compatibility issues was particularly daunting. This will allow me to fully take advantage of ES6, and really get a chance to learn how the changes work properly while getting me used to changing my coding habits. 
Not that I'm aware, but I would be so happy if we implemented a "no help requests" rule...
That would make your program test for debug mode even in production.
I don't think there is one, but I definitely support the idea Just as a general discussion sub for people to ask advice on which libraries to use, promote new ones - maybe /r/letstalkjs or something along those lines?
Every time I go to Bloomberg Business it's like more and more clowns have thrown up all over their site design. Holy fuck is this site making my eyes bleed.
Yep, but it's not quite as informal as here. I should point out that /r/LearnJavascript could maybe take over the 'help' side of things... I forgot that sub existed! I'm just keen that a place where 'newbies' (or whatever!) can go to ask questions and not feel judged.
Lol, never did cobol, but spent enough time on large teams building enterprise software. The value of maintainable easy to read code is immense. The last thing I ever want to hear is "don't work on that project, any small change could cause it to crash. it's unstable"
I would agree with SquareFeet. This subreddit is fine the way it is. I notice that (most of) the questions asked here are coming from people who already have some ground knowledge but are not skilled/trained enough to land the plane. I think that is a great element of the sub. However I do find it annoying to get all these questions when I'm looking for an in depth discussion or new libraries. That why I would like to suggest a new sub reddit dedicated to to that. 
The docs have been completely rewritten. I'd suggest you take another look. I suspect you tried it directly with a minified build. There are lots of warnings for common mistakes in the unminified build, and there are plenty of beginners using it without much problems. I'd appreciate it if you open issues on errors you find confusing.
As you just said /r/learnjavascript would be a better place than here for that.
Created! Let me know what you think
my intention was to create this with all printable characters and using ES5 code only any ideas for improvements? EDIT: 953 bytes http://jsfiddle.net/9wxzx9xe/23/
First rule of applying for jobs is to list the skills you have which match the requirements exactly. Don't make the mistake thinking recruiters or HR know anything about your field. Or that they will spend more than a few seconds looking at your resume. In some cases, it won't help since companies only hire through recruiters. If they have a careers page on their website, go for it.
Companies that use developers still use recruiters and an HR department, unless they're startups. Try to get your resume straight to a hiring manager i.e. LinkedIn or finding their direct email otherwise. Or networking events like meetups.
The question about [valid method definitions in classes](https://i.imgur.com/p5MWIau.png) is wrong. This is not valid syntax in ES2015: class Test { method = function () {} } 
Yeah. Hey. Spend 10 minutes out of your day to learn jquery before your next interview.
Pro tip #1: Don't use RETURN more than once in a given function.
Node.js for your back-end work. Piggyback off your javascript knowledge. Slap yourself in the face for suggesting C++ or Java. If you want to do OOP use ES6 (javascript) or C#. Also, don't short change yourself on the relational database side of things. Learn SQL!
Actually they're really looking for AJAX developers. Email them back and say you have 3-5 years of programming in AJAX. But it can't hurt to also drop that you were team lead of a group of jQuery developers on a mission-critical line-of-business application that improved the efficiency of core business processes by 42 percent. Throughout the duration of the project you managed and mentored your team with high effectiveness and positive results, collaborated seamlessly with stakeholders, and consistently adhered to industry best practices, successfully launching ahead of schedule and under budget.
The interview process is a ritualized monkey dance that we're all complicit in enforcing. Consider it career hazing. It's a society wide practical joke that got taken too far. The sooner you accept the fact that you need to dance the dance, the sooner you'll get you one of them jobs.
&gt; Is there any good maintained JS physics project, I wish someone had responded. Did you find any?
Interfaces are meaningless in a dynamically typed language. You'll have to rely on duck-typing, or some type of runtime type checker like tcomb.
The only thing recruiters (can) do is scan for keywords. Just make yourself an expert in every piece of vacuous hype you can find. Truth and honesty are undervalued by the ignorant. I am lucky enough to work for an employer that had "NO RECRUITERS!" spelled out in capital letters in their job listing. It was glorious.
https://twitter.com/recruiterbro
In over 35 years of electronic engineering turned into programming, I have been contacted by headhunters, sometimes every day for weeks on end. I have never, ever been sent out on an interview by any of them yet I have an extensive, successful background in every area I've been in and rarely lose a job I interview for (that I get on my own). So I have no faith in head hunters and tell them to not bother me on my linkedin page, my SO page and my person page (but they still keep calling and emailing).
Community flair and filtering with client configuration would be great
... and at least 4 years of experience with ES6.
I dislike CVs that appear to have been constructed to perfectly fit the job requirements. Source: sometimes I hire people 
All very true, but there's still an HR layer that might need you to list Microsoft Office on your CV.
Thank you for articulating this beautifully
If you went into development thinking you wouldn't have to deal with the business world, you're going to have a bad time. And yes, they are all full of show and bullshit. More than you can imagine.
bookmark javascript:window.scrollTo(0,75)
&gt; the reason why I went in development was because I felt that the business world is all show and bullshit Have you worked with other developers in a professional setting?
commented code is absolutely a good idea if it helps explain what's happening in plain English... 
Brush it off, they are idiots. If you have Angular and D3 listed on your resume, no competent person is going to question if you can pick up jQuery.
Not natively in NodeJS, but there are a few options for libraries that do this, like: * [Cheerio](https://github.com/cheeriojs/cheerio) * [JSDom](https://github.com/tmpvar/jsdom) * [htmlparser2](https://github.com/fb55/htmlparser2) In no particular order. I'll let them duke it out themselves...read through their READMEs to see what they use, how they use it, and for their claims to speed.
git stash
I strongly believe all that grunt/gulp shit should be abstracted. I shouldnt have to give a fuck what build tool you use if clone a project managed by npm. Just tell me to run npm run build and that's it , no more shit .
this says they are supported in strict mode: https://nodejs.org/en/docs/es6/
You didn't read the post.
You're right! Hence my first QYMAM is: &gt; Q: Are there exceptions to this rule? A: Yes. But they’re rare.
If it's explaining it in plain English, then it's not code anymore... It's documentation. That's different from what this article is talking about.
Why would you dislike the fact that someone catered their résumé to illustrate they had the skills you are looking for?? As long as they weren't lying, that is completely counterintuitive.
yep, I know, I mean, with require I have to declare the cdns in the requireConfig, would be nice if we had a service that knows what is the cdn for that library
Recruiters are garbage people; if you can afford to ignore them, I highly recommend it. Talk to companies directly, especially if they have a 'careers' page on their website.
My wife was a technical recruiter - and pretty much the only one who knew what the technologies and buzz words meant, so she could make those connections when looking at a resume. The business was full of cut throat, ignorant, assholes though, so she wanted out. She became an IT project manager, and was pretty good at it.
Thanks for this. I can't seem to get it to work. Do you mind explaining the proper syntax? 
Closure is a real compiler, not just a transpiler. It'll statically analyze your code and actually remove subtrees that are never hit, for one.
This is what I'm trying with on yahoo.com. anchor = document.getElementById("nav-wthr"); anchor.scrollIntoView(true);
Numbers with leading zeros don't exist. They're mathematically equivalent to the value without leading zeros, so in code, `00005555` is written as just `5555`. The fact that they are the same lets the language play around with a leading 0 to make it mean other things. For example `0xFF` is hex. ES6 supports a `0b101` which is binary. Just having a 0 (no x or b) means octal, or base 8. So what you get with `00005555` is the same as `parseInt('5555', 8)` - and that's probably why you're seeing what you're seeing ("fail"). If you need leading zeros in a number, then it has to be represented as a string. var example = "00005555";
Well those really aren't synonymous, so I don't see why you're surprised. I would understand if you had put that you know jQuery and they replied that they need JavaScript developers, since knowing jQuery implies that you know JS, but knowing JS does not at all imply that you know jQuery. Particularly if you listed other JS libraries and left jQuery off the list. What do you expect them to think?
recruiters 99% of the time are the used-car salesmen of the job world. sorry to any recruiters here, but I've only ever met one of you that actually understands tech. the rest of you were humanities majors who didn't know / couldn't get anything else. keep your head up and find either a company that specifically does tech recruiting, or just apply yourself. remember, you can fire them too. if they don't know js vs jquery then you don't want to be involved with them. FURTHERMORE the people they DO place are probably ill-fitted in the first place since they don't know any better. odds are the recruitment company doesn't exactly have a stellar reputation.
I got it to work. It was because I had allow pasting in the script I think. Thanks for the help. 
I saw a job posting looking for eight years of experience with "modern web practices"
And some managers. I had a manager pine over someone's resume because they were advanced in Microsoft Word AND Excel.... 
Just email him and explain the situation
Meetups! I've met so many people through meetups. If you're a pretty good developer and meet the right people, it's very possible to land a nice job. 
Ah... I see. I got tripped up by "in code, 00005555 is written as just 5555." I thought that meant it converted to 00005555 to 5555. My understanding; carry on!
That sounds like a horrid recruitment firm; they didn't even ping you.
Then you enable strict mode :)
We've recruited 60% of our team from the local user group/meetup. Get out there and talk to other developers and skip HR. 
Seriously, as much as it sucks to be rejected, I would **never** work for a company who's HR sucks so hard to make this mistake. Lift your head, thank god you dodged a bullet and go apply for better jobs. 
Recruiters don't know shit.
"yes, we know you have 1000 other things, but marketing needs the colors changed on these panels right *now* so please make that the top priority. I know we made you change them 3 times already but this time is to match with our new vision for inter-product synergy for our new marketing campaign that won't do jack shit for sales even though all our graphs will look very impressive" 
*vomits*
&gt; Way to waste time son. Bet you feel proud. And yet, here you are...
I can top that. I cowrote the current req for all of our open job postings. I have gotten 5 recruiters to send me my own req to me. They love to inform me that I sound like a perfect fit for this role. I then ask if they think it's a conflict of interest to interview myself. 
Tech recruiter here. The best resume will have a nice matrix at the top with each language/framework/os/tech you have experience with, the last time you used it, and how many years of experience you have. Then, each job you have should list the tech environment below it. Agency recruiters often dont know anything beyond the buzzwords. That is true. But, a good amount of the time I have spoken to the hiring manager directly and they told me they need x years of y skill. Unless I make it apparent to them that you have that in spades, they arent going to even bother with a phone screen. You have things all backward in your mind. You are placing the burden on the manager. They will not receive your resume, go to github, and open your stuff to check out your code. You are asking for the job. It is on you to make yourself the easiest skill set to interpret. Can you find work without a recruiter? Certainly you can do it without an agency recruiter. I know lots of devs who get plenty of work and inly go through me if they hit a dry spell from their normal clients. The likelihood of getting in somewhere without going through an internal recruiter or hr is lower. Lastly, from this perspective, jquery skills necessarily indicate javascript skills, but javascript skills do not necessarily indicate jquery. It is likely that js indicates jquery, but you get what I am saying. Make yourself an easy choice and you will get calls. You are already at a disadvantage if you are just starting out. 
You're on the right track.
Welcome to the 21st century. You are a product and you should get good at selling yourself. I agree, ends up as soulless bullshit.
This is true. 
Swift programmer with 10 years experience checking in.
[The Art of the Developer Resume](http://www.developerdotstar.com/mag/articles/read_resume.html) I followed this when redoing my resume 14 years ago and never had a problem landing an interview since. 
I dunno I think the practice can be fun. If it's a bad question it usually gets downvoted anyway 
I mean `:!` exists...
I would agree that developing strong js skills is the best way to go, especially for devs who are just getting into the industry. It seems like every week a new, hot framework comes up and it is all the rage. And yeah, it might make things easier and save a lot of hours, but the lasting skill that will help you long term is a solid js base. If you are a solid, well versed js dev then you can adapt to ember/angular/node/whatever2.0. However, that doesnt mean that I can convince a hiring manager to interview you when they are dead set on hiring an early adopter of the new, shiny js framework. The majority of the time I feel the pain with the devs I am working with.
On the flipside, some shops want someone who really knows that library. A couple of years ago, I had an interview at a startup and the interviewers went back to my agency and told them I didn't know Javascript despite the only questions I got wrong were the jQuery ones -- esp. when I was getting questions like, "list all the options for $.ajax," which isn't something most developers are going to know off the top of their heads. Still, that just goes to show that there are some companies that put more weight in having devs know the library over knowing the language.
That's my attitude on the subject -- I usually see something like that as the brown M&amp;M in David Lee Roth's candy bowl. If the interviewer is this much trouble, I'm sure there are other issues with the company.
It's not a clipboard that can be overwritten, I don't see the issue.
On line 137 of the JS - it seems that you are creating multiple instances of Google maps - rather than getting a reference to the existing map. This is causing the errors. var map = new google.maps.Map(document.getElementById('map')); Removing line 137 completely fixes the immediate issue. Unfortunately this fix relies on the 'map' variable which is created in the outer scope. You may need to find a way to refactor the code to better encapsulate the map reference.
Okay, I'm going to throw another long comment in here, because I think it is worthwhile to lend some perspective on the other side of the phone. First, recruiting is a very high turnover industry. I went from managing in retail to tech recruiting and we had much higher turnover in the recruiting firm. It's due to a learning curve combined with commission driven compensation. So, the young recruiters come in, start learning, build up their contacts a bit, and most wind up leaving the industry before they can get a foot hold. At first, they're missing the mark a good deal. They're calling designers for developer jobs. They're trying to submit pcb layout designers for high speed board design jobs. Usually, it takes two to three months to get the person through this phase, depending. The second phase is when you at least have some idea what is going on. If we're looking for someone who has extensive experience with 802.11 driver development, they might submit a low level kernel/driver developer, they may or may not hit the mark for what the requirement is. Usually, if they do it is a function of volume and luck. A lot of this business is a matter of volume and luck. Some recruiters, even successful ones never get an understanding much deeper than this phase. Finally, you get the people who like tech and stick with the agency for a while. They start to understand how things fit together and where the skills lie. They will google keywords that they don't know before they start working a req to see how skills all fit together. The truth is that due to the turnover, most of the recruiters you talk to are in the first or second phase of development. Asking a tech recruiter about themselves is not rude. Feel free to ask them how long they've been doing it and what kind of skills their firm typically works on. In fact, when I was starting out, I had several contacts who were really cool and helped to explain a req, why they were or were not good for it, and exactly what I should call them on. That's not your duty by any stretch, but due to the nature of the beast, most recruiters learn by talking with engineers. There's usually some powerpoint slides or a presentation first, but that only goes so far. Second, there's the fact that you can and should choose your recruiters wisely. You should be able to put your resume out there without being blasted with ten thousand calls. I tell engineers all the time that they should put a google voice or burner number on their resume. Then, if they decide that a recruiter is someone that they want to work with, they should give that person their actual number. Talk to the recruiter on the initial call. Ask about what their firm specializes in. For tech, you want a tech recruiter at a tech firm or at least in a specialized tech group within the firm. Ask some questions about the job. See what their responses are. The truth is that having a set of 5-10 recruiters that you work with should be able to get you in on most reqs. You should also know that statistically, the chance of me placing you at the first job we work on is pretty low. It just doesn't happen that often. Success in this business comes from the second and third efforts. Most people interview for 4-6 contract or even more perm spots before landing something. That's total, usually, not just the interviews I get them. So, if you find a recruiter that you like, stick with them. Even when I'm not in on the req, I've had a few circumstances where someone that knew and trusted me sent me a jd to find because they were on some massive email list for an overseas firm and they would rather work with me. Sometimes I had a contact at the company, sometimes the answer was that I wasn't in and they would have to go with someone else. One last tip: ask the recruiter what their relationship with the client company is. Are you on their vendor list? Do you subvendor though someone else or go direct? Have you spoken directly to the hiring manager or do you go through a system? You can and should choose your recruiting firms like you choose any other service you're buying.
Yes it does, If someone can develop a complex app in Vanilla javascript then they CAN you jQuery. jQuery is simply a library and it can be mixed in directly with Vanilla Javascript. Sometimes people write plain javascript to improve performance. 
I feel you. And sometimes you can get away with it. And sometimes you have to put on a show to get what you want.
Don't confuse HR with an organization. These are glorified keyword filters, drawing a paycheck.
Buzzwords are for the HR ladies. They know next to nothing. I actually interviewed a candidate today that was loved by the HR lady. She has all the qualifications on paper. When asked some simple questions ( what is variable hoisting, what's a closure, what are promises, when use apply vs call ). But she knew none of that. Her resume was solid - so it was apparently either bullshit or she just really had an off day. TLDR: Don't sweat it. Your skills will shine through even when the HR ladies suck. 
Honestly, if these sorts of companies do this, do you really want to work there?
This won't be an issue at any place that you'd *want* to work.
what part of **&gt;&gt;&gt;&gt;KICK ASS JQUERY ROCKSTARS ONLY!!!!&lt;&lt;&lt;&lt;** did you not understand?
All of recruiting is show and bullshit, but you need to play the game to get the good jobs. Let me describe it from my side as programmer in a mid-sized software company. * Someone on my team leaves or we've got more work than we can handle so management open a new head count for me. * I have to craft a job description for our recruiter. It can't just say "I need someone who is technically really good and can pick up stuff quickly". I need to list specific technologies, describe culture and make it sound interesting enough that decent people want to apply. I don't want to write this as we've got a deadline and I have proper work to do, but I need to do it. * Hundreds of resumes start flooding in. Everyone claims to have JavaScript experience. I've got to pick through each resume and decide if they really do. Each resume probably gets 2 minutes of my time. They all have links to projects, etc. There is no chance I'm going to click on those as my 4 hours of resume reading will turn into 4 days. Most resumes are not relevant for the job. Our project deadline is still approaching. * Once in a while someone will have listed all of the relevant technologies from the job description near to the top of their resume. They have also included a line in the summary at the top of the resume that talks about wanting to be in the specific industry our software company is in, and their cover letter has one line about what they like about our company. This resume is like a life raft to a (highly caffeinated) drowning man. * I get our recruiter to call 20 or so people and ask them to run through three or four simple technical questions. Most of the applicants fail as their 'expert-level' JavaScript turns out to be they once copied a script from the web into a webpage. * I have to phone interview, plan and run a short code test, in person interview, office tour and arrange team interviews for 6 or 7 candidates. There goes another week. My work on the project is now very behind schedule. Even so, I may spend 15 mins looking at your linked projects before you come into the office. * If we're lucky then one of the interviewees will be able to code, interact in more than grunts and not annoy any team members and we can start salary negotiations. * I've now spent nearly 2 weeks of my life recruiting for one position. The main project still rolls on. It's all show and bullshit, but make it look like you've read the job description and you're ahead of most. I can guarantee the person on the other end hates it just as much as you (and if they don't, you probably don't want to work for them).
Right, I understand that having solid javascript skills means that you can pick up jquery in short order even if you've somehow never seen jquery at all. However, all elephants are grey, but not all grey animals are elephants. So yes, they largely coincide, but you never want to assume, no matter how obvious you might think it is. The reality is that these days managers often aren't willing to accept ramp up time, even if it is minimal. There's more tolerance for the idea of ramp up with ft rather than contract roles, sure. I talk to 90% of the managers for every req that I work with directly when we take on the req. I go through the jd in depth and talk about each skill call out. You'd be surprised how often the "desirable" or "bonus" skills are actually hard requirements that will make or break a submission. You'd also be surprised how often managers are also guilty of the 6 second resume glance. Sometimes, I have been able to get them to read more in depth, most of the time it's an uphill battle. You just want to make it as obvious as possible. They're not going to work at hiring you, not HR, not the recruiter, and not the hiring manager. The HR/recruiter may or (likely) won't know what the hell they're talking about outside of the keywords. The hiring manager will be handed a stack of 10 resumes, especially for a jr level role. They will glance through and narrow it down to 5 and it will be the 5 resumes that look (from 100' away) like a javascript dev who has projects heavily dependent upon the use of jquery. Then, they will read those 5 a little more in depth. They might interview 2-3 of them. Most of the time they won't go to your github until they've become interested in you on paper. Often, they won't go even after that. It may be more prevalent for jr level spots. I don't know that, honestly. I will also say that most of my opinions on this matter are colored by the fact that I've worked almost exclusively on senior level stuff with the occasional mid-level req along the way. In my experience, someone like you, a self taught dev looking to get in, is generally better off going to meetups, hackathons, etc. You need to be able to talk with these people and show your abilities real time. I've placed a few people in your shoes, but they were people with long histories of sw development who made a sharp, self-taught direction change. One was a 20 year experienced embedded dev who learned android on his own and made the change to app development and the other was a web developer who got into iOS. He built an app and won a contest. That got his foot in the door. But, both of them were tough sells to hiring mgrs even with solid backgrounds outside of their desired field. Lastly, I would say that listing your hard skills on your resume is not buzzword cramming. Saying that you're a rockstar-ninja-badass who works on the bleeding edge is.
As a start-up founder and somebody who's done dev...there can be, and not saying there is in your case, but very good reasons why color changes have to be made. It's up to the manager to communicate it properly though and I've experienced it first-hand what it does to people when these requests are not communicated as such. These requests then become demotivating and uninspiring and I hope never to have my company become like this. But (get ready, eye rolls are about to come in) - I've changed URL colors slightly and gotten feedback from people saying it looks amazing. Or I've cleaned up UI just slightly, and its changed the entire perception of the product. Even though I spent two weeks refactoring all the backend code - making it faster and scalable, and then creating awesome features and nuances....nobody notices unless I tweak the colors. This used to frustrate me to no end. But as I've transitioned from a pure dev into the business side, I realized it's not a bad thing. The goal of a good salesperson is not to sell but to demonstrate the value of the product. Often the salesteam knows the customers needs and what they desire. I find even when I disagree with the customer, I will make the change for them, then step back and see I really like those changes then implement it across the platform. 2 years ago I would've totally agreed with the "new marketing campaign synergy" b/s, but after seeing it produce great results and see how it changes the entire perception of the product, I can't help but listen. I can't stand when it's done for the sake of bureaucratic political bs reasons though. That's very frustrating and I'm sorry if a company is making you go through that :-\ I think a good manager should communicate why certain steps are important because it can be very frustrating/demotivating to have 1,000 things and then an office-space type person comes and asks you to tweak colors. It's like, "u serus?" Nobody has said it to my face in business, but I KNOW I tend to overcommunicate. After being on the other side, I much prefer overcommunicating decisions that seem arbitrary vs the alternative. While I think others are happy, I also know part of them wishes I would say the same thing without going into a philosophical discussion. Working on it...
Checking it out right now. That's good stuff. You've set up a really cool interactive resume. Like I said elsewhere, I probably wouldn't be the guy who would be able to help you, and I'm not sure if there are many agencies that work on jr/mid level roles, but you're on the right track. If you get a manager on that website you'll be doing great. I think you should make up some cards with that url and your contact info and hit the meetups/hackathons/whatever in your area. That'll shake something loose. The challenge for you is going to be to get someone to dig into what you can do. You've obviously done a lot of hard work to get to where you are. So, congrats on that. It's a really good market right now. Don't get discouraged by the machine. It's a process getting in and established. I can look at that and tell, from the effort to get to building that CV site from zero, you'll get a job. One bit of feedback though, the text when you hover over your code review says "imporved." Best of luck.
 (function() { console.log(055); // 45 }()); Strict mode: (function() { 'use strict'; console.log(055); // SyntaxError: octal literals and octal escape sequences are deprecated }()); New octal literal syntax: (function() { 'use strict'; console.log(0o055); // 45 }()); https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Numeric_literals
Its kind of tough to look at a templating engine in isolation. All my work these days are within the walls of a major framework. For longevity reasons, it's hard to move away from big ones since the js world shifts on a dime. That being said, I checked out the code and its clean as shit. Well put together and organized which is touch when you write the entire thing yourself. Maybe it will never pick up, but you should be able to show that to any prospective employer or client and be proud of it.
Seriously, If you are good enough a javascript, you could re-write jQuery. The same cannot be said the other way around. One of my co-workers has admitted to not knowing any javascript but he "knows a little jQuery" (he's a designer). 
Nice. I'm going to start sending this to some of the engineers I know with atrocious resumes. I have a few example chunks from the best resumes that I've worked with, and I use those to send (with permission) to developers with horrible resumes. I just have snipped screenshots of the portions that show what I'm trying to get across. There's nothing more frustrating than having someone you've spoken with in depth, knowing that they're technically solid, but running into trouble getting them an interview because they're not resume writers.
Use Babel with Flow types!
&gt; I am shocked! Don't be. Most tech recruiters suck. Most companies write shitty job ads. The trick is cast a wide net. Occasionally you will find a rational company with rational people handling the hiring process.
Be careful. You might end up used as a replaceable code monkey. You might also end up being underpaid.
honestly, I have a very self deprecating sense of humor and like to present myself in a more open and honest manner. For example I was thinking about handing out business cards thats says: &gt;*writes highly coupled spaghetti code, sure to exceed all call stacks* &gt;**aptly able to increase any algorithm's computation, with exponential results, no base cases needed** anyways, maybe it's bad, but as someone who has been burned by a few past colleagues who had "Mr. Awesome Numero Uno" Linkedin profile, I just can't get myself to put on a fake face. I just like to cut the bullshit since it's counter productive, and I almost feel like people who drop buzzwords are just too worried about appearing to be what they're not. All of the smartest people I have ever met don't care about that crap it's the ideas/discussions and cool and new insights that matter, and what I enjoy. So no I just don't wanna be that guy who spends his working hours on **LinkedIn** typing out his blog about "office place synergy". I prefer more collaboration and working towards a goal I guess. 
yea /u/senocular is correct ill add that: * '00005555' a string is the best way to store this data * you can write a padding function if you want to store as integers. a padding function takes a number '5555' and adds 0s to the left side until the desired length. so with padding you can do myInt = parseInt('00005555') // 5555 order({quantity: 10, id: myInt}) outputInt = pad(8, myInt) // '00005555' a padding func looks like (but theres more ways to do it): function pad (n, val) { val = val.toString() for (var i=val.length; i&lt;=n;i++) val = "0" + val return val }
Npm as build tool only works as long as you have a small set of build tasks. But if your build process is longer - babel, linters, jscs, unit test, e2e test, 20+ valid tasks to improve perf etc (and we're using this in a real ecommerce webapp), the package.json file becomes bloated. Then to clean that mess, we move some of the tasks to a separate js file and voila, you're back to when you were using gulp or grunt. Npm can used to abstract the tasks (npm run dev, npm run prod etc), but the actual tasks should be written using gulp/grunt/etc if you have more than n tasks.
Don't go through recruiters. 100% of your time, it's a waste of time. There are 4 good places to get started. 1) Angel List, http://angel.co. Fill out your profile and look around for companies that have roles you can meet and express interest. Also, other companies will contact you. 2) Look at Hacker News under the job section. http://news.ycombinator.com. 3) Craigslist. Depending on your area, Craigslist is still a great place to look for job positions. You'll want to look at internet engineers and software/qa. 4) LinkedIn. It's mainly going to be spammy recruiters trying to contact you, but you'll often get a few contacts from legit representatives at various companies. It's worth putting up your basic info. One critical thing is to differentiate between an external recruiter and internal. Larger companies have internal recruiters as part of HR. Talk to those people. Avoid people that are "on behalf of" a company. You'll learn to tell the difference pretty quick. The biggest clue is the email address. If it's from the domain of the company, you're in the clear. Good luck!
No, don't do this. 
I run a company. I absolutely want to see a working product rather than a bs CV. If a person lists every little thing he has ever used on his CV, I assume he's trying to compensate. Not a good sign. I personally don't use recruiters though. And I work with people on a contract basis first before hiring fulltime. I also ignore education in favor of experience.
Now I want to hire you. How did you do that, I'm not even HR!
&gt; A classical inheritance heirarchy quickly becomes brittle and difficult to maintain. Programmers cannot predict the future and eventually a feature request will come that you weren’t expecting and will break your taxonomy This behavior you're describing here -- brittle taxonomies -- is actually **not** a consequence of classical inheritance, but rather it's a consequence of **single** inheritance. *Either* classical or prototypal can support *either* single or multiple inheritance. For example, C++ and Python are classical and they support multiple inheritance. Meanwhile, JavaScript is prototypal yet supports only *single* inheritance -- which means JavaScript's inheritance model suffers from that brittle taxonomy you described. &gt; * The Two Pillars of JavaScript * Common Misconceptions about Inheritance in JavaScript * Ultimately – “Software needs to be better“. On that note, I’ll leave you with these fine words of wisdom You should know that both Elliott and Mattias have some fundamental misunderstandings on topics such as inheritance and composition (among others). For example, what they refer to as composition is actually multiple inheritance (see this [top voted reddit comment](https://www.reddit.com/r/programming/comments/3m64ns/composition_over_inheritance/cvccr2u)). They also confuse single inheritance and classical inheritance... a mistake I suspect you picked up from them.
From dev perspective: almost every modern app/site includes a build process which involves these dependencies. Moving them to a remote server, even if it's cached, would not make any sense. From user perspective: making N remote requests vs ONE single request to a previously built file doesn't make sense either.
You were probably overqualified.
At the top of my CV I have a "word cloud" of the technologies I can claim to have experience of. This cloud is trimmed to match and exceed the job requirements. I have been challenged in interviews about this, but that's when I'm in the interview passing through Agents/HR, so the cloud has worked. (Which is also what I say when challenged)
&gt; If so, how ? Since it's supported in current (formerly io.js) node.js, What do you mean, "how". *Just do it.*
I would assume you could tweet them
When I was applying for jobs, I made two CVs: one was the CV to be given to companies, and one was a short-form CV for recruiters. It was less a CV and more of a brief. It was essentially three billet-pointed lists: "here are the things that I do well"; "here are the things that I don't do well but would be comfortable improving"; "here are the things that I want to avoid at all costs". I listed everything out, and it didn't even reach half a page. I wasn't trying to sell myself, or list my achievements: this was just about skills and keywords. The recruiter loved it.
This is my first github contribution, I hope the javascript community could give an awesome feedback :)
Your regular expression matches too much. If my query has ?limit=40&amp;offset=10, you'll be matching both ...t=(40) and ....t=(10) Hope this can help you: Instead of doing everything with one regular expression, try breaking it into small problems window.location.search // strip ? off beginning .replace( /^\?/, '' ) // separate them by '&amp;' (into an array of query strings) .split( '&amp;' ) // convert each query string into `{ key, value }` .map( param ) ; /** * Turns query param into * a param object */ function param ( paramstr ) { // 'name=William%20Hung' var keyVal = paramstr // -&gt; [ 'name', 'William%20Hung' ] .split( '=' ) // -&gt; [ 'name', 'William Hung' ] .map( decodeURIComponent ) ; // -&gt; { key: 'name', value: 'William Hung' } return { key: keyVal[ 0 ], value: keyVal[ 1 ], }; } With that code, you'll have an array of [ { key, value }, { key, value } ] Then you can check if one of those objects has key === 't'
If you want to use arrow functions, specifically, you can throw in some functional programming. function isType ( whichtype ) { return ( { type } ) =&gt; type === whichtype; } searchDetails.filter = isType( 'person' ); 
One thing I like about including my tests one level deeper than the implementation is that I can take that folder (by itself) and theoretically have a full, testable group of code. So, components/ Menu Item Spacer SubMenu index __tests__ Menu-test Item-test Spacer-test SubMenu-test ... ... If all of my tests are in a "test" folder, I'm more inclined to test *everything*, not small pieces. Tracking import SubMenu from '../../src/components/Menu/SubMenu' starts to get very unclear when you have deeper nesting. I mean, that is only one folder deep into components and it's very specific to how I've laid out my project. Now, if \_\_tests\_\_ is contained within the folder, I can move the /Menu or /components folder and the tests are unchanged. By using a sub-folder, every tested item is a ../ away
That seems fine for me too. But I am still wondering why Jest wants so much underscores in for tests dir 
Well, I am curtently using npm and browserify, I know what you are taking about, but for me it sounds interesting to have the web working together to reuse resourses instead of copy and paste into my own server
I think it could be to clearly distinguish it from the others, always making it the first folder and not just somewhere in the mix
Love it! You might want to add facebook meta tags to the demo site so it can show a preview image, it's not finding any so it's not as exciting to share there.
Id really appreciate if someone could compile: https://github.com/GeertjanWielenga/TypeScript and deliver a NBM File that I could import into NetBeans. Id rather not install Eclipse Portable again. So many annoyances. And I only use the most basic features, file search and project search, breakpoints, and it still fails so bad.
If a function signature changes, either (a) it's incompatible with the old signature and being forced to revisit every invokation is exactly what you want, or (b) it's compatible with the old signature and you don't need to update every invokation.
What you said works for IT companies, not for recruiters. Recruiting people sometimes are not technical, so they just check the keywords.
As a junior, you should not be going through recruiters. I've worked for several companies that refuse to use recruiters for developer positions anyway. They are too expensive (3-6 months salary) and as soon as they legally can they start harassing the people they placed about whether they want to work somewhere else. Sure, there might be honourable recruiters, but it's only ever worth it if for a company if they need to keep the fact that they have an open position a secret or if they need someone highly specialised (and experienced!) who is hard to find. My boss got suckered into a "can we please send you some resumes, you don't need to pay anything until you see something you like" kind of deal with a recruiter. The resumes were lifted straight from a Monsterboard-like site (it was a government site that was semi-compulsory for people on unemployment). Even worse, one of those "candidates" actually applied directly to us (since it was an open position) and had no idea he had been submitted by the recruiter, so we turned him down because we cannot afford a legal battle with the recruiter about the matter. As someone with no work experience, recruiters may also "use" you by submitting your resume or even sending you in for interviews just to make other candidates look better and to comply with the agreed upon "number of candidates" they are supposed to find. You don't sound like the kind of person who would benefit from these practice/bullshit interviews, on the contrary, you'd be embarassed and the rejections would erode your confidence. So for the kind of position you want, do not use recruiters, not even "on the side". As for the jQuery, just add it to your buzzword list from now on. Do not remove anything else, since 'jQuery' on its own says absolutely nothing about your skills because of how easy it is to use for people who know only CSS and who can't actually program. 
Here is a nice list for the end of 2015 but I guess the list is pretty good http://www.smashingmagazine.com/2015/06/upcoming-web-design-events-june-december-2015/
Recruiter does not know what they are doing really and as others have probably mentioned they are looking for buzzword hits.
Would love to see your implementation aswell!
translation: sorry, we want someone clueless that we can pay in peanuts.
So, "eat the loss by leaning on advances in other areas"? How comfortingly familiar.
Using VS on windows to create web apps still puzzle me. The ecosystem is very much command line and the tools and libs change so often that the support you are looking for with intellisense in VS is always going to lag behind.
nice ... what is clicking meant to do? left/right clicking just seems to clear the visualisation for me. http://i.imgur.com/jf1ATMz.gif
&gt; Ordnung.js is licensed under GPL 3. &gt; &gt; You may use this library at will – if you mention the author. That is incredibly misleading if not contradictory. Attribution is the one thing the GPL doesn't require. The GPL is a viral copy-left license. Any code using this library needs to be distributed under GPL as well. Unless the project is already under GPL or trivial, this is likely a bit excessive considering the value the library brings to the project. It's perfectly fine to publish your code under the GPL, but that blurb makes it sound as if the author either doesn't understand the GPL (maybe they were thinking of the LGPL?) or is unintentionally deceptive about its implications. EDIT: I'm guessing it's GPL licensed because isotope itself is GPL licensed. But if the author thinks it has to be GPL licensed because it is inspired by isotope, the attribution requirement is invalid.
This x1000. If you can talk to a dev or PM who works there and end-run the recruiters you are way ahead. Most of the people I have hired or saw being hired were through word-of-mouth and personal networks.
Options objects are a great example of what makes Javascript awesome, especially with the new ES2015 destructuring. TypeScript is a great example of non-javascript developers pushing ideologies from other languages onto Javascript. Sure, the popups look cool. But if you're writing Javascript, they're completely unnecessary. Any function that requires a popup for me to "remember how it works" is a function I need to refactor. Besides, using the IDE to do most of the work for you introduces another layer between you and your code. Convenient, yes. Makes you a better/more productive developer, no.
Most recruiters know very little about the technologies they recruit for. Assume nothing. Buzzword everything. Expect Java jobs. 
You have not to know anything to become a recruiter.
Might want to make a [jsbin](http://jsbin.com) of this. Or a [codepen](http://codepen.io). Or a [cssdeck](http://cssdeck.com). Or, you know.. anything that makes it easier to see what you're working on.
&gt; which has a practically identical [...] syntax to IDOM's That is very untrue. They are fundamentally very different. IncrementalDOM works on the basis of an implicit global cursor, with function calls writing at the cursor's location and moving the cursor, whereas `createElement` is self-contained and writes only to its return value. Coding for one or the other is very different. For example, something as simple as creating elements out of order cannot be done with IncrementalDOM. The plugin is an awesome project, and very ambitious. (Not sure where you got "building" though, it's complete.) It's also a great way to see just how different these two are. For example, here's the demo they give: **Input (JSX)** function render(data) { var header = data.conditional ? &lt;div /&gt; : null; var collection = data.items.map((item) =&gt; { return &lt;li key={item.id} class={item.className}&gt;{item.name}&lt;/li&gt;; }); return &lt;div id="container"&gt; {header} &lt;ul&gt;{collection}&lt;/ul&gt; &lt;p {...data.props}&gt;Some features&lt;/p&gt; &lt;/div&gt;; } **Output (IncrementalDOM)** function _attr(value, name) { attr(name, value); } function _renderArbitrary(child) { var type = typeof child; if (type === "number" || (type === "string" || child &amp;&amp; child instanceof String)) { text(child); } else if (type === "function" &amp;&amp; child.__jsxDOMWrapper) { child(); } else if (Array.isArray(child)) { child.forEach(_renderArbitrary); } else { _forOwn(child, _renderArbitrary); } } function _forOwn(object, iterator) { for (var prop in object) if (_hasOwn.call(object, prop)) iterator(object[prop], prop); } var _hasOwn = Object.prototype.hasOwnProperty; function _jsxWrapper(func) { func.__jsxDOMWrapper = true; return func; } function render(data) { var header = data.conditional ? _jsxWrapper(function () { return elementVoid("div"); }) : null; var collection = data.items.map(function (item) { var _item$id = item.id, _item$className = item.className, _item$name = item.name; return _jsxWrapper(function () { elementOpen("li", _item$id, ["key", _item$id], "class", _item$className); _renderArbitrary(_item$name); return elementClose("li"); }); }); elementOpen("div", null, ["id", "container"]); _renderArbitrary(header); elementOpen("ul"); _renderArbitrary(collection); elementClose("ul"); elementOpenStart("p"); _forOwn(data.props, _attr); elementOpenEnd("p"); text("Some features"); elementClose("p"); return elementClose("div"); }
I am a huge fan options arguments for a couple of reasons: * All options are optional. Those that must be mandatory require the function to specifically address this with a rule which should provide some output or error case that can be communicated back to the user. * Supported options can be analyzed against default values and statically typed * If you have multiple libraries sharing a common API passing around a single options object keeps everything uniform and ensures no single option gets dropped. An example of mandatory options: function (options) { if (typeof options.source !== "string" || options.source.length === 0) { return "Error: missing source, which is required."; } } In the above example all options coming from an options object are optional, which forces me to deal with those few mandatory options with rules. It also forces me to deal with those rules in the architecture of my application with detailed messaging of my choosing instead of just throwing some stupid code error that is far less helpful. Notice the early return, which means the problem is identified and dealt with gracefully before it causes the application to crash. Here is an example of detailed options analysis: function (options) { (function () { if (isNaN(options.characterSize) === true || options.characterSizer &lt; 0) { options.characterSize = 0; } }()); } In the above example I can always ensure each option in my supported API is a certain static type or conforms to a certain specific value. There is one major difference between this way and the op's example in that I am assigning the desired value/type back to the option property instead of to a new variable. This has some performance implications due to type recasting, so I have sheltered my options analysis in a child function which does not get hoisted due to IIME. I do this because.... option sharing. If you are working in multiple autonomous libraries sharing from a common API then you need to pass the options argument around in full to ensure each library is consuming things uniformly without things getting dropped. For example, I support a JSX parser/beautifier which means a JavaScript parser calls a markup parser that can then recursively call the JavaScript parser and so forth. This markup parser also calls a JavaScript parser and a CSS parser when working with HTML in the case of inline code. I used to operate exactly like the op's example until about a week ago when errors were reported that options are not being shared across the libraries correctly. Perhaps manually defining the options against internal variables is trivial if your API is small. The API in my application is around 40 options. The API in the JSCS project is closer to 100 options. This is not trivial. It makes so much more sense to do the following than have to specify each option against a property name when the options are already appropriately packaged. //inside my JavaScript parser markupToken = markuppretty(options); //too simple
For fun? Yes! For money? No!
&gt; The entire point of building the 'so called viritual DOM' was to let developers focus on higher level patterns of abstraction, and re-use the same code in multiple environments. You're conflating a bunch of different things here. - "let developers focus on higher level patterns of abstraction" is the result of mutation only through refreshing. This could be achieved just as well if `render` were to really construct and return a DOM tree. - "re-use the same code in multiple environments" is the result of componentization. React could have just specified component contracts without even helping a component to render itself, leaving us fiddling with `document.createElement` ourselves, and still achieved this. - The point of the virtual DOM really is just a performance optimization, necessitated by the fact that refresh-only mutation doesn't play nice with DOM output.
Sure, no one is pretending that legitimate business reasons for things don't exist, I was more referencing such requests coming from people who should have no damn business making those decisions, or who should have made them months ago when they already knew it needed to be done (pyro employees... always creating fires for others to put out).
Web scale actually means something in context, though. When someone asks "does it scale?" They are asking if their initial estimates for traffic are too low, or there is a spike in usage, will the application become unavailable? 
Beware the Java and Javascript distinction though - I've been offered so many Java jobs because they just search your CV for "hits".
Because you if you have an indeterminate number of those things on the page, then you have to dynamically generate unique ids via a sequential number or uuid or something, which is hard to target with css. It's usually better to use classes to avoid this, although ids are required for a11y in some cases.
The website looks like a scam: cheap knockoff of a mainstream style, free and low-quality everything (textures, typography, layout, etc), and, most importantly, a **ton** of bullshit marketting terms with hardly a single phrase that actually forms a meaning they could be held accountable for. They could be offering me cash for nothing and I'd still be scared to interact with them.
For client-sided web stuff, you'll need to know some JavaScript. There's no way around that. If you need a scripting language for a game or native app, things are different. JS isn't mandatory there and Dart is much easier to work with. I also think it's much nicer than Lua, Squirrel, engine-specific scripting languages (UnrealScript, UnityScript, ...) and other popular options. Another good target will be weaker SoCs with very little RAM (e.g. that IoT stuff). JS VMs are just way too fat for that. Fletch, on the other hand, only uses ~4 KB per process. So, it really depends on what you have in mind.
&gt; making N remote requests vs ONE single request to a previously built file doesn't make sense either. Liar. In the world of http2 it makes a lot of sense to make separate requests for separate libraries, because that way caching is much easier and effective. Sadly not all apps are running on http2 yet, but most big names like facebook or google are already running on HTTP2.
[JSPM](https://github.com/jspm/jspm-cli) has a cdn mode where it serves it's packages from a cdn. It can be switched to it by using this command: ``` jspm setmode remote ```
Hahaha, that's awesome. :D I don't know, probably just tweet at them with a screenshot or a quote I guess.
Most code you read isn't yours. A black box of options just forces me to consult documentation that will inevitably bit rot 
Thanks. Didn't know it could do that.
Crazy stuff! Thanks!! Would you mind giving me an ELI5 on 'use strict', please?
If you're working directly with an independent recruiter expect to get lined up for shit jobs. Personally I would avoid them. Go directly for companies that are advertising openings, customize your cover letter and resume for what they are looking for (as long as you are being honest). Getting interviews is all about getting noticed. You need to set yourself apart from the other 100 people sending them stuff. 
Seriously? Since when is HTTP2 the standard? I think I missed that memo.
The above syntax is more problem than solution in case where there are many options. Imagine maintaining that when there are more than 12 options and the options have to be shared across various libraries.
&gt;So I have just started my job search after spending almost all of 2015 learning CS and programming from C to Python, JS and Rails. Wow. A whole 10 months of experience? 
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Strict_mode Strict mode is, well, stricter. It doesn't allow implied globals and crap like that. E.g. this produces a ReferenceError instead of creating a global variable called "asdf": (function(){ 'use strict'; asdf = 5; }());
&gt;So I have just started my job search after spending almost all of 2015 learning CS and programming from C to Python, JS and Rails I'm surprised they even looked at you. And look, it's not buzzword bullshit. Devs gave that recruiter a list of skills to find. Your skill set doesn't match it. End of story. That person has hundreds of people to sift through. They don't have time to baby every resume for one job. You'd do the same thing. Ask a dev how many tickets they've chased down and addressed with incomplete replication steps and descriptions? Even if jQuery is easy to learn and the recruiter understood it versus JS, there's a huge difference between somebody who's a veteran at it, and somebody who's done a few ugly, inefficient DOM manipulations. As a dev, I'd never hire somebody who didn't list jQuery on their resume when I was hiring for it. It's just a hassle. 
&gt;Options objects in general are often frowned upon because they hide the expected interface. What's the expected interface? To put all of your parameters into a function one by one and never get them in the wrong order or miss one, ever? Who doing the frowning?
&gt; you have to dynamically generate unique ids via a sequential number or uuid or something, which is hard to target with css If you're talking about component-based frameworks like React, it doesn't even use selectors to apply styles - it does it all inline. If you're talking in general terms then there should never *be* more than one of anything with an ID in a given page, making the "autogenerating IDs" point moot. Conversely, if there *are* singleton elements of your page, using classes to target them is: * Misleading (as classes imply the possibility of multiple elements) * Inefficient (as IDs are unique they permit DOM lookups orders of magnitude faster than classes) In either context, saying "id selectors (and id DOM attributes) should really be avoided" is nonsense - it's basically irrelevant to React, and it's inaccurate and misleading if you're talking about CSS generally.
&gt;I hate that stuff though, the reason why I went in development was because I felt that the business world is all show and bullshit, Developers get to avoid the "show and bullshit". That's why you and the people who actually do the first pass of your resume are stuck with this crap.
anal swordfish indeed. 
Looks like since May 14, 2015. https://en.wikipedia.org/wiki/HTTP/2#Development_milestones
I know. That was the point I was making.
&gt; a lot of people **using underscore** FTFY, although you can achieve the same using generic JS, just not so concisely.
A function with more than 12 options looks like code-smell to me -- your is probably deals with too many concerns.
&gt; The argument is that people who use typescript don't get nice autocompletion popups/they can't be statically analyzed. No, it's bad for people who use ES6 (or TypeScript). This stuff is inaccessible to static analysis. &gt; I like options objects, they are extremely useful That's not an argument for anything. &gt; I'm pretty sure this is exactly what interfaces and typescript definitions are for That's not an argument for using them in ES6. &gt; Advising people to use a particular pattern for the benefit of a different(ish) language seems pretty selfish Huh? Option objects work great in TypeScript if you augment them with interfaces. They do not work great in ES6. Again, this is not an argument for using them in ES6. Anyhow, here's what I said last time (comes with GIFs which illustrate the tooling differences): https://www.reddit.com/r/javascript/comments/3qc1e3/best_practices_about_the_factory_pattern_vs_class/cwe2dm5?context=3 If you use TypeScript, option objects work fine if you augment them with interfaces. With ES6, destructuring works much better than option objects. In the future, we'll also get auto-complete and better call-tips if destructuring is used. The situation with option objects, on the other hand, will remain as crappy as it is. There simply isn't much one could do about that.
&gt; To put all of your parameters into a function one by one and never get them in the wrong order or miss one, ever? ...yes? That's how functions work in most languages that have borrowed their syntax from C. And a bunch that haven't. Has modern Javascript fashion so deteriorated that it's now out of vogue to *define a function*?
That's just the spec publishing date. By following that logic, ES2015 should be the standard since June 2015, yet we still need tooling to run it in browsers.
You should use javascript and timers to handle what you want. Here is a simple example, you should improve: http://jsfiddle.net/tu27hnrj/
[removed]
Here are some projects with 12 or more options. Are they all suffering from code smell? * https://github.com/beautify-web/js-beautify * http://prettydiff.com/documentation.xhtml#options_definitions * https://github.com/glavin001/atom-beautify/ * http://jshint.com/docs/options/ * http://jslint.com/help.html
&gt; Not sure why people think OP's description is unclear. Is div2 inside div1? Div2's position and opacity is changed in response to what? Div2's position is changed from which value to what other value? The description is simply incomplete and there is no context to fill the blanks.
&gt; To put all of your parameters into a function one by one and never get them in the wrong order or miss one, ever? So... _literally_ every native function and _most_ library functions? Yes, exactly. That's how functions in _nearly every_ language work. Alternatively I'd argue that required arguments should _always_ be written out, either in this syntax or something like: function foo(url, data, method, options) {
See also: http://es6-features.org/#ParameterContextMatching
Wait... that doesn't make sense to me... += takes what's already in the element and adds to it, right? I know I've used it in this fashion before. The &lt;div id='one'&gt; shouldn't be destroyed or lose it's eventListener... Hold on...
&gt;Has modern Javascript fashion so deteriorated that it's now out of vogue to define a function? I guess its out of vogue to define a function in such a way that its annoying and easy to make mistakes when using it. If I have a function with 7 parameters I don't want to have to remember what order they're supposed to go in when I'm feeding them into the function. Its just unnecessary and its going to lead to mistakes. I'd rather throw them all in an object in whatever order I like and give them all labels so the function knows what they are when it gets them.
You should never pass 12 arguments to a function, but a single options object is far more sane. As far as a solution I wrote one in this thread: https://www.reddit.com/r/javascript/comments/3qoc8v/hating_on_options_objects/cwh1gzu
Here: http://codepen.io/ForScale/pen/doXdVa What's different?
How is it working here: http://codepen.io/ForScale/pen/doXdVa ? Today is the first day I've ever experienced any issue with adding text or elements to the body of a doc... I'm thoroughly confused...
Okay, so in your solution if you have 12 options you have 12 checks, and a lot of `if (opt.foo) {` calls. What's wrong with: function foo({ a = true, b = true, c = false, d = 42, e = [], ... } = {}) {
Huh, I see, that makes it much clearer - guess I just didn't understand it properly. (The "building" was probably caused by the sentence starting with "Google is working on", though I see now that referred to something else.)
&gt;So... literally every native function and most library functions? Yes, exactly. That's how functions in nearly every language work. Javascript can create and modify objects quite freely at runtime while other languages have a more rigid approach. So "the other languages do it this way" isn't an argument as to why you shouldn't do it in Javascript. Plus in Javascript functions themselves are first class objects, you can use a function as a parameter in another function if you want. &gt;Alternatively I'd argue that required arguments should always be written out You can do requred parameters individually if you want, or you can have two options objects - one for required params, and another for optional params. I don't really see the benefit of writing them out individually they're going to cause an error if they're not present either way. But y'know, its your code, do what you want.
Understandable. I feel like it's weird to have a function that takes 7 parameters, though. Anything more than three and I start to get itchy. The paradigm outside of javascript seems to be to define a class with multiple member variables and the big DoTheThing() function. Option objects are similar, but also sort of the inverse? Is there something about Javascript that lends itself to having large, unwieldy chunks of state that have to get shuffled around?
It's string concatenation which involves a getter/setter. The *get* part serializes the DOM to HTML (which does not include registered listeners). The *set* part deserializes the HTML and creates a new subtree. It's probably easier to picture if you desugar the += operator: element.innerHTML = element.innerHTML + moreHtml;
The generate button is not part of div#container so is not serialised when innerHTML is changed. Also because they're using an attribute in the html to attach the event it won't be lost when you make innerHTML changes. In your example you're using addEventListener to apply the event to the one div, when the innerHTML is changed your orignal one div is destroyed and a new one is created so the event loses it's target and never fires again. edit: you really shouldn't be using innerHTML, it's bad practice because of quirks like the above and it's really slow to boot. 
The button isn't inside #container nor have you attached a listener to it. Recreating everything inside #container doesn't affect anything.
&gt; isn't an argument as to why you shouldn't do it in Javascript. No, but keeping a style consistent to a native API is. Regardless, each method has its uses. I'd shoot someone of they used an `options` object instead of `(str, index)`, for example, and likewise if they used 30 individual arguments :)
Even if it is not the standard yet it probably will be in the future, so this idea of making requests to CDN may be a good idea for the future.
thanks, I will check it out
if you have more than one instance, they won't occlude well as container is shared in your closure and overwritten by your constructor: https://github.com/psolbach/ordnung/blob/master/ordnung.js#L5,L15
T.S.?
Hmm... still not quite clicking... but I do appreciate you taking the time to explain. It makes a *little more* sense. Thanks!!
Sounds like you dodged a bullet, that's a terrible way to recruit decent developers.
Heh. "Are we web scale" is like "but who was phone?" I think I know what you're asking, but I'm not sure. :) Generally that'd be "are we web scalable" which means, "can we handle the sometimes unpredictable traffic patterns that doing business on the internet implies." Of course there are people who just use it without knowing what it means, which places it in buzz word territory. Like someone asking if your jquery implementation web scales. "Well, it's single threaded on a single browser, so.... yes?" \-edit: Then again, maybe [I'm the one who doesn't know what he's talking about](https://www.npmjs.com/package/jquery). 
&gt; Also because they're using an attribute in the html to attach the event it won't be lost when you make innerHTML changes. That's interesting... &gt; In your example you're using addEventListener to apply the event to the one div, when the innerHTML is changed your orignal one div is destoryed and a new one is created so the event loses it's target and never fires again. They're both my examples! :) Interesting... I had no idea. I always thought that `innerHTML +=` simply tacked more html on to whatever was already there. I thought `innerHTML =` overwrote what was there with new stuff. &gt; edit: you really shouldn't be using innerHTML, it's bad practice because of quirks like the above and it's really slow to boot. People have said it's not optimal, but until today I'd never had a problem with it. I'm familiar with `createElement()` and `appendTextNode()` and `appendChild()`, I just always thought those were cumbersome compared to `innerHTML =`. Guess I have a new understanding of some of the issues... Thank you very much for discussing!! 
Ok, good luck trying to use http2 today in popular PaaS providers
 arguments[0] though I'd argue you shouldn't in general. You should pass on a subset: function foo(...){ bar({e, f, g});
Yea, that's why event delegation is great. You put the listener further up the tree and if you now add/remove stuff, the listener will continue to work fine. http://jsfiddle.net/qe5gg7mw/
I agree with you. Option objects are great, especially if you have written 100's of tests and don't want to break the public interface to add extra options. The whole point of using Javascript is it is a dynamic language! Use it for it's strengths. If you want types or inheritance then use another language!
Like I said in an above comment if you find the DOM API cumbersome take a look at [insertAdjacentHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML), it allows you to continue to use html strings, is more flexible than innerHTML and it's faster than the DOM API in most cases.
Or just play numbers game. Let me elaborate, few years back I was reading some guy who got high payed ror job sending shitload of emails to job offers. I rember he said he actually was not even that good, but it did't matter as the people who was looking for dev, was needed one. What he did he automated everything from scraping and sending his resumes, and he only look at the offers he got. Inspired by that, I landed high paying job as a waiter after creating similar bot in Ruby and sending ton of emails for hotels and restaurants in Germany(at the time I was sucking at programing but still was able to make a bot work). I didn't even care did I got rejected or anything, I remember sending around 300 -400 emails. And I'm pretty sure I'm only guy who made a bot to land a job in Hotel as a waiter. Bot was parsing couple of sources where potential job offers could be shown. It would parse the page looking for email and most of them was in similar format somethign@domainname.com. after getting email I saved it to database and visited site looking for adress/phone. Not only that I scraped around 3000 hotels who was promoting services and extracted their emails as a plan B. So at the push of a button I would send 3000 emails with my resume to potential employers. I qucily learnd this strategy is not very smart as I was getting quite a lot of replays, with a lot of interesting offers, so I kind of sending it in batch of 50 emails, and then waiting a little bit, and again. Hope you got what I was trying to say. Think outside of box :)
I am doing something like that in my project right now, but because it has many options things were getting lost when passed between the libraries. In my next update I will be passing every option each time I pass any option to ensure nothing ever gets missed because I failed to add an option to each library reference in each library.
Yea, passing option objects is kinda like passing event objects around. E.g.: showContextMenu(mouseEvent) How do you test this? Which properties do you actually need? How do you call this in response to a KeyboardEvent? Things can be so much simpler: showContextMenu(x, y)
Im so sad.. this stuff is on my resume. Every time I read it I think to myself.. this is like saying Im good at swimming, I also excel at back stroke, front stroke, and breast stroke.. /sigh I will say though, our current code base primarily utilizes JQuery and we have hired Devs that almost refuse to utilize it.. its frustrating to trouble shoot code thats primarily utilizing Jquery and then has sprinkles of base JS. 
Thanks so much! Moving forward, I will use insertAdjacentHTML instead of innerHTML. Thanks!!
jQuery.ajax uses an options argument, I don't get why you're linking it
"Are we web scale? Yes, almost as much as we're web pineapple"
Events bubble up. If there isn't an event listener which uses `return false` or `e.stopPropagation()`, the event will bubble up all the way to the root node. In the example above, the listener is attached to &lt;body&gt;. "target" is the element which was the original target of this event. So, if you click a particular button, the "target" property will refer to that particular node. "matches" is used to check if the element matches a particular selector. So, `if (target.matches('.inc'))` checks if the user clicked on an element with the "inc" class.
I did it, and loved it for about ten minutes. Then I got too annoyed. Still, thank you, and Happy National Cat Day!
Hi, author here. Really valid points. I think HTMLDocument is not trying to be the most performant option right now (that should get better over time, especially with things like [ReactDOMStream](https://github.com/aickin/react-dom-stream)) nor the most feature complete, it's just something tiny and convenient for building a subset of React-only projects. 
Because you'd shoot whoever wrote it. Look at how many options it has.
I said individual arguments, not options. As in if you re-wrote it to be: ajax(method, url, data, accepts, async, beforeSend, complete, ...)
&gt; I like that because, y'know, remembering the right order that arguments go in is a waste of the glycogen in my brain. http://i.imgur.com/jvZCayG.png You do not have to remember this. However, you do have to remember the property names and default values of your option objects because that stuff isn't part of your function's signature. Use destructuring if you want optional named parameters. Use regular parameters for mandatory stuff.
premature/preemptive optimization is probably the most well known anti-pattern in all languages. 
Crazy! I'm a bit lost on what's happening now... I don't quite understand the first comment about storing divs, but I'll keep looking at it! I have become aware of querySelector since writing that graph generator, but I've been warned it can be quite slow... Checking to make sure we're using the right datatype (ie, number) makes sense! Ah... I see what you're doing with .replace() there... Lol... I don't know nuthin' about regex... I'll have to get up to speed! This is kind of embarrassing, but foreach() is kind of hazy in my mind... I'm going to read some documentation on it right now! Thanks again for discussing!!
What is this syntax?
totally. the best developer I ever met didn't go to college and went back years later for a two-year degree.
yeah, I completely agree that in the case of mandatory parameters, listing them as arguments makes perfect sense (e.g. the `callback` parameter in my example). My argument is that something like this (absurd) example: function printName (name, color, fontSize, isItalic, addExclamationPoint, indent, andSoOn) {} is _definitely_ not the right solution. Limiting functions to a reasonable number of parameters is more important to me than being able to read everything from the signature. Note: I'm not suggesting that you disagree, just clarifying my position.
Again, totally reasonable. By "unwieldy" I didn't mean rigid. More "difficult to get a grasp on". Javascript objects are slippery, amorphous things that can change and mutate. They have almost no definition or structure whatsoever. That's what I'm really getting the culture shock from. It's hard for me to reason about those option objects. It's even harder for the tools that I use to do so.
Oh... okay... I think I getcha! Thanks again again again!!
Okay... cool! Thanks again again again!!
It sounds like you aren't leveraging enough agile resources to have a laser-focus on value-add synergies. Try using industry standard enterprise level technologies for win-win consumer-centric processes. 
ha, well, if you're worrying about object allocations causing performance issues, code readability likely went out the window a while ago ;)
You said that style consistency with the native API is an argument for why you shouldn't use options objects.... except for when you should use options objects because there are too many parameters... which was my main point. I'm really glad we had this talk.
Every javascript function like this: function f(x1, x2, x3){ ... return y;} Is equivalent to one like this: function(){ var x1 = arguments[0]; var x2 = arguments[1]; var x3 = arguments[2]; ... return y; } So there's no guarantee that there isn't a hidden interface within the arguments of a function. What about this one: function happyDance(x1, x2){ if(arguments.length === 100) return fireNukes(arguments[99]); else ... } That args list is basically documentation anyway. 
I may be crazy, but didn't you ask this on stack overflow too? I've seen this exact question before.
Yeah I've heard that Javascript can be hard to get used to for transitioning developers. Its different but its quite powerful when you get used to it. In any case [welcome to Javascript](http://i.imgur.com/FNJZnIl.jpg).
yay for circles!
I haven't a clue...
&gt; Google doesn't even use Angular. Google uses Angular for a lot of things. Parts of youtube, adwords (which is like their biggest product) and lots of other stuff.
Mr Robot
No they don't. Only a single extension of YouTube uses it, the YouTube app for PS3. Double-click uses it for some things. That's it. Nothing in Google's production sites use it. Doesn't lend a lot of credibility to the framework if their own sponsoring company doesn't even want to use it. It's a toy. A personal project for a few Google developers. Not a serious enterprise contender.
Nah, I didn't. I guess I'm not the only one with this problem.
Use a gulp workflow and have it compress the code at save and compile it via a node compiler, It should run okay then. Please note that compiling won't make your game more efficient, you have to make better code or compress it.
Yeah, I figured as such. I found a few tips online, like changing for (var i = 0 ; i &lt; array.length ; i++) . . . to var l = array.length; for (var i = 0 ; i &lt; l ; i++) . . . so I was hoping there might've been some other little things to slightly improve performance. A magic spell would've been nice. Ultimately I should probably just work on my algorithm design. I'm not familiar with profilers. Is that a tool for seeing how much time certain parts of your code are taking? Is there one you'd recommend? Thanks for your response!
Oh, really? I thought that compiled code generally ran faster than interpreted code, but apparently my understanding is incorrect. Is there no benefit to compiling my code then? 
My understanding was that asm.js was a way to compile *to* javascript, but I could be wrong. I'm not familiar with profiling. Any particular tool you'd recommend? Thanks for your answer!
&gt; Is [a profiler] a tool for seeing how much time certain parts of your code are taking? Yes! &gt; Is there one you'd recommend? All modern browsers are shipped with one. https://developers.google.com/web/tools/chrome-devtools/profile/rendering-tools/js-execution https://developer.mozilla.org/en-US/docs/Tools/Performance
Oh haha, shows what I know. Thanks! That sounds like an amazingly useful tool that I wish I had known about before I started. 
Inlining `array.length` is not an optimization that will make *any* impact on the "lag" of your game. ;) Most modern JITs are smart enough to handle that for you, and faster than you would do it manually. [See here](http://mrale.ph/blog/2014/12/24/array-length-caching.html).
&gt; My understanding was that asm.js was a way to compile *to* javascript, but I could be wrong. Yes, if you need more performance, you can theoretically write parts of your application in C/C++, but it won't be much fun.
100% agreed. I develop an online game ([TagPro](http://reddit.com/r/tagpro), in case anyone is interested) that used a custom canvas renderer. I switched the renderer over to pixi, and there were significant performance gains once we ironed the bugs out. We're currently developing a sequel to the game, and have stuck with Pixi. Unless you're dead set on learning manual canvas drawing, I would absolutely use a library like Pixi or Phaser. Considering it sounds like you have the game logic itself all sorted out, I would recommend Pixi over Phaser as Phaser is fairly heavy duty and uses Pixi for rendering anyways.
It's been really fun for most of it. It was just that the project got out of scale really quick relative the speed of communication. Causing people to stop talking to each other. Thank you for your comment.
How and where did you land a gig like this. In NYC you need good connects or years of exp from what I've been experiencing.
I more meant faster in terms of development time. Performance is probably pretty negligible, especially compared to the rest of the React application. I fully understand your reasoning, though. I built a component kind of like that when I started working on React, because the idea of having the same framework handle it from the top down was awesome. I still hope they can add static stuff like comments eventually.
You point out an upside, there are downsides too. For example, what are the actual arguments to a function that just takes an opaque options object? Nobody knows unless they read the code or unless the function is documented (lol) I am on the fence about this pattern. I think past a certain number of arguments it's better than positional arguments. Destructuring can also help with this.
regarding my code, that was intended to be an example of what tooling might be able to do as far as static analysis. As far as the options object goes, we agree on destructuring being an improvement. The reason I made this post in the first place is because I interpreted your comments as advocating the complete abolition of the pattern: `someFunction({a: 'list', of: 'options'})` To be fair, it was almost 4am when I made this post. I could have been clearer about my concerns, but you're use of absolute language like "option objects suck" can easily be misconstrued.
Just Mr Robot, not Mr Roboto
Also if you are rendering on the server this would make your generated html files absolutely massive.
Not completely on topic for this post, but if you have any build system whatsoever, babel should be pretty painless to add on, and it is definitely worth it.
Never seen it... I'll have to check it out!
Dublin, Ireland. I have solid experience in other related areas, and a decent GitHub showing. The company wants people who have a grasp across the entirety of website crap, instead of someone who just has one framework or speciality.
Hm... I just looked into it and yeah it doesn't look too bad. It works well with gulp, uglify, and sourcemaps?
&gt; I interpreted your comments as advocating the complete abolition of the pattern [...] For what it's worth, I actually do wish ES6 had done just that. I would have preferred dedicated syntax and simpler semantics for optional named parameters with default values. For example, in Dart, it looks like this: foo({a: 1, b: 2}) { ... } foo(a: 11); // a is 11, b is 2 foo(c: 33); // caught by the analyzer In the function's signature, the default values are compile-time constants, not arbitrarily complex expressions. You can display them as-is in tool-tips or docs. When you call the function, you can't just pass whatever you want. Only the existing names are allowed. So, if there is a typo, it will be caught immediately. Dart does everything I want or need from that language feature. The flexibility added by ES6's use of destructuring makes plenty of room for code-golfing, but none of that flexibility was actually needed. If you make the tiniest use of that flexibility, your code becomes super confusing. function foo({a = 'a', b = 'b', c} = {c: 'c'}) { console.log(a, b, c); } foo(); // a b c foo({a: 'A'}); // A b undefined foo({c: 'C'}); // a b C I really don't know what they were thinking.
It does run faster, but not in the way that you would expect. Compiled code doesn't have to be interpreted and can run natively, which is one of the down falls of languages like python. However, compiling code isn't a substitute for sloppy and uncompressed code. Focus on efficiency rather than compiling
you're right, I would never want to go through people's resumes, i would prefer to develop something.
I see this sort of project page a lot on Github (and they get linked here a lot, too): "It's like library X, but smaller/faster/cleaner!" Given the vast number of JS libraries and frameworks out there, you should at least mention what your library actually *does* somewhere early on in the README file. Also, your example doesn't do anything, at least not on my iPhone. 
yep, I am a newbie
Looks like this one won the upvote war: https://www.reddit.com/r/javascript/comments/3qqeae/babel_60_released/
Well written and acknowledges some positives of inline styling with JS. I'm currently wrestling with where I stand on this debate, leaning towards the author's position.
Here: http://codepen.io/ForScale/pen/pjKJWE
You can save: * 1 byte by writing `/.../g` * 10 bytes by removing `.join(“,”)`
You have any finance experience? 
I don't care how many hits you have or what can use says: IE is still dead on the W3C specs these days, and browsers going beyond those specs are doing exactly what IE did wrong on the past. It's not about what you can do. It's about what you should do. As a developer of you're ignoring IE, you're committing an amateur mistake. That's over a third of the internet.
Thanks, I haven't read that second post. I haven't used Babel yet, but when I read the features you listed in those posts they mostly sound like things that are already either built into most IDE's or available in most Grunt/Gulp workflows. So I guess a better version of my question is what will be the advantage of using Babel for all of those things instead of the individual tools I have in my Grunt workflow.
Would it be possible to write a drop in replacement for coffeescript just with plugins? I just flew over the sourcecode and it looks damn awesome how modular it seems to be (https://github.com/babel/babel/tree/v6.0.2)
Relax, you'll spend the next year spending a metric shit ton of hours ramping up and learning the ins and outs of Angular 1.x only to throw it all away and relearn everything for Angular 2.x.
Smallish company down in the city center. Direct hire, after nothing but bad experiences with recruiters.
no, you should learn Elm.
ES6 syntax for default parameter objects. 
Now you hope you don't hate programming after a year :-)
Right now I tend to follow a namespacing pattern similar to what the OP article talks about. I mostly drew inspiration from [Trello's LESS Guide](https://gist.github.com/bobbygrace/9e961e8982f42eb91b80) which was itself inspired by [Medium's LESS Guide](https://gist.github.com/fat/a47b882eb5f84293c4ed). My LESS "components" are mapped almost 1:1 to my ReactJS components but it affords me some flexibility as well.
That is the case everywhere. I've never gotten an interview through blindly applying.
Working with an entirely different syntax wouldn't really work. It needs a totally different parser and AST. Babel is general purpose but still specific to JavaScript. Besides then you'd have CoffeeScript :trollface:
Awesome, thanks. I don't think drawing to the canvas is the main thing that's holding me up, but it can't hurt. 
Thanks a lot, I'll look into it. I enjoy doing things manually and not using libraries, but if it's straight up faster than canvas I should probably switch to it. 
I'd also look at [Vue](http://vuejs.org/). Just went 1.0 the other day and it's been a beaut to work with so far.
Keep in mind this: &gt; Please ensure that if you're happy with this, you do spend more time investigating the framework (including reading the official docs, the source and its complete feature list). There's often a lot more to a framework than what we present in our examples.
Congrats! Really excited to see what else is rolled out in the Babel ecosystem
&gt; That's how functions in nearly every language work. [Oh really?](https://msdn.microsoft.com/en-us/library/dd264739.aspx)
Redux can track state changes more efficiently by checking whether or not the object references changed rather than doing deep equality checks or requiring you to emit changes yourself (which is not Redux-like at all, and is closer to the original Flux architecture). Immutability isn't important just because it fits this architecture, but that's for another discussion. It being JavaScript there will be some overhead, you're right, but there are a variety of solutions out there meant to make the process more efficient (e.g. ImmutableJS). I've yet to run into a performance problem with this pattern even with hundreds of objects, but if it's causing issues for you perhaps consider a different Flux approach.
Thank you /u/sazzer and /u/x-skeww for your suggestions to use a profiler. I used the one in firefox and I was able to figure out that one function in particular that I wrote a while ago had a hack in it that I had forgotten about that was making it very inneficient. It's already working noticably better. Thanks! 
Isn't this a bit of premature optimization though? Also, how do we know that the cost of constantly duplicating immutable objects is less than re-rendering the DOM (also wouldn't React's Virtual DOM heavily mitigate this cost?)
Thank you very much! Now I just need to analyze this and use in my project.
I don't see it as a premature optimization so much as an architectural decision. Using Immutable data structures has been a mainstay of React development since it allows you to quite easily determine whether React even needs to attempt to re-render sub-components and, from an even higher perspective, be sure that objects distributed across your application aren't silently mutated. As far as constantly duplicating immutable objects, that's not really the case (depending on how you approach it). For example, ImmutableJS is smart enough to re-use subtrees that haven't changed, so you're not at all cloning the entire object. So really, in most use cases, there isn't much of a cost to using immutable data structures, whereas the benefits are plenty (and by not using them, you're likely opening yourself to other performance/maintainability concerns). **Edit**: I think it's important to note that Redux chooses this paradigm not because it's more efficient (whether or not it is), but because it's a more functional/Elm-like approach that is designed to make it easier to represent and understand the state of your application and how it changes over time. So if you look at it more as a design decision and less as a decision centered around optimization it may be a bit clearer.
&gt; It has some entirely different syntax from javascript No it does not. It's a syntax extension. It even defines AST nodes that fit in well with a spidermonkey-like AST. https://facebook.github.io/jsx/ &gt; Coffeescript at least has the same language constructs as javascript. Not at all. CoffeeScript's syntax is completely different from JavaScript. For one, it has significant whitespace. It also is very poorly designed for creating a sane AST (and has a lot of syntactic ambiguity). The JSX implementation is here btw: https://github.com/babel/babel/tree/development/packages/babylon/src/plugins/jsx
Will update soon
The docs were thrown together last minute late last night. I'll be spending the next week getting it cleaned up again.
Banks are struggling to get devs in SF. No one finds it sexy. 
Idea is simple, after each action that caused change to the data in store, you return a *new* object. Then it can be checked via === and this is super fast (if you would mutate state object, you need to do a recursive pass through whole object to find out if object changed). This way you can just push items in the array, it will not change a reference of this object and === check will return true. React does not care about if you change object a little or it is a completely new one. It will create a diff between old and new data and will mutate DOM as much efficiently as it can. And redux is not actually requiring you to use a immutable structures, it just require you not to mutate an old data, but return always a new object. 
What you need to do is something like this: count = 0 for `string` in array: aIndex = -1; bIndex = -1; cIndex = -1 for `character` in `string`: if `aIndex` == -1 and `character` == 'a': aIndex = index of `character` in `string`. if `aIndex` != -1 and `bIndex` == -1 and `character` == b: bIndex = index of `character` in `string`. if `aIndex` != -1 and `bIndex` != -1 and cIndex == -1 `character` == c: cIndex = index of `character` in `string`. if `aIndex` != -1 and `bIndex` != -1 and `cIndex` != -1: count += 1 alert(count) This should work - although it's just off the top of my head. There's probably a much more efficient way to do this too, but hopefully you get the idea.
Here's an example for you: http://jsfiddle.net/OriginalEXE/z8vz8ve6/ That should do what you need.
It's worth keeping in mind that a lot of the advantages that Redux touts, and a lot of the disadvantages associated with Global state, come from the perspective of debugging. Global state is so maligned because it is notoriously difficult to debug. If any part of your application can modify it at any time, it becomes difficult to figure out which part is making the change that breaks the system. Redux doesn't suffer from this, because you can easily track the state, and the actions that are applied to it, in order. Which means you can know exactly which Action (the only thing that modifies state in a properly architected Redux/Flux app) is the culprit.
Don't use "transpilers". Chasing the "new and shiny" is not always the best way to get work done.
Read the angular source code. There's lots of useful comments there.
Producing the coffeescript AST is relatively straightforward, the hard work is in turning it into js that browsers can execute. Babel would give a significant leg up here because it can cover almost all of coffeescript's features. It's also the direction which sweet.js is going - the next version of sweet is built on babel because it gives them a lot of stuff for free. I'm surprised you're arguing against it tbh.
regex is your friend
&gt; ...Babel it will no longer transpile your ES2015 code by default. I know its all for the sake of Babel as a platform (which will only get better), but this is a **huge** change. Its a little less convenient for now, but I'll be optimistic about this decision. Does anyone one know if the es2015 transpiling is just one babel plugin or is a set of plug-ins?
I'm working on a driving game side project, here's my TypeScript options object: interface ICarConfig { gravity?: number driveTrain? : number halfWidth? : number halfLength_f? : number halfLength_r? : number cgToAxle_f? : number cgToAxle_r? : number cgHeight? : number wheelRadius? : number chassisFloor? : number mass? : number throttleForce? : number brakeForce? : number ebrakeForce? : number drag? : number rollResistance? : number slideResistance? : number minRpm? : number maxRpm? : number numGears? : number cornerStiffness_r? : number cornerStiffness_f? : number tireGrip? : number lockGrip? : number heatRate? : number coolRate? : number weightTransferScale? : number driverHeight? : number maxSteer? : number cabSize?: IVec3 cabPos?: IVec3 } 
This is great. Now let's see if we can make a TypeScript plugin happen :)
20% is the standard for the industry. I sometimes do 15% for a company that has a lot of need or uses contractors as well and I will get to work on those reqs as well. If you find a company that will work for 10%, you will undoubtedly get what you paid for.
Has the Bluebird-coroutines transformer/plugin been removed? I can't seem to find it in the docs anywhere. EDIT: I found [This](https://github.com/babel/babel/issues/2512#issuecomment-147579718) thread, but there is still no documentation of that feature, if it exists.
&gt; function inject(...deps, static = false) If called with 'foo' &amp; 'bar', will "static" be `false` or equal 'bar'? So, default values apparently won't work. In C, Java, C#, and so forth "varargs"/"params" always come last. I'm not sure if there is any language which handles it differently.
New recruiters dont know the relationship between js and jquery. They also dont know java vs javascript a lot of the time. They learn. But due to the high turnover nature of the industry, most of the recruiters you talk to have been doing this less than a year. A good portion of them wont really get it even after a year. You can find good recruiters. It does happen.
ES3/5-style option objects try to emulate optional named arguments. Use destructuring instead.
Even when you're just one person on a project, it's easy to lose track of the head-space architecture. I've lost track of the number of times I have put down a side project, picked it up 3-6 months later, looked at the code and thought, "Which asshole wrote this?"
No problem. You'll find these methods super useful once you get comfortable with them. .map, .filter, .reduce, .some, every and so on. They're all functions you can call on Array ----- &gt; Is it possible to not convert the query string into the {key, value} format, and then use a modified version of the regexp from the previous code? Yes, but will become difficult to maintain. Every time I start getting some awesome regular expression going, I smack myself because I already know how much I'm going to hate myself the next time I have to open the file and figure out what the hell I was doing. -------- &gt; So basically, the .map property applies a particular function to each element of a specified array? Exactly. .map says "_take this array, pass every item through some function, and give me an array of what that returned_" I'll give you a straight-forward example: var numArray = [ 1, 2, 3, 4, 5 ]; Now, let's get ^those items... but times 10 // complex math problem function timesTen ( num ) { return num * 10; } var bigger = numArray.map( timesTen ); // -&gt; [ 10, 20, 30, 40, 50 ] And it left the original items untouched numArray; // -&gt; [ 1, 2, 3, 4, 5 ] ------ &gt; after keyboard.map(decodeURIComponent), the output is a 2D array? Now that you have an example, we can step through what that _param_ function was doing. We started with just a query string var paramstr = 'name=John%20Doe'; And we separated them by the '=' var encodedKeyValueArray = paramstr.split( '=' ); // -&gt; [ 'name', 'John%20Doe' ] Then, we said to uri-decode every item var keyValueArray = encodedKeyValueArray.map( decodeURIComponent ); // -&gt; [ 'name', 'John Doe' ] Last, we take the array and make it an object return { key: keyValueArray[ 0 ], // 'name' value: keyValueArray[ 1 ], // 'John Doe' }; I'll post another comment with a working version of what you're trying to do
You could do something like this if you wanted: function MyImportantFunc(options) { var _type = 'myImportantFuncOptions'; if (!options || typeof options !== 'object' || typeof options.type !== 'string' || options.type !== _type) { return { param1: 1, param2: 2, param3: '', type:_type }; } // Do your code. return "Correct options object passed."; } var options = MyImportantFunc(); MyImportantFunc(options);
Yes, really. Do you understand what the word "nearly" means? Or optional syntax?
I asked because I only had time to skim. I'll have to read it later. Thanks
It pretty much just works. I use the babel setup where it ties into the parser so that all subsequent files are run through babel automatically. At that point all of my files use the import/export syntax instead of require/modules.exports and it all just works. &gt; npm install --save babel require("babel/register"); require("./src/server.js"); // &lt;-- src/server.js will be interpretted as es6, along with all files it imports. 
I find source maps to be most helpful for splitting my js blob back out to multiple virtual files, but the internals of those files are usually still just ES5. Is your ES6 so different from the output ES5 that you can't just debug in that? Also worth asking: What are you debugging in? Is this a web-site and you're using one of the browsers, or is this a node program and you're debugging with either the node debugger or an IDE? If variables aren't showing up as having values and other behavior like that then there's a toolchain issue. Like I said I prefer to just debug the output, es6 is so close to es5 that it never matters anyway.
I think the upgrade to npm 3 is a pretty noteworthy change. I've noticed fewer duplicate dependencies are installed, and it seems to produce less errors in my webpack builds.
ImmutableJS uses structural sharing so the amount of copying that goes on is relatively small. It adds some overhead compared to mutable objects, but much less than the full object copies in your example.
Hmm, if I'm working with a large configuration object (see my comment below) I don't think I'd want to destructure it. The example is TS, so it has types that can be required or not and caught by the compiler, but I think I'd do it the same way in JS.
Sorry, you did make that distinction.
Except that the "new and shiny" in this case is the actual fucking standard, which you'll be writing natively in a year or two anyway.
Just in case anyone hasn't come across this, nvm is handy for upgrading node quickly: https://github.com/creationix/nvm
&gt; The example is TS, so it has types that can be required or not and caught by the compiler Yes, TS provides the duct tape to make it work. &gt; but I think I'd do it the same way in JS. Why would you? Destructuring already works better and the tooling wasn't even adjusted yet. In the future, you'll be able to auto-complete the property names.
So something like this: (Math.round((event.pageX-scene.rect.left) / (scene.rect.right-scene.rect.left)*canvas.width) - scene.xOffset) (scene.xOffset is for panning.) That code is for getting the normal, unscaled mouse position. As for step 2, I am confused about what you mean, or how to get that. Could you explain? I am still quite new to coding.
Is there a way to keep the parameters contained in an object rather than, well, destructured?
Is this sort of major release cycle going to be common, or are they just sprinting to catch up with what Joyent held back? 
Cute solution, but there's no guarantee that the numbers are in any given order. Your overly simplified solution works if you assume that the numbers in the array are ordered (because you are abusing sort and concat to create a kind of double up method). So, it would require knowing more about the expected results. I actually like problems like this where they give you an example of [1,2,3,4] and then have hidden test cases that might use something like [4,2,5,10]...
Also, consider that adding sorting will be expensive... http://jsperf.com/double-up-solutions
You are right that a dev would view the resume different than someone for whom the words mean nothing. I have trained a ton of recruiters on skills and there is a portion of them that just wont ever get it. Oddly, that does not keep them from being successful as recruiters in some cases. I have seen some of the dullest people fill a ton of jobs. On the flipside, I would say that I typically dont pay that much attention to jquery (in particular) being called out on a resume or a jd. I havent run into it being a big deal breaker. If I see a solid javascript dev resume, I am going to call them, and if the mgr told me that jquery is important, I will ask during the conversation. There is a good amount of devs that will blast you for calling them with something like, "is it on my resume," or "I wrote down what I do," or something similar if you ask something that isnt explicitly stated on the resume, even in cases where it is something like jquery and javascript or asking if they have worked on cyclone family of altera fpgas and what generation. And, for what it is worth, I get it . They are frustrated by the endless barrage of calls and stupid fucking questions. I would wind up with short patience for it all too if I was on your end of the phone. That is one of the biggest frustrations in my industry. I have to find some way to stand out of the crowd of people who are rude, dishonest, inept (due to stupidity, apathy, or just being green), and a slew of other legitimate complaints that people have about recruiters. I wrote in another comment about the tips I give out for devs to pick recruiters. Put a google voice phone number or a burner on your resume. I know a lot of contractors who have a burner that they turn on when they are looking. If you have a few conversations with a recruiter you like, give them your real number. You should be able to have the benefit of putting your cv out there without being terrorized. The process should be symbiotic rather than parasitic. 
Coffeescript supports as many splats in the arguments as you like, but in the example above, `static` will equal `"bar"`. So, it only works well when you don't have defaults. But it's sometimes quite handy for writing left-recursive variadic functions.
Where can I find a list of ES2015 features that can't be shimmed? Or more specifically, stuff that Babel doesn't shim to-the-spec.
I've added a couple other ways to do the same thing. You get much better performance if you don't use array push at all. http://jsperf.com/double-up-solutions/2 
With gulp and browserify with babelify it seems to keep the source map to the es6 code in my case. That might be a lot of setup depending upon what you already have set up
another one: function doubleUp(a) { return a.reduce(function(p, v) { p.push(v); p.push(v); return p; },[]); } // if es6 function x(a) { var b = []; a.forEach(v =&gt; {b.push(v);b.push(v);}); return b; } edit : i forgot you can push(v,v)
Is this good enough for production as well, or just development?
Correct. Both are on the same server. In a few rare cases we need to call a service on render, but we find superagent to be great for that.
Definitely interesting...
Isn't Immutable massive though? I added it to my project and it was bigger than my animation, Ajax and event frameworks combined (IIRC)
1. I'm not the right person to ask about that, I highly doubt it but I hardly have a horse in that race. 2. You could very likely use pieces of Babel for this purpose.
&gt; styles are just another form of state only if you change them dynamically. Most styles are constant-at least in my apps.
Interesting. What's the rationale for having the cache functionality inside my application instead of the web server?
Got it. Sorry, it's my first post.
awesome! (942 bytes / http://jsfiddle.net/9wxzx9xe/33/) I tried saving some characters by forcing a few variables to 38, but the assignment takes up enough to make it just the same length
Due to the new, modular structure of babel 6, with tiny plugins all requiring `babel-runtime`, one ends up after `npm install babel-preset-es2015` with more than 20 copies each of: babylon, esutils, core-js, babel-runtime, lodash, js-tokens and ansi-regex (check with `pkgcount`). Installation takes 1min 25 sec, `node_modules` occupies 74 MB of disk space. But thank God node 5 was also released today. The included npm 3 auto-flattens module trees. Now, installing `babel-preset-es2015` completes in 21 seconds and the resulting `node_modules` takes up only 11 MB!
thanks.
ES6 is quite modern and good enough. Say to no TypeScript and CoffeeScript 
Had to google intellisense... Microsoft code completion tool? What's wrong with TernJS?
You're welcome.
who said I'm ignoring it? I HAVE to take IE in account ofc, you were saying that IE is actually a good place to develop and I would honestly say 'no'. I still have to double my work for IE and even if it's coming out the 'dark side' of development it's still there as it's one of the least feature-implementing browsers out now
Looking at code style guidelines for [neovim](https://github.com/neovim/neovim/wiki/C-Refactorings-and-Code-Smells-Catalog) under "Complex Refactoring", they address this by advocating structs that encapsulate several parameters. In this sense, they closely align with /u/ZyklusDieWelt and his illustration.
My team did a lot of investigation on how to deal with this issue and we ended up ruling out inline styles for several reasons. We are currently using a home grown tool to implement suit-css namespacing: https://github.com/brentertz/react-suitcssify
I'm not sure about 5 years. Look at https://kangax.github.io/compat-table/es6/ to see where the different browsers are with compatibility right now. FF43 apparently has *more* of ES6 covered than Babel does, and Chrome48 isn't far behind Babel. Babel does massively win when looking at ES7 though, but that's not even a released standard yet.
1. If you're using ImmutableJS or a similar immutable data structure lib, then you won't be doing any object duplication and the code is easier to read and write too. 2. Implementing 'shouldComponentUpdate' is not a premature optimization. It has a very large impact on performance, and you should implement it whenever possible.
A function with 7 arguments is a huge code smell, that code should've never been written. I agree with the general sentiment that doing the options hash thing is a lazy hack, although a very useful one.
[N](https://github.com/tj/n) is another option.
https://www.codeschool.com/ has a good angular course in a fun learning style. Would recommend.
Just waiting on the browsers!
It seems like web torrent is more complete than this 
Thanks! That was a good read.
Is there a word for posts like this? If not, how about "vagueware"?
I remember seeing a presentation by someone dressed as Bono about how the CoffeeScript compiler/translator worked and it was horrific. It didn't feel like getting anywhere near CoffeeScript after that. 
I prefer using something like [flow](http://flowtype.org/) to typescript
You might want to check out any local meetup groups for JS. They aren't necessarily conferences but depending on where you are there could be 100+ people attending. I'm sure you could at least find out about some new conferences by networking with people there. 
Or: this.validatedFields.email = this.validateText(this.$email) &amp;&amp; this.validateEmail(this.$email);
&gt; If I add a parameter, I will also have to update **every place it is used**. You wouldn't. Just add it at the end and check that it's not undefined în the function. Calling a function with fewer pareters than its singature is not a problem in js. jQuery makes extensive use of this. 
You realize all you're arguing about is positional vs named parameters/arguments. This is completely subjective though. It can be thought of as just as easy to forget one of the 7 property names you now have to now remember when passing your arguments into the function, rather than just the ordering. I would argue that both solutions have merit and even that they may both be employed better under certain circumstances. If you're arguments have sort of a natural ordering to them that one would expect to pass them in, then positional arguments might be the best choice. On the other hand if they have no obvious order but have obvious, easy to remember names, then using named parameters (ala. an "options" object) might be better.
Copy of my comment to the OP in [another post](https://www.reddit.com/r/reactjs/comments/3qj1r3/why_you_shouldnt_style_react_components_with/cwg38qf?context=3) &gt; You can't re-use existing CSS code or tooling What prevents you from using classes and styles at the same time in the transition period? &gt; You can't integrate Inline Style with plain CSS because it will always override other styles But you don't have to override the styles. If my css says "background: red" and my inline says "color: blue", both should work. &gt; You'll need to re-implement media queries and pseudo selectors (or use a library which does) True.. but using a library is pretty easy, compared to setting up sass into your build .. &gt; You need global styles for things like fonts, so not everything can be accomplished with inline style anyway Inline styles doesn't mean use 100% inline anyways.. CSS is good for globals, it should still be there and used. My scaffold/grid is in the global CSS, but every components are going inline, for example. &gt; You'll make growing a team hard because people who can competently do both Style and JavaScript are rare Everyone that knows CSS can code inline style react code. There's some small differences like camelCase instead of dashes, but it's something that can be taught in no more than 15 minutes. Plus, if you have a good react environment, you should have react hot loader.. so no more reloading. Not sure if you ever worked with designers that have to test on 7 different devices at once? Once you show them that CTRL+S hot-loads them automatically on all devices (and keep application state), trust me.. they won't complain about camelCase; they'll embrace it. &gt; Have fun caching your inline styles separately. You don't need to cache your inline styles cause they're part of the JS logic.. which should already be loaded and cached. Bonus: less blocking resources to load. Bonus 2: you don't use classes (which are not minimizable) so file size should be smaller. &gt; Inline Style lets you use JavaScript, so you won’t have to learn CSS Not sure where you read that. That's bollocks &gt; you wouldn’t have to worry about this anyway if you just namespaced your classes properly. We'll come back to this point later. &gt; Designers speak CSS Inline styles are still "CSS", just packaged differently with some different syntax. Designers are not that dumb. My opinion: I think you're missing the mark on using inline styles. It's okay though because most people go through that phase before jumping. It's pretty hard to defend the use of inline style until you realize that you need it (hint: only in large project with a lot of devs). - When naming elements becomes a clusterfuck: `.overlay-market-btn-trash-active-alt2`. Jesus. Gotta make sure it doesn't exist first! - When you need to minimize your classes because a bunch of `.overlay-market-btn-trash-active-alt2` takes more space than the actual content itself. - When you realize that a lot of CSS gets unused with time and you want to get rid of it, but you're scared to delete it because there's no real way of knowing if it cascades to something else. - When you're starting a project in React Native and you realize, shit, I can't use CSS. - When you encounter specificity conflicts because of the junior dev. - When you first started to minimize the whole app CSS in 1 file, then it grew over time, so you're separating into 1 common chunk + page specific,.. but you're at the point where the page is too big, so you're loading CSS asynchronously per group of components... but then you go into a very hard to reproduce bug where one stylesheet loaded before the other one, so some stuff are borked. (Good luck with this one. FB had the same problem) - When you go into the A/B (CDEFG) testing world. lel. - When your CSS is so big even libsass takes a few seconds. - When you have to question "hmm, where should I put this CSS rule". - When you're at a point where you're just scared of adding CSS because of the repercussion it can create, and how hard it is to test for visual regression. After using it once.. you realize that it's so much better.. and when it's time to start a new project, you ask yourself "hmm, should I just use inline styles? It's simpler since I don't even need to setup extra build tools.. hmm".. then you realize just using inline styles with React is the natural way to go. So.. yeah. If you don't see the value of inline styles, chances are most of your projects are small and simple.. in which case, continue to use your CSS. You lucky bastard. For everyone else: it's the best shit that ever happened to the web world after webpack, react and redux. 
Enterprisey coding style
Flow isn't crossplatform. That's completely unacceptable.
... I'm still on v0.10.36
I wish I could find something like nvm/rvm/etc. that actually worked on Windows/git-bash.
&gt; To run into them, you need a function that creates and returns another function. A minor nitpick. Closure is available when functions are nested (now blocks in ES6), regardless of creation, return, or passed around. Awesome research.
Thank you. I figured I would get a couple of things wrong. I may correct this later. 
What's holding you back?
really hope you'll do it! Please let me know when you finish it :)
Read 2001-ish version and still recommend the more modern editions to anyone expressing interest in mastering the language. It's almost too general sometimes, but that is outweighed by how comprehensive it is. Afterwards read "Javascript: the good parts" and some domain - specific stuff and you're on your way to actually knowing what you're doing. 
wooot GO JAMES GO
All other arguments aside, ES6/Babel are under active development, while CoffeeScript doesn't appear to be.
&gt; Not sure why you think it's unacceptable though. Would you install Windows in order to contribute to some open source project? You'd think that's perfectly reasonable? Why would anyone pick something which isn't crossplatform if virtually all other options are? &gt; Who's job is it to guarantee cross platform? Windows is the outlier in the tech world, and as an outlier you'll need to be rolling your own support. Man, that's backwards. No, it works like this: If you want to sell me your product, you have to make it look good in comparison to the other alternatives. Right now, Flow looks pretty uninteresting. It doesn't support Windows and it also doesn't seem to help much with tooling. It only does type checking. I don't see a reason why anyone would pick it over TypeScript, which is crossplatform and which does improve the tooling quite a bit.
I found Pluralsight.com tutorials to be super helpful when learning a new framework, such as Angular. I still watch them for various subjects because new ones are constantly coming out
These are fantastic, I'll add it in. I was worried that putting both functions on the same line would run both of them, rather than only running the second if the first returned true, but it looks like it operates perfectly. Thanks! Edit: I'm curious what the difference is between having and not having the wrapping parenthesis, other than the lack of the two characters.
&gt;It's still a global state tree mutated via actions emitted but extremely simple and efficient. Sounds like you're on to something. Maybe create a new flux implementation... Relux: for those reluctant to embrace functional programming. All the benefits of redux minus hot reloading, time travel, easy debugging and those other frivolous things.
It's called short circuiting. :] Edit: Not much difference. Preference really.
Thanks! I originally had my code in 2 separate files. I forgot to remove that when I copied that in.
A company I contract with has a lot of legacy systems; they also had a lot of concerns for implementing anything more than the Node.js application which I was hired for. So due to the restrictions, and the reliance upon an extremely slow API, I had to implement something in-application, thus the motivation/rationale for my use case. As for why I made an open source version (Middleman). I think Middleman could be extremely useful for anyone who is deploying to a restrictive environment and/or needs to put together a super portable application quickly. With that said, Middleman's cache abstraction was built from the beginning to work with a very simple, asynchronous "store" interface. So caching can easily be done out of application (with and without LRU). In fact I built a [Redis based store](https://github.com/Nindaff/middleman-redis-store) for those concerned with a memory cache. Thanks for taking an interest!
definitely gulp and sourcemaps, not sure about uglify but I'm sure that's been done before
&gt; While closures never changed, their relevance did. Early versions of javascript did not have closures. They showed up in Netscape Communicator, released in June 1997. Which means there's a good chance the 1997 version of the Flanagan book was written before closures were officially available. Sauce: https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/1.2 &gt; You can now nest functions within functions. 
Or brew
Wow!! This is a major revelation! Thank you. I'll have to update the article. Flanagan's 2nd edition indeed predates the June 1997 update, having come out in January. Now I want to dig up a 20th-century machine just to make sure when closures indeed came in.
Do you think the es6 non-concatenated version will become standard? In PHP, we've been able to do the same thing with double-quotes, but it's still considered best practice to concatenate for code clarity.
That's cute, but it would bug me after a while...
file a bug.
Maybe it's time to submit a TC39 strawman that allows rest params at any place in the args, as long as there are no defaults that follow.
Maybe in the future there will be techniques that do the same thing "css-modules" or "jss" do, so you don't need manual discipline for maintaining BEM conventions , basically preventing 2 independently written components to accidentely clash in namespace. 
It's a fools game to use Coffee Script in time where ES6 is spec and ES7 is in development. Most of the advantages that made CS worth while are now ingrained in the official spec.
[all i could think of](http://i.imgur.com/rIznLtw.jpg)
Unlike PHP, without the \`\` quote marks JS doesn't have any support for multi-line strings. JavaScript also has no requirement that variables start with $ (though it's a convention for certain types of values), so the non-concatenated version won't be nearly as confusing in JS as in PHP. Personally, I find them to be more clear to read and understand than concatenated strings.
Hold up, the tick marks will support multi-line strings? That's fantastic! That alone could replace JSX.
Probably wanted to put this somewhere like /r/webdev and not /r/javascript.
To build a simple website (or web application) you only need HTML and CSS. If you want a more dynamic website, you can run server side code (PHP, .NET, Java, Node.js, etc...) that can include snippets of HTML within your HTML, or fetch content from a database and display that. If you want a dynamic client-side, then you can include JavaScript on the client side, and this can either include snippets of HTML, or content that is already present within the page, OR it can do an XMLHTTPRequest (XHR) to fetch data from a http resource (html page, web service, etc). I'd highly suggest not using jQuery*, and instead getting into AngularJS if you want to rapidly build out a web application. *I say not to use jQuery as Angular includes a minimal version of jQuery already (jQLite), and this contains 95% of the stuff most websites use in jQuery already. 
How will the client connect to the back end? REST API?
I build the Js, with basic html, and fill in the html later. Sometimes I need to grok the functionality with things like composed views before I can start real html and styling work. If you are doing single page app like stuff, its probably easier to build the html first.
A slew of RESTful APIs
30-ish optional parameters are too much. Consider splitting it up into wheels, chassis, engine, and whatever and make *car* own these things (object composition). Also, I'm really confused why a car would own "gravity". Check this book. It should help a bit. http://gameprogrammingpatterns.com/
I have the same problem. The solution: In the directory where you use `babel` should be installed `transform-es2015-modules-commonjs` (npm install babel-transform-es2015-modules-commonjs) and then execute again and it should work! the directory should look like: - script_to_transpiler.js - .babelrc - node_modules/babel-plugin-transform-es2015-modules-commonjs/...
/r/bugs
ES6 for sure. Coffeescript always seemed cool to me but also way too much of an abstraction on the language I'm actually writing for. I was over it pretty quickly. Meanwhile using ES6 just means you're staying up to date. And the neat thing about Babel is it will always be ahead of the curve, of course with the risk that you're going to use some concepts that wind up changing or being taken out before ratification. 
Yeah I have been recently trying to use more pure DOM methods over jQuery but jQuery does most things much faster than native DOM methods. Everyone talks about the intuitiveness as being the major issue but really it's the terrible performance. If you do $("#someid").find(".some-class") and compare it to document.getElementById("someid").querySelectorAll(".some-class") over 1000 iterations of that call, jQuery takes a total of 15ms compared to the native method's 220ms. You're stuck searching the whole DOM every goddamn time which is insane. At that point you may as well just do document.querySelectorAll("#someid .some-class") which is only slightly slower.
I don't think there's any demand to charge for it. In all honesty I am pretty self conscious about it.
Ahhh, the days when it was still trendy to hold down the shift key while writing HTML tags… &gt; `&lt;SCRIPT LANGUAGE="JavaScript1.2"&gt;`
The project I'm working on is using bottle (python) for back end api layer and angular for the front end. Seems to work just fine for us. I've worked with tornado before and it should work great as well.
To aid mobile users, I'll link small subreddits not yet linked in the comments /r/frontend: /r/frontend is a subreddit for front end web developers who want to move the web forward or want to learn how. If you're looking to find or share the latest and greatest tips, links, thoughts, and discussions on the world of front web development, this is the place to do it. --- ^I ^am ^a ^bot ^| [^Mail ^BotOwner](http://reddit.com/message/compose/?to=DarkMio&amp;subject=SmallSubBot%20Report) ^| ^To ^aid ^mobile ^users, ^I'll ^link ^small ^subreddits ^not ^yet ^linked ^in ^the ^comments ^| ^[Code](https://github.com/DarkMio/Massdrop-Reddit-Bot) ^| [^Ban](https://www.reddit.com/message/compose/?to=SmallSubBot&amp;subject=SmallSubBot%20Report&amp;message=ban%20/r/Subreddit) ^- [^Help](https://www.reddit.com/r/MassdropBot/wiki/index#wiki_banning_a_bot)