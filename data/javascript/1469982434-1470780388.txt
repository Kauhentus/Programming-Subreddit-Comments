&gt; I have no issue with TS for those that don't know JS or don't know JS well ... but you have to know JS to know TS. Typescript is a superset of javascript.
&gt; "Dynamic type checking" means nothing more than the absence of static type checking. Well not really, there are many things in our language that utilize dynamic typing: coercion, defaulting and truthy/falsey to name a few. When understood and used as designed features like that are very powerful. It is not that it is forbidden either, it is just not needed. 
&gt; It is not that it is forbidden either, it is just not needed. Not sure what you mean. Specifying the type of a parameter (for instance) is not allowed in vanilla javascript. It is allowed (but not required) in Typescript. And the features you mentioned (coercion, defaulting and truthy/falsey) still exist in Typescript.
I'm not sure about Chevrotain being "better", with regard to ease of development. I ran into PEG while designing a DSL for the first time, and [its configuration](https://github.com/sap/chevrotain/blob/gh-pages/performance/jsonParsers/pegjs/json.pegjs) seems much easier than [with Chevrotain](https://github.com/sap/chevrotain/blob/gh-pages/performance/jsonParsers/chevrotain/chevrotainParser.js).
&gt; a lot of "if (obj instanceof UserRecord)" Typescript does not check types in runtime, so you have to do this manually regardless. You write in TS to help your IDE with pointing out potential issues. It also gives you an illusion of something you might be used to, like .NET/Java. Does it help with development? Perhaps, somewhat. Is it really JS with ~~static~~ strong typing/type safety? No. Because there's no type checking in runtime. Which, to some, myself included, defeats the whole purpose.
Edit: my bad, poor wording. My point is that you will not get any type mismatch errors when a user inputs some weird shit you're not expecting. No warnings, nothing, you still have to handle this manually. Which you kinda do anyway, with or without TS. Without TS you have much less overhead though.
Not to be a downer but I give less credit to Microsoft and most of the credit to [Anders Hejlsberg](https://en.wikipedia.org/wiki/Anders_Hejlsberg). He has always been on the forefront of making things better and easier for developers. Always focused on how to make developers more productive at getting things done. When he chose to leave his C# duties and begin the work on TypeScript he, I am certain, would have left Microsoft if they would have blocked his desire. He always goes where he feels he can do the greatest good and JS, while making improvements with ES6, still needed help. The only credit I give Microsoft is that they let him do whatever he wants over there.
Yeah, good point. Just forbidden seems like the wrong word there. To me it is equivalent to saying: Lexical scoping is forbidden in Ruby. It is not that it is forbidden, it is just not how it works.
Shout out to [Canopy](https://github.com/jcoglan/canopy), a PEG parser generator written in JS that can generate parsers in JS, Java, Python, and Ruby. IIRC I preferred the syntax and features of Canopy over peg.js when I was doing parsing in JS, but that was a few years ago.
Really dig it, good article. Associativity and both right and left identity holds with this implementation (even thought there is no applicative, if one one added it would hold up). Think it would provide better clarity if the algebras were wrapped in a data type, so you can really show off referential transparency.
I'll explain the thought process behind the debugging to give you an idea of how to solve this yourself: 1) I would make a minimal example of the problem to narrow down possible points of error. So I copied your ajax() function call, and stripped away the logic until I was only left with: ajax( "/getAvatar", { method: 'GET' }, function(err, data) { console.log(err, data); }, function(xhr){} ); This ran fine in the Chrome dev console, therefore the problem must be somewhere else. 2) I would check the surrounding code to make sure that's not problematic. The surrounding code is the document ready. Minimal attempt at that: u(document).on("ready", function() { console.log("Ready"); }); Doesn't run. Therefore, the problem isn't with ajax at all. 3) Find out how to actually get document ready with umbrellajs https://www.google.com/#q=umbrellajs+DOM+ready No good responses there 4) Try a more specific search https://www.google.com/#q=%22umbrella%22+dom+ready Leads me here: https://github.com/umbrellajs/umbrella/issues/17 A comment by the author: &gt; [no] There are so many libraries for ready() that I think it's best if it stays out. Also it's not needed if you put your scripts at the end of the page **Conclusion**: This is not supported by the library, and he's right - just put your script at the end of the body tag and forget about anything like jQuery's $(document).ready. It's not needed.
Looks like jQuery had made me lazy, indeed. I didn't even think of `ready` not being a standard event... Thank you!
Or Jenkins.
&gt; Webstorm even supports it. But it hasn't gained much traction. I use it heavily and I really like what it gives me (through this IDE only). For anyone *not* using TypeScript, this is one of the benefits of an IDE. I did look at TypeScript though, but I'm really, *really* reluctant to ever use anything "non-standard". No special add-ons in my browsers except for basic ones, no special add-ons for my OS - and I try to avoid anything "special" when programming too. I want my computer and the software on it to be as ordinary and boring as possible. I would not mind if the types from TypeScript make it into ES 20xx some day. Should be doable, after all, they are optional.
Notice that the bit about not having gained traction was meant about Google Closure's type comments, not about Webstorm. (Just saying, in case it was interpreted otherwise.)
Notice that the bit about not having gained traction was meant about Google Closure's type comments, not about Webstorm. (Just saying, in case it was interpreted otherwise.)
Notice that the bit about not having gained traction was meant about Google Closure's type comments, not about Webstorm. (Just saying, in case it was interpreted otherwise.)
Seeing that code I'm reminded of this blog post: [Does Curry Help?](https://hughfdjackson.com/javascript/does-curry-help/)
Test
Although, the example chosen was probably not the best for clarity. An Option/Maybe would have been a little easier to follow. Also one problem with the example is the lack of error flow control, I would expect that any future chains would not run if there was an error in the flow. As it sits right now, you would have to write that in every Monadic function passed to `flatMap`. That could be captured in flatMap itself.
Did you read it? I have nothing further to add. He says it all.
Oh yeah. totes read that. but the only thing that is curried is the monadic functions, so I can provide context to them. Without currying how would I be able to use those functions in the chain calls. I would have to write a separate function for each context. That does not seem very reusable to me.
My results from that benchmark are strange... Parser Generator/Framework Ops/second Jison 3.29 ±2.74% Chevrotain 3.42 ±2.35% antlr4 90.16 ±5.85% pegjs 210.36 ±3.24% parsimmon 18.02 ±3.93% nearley 17.82 ±5.04% Ohm 3.44 ±23.74%
I love PEG. I wrote a subset of some Excel functions for a part of our product at work. Very easy to work with! I wish it was a bit faster, however. I have looked into porting it to jison, but have been struggling with some of the rules. 
I believe your theory is correct. But honestly I would prefer Statically typed [Frank Grimes](http://simpsons.wikia.com/wiki/Frank_Grimes) types, over pretentious [Ruby hipsters](https://www.youtube.com/watch?v=TBb9O-aW4zI). Plus I always think that if JS wasn't so loosely typed, we wouldn't have to deal with this annoying test test test of every trivial block of code. I would rather write a type than a whole test Suite. 
I agree. it would be nice if our specs actually focused more on the actual unit under test then type checking. I write 10 specs for every function that could go away if we had static typing. When all I *really* needed was 2 specs for that given function. In my heart of hearts I wish that people would focus on a feasible way to get optional static types into the language. That we we could have something that the committee may accept and include into the spec. As I see it now, TS has very little chance of getting into the spec, so what is going to happen when we actual do have something that will work in JS? Does one continue pouring resources into TS for existing projects, or do they get abandoned to use a method adopted by the language.
Interesting responses. Maybe coding is not for me then... I will keep at it for a bit see if it improves though.
&gt; set TS to emit ES6 then use babel to transform in to ES5. Yo dawg, I heard you like transpiling...
I switched from using babel with webpack for es6, to Typescript with webpack. It was very easy and now I get significantly better autocomplete. But all of my es6 code was valid Typescript.
It's something trainable, so don't let it put you off.
&gt; Who knows just like when the ruby-ist realized the benefits of delegation and composition over inheritance Hasn't Ruby's classes been using delegation all along? And composition over inheritance has been a well known best practice since before JavaScript or Ruby even existed. JavaScript is a fine language, but you may be interpreting its history through rose colored glasses.
I recommend either Jasmine or mocha. Both have good documentation and you can find additional resources online. I personally started learning testing by adding tests to an existing project. 
&gt; a note for microsoft's PR team: You've crammed too much of your payload into the title here. "Love", "Random", "Honest"? Normal users of this site don't put so much effort into their titles. It's usually just a provocative quip; something like "typescript team getting love". Microsoft PR team? Are you insane? I've never worked for Microsoft, shut up if you have no freaking clue of what you're saying, srsly.
colors is an object that contains keys and values. As others mentioned below you can use the (.) dot notation to assign values to properties. If a property doesn't already exist it gets created. For example colours.teal = "#008080" or colours["darkcyan"] = "#008B8B" 
To me the best way to learn is to think of a project you really want to accomplish and just do it. If you get stuck look it up. Going through the motions on something like codecademy works for some, and is a good way to learn basic syntax, but if it's something that you want to do it'll come easier to you. Just my opinion though.
&gt; The only credit I give Microsoft is that they let him do whatever he wants over there. Why IMHO deserved praise so that they keep doing it!
Typical MS PR representative's response.
[removed]
Could someone go into a bit more detail about this line - "Closure is the ability of functions to access variables from containing scopes, even when those scopes no longer exist." I know how Closures work and I've used them in the past - well, I think I am doing so correctly - but I'm not sure how the above works. How does it access variables from scopes that no longer exist? How does it not exist? Great article btw. 
`log` is overconstrained to be an array here, when a writer is parameterized over all monoids.
Good call. Thanks!
Well except a simple `@` or other style could be more easily accepted into the language then creating keyword like `interface` and having a colon syntax inside of the function sig. But if people could focus on things that have a hope of being included in the spec, maybe we could make progress on this. Have more JS devs and less language x that compiles into JS devs. The less intrusive something is, the more chance it has for adoption. Personally I would Love to see static type in JS. But I would rather keep it in JS, So I am not writing in another language. Typescript is Javascript just like CoffeScript, Elm and Purescript are Javascript. (actually I would say Elm and Purescript are closer, as they are functional like JS is)
The [MDN article on closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) is really informative. There's a good deal of examples there to read through as well if you need more clarification. I think this line addresses your question: &gt; Closures are functions that refer to independent (free) variables (variables that are used locally, but defined in an enclosing scope). In other words, these functions 'remember' the environment in which they were created. 
&gt; Well except a simple @ or other style could be more easily accepted into the language then creating keyword like interface No interface keyword needed. Typescript doesn't need to be accepted or rejected wholesale. The spec could simply adopt :*type* And I'd wager this simple and already established syntax has a far greater chance of getting adopted. EDIT: &gt; Personally I would Love to see static type in JS. But I would rather keep it in JS, So I am not writing in another language. To be clear, your proposal isn't "in JS" either. We're both proposing new syntax to support a new feature. EDIT 2: &gt; Typescript is Javascript just like CoffeScript, Elm and Purescript are Javascript. (actually I would say Elm and Purescript are closer, as they are functional like JS is) Honestly that's a bizarre conclusion. Typescript is a superset of JavaScript. Any JavaScript code is also typescript code.
&gt; But what happens to all the code that is being generated now? Implements, interface and all of those bits could keep that code in a state that always has to be transformed. Well, yeah. Of course. It seems like you're moving the goal posts for every solution except your own. The :*type* would not cover all uses of TypeScript, that's true, but neither would your `@ someFunc :: a -&gt; a` cover all uses of TypeScript. Regardless of which static typing syntax we go with, there will still be uses for TypeScript. &gt; you can just scan a line above the function and not have to dig into the actual function implementation. Why would scanning the line above the function be better than scanning the actual first line of the function? &gt; Then the code stays javascript and the actual definition is separate. You keep saying that as if the new syntax you're proposing doesn't count as new syntax. If you would need a transpiler to make it work, as you've already said you would, then your code isn't staying JavaScript.
HA. there is nothing special about it. There is some math behind it, but it can basically be thought of as an operation on a container that can perform actions on "values, functions, other container" sequentially in well understood and expected ways. Well that could be said for all types of containers (except for the sequentially part, the `flatMap` has to happen one step at a time). The thing that makes the monad special is the ability to combine 2 of the same containers into one container. That is it. nothing more. that is all a monad is for practical purposes. So if I have a function that returns a Maybe. if I map that function into another Maybe, I will have Maybe(Maybe(x)) with my value wrapped in that new Maybe, so any further mappings I will have to Map twice. const safeAdd3 = x =&gt; Maybe(x + 3) const add5 = x =&gt; x + 5 const flow = compose(map(add5), chain(safeAdd3), Maybe.of) const flow2 = compose(map(map(add5)), map(safeAdd3), Maybe.of) console.log(flow(32)) // Maybe(40) console.log(flow2(32)) // Maybe(Maybe(40)) Chaining or flatMapping will combine the containers in one call, in a manner that makes sense for a given container (that is where the monoid part comes into play).
I considered that before. But I don't think Option/Maybe is the best for clarity. In my opinion, it is easier to follow, but also easier to miss the point. Because it is too easy to fetch the value out from Just by using dot syntax. Swift uses this a lot, it even provides syntax for it. And for error handle, I agree with you. But I also want to simplify the example code by removing anything that may distract readers.
The explanation you gave is too general. I would say everything fluent style libraries fit your explanation. However, this is a living example of "you don't need to understand monad in order to use it" mentioned in this article. :)
Me too!!
http://regexone.com is a great resource for learning regex. They have interactive examples which simultaneously show what's selected in multiple samples. Plus touches on really useful features like capture blocks.
I think it's a lovely accident that the title has the word "aquatinted." Can we leave it, or are we required to correct it to "acquainted"?
Tor doesn't shut down a circuit if there are active connections. You'd end up using the same circuit for the life of the websocket connection. Being bidirectional is irrelevant, because everything is bidirectional. And it's no more "direct" than a standard HTTP connection. From the standpoint of Tor, there is no difference between a WebSocket connection and a standard HTTP connection, except that the former lasts a lot longer than the latter (or at least, it potentially lasts longer; a large download over HTTP could last for hours for example.) 
Wut? People are throat deep in react here. 
&gt; In my case they shouldn't be a part of program core at all. That was my architectural choice (modular architecture vs. monolith) that "program" shouldn't be responsible for application logic but rather for infrastructure. I once did the same. I created a JavaScript based program that allows users to add little code snippets (executed in their own context only having access to some of the variables and functions of the actual program) as plugins to the program's logic. I wouldn't call them configuration nor would threat them as configuration. So I don't need to beef up any "configuration language" or language for "stringified" JS objects.
Hate to say it, but one of the nice things about React is that its so *easy* to write your own components that you don't really think about downloading these plugins. Just write your own input field to do exactly what you want. Now you don't have to use someone elses' plugin that takes 50 different hooks. 
yeah. but how long does a download usually take -- if its anything large i'd download over cleartext. if i'm chatting over sockets for example, i could be connected for hours.
There's really no great way to handle that, other than writing your own utility function. And if you're going to do that you might as well use an existing one, for example lodash has [`_.get`](https://lodash.com/docs#get). 
You could try wrapping it in a try/except. Lodash also has a "get" method that I usually use for this purpose. 
Declaimer: I am the author behind Chevrotain. &gt; I'm very suspicious of benchmarks provided by the creators. Everything is transparent, the entire source code of the benchmark is [available](https://github.com/SAP/chevrotain/blob/gh-pages/performance/index.html) on github. You can clone it and run/profile/debug it locally to alleviate any suspicions. And maybe even provide pull requests to fix any issues. :) &gt;Chevrotain itself doesn't look like my kind of tea either. Since it is a javascript DSL it looks really ugly an cluttered compared to any grammar format parsergenerators use. Being an internal DSL (no generation) Chevrotain is inherently limited by the Javascript syntax. And it is indeed uglier than a pure EBNF like notation used in most parser generators. The upsides to this approach are: * No debugging of **verbose** (&gt; 1,300 lines) and even **uglier** [generated code](https://github.com/SAP/chevrotain/blob/gh-pages/performance/jsonParsers/pegjs/pegjs_jison_parser.js), instead the **same ugly code** that implements the parser is the one debugged. * No need for a special text editor/plugin to write grammars. * No need to write code snippets in a none .js file. * No need for a build process step to generate the code (or even worse committing generated artifacts) &gt; Edited to reply to a another statement in the above post and fix formatting
I understand that, I guess what I was trying to ask is if there is a preferred design pattern when writing modules and trying to do it mainly functional programming?
Thanks for the post, I'll defiantly see what I can read up on Dan Abramov's projects. 
[There is operator spread and rest spread](http://stackoverflow.com/questions/33898512/spread-operator-vs-rest-parameter-in-es2015-es6). The first one is used heavily in reactive programming for immutable data. If you look into React projects you will pretty much see it all the time. [Here's the official issue](https://github.com/Microsoft/TypeScript/issues/2103). You can see people trying to convince TS makers to implement it. Anyway. I won't understand why people go through all of that to be honest. There hasn't been a single explanation why you want to get your Javascript filtered and served from them just for types, which can be had clean. 
Declaimer: I am the author behind Chevrotain. &gt;My results from that benchmark are strange... I'm guessing you are using **Safari** to run the benchmarks. There is a **horrible** [performance issue](https://bugs.webkit.org/show_bug.cgi?id=152578) with certain Regular Expressions on safari. I suspect it also effects this [issue](https://github.com/less/less.js/issues/2339) in the Less.js compiler. Jison, Chevrotain and Parsimmon all use a regular expression which is affected by that issue. Which is why the results are strange. Please try to run the benchmark on a another browser. Note that one workaround for this is to simply write a hand crafted lexer. Chevrotain is not constrained to only be used with it's built-in lexer. 
Declaimer: I am the author behind Chevrotain. &gt; I'm not sure about Chevrotain being "better", with regard to ease of development. I ran into PEG while designing a DSL for the first time, and its configuration seems much easier than with Chevrotain. Granted the syntax is not as pretty as an external EBNF like syntax. but ease of development does **not** begin and end with writing the grammar's code. * What about debugging [generated code](https://github.com/SAP/chevrotain/blob/gh-pages/performance/jsonParsers/pegjs/pegjs_jison_parser.js)? * Quick feedback loops (due to no code generation) ? * Dealing with generated code on the source control(commit the source code or add a separate build step?) But even if we limit the discussion to only **writing the grammar phase**, using an external EBNF like syntax (as in parser generators) to define your grammar will make it **pretty**, but also means that to enjoy a good editing experience you must have a IDE/Plugin which understands that syntax, does one exist for your favorite combination of Parser generator and IDE/text editor? If not you are out of luck... With an internal JavaScript DSL (Chevrotain's approach) you can use **any** JavaScript IDE/text editor and enjoy the benefits of modern development tools such as autocomplete / go to definition / find usages / refactor ... Because its all just **pure JavaScript** 
I done a lot of reading today, you've cleared a few things up. I'm getting my head around design patterns and the paradigms not explicitly being related. I saw the 'object container' in all it's objectness and just assumed that you should do a object oriented style when working with it. Thanks for your help as always.
Correct, I thought it was likely that. Its a shame, hope they sort it out. What does PEG.js do differently?
And AFAIK, WebSocket include a keep-alive header in the HTTP request, so that the server doesn't drop the connection.
Be more explicit regarding the benefits of doing this. If I would be new to this I wouldn't really see a reason to start following what's outlined here. For example, in the section regarding array.push vs array.concat, you could have added a snippet showing how this helps with comparing arrays and seeing if they've changed.
A lot of your complaints are about ES6 and not Angular2. You can write Angular2 in ES5, without imports, or build systems. But your code would be much more difficult to handle (meaning you will have to add every script file manually to your html). The more you invest in infrastructure, the more your code will be manageable.
Don't use string concatenation to create DOM elements. If you're not using any front-end frameworks where you can use templates to create your UI, use something along the lines: var myNode = $('&lt;div&gt;'); myNode.addClass('myClass'); var mySecondNode = $('&lt;div&gt;'); myNode.append(mySecondNode); This would help you to easily update your data; 
This is cumbersome indeed. So much, that in AngularJS HTML templates they allow such expressions to quietly interpolate to null without throwing exception. The following "Hello {{ user.fullName.firstName }}" would not throw an exception in AngularJS even if any intermediate object is null. So one option is to use templates that handle nullable properties gracefully. Naturally, this only works for viewing stuff or generating HTML and not for proper server side code.
Well... context set by OP was "static data for game" not "configuration" :)
Yes, I've made it. Thanks for you appreciation!
&gt; Or anything else that can't be easily understood by simply reading through the lines of code, no matter how well the names of the objects and variables are set. How would you prove the claim that there's "something that can't be easily understood by simply reading through the lines of code, no matter how well the names of the objects and variables are set" without providing an example? I honestly recommend writing something and post it here. I would be very interested in an explanation on why something wouldn't be able to be understood without comments using a high-level language like Java, JavaScript, C#, etc.
Thanks, but I think that /u/bj_hunnicutt hit the nail on the head; Netflix has a protection on their &lt;video&gt; element which prevents it from being drawn directly like this. Thanks, though!
I refactored a scraper for [Bandcamp](https://bandcamp.com). The project is on [github](https://github.com/masterT/bandcamp-scraper).
throw vue.js into the list of popular options now.
What would the advantages of this be over something like redux? It's sound pretty similar.
hmm vue.js haven't heard about it before. What are its benefits/downsides? If i may ask. ps: thank you for commenting btw, its really appreciated. 
(((response || {}).user || {}).fullName || {}).firstName
React is popular because you can render the content server side, avoiding SEO problems. [This might help](https://medium.com/@firasd/quick-start-tutorial-universal-react-with-server-side-rendering-76fe5363d6e#.q0fztbdpr). Disclaimer: I haven't done that myself so I can't comment with real authority, but it's definitely something lots of people are doing in real sites.
"No longer exists" probably means "no longer in the stack". It (the scope) definitely still exists.
You don't need anything but html, practically you can usually do anything you want if you add in js and/or css. (though you don't technically even need html... for really simple stuff you can either host a text file or you can write markdown and 'complie' it to html...) if you want to get up and going faster but increase the long-term support effort, frameworks are for you! I say they increase the support effort because now you have a framework you should probably update occasionally, which means updating code that uses it. Also when you pick any framework you reduce the pool of people who know how to help you (both internally in a company and online)... that said it's often harder to find out how to do something without jquery than with, b/c with seems to be the default. You also have to consider, if your project is small, is adding another 32k worth of code, in the case of jquery, really necessary? or do you just want the $() selector? One final point is that when something breaks when using (at least some) framework(s), instead of just changing the thing that's broken you now need to figure out what change that thing so you can fix it by proxy (if what you want is allowed by the framework) ... not that you shouldn't ever use frameworks, but you should A.) consider these points and make the decision rather than just defaulting to a framework B.) know how to do the things you need to without frameworks (with a few exceptions like three.js whose functionality you're unlikely to replicate in pieces.)
First of all, you need HTML if you need to add some structure to your page (headers, paragraphs, lists, italic, bold, underlined text), links to direct your visitor to other pages or websites and you can also add media such as audio, video and images. Now, your pages will look dull, that's when CSS comes in. It allows you to turn your not-so-great looking pages into something a bit more easy on the eye. You can change color, font, font size, backgrounds, layout and even add animations with CSS3. CSS is cool but can be tedious to write and organise, so there are some CSS libraries (bootstrap for example) that can help you organising your pages' style and has already a lot of the style pre-written for you (you can override it of course) JavaScript allows you to add behaviour to your pages. Listen to events like clicking, mouse hovering, and do something about it. I'm over simplifying what JS can do, but it's quite powerful. Unfortunately, some browsers speak different JS dialects (APIs), so it's often useful to use a library like jQuery, which take care of that. It also simplifies your JS code with some functions already written for you Then it could be that your web page end up being huge, with a lot of behaviour and reusable components. Now, you can organise that massive code base you have written all by yourself, took time to document it for other developers to get involved and understand every bits you have written, or you can use a framework such as react, angular.... They are well documented, a lot of developers already understand how they work and won't need to invest much time to understand your project. Frameworks help with project organisation and keeping your code DRY. 
Nifty.
Awesome response and good to know!
Understood. We're not looking to just collect emails. Those that are signing up are being given an activation link to begin building on the platform. 
Well. . . you also need a webserver.
Time to npm package this, "gradient-color" is not taken.
Well you can create a front-end, single-page application (to a static extent...) with just your desktop, your text editor and the browser you used to make this thread. If you want some dynamic aspects or you want your site public, then you'll need to find a webserver provider or host a server from your home (if your ISP allows you to *and* you're proficient with networking/IP.) So what all are you interested in having to publish a Webpage?.. some more context will return you some better answers.
It looks like linear interpolation in RGB space. An interesting update would be to pick between RGB, HSL, HSB or LAB. If you can afford the extra computation time some of these will make muh more aesthetic output. 
I would look up how to do small things like 'how to translate' in a js and then apply that logic to your own thing. Start small and work your way through. Free code camp has some good project ideas, I suggest looking into that
Looks great !
Brian Lonsdorf is really cool. He links to one of his talks in his post. I think his talks works best though when he takes the proper time to explain how stuff works instead of just blazing through slides.
Here's the [Pipeline operator proposal](https://github.com/mindeavor/es-pipeline-operator) (which is buried in the article)
The bare minimum to make a website is chrome browser (for editing, testing, and viewing a webpage). You don't even need an internet connection.
Another difference is that Meiosis creates components that are view = function(model), with the propose function/actions object already passed in. I really like being able to compose views with components that are functions. Works well with not only React, but also Snabbdom, Mithril, or other VDOM libraries.
This looks like a really simple example to a very powerful technique. Cool
Although I prefer a more declarative style. This is great for those who find imperative code easier to read and manage. In this style does it still make sense to put your functions with data first and context last? Like Employees is the data and the predicates are the context for that data through the function.
Hi /u/swizec, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Firstly thank you so much for taking the time to write all this out. The goal is to learn the framework in essence with website development. I know there are more better suited frameworks and pathways to do this. But im intrigued about the idea to learn more about isomorphic frameworks that can be utilized to develop more interactive websites. SO i wanted to challenge myself and build a personal portfolio website with some interactive ideas in mind, that would allow me to learn as im building it. I feel personally i learn more by finding something already built as a goal and try to build towards it and if possible build it better. So when i saw the arsthanea website i was intrigued because i hadn't seen angular been used as a portfolio website before. And it got me interested in seeing if it was possible for me to do as well. although now im contemplating between react, vue and angular2.
Thanks for the heads up. It's fixed now.
i don't think your virtual dom library is going to help someone who's barely picking up jquery
code your own pomodoro timer as well
no. 1. it’s of limited use and weird design: why not exported free functions? 2. [d3-interpolate](https://github.com/d3/d3-interpolate) exists: `d3.interpolateLab('steelblue', 'brown')(0.5)` 3. it interpolates in RGB space, which is a bad idea.
&gt; I would be surprised if anyone from the JS community would particularly need a non-node server. Genuinely can't tell if you're serious or not...
Hey /r/javascript, just wanted to let you know that the Flow team is watching this thread and can respond to any questions that you have.
I have a hard time learning from blog posts and tutorials and what not, so I like his blazing fast bits, with accurate names and information. Gives me things to search on at my own pace. The key thing for me is his ability to give me what I need to search on to broaden my knowledge on a given topic.
There have been a number of discussions about optional static typing in esdiscuss over the years. 1. https://esdiscuss.org/topic/optional-strong-typing 2. https://esdiscuss.org/topic/es8-proposal-optional-static-typing And I recently saw this draft of a proposal on GitHub: https://github.com/sirisian/ecmascript-types However, no one on TC39 is not actively pursuing it AFAIK. I have not participated in TC39 so I'm not sure how they feel about it. I wouldn't hold your breath though, the standardization process is very long. &gt; It seems like the combination of Typescript + Flow there are two implementations that could be used as reference? Flow and TS have syntactic similarities but a lot of differences in terms of the actual type system (Flow tries to be as sound as possible where TS does not), I don't know how useful they are as reference implementations for anything other than syntax.
https://ecmascript-daily.github.io/pages/status-of-static-typing-in-ecmascript/ is a relatively recent summary of the various proposals.
Weird that this links to HN then to the real article...
Thanks for sharing this! Yes, Inferno now has bindings for all three libraries thanks to contributions from other developers in the community. Please try them out and let the team know if you experience any issues and we can help. Note: I'm the author of Inferno.
Oh geez, that was unintentional...
As someone who hasn't really used TypeScript or Flow, could you guys mention what the differences are, and maybe why it would be preferable to use Flow over TypeScript?
Flow and TypeScript are actually quite similar in terms of the syntax (and in places support each other's syntaxes) but they have different goals in terms of the type checker. - TS has said that having a sound type system is a non-goal of theirs, where it very much is a goal of Flow. - Flow is also better designed for incrementally migrating codebases to having types which is a hard requirement for many people. - The design of Flow internally is quite interesting ([suggest watching this for a technical deep dive](https://www.youtube.com/watch?v=VEaDsKyDxkY)), it allows Flow to follow types much further and infer more (lots of possibilities for future development too) This is just a couple quick things (maybe not as specific as you wanted), to get a better understanding you should try it out yourself! Feel free to ping me if something blocks you https://twitter.com/thejameskyle
I really want to dive deep into functional programming and seeing articles like this is really cool… but for the life of me I don't see any practical application for most of FP.
I believe you have more context than I do in this area, but for practical purposes, that is the simple interpolation code I see used everywhere and I think it has worked perfectly fine for me so far. For example this is the view pager implementation code from Android, where the tab titles colors are interpolated the exact way as in your code example. https://developer.android.com/samples/SlidingTabsBasic/src/com.example.android.common/view/SlidingTabStrip.html#l172 (blendColors method) I am currently at work, I will read your links when I have free time.
Thanks 🙏🏻
You should check out gatsby : https://github.com/gatsbyjs/gatsby it allows you to build a static site that renders via react components. recent HN thread : https://news.ycombinator.com/item?id=12128989
&gt;Any update on support for using TypeScript definition files with Flow? It doesn't seem as though the team is still watching the issue on Github: https://github.com/facebook/flow/issues/7 &gt;&gt;We've actually been discussing going the other way with a conversion tool for package publishers. So converting Flow definitions to TypeScript definitions? What would be the point of that?
It provides the same practical applications that anything else does. Benefits vary on many different levels, but the main benefit of learning the principles, is it allows you to write concise, well controlled code removing dependencies on outside state. Most of the bugs I used to run into with my code usually boiled down to shared state between different parts of my app. Just learning the basics, you can see and recognize where potential issues are going to arise in your code. So just learning it will provide much knowledge, even if you do not go full on "pure functional" JS. It also lets you fully utilize the root features of JS (Lexical Scoping and First class functions). 
In all honesty I only took a quick look. I was just surprised by seeing a python option to serve the examples specifically. I should have been more specific - my bad
sure, i work in other languages on the backend, but i mean specifically to serve examples - unless there's some isomorphic hookup I'm missing? having said that i've been full stack js for a few years so it just surprised me, should probably get out of the js bubble!
yup, i bet you’ll find them interesting :)
@Sunwukung Hmm... but did you realize that if you have Node installed, then I use Node to server the examples? npm start :-) Python was just an arbitrary example for people not using Node. UWYL: Use What You Like! :-)
Do you have some references/citations for your first two bullet points ? Those are some strong claims. In what way is the TS type system not sound ? In what way is Flow better designed for incrementally migrating codebases compared TS ? Are you familiar with the changes in TS 2.0 ? 
I don't fully understand FP (the math goes over my head), but the concept of creating functions that don't rely on outside state — meaning that no matter what's going on in the rest of the app, if you feed the same argument to the function you will _always_ get the same result — has been pretty game-changing. It makes debugging WAY easier, and narrows the scope of a bug hunt dramatically. I think it's well worth digging into at least the broad strokes of FP for sure. 
The biggest plus to using modules whether it's CJS (require) or ES6 module syntax (import / export), is it allows you to scope each file/module in such a way where you are only using modules, vendor or your own, that you want to. That means if you have some weird declarations or functions that would be defined on the global scope otherwise, will now only be available for the file importing it.
Sure! The third bullet point on [TypeScript's design goals wiki page](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals) says this: &gt; Apply a sound or "provably correct" type system. Instead, strike a balance between correctness and productivity. As many have noticed, Flow and TypeScript have very similar syntaxes to them and they support many of the features. But in order to compare their strictness you have to dive into the implementation details of those same features. I'll try to be as fair as I can to both systems, both are great projects and I respect these design decisions. TypeScript designs things to warn you less when things will *probably* work. This is what they mean by striking a balance between correctness and productivity. Flow designs things to warn you more often and does its best to validate that things *will* work. The opinion is that catching more errors makes you more productive. Here's an example I linked to elsewhere where Flow validates more than TypeScript as a result of it's design goals: https://gist.github.com/thejameskyle/24a4e32be4899419e53eec655e538a7f (It's more complex than that and there are many more examples, but I'm trying to keep this brief) It's harder to describe why Flow is better at migrating codebases incrementally. It's going to be a lot of little things around Flow's inference, file-by-file migration, and the design of the type checker– all together it's a strong focus because Facebook has a lot of code that it needed to migrate over a long period of time to using types. I am pretty familiar with the changes TypeScript 2, and I like that they are starting to head in the direction of Flow (although I wish they didn't divide their community by using flags). However, we still have different design goals that are both are worth pursuing. I hope that this is helpful, I explain things much better verbally and this is a complex subject (and I only recently joined the team!)
&gt; Monoidal Contravariant Functors "Hi, I'm functional programming, and I have a jargon problem."
Well it would not iterate on those functions in that function call, iteration would happing in either pipeline or compose. But yeah, I feel yeah. I thought that way too at one time.
Great suggestion, I'll resubmit a new post. Thanks
maybe you should consider citations before answering the cavalier "better" in the future.
This is extremely helpful. Thanks so much. 
Not trying to be cavalier. I'm trying to find better ways of communicating information without going on and on. Others might have an easier job than me
On my phone so excuse me for being brief. It's like how a square is a rectangle but a rectangle isn't square. You can get less specific but you can't get more specific. Obviously more complicated than that but it's a better starting place
The most elegant way I've found is [getify](https://github.com/johnste/getify), using ES6 proxies. Example: import getify from 'getify' const obj = { a: { b: ['c', 'd'], e: ['f', 'g'] } } // Get existing value from object getify(obj).a.b[1]() // returns "d" // Get undefined if path doesn't exist getify(obj).nothing.here() // returns undefined // Use a default value if path doesn't exist getify(obj).nothing.here('oops!') // returns "oops!"
Wow, so many downvotes with so few comments. If you are going to down vote at least have the balls to explain why.
Excellent job!
So you have a forgetful functor, F : Flow -&gt; TS.
Another company asked some specific Backbone questions about managing child views, and how to use the `update` event on a Backbone collection. Other than that, just general knowledge.
With TS 2.0 settings, you can make `import React from 'react'` work. Hovever, `import { default as React } from 'react'` doesn't even with the setting.
&gt;How would you prove the claim that there's "something that can't be easily understood by simply reading through the lines of code, no matter how well the names of the objects and variables are set" without providing an example? Because it's uber complicated maths or whatever. &gt;I honestly recommend writing something and post it here. If I were a maths genius I would 😂
&gt;Why is it easier to express complex data and interaction with OOP than FP? It isn't. It's precisely the opposite. OOP may make it easier to conceptually model certain data *structures* because general human cognitive processes about "things" is more encapsulation like than compositional (i.e. your average person sees an automobile as an object that moves {encapsulation}, while an auto engineer sees an automobile as the sum of it's parts {composition}), but OOP vastly complicates a human's ability to cognitively manage the interaction of elements as the complexity of the system increases, which is why in the age of modern (imperative) programming, more time goes into writing tests than writing actual productive code. OOP should deservedly get bashed for it's shortcomings in the modern age of distributed, concurrent, high-availability (i.e. you can update-in-place as a matter of course in PFP), [more buzzwords], as well as it's failings in developer productivity in the general case, which is really the most important case of all. Afterall, we are the music makers, and we are the dreamers of dreams.
As I said, tabs vs. spaces. As complex data evolves it may be much easier to add a function to a class or create a new class, rather than altering many functions to support a new use case. Insert biased sentence here. I've seen just as many testing complications with functional mixin solutions as I have with OOP.
It also just seems like such a strange, distant world. At least OOP is somewhat relatable in its terminology. I saw some thread on /r/javascript and the title is "Monoidal Contravariant Functors". What in the hell?! Do these people just put together random syllables to try to come up with the strangest words? 
&gt;Do these people just put together random syllables to try to come up with the strangest words? Whatever do you mean? A monad is just a monoid in the category of endofunctors, what's the issue? ;-)
I've had this same thought and when I explored it I didn't think it was going to cut back on the work load. It seems like every mini angular app you have is going to have its own configuration to it. I don't know how to explain it. How do you propose to structure the angular apps and what would their purposes be? 2 way binding, validation, and maybe some http requests? There wouldn't be much if any routing going on with it right?
Pf, another eric elliot with"mind blowing" information. No thank you, sir!
HA. Starting to notice that :D.
&gt; At first glance, Inheritance appears to be the biggest benefit of the Object Oriented Paradigm. Stopped reading at that point. Are schools just teaching OOP this badly? Inheritance is a facet of _type systems_. It is not a part of _object orientation_. They are completely and utterly unrelated topics. The flavor of FP that is popular in the JS community is _deeply_ dependent on OOP to even *ahem* function. Good software uses OOP _where it makes sense_. It uses FP where it makes sense, uses procedural programming where it makes sense, and uses declarative programming where it makes sense. It uses data-oriented programming where it makes sense, and data-_driven_ code where it makes sense. It uses configuration where it makes sense, code where it makes sense, and convention where it makes sense. Constraining oneself to only use or never use one programming paradigm is like trying to speak a language while containing oneself to only use or never use one part of speech. Avoid part of speech would language incomplete and I sad for people that not complete. :(
Love to see UI components (like OnSen UI) built on it
So you're not seeking to do anything server side with this project?
Something I usually do in this situation is just check for the data beforehand - sometimes, if you don't have a user, you might not want to continue at all. Other times, you can just initialize the object to something like an empty object so that the following code can just continue without all the checks: if(!response.user) { return; } response.user.fullName = response.user.fullName || {}; let firstName = response.user.fullName.firstName || ''; 
Back when I was getting into promises I found this [article](https://ponyfoo.com/articles/es6-promises-in-depth) very helpful... Even comes with a [playground](http://bevacqua.github.io/promisees/) EDIT: Really dug most of the ponyfoo articles when coming online with the ES6 features back in the day.
There's a beginnings of a WebStorm Flow plugin at https://github.com/dsilva/webstorm-plugin-flow-typecheck It's fairly basic: on edit, it runs "flow --show-all-errors --json" and turns the errors into problem descriptors in the editor.
I still need to decide on TypeScript vs Flow for Pokémon Showdown. My main issue is that I'd prefer for the codebase to be executable out-of-the-box by Node with no compile step. flow supports this with Flow Comments, but these are kind of ugly... JsDoc support would be really nice. TypeScript seems to support JsDoc comments only for IntelliSense, not for actual type checking?
Thanks for the information. I tested myself the Github Gist you linked and I have to say I did not get the same results. I get an error with Typescript 1.8. See for your self: http://imgur.com/a/TWSeC Also, as expected, doing `return obj.prop.toString();` will resolve the error. You can try this your self at https://www.typescriptlang.org/play/. It throws the error. 
In this demo, I render reflections in a plane using a trick with the stencil buffer. I provide a video [here](https://www.youtube.com/watch?v=FUNAcjJHo8U), in case the demo won't run. Those who are curious can find the implementation details described in the top of the [source code](https://github.com/mikolalysenko/regl/blob/gh-pages/example/planar-reflection.js). 
Check out Brackets with Live Preview option. Indispensable for me. https://www.youtube.com/watch?v=Nhvj1NYC3Uc
What URL can I add to a WebStorm ticket to show them this API? Whenever I'm missing something I write a ticket (at least a hundred thus far) and most of them get resolved.
Hmm... how many statements needed to implement a `try...catch` block by the interpreter?
Vanilla JS? Where can I find this framework?
If you're storing data (like posts with their tags), you *will* need somewhere to store data. That means something other than just HTML, JS, and CSS has to live somewhere. You can get away without running an actual backend by using a backend-as-a-service like Firebase, but be prepared for it to be more involved than a typical jQuery page. You'll also need some notion of authentication (read: login) if you want to be able to write posts without manually inserting them into wherever they're stored. That's logic you *definitely* don't want on the front-end, since anyone who can right-click and "view source" will be able to get around it. What may be a better solution if you want a simple lightweight blog is to look into a static site generator like Jekyll... although at that point the Javascript isn't really needed, since the HTML and CSS for each post and everything will already have been generated.
Check what of the hundreds of new and fresh and important and best-practice frameworks is THE framework at the moment and use it as buzzword. Since "the best framework ever" changes every few weeks no-one cares ... Are node.js and jQuerry still a thing? You should know those at least.
I don't understand the need for this. I'm adding 3 KB to my page weight just for some syntactic sugar, whereas I could simply do this: const colours = { RED: 'RED', BLUE: 'BLUE' }; const myColour = colours.RED; const isRed = myColour === colours.RED;
My problem is that for the stuff I program *there IS state*, and I can't avoid it. It's because I keep little in memory, the actual processing on any one given machine is insignificant. My problem is the consistency of the data that I write. I can't encapsulate data that's not in system RAM in a function. Or if I try I add other complexity that's just not worth it. I use *a little bit* of FP, but nothing approaching "pure FP" because I don't see any value in code that few people can read. Each time someone posts an exercise in "pure FP" most people have a hard time even figuring out what that piece of software is doing - and the same code written "traditionally" is easy to comprehend. I always get the impression the cure is at least two orders of magnitude worse than the problem, because when using some common sense and good style "traditional" programming is just fine. FP is all claims and little PROOF of its superiority - and I mean "pure FP", not "using FP elements". Which I happily do, for example, in my JS projects (that's what I wrote most stuff in right now, but it by no means is my only language) I use neither `prototype`, `bind` or `this` or the new `class` (or the ES5 equivalent). I encapsulate everything in functions. I never change function arguments because who somebody might use that object just given to a function for something else even if the current code doesn't, and the side-effect of a changed object might come as a surprise. And yet, I just don't see any reason apart from "looking smart" of making it more complicated and adding some of the deeper FP stuff. I see a value for processing-heavy code. Parallelization is easier, but there is a lot of code that just shovels data around and does very little with it. It seems to me the FP guys are waaayyyyy too heavy on enthusiasm and way short on even trying to understand *why* other people don't follow. Examples always are way too short to convince anyone. The evidence that *overall*(!) "pure FP" is better is lacking, and I've spent a lot of time looking at and learning FP (hey, I even think I understand monads... of course I could not explain it to anyone :) ). Personally, and I don't think I'm alone, I much prefer to listen to someone *less* convinced of the righteousness of their ways. Somebody for whom the whole matter is just "a job" without emotional involvement. It's easier to trust someone like that to have carefully weighed the options. People who start using what to their audience is just mumbo jumbo when trying to convince other people demonstrate a profound lack of understanding of their own subject. My impression is that A LOT of those trying to "sell" (pure) FP have just recently understood *a little bit* and now are enthusiastic and messianic. The psychological principle at play here is that what we had to work hard to achieve - here, understanding FP - is much more valuable to us. However, that is not a basis for an objective assessment, that's clearly a bias. It doesn't mean they are wrong, but their own statements and behavior are hard to use for a judgment. It seems to me that most *real* attraction of FP doesn't come from it being demonstrably better *overall* (not just in some areas), but from being *hard*.
I hadn't mentioned, but security isn't a concern, as it's something I plan on running on my own computer just for me. Though for the portfolio, maybe not a good idea to offer an insecure thing to the world haha. That said, I'll check out Jekyll. :) thanks!
Downvote. This is based around the WHATWG spec, which is... garbage. The real DOM spec, the standard used by every user agent application that renders a DOM, is https://www.w3.org/TR/#tr_DOM
Nice :)
W3C often takes specs from WHATWG, copies them, makes some minor changes, puts the W3C name on it and call it their own without attributing WHATWG.
Automatic semicolon insertion: // This function will return undefined not the object literal (function () { return // JavaScript will insert a semicolon here { a: 1 }; })() 
+1 for webpack
Hi /u/lakidavid, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `blog.risingstack.com`. **Also**, please be aware of a [previous warning](https://www.reddit.com/r/javascript/comments/4p9bj3/handling_react_forms_with_mobx_observables/d4jayor) against this same site (curiously, /u/hfeeri stopped posting a month ago, about the same time /u/lakidavid was created...); it won't take much for `risingstack.com` to be banned, so tread carefully. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.risingstack.com](/search?q=%28and+site%3A%27blog.risingstack.com%27+author%3A%27lakidavid%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|6|60%
Maybe, so then lets consider the WHATWG spec a suggestion box.
Hello, I have been working for a few days on a tool to make life easier for some people and have encountered the first hurdle that I can't overcome, no matter the amount of search I do. I am trying to upload canvas to my server, I know the canvas are generated well and that the serverside code works too but when uploading using toDataUrl all I get are blank images and I don't understand why. https://codeshare.io/WTvlU Thanks in advance
I'm not sure how you're getting an error because I'm doing the same thing in my own editor and getting no errors. http://i.imgur.com/5h9GJNp.png When I use it on the TypeScript play website it ignores the refinement altogether (http://i.imgur.com/ZMNbj8k.png). I'm not sure why the inconsistency. /u/DanielRosenwasser any idea? 
Can you test the toDataUrl on the client side? Are you able to see the image purely on the client side after converting it to a data url? Remember it's not what you don't know that gets you in trouble. It's what you know that isn't right. Is your server getting the data? 
thanks for responding, I can see the canvas clearly clientside but the data url, I can not. edit: I can see the data url client side but it gives a blank image. 
If you console log the data url what do you get?
https://github.com/CEREBR4L/linkr/issues/10
&gt;It uses FP where it makes sense, uses procedural programming where it makes sense, and uses declarative programming where it makes sense. It uses data-oriented programming where it makes sense, and data-driven code where it makes sense. It uses configuration where it makes sense, code where it makes sense, and convention where it makes sense. **This is why large systems become unmaintainable messes that are an absolute nightmare to extend and/or refactor!** The entire purpose of statically typed *pure* functional programming is to eliminate computational uncertainty caused by mutable state to the degree that reading a functions type tells you explicitly what effect it will have on the system under computation. Your entire thesis here is that creating the modern equivalent of 1980s imperative spaghetti code by mixing paradigms and conventions and styles in a ad hoc fashion *is a good thing.* Coming from a statically typed purely functional point of view, you sound to me *like a madman.*
This! http://brackets.io Brackets is an open-source project, and it has this: *Get a real-time connection to your browser. Make changes to CSS and HTML and you'll instantly see those changes on screen. Also see where your CSS selector is being applied in the browser by simply putting your cursor on it. It's the power of a code editor with the convenience of in-browser dev tools.*
&gt;there IS state, and I can't avoid it. You can avoid it. Start by watching the video I linked in the comment you replied to.
Fix for this is also now pushed to live site, thanks for noticing the issue :) 
I'm on mobile so can't test, but your problem appears to be one of timing. You are creating a blank canvas and setting it to load an image once it has fully loaded, but then you are immediately trying to upload the data. When the call to `toDataUrl` is being made, the canvas is still blank because it hasn't processed the `onload` handler that inserts an image yet. Then, only after it fires off the AJAX request with a blank image, does it get around to loading the requested image.
X-Post referenced from /r/aureliajs by /u/Davismj [Custom Elements and CSS Frameworks in Aurelia](https://www.reddit.com/r/aureliajs/comments/4vtp65/custom_elements_and_css_frameworks_in_aurelia/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
That would totally be cool. I'm creating a video player on top of Inferno. Combined with mobx-inferno it's fast as hell ! My only wish is that the router was better... I'd contribute but I know nothing about routing!
I use Brackets as well. It's great. Sometimes, though, I find you still have to refresh the page every once and a while. Especially when copying/pasting large blocks of code, performing multi-line edits, or when altering JS code.
[removed]
As you can see, there are 3 buttons. 1. is assigned with .onclick inside the class. So it has no knowledge of the current instance per se ('this' == the button) 2. it is using the current instance and assigning an inline onclick and it works. ('this' == the instance of the class) 3. I am using getElementById.onclick and have the same result as 1 where this is not proper scope. ('this' == the button) Should I use something other than 'this' in there? I'm sure I am missing something simple but been at it for a while. Thanks
Hi /u/sammyhogswarth, your comment was filtered because you used a URL-shortener. Please repost using the full URL. Thanks!
[removed]
Hmm.. looks like that needs a fix. Thanks for pointing out!
SOLVED:: I was just missing .bind(this); THANKS REDDIT
Array.prototype.reduce is REALLY powerful. You can write a lot of things in terms of it, things you wouldn't think of immediately. As a start, I would read more about it (MDN is a great resource) as well as the other array methods. My advice would be to study those in-depth, and maybe even try some practice problems and limit yourself to never use a "for" loop. My team at work has a relatively large (8000 lines or so, including tests) front-end project and last time I checked we didn't have a single "for" loop. Another great resource (free) is one you may have heard of before: [YDKJS](https://github.com/getify/You-Dont-Know-JS). It's a book series that is free to read online, and it wasn't until reading through those that I really understood JavaScript deeply. For the array stuff specifically, there's a nice course on egghead about arrays (https://egghead.io/courses/javascript-arrays-in-depth) and one specifically about reduce (https://egghead.io/courses/reduce-data-with-javascript).
I can't speak generally, but for me the path to learning "better" ways of doing things (pure functions, higher order functions, functional tools like map/reduce, etc.) went something like: 1. At work, do things the "wrong" way for awhile 2. Read an article about a better way 3. Think "that's cool" ... and then forget about it 4. See another mention of the "better" way somewhere (possibly in another article, or just in someone's code) 5. Sometime later (back at work) I go to solve a problem the "wrong" way and (because of #2/#4) I think of the "better" way, so I try using it. Usually this takes ten times longer and involves looking up how to actually do the "better" way. 6. After #5 a light bulb usually goes off, and when I see similar problems after that I at least think of the "better" solution TLDR: Read how to code better, file it away in your brain, and the next time you see a problem that might be able to use that technique, try it. In my opinion, if you really want to make it natural to use such techniques, you just need to code as you always would, while keeping an eye out for opportunities to use the stuff you read about. And if you keep missing those opportunities, read and re-read about the technique until you get it stuck in your brain enough to think of using it.
What I meant about reduce being powerful, is that you shouldn't feel bad at how "simple" that code example is. I had to really study it to understand how it worked. Power/elegance often comes at the price of understandability. So don't feel like the "reduce" example is the "right" way to write JavaScript or anything. Your original solution could certainly be condensed some, but it accurately represents the way you thought about the problem in your head. If you start there and add tools like the array methods and other language features to your toolbelt, you'll start to think in terms of those tools.
Yeah, definitely not good for secure links. But probably fine for public urls.
Yeah so the app right now is not designed for private links, actually everything is publicly available via the api. I plan on building in a feature for private links, just a check box to mark links as private and will look to generate a random string/guid and return it back in the same fashion, it wont be visible on the site or via the api. The is an issue open for it here: https://github.com/CEREBR4L/linkr/issues/6 Thanks for the feedback :)
Yeaaaa you're going to want to change it to a randomized string unless you made the domain for the fun of it. No one will legitimately use it otherwise. Also, reusing shortened links for the same URL is fine in the short term, but not if you ever want to provide analytics on a per link basis. Another reason why you want randomized links versus auto incrementing.... With alphanumeric, you'll get 1.5m+ variations of URLs out of 4 characters, versus 10k. 
You're welcome (for the feedback), and thanks for clearing that up! 
You can pass scope around as a variable by assigning a variable to 'this'. Or the better way would be to make a class and use the scope of the class. A simple example would be: function TicTacToe() { this.board = [ [' ',' ',' '], [' ',' ',' '], [' ',' ',' '] ]; } TicTacToe.prototype.reset = function reset() { this.board = [ [' ',' ',' '], [' ',' ',' '], [' ',' ',' '] ]; } TicTacToe.prototype.render = function render() { console.log(this.board.map(function (row) { return row.join('|') + '\n'; }).join('-----\n')) } var game = new TicTacToe(); game.board[1][1] = 'X'; game.render(); game.reset(); game.render(); 
&gt; "And great. Now it won’t compile. Why?? Oh, I see… This object contains this other object. So I’m gonna need that too. No problem." Good luck importing non-OOP code, if you think this is the worst it gets. 
you're a god send 
We are in the same boat mate...
That all depends on your definition of "effective" code. Some people like to write their code so that there is a balance between performance, testability, reliability, and readability. Others might just focus on performance. Some focus more on big-picture coding concepts like DRY and Law of Demeter. Others write code to make them look smart, but don't really care if coworkers understand it or not.
Is it just me or are these two solutions not returning the same result? I created an array (`[1,2,3,4,5,6,7,8,9,10]`) and input that into each function. `function findOdd(A)` is returning `9` and `const findOdd` is returning `11`. Am I missing something?
Many of the higher-order functions are ridiculously powerful. I once wrote a function that found the top 10 words used in a collection of blog articles. It was riddled with HOFs doing all of the heavy lifting. [Code in a gist](https://gist.github.com/goodwid/9c9d290de69f157a74505bd68c03ec98) if anyone's interested in seeing it.
Shame on me but I hadn't used the XOR operator before I stumbled upon this exercise. To me it was just one of the operators that are often described in JS books' introductory chapters and are not likely to be used in real life. It's clear now how mistaken I was. 
It's not just you. According to the exercise, there can only be one number with an odd number of appearances which is why I didn't even think about handling this case. 
&gt; This is why large systems become unmaintainable messes that are an absolute nightmare to extend and/or refactor! Applying abstractions and patterns where they aren't appropriate (and becoming overly abstract in the name of functonal purity is very much a common flaw in functional programs!) causes that. &gt; Your entire thesis here is that creating the modern equivalent of 1980s imperative spaghetti code by mixing paradigms and conventions and styles in a ad hoc fashion is a good thing. You can trivially write functional code that is like a hojobazillion times harder to trace, comprehend, debug, and maintain than even the worst C code I've seen (pretending momentarily that I've never seen the IOCCC). &gt; Coming from a statically typed purely functional point of view, you sound to me like a madman. When you live in the madhouse, I'm sure everyone sounds like a madman. :p
With respect, why do you want the codebase to be executable with no compile step? What benefits does that give you, and are they worth the inherent redundancy of non-TS JSDoc comments? For what it's worth, ["ts-node"](https://github.com/TypeStrong/ts-node) lets you `require()` TypeScript files directly, which is great for development.
Gotcha. Wasn't sure what the behavior was supposed to be if there were multiple numbers that occur an odd number of times. Seems to work otherwise for both if there's only one number occurring multiple times.
Sorry about the delay. I believe this was the series: https://www.youtube.com/watch?v=k66bOHX8MnY
This is actually a horrible example of reduce. It's incredibly obtuse and specific. It works only because of a number of specifics of the problem. If the problem was sum the even counts, this approach wouldn't even be valid. It's like the problem was stated in a way so people could come up with clever answers.
But why do you disagree? Higher-order functions are very powerful, and allow you to write functional, concise code. I personally never write for loops. Every time I see a for loop, all I can think is "Here come some crazy mutations!" Edit: Yes, I'm generalizing. But from what I've seen in reviewing other people's code, for loops are used when a higher-order function would simply work better.
Well, PS is a game server, so the line between "user" and "developer" is kind of blurry. Users are encouraged to edit the source, so the fact that the `.js` files that users run and the `.js` files that developers write are the same is very important for usability. Users start by cloning the repository and running `./pokemon-showdown` (which runs `npm install --production` and installs only 1 dependency and 2 subdependencies). They can then easily edit the `.js` files in the repository to suit their needs, without needing to do anything else. When they want to go deeper, they can install the full devDependencies and test suite, but that's not necessarily just to run stuff. So, transitioning to TypeScript would require either: 1. a compile step just to run PS, or 2. separate release and development distributions, which would make it harder for users to make changes to the code, which is very common (I don't know any major PS server that leaves the code unchanged) I just looked and typescript doesn't seem to have any npm subdependencies, so depending on compile speed, option #1 might not be that bad, but I asked a lot of my contributors/developers and a lot of them don't really want to learn TypeScript. This is where something like Flow does better since you can still write regular JavaScript and interoperate without a problem.
Just add a comment 
"But, it's isomorphic!" "Hmm, but what does that mean, what does 'isomorphic' mean?" "Well, isomorphic actually means something completely different from whatever this is, different enough that it's not really even good as an analogy." "Ah, uh, ok, great." "Hmm" "Yep." "Why am I talking to myself?"
I've used [The Algorithms and Data Structures](https://smile.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844/ref=sr_1_1?ie=UTF8&amp;qid=1470179612&amp;sr=8-1&amp;keywords=algorithms+and+data+structures) book in a course and definitely provides a lot of insight into various algorithms and their perks but I haven't really used much of its information in actual programming. I think a really good way to kind of look at these kinds of problems from a different perspective is to take an intro online course on some functional language. I mean look at this solution to merge sort in Scheme! https://stackoverflow.com/questions/14656435/mergesort-in-scheme
Judging by the code sample (using `xs` to identify the array), the person who wrote it was likely experienced in Haskell or ML, two functional programming languages. Indeed, learning FP has been the single largest source of efficient and robust algorithms and techniques for me. Writing functional code requires a mindset that analyzes a problem in terms of its mathematical and structural properties, and such things like the xor technique will come to mind much more naturally. Many functional techniques can be used in Javascript with the use of lambdas, and Array.prototype.map/reduce/filter makes lots of functional list computations readily available, thus making it standard and commonplace. Learning and playing with a language like Haskell will get you pretty far.
After sitting here staring at it, then finding my computer and fucking with it in repl until I understood, I came to the same conclusion. I'm glad to have learned something but it doesn't seem very widely applicable. 
I published a reducer library for redux! Check it out here http://reducify.mediadrake.com
To download from a src you could use something like this: function downloadFile(path, cb) { var client = new XMLHttpRequest(); client.open('GET', path); client.onreadystatechange = function processFile() { var DONE = 4; // readyState 4 means the request is done. var OK = 200; // status 200 is a successful return. if (client.readyState === DONE) { if (client.status === OK) { cb(null, client.responseText); } else { cb(client.status, null); console.log('Error: ' + client.status); // An error occurred during the request. } } } client.send(); } You can look up how to get all of the script tags and iterate through them accessing each's src property. You also need to keep in mind downloading like this is asynchronous. 
If the script tag is applied to the page you'd essentially be downloading it twice. You're better off using a minifier and webpack. Please google webpack and a minifier (uglify).
Best I could do off the top of my head: http://codepen.io/anon/pen/OXokym You have to manually copy and paste the contents of the iframe... I can't figure out how to get in there programatically. :/
&gt;By the way, do you think that I could benefit from passing a course/reading a book on algorithms? It's impossible to say - different people learn differently. Personally I can read an entire book cover to cover and not learn a thing. I have to actually build something useful and learn by encountering and solving problems along the way. This is important to me because just reading about manufactured problems and their solutions will not have an impact on me. But there are plenty of people out there that benefit greatly from reading books, and that's fine too. 
It's likely a cross-domain issue.
You said at the beginning you're trying to download script tags. Those have JavaScript in them. Perhaps if you posted a full example of what you have and what you want in a codepen then other people would be able to help you better.
Yeah, and script tags don't have to include javascript code, that's why you can specify the type of the script. Breaking it down, I have huge text files, and I want to load them into strings to use inside the code. What's the best way to do that?
make a library of your functions using npmjs.com
This is such a good answer, thank you! This is exactly how I get proficient in a new framework or library. I read through the documentation, at least familiarize myself with the API, then when I encounter a problem, I go "I think there's already a method for that..." And in most cases I can recall it. Then after I use it, it's stuck in my head. The same can be applied to programming languages! 
Do you have an example of the top and bottom of the file? If it is a JS file, there may be some trace of it on window somewhere - if you can find a variable name, `JSON.stringify(varName)` will return a string representation of the variable... and if there's a function, you can call `toString` on the function to get its inner contents. If you don't need to load the shaders into the page and you are only interested in text processing, then loading it through an XHR seems the most sane approach. Of course, 10mb text file is going to take some time -- but it's about the same if it's included in a script tag (or even inline with the page -- it's just moving the download to someplace else with slight differences in overhead for separate http requests), so it'll be the same switching from one to the other. In fact, if the HTTP headers are set right (and sometimes even if they aren't) the browser will recognize you are serving the same file and cache it so the 2nd one won't hit the network (and after subsequent reloads, won't hit network either)
Interesting that merge sort is faster than Array.prototype.sort. I thought Mozilla was using a pretty fancy Merge sort and V8 uses quicksort (insertion sort for small arrays). I guess it could be the comparator slowing it down. I wrote a library a while back that compared running times and I could get a few sorts to outperform. Things like what you're sorting and the size of the array definitely matter. Insertion sort was mostly faster for small arrays, but [Android's Dual Pivot Quicksort with a Sorting Network](https://github.com/mtraynham/sort.js/blob/master/lib/quicksort/sortingNetworkDualPivotQuicksort.js) always out performed for larger arrays. I allowed comparison operations though... Although, I will say, I never did investigate if the size of my functions were causing optimization issues with the JIT compiler. Here's character arrays (`['a', 'z', 'r'...]`) of length 1000. (Node 6.3.1, 2.2 GHz i7) [23:46:31] Running 'Bench Character Large' from benchCharacterLarge.js ... [23:46:37] Array.prototype.sort x 6,440 ops/sec ±1.83% (90 runs sampled) [23:46:42] bubbleSort x 92.63 ops/sec ±1.41% (71 runs sampled) [23:46:53] heapSort x 2,065 ops/sec ±1.11% (90 runs sampled) [23:46:58] insertionSort x 272 ops/sec ±1.42% (89 runs sampled) [23:47:04] mergeSort x 687 ops/sec ±2.21% (89 runs sampled) [23:47:09] mergeSortInplace x 99.62 ops/sec ±1.49% (75 runs sampled) [23:47:15] sortingNetworkDualPivotQuicksort x 7,623 ops/sec ±1.52% (91 runs sampled) [23:47:20] dualPivotQuicksort x 3,667 ops/sec ±1.33% (91 runs sampled) [23:47:25] quicksort x 909 ops/sec ±0.73% (95 runs sampled) [23:47:31] quicksortFunctional x 374 ops/sec ±1.12% (89 runs sampled) [23:47:36] quicksortInplace x 3,496 ops/sec ±1.23% (90 runs sampled) [23:47:42] selectionSort x 104 ops/sec ±1.25% (78 runs sampled) [23:47:42] 'Bench Character Large' from benchCharacterLarge.js (passed: 13, failed: 0) [23:47:42] Passed: [23:47:42] 'sortingNetworkDualPivotQuicksort' is etalon [23:47:42] 'Array.prototype.sort' at 1.18x slower [23:47:42] 'dualPivotQuicksort' at 2.08x slower [23:47:42] 'quicksortInplace' at 2.18x slower [23:47:42] 'heapSort' at 3.69x slower [23:47:42] 'quicksort' at 8.39x slower [23:47:42] 'mergeSort' at 11.10x slower [23:47:42] 'quicksortFunctional' at 20.40x slower [23:47:42] 'insertionSort' at 28.02x slower [23:47:42] 'selectionSort' at 73.48x slower [23:47:42] 'mergeSortInplace' at 76.52x slower [23:47:42] 'bubbleSort' at 82.30x slower 
Back in the day we had to. In any case, when you call something like `$('#myModal').modal(options)`, you need to do it when `&lt;div id="myModal"&gt;` is available in the DOM. Since Aurelia routes will be composed into the DOM dynamically based on user navigation, we need a way to get Aurelia to tell us when the elements are in the DOM and its safe to instantiate them. That's what this article is about.
I'm not sure what you mean about "like that", as this is standard for ES6 modules. We need `$` for use in the view-model. Semantic-UI doesn't export anything--it's not really written to be used as a module at the moment--but it does expose a bunch of plugins to the jquery object. So having the module loader load the module is sufficient for getting access to the plugins. Hope that helps!
Don't necessarily assume that the more "advanced" solution is better because it's more terse. Programmers today have a habit of assuming that shorter is automatically better (must not make dick joke... must not make dick joke) but it's not always true. Take your example for... err... example. Even if you only know basic programming constructs you can probably follow that code. The one-liner however presumes a lot of knowledge: constants, arrow functions, array methods, what the carrot symbol means. In truth, this isn't the best example to make my point on because this arguably IS better in the single-line form, but even still, you can walk through the logic of the lengthier version without (as many) assumptions. It's less of a black box essentially, which arguably makes it more accessible to less experienced developers, which unfortunately is a consideration in modern professional development. Basically, write the code that seems most expressive of what you're trying to do and don't worry about terseness and don't worry about advanced functions. If 10 lines of clear, basic logic seems easier to understand than one or two "clever" lines of code then don't sweat writing "basic" code. Other developers will, generally, thank you for it. 
Don't even start with the XOR solution. That is a clever trick, but real life problems are rarely solvable this way with a one-liner. Edit* I wouldn't even touch Haskell or JavaScript books people might recommend you in this thread, first iterate on your own solution and understand how to make it better (hint: try not sorting). Write it in different ways and time your code with larger arrays, see what happens. Don't bother with one-liners, if codewars recommends this solution, start with a beginner's website. Edit** Removed entire part about the runtime, as /u/Reashu made me realize I misread the code.
Sorry, what I meant to say that when you map over an array, you get an array back. You can't get a set or an object back. If you map over an object, you get an object back. So on and so forth. You can definitely map over an array of strings and get an array of objects or DOM Nodes back.
I'd use lodash and do something like this: _(folders) .flatMap(folder =&gt; folder.getFiles()) .find(file =&gt; file.config === me.config) .value()
/u/alakazan is running on 1.8 and so is the playground. If you're running on 2.0 beta, that would explain it.
Awesome, here it comes: + Allow to programatically change location. Currently I have the following workaround (I'm using hashbangs), it would be nice to have standard way (please use similar API to [react-router's push](https://github.com/reactjs/react-router/blob/master/docs/API.md#pushpathorloc) instead of routeTo) import { browserHistory } from 'inferno-router' browserHistory.push = function({ pathname }) { location.hash = '#!' + pathname } + memoryHistory (so we can use it with Electron / nw.js) + onEnter(nextState, callback) + onChange(prevState, nextState, callback?) + onLeave(prevState, callback) Thanks man ! 
I've written about [a similar topic](http://aeflash.com/2014-11/avoid-foreach.html) in the past. `reduce` is just the gateway.
lol yea
You are right, both functions don't work properly when there are two numbers in the array that satisfy the condition. But this wasn't required by the original task according to which there's only one such number. 
Interesting. When I do math ( I am studying math and statistics) I cannot listen to any music at all. Because I need fully focus on math calculation:) And I found that while learning programming (I just started it this summer) some techno music really helps me to move on. For example when I get stuck with just a syntax mistakes for long, and the music does relieve my anxiety.
Ouch. But we've all been there, I guess.
I'm going to reach out to someone I know at JetBrains to discuss this in greater detail
Aurelia is an excellent framework. I've been using to build a SPA Wordpress plugin and it's been a joy to use so far.
It would be really helpful if you could slim this testcase down. I'm puzzled by this one line: result.should.exist; Since that's not a Sinon.js type assertion. Are you using another assertion library? What happens if you remove that line?
In general, the native algorithms (in any language, really) will usually have some subtle modifications to the algorithm you'd find in a textbook because the goal is to get the algorithm to be performant with _all_ different kinds of datasets and datasizes. Some modifications may make the algorithm a bit less performant with certain datasets but that's ok, because the very same modifications make the algorithm more performant for another dataset. You don't want an algorithm that's really fast for some datasets but really slow for others, you want an algorithm that's at an acceptable performance level across all datasets. Sure, the question of why is "my" algorithm faster than the native one for this specific dataset is interesting, but it doesn't mean it's a better algorithm than the native one by any means. 
Can't break an iteration which you can in a for loop
https://www.youtube.com/user/Liquicity Is a YouTube channel I listen very frequently to when programming. I also like modern classical music by Einaudi.
One argument against higher order functions, and in favour of a plain for loop, is that invoking functions is typically much, much slower. Recently I wrote a function that merged arrays by key, and the functional approach (.map, .filter, .find etc) could run over 10k items in 1710.990ms. The for loop equivalent was only 15.037ms.
How do you render a list of stuff then? Look at this example. // Out initial state const state = { visibilityFilter: 'SHOW_ALL', todos: [ { text: 'Consider using Redux', completed: true, }, { text: 'Keep all state in a single tree', completed: false } ] } // Returning a new state const newState = Object.assign({}, state, { todos: state.todos.map((todo, index) =&gt; { if (index === 0) { return Object.assign({}, todo, { completed: true }); } return todo; }) }); // Immutable.js to the rescue! const iState = Immutable.fromJS(state); // returns a new object const iState2 = iState1.setIn(['todos', 0, 'completed'], true); Edit: can't do backtick at mobile, will fix formatting when I can 
Where???
A lot of people recommends [Eloquent Javascript](http://eloquentjavascript.net/) (I read just few pages, it *seems* to be good). There is a guy who posted on /r/learnprogramming about a nice [JavaScript teaching project](https://www.reddit.com/r/learnprogramming/comments/4syftj/hey_rlearnprogramming_my_names_tim_and_i_want_to/), which I find very cool once you grasp the basics of JavaScript and web technologies. Also [free books](http://jsbooks.revolunet.com/)!
Ok... take me through this. The "live" copy of `fillPdf.generatePdf()` takes a **callback**. You've overridden this with a mocked function, which **returns** an object, but doesn't call any provided callback. That object (`mockChain`) that's returned from the mock has a single member, called `exec()` (that appears to be the function that's supposed to call the callback passed to the `fillPdf.generatePdf()` mock)... only nothing that I can see ever receives the copy of `mockChain` returned from the `fillPdf.generatePdf()` mock, and hence nothing ever calls its `.exec()` member. Is there some deep magic going on behind the scenes with sinon.stub() that converts specially-formatted return objects into invoked callbacks, or have you fundamentally misunderstood the difference between a *returned value* and a *called callback*?
I would connect to the todos at the top level components and pass the list down using props. If the todos have changed I want the components that display them to re-render. I would set the todo item via a prop for text and a prop for completed and on shouldComponentUpdate, a shallow check would be enough. I feel like I'm missing something fundamental. Thanks for your reply :)
Trust me, you will LOVE MPJ! 
Hi /u/contrastweb, this post was removed because /r/javascript is not a job board.
I'm not 100% sure what you're asking. If you just want getData to download a JSON file via XMLHttpRequest and parse it, you can pass a callback to getData: function getData(callback) { // existing code... data = JSON.parse(xhttp.responseText); callback(data); Then you can define what happens to that data by passing a function to getData at the bottom of your script: getData(function (data) { // getData will download and parse the JSON file, then call this function and supply "data" as the first param // do whatever with data }); So getData will download and parse the JSON file, then call the function you supply with the result. Does that help? Two other things: you're using data.map, but you're not transforming the data array to anything, so I'd probably go with data.forEach. It will work with map though. you're declaring var data at the top of the script, but data is only used within getData. So better to define it in getData.
Yeah, this is a bit ridiculous. If you are pulling ten million unsorted rows of a datastore often enough that this is relevant, you might want to reconsider your over all architecture. 
Not only that but in a language like javascript, native sorting algorithms need to handle a crazy amount of edge cases. It's the same reason why something like lodash's forEach is much faster than the native one. They aren't 100% compatible, but often you know you aren't going to do the crazy thing that the native one needs to guard against ever iteration.
What you're doing is calling a function. A callback is a function passed into another function as an argument with the purpose of being called after some asynchronous action is done.
Making your coworkers laugh 
Anyone else listen to rock when programming?
None? It's a gimmick. Will take the sum of elements in miliseconds time to sort the array.
wow this one is really cool!
I am sure there are but not me :P rock is for shower time for me :)
This isn't really to show "wow node is slower" but rather to highlight that regular JS sort is much much slower than commonly taught merge sort and Quicksort algs
again, you are missing the point by a landslide. the issue isnt really about JS being slow, but rather that native array sort is slower than already known algorithms 
Remember all those articles about writing "clever" code and why you shouldn't? Or the articles about reducing cognitive load? That one liner is clever. It took me less than a minute to mentally parse your code. It took 3-4 times that to mentally parse the one liner. I don't want to encounter code like the one liner in a real codebase. I'd tell coworkers to rewrite it or explicitly explain what the function does in a chunky comment during a code review. All the other advice here is good, I just wanted to say this explicitly in case you were still feeling out matched. By all means write clever code in your personal projects. But please don't do that in a collaborative codebase. Use the higher order functions (a lot, constantly). In fact, if you're writing javascript and you're trying to get better at the higher order functions, rewrite every loop with one just as practice. Map and reduce are your bread and butter. In almost every javascript project you'll also likely have access to lodash or underscore. Start learning one of them by going through the functions when you have to solve a problem to find one that fits!
I work with ReactJS. I've worked with Ember. And I gotta say, neither is overtly difficult once you understand the entire picture. Maybe your team should spend more time reading docs and tutorials instead of "tricking" the framework into accomplishing what you want. I understand that we all have hard deadlines and we're all the busiest people in our own little worlds, but it sounds like that would really benefit your work environment. 
Needs a more convincing argument. I haven't used react and am prepared to be convinced. But that was a useless rant.
It isn't a typical link and you can't paste it. What it does is call a function in the JavaScript of the website its on. Copying the link won't do anything useful. 
Completely disagree, my experience has been that once you get into the right mindset and follow the framework's conventions, development speeds up and things get done a lot faster. Also, you better supply facts if you're gonna call React's performance 'abysmal', considering that's one of their selling points.
`__doPostBack` is a JavaScript function added to pages written in ASP.NET. It initiates a full page postback triggered by the control with the client ID `ctl00$ContentPlaceHolder1$Label2` (the event target). The second argument to the function is the event argument (in your case, an empty string). It's not just a piece of JavaScript code that can be copy/pasted into any old browser window. It needs to be run in the context of the web page from which you took it. 
The code samples error out in both Firefox and Safari, so I am going to make the blanket guess this is likely some V8-specific optimization silliness. That said... the custom solutions might be faster for V8, but that doesn't mean native array sort is slower (the web **and JavaScript** are more than V8).
To expand this and give the OP a bare-bones example of what you mean. &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Simple Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function __doPostBack(id, thing) { // do things here... } &lt;/script&gt; &lt;button onclick="javascript:__doPostBack('ctl00$ContentPlaceHolder1$Label2','')"&gt;Click Me!&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; What that string is doing is telling the browser that when the button is clicked there should be a function called `__doPostBack` in the document context that can be called and used to do the work of loading up the link information.
Google Apps Script uses entirely ECMA 1.6 Javascript, with a few other 1.7 and 1.8 features.
It is `javascript` URI scheme, which is a non-standard URI scheme. It doesn't work outside of web browsers even if the executing software provides JavaScript support. This is oooooooold. It only still exists for the convenience of writing bookmarklets. Any time you see the javascript URI scheme just assume its malicious.
Is the JavaScript executing incorrectly? When it executes do things break or do you get unexpected results? The answer is likely, no, because the JavaScript isn't there at all. It is denied by standard security conventions in the browser.
The sum? Assuming it's async, it'll take however-long the largest item is in milliseconds (plus some overhead), surely?
Hi guys. This is a reference implementation of shadow volumes that [I](https://github.com/Erkaman) implemented with the help of [Mikola Lysenko](https://github.com/mikolalysenko). This demo was implemented to demonstrate the stencil buffer manipulation features of our WebGL Framework [regl](https://github.com/mikolalysenko/regl) I provide a [video here](https://www.youtube.com/watch?v=oO0LJWy5COg), in case the demo won't run. Since these shadows are shadow volumes, there are no jaggies whatsoever. Even if you zoom them in, they remain crisp and clear. That is one advantage of shadow volumes compared with shadow maps, but it is also the only real advantage of the method I can come up; I personally think shadow volumes is a pretty terrible technique. Drawing the shadow silhouette eats fill-rate, constructing the silhouette can be very CPU-intensive, and the technique in general is quite tricky to implement, compared with shadow mapping. Personally, I can't find a single reason that a sane person would use this technique nowadays. But some may disagree with me, I suppose... I mainly implemented this demo to provide a reference implementation of shadow volumes. In particular, this is an implementation of [Carmack's Reverse](https://en.wikipedia.org/wiki/Shadow_volume#Depth_fail), or depth fail, as some people like to call it. My implementation follows the description on Wikipedia pretty closely. I provide the source code [here](https://github.com/mikolalysenko/regl/blob/gh-pages/example/shadow-volume.js). I want others to be able to learn from this code how shadow volumes can be implemented, so I have littered the code with comments. I hope that at least someone will find it interesting. 
Do you even understand the problem that I am positing here? This tool that I'm talking about is a way to run Javascript server-side, and has nothing to do with the browser...
The absurdity of YOUR comment shows that you think adding a HUGE amount of complexity for a simple problem makes it a "solution" or "proof" of your ridiculous claims. State is state, no matter what stupid noises you make, little moron. You think you got rid of state by wrapping it? LOL.
Your link 404s. I think you mean "java*script*" instead of "java". This isn't really the right community for posting "pls help me debug my random bit of code" requests unless you have a really interesting bit of code - try r/LearnJavascript or somewhere similar.
&gt; The current darlings of the JavaScript world are React and Redux. I don't care. If you don't either skip to the bottom half of the article. The rest of the article is about to make some really good points, but... doesn't quite get there. My opinion is that JavaScript expressive I am not locked into OOP (or other convention) stupidity. I can form my own architectures as imperatively as possible around immediately focused upon separation of concerns. Once the application gets big and I realize its not as well separated as I earlier thought refactoring can be fairly light.
A slightly fuller example, to show how it can take arrays and concat them when calling through .. function operate(f, a, ...b) { return (...xs) =&gt; { return f.apply(a, b.concat(xs)); }; } function multiple6(a, b, c, d, e, f) { console.log('Called with', a, b, c, d, e, f); return a * b * c * d * e * f; } var multiplyTwoArgsByFactorial4 = operate(multiple6, null, 1, 2, 3, 4); var r = multiplyTwoArgsByFactorial4(10, 5); console.log(r);
I'd be more considered with ease of understanding than line numbers of code. So for example, if someone new to the code looks at the immutable reducer, you'll need to mentally unpack the statement to understand the state shape. However, with the destructuring example, a simple glance shows what the state looks like and which parts we are modifying. I personally prefer that over having to read a bunch of strings in a function call, but maybe people who use immutable.js a lot don't have that issue. 
That's true, but it's also the same the first time you use Redux, React, Lodash etc, you have to learn the library. 
I am genuinely interested, what can I use this for? 
Can you point me to a more fundamental js tutorial, like starting by soldering your own transistors and stuff. 
I don't think you understand. I want to be able to define a variable in foo and be able to access it in the scope of main
HILARIOUS!!!!
I, too, enjoy bringing the entire grocery store to the table when I want some mustard for my hot dog.
You could use `window.location.reload();` in the reset button event handler..
i recommend rollup
http://chaijs.com/api/bdd/
It's very useful when you are using folder = module structure, only exporting from index.js So when you add another inner nodule this will collect them to the root file and import+export all those modules for you
I'm sorry. Too stupid to be taken seriously. Obvious troll
Some examples: [1] // =&gt; 1 (odd number of ones, no other numbers) [1, 1, 2] // =&gt; 2 (even number of ones, odd number of twos) [1, 1, 3, 5, 5] // =&gt; 3 (even number of ones and fives, odd number of threes) [1, 2, 1, 2, 1] // =&gt; 1 (even number of twos, odd number of ones) [1, 1, 2, 2] // =&gt; undefined behavior (no number with an odd number of occurrences) [1, 2] // =&gt; undefined behavior (more than one number with an odd number of occurrences)
Ah yes, my bad - it will take the largest number of miliseconds.
Wow I had this same conversation yesterday. Let me just say: you are not the problem.
Partially that, but also the `i+=rep` part in the outer loop.
unfortunately this problem sounds like the generic interview question that you're supposed to sum all the numbers and subtract from the sum of sequence of 1...100, which is given by formula (100*101/2) What test cases did you try for your own solution. Can you try with `[1,2,6,7,3,4,8,9,10]` where 5 is missing?
Ahh missed that part, much efficient than what I thought it is then. Yeah the algorithm is O(NlogN) then. Thanks for proving me wrong. I still think sorting was unnecessary though.
Assuming then you are growing your own veggies and baking your own bread?
Well get used to it. Why learn JS if you can do TS? Why learn C if you can straight into C#?
Thank you! That was very helpful
medium.com : because everything is either unconditionally perfect or terrible
 I think he is getting all the downvotes, because the first part of the course, is a break down of es5. It seems like you already need to have a fundamental js understanding.
No, why would I want to use TS ever. Honestly. TS fixes the wrong problem with javascript. You don't structure a prototypal language like javascript. THAT IS ITS STRENGTH. class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return "Hello, " + this.greeting; } } var greeter = new Greeter("world"); var greetWorld = greeter.greet; alert(greetWorld()); //undefined The FUCK is this shit. That's not strongly typed. That's not what 'this' should be. TS fixed nothing. ES5/ES6 are better than ever. There is no reason NOT to default to JS. Comparing C and C# are completely different
There's definitely a distinction between "managing your data in an immutable fashion", and "using Immutable.js types to store your data". There's a great article laying out the overall concepts at http://reactkungfu.com/2015/08/pros-and-cons-of-using-immutability-with-react-js/ , and I have a number of other articles on managing data immutably at https://github.com/markerikson/react-redux-links/blob/master/immutable-data.md. Finally, I wrote a comment a few weeks ago [laying out my reasons against using Immutable.js](https://www.reddit.com/r/javascript/comments/4rcqpx/dan_abramov_redux_is_not_an_architecture_or/d51g4k4?context=3).
I mean literally what I wrote, which also has little to do with speed of JS, but that this is a typical artifical scenario that pops up a few times a year that is constructed as a show off (by someone very smart™) that would never happen in a real world application as made obvious by the ridiculous number of rows to be sorted to have a measurable difference. In any sensible situation, the generic sort may not not be the fastest, but it is fast enough. And if you have a fringe situation, it is a exactly a fringe case where you batch through a massive dataset where the extra time consumed does not matter, or you should really consider a different approach to what you are trying to achieve. So, in conclusion; The landslide is a storm in a glass of water and these benchmarks mean nothing except work their own universe. And they are not really news to anyone. 
What? 
You must be great explaining yourself at work.
hex.map((e) =&gt; parseInt(e,16)); ES2015 ftw! Edit: Damn HTML escaping! 
* grunt/gulp - Still work. I've never found them especially useful and use webpack with npm scripts as my build system. If you're thinking about learning webpack and can wait, hold off. There's a lot of movement around webpack2 and making it easier to configure and whatnot. * Coffeescript - Most of the good parts got rolled into ES6. I wouldn't start a new project in it. * Typescript continues to increase in popularity * bower - Everybody just uses npm now * Promises - They're part of the standard and will become increasingly prevelant in browser APIs. * MEAN - No comment. I mostly avoid server side javascript. You'll want to learn ES6. The new features result in code that looks quite a bit different than es5 even if it doesn't work too differently. Otherwise, it's the normal framework and technique churn.
Wait, what? I don't understand your code snippet. What's wrong with it?
Nice framework. On 4k screen mouse movement is very slow, it shouldn't depend on resolution
Oh, I see. Well, that's not really unexpected though. What I didn't understand is what does this have to do with strong typing or what problem would that outcome solve.
Said every Java/Python/C# developer...
Thank goodness I didn't fall into those pits of despair.
You now have to create new instances of it at least 8 times apparently: https://github.com/petkaantonov/bluebird/blob/b8e580c52504457f618018c5e434abb72548a3b8/src/util.js#L201-L213
I'm starting to lean the same way. For one reason mostly: it is **so** much easier to eyeball Vue, even Angular really, and see what it's doing.
Javascript has matured a lot in just a few years. ES6 is the new rage. What was really cool about Coffeescript and the likes is now possible natively. There's also some new APIs (like [fetch](https://developer.mozilla.org/en/docs/Web/API/Fetch_API)), which will make your life so much easier. Browsers today have a pretty good JS support (Microsoft officially [killed support for IE10 and under](https://www.microsoft.com/en-us/WindowsForBusiness/End-of-IE-support)!), but you can use something like [Babel](https://babeljs.io/) to compile your ES6 code down to ES5. It should be easy for you to catch up, as there are several good resources online. I recently invested in [ES6 for everyone](https://es6.io/), which is a course by Wes Bos, that you can just power through or just use as an resource. As for MEAN, it's still a thing, but it has also evolved. Angular is still very popular, and is also releasing a v2.0 version, which is completely reworked. However, you should definitely look up on [React](https://code.facebook.com/projects/176988925806765/react/) - a framework by Facebook, which focuses on super snappy DOM updates. It's basically the "thing" right now, like Angular was a few years ago. Once again, I can recommend a course by Wes Bos called [React for Beginners](https://reactforbeginners.com/). It's a course where you build a small real-life project.
this works perfectly how I would expect it in c# or any other compiled language I can think of. Edit: Kminardo. Please see my reply to eigth later in this chain.
 let s = ''; for(let c = 0x21; c &lt; 0x7F; c++) { s += String.fromCharCode(c); } console.log(s); https://en.wikipedia.org/wiki/ASCII#Printable_characters Do you mean something like that?
If somethign is strongly typed, each type of data, is predefined. includnig objects. The this keyword should relate to the current instance of an object. If you truly wanted Tscript to be strongly typed, this should make sense in context to the current object.. "an advantage of strong data typing is that it imposes a rigorous set of rules on a programmer and thus guarantees a certain consistency of results." So Tscript is failing in it's most fundamental attempts in this scenario. And there are many more Edit: I hope you can see the comment by Kminardo in his edit. I think there is a little bit of bias here from the tools and languages you are accustomed to. I have absolutely no confusion how 'this' should work on the fundamental level of the object instance. Coming to Javascript, I liked this gotcha on the this keyword since technically the object instance was not the Greeter class. The problem I have is with TypeScript not matching what it is attempting to do. Bound the Object to be strongly typed. 
Right, it does work how you would expect it to in c# etc, but "this" in vanilla JS is inconsistent with those compiled languages in many cases. I just wasn't sure if that was another piece of your complaint :)
You mean the hotdog that consists of 3 different animal byproducts, 24 spices, and countless other ingredients, condensed in one easy to consume package? 
again see my reply to eighth.
And of course, in JavaScript... an Array is a single value, too. ;) Array.prototype.map = function (array, predicate) { return array.reduce((newArray, value) =&gt; newArray.push(predicate(value)) , []); }; This can be helpful in other ways, e.g. we want to combine certain values in our array, or flatten a multi-dimensional array, etc.
So String.fromCharCode() converts octal numbers into a string? If so you solved it! And I assume there are 127 characters? Anyway thanks!
This isn't a TS issue, that is how javascript works. 
While I agree in principle with the argument, a framework is a pretty essential for high volume, high data delivered apps. I'm using a front end framework every day for my job but the logic and design patterns stay the same. I just look at it like another layer of abstraction. Nothing wrong with that per se. Edit: just seeing all the other replies and looool
Good thing my career doesn't rely on me cranking out crap for spare change.
Oh alright lol. Which one do you recommend me using for what I'm trying to achieve?
But, based on this thread, people don't seem to like communicating with you, so there's that.
And I should give a fuck, why again?
Sure, no worries. I think you added complexity to the problem by worrying about octal. You don't need octal anything for this. I provided a way to get the remaining characters from the Latin 1 character list. There are 191 characters.
You can be whatever kind of human you want.
Great! I thought the way of converting numbers into characters was called octal but that's clear now. I saw the Latin 1 character list, but to make it a bit more encrypted I would also like to add characters like this: àáâäæãåā. How would I go about that?
 var chars = ''; for (var i = 32; i &lt; 127; i++) { chars += String.fromCharCode(i); } for (var i = 160; i &lt; 256; i++) { chars += String.fromCharCode(i); }
If you are only passing primitives as props you won't see the need for Immutability. Once you start using multi dimensional arrays and wonder why your component won't update you'll see the problem. You don't need to use Immutable.js but Jr. Devs may get quagmired trying to debug a problem that that library would have forced them to understand
Paste that code in your browser.
Yeah I know but I'd rather all have it visible all the time but I already found it :P http://www.ascii.cl/htmlcodes.htm Thanks a lot man! :D
forEach is handling a function each time it loops, so it scopes, hoists, etc. At the surface, both seem to do the same thing, but they're subtly different and depending on your use case either will often be significantly more appropriate than the other. Here's a really good read on it: http://stackoverflow.com/questions/9329446/for-each-over-an-array-in-javascript.
Is the script **bound** to the form or to the sheet? Since you want your script to run when someone opens the form it has to work with the onOpen Trigger. This trigger is only available if the script is bound to the form. [Read more here](https://developers.google.com/apps-script/guides/triggers/) 
Can you give me an example of that? I'm not sure what you mean that could possibly be faster.
For-in deals with it quite well... What else might I do?
Here's a SO answer. http://stackoverflow.com/questions/13488751/why-is-for-in-slow-in-javascript jsperf seems to be down, so can't link you to anything.
;) It was in the first link I sent you at the bottom. Didn't look at it?
On a side note, the Babel site itself is really cool. Who did the logo and the site design?
Fair enough.
I agree. There are benchmarks. http://elm-lang.org/blog/blazing-fast-html Its neither fastest or slowest. though I think he means relative to vanilla js. not exactly headline news that abstraction isn’t free. 
You've already passed the point where flat files is the simpler solution.
/u/achen2345 gave you the right response. It's scalable, and it's easy to maintain; however, here's another option to show you alternatives depending on where you're trying to use it. (The KISS option). //Merge the space now. var p = ["big boy: "+ large_pizza, "small boy: " + medium_pizza, "chop: " + small_pizza] //Manipulate the element without messing with the DOM. var result = document.getElementById('result'); for (var i = 1; i &lt; 4; i++){ result.innerHTML+="&lt;h"+i+"&gt;"+p[i-1]+"&lt;/h"+i+"&gt;"; } I wouldn't use this in production unless I was working on something arcane, but you did ask for opinions. 
Stop making things sound delicious.
Libraries like prototype made devs paranoid. Perhaps you'll eventually run into a library with a similar approach.
Part of it is also about having a safety net against shooting yourself (or others on your team) in the foot. You say "if the todos have changed I want the components that display them to re-render". Without Immutable, it's common for junior devs to *accidentally* write a state-mutating function (reducer) that mutates state deeply without updating it's parent reference... eg. You can see why someone would be tempted to write a reducer that does something like `todos[i].title = "newTitle"`, which wouldn't change the `todos` reference and wouldn't get re-rendered. And in bigger codebases with more complicated state trees, it can be easy for a bug like this to pass code review and go unnoticed for awhile. With Immutable, you can be confident that, if any part of the state changes, its parent object(s)'s references will change - because that's the *only* possible way to "mutate" your state. This allows you to sprinkle *PureRender* on all of your app components and to sleep soundly at night knowing you got a solid performance bonus out of the deal without introducing any potential bugs. Note, however, that there is an inherent performance hit involved in Immutable "mutation" vs. using native arrays and objects. If you are doing something like changing a few elements in a really long (5000+) array several times per second, Immutable is going to be significantly slower than deep mutation + a clever custom `shouldComponentUpdate`. ie. Don't write a particle system in Immutable. But shit man, don't write a particle system in React either :) For most normal-sized apps this hit is pretty negligible compared to the gains of `PureRender`ing all the things. It's really up to you though, don't feel pressured into using it because it's hip. I use [React Immutability Helpers](https://facebook.github.io/react/docs/update.html) with plain old objects - it feels like a good middle ground. This works well with my small team at work, as long as we follow the simple rule of "only the (immutability helper) update function is allowed to modify state". We get most of the same benefits as Immutable, with the downside that the safety net isn't quite as airtight, but with the upsides of the simplicity of native objects/arrays and still being able to use things like `lodash`.
To be honest from your line of questioning you seem like someone who is very new to this. With that said, I would recommend learning JavaScript from this online book. It's very thorough and starts at the fundamentals and will also teach you the two other crucial technologies of the web, HTML and CSS. http://eloquentjavascript.net/
not really sure what you mean by "is there a web version" but I like https://www.npmjs.com/package/crojsdoc, it produced really useful documentation that actually looks good. 
what version of IE are you using? all of that should work as far back as IE7. all bets are off on IE &lt;=6 though.
Internet explorer 11. It doesn't click the button on page load. If I click the button manually, it works 
How is for (let val of arr) { console.log(val) } more readable than arr.forEach(val =&gt; { console.log(val) }) ? I agree with your other points.
Well you're a cynic 
Can we start calling them WebExtensions, instead of Chrome Extensions? They work in Firefox too(Not sure about Opera and Safari), Edge should support them soon enough too.
Thanks OP for the article, I found it very insightful. I'm starting out a career in development but I was curious: what does your background in this industry look like for Amazon to reach out to you directly?
I didn't even notice it was there xD
In Photoshop you can run action
I'm going to be fairly brutal since presumably you wrote it, and hopefully the criticism will be helpful. The article is really badly written, to be honest it barely even makes sense. You start off by talking about elm but just make broad sweeping statements with no justification or reasoning. Why is Elm better? It's silly and a cliché to say front end is solved when every couple of years something new will come out that solves the next problem. Lots of people haven't even heard of Elm yet. You start off by talking about a CMS, then you're talking about an ORM. Do you really mean Object Relational Mapper or are you using the terms interchangeably? Because nowhere do you really mention why you're writing an ORM. Maybe it's a good idea that a CMS provides an ORM, but the two aren't synonymous. I felt like the main point of your article was about caching but then you go on to talk about something totally unrelated with insert vs update SQL statements and triggers. What has that got to do with caching? And in any case why would it be a good idea to swap all your update statements for inserts!? Hey and what happened with the caching anyway? If you want people to read your work you're going to need to put a lot more time into improving your writing. A plan before you write will really help because atm it's just a series of totally unrelated paragraphs that aren't written very well.
I've been turning the document name into a string and .replace(/someStrings/i) to select corresponding documents and then running an action and outputting to a conditional location. Because this will happen x amount of times for the images that are being dumped into photoshop, I wanted to be able to iterate over the documents. edit:I will add a close document so there will be less and less docs, so if I could do a: if document.count &gt;0 do () that'd work. It's just the syntax I'm not familiar with.
Just a guess, does IE not like single quotes for attributes? It's not standard. we can rule my guess out by checking that calling alert('hello') works from the body onload Do you have multiple id's on the page? Any other onload events defined, overriding? IE has different override rules for it I know.
Why would I use a library when for-in works exactly as I expected?
Looks good. Suggestion: split out the file lookup/loading. Separate the concerns of parsing configuration from everything else. Users should be able to supply config files as strings, or pick their own config file names, or their own search paths, etc. The best and most flexible way to handle that is to just remove the file loading from the main library interface itself. Continue to provide it as an optional convenience, certainly, but don't force it. I'd also personally allow more explicit use of specific formats. Say, a specific function for each format and a higher-level function that determines format automatically. Likewise, split the path searching function into it's own utility. Then I can compose the features of the library rather than being stuck with the hard-coded behavior.
put the code in a script tag at the bottom of the page
If you're looking for practical experience that can translate to paid work, I'd recommend looking into building some web projects. Play with single page apps, frameworks like React and Angular, and so on. I'd also really encourage you to try and build some projects _without_ a framework. In production a framework is going to save a lot of heartache, but for learning it's really helpful to build all the pieces yourself. (For example, I built my own Flux implementation when I was learning, but I either use Flux or Redux in production.) Good luck!
All you are doing here are "iterating" and "indexing", but there are other operations of the data structure * size/length operation * serialization (i.e. `JSON.stringify(sparse_array)`) * space/time performance of all the operations While you may not need it now, if maintainability is a concern, those would need to be considered as well, as any other developer on your team might come along, and do of those operations and create a bug. 
Thanks for this reply - it really connects the dots for me. I've been too focused on immutability and redux and got a little confused because the way I constructed my reducer code, even if you mutate the state object, it will always return a new object via spread operators. It's really hard to mutate state with this in place. ```return { ...state, ...reducer(state, action) }```. This is what handles that aspect for me. I understand that the deeper states, if arrays or objects would still have the same references. The pages I've been dealing with are simple though, as are the stores, but when it starts getting complex I can see the benefits! I'd not considered it from a junior point of view, I took mutation and equality checks as a given but even with that in mind it can be easy to accidentally mutate state. I still think immutability.js is a bit clunky for what it does. I understand the mechanisms behind it, but it quickly gets cumbersome swapping to and from standard JS objects. I like the look of Reacts Immutability Helpers, I prefer their approach to working with standard objects. Just as a side question - at what point would you notice the need for shouldComponentUpdate? I'm on an established code base and was wondering if it's worth refactoring, or to simply implement it form our current point.
https://github.com/petkaantonov/bluebird/commit/53d23f74c2e62eabd2f0f783df29e1d2182b3d6f Yup, the way v8 optimizes changed after the initial post. That is the new way. Do remember though, you shouldn't need to do this in your day job.
just an update in case anybody is reading this, both of these have been fixed
Ignore libraries and "supersets" (aka Typescript) for starters, get familiar with ES2015 syntax enhancements and google virtual dom. When that's done, you might be able to choose a stack that feels comfortable and fun to work with. 
Enlarge your skills
The saving grace for TS are, well, types. They can help a lot but are very much not part of any JS spec at all. And just because some transpiled code is kind of comprehensible as in not totally obscure, doesn't mean that you actually would want to work with it as your main code base. 
Haha, so true. Javascript is not THAT complicated in and of itself, but in today's job environment, knowing the new standards and what most of the business world is actually using in their stacks is pretty damn important. If you're JUST jumping into Javascript, you should probably focus on tutorials that teach you the basics so you at least have an idea of the general syntax of it and how it interacts with the DOM before jumping into modules and more complicated stuff.
Hey, I've been doing the [FreeCodeCamp](http://www.freecodecamp.com) course and it basically teaches you JavaScript, HTML, and CSS and how they all combine together. The course runs you through a curriculum and they give you a certification for each stage; Front End, Back End, Data Visualisation. You also have mini little projects to do along the way to earn your "certification" which helps you test your knowledge and see how you actually go about making things (build a calculator, weather app, various apps using API(data from other websites) etc). Eventually once you have your certifications they hook you up with a not-for-profit with someone else who is doing the course and you both work as a team to assist the not-for-profit complete a project. It starts off easy but eventually they let go of your hand and it really becomes up to you to find the answers. I'm 3 months in and only just nearing 3/4 of the way through just the Front End section.
Play with tweenmax
That's neat. I would personally like to write an article discussing in-depth the ins and outs of the actual loop - as in treating and responding to the dt value. Fixed timestep vs variable timestep. Timestep clamping possibly combined with multi-sub-step, having a maximum and minimum time per sub-step etc. There's a lot to consider, especially if your game has a variable-time progression, as in "bullet time" or massively accelerated time (while still keeping game accuracy and behaviour stability).
also, for just getting started, you can link chrome (don't know about others) to your filesystem, so that you create a directory with your bootstrap html file and your js files, open it with a file url in chrome, and link them together, so you are editing your code in the browser. 
[This might be worth a reading](https://medium.com/@fagnerbrack/code-smell-92ebb99a62d0) to understand my proposed definition of Code Smell. A definition that should have been clarified early before this whole discussion.
Hey, thanks for the response. The script is bound to the form - I think I have a good idea on how to use the onOpen Trigger; I just don't know how to access and modify the list items on an already-existing question. I wrote a script that creates the question and populates it with the most up to date list, but what I can't figure out is how to write one that will modify an existing question. If I set my current script to run with an onOpen trigger, it would add a new question at the bottom of the form every time the form were opened. Any ideas?
Oh good, it explains the requestAnimationFrame method instead of setInterval, I was ready to come and ramble about how much better raf is ;)
edit: looks like it's addressed in TS 2.0, course you can specify type of "this" on functions now but this just leads to compile time error which would probably be the same as 'use strict', and it still wouldn't change the behavior your expecting as that's not TS's goal. 
Just finished it! Thanks! What I did was make 2 arrays including all characters and then shuffling bot like [this](http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array/12646864#12646864). Then I combined them again. :D
No, you should definitely be using it. It's actually much quicker and works in sync with the browser so it looks better. Now, if you're really concerned about things like this, than the browser might not be the right platform. For real speed, and input latency, the browser is very very good, but nothing beats native code.
anything that's latest and greatest will fall under "modern js", unless i'm misunderstanding your question.
Nothing beats building something. Make a todo list web-app or something.
Thanks for the info. Could have sworn I read some articles that said to avoid it. It was also two years ago so maybe things have changed. Wish I could code in something other than Javascript, but it and Ruby is all I got right now. :P
HOLY SHIT you have no idea how bad I needed this. Thanks!!
This is fucking cool! Can't wait to mess with it.
@great!
Well, this is an article about how to use the "extra features" of CSS frameworks.
Have at least a cursory look at TypeScript, which is a superset of ES2016/2017 (also known as Javascript) with optional static typing. It will help you to obtain a different feel of types and new perspective on the language semantics. Code autocompletion is especially helpful during exploration phase and is available for TypeScript in free, open source editors like Visual Studio Code or Atom with atom-typescript plugin. Course auditing is free and course materials are developed by MS. [Introduction to Typescript](https://www.edx.org/course/introduction-typescript-microsoft-dev201x-1)
By that logic, anytime you use a 3rd party/vendor code, you are paying a tax. 
I also work with the Webpack team and they're working on it
It feels like `getDateBounds` and `getRangeStr` especially could be composed, but I'm not grokking the right pattern for doing so.
&gt;Coffeescript, and typescript was gaining traction Nah since ES6 no one really uses Coffeescript &gt;grunt/gulp ... gulp was becoming more popular than grunt Yeah Gulp is pretty popular, also Webpack(and browserify) is also a new tool which is pretty cool. &gt;MEAN was starting to get popular The mean stack is silly, I mean sure it is ONE possible way to go about development. I honestly think most people are dropping Angular. Express is still the de facto dependency for most node applications, probably since it's already pretty low level. But here are the 2 biggest changes and trends in the JS world: *Functional programming: JS works better as a functional language than an OO language, so most Devs are promoting immutability and modular composition style over structure hierarchy and inheritance. Personally I think it's great, especially for UI since UI is more like widgets and components, and functions now often work more like lists of chained functions. *Components and modular frameworks, I think these days developers like to construct websites like a bunch of relatively independent parts. I like to think of it like how Wall-e can easily switch out and replace parts like his eyes
This man speaks the truth 
kinda like Scala's functional programming. Objects and streams
Lol, so true. Any and all Medium articles are essentially arguments defending a certain position. I still like reading them though,especially the flame bait is always a fun comment read
plnkr.co. Create an account and start building small things. Save your projects and use them as notes. I also recommend you codewars.com where you can do challenges and see most voted solutions.
Hi, author of this article and flow team member here. Let me know if you have any questions!
@crazy!
This is a really interesting problem. I would guess that there's something wrong. This wrong thing is preventing your code from doing the thing you want it to do. If you fix the wrong thing, perhaps by replacing it with the right thing or by adding the missing thing, you may be happier. ...but it's difficult to say given the details provided.
I updated my post. Maybe I need to enter code in a different source file and not in my own?
Jumpsuit is a powerful and extremely efficient Front-end framework &amp; CLI. It is the fastest way to write scalable react/redux apps with the least overhead. - No boilerplate - Dedicated build system - Scaffolding tools - Minimal API - Simple and scalable state management based on redux. You can have it installed and be writing actual code (not setup or boilerplate) in less than 5 minutes. Already have your own build system? Just use the module and ditch you react/redux boilerplate!
Of course I find out about this right after deciding on MobX for our latest project since my coworker was having trouble with Redux. I think this would have saved it, looks great.
One thing I wish would change before service workers become wide spread is the name of the function `ServiceWorkerGlobalScope.skipWaiting()`. When I was becoming familiar with service workers, I found it very unintuitive. To explain what I mean, imagine you are passing a function to handle the listen event: // the ServiceWorkerGlobalScope can be referenced with self self.addEventListener('listen', (event) =&gt; {}); Because you may be performing some asynchronous actions (adding items to cache for example), you will wrap them all in a handy method on event called `waitUntil`: const cacheName = 'coolCacheVersion1'; const items = ['/', '/index.html', '/index.js', '/index.css']; self.addEventListener('install', (event) =&gt; { event.waitUntil( caches.open(cacheName) .then(cache =&gt; cache.addAll(items)) ); }; }); Nothing wrong here. But to get the new service worker to take over, you have to call a method on the service worker called `skipWaiting`. There is nothing wrong with this method name on its own—I later realized it means "don't wait to become the active service worker, go ahead and do it"—but in practice you're calling it within `event.waitUntil`: const cacheName = 'coolCacheVersion2'; const items = ['/', '/index.html', '/index.js', '/index.css']; self.addEventListener('install', (event) =&gt; { event.waitUntil( caches.open(cacheName) .then(cache =&gt; cache.addAll(items)) .then(() =&gt; self.skipWaiting()) ); }; }); For a while I was convinced that I did not want to `skipWaiting` in the middle of `waitUntil`. I know it's my own fault, and I eventually paid enough attention to the docs and realized that it was referring to a different kind of waiting, but I can't help but think there is a better API out there: `makeActive` for example—also symlinking a worker global to self (like window and self in the browser) might make it even more clear: const cacheName = 'coolCacheVersion3'; const items = ['/', '/index.html', '/index.js', '/index.css']; self.addEventListener('install', (event) =&gt; { event.waitUntil( caches.open(cacheName) .then(cache =&gt; cache.addAll(items)) .then(() =&gt; worker.makeActive()) ); }; }); 
`position: sticky` will work some day. Maybe.
Hi there, I'm the author of Selectivity. Feel free to ask me any questions :)
👍
Example only shows until line 11 for me and I can't scroll inside the code box.
Oh hell yes. This is exactly what I have been hoping for. Something to wrap all these disparate parts of the ecosystem in a nice bundle. I'm definitely trying this out.
Cool! The code looks super clean.
Possibly part of react-native. Assuming that some components are omitted.
Actually a typo in the Readme, not sure why they were uppercase. It's fixed now, thanks for pointing it out!
I love this, great job!
JavaScript is the language. Node.js is a runtime. The browser is another runtime. They both implement the same basic language, but expose different objects.
Thanks! Yeah the website actually isn't meant to be live yet, just noticed I left a link in the license section of the readme.
Node lets you write JavaScript that can do extra things like read and write files, which is forbidden for JavaScript in browsers.
Perfect for some April Fools joke ideas!
It might have something to do with the names you're using. 'object' and 'location' sound like words that Javascript might already be using for something, and trying to use them yourself could screw stuff up. Try renaming those two arrays to something else and see if it helps.
I think it's kind of like elm in a sense that actions, reducers, view, model are all put in a same file. Definitely the right way to go.
That was it. Thank you.
Thank you for the response guys! I guess, I will make a JavaScript game to understand more about animations and etc...
That in and of itself is a good idea for a side project...
Why
So you need to update or change the possible choices for a question that already exists. I'm going to answer your question assuming you're an absolute beginner because I have no way of knowing how much you know. This is called 'setting'. You've probably heard of getters and setters in object orientation. Google appscript also uses 'adders' and 'deleters'. It looks like questions in Google appscript are in the class **item**. When the question is a list its in the **class listitem**. So we're looking for the setter in the Listitem class. Find it here: [Listitem documentation](https://developers.google.com/apps-script/reference/forms/list-item#setChoices\(Choice\)) But you can't just use their code that's written there. They're not targeting an existing question they're targeting a new question that they create or instantiate on this line: &gt;var item = form.addListItem(); You need to get the question desired first. So you need a **getter**. But you aren't going to find that getter under the Listitem class. You have to get the question from the Form. So you have to find the getter under the [Form class documentation](https://developers.google.com/apps-script/reference/forms/form#getItemById\(Integer\)). There's two there that apply. 
your first line is wrong you are using brackets instead of parenthesis so var colors isn't being set. So it can't find the length of colors.length. instead of var colors = generateRandomColors[6]; do var colors = generateRandomColors(6);
Still not working :(
Take a web dev pluralsight course that covers both together and see how you feel about them afterwards. My own opinion is js for client side and C# for everything else. Then maybe move on to typescript later if you end up doing a lot of client side work.
In it's current incarnation it does what I'd expect it to. It does send your encoded secret via otpauth protocol to a server listed in a third-party script (could change at any time) also note it pulls in 3 third-party scripts from a git Master/default branch that can be modified at any time. Pulling in those three scripts and any dependencies would be strongly recommended. 
1) basically it boils down to javascript's ignominious origins as a toy language for decorating markup. that perception has persisted even though &amp;mdash; especially since the introduction of google chrome's javascript engine, v8 &amp;mdash; javascript has gone through a major increase in the quality and complexity of programs that can be written with it. 2) yes. nodejs is basically v8 welded to libuv; it's great for I/O bound tasks, but suffers tremendously on CPU-heavy tasks. C# fills that role nicely, plus it has a much more mature security story (with tools like OWIN) than nodejs does. as a real-life example, netflix uses node for its UI and java with spring for its main operations. 3) yes and no; it really depends on your needs. specifically, you'd probably be using a framework like ionic, which spits out an angularized cordova app. developing with ionic can get you up and running in a frankly ridiculous amount of time &amp;mdash; i once wrote a conference app with ionic in three days after knowing angular for about a week. i will say, however, that our shop is currently leveraging xamarin for our heavy-duty apps, though i can't offer much of any feedback on what the benefits or downsides are. either way, both technologies rely on garbage collection, so if you're making an app with larger memory requirements it's likely that both will prove a poor fit. 4) sure. for C# you'd probably want to look at [.net core](https://www.microsoft.com/net/core#windows), which is designed as a modern, lightweight api framework (much of the bulk and cruft of .NET 4.5 and earlier has been stripped away, replaced with a much easier configuration and scaffolding story). for node, there's a variety of solutions for clustering, including their built-in [Cluster](https://nodejs.org/api/cluster.html) module &amp;mdash; though i've heard rumblings about it not scaling as efficiently as third-party solutions. again, depends on your needs.
Why do you use browserfy? Why did you choose that over say webpack?
We're not saying not to learn React or Redux... in fact, you're still using React/JSX as you would normally. Jumpsuit just makes state management, boilerplate, and the build system a little more abstracted so you can get started writing an app quickly rather than spending hours setting it up. &gt; We need more libraries and less frameworks. I have to disagree with this--it's exactly what is causing Javascript fatigue. Too many choices and not enough standards. You can always go that route if it suits you, but most developers just need a good setup so they can get stuff done instead of fretting over choosing libraries and wasting time learning each of them. Just my opinion :)
 return "rbg(" + r + "," + g + "," + b + ")"; This line has a typo, it's **rgb**
Nice catch its still broken though, https://drive.google.com/folderview?id=0B1U0s0OzOocLcFFTVHEyekVrTlU&amp;usp=sharing here are the files
fuck sorry, ITS Working thx man, thanks for all the help guys!!!
Angular != Modern JS
This is a tool that allows for a dynamic module based app architecture in ES6. It allows you to collect exports from a series of folders or files in folders and then manipulate them as an array. For example let's say you have express routes in folders, indexr will automatically update an index file so they can be sent to app.use() within your global app. 
Oh god damn, knowing that my stuff got sent somewhere makes me worried already. From my coding experience my input got sent no where but I guess my experience is worse than I expected it to be. By "Pulling in those three scripts and any dependencies would be strongly recommended" do you mean to use a local copy of them to avoid them being changed in the future to avoid unexpected behaviour?
Yes, yes I do mean local copies of those three &lt;script&gt; tags. The secret *has* to be sent via otpauth. It might help if you were able to divulge what it is you're trying to achieve? It's possible we may be able to come up with a more workable suggestion for you to keep everything in-house. EDIT: If you're looking for a one-time code login solution, they do exist. Google Authenticator seems to be well trusted. I'm not entirely convinced one could do an objectively *better* job securing something like that themselves. Perhaps if you had all servers local to your environment, and you had the experienced networking and security folk to boot. The reality is, Google's own service takes the headaches out of securing the token response. The sending of data also appears only work under a TLS stack.
Thanks
Node has the power of input/output operations. It's a lot like a JavaScript wrapper for a terminal shell. Pretty powerful stuff. Keep in mind that JavaScript is sandboxed in your browser. Node isn't. 
Are they the same syntax wise? So for example if I learn Node.js, will I be able use Javascript right off the bat or do I need to learn syntax differences etc?
Vim for your editing. Try to get started on a framework, then build a game with it, and also do it with vanilla js or jquery, just to keep in mind what's being abstracted. I also recommend nodeschool, it has great JavaScript challenges and you get to learn node. If you're not comfortable with CSS/HTML, practice them for at least a few hours a week. Not too much, but just enough so you don't forget the stuff. 
They in essence are the same, but have a few little differences here and there. Since they run in different environments, they have a few different global objects and methods, but nothing game changing. They both use the V8 engine to compile though. They mostly will look a little different in real world examples, not necessarily syntactically, but functionally, cause they have fairly different roles in an application. Node is usually utilized to set up a server, house middleware that works on database and API queries, and help with socket signaling (in my brief experience). You can also do server side rendering with a node server. 
In my experience I've used a larger spectrum of js syntax in front end programming (less node), but I really like to use node whenever I can, it's just more powerful :) it has quite a bit of interesting methods in its library that aren't in regular js. You might not like it that much. I have a lot friends that don't care for it outside of what shortcuts npm affords them 
No idea what it does
What application do you want to build? Or are you looking for a job?
Why canonical lol?
You can use this.doSomething = function(){}; If you ever want it back, use: delete this.doSomething; Makes total sense, right? Though you'd probably instead want to do the `if(device.tablet)` check in `init`, not within `doSomething`.
Can you elaborate?
If you're coming from an OOP background it is definitely easier to understand.
Cool. The text reminds me of Pi the movie. Modern but retro at the same time. https://www.youtube.com/watch?v=jo18VIoR2xU
Hi /u/sandtana123, it might help if you posted your code.
Yeah, this is a bit too "tinfoil hat" for me. 
For clustering I tend to setup an amqp worker queue and just add more servers as needed.
Odd - the entire thing show sup for me.
Using `Object.create()` allows you to add additional properties even if the base object's constructor doesn't provide a way to add additional properties through its arguments.
I don't know if it's a bug. PHP does that as well. I think it's _we_ who thing the function should return the number of characters, while it returns the number of UTF-16 code units.
FWIW, C# (`"𐐷".Count()`) returns 2 as well. The proper way in C# would be `new StringInfo("𐐷").LengthInTextElements` which returns 1. edit: Of course I only learned about the 2nd thing when posting this. So please everyone who happens to be a coworker of me: Don't use weird emojis in your text! 
JS was intentionally designed to have similarity with Java, both syntactically and in the core library. Java chose UTF-16 (well, I think it was still "UCS-2" at the time) because Unicode only went up to 65,536 code points, so you *could* fit any code point in a single 16-bit value. There were no surrogate pairs so it a nice encoding that covered the whole character set, didn't waste too much memory, and let you quickly index into the string. Then Unicode added the other planes and 16 bits was no longer enough. But Java was stuck. It was already in wide use and specified a 16-bit encoding. Surrogate pairs was the workaround to deal with that. At the time that JS came out, Unicode still actually fit in 16 bits so UTF-16 was a reasonable choice and followed Java, which JS was designed to do. Also, UTF-8 was pretty new at the time.
Well it's the problem that `length` doesn't say what units the length is in. You just ask, "length?". When when someone expects the length in one kind of unit but X programming language has implemented it in another, inevitable problems occur. Unfortunately there are a couple of different relevant 'lengths' that a string could have.
Wow. I can't believe I've never heard of `StringInfo` before! `System.Globalization` just keeps on giving...
Length is the method on array-like objects which returns the number of items in the array. A string is an array of Unicode code points. The behavior is orthogonal and well documented. If a developer is having problems with it, it's because they don't know their tools well enough.
I wonder how much shitty validation was written not knowing this was the case?
I guess I can see why the simplicity of UTF-16 was preferred over UTF-8 especially when indexing a string. Now that surrogate pairs allow UTF-16 to cover all of the Unicode characters, there really isn't a need to switch.
Here's a couple thoughts: 1. "getMovieById" might not need to be a method on any object at all, since it doesn't need access to DataStore's internal, private data. function getMovieById(dataStore, id) { let store = dataStore.getStore(); return store[id]; }; Or, alternatively: function getMovieById(id) { let movieStore = new DataStore("movieStore", { moviesList: StoreType.object, categories: StoreType.array }); let store = movieStore.getStore(); return store[id]; }; 2. If you're only ever doing this once, does it need to be in any kind of function at all? Couldn't you just put the code at the one place it needs to be used?
Yeah, this seems to be pretty standard across programming languages that store strings in UTF-16 internally. It does make me wonder how Python would handle this because it uses its own format for storing characters internally.
Every action on the state is automatically merged into a new copy of the state, so it's built in at the root level of the state object. You still need to handle immutability for deep props, same way you would anywhere else.
I don't know. Wouldn't it be weird if you could use the `String.prototype.codePointAt()` with an index greater than `String.prototype.length`? This seems like the best way to keep the API consistent. No matter what, encodings are always going to be a pain to deal with.
We use [Concrete5](https://www.concrete5.org/). Easily the best tool for our clients but opinions are divided in the development team
The example shown is definitely a condensed example. If you look at the Todo List example in the repo, it's easy to see how you can split up the app into as many bite sized chunks as you want. I personally keep each state (including any async methods that use it) in a single file. I then import all of my states into a single states.js file, and from there import that into my main app.js. Really, you could set it up any way you'd like! :)
Even if you count the number of Unicode codepoints, you're still going to get it wrong; "ﬁ" is a single codepoint, while "รั" is two codepoints, as is "🇺🇸". In fact, counting the number of characters depends on the language - in Hungarian, "dz" is considered a single letter.
So this was a dumbed down example just for posting. Basically I have multiple stores as singletons throughout my app for different data domains. Basically a Flux like store that uses method calls instead of dispatching actions. I would be calling this and other methods in many different places throughout my code. Probably should have mentioned that to begin with. You are right though if I was only using this in one spot it would not really need to be a method on an object. 
Fortunately all characters in the basic multi-lingual plane fit in a single utf16 code point so chinese, japanese, korean will work OK, it's things like emojis that'll return incorrectly.
Create a function renderPrice that accesses all the form values, does the calculation and outputs it into the input fields on the right. Now, watch for the 'change' event on the form on the left and call this function everytime one of the values changes. function renderValues() { ... } $('#formFieldToWatch').on('change', renderValues); This assumes you have jQuery installed.
There aren't too many fixed-length fields that use these characters. Really, there aren't any that I can think of. If they're used in a name, street, etc, you generally want a reasonably forgiving length to begin with. It's different from validating a date or credit card, which have stricter requirements. There are probably a ton of text-effects that get this wrong though.. 
Hi /u/BradGough123, this post was removed for lack of information. * Are you sure this isn't just a CSS/HTML problem? It sounds like it is... while you could of course use JS for something like this, you probably shouldn't in most cases. If it's an actual CSS/HTML issue, then please post in a more appropriate sub (/r/css, /r/html, /r/frontend, /r/webdev, etc). * If you're having a specific problem, you should really post some code. If it's just a few lines, then include in the post, otherwise it's preferable to use codepen.io, jsfiddle.net, etc. Help us help you. * Lastly, and don't take this the wrong way, but the problem sounds super basic... like first or second result on Google basic. Have much time did you spend on the problem before you gave up?
I'm not positive, but it could be that I'm using the actual unicode as the [characters provided to the demo](https://github.com/camwiegert/baffle/blob/gh-pages/assets/js/main.js#L5). It will also depend on the font you're using having coverage for those unicode characters. The font I'm using in the demo is [Input Mono](http://input.fontbureau.com/), which has all of those characters in monospace. Hope that helps!
&gt; With the bug intact, if JavaScript uses UTF-8 internally, length would count up to 5 characters. The "bug" is that String#length counts code units rather than codepoints (or grapheme clusters). Doing the same thing in UTF-8 would return 4 (0xf0 0x90 0x90 0xb7) not 5.
Not quite, that's Python 2 with a "narrow" build. Python 3 or Python 2 in a wide build return 1.
Yes, the variable width of grapheme clusters in unicode means that you'll always have to deal with the variable nature, even when using the supposedly fixed width UTF-32. Edit: I usually like to link the [Unicode testpage for combining sequences for Lithuanian](http://www.unicode.org/L2/L2001/01190R.html). It got some special cases where characters take 3 unicode code points even when normalized and is based on the Latin alphabet, so it's also good as argument against ignorant people who say "yeah but it's only those weird Asian writing systems that are broken and weird anyways".
Would be cool to see a demo but looks good from the screenshot :)
Let me bring a counter example that doesn't even go into Asian languages with lots of "characters". Let's just look at Lithuanian that is based on the Latin alphabet. How about [combining sequences necessary for Lithuanian?](http://www.unicode.org/L2/L2001/01190R.html) The character `i̇̀` (latin small letter i with dot above and grave) needs 3 Unicode code points to be represented (even when normalized), (&lt;U+0069, U+0307, U+0300&gt;). Unicode Grapheme Clusters are inherently variable width, so despite common believe even UTF-32 isn't truly fixed width. Note that programs often have problems rendering those characters due to wrong assumptions about text encodings, so you might want to try a different browser if it doesn't correctly show up.
If you'll look into it you'll find that text isn't as easy as it seems to be. &gt; New programmers will expect .length() to obviously return the number of characters in the string! You'll find that sadly "characters" is a heavily overloaded term that isn't well defined. One of the reasons Unicode defines its own terms. In this case you just have to look at the manual as it isn't as trivial as it seems on the first look, even if you'd like it to.
Well...1 and 2 were easy, after that I'm kinda lost.
the goal was the smallest possible number though :o
I'd start looking for libs based on ndarray: https://libraries.io/search?keywords=ndarray&amp;languages=JavaScript
on nanever mind I got it..
It doesn't seem like text encoding should be so difficult...
It's `!x`, not `!x()`. It's called only once. 
Anyone have a hint or anything on the symmetry one? Unless I'm misunderstanding something, each variable only gets evaluated once, so you can't use order-of-evaluation tricks, and otherwise == is supposed to be symmetric isn't it?
Your objection makes no sense at any level: 1. JS strings are arrays of UTF-16 code units 2. as I noted the very idea of an array of codepoints is nonsensical, the closest feasible things to a uniform fixed-size codepoints array is a UTF-32 code units array but you can have "array of codepoint" strings which are not UTF-32 code units: Python 3's "flexible string representation" uses codepoint indexing but the underlying array can be ISO-8859-1, UCS-2 or UCS-4 depending on string composition.
To be honest it really isn't that hard. If you know what the terms "Code unit", "Code point" and "Grapheme cluster" mean and are aware that the grand scheme is variable width you get around quite nicely. Maybe be aware of normalization as well so that you can look it up if you need to. In my opinion the main problem is that you don't usually learn anything about unicode. Text simply gets treated as "plain" text while learning, without any worries and no one ever thinks about encodings until they run into bugs.
... for what? personal use? professional intranet? client engagements? marketing sites? My answers range from none to Wordpress to custom coded CMS systems, but it all depends on what you need and who will be authoring content.
People created typescript to compile better language features into javascript. Same with Coffeescript. Now ES6 is here and people are compiling javascript to javascript. Once we've allowed ourselves to do that, I think we should consider ANY language that could potentially be compiled to javascript to write webapps in. Maybe learn a new language and make a js framework with it? Or try writing a simple compiler for a new language to javascript? Try [these maybe](https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js) I think the framework patterns offered by direct js are pretty well explored now. But ScalaJS and ClojureScript+react are really interesting and make development more fun. I'd predict the next generation of javascript frameworks will be built in other languages. 
Hahah yeah I was actually thinking about that too! I think it'd be much easier as a starter project than the workout one I mentioned above. You want in? :-P
I've done a little Vue (1.x) and a little React. They're both fairly easy to pick up quickly. Read the "Thinking in React" article on the react website and see if it appealls to you. But they're just view layers. You'll need something to help move the data from client to server as well. The react community has ways to do it, flux, redux etc. But you can probably plug in anything you like to either library. 
Thank you for your thoughts! I honestly hadn't even considered Mongo or Ionic, although I have read up on them a little bit. I definitely plan on making it dead simple at first since I'll be learning API design and such as I go along. Node.js is a great suggestion - I definitely want to stay away from .Net and the likes. Great point on using the gap software - I was definitely planning on that since the duplicate work would just be too much. Thanks for all your input!
I'd expect most people, once made "unicode-aware" would think of characters as referring generally to code points.
I appear to be the first one to win this one! Spoilers! https://i.imgur.com/k4O2aIU.png I'm sorry, Code Gods. 
Cool, you can see it directly on reddit's comment box's character counter. If you put 𐐷 it will give you 2/10000.
And today I learned I'm terrible at JavaScript. Oh wait, that's every day for the past year...
Word. Library support is sometimes an issue, especially for regex. Makes me so glad that we finally got the new `u` flag in ES6 and it slowly gets implemented.
Don't be, it looks like I was the first to figure it out!
Hey ! Thanks for the feedback.. currently its only 3x3 and the points/co-ordinates are hard coded. I am looking forward to add 4x4 and 5x5 without hard coding. The user cannot join one dot more than once, so max length of the combination will be 9 numbers. Also you can provide the minimun no of dots to be joined for a valid pattern, by default the min. Limit is 3dots
Isn't length a property in JS as opposed to function in other languages?
All kinds of things are a valid date in Chrome :-P Morgan Phillips [is doing some great work](https://github.com/mrrrgn/proposal-date-time-string-format) toward getting a spec for all this so all browsers can be equally crazy.
Ah okay. Some ideas for you! - The canvas is a fixed shape, so perhaps use percentages relative to the width/height of the canvas. So that you'd have a more flexible dot arrangement. - if you used percentages, you could even start using math on them to divide up the canvas into dot regions. so you could have 3-by-5 dots or other fancy setups. &gt; minimun no of dots to be joined - Also related to a Github bug that I posted about the vibration boolean, you can only have a minimum of 1. If you try to use 0, it will instead be assigned your default of 3. Sorry if I'm rambling a bit, but your library does seem pretty interesting. :)
There seem to be solutions with only 20 chars, but I can't figure out how the f they did that...
 transitive([], 0, '0') After that, I dunno. I can't figure out the "symmetric" one.
It's the same solution as mine, but refactored to be a putt instead of a drive.
Thanks man , i have fixed the vibration bug as per your suggestion, i will try to make the dot arrangement more responsive as you have suggested.. i liked your suggestions no need to be sorry man you are awesome :)
UTF-8 is great for passing strings around, but it's inefficient to work with. Even basic operations like string.charAt(n) would become O(n) rather than O(1), for example. Next language, let's plan ahead and just use UCS-8 right away. That way we'll have one character fitting exactly in one register, just like in the good old days. 
Hmm...if that's the case, and there isn't a more straightforward answer, I feel like this isn't a very good puzzle -- at least not in line with the previous examples.
if the server can return jsonp, then you could do &lt;script&gt; var data function jsonpCallback(value) {data = value} &lt;/script&gt; &lt;script src="http://foo.bar/api/?callback=jsonpCallback"&gt;&lt;/script&gt; &lt;script&gt;//rest of your code here&lt;/script&gt;
I don't even see that character in the reddit is fun android app. 
Javascript is literally not based on Java at all. I know that some of those programming assumptions and standards would be the same because they are languages from the same era, but there was never an attempt to make javascript like java. This is going to forever be the most confusing naming decision ever.
That's a pretty cool solution. I'd like to think I'm pretty decent at JS, but I'll admit I didn't even know about valueOf. In an attempt to understand what this code does, I made some comments and unminified it in case someone else is also confused: // Create a function that creates the `initial` variable and sets it to 1 var getObjectWithModifiedPrimitiveValue = (initial = 1) =&gt; { // Because we are using arrow functions, `this` still refers to `window`. // We are now setting the `valueOf` of the window to a function which returns our "initial" value. // valueOf lets you set a primitive value for an object for when for example math is being done to it. this.valueOf = () =&gt; { // The original code used `x` instead of `()` just because it is 1 character shorter - really, the goal is to have valid syntax for an arrow function, and parens can be omitted if there's a single parameter // After this, window + 0 would evaluate to 1, since window's primite value is now 1. return initial++; // We are also incrementing this value by 1 so that next time it calls, it will be higher by 1 }; return this; // By returning `this`, the symmetric function now gets `window` as its argument } // We call the function, which runs any code we need and eventually returns `window` symmetric(getObjectWithModifiedPrimitiveValue(), 1);
[Did just that](https://www.reddit.com/r/javascript/comments/4wa9q4/return_true_to_win_javascript_code_golf/d65r8vf) in a response to his solution. 
Great explanation! Thanks! 
~~[Spoiler (hover to see answer)](/s "eval.bind(null, 'throw true')")~~ Edit, apparently the UI was confusing me because it shows `true` as the output. But the below comments are correct, this isn't actually a solution. I'm convinced that this problem is impossible.
[],0,[] is the best answer
I don't think throwing an error works.
That's so dense! You could publish a one liner npm package.
For a second I thought its a copy-paste of react-native under a different handle!
At that time I was trying to make sure there wasn't a space in between a string of characters that I had no control of. If there was a space it was invalid. Answered pretty late but just saw this 
Awesome, thanks for the suggestions! I'll definitely read that article this weekend!
what was the baby dressed as???
I agree. You can literally solve all of these puzzles with functions.
haha, i debated stepping up, but when i put it in it gave me undefined domain, i must have type it in wrong - thanks!
I feel like this is a great example of timing, tracking states, etc, but it's hard for me to follow your source. Is English your primary language, sorry not trying to insult, just curious?
&gt; Now that surrogate pairs allow UTF-16 to cover all of the Unicode characters, there really isn't a need to switch. Well, the problem is that with surrogate pairs, you now have exactly the same indexing problem you would have with UTF-8. Want to find the 53rd code point in a UTF-16 string? It's not necessarily going to be 53*16 bits away from the beginning, because there may be surrogate pairs that throw that calculation off. UTF-16 is basically the performance problems and error-prone-ness of UTF-8 without the memory savings. Its only reason for existing today is historical baggage. Other encodings are strictly better.
And that's the best reason we don't need to count the length of strings in 'characters' at all. There is simply no valid usecase for that. We need either bytes or graphemes, the rest is for encoding converters.
Yeah, bad title. It's accessed as a property.
The misunderstanding of String#length is everywhere! In all fairness, I've been writing Javascript for years and didn't understand this.
[removed]
UTF-16 was standardised in mid-1996. JavaScript was implemented and shipped in mid-1995. UTF-16 only existed in draft form, because the Unicode Consortium was essentially in denial about needing more than 2^16 characters, and all that existed were a fixed two-octet format (UCS-2) and a fixed four-octet format (UCS-4), as the compromise had yet to be agreed to between the two standards bodies. And from those two bodies, there were two standards: that developed by the ISO/IEC (which had 2^31 characters) and that developed by the Unicode Consortium (which had 2^16 characters), and the variable length UTF-16 and its associated 2^21 character codespace compromise is the result of unifying the two, which finally came to pass in 1996. The ISO/IEC standard had far more varied contributors, including far more from a background in linguistics, whereas the Unicode Consortium was mostly made up of tech companies, hence what the Unicode Consortium did is what mostly got implemented, leading us to end up with all these environments that use UTF-16 code units rather than something more natural (like code points or graphemes).
I can't even see it on desktop either.. What on earth is it?
UCS-8? Planning for when 4 billion code points aren't enough? 
Solution in 20 chars: `i=0,{valueOf:_=&gt;i++}` 
how does Mithril compare to Inferno using hyperscript and stateless components? They look very similar, except with Inferno you get the flexibility of using whatever state management library you like (my personal favourite is Redux). Are there plans to bring Redux to Mithril? I don't want to use MVC – which is all over the Mithril website. We've really come a long way since using MVC, we now use a component driven architecture, so I'd like to see how Mithril tackles this difference... people really don't want to create components with view and components over again to represent a UI... that would be Angular all over again!
Fixed: if(one_slice.value === "" &amp;&amp; two_slice.value === "" &amp;&amp; three_slice.value === "" &amp;&amp; four_slice.value === ""){ console.log("enter a value"); one_slice.focus(); }else if(one_slice.value === "" || two_slice.value === "" || three_slice.value === "" || four_slice.value === ""){ console.log("enter values for each slices to be eaten"); }else{
Jeez an npm package for determining string lengths. Did we already forget about left-pad?
Is finding the nth character in a string really an important use case to optimize for? Other than iteration (which UTF-8 can still do efficiently in other ways) what would you use it for? The only other uses I can think of would want the nth glyph instead, and they aren't fixed width even in UTF-32.
Interesting. I was looking for a minimal framework that stuck as closely to plain Javascript as possible. http://codepen.io/wulab/pen/JoqXja?editors=0110 https://www.quora.com/What-are-some-nice-web-apps-build-with-Mithril-js https://techwalla.com/
&gt;PHP does that as well. I'm with you, but this may not help your case
Well, something as elementary as `string.length` would also require iterating over an entire string unless the engine decides to store both the length and size of every string. Any string operations that take a string index would have the same performance problem, so calls to .slice()/.subtr(), or .indexOf() with 2 parameters, and probably others, would be impacted. Ultimately, it's a trade-off between memory usage and cpu usage. 
so i kind of get what's going on but I think my ES6 syntax is weak and also valueOf isn't really clear to me. so _ =&gt; i++ is the es6 syntax for an anonymous function where you're returning an incremented i, however, where does the valueOf come into play? Is the valueOf a Window attribute that's being overwritten? Even if it is, how does that help? Are we passing in the whole window object in that empty object or something?? Also, just to make sure i'm not mistaken, you're able to use _ instead of () when your es6 anon function doesn't need any parameters passed? EDIT: OK i think i get it. we're passing in an empty object but setting it's primitive return value-type (via valueOf) to a function that returns 1 and it only POST-increments after it's evaluated the first time around.
whoa, that's an awesome article. Thanks! 
NaN
What would you suggest as an alternative?
It's comparable to some of those, but probably a bit more opinionated along with some nice abstraction in front of state, routing, etc. It uses [HSR](https://medium.com/@tannerlinsley/introducing-hsr-the-hot-state-reloader-behind-jumpsuit-js-42498712ac90) instead of HMR, and has a really minimal API. You can read a great article about more of the differences [here](https://medium.com/@tannerlinsley/jumpsuit-react-redux-made-simple-e3186ba1b077).
`console`, strictly speaking isn't part of the JavaScript language: it's part of the `window` object, provided by the browser at runtime. It is possible, therefore, that VS doesn't predefine it, so it doesn't autosuggest. What happens if you try `Math.`, which is part of the language? Does it suggest any of the built-in math functions? Because JavaScript is dynamically typed, very few IDEs support an Intellisense style of autocomplete. I'm personally fine with this, but many people aren't, and if you're in that category I would suggest you look at TypeScript.
Four wheels + windows = 10 parts! 
Did your answer have moxie?
you're computer exploded?!
TLDR: MEAN stack if anybody was wondering.
Clickbait title
Fuck the title. He found a shitton of completely unnecessary code. Not left-pad style unnecessary, but an entire encyclopedia as a sub dependency, simply to console log a definition, or just a picture of Guy Fieri in the middle of babel-core
Obviously it's going to result in a spread and another function call which will be slower. But instantiating enough instances of this class to make it something to worry about is probably going to be WAY slower than this anyway. I would rather be concerned about the fact that you are adding lines of code that do exactly nothing compared to not having them. Unless you are going to add some specific behaviour in to that constructor. 99% of the time people should worry about code quality over fine grained performance like this, because mis-reading legacy code is going to cause you to write WAY worse code in the future than this little thing now.
This is just FUD. npm install yummy and see for yourself...
Thank you for telling me!
1080p is just the upscale size of the VHS tape's natural resolution. There were actual 1080i tapes made but they weren't used for home recording however.
I didn't go through everything, since it's very difficult to read, but looking at your JavaScript, the problem is you're trying to do arithmetics with elements, which doesn't make sense. When you call [getElementById](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById), you get back your input elements. What you need to do is then access the *.value* property and cast it to a Number (since it's a String). After that, you can use the value to do your calculations. So for starters, try changing all *document.getElementById("someId")* calls to *Number(document.getElementById("someId").value)*. Functionality aside, your code is following some terrible practices. Using global variables instead of returning from functions is a good sign you should focus on improving your general understanding of programming languages and concepts.
Well regardless, I think my point still stands about stupid title, and micro summary 
I have implemented some demos for the WebGL framework [regl](https://github.com/mikolalysenko/regl) this week. They all use the stencil buffer to implement some cool tricks. Three demos in total: * [Reflections in a plane](https://mikolalysenko.github.io/regl/www/gallery/planar-reflection.js.html). [Source Code](https://github.com/mikolalysenko/regl/blob/gh-pages/example/planar-reflection.js) * [A blocky dissolve effect](https://mikolalysenko.github.io/regl/www/gallery/stencil-transition.js.html). [Source Code](https://github.com/mikolalysenko/regl/blob/gh-pages/example/stencil-transition.js) * [Shadow Volumes](https://mikolalysenko.github.io/regl/www/gallery/shadow-volume.js.html). This is a shadow rendering technique that, in difference to shadow mapping, has no jaggies or pixels on the shadows whatsoever. [Source Code](https://github.com/mikolalysenko/regl/blob/gh-pages/example/shadow-volume.js) 
I realise Poes law is probably in full effect here but it's actually satire, took me a few reads but it's actually quite funny
I made a lightweight, stable, performant and extensible abstraction over WebSockets. Custom plugins can be used to modify the behavior of message serialization and add socket extensions (like the built-in `ServerSideSocket#broadcast` method). https://github.com/kripod/wsx
[Doesn't seem faster](http://i.imgur.com/lvBjobG.png) than on the CPU for me. Tested on Safari 9.1.1.
&gt; nanever mind NaNever mind
This isn't code golf, it's JavaScript trivia.
&gt;there's a simple string-length package you can use oh lord
Similar results on i7, 980TI: Firefox Average time of reduction on the GPU: 4.06ms Average time of reduction on the CPU: 0.65ms Chrome Average time of reduction on the GPU: 2.78ms Average time of reduction on the CPU: 13.32ms I suspect shuffling textures to/from the GPU might be a bottleneck here?
I would like to say thank you for your feedback, mainly for the second part where you say that is a terrible idea to write using global variables.I will fix my code and then I'll try to learn how to write more efficiently.
Not in strict mode.
Correct. If one side of the equality is a number and the other is an object, the object is converted to a primitive value by calling its `valueOf` method. If that produces a primitive value, the comparison is retried with the number and that primitive value. (Relevant parts of the spec: [11.9.3 step 8](http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3), [9.1](http://www.ecma-international.org/ecma-262/5.1/#sec-9.1), [8.12.8](http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.8)) So, we create an object with a stateful `valueOf` method, which will get called once for the `x == y` comparison to return `0` and then again for the `y != x` comparison to return `1`. &gt; Also, just to make sure i'm not mistaken, you're able to use _ instead of () when your es6 anon function doesn't need any parameters passed? If a lambda function takes exactly one argument, you can leave out the parentheses. That is: `(x) =&gt; foo(x)` is the same as `x =&gt; foo(x)`. That way, if you want a lambda function taking *no* arguments (i.e. `() =&gt; foo()`), you can save 1 character by taking *one* argument and ignoring it (as in `_ =&gt; foo()`).
I agree with /u/Heqx, if you see the demo code here : https://github.com/camwiegert/baffle/blob/gh-pages/assets/js/main.js, you'll see the exact same thing.
Very similar result here on a 2015 MBPr
There was a challenge last week in r/dailyprogrammer to make a Julia Set fractal so I did it in WebGL. I like how it turned out. http://universefactory.net/test/julia/
Far from being my own project, but I am core team member of [AVA](https://github.com/avajs/ava) and we released version [0.16.0](https://github.com/avajs/ava/releases/tag/v0.16.0) today.
You might enjoy this: http://www.2ality.com/2011/12/fake-operator-overloading.html
What is this? 
I made an alexa skill (just for use in our office, we have an office echo) where you can say something like "alexa, have someone take out the trash" or recycling, make coffee, etc. And it sends the intent to an AWS lambda function I wrote with node that gets our list of slack members, queries our database for whose turn it is, and posts a slack message asking that person to do said task. It also has the echo say "*blank* has been notified". We have a problem with people taking turns doing chores, mainly the trash...
I guffed, but joking aside my guess is that its hinting off of the file extension because they ported the windows code. The ext of the file is probably what they use to pick the intellisense language. Not the cleanest/best solution but to be fair the tool is still not on final release as far as I know. 
Survivor's bias. Limitations can force someone to make the right decision, but they can also force them to fail completely. 
This will help (very obscure stuff) : https://developer.mozilla.org/en-US/docs/Glossary/Falsy
It's a little bit of both. Once you've solved a puzzle, there's a leaderboard ranked by number of characters used.
&gt; For length, you would typically want the number of glyphs, which is O(n) even in UTF-32. Only as a start, though. String length has three major purposes that come up in common use: 1) Calculating memory space. 2) Calculating display width. 3) Calculating the range of valid indices. The first is irrelevant to JavaScript in the vast vast majority of use cases, though it can come up when working with binary protocols. Said protocols usually enforce UTF-8 anyway, though, because space savings. The second can't even be done by counting glyphs as it's also dependent on font and even layout engine settings. This is entirely something that needs to be left up to the display engine and should not be attempted manually. The third is what makes this seem more complicated than it really is. There are various JavaScript string interfaces that take a `pos` and you generally want the `length` so you know the range. This is less complicated than it seems, however, because both `pos` and `length` should be treated as mostly opaque/arbitrary numbers that have no significant meaning besides being a cursor and a sentinel, respectively. Of course, in this case, `length` should just be the size of the string over the size of the element, e.g. `bytes/2` for ucs-2 strings and `bytes` for utf-8 strings. There is literally zero reason to care about "characters" in this case because the iteration methods will always return `pos`/index values that point at valid whole characters. In the native code land I always points people at http://utf8everywhere.org/ -- it's less meaningful for JavaScript developers since the language makes the choice for you, though.
Wish I could upvote more. Developers who don't optimize for later maintenance (i.e., developers who go out of their way to defeat tools) need to be thoroughly educated on how they can improve their process. :)
Hi /u/imright_anduknowit, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
It IS callable, oh god. See spec for [legacycaller](https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-all).
I tried to do document.all.legacycaller=_=&gt;'world:' But that doesn't appear to change what `document.all()` does. It also seems like the spec states that legacy caller only exists on HTMLEmbedElement.
`document.all(str) === (document.getElementById(str) || document.getElementByName(str))`
another options would be to just make it so that when you looked up the property "object" on any Object that it returned something.
Thanks, I managed to get it to work in my Chrome console, but the website refuses to accept it as solution: (el=document.all('hello')?document.all('hello'):document.createElement('a'),el.id='hello',el.toString=_=&gt;'world:',document.body.appendChild(el),document.all) If I copy the definiton of `wat` and call it with this argument, then it returns `true`, but the one on the website itself returns `false` for some reason.
Ah, cool. I'd like this for the languages I actually use...I can't be bothered to research JavaScript.
Oh cool, learn something new everyday.
Hi /u/khirviko, when you cross-post, just post a link to the original source (and not to another reddit post). Thanks!
Your post is a general programming topic, which doesn't really have anything to do with JS specifically.
Got it. Thanks. 
can you describe what this is?
Got it. Sorry about that /u/kenman, still new to Reddit!
I agree. These are little points of infuration that developers bump into and that makes all the difference. The things that make you type for 5 minutes wondering what's wrong - wondering if the editor is broken, if you're going crazy, if you did something wrong, if you should throw your laptop away and go into landscaping because while it doesn't pay as well, you can still make beautiful things without the frustration. Anyway, that's something we're trying to fix!
&gt;You could also use one of the popular systems for e-commerce, like Shopify, Squarespace, WordPress, etc &gt;Rate is $100 per hour, half up front, plus $100 up front for what I gave you. TIL: how not to advertise your services on the internet. Seriously, you recommend WordPress for e-commerce? If you mentioned Magento, that would be slightly better, but with what you mentioned and $100/hr with 50% + $100 up front? I just... I think you forgot your /s tag
This is the 6th piece of software called Phoenix I've encountered, starting to get confusing.
I'm not advertising my services. I'm trying to give the guy some perspective on the reality of asking people to write his computer program for him and an alternative to just leaving him hanging with a partially complete program. I also said Shopify and Squarespace. GFYS.
apparently setState is asynchroneous, so +10 might not work, at least thats the effect im getting * fiddle showing it doesnt work with setState: [fiddle](https://jsfiddle.net/setpshy4/) * working fiddle: [fiddle](https://jsfiddle.net/8h9t3z6n/) * article explaining: [link](https://medium.com/@wereHamster/beware-react-setstate-is-asynchronous-ce87ef1a9cf3&amp;ANYPE_SUBMIT=0) article says use the previousState to set the currentState this.setState((previousState, currentProps) =&gt; { return { ...previousState, kount: previousState.kount++ }; }) }, dunno if this helps i realize ur having mouseOut issues...... im trying to reproduce it
It's a code that rewrites javascript to be as small (minimal) as possible. [UglifyJS2](https://github.com/mishoo/UglifyJS2) is currently en vogue as far as I'm aware.
you could try doing `this.forceUpdate()` in `handlePressOut`
Wow, what a clusterfuck
Contribute to open source.
You want to give him a perspective on reality, but also suggest using WordPress for an e-commerce website, and also offer your services for a ridiculous rate and an up-front payment for something that should take the average developer around 15 minutes. Hell, I could write the entire script for the OP in less than 10 minutes with the given screenshot. I would do it, but it's 12am as I'm typing this and I need to catch some sleep.
CoffeeScript is NOT a superset. Typescript is a superset of JS because all valid JS is valid TS. This is not true for CS.
You'd have to research whatever language it was for, unless you tend to keep the entire spec (and its common violations) in your head for the languages you use. And that research isn't going to be *super* useful anyway (all though I did learn a bit about es6 proxies doing this).
That's what I'm saying
Oh, expensive! But it looks so good.
Ah, I see. Well the purpose of a constructor is to prepare the instance for usage, NOT to start that use. Decomposing props and setting up initial state first time round is all exactly what you should be doing here. The call to this.DoSomething(); is more dubious. Unless it's preparing internal state you shouldn't be calling it here. Assuming you're talking about React: If you need to do some DOM manipulation or call some actions or something, you should hold that stuff back until ComponentWillMount() or ComponentDidMount(), as these are actually part of the component lifecycle, which is what you should be concerned with, rather than instantiation time.
Those performance comparisons were funny. Aurelia faster than react? Keep dreaming.
Check out source code pro for free
&gt; Windows applications.
While not exactly the same, I'm using [Google's Droid Sans](https://www.google.com/fonts/specimen/Droid+Sans), which is free and looks pretty decent. Edit: [Here's an example](https://i.imgur.com/Y9XX7Wn.png)
Yes, and? Some people use Windows. I prefer to be able to offer my software to them.
ah okay, thank for the response and examples, quite helpful 
key is created inside a function as a local variable they only give you access to the function. No idea how to do that one. Possibly you could brute force random4.
Thanks for the informative link. I'm not sure it's really "built-in" yet. Mobile support for `Array.from` is atrocious. [We'll just sweep those cross-browser support under the rug for now](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from#Browser_compatibility). ;)
The part that's related to JavaScript completions is indeed related to what I've described. Glad you could catch an answer here. :)
Function overloading can definitely be handy, and you clearly put a lot of thought into this, but at the end of the day, I'm not sure this library made the task any easier. :-/ If we were to implement overloading by hand, it would take the same number of LOC and the same chunks of logic: var add = (function() { function addNumbers(a, b) { return a + b; } function addArrays(a, b) { return [].concat(a).concat(b); } return function add(a, b) { if (typeof a === 'number' &amp;&amp; typeof b === 'number') { return addNumbers(a, b); } else if (Array.isArray(a) &amp;&amp; Array.isArray(b)) { return addArrays(a, b); } }; }());
and I thought the satire was good until I saw the number of people not getting it. Sad.
Also check out the full code on github [repo](https://github.com/peey/js-multiple-dispatch/blob/master/index.js). It's complete software package with tests and custom Error objects. It may be useful if you're using this function overloading pattern widely throughout your code.
Tru. They should name this *barista* since it's a js project 
There are many options: https://css-tricks.com/os-x-window-manager-apps/.
[removed]
Well as you can see, choosing names that are not in use is rather hard these days. :) This project has been around for several years. Since then many other projects have chosen the same name. I guess the original author chose this name back then because the app was a reincarnation of his previous projects. Maybe a rebranding could be beneficial, who knows.
I'm not using any of the frameworks so I don't have any skin in the game, but I'm wondering how do you know Aurelia isn't faster than React? Are there any trustworthy comparisons you can point us to, or are you just going on gut feeling?
I think people miss the joke because it's not particularly funny at all.
The reason it doesn't work is you are defining the positions array to have two elements, but you're asking positionsFunc to update six elements. So when the code tries to modify the third element, you get an error. Here's an updated version: http://jsfiddle.net/6X8BW/271/ Hope that helps.
I figured that, but also thought of that but then there's [this](http://codepen.io/anon/pen/dXgdpW) and [this](http://codepen.io/anon/pen/rLqJjX).
As johangirod commented on the article: &gt; This article greatly misuses the term of Higher Order Component (HOC)! What are called here HOC are just standard React Component, and "Higher Order Component Creators" are what the community calls HOC. Indeed, googling Higher Order Component Creators return no results except this post. &gt; &gt; For a clearer and more accurate explanation of what HOC component are and what they do you can refer to the thorough post from Dan Abramov https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.w1dfp3mpz A minimal example of a HOC can be seen here: https://gist.github.com/sebmarkbage/ef0bf1f338a7182b6775
Pro tip: put your code in jsbin, plunker, codepen, or jsfiddle before asking your question. Not only does it help clean room your code and possibly realize it was a trivial error but it helps anyone easily test it and debug it with console.
Oh give over man you boring fuck
im not seeing any event handling in there, i could be wrong though its a lot of code. heres a simple example, youll have to handle the click events and position your popup and show it. https://jsfiddle.net/xum94tu0/ jquery ui has a nice popup util too though its a lil frusterating.
If you just assign `document.querySelector` to a variable the function application won't happen in the right context. You can fix that like this: var q = document.querySelector.bind(document) The method is called `addEventListener`. No idea which browser autocompleted that to addEvent. 
cheers, thx for the tip i like that 1 letter query selector
 [[1,2,3],[3,2,1],[1,2,3]].reduce((m,v)=&gt;m+v) // "1,2,33,2,11,2,3" (what happens when the default param for reduce is `{}`) 
The thing that looks wrong to me is copying all props into state? When would you ever need to do that? Now you have two copies of your state.
It's a shame they don't do proper server-side validation. You can easily get the record just by sending bogus data that evaluates to a truthy value.
Well... an svg is itself an image. Nice little repo though.
Thanks for your replies! I will look into the event handling thing, and I can restructure my media wiki pages so that the body and head tags are no longer there. Also does anyone have any good JavaScript learning resources? I would like some things to reference! Thanks again
I can tell you why it doesn't work, but I think it's better to do it the other way around: what do you expect your snippet to do, and why?
I mean to test it yourself part could work on small projects. With unit tests you basically make a time investment up front and then any time you make changes it automatically runs again. When manually testing you have to keep rerunning all those tests manually every time you deploy which after a certain point can take much more of your time than the initial time it would have taken you to write tests. It kinda sounds like you are use to working on small projects. Say you built Reddit 100% client side. It would be extremely hard to just glean over the code every time you deploy. One thing I will note is that testing in JS is alot easier if you are using a framework to abstract the DOM away for you like React, AngularJS, Ember or Vue. Unit testing jQuery soup is hard unless you put lots of abstractions in yourself. How big is the project you are working on?
The main value I have in unit tests for front-end code is having greater confidence in making larger code changes. This is particularly important in larger team settings or in larger projects, where a change in one place can have all kinds of whacky impacts in other parts of the code base you might not even be aware of. However, a lot of JS code is inexplicably tied to your view engine in some way or another. If I test that a react component is rendering correctly with something like shallow rendering, how much of my test is actually useful in testing my code, vs testing react itself? This is why I'd say there's some value in unit testing, but to also be mindful of integration tests with automated UI (AUI), and to use those when more appropriate.
&gt;The agenda for underspace is to make it easier for designers to design stuff by just writing plain HTML. I've heard this parroted a lot, but I find myself constantly questioning the legitimacy of this. Where I've worked, designers did the design, not the implementation - they were not expected to know HTML, and very often only knew photoshop. Even if you did get an HTML out of it, the styling they made for it often wouldn't be cross-platform enough or compatible enough for e.g ie8 or mobile devices. And if you wanted to make an angular component (*or whatever*) you'd have to add a bunch of markup to make that library happy, and probably restructure it at least a little bit. So you'd end up having to re-implement it anyway.
Careful in calling some of this "unit" tests. Whenever you involve the UI (*especially* the DOM) you're getting into integration territory.
Meh, careful in trying to adhere to muddled definitions of "unit." A unit is a unit of behaviour, and you _can_ test a single behaviour at the ui level.
Yeah, it's not like any major sites use star ratings these days. Certainly not: * Yelp * Google * Facebook * Netflix * IMDB * Amazon * Yellow Pages * Dealer Rater * Edmunds * Healthgrades Or it could be that literally *every single one* of those uses stars in ratings.
Why did you choose to build this on top of jQuery and not d3? Just seems like an odd decision.
OtherThing is still a HoC. Functions can be components too.
Seems that the only solution anyone has so far has been to mess with the script running parts of the page
It should work after you save the file. See: https://www.reddit.com/r/javascript/comments/4we7qg/vs_code_doesnt_autocomplete/
&gt; Why unit test when I can just glean over the code myself and test it against common types of inputs? Why not write tests to automate this "glean"ing away for you and validate that your independent pieces of functionality still work after big refactors/feature additions in your system?
But OtherThing is not a component. It doesn't have any of [this stuff](https://facebook.github.io/react/docs/component-api.html) or [this stuff](https://facebook.github.io/react/docs/component-specs.html). You can't do `&lt;OtherThing /&gt;`. I'm still confused about the terminology.
No, it's a function that returns a component. Like this is a number: const x = 6; This is a function that returns a number: const f = () =&gt; 6; You can do `f + 5` because f is not a number. You can't do `&lt;OtherThing /&gt;` because OtherThing is not a component. It doesn't have a limited API, it has absolutely none of the component API, because it's not a component.
`OtherThing` would in this case be a function, which consumes a component as the only argument, and returns a component. And in that sense a HOC. But I can see where the confusion comes from. But who says the definiton of HOC is similar to HOF, with just the "function" part substituted with "component"? :) However, what the article calls HOC is just a normal react-component; Nothing more. Calling it a HOC is simply wrong imho. And "higher order component creator" is equally wrong, as it does not create a HOC. Regardless of the definitions of "higher order function (HOF)" and HOCs I still think the article-author have (intentional or not) misunderstood the "higher order"-concept. And it would have been better if he used the same names as the rest of the community.
Very cool! I think the use of file names as keys is pretty interesting and would be helpful for eliminating the configuration that you normally see with DI systems. That said, I do think you should expose some way for people to avoid using the file system. A lot of the power of DI comes from the ability to swap things in and out depending on use case, and locking to the file system 100% of the time would prevent doing so. For example, I have two parts to my site, a logged-in and logged-out experience. I have an injected `Session` that's an instance of `AuthedSession` in one app and `UnauthedSession` in the other. Because of DI, my shared code can simply request`Session` and needs no knowledge of where it's being loaded.
Thanks for sharing this, it's pure gold :). For now i am taking a video course about compilers in Lagunita.stanford.edu for (try) to know how engines compiles Javascript. :P Hard but fun times hahahaha. PS.: Redomend this talk https://youtu.be/BRNxM8szTPA Here are the slides: https://ia601503.us.archive.org/32/items/vmss16/titzer.pdf This was in Virtual Machine Summer School of 2016 http://soft-dev.org/events/vmss16/ Sry for bad English :s
What do you expect it to do? The parameter V in your arrow function is an array in this context, so you're trying to add arrays together, and it's treating them as strings. 
/me shrugs I'm with you. sa*tired*.
I feel the **main purpose** for type systems was to prevent runtime issues. For this example, sorry, I was trying to express a case where "Infinity" was supposed to be an unexpected response, it was simple to show how even a such simple example could benefit from first-class support for validation, but I should've mentioned that assumption.
I would say they could/should be stateless so validation could occur within the context of only the argument or arguments being passed. EDIT: I understand, I think I really underestimated the complexity of runtime validation if there's a complex state.
Oh, and I think that ES7 will implement annotations as decorators, which is kind of the same thing? http://www.martin-brennan.com/es7-decorators/ 
This post is kind of a monster, but I'm hoping it can make some of the weirder stuff about `Array.prototype.reduce()` clear by showing a practical example. Feedback is welcome — especially if there are ways to optimize and/or make this more clear for people who don't already know how things like `reduce()` work. Thanks!
I'm no expert in this area, but I believe that a common example of why we want to enforce statically checked bounds on values is to statically guarantee against out of bounds errors when indexing arrays.
[check-types][] is an interesting looking library for runtime typechecking. I think it would be an interesting project to add auto-generated runtime checks based on typescript's type signatures. When you are writing a library in typescript and you have the helpful compiler reminding you that the object you are passing to a function needs another property to be valid it's really easy to write a library that will be _shit_ to use from vanilla JS. I think that converting typescripts static checks to devo build runtime checks would be great for javascript inter-opt. [check-types]: https://www.npmjs.com/package/check-types
ha, right. But well believe it or not tons of sites still prefer rating in this fashion. I basically made it for a client and decided to make it legit. 
yeah you're right. But what I meant is that you dont need to load your own png's etc. 
Don't forget app stores
I think whenever someone attempts to introduce DI into JS they must first explain why ES6 modules are not sufficient, and I've yet to hear a satisfying answer for that one.
Is this a tutorial meant to explain `reduce` or converting form data to JSON? Since there's an explanation of `reduce` about ~33-40% of the way through and it's very muddled with all of the DOM code and necessities of calling reduce through an empty array prototype since DOM nodes lists are silly. The way the post reads, it's a tutorial on the latter. The way your comment and link here reads, it's the former. If this is meant to explain reduce, I think it would be *much* more efficient to start the post like that, and then lead into this *as an example*. A few very simple uses of `reduce` to start off with I think would help novices a lot more, like: [1, 2, 3, 4].reduce((sum, x) =&gt; sum + x) // 10 I also think that *generally* it helps to show the kind of `for` loop that you'd be replacing. This is one of the older tricks in teaching functional stuff that illustrates people the value of what you're showing - a lot of people perk up when you can replace: var data = [1, 2, 3] var transformed = [] for (var i = 0; i &lt; data.length; i++) { var value = data[i]; transformed.push(value + 1) } With just: var transformed = [1, 2, 3].map(x =&gt; x + 1) 
I should probably too!
The problem I was trying to solve was unit testing -- I'm trying to test a build system that interacts with the file system a lot, and wanted to run tests without changing my config or checked out code, so I wanted to inject mock dependencies at test time, which meant I couldn't just `import` them. In the past, you could just put your mock into the require cache, but since modules haven't landed in node, I can't put my mock into the "import cache," or whatever es 6 modules will have on the server. To make the transition from imports in each module to injecting the dependencies, I had to spend a long time figuring out in what order I had to instantiate each module so their dependencies were available, which was tedious. If you notice, all the examples and tests do use es 6 modules, and the framework adds mocking and bootstrapping the dependency graph in order on top of modules.
&gt;so I wanted to inject mock dependencies at test time, which meant I couldn't just import them. Why not? import depA from 'somewhere' import depB from 'somewhereElse' export default ({ depA = depA depB = depB } = {}) =&gt; { depA.something(depB.value) } =&gt; // real code import testable from 'testable' testable() // good to go // unit test import testable from 'testable' testable({ // only mock what we need depA: { something: val =&gt; true } }) There's also things like rewire for webpack, but what I just outlined has worked just fine for me, and is already quite similar to what you're already doing.
 S A T I R E A R T I I T R A E R I T A S
I want to add that this tool can be used for really interesting esoteric things as well. For example, a few years ago I wrote a jQuery plugin. Using BigQuery, I'm able to find all websites indexed by HTTP Archive that include my JS. Here's the query: &gt; SELECT pageid, urlShort FROM [httparchive:runs.latest_requests] WHERE REGEXP_MATCH(url, r'trunk8.*\.js') ORDER BY pageid ASC; The results include IFC (TV station), the Seattle Symphony, and even the PM of Turkey! The limitation is that the JS URL must contain the keyword for it to be found; bundling JS would generalize the file name and obscure the plugin. But still, some cool things to be learned about the web with a small amount of SQL.
Ok, just wondering about the rationale. Don't know why I got downvoted for asking a relevant question, but whatever.
I enjoyed this. Any chance this was inspired by the Polyglot's Guide series a few weeks/months back?
My mistake, I didn't see the difference between github.com, and github.io.... it's early in the morning. That animation looks cute. I could see myself using that... I like the way you can control the speed. Hope someone makes a Codepen. It's a good way to get exposure...
A pre-recorded stream and a live stream look identical.
Gotcha. Thanks
Satire doesn't have to be funny. Not all satire is a joke.
I'm on mobile so I can't see your example very well, but isn't this article discussing for loops vs. Array.prototype.forEach, not for x in y? In which case forEach WON'T give you random properties added to the array's prototype?
I started a Codepen here. It's in collab mode so you can fix it directly if you want: http://codepen.io/Teeke/collab/RRqazJ Or here: http://codepen.io/Teeke/pen/RRqazJ/ 
haha, yes. You're right :) I am guilty of half-reading the title, key-word scanning, and then writing a comment while playing Overwatch.
I've make a Codepen here: http://codepen.io/jrainlau/pen/vKQKEA and thanks again for all you did! You could share the link above to your friends, MottoJS is under MIT license and i am looking for more discussion about it.
Awesome. It looks easy now... I see how you fixed it. Cheers. 
if you tag each one with an anchor (with no link) ex: `&lt;a name="section1"&gt;&lt;/a&gt;` you can update the window bar like: `window.location.hash = "section1"` use whatever names you want
hmm ok! good to know! probably this. cheers
Infinite scrolling is hard to do right. It's Very hard to achieve smoothness on mobile. That's why flipboard uses its own canvas rendering. Look at this on mobile: https://flipboard.com/@banica5 Edit: related blog post: http://engineering.flipboard.com/2015/02/mobile-web/
Oh man. You saved me a lot of head ache. Thank you! Works like a charm. 
Nice, I like the idea of putting a for loop in to show what we're replacing. I'll add that in. Really, the article is meant to teach both, so I suppose my title for this submission was unclear. I wanted to avoid the simple examples off the bat because I love noticed people shut down during esoteric examples of they aren't part of a practical problem — that was why I started with the form stuff. (Although I didn't plan on this post being as long as it came out, so there's that.) Thanks so much for the feedback!
I made a starter kit to bootstrap ES6 / Typescript applications. It uses Webpack as a midule bundler https://github.com/emyann/typescript-webpack-starter All the assets files and dependencies are bundled into 2 files: app.bundle.js and vendor.bundle.js. It makes your app easy to integrate any environments just by adding those scripts. You can take advantage of *import* and webpack loaders to bundle all kind of assets like html or css files. About the routing, you should choose an appropriate approach between using a Framework which will handle the routing mechanism for you, picking a library or doing it by yourself. No matter which solution you'd choose, you should be able to build upon the starter kit by importing your dependencies and create your business logic into appropriate classes. Hope it helps!
[removed]
You don't need to use the jQuery selector twice to add and remove a class from an element: $(window).scroll(function(event){ if ($(window).scrollTop() &gt; 99){ $('header').removeClass('big-nav-bar').addClass('small-nav-bar'); } else { $('header').removeClass('small-nav-bar').addClass('big-nav-bar'); } });
 | - app-a | - app-b | - shared-stuff | - AwesomeComponent | - AwesomeUtility in Webpack for each app, add resolve: { modulesDirectories: [ 'src', 'node_modules', '../shared-stuff' // &lt;====== this thing right here ], }, It's going to look in node_modules first, if it can't find it, it'll check in shared-stuff. Change the order to your liking. 
Since it's games related learning you can try [Codingame](https://www.codingame.com/). Not sure how it would work on slow connection tough.
Lovely. Just wish I had a ZXS!
Amazing work! And a great username too!
angular does not use jsx, vue can do non-jsx and jsx. i think vue defaults to more of a mithril-like creation of elems: `v('h1', props, children)` angular has a nice collection class, `collection.update({id:123, newprop: foo})` (similar to a database or datastore/lodash's array fns) angular mixes js logic right in your html templates `&lt;div ng-loop=directiveFoo ng-props=propBar()&gt;` (so you dont have to write as much JS... but then you have to write custom directives to do fancy stuff) *disclaimer not an expert for either* 
The problem with server-side validation is that some solutions are browser-specific, like the 8-character solution of `proto1`.
Half of this is already backed into the language.. I mean `getElementIndex `? seriously? edit: Turns out the function does something completely different than the docs say it does..
Not to mention how inefficient it is to uppercase the entire string, then only take the first letter... 
http://pastebin.com/aNb5Pqfg
I know what AJAX is but that is not the case(just trust me on this one).Either way I changed the code, now the only thing that I need is to call a variable based on another fetch.
Well I'm glad you got it working to your satisfaction!
Is there a way to bring a value from the database based on a dropdown menu?
Wow this is pretty good, I've always been interested in this stuff, and now it's all in one place. Thanks op!
i think you might be looking for something like [tern](http://ternjs.net/)
Thanks for the tip! I looked at tern but seems like a electron intellisense doesn't exist. Is this perhaps the case for all editors? Can't seem to find a electron intellisense anywhere. Thanks tho!
Visual Studio still has one of the best intellisense implementations that works fairly well for JavaScript. The big alternative IDE is WebStorm (and other IntelliJ based IDE's). I'm fairly sure Atom also has this (or via a plugin). You can probably bolt this on text editors like Sublime via a plugin but this is where the difference between IDE's and code editors comes into play. Note that Microsoft is moving most of it's VS &amp; JavaScript effort to TypeScript (a typed superset of JavaScript). You can get 'addon' declaration files that add type info for many popular libaries. WebStorm can also use these same files to improve it's intellisense for regular JavaScript (not sure if VS does this).
Thanks for the reply! I updated the client code to add an authentication header with: xhr.setRequestHeader("Authorization", 'JWT ' + cookie); and that didn't help.. What I dont understand is why the strategy doesn't even start. I expect the first log to work regardless of what I put in and then fail inside the strategy
http://stackoverflow.com/questions/35274934/retrieve-image-data-from-file-input-without-a-server 
A surprising number of developers are only able to think in OOP terms. Prototypal inheritance throws them through a major loop: thus the purely syntactic sugar `Class` made it into ES6. For devs who are eager to learn more I encourage them to take a look at [the language IO](http://iolanguage.org/)... it's a non-JS language that also makes great use of prototypal inheritance.
Yes, IE8 obviously doesn't know anything about CSS3 selectors. Anyhow, IE8 doesn't support SVG anyways.
Sick!
I like syntax sugar too. Main reason: it reifies (and enforces) the common patterns we are already using in code, thus allowing parsers / linters / compilers to catch errors that would previously slip past. 
Object spread is the best.
TIL Array#findIndex good stuff!
The last time I had to code around this problem, I just used parseInt / parseFloat. Then you can simply do: if(parseInt('string') === NaN) { // Not a number! } else { // number! } Here's a link to MDN for parseInt, it says it works exactly this way. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt 
if you're worried about performance var $window = $(window); var $header = $('header'); $window.scroll(function (event) { if ($window.scrollTop() &gt; 99) { $header.removeClass('big-nav-bar').addClass('small-nav-bar'); } else { $header.removeClass('small-nav-bar').addClass('big-nav-bar'); } }); 
This looks great! I made something similar a decade or more ago, with ActionScript. But this looks much nicer (and more full featured). Very well done!
The reason that NaN != NaN is for when comparing two variables that you think contain numbers but actually contains NaN. If the equality check passes you would think the two variables both contain the same number, which they don't. Not saying that it's a great idea though, but things like this is quite tricky to get right in dynamic languges.
Might be interesting to see TypeScript in Unity. Which, since it is transpiled to JavaScript, will also bring proper JS support to Unity. 
This could be different from any "official" answer but my take is that Number.isNaN should *only* be returning true when it's actually NaN. You wouldn't want an isNull() function to return true for an empty string, same in this case. To work that way just builds extra work into the function without always being useful. Depending on your situation, a better way to handle this is to parse the string (if you're expecting strings) or checking the type or some combination of both.
NaN != NaN is actually part of the IEEE 754 float point number standard, which JS implements. This is not a JavaScript thing, nor does it have anything to do with the dynamic typing used by the language. 
"If you want to know if a number is numeric, you should be checking for that." Right, and that seems to be exactly what plain vanilla isNaN does. But when the author shows that: isNaN("foo"); yields true, he comments "ouch!" as though that's a terrible error. And when he shows that: Number.isNaN("foo"); yields false, he comments "phew!", as though he finally got the right answer. Ordinarily, I'd just ignore this as obviously wrong, but this guy is presumably a guru, and must be making some deeper point that escapes my meager understanding. Why would one EVER want to use the "new, improved" ES6 Number.isNaN instead of plain isNaN ???????? 
happy 808 day!
Vuejs is the best mv framework for you, which is very lightweight and user friendly.
Because large games require memory control, CPU/GPU performance, and compile-time errors. JS doesn't give you memory control, it's specialty is not CPU/GPU performance, and it doesn't compile so you're stuck with runtime errors only.
I see what you're getting at, but "foo" is not a NaN, it's a string
is it actually impossible to have name clashes? require('foo') is 100% without fail guaranteed to be foo v1.0.0?
what's wrong with for ... in? var mylist = ['a','b','c','d']; for (var x in mylist) { console.log(x); } clean, concise, can break out early, no messing with scope. Downside is no index but easily obtainable with indexOf()
If I'm going to be honest, I think this is standard material even for a non-senior javascript dev/engineer role.
Is anyone really expecting to be writing ES/JS directly when WASM is production ready? Seems like ES8 isn't really going to be very significant to the industry when there are vastly superior langs that will be browser targetable by then. I know this is controversial, but...let's be honest.
They're _mostly_ being careful. It really depends on which features are involved. Object spread is a very simple feature, and you'll note that the current implementation simply transpiles to `Object.assign` calls. Class properties are a more complex feature, and therefore there's a higher chance that _something_ might change. Decorators are _very_ complex, the semantics and spec _have_ changed a few times already, and Babel's approach to them has changed a couple times as well. That's the risk and reward of using not-yet-finalized syntax. FWIW, just about everyone is using object spreads right now, so that one I have no problem recommending. Class properties are used fairly frequently.
You can't. http://www.2ality.com/2014/12/es6-proxies.html &gt; Proxies are shielded in two ways: &gt; * It is impossible to determine whether an object is a proxy or not (transparent virtualization). &gt; * You can’t access a handler via its proxy (handler encapsulation). You can trap `getPrototypeOf()` and return something else, but `instanceof Proxy` is never going to work because `Proxy.prototype` is undefined so you can't return that from `handler.getPrototypeOf()`. You could, however, do something like this instead: https://jsfiddle.net/Lr82xzpm/
Huh, TIL! 
Neat!
Javascript is too dynamic to offer decent intellisense. If you really want it (and willing to put some work into it), you can look into something like TypeScript, which allows to add type information to your code and the libraries you use. The immediate benefit is that your IDE knows the object you use better and can offer autocompletion and compile-time checks that actually make sense.
Let's be honest: way too unlikely to be controversial. ES8 (whether or not it's called ES8 or contains the features listed in the article) will arrive long before WASM anyway.
Well this seems dangerous! NPM install feels like a risky game to play quite this blindly. E.g. http://blog.npmjs.org/post/141702881055/package-install-scripts-vulnerability, https://github.com/joaojeronimo/rimrafall. On the other hand, it does look fun...
Article (written by OP) on performance (as tested by OP) between Node.js web frameworks (with suggested solution: framework written by OP).
Here's one I made a few weeks back: https://github.com/githop/webpack-typescript It uses webpack 2 beta + typescript 2 beta. Key take away - Webpack 2 can consume ES6 modules and tree shake them, Typescript 2 can emit ES5 code with ES6 Modules 
This is true. I probably would not have went with testing and writing the article if I did not have something to say about it in terms of a solution (that is, never would've even thought to look into it). The solution is as you mentioned is just a suggestion. I think the bigger take away is that frameworks don't necessarily always have to have significant overhead, and anyone can write their own solution with that in mind for the future. It's more like a lessons learned, in fact as I mentioned in my article, it wasn't something I expected till afterwards. As I always assumed that frameworks have costs. I think the issue you may have with it is that I offered a suggestion, if I had written the same article without a solution, then it probably would've been fine? So I don't think the rest of the article should be disregarded just because I happen to offer a solution, it is merely a suggestion as you mentioned. I want to also mention that all tests are shown and open source, and how the tests are ran are all described, so anyone can run the same tests if they wanted to. So me testing it shouldn't be an issue as everything is transparent, I mean what else would I write about if I had nothing to talk about or show?
The isNaN function is handy for identifying if strings are potentially numeric or not. When converting from string to number it allows you to produce actual numbers and a fallback instead of sending NaN to your users (worthless).
The developers working on WASM [say that it's 5 years away](https://www.youtube.com/watch?v=iCSAUHpPbiU). Until WASM provides GC and DOM API access, compile-to-JS is a far better option. And hey, compile-to-JS is pretty viable at the moment with a lot of choices. Yet people continue to use JS for some reason. And "before I'm ready for it?" Nice non-sequitur.
I would start by memoizing the isPrime function.
Testing with a plain hello world request seems pretty pointless. Wouldn't the overhead become way less significant in real requests as more time is spent in actual application logic and middlewares?
Found this very helpful.
isNaN is not designed to test if a value is a number type, it is designed to test if a variable has the actual [NaN value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN).
&gt; but haven't gone back to it at all since it's in Backbone Funny...I just rebuilt my wife's portfolio site in Laravel/React because I had started a rebuild about 2 years ago in CakePHP/Backbone, got 90% complete and then got too busy/lost focus to finish the project. Thought it would be easier to just port the backend into Laravel and rebuild the front end in React than it would be for me to remember Cake/Backbone stuff..lol
Thanks for the feedback /u/wreckedadvent. The article was mainly aimed at people who had read [A Gentle Introduction to Functional JavaScript](http://jrsinclair.com/articles/2016/gentle-introduction-to-functional-javascript-intro/), but perhaps had not heard about functors, applicatives and monads. But you're right, I should probably been a bit clearer about the assumed knowledge. It was a bit buried in the third paragraph or so. I think that Maybe is a good 'gateway drug', so to speak, for getting into the world of algebraic structures without having to learn a lot of category theory first.
It's a good point, I tried to point this out too, that 2ms - 4ms extra on every request may not be a big deal, but we (community as whole) have put a lot of effort into speeding up every part of a request as much as possible (for example, server rendering dynamic content). So that's my argument for why it can matter. I guess it's similar to, does minifying your JS script file matter? Or HTML, etc. The amount you save can be translated in terms of time (milliseconds) too. That's for latency on a request though, throughput will always be lower if every request (of varying complexity) has at least 2-4ms of lag on it, which the requests per sec results show. But this also is personal opinion for whether that matters. The main point I think I tried to show is that these web frameworks could've done everything the same way but _without_ the cost overhead. For example, Express could be re-written by someone with the similar feature support, and similar API and be less weighty than it currently is. 
The "need" for it is - if you plan to pre-process your code with Proxies for a set of objects - but dont want to proxy an object that has already been proxied ? I dont understand "why" someone would want to hide ( universally ) if an object is proxied ? 
The thing that is glaringly missing here, to me, is setup for tests. I've been idly looking at how to do that myself but haven't gotten into it much.
http://vuejs.org/guide/comparison.html
I’d do: // "Marks" proxies, but does not prevent them // from being garbage-collected const proxies = new WeakSet(); export function createProxy() { const proxy = ...; proxies.add(proxy); return proxy; } export function isProxy(obj) { return proxies.has(obj); } 
Thanks for all the kind words, it really means a lot to me! This being my first 'real' react/redux project I was worried that I was doing it all wrong :D
VS Code uses typescript for the suggestions (even when writing plain js), so you can install extra definition files, in this case https://www.npmjs.com/package/@types/electron See https://github.com/DefinitelyTyped/DefinitelyTyped and http://aka.ms/types for other libraries/projects
WASM is definitely not production ready 
Not nearly as shiny, but I made a vaguely similar thing a while ago - [nimm (npm install missing modules)](https://www.npmjs.com/package/nimm) - that wraps the node binary in a child process, detects when it fails due to uninstalled modules, and prompts to install. Disclaimer: it's pretty POC-y.
&gt; Yet people continue to use JS for some reason. ES7+ Javascript is a very good language for user interfaces. You don't need speed or strong typing. You need expressiveness. I don't see WASM changing the game too much. It will be used for games and performance critical libraries, for UI I think only fraction of JS haters will try building in it.
Yeah it would get shut down within a day lmao. Super illegal
I said "when."
Would you use it at work or your start-up? Do you know JS already? Do you know any other typed languages? All pertinent.
I only know JS. I've done some Arduino things but that's about it for other languages I've tried. Everyone seems to like types in general and I see some projects I like on GitHub being rewritten in TypeScript.
Honestly it's not a dire must-have, but learning it and utilising it can be very helpful in certain environments (if you have a team of mixed skillsets, TS can provide a middle ground for frontend primary and backend primary developers). It's not going anywhere and frameworks like Angular 2 are TS-optional, so you're under no immediate pressure from the industry to learn it. Edit: In short, it's only as necessary to learn as your immediate needs require.
It's a valid point, but is undermined by the data supporting it. It would be much more realistic (thus more convincing) if the number is based on a typical request load, e.g. rendering a page with a set of commonly seen middlewares. So the number may drop from 100% faster to for example 30% faster, but it becomes more relevant.
You should learn JavaScript fundamentals, first and foremost. Once you've done that, learning TypeScript is a relatively quick process. If you plan on starting projects, I would recommend using TypeScript for anything non-trivial. For me personally, the value of compile-time type safety is worth the additional tools required.
If you know JS, you can literally learn TypeScript in an hour. And I see that you also have some experience with Arduino (C/C++), so you already know the basics of a strict typed language.
Hmm so you mean, while in full screen mode, change the user's host OS screen resolution? https://github.com/nwjs/nw.js/wiki/Screen SHOULD work, I haven't actually tried myself but I'd be very interested in the results! 
`Infinity` is a perfectly valid value if you were to implement a calculator app and user ends up entering `1/0`, so it is entirely contextual. How would a compiler/static analyzer know that `Infinity` is invalid in your program? 
Right, that's the academic view. But I don't care whether a variable contains "NaN". I want to know if it will blow up when I do arithmetic on it. That's what window.isNaN tells me, and what Number.isNaN doesn't tell me. What is a reasonable non-contrived situation where window.isNaN would get me in trouble, but Number.isNaN would save me? 
I just started using it this year on a couple of fairly large projects. Though I was initially hesitant, I've grown enjoy it. The IDE support makes refactoring much easier and foolproof than before, in terms of preemptively highlighting possible bugs. One great thing about TS is that you can use it incrementally - if you're pressed for time or don't know all the advanced features of it, you can just type things as `any` or let the TS compiler infer the types for you. Then, you can progressively add more TS whenever you want. I say that it's well worth it spending a couple hours one night running through the Hello World on it and setting up the compiler into your build process.
I've actually found it easier to train people who previously lack app development experience rather than existing web dogs. "Can't teach an old dog new tricks" or at least it's harder lol
Damn needed this a couple of months ago... Ended up building a typescript boilerplate for me team cus have the people are on windows
**There are many other JavaScript DI frameworks. Why another one?** Good question - half a learning exercise. I've also yet to find another actively maintained JS DI framework that fits really what I'm looking for. I've tried hard not to make the barrier to entry to high - there's no central service locator, and in testing, modules act as normal ES6 classes. **Is this necessary?** Maybe. ES6 allows destructuring of an object passed to the constructor, which can store 'default' values, as described [here](https://www.reddit.com/r/javascript/comments/4wmamt/i_wrote_a_simple_dependency_injection_system/d68es4m). This is a good pattern, but can get complicated quickly as your app starts to grow. Not only do you have to maintain large constructors which just bind arguments to *this*, there's also still the instantiation and ordering to worry about. LentilDI does all these things. That said, this is primarily a learning thing for me; there are other good, more mature frameworks out there for this kind of thing. Please let me know your thoughts :)
This is really impressive. Well done! Did you generate all the drum sounds using web audio synthesis?
NaN in Javascript doesn't mean 'anything that isn't a number'. It's a term used in the context of floating-point arithmetic where it denotes a specific floating-point value used to represent undefined numbers (such as the result of division by zero). I would assume that the purpose of isNaN() is specifically to check whether a floating-point value is literally NaN. Generally speaking, if your code isn't even sure whether it's dealing with strings or numbers, you probably wrote the code wrong to begin with. But if you did need an isThisActuallyAValidNumber() method for some reason, there's nothing stopping you from writing one yourself.
React.
Part one is [here](http://eli.thegreenplace.net/2016/a-polyglots-guide-to-multiple-dispatch/).
React is more modern than Angular 1, for sure. But modernity may not be what you want starting out because it comes with a lot of tooling and complexity...but non-trivial Angular projects also have tooling and complexity, maybe even outdated tooling, which is worse...
I think my attempt to make the example simple, ended it up making it more complicated. Sorry, I was trying to express a case where "Infinity" was supposed to be an unexpected response, it was simple to show how even a such simple example could benefit from first-class support for validation, but I should've mentioned that assumption. Just imagine a more complicated example where you don't want certain inputs, in the same way I don't want 0 in mine I should edit the question to say that it was answered already with all the comments, assumed this would be off /new by now. Thanks. 
Yes. You need to learn all you can. Every day for the rest of your life. I would never hire someone who wanted to learn only enough to get a job. 
NaN is not a distinct value. It is a category of bit patterns that do not represent valid floating point numbers. It is agreed that NaN will never equal anything. 
For example, if you use a hex editor on a .obj or .class file, you might see "0xDEADBEEF" on an uninitialized float. 
Going back to your original verbiage of "value validation", that is actually not possible in some scenarios without running the program. But running the program basically makes it a "computability problem". For example, if I were to write a compiler, how do I know the source code input is valid? (Assuming the definition of valid is that it is a program that won't crash) Beyond static analysis, the only solution is to execute the source code. However this could quickly lead to the "halting problem" (infinite loop), which is an "undecidable problem". You might think that a compiler to be super complicated and your regular web application does not behave the same way. However, whether your application is a compiler or not, remember all applications take a series of inputs and produce a series of outputs. If it is complex enough it eventually would encounter those same set of problems. How would you know that a series of user input would not put your program into an invalid state? For further reading on this you could look up * "undecidable problem" * "halting problem" * "Godel's incompleteness theorem" 
To add to this; TypeScript provides a way to provide more structure to largely-scalable applications. I work on an application that is one of the largest Angular apps in the world, and I wish I had TypeScript every day. That being said, if the next version of JavaScript decides to incorporate TS features then TS will go the way of the dinosaur (See: CoffeeScript post-JavaScript2015). I'd say TypeScript is worth an afternoon spent fiddling around to learn the core fundamentals.
Out of curiosity I checked what Python's numpy's isnan function does with 'foo': it raises a TypeError that it is not implemented for strings. 
I should have added [Xpost from https://www.reddit.com/r/learnjavascript/]
You might be right! My point of the title is that junior roles might not be expected to know ALL of this . .. but then our different views might just be based on the fact that "Senior" titles vary a lot. Maybe I should have just called it "experienced?" 
Typed JavaScript is awesome, and well worth the investment! While you're at it you should try out https://flowtype.org. I'm on the Flow team and if you have any questions you can feel free to reach out.
Typescript is an investment but it pays off and many ways. Better tooling support (find all references, go to definition, refactor, errors, autocomplete), self documenting code with types and interfaces, intent is communicated better if your working in a team etc.. The list goes on.
also try to look at gaming libraries like phaser js and/or gameJs
I would say based on that, a very specific use case, not super common in "normal" front end development 
i like it, make sure you know OO programming concepts pretty good though in my opinion.
If your goal is to `start up a company` in the near future, then it is probably not worth investing your time on this right now. There are many other skills in making a company that would be a better use of your time. For example: * How to break up work * How to estimate cost * How to delegate * How to fund raise 
As a person on the TypeScript team, knowing OO concepts (while helpful for any programming language) is not a must. In fact, we use few to no classes within the compiler. The real benefits to the language are in the types, making the language amenable to whatever style suits you.
That's insane, I love Flow! How do you have a job working on tools I love using. I'm jelly
I asked there, they said not possible, but added as a feature request, they will see what can it be done
Yes but why Typescript in the first place ? I can achieve a similar, and I can argue a better and more inclusive outcome with Babel + Flow. Also typescript tooling is great and all but it is specific. There is a TS linter, a TS compiler, TS stuff... But out there, are tons of Javascript tools and libraries that will integrate and work without any extra pain if you stick to Javascript and Babel transpilation.
Vs code is pretty cool, join us
And instead of pokeballs we'd be throwing pokedicks
Because in this horse race, popularity matters. 
If you have a problem with installing plugins, then yeah, Atom is definitely not you. That's kind of the entire point of that editor. It allows super easy customization, even if the base editor is maybe not that powerful out of the box. On the other hand, why would you have a problem with taking 4 seconds to type "apm install typescript" into a terminal?
I'm actually not sure which of those two categories it'd fall in, because I'm not really experienced with this, I'm just learning and playing with Node/React/Express right now. It's a simple little CRUD application and my intent is that it'd be a SPA, where you only make the one initial pageload, and the various views (List, Edit Item, Add New Item, Item Info, etc) would be just things swapped in and out on the client side with no server interaction/new pageloads -- just patch/post requests to the JSON API to add and edit items. I am more familiar with Rails though so Sails sounds like a promising entry point to the JS world, I appreciate that tip.
It has nothing to do with academic views or not. Kyle Simpson is saying that window.isNaN sure SOUNDS like it is going to check for the NaN value, but it actually checks if the input is a number type (which you do want in your particular use case you outlined) He is making a point that MANY developers have mistakenly used window.isNaN because they didn't understand what it was doing. You understand what it is doing, so you are fine. Use window.isNaN for checking numeric values, use Number.isNaN for checking the NaN value. 
&gt; if the next version of JavaScript decides to incorporate TS features then TS will go the way of the dinosaur Even if TypeScript features made it into ECMAScript, that would reinforce that you made a good investment in learning TypeScript, wouldn't it?
There are dozens of us dozens!
yea src/backend src/frontend is what im using atm. just keep it simple. if you dont have another top level directory optionally dont use `src/`. optionally avoid nesting directories unless you have N+ files in each folder you could break it down via how many build steps you have, i use templates so `templates/ backend/ frontend/` with a build.script in each is perfectly ok. if you have lots of js and use es6/coffee and `js/` as a top level is fine too. (optionally put the stuff that requires a seperate build step away from t he deployment stuff) if you have fewer static files you could even do `static/ src/` and thats it my 2c 
I guess I'm not sure why you think that TS codebase turns into a legacy app at that point. Part of the reason you started using TS was for design-time tooling and error catching, right? Why would you want to lose that just because your runtime started allowing optional types? Edit: Hope I'm not coming off as confrontational, I just wanted to get a better understanding of this perspective.
I'm using a layout like this: /lang /src /app /actions /middleware (this is Redux middleware) /reducers /sagas /ui /admin /login /shared /shell / ... each page or area has its own directory with a /components and /containers subdirectory /client /server /api /data /middleware (this is Express middleware) /util /tasks /typings *client* is code that strictly runs in the browser, *server* only runs in Node, *app* is shared because it's a universal/isomorphic web app, *lang* has translation files for i18next, *tasks* has Gulp tasks, *typings* is all the .d.ts files for TypeScript. I'm using webpack with separate configs for client and server... and one master config that pulls in client and server configs (e.g. so you can watch the master to pick up changes in either)
That mobile layout was quite the ride. DOPE write-up. I've been looking for functional js articles that focus more on coding process and you seem to have read my mind. 
It takes more time to learn the Typescript Tooling environment (tsconfig, typings, module loaders, ..) than it does to learn the language. Especially if you have a background in OO programming.
Just my two cents worth, but, most of my development is html/css/js, with HttpHandlers (ie, ajax) in C#. I push most of the processing intensive work into the HttpHandlers, which return either JSON serialised objects pretty much ready for use, if not outright HTML ready to be injected directly into the page. I just do not see a lot of use for classes in the UI. By the time you get to the UI, data processing and manipulation should be done. Again, just my opinion.
I'd rather want to replace Javascript with Lua instead. Just look at how small LuaJIT is compared to JS engines like V8, and how amazing its performance is. I realize that this has no chance of happening, given how ubiquitous JS is, but technically, Lua is a better choice. 
Shadow DOM vTheOneAppleAgreedToShip
Honestly, typescript is imho very uninteresting to learn. Sure, it's useful. But it's so similiar to javascript and other "normal" languages such as java/C# etc so you are not actually going to _learn_ anything. Let me explain what I mean before you stop reading right there. Of course you are going to learn _something_, you are going to lean typescript. But in my experience learning another language that are in the same "family" of languages doesn't really make you a better programmer. You have just learned another set of syntax and standard libraries. And while that can be useful it is also something that is quite easy to just pick up as you need it. If you truly want to develop yourself as a programmer and learn to look at problems from a different angle and improve your problem solving toolbox you should look at learning languages that are in different language families instead. It will be harder, but you will evolve much more as a programmer while you are doing so. I suggest looking at for instance Elm or ClojureScript. They may not be skills that recruiters are looking for, but as said - if you know javascript you can probably pick up typescript in a couple of days. However learning to think about and tackle problems differently will help you improve as a programmer - and that is what you are going to do by learning something like Elm or ClojureScript instead.
Nice.
Questioning the investment to learn a language/syntax is a sign that you're of the wrong mindset. TypeScript could take maybe an hour to get the gist of, if you know JavaScript. JavaScript may take a week to get the gist of once you understand the principles of programming (loops, conditionals, data structures, types, OOP, etc.). Just dive into and swim in literally any language. Wander among them if you're curious or get bored. Eventually you'll hit that critical mass of understanding the principles of software engineering that it's no-longer about "which languages do I invest in", it becomes having a keen eye for which tools are right for which tasks, and how you would approach a task.
If you only know JS then you will (and should) get orders of magnitude more benefit from learning a very different second language than you will from learning a different dialect of the same one like TS. It's not unfair to say you aren't even a good general programmer until you know at least two or three different languages to a high level (because every language introduces you to different concepts and tools and idioms that improve the way you conceptualise and solve problems in *all* languages). If you already know JS and want to learn a different language then you really be looking for something substantially different (like Python, Ruby, Java, etc), not minor variations on a theme like TS.
this is probably more of a longer term goal.
Sails is definitely a great entry point to working with express and NodeJS. It's a very opinionated and feature rich framework which makes it great for beginners and personal projects. 
TypeScript - a minute to learn, a lifetime to master. No, just kidding. It's very simple to understand. At the moment it's harder to learn how to set up typescript in you webpack toolchain than actually using it.
+1 to that :)
Yeah, that's been my finding. Extremely esoteric since arrays and objects are enough to solve the things that need solving 99% of the time. May be good practice (albeit masochistic) for me to try and force binary trees into a number of different JS examples...
what is event emitter? 
Which application?
Tried this already, even tried using `aliases` in webpack, however the HMR part gives me errors :/ Thanks for your suggestion though!
Ahahaha what are you, rain man? Parallel task. Well, then I assume you just shit yourself and stop breathing while programming because well, parallel tasks LOL
What's the error? 
Neither, go with [Vue](http://vuejs.org/) . It is much easier to learn and use compared to angular 1 or react. 
You're trying to get a array element from an object. Latlng is an object not an array (line 33). I take it that your for loop is only for testing?
Neither actually "copies" the bound function. Both just create NEW functions that call the bound function with the right context and arguments. ...though this one sets the context to something less than useful.
I wrote one for a game i made a couplw of yrs ago. But im about to get rdy for work. Ill send this to myself and if no one answers you by the end of day ill post mine to a repo and send a link. I wrote it for android and it takes into consideration multi-touches (what a pain). Now that i remember i reused it for an android app i made called MiTimer. I havent looked at the code in like a yr but the repo can be found at https://github.com/ladams1776/MiTimer/tree/master/wear/src/main/java/com/miproducts/mitimer. I hope thos gets you started!
It's relatively simple to program this. A small div inside a larger div (use position: relative). Then use these events etc: the https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API Auto-centering on release would probably be implemented with a setInterval function.
I don't have a problem installing plugins, but let's not pretend that they are equivalent to built in features.
the for loop is there because that's what was in some of the examples [here](https://googlemaps.github.io/js-marker-clusterer/docs/examples.html)
Why not just use vs code?
I think you've misunderstood how bind work, and why that eslint message is important. Your utility created a new function every time render is called, avoiding this behaviour is the point of that error message. Yes you've managed to silence eslint, but you haven't actually fixed the underlying problem.
I made one myself for a game last year, it might be a bit hard to read cause I was (and still am a beginner) but I liked how it turned out, hope this helps at all [Here](https://github.com/TomNaN/Multimedia_Project/blob/master/Inputs.js) The joystick was made of 2 images, the knob and the base (might have been third too with shaft don't remember really) 
``` webpack: bundle is now VALID. Error: locals[0] does not appear to be a `module` object with Hot Module replacement API enabled. You should disable react-transform-hmr in production by using `env` section in Babel configuration. See the example in README: https://github.com/gaearon/react-transform-hmr ``` Something like that, although it has nothing to do with my env, since it runs in development only.
http://yoannmoinet.github.io/nipplejs/
What if his company has no need for it and never uses it? Most companies and programmers do not use Typescript.
Neat, I would just throw some `user-select: none` and `cursor: default` for non-interactive elements.
Cool, that's what I want. Really easy to add to a webpage but I'm not understanding how it handles the joystick data or how to get the joystick position values.
And it will never be able to compete with innovation and push that React has behind it. Choosing Vue over React will limit your opportunities as a developer, plain and simple. 
&gt;And it will never be able to compete with innovation and push that React has behind it. Or maybe it can? While react does have a lot of innovation and push, it also has a lot of churn. As react and its related technologies are open source, Vue can just not only cherry pick react's good ideas, Vue can actually *improve* upon them before react does. :) So you see while react community can actually arrive at excellent ideas first, Vue can copy the good ideas without trying out the bad ones. On other hand, vue's good ideas like single file component or reactivity are something React can not copy (due to design differences). 
Yeah, it strange to think about a B tree being used in front-end, but I suppose it depends on your needs.
&gt; it moves toward a more object oriented programming style No it doesn't.
&gt; I want to know if it will blow up when I do arithmetic on it. That's what window.isNaN tells me, and what Number.isNaN doesn't tell me. `isNaN` does not tell you that. x = "3"; y = 1; if (isNaN(x) || isNaN(y) === false){ return x + y; } Returns `"31"`. To ensure you end up with numerical operations, you need to parse the variables as numbers before putting them in the equation. After doing that, there's no advantage to isNaN(). `Number.isFinite` may be more applicable than either, though -- it catches NaN, and infinities 'blow up' equations in the same way NaN does. Though... to be fair to NaN -- it 'blows up' equations in a sensible &amp; meaningful [though generally annoying] way. If a calculation ends up with a result of `NaN`, it usually indicates a particular edge case in the problem domain, or a specific kind of math error. `Number.isNaN` catches those when they're relevant, and lets you handle them appropriately.
Thanks!!
Most companies and programmers don't use &lt;insert technology of choice&gt;. I make the argument that it's worth using over ES5 or even ES6 JavaScript.
I like it, but if you don't use JS often, or have a dissimilar backend language, I would caution against it.
ES6! This is roughly the same ES3/5: var realDepA = require('somewhere').default; var realDepB = require('somewhereElse').default; module.exports.default = function(args) { args = (args == null) ? {} : args; var depA = args.depA; var depB = args.depB; depA = (depA == null) ? realDepA : depA; depB = (depB == null) ? realDepB : depB; depA.something(depB.value); } Basically, we expect one argument to our function, which we destructure `depA` and `depB` out of. If they weren't specified, we default to our imported dependencies, otherwise we use the arguments that were passed to our function. This allows you to call the function with mocked dependencies in testing scenarios while also allowing your production code to work with the real dependencies.
Classes are part of Javascript. Static typing is beneficial to just about any paradigm.
&gt; http://pastebin.com/AXRzCUer Also, the options must be outside the for loop since they are used by the MarkerClusterer instance.
**Everybody** uses javascript. Relatively few use Typescript.
Also https://devchat.tv/js-jabber Javascript Jabber is as weekly podcast - over 200+ episodes. Even the topics that I think I have no interest in are interesting because of the discussion. Great stuff. 
Using that logic, no one should ever use new tools. After all, everyone is already using the old tools, what benefit could the new ones possibly provide?
I've been going over the examples and code for an hour but I can't make head or tails on how to access the joystick data.
I'm glad people found it helpful! I was just wondering how large the pie was of people who were already fluently using ramda but had no knowledge of even the most basic of functors. In my experience, not very, but I learned before FP became more popular through react and similar.
I don't blog much, but I'd like to think that the things I post have a lasting value. http://gajus.com/blog/ A new blog post is coming later today/ tomorrow about setting up a "perfect" continues integration and release process.
That's more than a library, it's an entire app. Libraries typically would perform 1 or 2 of those features that you're asking for. If it doesn't everything you've said, it's acting as an entire app and isn't flexible enough to be used as a library inside something else.
Well, if you just want a grayscale effect, you can use a CSS filer for that. https://developer.mozilla.org/en/docs/Web/CSS/filter#grayscale() However, if you actually want to mess around with the pixels, you'll need a server. Quickly spinning up a local server is very easy though. E.g. if you have Python 3 installed, just go to the directory you want to server and run: python3 -m http.server After that, that directory will be served over at localhost:8000. If you've Node installed, install http-server: https://www.npmjs.com/package/http-server This one works basically the same.
You can read images/files that are drag-dropped on to the page, or loaded from a file `&lt;input&gt;`. You don't have to read the contents with `FileReader`, you can give them an `ObjectURL` and use that as the image source.
&gt; but let's not pretend that they are equivalent to built in features. I mean.. That's not really an argument, you realise that right :D
I'm going to deviate from everyone else here including the OP. If you are new to JS, get better at JS. Make a real time Web App without any framework or view library so you experience and understand what they are trying to solve. Try to make your own small virtual dom. Make your own small framework or your own module system. Doing this will only help you better understand when to use what. Don't rally behind a tool in the js ecosystem, it's a horrible idea. It goes too fast and there's too many flavors of something. Learn to identify when to use what, and if you have a deep understanding of js it will be simple to pick up whatever you need to. 
Classes are only recently apart of JavaScript, though. And you are right about static typing, but JavaScript doesn't have it while Typescript does. It even has interfaces and abstract classes.
You are doing harm because you're not abiding by the authors rules. Also because you're not familiar with the licensing. Here it is in plain English. What you're doing is illegal. I understand you're trying to provide something the author is already providing for free in a different method, but the online version is the free version. If you want them in PDF form you have to pay, which he directly links to.
I subscribe to [javascript weekly](http://javascriptweekly.com/) as I prefer the weekly roundup format.
Interfaces aren't specific to OO. In fact they help you avoid OO. Abstract classes and private members, ok. But they just fill in some typically expected features of classes that JS couldn't do. Anyway, nothing about the language pushes you toward OOP.
I removed the content by the author's request and apologized.
Hello redditors! I've been using this sort of pattern for sometime but finally consolidated it into a Prototype-OOP and wrote some documentation; and of course a named it (intentionally incorrect) after my favourite antagonist of all time. I generally like this pattern because you can build good structures/models without having to rewrite them for minor changes. It also allows the developer to suggest future integration points in their code without writing documentation or elaborate comments. In general I've implemented this in a few projects and tends to pay off well in the future. This is similar to JavaScripts pub/subs; however this is blocking rather than async (and isn't intended to work with async). Its more intended to allow you change in values or react to those changes (similar to Wordpress's filter API) without using data-binding. Note I do expect there to be some bugs (I didn't test remove() yet ;) ).
Why do you say Interfaces help you avoid OO? Not disagreeing or agreeing, but I can't find anything elaborate on your statement.
A great podcast about programming meta topics is Developer Tea. Great little five to ten minute shows.
Not working on me for Chrome 52 :( Just a black screen with the default HTML text. Clicking or not does nothing. Edit: My console throws these errors on Codepen. &gt; THREE.WebGLRenderer 75 &gt; console_runner-d0a557e….js:1 THREE.WebGLProgram: shader error: 0 gl.VALIDATE_STATUS false gl.getProgramInfoLog C:\fakepath(313,9-30): error X3004: undeclared identifier 'IncidentLight' &gt; Warning: D3D shader compilation failed with default flags. (vs_3_0) Retrying with avoid flow control &gt; C:\fakepath(313,9-30): error X3004: undeclared identifier 'webgl_45daf4aa877f103d' &gt; Warning: D3D shader compilation failed with avoid flow control flags. (vs_3_0) &gt; Retrying with prefer flow control &gt; C:\fakepath(313,9-30): error X3004: undeclared identifier 'webgl_45daf4aa877f103d' &gt; Warning: D3D shader compilation failed with prefer flow control flags. (vs_3_0) &gt; Failed to create D3D shaders. Seems to be related to this S.O.: http://stackoverflow.com/a/37617896/4147290 Which links to this bug: https://github.com/mrdoob/three.js/issues/8161
Because it gives you a way to declare structs of pure data to pass/return from functions rather than a class with a constructor or having methods, encapsulated state, etc. It helps you work with POJOs rather than classes.
Assuming you're on a PC, then you're facing an uphill battle when it comes to testing this in your current environment (at least easily). Here's a couple solutions: 1) you can download a windows-friendly version of Safari (here: http://www.techspot.com/downloads/4184-safari-for-windows.html) and use their debugger/log just like you would in Chrome/etc, but this has been discontinued for a few years now and thus you will only be testing for old versions of Safari (not the latest supported versions). 2) Partition a hard drive, install linux, emulate a mac, install Safari. 3) Hand manage/be aware of all cross browser limitations by utilizing sites such as http://caniuse.com/. 4) (Recommended method) Manage your projects with webpack, install transpilers (like babel), use bleeding edge (like ES6) and don't worry about cross-browser support (except for some CSS-use cases you will need to be aware of/manage).
So, I could either write something like: function getUserBanner(banners, user) { if (userAccountIsValid(user)) { return banners[user.accountDetails.address.province]; } }; function userAccountIsValid(user) { if ((user !== null) &amp;&amp; (user.accountDetails !== undefined) &amp;&amp; (user.accountDetails.address !== undefined)) { return true; } return false; }; console.log(getUserBanner(banners, user)); or I could write: &lt;script src="//cdnjs.cloudflare.com/ajax/libs/ramda/0.22.1/ramda.min.js"&gt;&lt;/script&gt; var Maybe = function(val) { this.__value = val; }; Maybe.of = function(val) { return new Maybe(val); }; Maybe.prototype.isNothing = function() { return (this.__value === null || this.__value === undefined); }; Maybe.prototype.map = function(f) { if (this.isNothing()) { return Maybe.of(null); } return Maybe.of(f(this.__value)); }; Maybe.prototype.join = function() { return this.__value; }; Maybe.prototype.chain = function(f) { return this.map(f).join(); }; Maybe.prototype.orElse = function(default) { if (this.isNothing()) { return Maybe.of(default); } return this; }; Maybe.prototype.apply = function(someOtherMaybe) { return someOtherMaybe.map(this.__value); } var compose = R.compose, prop = R.prop, path = R.path, curry = R.curry; var getProvinceBanner = function(province) { return Maybe.of(banners[province]); }; function getUserBanner(user) { return Maybe.of(user) .map(path(['accountDetails', 'address', 'province'])) .chain(getProvinceBanner); }; var bannerSrc = getUserBanner(user).orElse('/assets/banners/default-banner.jpg'); var bannerEl = Maybe.of(document.querySelector('.banner &gt; img')); var applyBanner = curry(function(el, banner) { el.src = banner; return el; }); var liftA2 = curry(function(fn, m1, m2) { return m1.map(fn).apply(m2); }); var applyBannerMaybe = liftA2(applyBanner); var mutatedBanner = applyBannerMaybe(bannerEl, bannerSrc); ? After reading the article I'm not convinced why I would want the second version instead of the first. 1. The second version required a library (ramda) not required by the first. 2. The second version requires much more code. 3. I would think that any JavaScript developer would understand the first version, but if another JavaScript developer were to look at the second version, and they weren't already familiar with monads/ramda/currying/etc., then they would be frustrated. I think the other developers I work with would take me out back and give me a thrashing if I used the monad version ;-) Can anyone explain why I would want to use the second version instead of the first? That is, what are the Pros of the monad version that override the Cons that I have noted above?
Hmm. I'll have to think about this. Thanks for the answer.
Anyone get the one for the Peano?
how about /r/javascript? 
[promiscuous](https://github.com/RubenVerborgh/promiscuous) is the smallest I'm aware of.
Ah, good ol' IEEE 754 floating point. When you display floating point to the user, you can use the `toFixed()` function, passing in the number of decimal places you want to keep. Note that this will convert the number to a string, so don't do any more arithmetic with it. (3.4444555333).toFixed(2) // 3.44
Thanks!
usually its basic knowledge and trick questions. theres no console (!) and no auto complete, so relies on memory a lot. google `javascript assessment` for some practice tests
Flow has an `init` on the cli? Did babel ever get an `init` for its cli? 
You are the man, found ()=&gt; is not supported on IOS http://caniuse.com/#search=%3D%3E :)
### These are the subreddits I follow daily. - /r/Frontend - /r/graphql - /r/javascript - /r/learnjavascript - /r/node - /r/programming - /r/reactjs - /r/reactnative - /r/tinycode - /r/web_design - /r/webdev Another good resource is twitter. I have my own twitter list, but there's a few out there that are popular that focus on front-end or javascript. Mine is a bit more geared towards React, and general html/css/javascript/spec/browsers. Definitely try to follow some of the big guys at google/facebook/netflix and other tech giants. Most of the people will good blogs will tweet daily. And you can discover from there by looking at their retweets and what not. It's harder to parse, but you get a good dose of daily knowledge.
If you have already found the issue - great. In general, AFAIK all browsers on iOS work with the same engine, so it does not matter, whether you check Safari, Chrome or FF at the first glance. I'd always recommend remote debugging, if you have access to the equipment. Like in Android powered phones you don't have dev tools on the devices. So use an desktop PC/Mac for debugging with dev tools of a browser there (Chrome for Android stuff, Mac for iOS - I'm not very familiar with Windows based devices/environments). You need an iPhone/iPad and an MacOS (Mac Mini for example). Then you can start remote debugging; some [instructions here](http://appletoolbox.com/2014/05/use-web-inspector-debug-mobile-safari/). There are some proxy solutions out there, but I never managed to get them work.
Last guy that did this exact thing had maaaaassssive ego problems (including thinking his code couldn't possibly be amazing), so at least mad respect for not being that. My concern is this; frameworks aren't only measured by their performance, but by their stability, feature set, flexibility, and handling of important edge cases. You have a faster framework - but do you have a -comparable- one? Medium is becoming an awful disservice, in that anyone can do what you've done. Write a thing, then promote the thing as if it's objectively better. And hey, maybe your thing is better. But you've written an article making an accusation that express is -slow-, based entirely on the cases you think express should handle. You haven't really answered what express and others are doing that your framework is not. This gives me few assurances that you have evaluated why this might be. You set out not to reach feature parity, but instead to beat them at your own performance tests. That's not enough for me to switch my codebase over to a new player in the landscape. I need to know you have security covered, that you have memory leaks dealt with, that you support the features I need. And sure, the rest of the article, you try to evaluate framework performance, but the solution for readers isn't always "write your own"... for a lot of frameworks that's a huge cost in time and quality. If I need some subset of functionality of a framework that's bogged down by overhead, sure, I'll rewrite just that subset. But a framework like express? If I cared about performance I'm probably putting express through its' paces pretty hardcore. And if I'm doing that, and evaluating your solution as a replacement, it had best be profiled, tested, and have feature parity. Until then... this article is premature. 
Seems to be coming in Safari 10. http://caniuse.com/#feat=proxy
It is. Nevertheless, I had no way of knowing what was broken or why from the messaging.
Yeah, NX works in Safari 10 and TP. (btw Safari 10 will have a 100% ES6 support I think :)
Nope
A rails like routing system for express 
Wrap everything after the `&amp;amp;&amp;amp;` in parentheses. Edit: function isPresent(root,val) { return root != null &amp;&amp; ( root.data==val || isPresent(root.left,val) || isPresent(root.right,val) ); }
As others have implied, *if* your goal is to work at a startup, then I'd be surprised if they used TypeScript there. TypeScript is more for enterprisey big conservative companies.
giving it a light estimate like that is disengenuous IMHO. Everyone has their individual "pick up" times. Maybe you'll be able to read TS within an hour, but understanding how and what to use where just takes time / patience and practice -- like everything.
From what I've seen Atom is switching away from coffee script. You can contribute by writing plugins in js, or converting existing coffee script to js may even be welcomed.
Thank you, that does work, but I'm still confused as to why. Is my assumption wrong that &amp;&amp; doesn't evaluate the right side if the left side is falsy? I see that &amp;&amp; has operator precedence over ||, so that isn't it. I'm confused :P
&gt; one of the largest Angular apps in the world how big is that? And how do you know it is one of the largest in the world?
Doesn't work on iOS Safari 
Compare it against Babel and Flow first before making the step. You can get actual ES6, 7 and up (future drafts) and static typing just like that. Babel is arguably more feature rich, Flow is arguably the better type parser. Both do one thing and do it well. I have never seen an explanation of why TS needs to ship its own language that has caused troubles in the past if you wanted it to go along with common JS and npm, while now it needs configs and compiler switches to do it.
thanks for this. very clean code. but am I missing something or there is no delay to the next video? I wanna play the next video some minutes later
The difference between your code is that you have `A and B or C or D` while /u/jcready has `A and (B or C or D)`. The difference is more apparent if you add parentheses, your code is `(((A and B) or C) or D)` compared to `(A and ((B or C) or D))`. The `&amp;&amp;` operator only controls evaluation of the second operand, it doesn't affect the rest of the expression. So in your code, since `A` is false then `B` is not evaluated but then `or C or D` is still evaluated.
- @andreysitnik - postcss/autoprefixer author (can be nsfw) - @jordwalke - Facebooker, React creator - @nzgb/@ponyfoo - JS Consulter/Speaker/Author - @legomushroom - mo.js creator - @SaraSoueidan - SVG Expert - @mattdesl - Three.js demos and cool 3d stuff - @JavaScriptDaily - The new js daily - @FirefoxNightly - See what's hitting nightlies without using it - @svgeesus - Tons of huge web contributions including Woff, PNG, and SVG - @Vjeux - Facebooker working on react - @dan_abramov - Facebooker, redux creator - @rauschma - We should start calling this guy Dr. JavaScript - @mozhacks - Follow the blog too. - @addyosmani - Googler, who talks about tooling and dev tools and perf - @burgessdryan - Netflixer, works with react - @viljamis - Web typography - @csswizardry - CSS expert - @LeaVerou - CSS expert - @mrdoob - Three.js creator - @davidwalshblog - the one and only - @rauchg - active js dev - @jaffathecake - Googler, works on Chrome I think - @lukew - UX - @kangax - he made that es6 compat chart - @mdo - Bootstrap creator, Githuber - @paul_irish - Lots of stuff, now Chrome Devtools - @chriscoyier - Css-tricks/codepen - @jeresig - JQuery creator - @meyerweb - tons, huge name in the web - @mathias - Lots of obscure spec stuff, mothereffin unquoted attr, etc - @snookca - Front-end good stuff all around - @beep - invented rwd Sorry they aren't linked lol 
True it's probably just the style of my team actually