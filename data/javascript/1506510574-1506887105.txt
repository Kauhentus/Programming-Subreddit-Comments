I haven't said lock/freeze on a certain spec. I said stop trying to turn js into something that it isn't, or shouldn't be. &gt;If anything, this is a push to make JavaScript more convenient for functional programming paradigm. And that is why I'm against the entire thing. Functional is nice and all, but I'd rather have readable code than a jumbled, syntax-syrupy mess. &gt;Syntax sugar has value Yes, the Elvis operator, and such does. This does not. It replaces one boilerplate for the other, and it makes one heck of an exotic call chain. "Get with the time, gramps" I can hear you utter it already. &gt;Almost anything new in JavaScript is syntax sugar ...rest operator, splatting. Those are hardly nice to work around, and are legit concerns. However, method chaining and calling in sequence is already there. Oh, I have to type 3 more characters, I cannot code golf my job's secured place into the 31st century! The horror! &gt;You don't need arrow functions, I still am resistant to using arrow functions, because I realize naming things is well worth the effort, among other things. &gt;Your code is more focused on intent, than repeating the same technical details to accomplish it Yes, and less readable if we go by every single "good" thing other languages do, and we "like, totally should embrace, guys *sips starbucks*". &gt;previously inconvenient patterns that required excessive boilerplate become more convenient and developers get more viable solutions to whatever problem they are trying to solve. This is adorable. Less verbose syntax does not mean more viable, just less verbose. You can program in Fortran with succinct syntax. You can program badly in any language, with any syntax. &gt;The language already has first-class functions to facilitate it, it's just pain in the ass to take full advantage of it. How? Because you can't write "elegant", "succinct", "non-verbose" code? How much is too much? How much is too little? Simply put, I'm not against good ideas, and useful solutions, but this is just pure sugar with no inherent value. Convenient for functional programming, use haskell or such then. Don't mix unreadable mess syntax into an okay tree.
Be careful you don’t injure your wrist while shaking your cane 
using pipelines, is more like when you think about how to solve the problem: i ll do this, then calculate that, then extract a value, and so on. This will translate to the same thing, when you pipe through functions. With method chaining, you either break encapsulation `a().b().c().d().x().y()` or you create intermediate variables Adding sugar to languages doesn't break them. You don't add "hip", you add ways to express in a more natural and less verbose way, as others (or you) can visualize the "why" and not the "how".
Except ease of hiring devs or finding work.
Why not?
&gt; I haven't said lock/freeze on a certain spec. I said stop trying to turn js into something that it isn't, or shouldn't be. Then what should it be and who gets to decide? JavaScript isn't Haskell or Elixir for many reasons and making it the same would be practically impossible. That doesn't change the fact that functional languages have good concepts that can be adapted to JavaScript, which makes the language more friendly for wider range of uses and developers. Nobody is taking away your for-loops or mutations, the fundamentals of the language remain the same and I can't think of a single genuinely useful thing that would have been deprecated from JavaScript. &gt; How? Because you can't write "elegant", "succinct", "non-verbose" code? How much is too much? How much is too little? If your code isn't readable, it shouldn't pass the review. Functional operators aren't there for golfing or obfuscating code, they are there to make it more declarative. Every team decides for themselves what kind of coding style and patterns they follow and every client should demand clean and maintainable code. If shitty code that's impossible to follow is tolerated, you can hardly blame the programming language for it. It's not like you can't get too clever with JavaScript already and write shit code. Besides, it's quite easy to enforce many good practices in JavaScript these days. Should a form of pipeline or composition operator pass to official language specification and you still think it automatically makes code worse, I'm sure you can set up a linter that rejects use of those operators entirely. I believe JavaScript is a *multi-*paradigm language, for better or worse. To reject improvements that just aid FP paradigm is pretending it's something else. Enforcing use of only a specific subset of conventions should happen at company, project or developer level, not at the language level.
Twitter?
This is cool, but what I'm hoping for is the function composition operator https://github.com/TheNavigateur/proposal-pipeline-operator-for-function-composition
The pipeline operator seems to me to be a very functional concept so wouldn't you want to use it with other functional concepts like currying? function double (x) { return x + x; } function add (x) { return (y) =&gt; x + y; } function boundScore (min, max) { return (score) =&gt; Math.max(min, Math.min(max, score)); } let person = { score: 25 }; let newScore = person.score |&gt; double |&gt; add(7) |&gt; boundScore(0, 100); newScore //=&gt; 57 
Upgrading for me has been a breeze and I'm working on a fairly large project, any specific things you're running into that are a problem?
Maybe I'm not understanding how the `double` part of the pipeline is working here, but from the looks of it I think you can get it to work like F# by using nested arrow functions to fake partial application. add = (x) =&gt; (y) =&gt; { return x + y } boundScore = (min, mix) =&gt; (score) =&gt; { return Math.max(min, Math.min(max, score)) } ... let newScore = person.score |&gt; double |&gt; add(7) |&gt; boundScore(0, 100) Edit: /u/BizCaus also covers how it could look [here](https://www.reddit.com/r/javascript/comments/72pbfs/pipeline_operator_has_now_moved_to_stage_1/dnkra23/?context=3).
Seeing as no one mentioned it yet if you're going to do E2E tests [Puppeteer](https://github.com/GoogleChrome/puppeteer) works like a charm.
Thank you! I'm very humble to be able to help out making JavaScript a little better.
Thanks!
I've been experimenting with a different approach to simplifying Redux. I've ditched action creators and constants in favor of just plain object literals. This is perfectly safe when using either Flow or Typescript, since the compiler checks the actions for correctness. For async work, `redux-thunk` doesn't make much sense. Redux works best when the actions record "what happened", not "what needs to happen". So SERVER_RETURNED_RESULTS would be a good action name, not DISPLAY_SEARCH_RESULTS. If you are trying to perform work in your action creators, you almost certainly have this backwards. For Redux side effects, I prefer solutions that run after the reducers, like `redux-saga` or `redux-observable`. This way, whatever actions take the user to the search page (and there may be several), the saga can handle them all in one place. Actually, even these solutions suck a bit by focusing on actions rather than state. The best solution would be to ignore actions and just notice when the user is on the search page with no results, and start the fetch in response to that. This is how React itself works - it has no idea about Redux actions, but simply does whatever work is needed to make the DOM match the state.
good point. but even then a link to a gist or something would probably favorable, no?
Anyhow, with respect to your library, I do think it encourages the wrong approach by focusing on verbs ("search") rather than events ("userClickedSearchButton" / "userClickedFindSimilarButton"). On the other hand, if somebody wanted to implement Relessjs reducers as events, there is nothing stopping them - userClickedSearchButton and userClickedFindSimilarButton could both call some common helper code to actually kick off the search request. Given this, I actually think your library has potential. It's actually really nice to have a "flat" structure where all the actions types sit next to each other in a single place, especially for smaller apps. It make it very clear what all the things that can happen in an application are. So, while I wouldn't use Relessjs myself (I've tamed Redux overhead in other ways), I do think it's neat, and wish you the best of luck! Of all the attempts I've seen to make a simpler Redux, yours really seems to have landed on an especially elegant approach.
if I see that right, either all streets are considered bidirectional, or none are? ofc we could just go for none, and then make reverse addLinks for every bidrectional streets, but wouldn't it be nicer if we could specify direction for each addLink individually?
I gotchu fam. Called it in another post, Sonny.
You know, method chaining and sequence calling enforces good coding practices. Using such operators does not. Edit: The downvote button is still not the dislike button. ;^)
Love the licensing change
I recall the sad, badly done with {} block to be deprecated as much as possible. Is it even in the newer specs? &gt;I believe JavaScript is a multi-paradigm language, for better or worse. I have nothing against that, on a mostly surface level. The internals of the code, however, I'm more than likely to raise an eyebrow at {sequential, classic JS code} a bunch of pipes {more classic JS}. If it fits, I have nothing against it. The problem is that it doesn't fit, and it's only enforced or asked for because of how other languages did it. Looks good on paper, can be hideous. Fairly sure you've worked jobs that required skimming, maintaining or altering others' code, especially hideous, unmaintainable, unreadable, unfollowable, illogical and slapped together code. You should understand that even with linters, there can be other teams or contributors, that in the end, get into the code, the end product, and mess with everything that's holy. Adding more syntax sugar means people are going to go on a sugar-induced diabetes spree. Yes, linters can enforce things. People also can code with ; at the end of the lines, way over from the last character, in one column. Just because you can, doesn't mean you should. I don't think it makes the code automatically worse. I see the people using it making the code automatically worse, as is tradition of hipstoJS. 
There's a good chance it doesn't work without user interaction. You're trying to just have it do it automatically, but the demo seems to require the user to click.
Just a shitty rehash of this excellent blog post: https://facebook.github.io/react/blog/2017/07/26/error-handling-in-react-16.html Could you at least try to add some value with the blog spam?
yup. It's says it right in the read me... "must be wrapped in a user input event handler e.g. a mouse or touch handler"
Would be great if somebody could send a PR with this info to CRA user guide!
Hydration = your server gave HTML, and we want to boot up a client up "from" that HTML (and attach events to it) instead of destroying it and rendering from scratch.
Awwwww, shit. Thanks guys - I didn't even read it. Muppet. Woo! Truely spooky - =D
Different programming languages entirely. Java runs on a server or operating system and needs a compiler, while JavaScript runs in web browsers (and with Node, on servers). So Java is great for writing an Android app or the data management (API) for a web app, for example. JavaScript is useful for making web sites more interesting. JavaScript's [creator says](https://www.infoworld.com/article/2653798/application-development/javascript-creator-ponders-past--future.html) that "the idea was to make it a complementary scripting language to go with Java, with the compiled language." A nice thing is that once you learn one programming language, a lot of the basics are the same.
I'm getting a law degree before I ever decide to use a js framework again /s
So if I finish with Java in school I can try and also learn Javascript after that and already have some of the basics?
&gt;implying implications Is there an actual counter-argument, or, just ironic Excrementack Exemplar?
Pipelines actually make functional programming very nice and readable, as you can easily discern the different steps in an operation
It still will suck for an existing codebase though, where add is not returning a curried function.
how do you enforce good practices if you use a certrain set of operators? You can run into issues explained here - http://wiki.c2.com/?LawOfDemeter
It would be fairly trivial to just wrap the existing function with a curried version: `const curriedAdd = (x) =&gt; (y) =&gt; add(x, y);`
Excited to give this a shot. Any TS users fire it up yet? How are the defs looking? UPDATE: Defs are good! I got some warnings that were easy to clear up. Some libraries need updates. Normal stuff. Build seems faster.
It would be easier and more reliable to save the starting time whether manually or via a build script. Then when you open the page, it shows the current value: number of seconds since the starting date. That's an artificial counter but 100% reliable even if you close the page. I don't know if it applies to your real use case though
I say it is bloated because they just keep piling shit on top of prior releases, bloated may not have been the right term. Messy? I'm not sure, and again, this is all just in my opinion.
Hi /u/learning2code101, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/only_the_sun, For javascript help, please visit /r/LearnJavascript. Thank you!
yep!
Pipelines and function composition are standard fare in functional programming languages. Method chaining may be common in OOP but that isn't the only programming paradigm you can use in JavaScript. This operator gives you readability similar to chainable stateful methods, but with pure functions which are easier to test and reason about. I prefer this: import { filter, sortBy, take, map } from 'lodash-fp'; const upcomingConcertDates = concerts |&gt; filter(({ date }) =&gt; date &gt; currentTime) |&gt; sortBy('date') |&gt; take(3) |&gt; map(({ artist, date }) =&gt; artist + ' on ' + formatDate(date)); over: import _ from 'lodash'; const upcomingConcertDates = _.chain(concerts) .filter(({ date }) =&gt; date &gt; currentTime) .sortBy('date') .take(3) .map(({ artist, date }) =&gt; artist + ' on ' + formatDate(date)) .value(); With the functional example: - You can take advantage of tree shaking so that only the functions that are actually used from lodash end up in the dist bundle, rather than the entire object with all of its methods - The pipeline is simple and straightforward. No need to think about the semantics of the `chain()` and `value()` methods or how lodash handles the intermediate state. - You can add in any pure functions you want, without having to extend or mixin anything.
If you're using lodash, `_.curry` is an option; it creates a function that can be called both normally or can be partially applied, which makes it easier to migrate from normal calls to partial application.
Very insightful. Couldn't have said it better!
I guess this means we'll be seeing it in TypeScript soon.
[Finally!](http://www.zdnet.com/article/facebook-relicenses-react-in-the-face-of-open-source-dev-backlash/) I'm sick to death of the patents license getting brought up in every discussion about frameworks.
You will only include react.js and all the dashboard associated files in that page.
thanks for the fast reply. The point is: If I have the page A, B and C. I want to mount on C page react. How can I start the mount programmatically in freemaker? I have to wrap the mount function in another function like: function startMount(){ React.mount(etc) } and call the function in the freemarker page?
&gt; you have to know Vanilla JavaScript on a certain level, otherwise you will end up having a hard time debugging right. ;-) or you should be a strong enough programmer that you can learn javascript while learning a framework. Hell, I remember my university capstone I had to learn ruby/rails, javascript/angularjs and css. Oh and figure out how to deploy. Personally, this whole "should I learn the framework or javascript first" question irks me, and I know people will disagree with me, but I think another perspective is good for the silent reader. Some people learn best by doing, so they will want to learn js by writing js, and js is commonly used to write webapplications/websites. However, writing a webapp without a framework is very difficult so you might want to use a framework. And boom now you're at the point where you're learning javascript and a framework at the same time. The other alternative is to learn the DOM API and other associated web APIs at the same time as learning javascript, and that is arguably the far more daunting task. Now, this "advice" only really applies if you have prior programming experience... if you don't know how to program at all then stop thinking about a framework and learn what a function is!
Everyone here has both seen and written bad code, I just don't think someone potentially writing bad code is a good reason to reject good features from a language. Of course someone can abuse pipes to write unreadable mess, but I also think it's a clean, declarative way to run a value through multiple functions. Looks and reads more like a specification "Take this thing through A, B and C" than "Call A with Call B with Call C with this thing" Doesn't take a category theory thesis to understand and I'd argue it's more straightforward even to a layman who doesn't know what a function of a variable is (not that the latter has much value) I'd also argue a feature like that can encourage developers to write smaller and simple functions that are naturally easier to test, which is great. It doesn't make naming and documenting things any less essential, just one way to write things in a more declarative way. The main drawback is that once or twice you may have to Google "what `|&gt;` means js", if it isn't obvious from the surrounding code.
Use `class` syntax and `arrow functions`. Class syntax is for obvious reasons, and `arrow functions` implement a lexical this which will likely be more familiar. 
make a couple simple-ish apps (think todo or maybe a bit more) with different frameworks and pick the one you found easiest/most enjoyable to develop. 
&gt; The main drawback is that once or twice you may have to Google "what |&gt; means js", if it isn't obvious from the surrounding code. I've been preaching against this the whole time, and you validated, reaffirmed my case. I understand the intent(edit: derp spelling), yet |&gt; isn't very descriptive. Yes, smaller, easier to test functions. Which we can absolutely abuse. I rest my case, you even brought my own point up at the end of your post. 
Yeah, well one article is a thin wrapper around the other and plugs it's service, ie it's a glorified advertisement. I'd rather just read the source content. 
&gt; Pipelines and function composition are standard fare in functional programming languages. And you can do that in JS without fancy operators. &gt; readability similar to chainable stateful methods It gives you a view similar to that of a switch -case, C-style. Fallthrough, which is just awful. "but with pure functions which are easier to test and reason about." A meticulously designed and crafted function is just as easy to reason about as a "pure" function which was thrown together under the aegis of functional paradigm ideas. Program correctness is still largely up for debate.
I'd rather read this: import { filter, sortBy, take, map } from 'lodash-fp'; const upcomingConcertDates = concerts |&gt; filter(({ date }) =&gt; date &gt; currentTime) |&gt; sortBy('date') |&gt; take(3) |&gt; map(({ artist, date }) =&gt; artist + ' on ' + formatDate(date)); than this: import _ from 'lodash'; const upcomingConcertDates = _.chain(concerts) .filter(({ date }) =&gt; date &gt; currentTime) .sortBy('date') .take(3) .map(({ artist, date }) =&gt; artist + ' on ' + formatDate(date)) .value();
Highly subjective opinion there, I don't see any infallible, non-stylistic, preferential proof about it. I, for one, dislike it. I neither see the need for, nor want the operator. I only see a "Geee, that sure would be useful for x% of people", with x being way less than ~30%. 
That's your preference, also that's horribly formatted. Reorganize into reusable chunks, then call in a chain - regardless of how it looks. 
You will have a mounting point in the freemarker page C &lt;section id="root"&gt;&lt;/section&gt; And this in the jsx that is included only in that page React.render( &lt;Dashboard /&gt;, document.getElementById('root') ); 
Probably needs to be wrapped in a document-ready callback.
Congratulation on the release :) Edit: you should do an AMA here one day
Might be helpful to work with typescript. 
it takes exactly 1 hour and 23 minutes
Hey man! Haven't you heard of Higher Order blogposts? You gotta get on with the times! ^/s
That **is** the block to check where it is set. If it is set, to anything that is truthy (basically everything other than `false`, `0`, `null`, `undefined`) the `||` will short circuit, and not run. However, if the value of `process.env[name]` is not truthy (ie. when it isn't set), the `||` runs the next statement which is an inline function call which throws the error. 
Ok, I really don't care enough to argue. Just trying to be civilized to other human beings.
It sounds like a global store (Redux, for example) might be useful. Keep cross-component information there so you don't need to couple components by using CSS or HTML identifiers. To avoid store-soup, make sure you stick to the action/reducer/effects pattern encouraged by those types of stores. Audit the Javascript code and make sure you're caching jQuery calls wherever possible (i.e. don't call the same selector more than once within a scope - assign it to a variable instead if you need to do that). In my experience, .net partials have proven to be something of an anti-pattern. My advice is to simplify your usage of them wherever possible.
Sorry Reddit does that to the text, but the program is fine, it's just I don't know how to compile.
this is a javascript subreddit, not java also, in the command line: javac &lt;filename.java&gt; and to run it java &lt;filename&gt;
thanks
thanks
Syntax is subjective for a large part. What's considered readable and what not is subjective as well. Your opinion about this is just as subjective, even though you try to make it objective
Only use 'let' and 'const' since they have lexical scope like most other languages. 'var' does not, avoid it like the plague.
`expression1` || `expression2` can be used as a shorter version of an if statement because of how the `||` operator "short circuits" and only evaluates it's right hand side if it's first operand is false. ``` x = y || z(); ``` sets x to y if y is truthy. If not, only then is the z function called (and then the result assigned to x). The rest of that after the || is just assembling an Error and throwing it. Because `throw` is a statement, not an expression, it can't normally be the right-hand side of an or expression. The author wrapped it in an immediately invoked anonymous function just to make that work syntactically. 
To add to this, never use bind, call or apply as they break this classical oop behavior by changing the value of 'this'.
in the future though don't post java questions here
Got it.
I have nothing relevant to add to this. Just wanted to say, it was nice that you answered their question anyways. That is all.
You're right, my response was worded carefully - because Isaacs' implicitly violent outbursts were also worded carefully, which impacts my reference to the situation. Unfortunately I can no longer access these tweets so, providing credibility for this portion of the debate is not possible. As far as "a position of power", I also believe twitter, or any social media outlet for that matter, do not necessarily constitute a position of power. However, being ceo of one of the two most popular package managers in the non-stop, action packed javascript ecosystem does put you in a position of power, I assume this is what you meant by "higher visibility". Basically, it's not about tweets, its about his position in our bubble. You suggested that we separate the the drama from the tech, and while that's easily done from the perspective of the lone developer, that relationship, or lack thereof, is not likely to be nearly, if at all, compartmentalized on the other end. However, at the end of the day I do agree with you, "change through creation" &gt; "change through destruction". Maybe it just stings some of us a bit when the ceo of an organization we, shallowly, love so much opens up and reveals what we find to be an abundance of ignorance.
**Explanation** It is evaluating an OR condition. * If (A OR B) * TRUE OR anything =&gt; True. * For optimizing most run time environments wouldn't evaluate B when A is TRUE. * In Javascript you have truthy strings/variables. * So, B would be evaluated only if A is false. * B is a function in the code snippet you shared, so when engine evaluates it (calls the function) error is thrown. **Homework** Based on the explanation above, find the bug! 🐞 * There is a situation when a variable is set but error will be thrown. * Is it also possible that a value is NOT set correctly and error is not thrown? **Peeve/Rant** Do not follow this style! It looks clever, L33T, but is a maintenance nightmare! With experience one learns that more time is spent reading code to understand than writing it! It is also hard to evolve, what if you want to check that proxy URL is a valid URL? The code that is written by humans would be turned into machine readable code by tooling... Think webpack or any bundling/minifying tool. If there is a genuine reason that the snippet is better than a forEach block with a nested If, I would love to hear/discuss. *edit* Corrected the formatting hell caused by posting from phone
Sorry. At this point, pipeline is the way for doing pipelining. The bind operator as-is will not happen in my estimation. The method extraction use case (i.e. prefix `::`) is important but can likely be accomplished with better syntax.
Mocha + Chai + [Ololog](https://github.com/xpl/ololog#using-with-mocha) (for better logging / error reporting)
What's the precedence of the pipeline operator?
In addition to what's already posted, don't try to write JS like you wrote your old language. For example, JS is different from C# or Java. The people I've worked with who have struggled the most have been unwilling to adapt to their new language (whether that's JS, Ruby, Elixir or something else)
&gt; |&gt; _ =&gt; add(7, _) That is literally what the spec is suggesting and what /u/ggolemg2 just pasted above.. It is just awkward compared to doing the implicit first arg.
There is also the proposal for partial application which dove-tails with this proposal: const curriedAdd = add(10, ?); add(5); // 15
&gt; better than a forEach block with a nested If This might be better than both variants since it reports all missing vars at once const missingVars = [ 'NODE_ENV', 'PORT', 'DB_USER', 'DB_PASS', 'DB_HOST', 'DB_PORT', 'DB_NAME', ].filter(name =&gt; !process.env[name]); if (missingVars.length) { throw new Error("Missing environment variables: " + missing.join(", ")) } 
But doesn't Webpack do that too? In the Webpack 3 announcement, they mentioned webpack.optimize.ModuleConcatenationPlugin() which supposedly does the same.
Hiya I use the following structure top down IOC -&gt; autofac to wire everything up Site -&gt; MVC shell for angular and web api 2 controllers Service -&gt; all business logic ServiceContract -&gt; service interfaces Data -&gt; repositories DataContact -&gt; interfaces Models -&gt; reverse engineered entities Test -&gt; Full integration tests Utility -&gt; static helpers I have moved out most of my boilerplate code for base objects, factories etc to a library I have on git (let me know if you want a link) Just follow kendo standards for the site and then split out the rest to make sense to you. Edit: looks like I half read it, in terms of the standards simplify, apply consistently, make your pain known to whoever is above you, good luck. Been in that situation, it suuuucks
var absolutely has lexical scope within function declarations. the only difference between var and let is let can limit scope to within curly braces alone without a function declaration. you're thinking of declaring a variable without any keyword, that puts it in the global scope.
- Avoid unnecessary inheritance. - Avoid creating many interconnected classes - Keep classes small - Remember that `class` is only one of many possibilities to do OOP in ES6 (prototypes are as good as classes, and object literals often even better). 
I'll go ahead and take the downvotes here. All the oop guys love Angular, go check it out.
That's too bad. I can't tell you how many times I've had to write something like "this.whatever.bind(this)" or "() =&gt; this.whatever()". Writing "this::whatever" is so much nicer, not sure why enthusiasm is so low for it.
Because of the need to wrap the throw in an IIFE it's not even less characters than an if statement version. I wonder if a minifier would be capable of turning it back into that.
Also weird, because the same code works on my home computers, but wont on my work computer. lol
Nice work - can't wait to try this in a pumpkin w/cellphone
Thank you for explaining it :)
PEAN Stack: postgres + express + angular4 + node
&gt; Based on the explanation above, find the bug! If an environment variable's value is falsey?
Because pipelining is a functional pattern and passing the piped value via this only works for method chaining. There are other ways for method chaining to work (i.e. fluent APIs). Also, fwiw, this.whatever.bind(this) is ::this.whatever in the current bind operator proposal (another reason why I don't like the proposal, this aspect is confusing). Further, you can actually pipeline reasonably using this via the following pattern: let x = [1,2,3] |&gt; Array.prototype.map.call(?, x =&gt; x * 2); 
Just above comma. 
Rather than down-voting, I'd like to see some real rebuttal to this. I'll start: I think you're misunderstanding `this`. The reason for explicitly setting `this` is most often _in support_ of better encapsulation. Here is a good article [explaining the use of bind/call/apply](http://javascriptissexy.com/javascript-apply-call-and-bind-methods-are-essential-for-javascript-professionals/). 
Without a concrete example it's hard to say, but my instinct says static methods will be neater and clearer. In the case of our `Vector` exmaple, rather than `default export class Vector` with a `Vector.addTwo` function, I now have to export / import multiple items from the Vector file. Or worse, import the function from a `utils` directory (this seems a common practice), which creates ambiguity (is the `vector` in `utils.addVector` the same as a `Vector`?). Static methods are easy to use and have an unambiguous relationship with the class they're supposed to manipulate.
Can confirm. OOP guy that loves angular.
OOP guy here, do not like Angular. Love me some React, not a fan of Redux. Am I a paradox? lol 
If you're not writing a library, I think this is rarely a concern. Most projects do not require multiple builds, so everything has to be bundled anyway.
No-one is writing Vector classes, they're just useful for illustration.
lol i love when people just make shit up. arrow functions cant do everything. they break certain libraries if you use them. bind call and apply have their use cases and are still necessary in certain situations.
This seems more like a case for Sentry than Frontend Error Tracking. No alternatives were provided and no examples of how any problems were solved. Sentry has a "free" plan, but any sorta robust app requires a paid plan.
This is an ad
Oh my God. People like you are why I am confident I will always be able to find a job in this field, no matter how out of practice I get.
Let and const are more like oop I was lead to believe. Do you think this is true?
There are other logical operators you can use in a similar way to execute functions (but of course the return values don't work like with `||`): * `y() &amp;&amp; z()` (logical AND) will call `z` only if `y` returns `true` * `y() ^ z()` (bitwise XOR) will always call both `z` and `y` – i like to use this with arrow functions, `callBoth = () =&gt; one() ^ two()`. But it's not standard code style, so use at your own risk :)
Yes, because they give you block level scoping rather than function level scoping. Honestly, I never use var and I'm not necessarily an oop person.
If it's the verbosity of Redux that you don't like then I suggest giving Mobx a try :-)
Ololog really saves the day for me!
Yeah I don't get the var hate. We got some shiny new toys in es6 and all of the sudden function scope is the plague? Honestly this kind of rhetoric comes from people who do not appreciate how brilliant function scope can be.
Everything that I'm reading is saying Javascript isn't an OOP language and to use it as such misses the point of how beneficial prototype oriented languages can be.
It's been answered, but google this mdn foreach There's a few array functions that are.... Weird... At first. Map, reduce, filter are other similar ones. If you're unfamiliar with them, study foreach first, it's easiest, and they all work sorta similar.
Prototypical inheritance is still OOP. It is just not class based inheritance. Javascript is a multiparadigm language.
This drama just makes me love the django comunity even more 
Seriously function scope is a life saver when dealing with callback functions that interact with third party libraries that don't allow you to pass custom data into the callback
I thought I was adding this to the end of the thread sorry. But now that you respond I was under the impression that OO languages utilize classes and they work really well in that scenario but Javascript didn't come with classes because it is PO, and if you treat it as such ends up working much better than classes would in JS. If that's the case even if Prototypical inheritance is still OOP there's still a distinct difference from the two and should not be treated as the same yes? 
That's weird you must be open minded or something.
Weirdly phrased question. For the "any tips for re writing scripts in es6" perhaps you'll find https://lebab.io/ interesting For the "more used to oop languages" check http://exploringjs.com/es6/ch_classes.html
They equally bad than the PePE army at /r/the_donald. Both groups just become a parody of themselves irrespective of any rationality. 
yep, djagno comunty is pretty great. Actions speak louder than words
Tl;dr **It's still a shitshow**
Functions as first class citizens (callbacks) is one of the best features along with it's scope.
I'm happy I never left django-python
indent code blocks with 4 spaces I indented this by four spaces
I mean, there already are way too many articles about map, filter and reduce, why do we need another one? .__.
Thanks I am not using cra but I stumbled upon a jest config for test startup scripts and got it working. 
I'd certainly be interested, not sure about availability/commitment though. I organized a web audio meetup in Philly 2 years ago along with /u/kylestetz, before we both moved to SF -- I know he had been talking about doing something in SF back then, not sure if he ever did.
&gt; Prototypical inheritance Minor nitpick: it's "prototypal inheritance," not "prototyp**ic**al inheritance." For /u/marstheram or anyone interested in learning more about prototypal inheritance, I think that the MDN article, [Inheritance and the prototype chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain), is really helpful in understanding the basics.
So exciting! I really want this operator which is especially great with ramda and additionally with static type checking such as flow &amp; typescript. // instead of ... const propOf = flip(prop); const getColor = compose(propOf(COLOR_HEX), defaultTo('red'), prop('color')); // it could be written as... function getColor (model: { color: string }): string { return model |&gt; prop('color') |&gt; defaultTo('red') |&gt; name =&gt; COLOR_HEX[name]; } 
I see why you might think that but I assure you it is not. The main point of the article is that you should use frontend error tracking. You can choose from many tools, here you have a list of tools with free tiers https://github.com/ripienaar/free-for-dev. Other examples for error tracking that I see on the list are: rollbar.com and bugsnag.com I mention sentry because I use it and because it has a free tier that allows you to do a lot. This is what allowed me to try this in the first place with very little effort. I also give it as an example because I don't want readers to be paralyzed by choice. With a free choice you can try it in personal projects or you could even try it in your company (if the products free tier allows it) without requiring a budget approval. Thank you for your feedback. I'm sorry if I sounded "salesy", it was not my intention.
Thanks for the correction, I was a little to hasty in my response. I'm actually reading this little break down between class-based vs prototype-based OOP as well. http://www.datajett.com/Tuts/JScriptGen/JSObjectModel.pdf
My vote goes for DONT! Learn JS for what it really is. You will be well rewarded for taking a more functional approach, that imho fits JS a lot better than classical OOP does.
&gt; You can add in any pure functions you want, without having to extend or mixin anything. This. This is the real killer feature. With method chaining you're stuck with only the methods the object provides. With pipelines you achieve basically the same thing, but you can throw whatever you want in there, whether they're your own functions or imported from another library. Using the chain from lodash is great until you realize you need to throw your own custom function in the mix, and then suddenly you need half a dozen intermediate variables
I mentioned sentry to provide an option so readers could try it out with as little effort as possible. I don't give or compare alternatives for two reasons: 1) that is not the point of the article. 2) I don't have experience with a enough variety of frontend error tracking tools to provide valuable insight. I don't claim sentry is the best or event one of the best. I claim that sentry (and probably almost any) tool is better than having nothing. I also disagree with your comment "any sorta robust app requires a paid plan". For example, B2B can have a low number of valuable users and be successful businesses. Not all tools are made for a very high number of people. Those cases with a lower number of users can be accommodated by some free tiers. Even if the free tier is not enough to capture all monthly events you have, it might still capture enough to allow you to improve the app. btw here are alternatives I got from a quick search of https://github.com/ripienaar/free-for-dev: rollbar.com and bugsnag.com 
Testee with qunit! 
You are right, I did not provide examples of how any problems were solved and that would have probably made the post more compelling and relevant. I do have examples but they are not "exciting" and might be too specific to the applications to be relevant, so they would not be so interesting. Thank you for the feedback.
Pipeline is much more powerfull and simple. no need for 'this' just input and output. 
Oh shoot, that's my fault. Shouldn't post comments just after I've woken up. What I meant was the process of passing/sending data from the server to the client.
Just FYI it's println not print1n
To be fair, Angular 2+ almost forces OOP, so it's an easy thing to get into.
its*
JavaScript is very much a functional language, and you can write very expressive code using just functions. The pipeline operator makes it very easy to follow the code and makes refactoring super easy. (add(double(validate(notify)))) // wrong exec order add |&gt; double |&gt; validate |&gt; notify // right exec flow The above should demonstrate how easy code can be read. The added benefit is when you can pipe easily code will be written in a more simple way. Makes testing super simple, and most likely also generates less bugs. 
I can write blatantly wrong code too, oh and watch, I can also write it the same as with pipe, but less so. notify( validate( add( double( x ) ) ) ) Or even: var score; score = double(score); score = add(score); score = ... You get the idea. Absolutely stellar. You're arguing the wrong thing, it's almost akin to strawman. &gt; The pipeline operator makes it very easy to follow Maybe for you. I have to keep going back to the top to see what the hell is going on. Nobody should read backwards after going a bit forward, it breaks the flow. &gt;Makes testing super simple Lolno.
I would go for compose too, but in my daily work i never "ad hoc compose functions", in the same way i would use the pipeline operator. Composition (imho) always requires more thinking and business logic, so i dont see it as usefull as a native operator becase of this. Pipelines are "dumb" and dont really need that much "thinking" in how the code behaves. Just inputs and outputs.
&gt; Syntax is subjective for a large part. What's considered readable and what not is subjective as well. Your opinion about this is just as subjective, even though you try to make it objective Doesn't make this proposal more sensible, or less subjective. I'm factually saying it has no real use case, other than minor convenience for a select few who like doing hipstoJS. Hipster somewhere else. 
You still sound super salesy
Ah damn you are right - i am not a native speaker, I suppose my brain played me a trick here. Thanks for pointing out my mistake :)
You're right, I also thought of that :) I guess I need to work on that. Regardless, the main reason to trust that this is not an ad is because it would be a dumb one. Talking about a free plan is not a good way to get paying customers. 
You have a point
You mean to tell me I don't need lodash after all?
My experience is that it's a shitshow in pretty much everything. 
I'd also add `find` and `findIndex`. Very useful array methods.
/r/titlegore )
Using html2canvas and canvg (SVG to canvas) you can also use canvas2pdf to make client side pdf screenshots. It's not as streamlined as you'd want it to be as html2canvas doesn't support all CSS properties. But most clients I've implemented this for were ok with wat we could offer them that way. And preferred that type of print out opposed to the print page functionality of the browser.
&gt; and all of the sudden function scope is the plague? It always *was* the plague. It was also the only way to do things at the time. var was a mistake from the very beginning.
&gt; Everything that I'm reading is saying Javascript isn't an OOP language It is. https://en.wikipedia.org/wiki/Object-oriented_programming There are objects with fields and methods. There is some concept of self/this. Boom! OOP.
&gt; Learn JS for what it really is It's multi-paradigm. OOP is one of the things it covers.
Interesting, How do you share data across components, especially when you only want to share a subset of a viewmodel's fields with another component that may have its own viewmodel? 
This is probably true, though day-to-day--and especially with the introduction of syntactical sugar for classes in ES2015--if you really want to work with JavaScript using class-based paradigms, you can kind of do that. The biggest frustration for me has always been working around not having protected/private properties. Not the end of the world, though--it can be done. Kinda. In general, though, I do think that it's a good idea to push classes out of your mind when starting to work in JavaScript, and try to embrace prototypes. Heck, since Object.create made it into the language, I don't even use the "new" operator anymore. I like to reason about my objects the way that JavaScript is reasoning about them.
Your "facts" is just your subjective opinion, if you can't see that I'm not sure what else I should tell you. Anyway as you are devolving the discussion into childish name-calling, I'll just stop here.
Learned a lot from their process. Impressive :)
I think it would be totally fine to mention Sentry if you at least compared it to some other options. That would be helpful and a good contribution to the web dev community. What this is is saying "You totally need to do this, if you aren't it might already be too late, and here's the best and only way to do it".
This code is much more readable. The functional upgrade is nice, too.
&gt; I only see a "Geee, that sure would be useful for x% of people", with x being way less than ~30%. I don't see any infallible proof associated with that percentage :)
Because nobody else has fully explained it yet: (() =&gt; { throw new Error(`Missing environment variable ${name}`); })() Is called an immediately invoked function expression (IIFE). Let's simplify it: (function(){ throw new Error(); })() When this is run it creates a new function which returns an error. By wrapping it in parens it becomes an expression and because the expression is just a function, the final pair of parens executes that function.
u need to wash ur mouth out with soap
Very true. I should have said Javascript wasn't and shouldn't be a class-based OOP. It is a prototype-based OOP.
Couldn't disagree more, but if working with block scope makes programming in javascript easier for you then more power to you. Again prototypical inheritance, first-class functions, and function scope (closure) are what make javascript an incredibly powerful programming language. Thinking that it is a plague is just ignoring all of the awesome things that javascript accomplished before "let" was introduced.
Yeah with ES6 you can definitely accomplish the class-based paradigms. As far as the protected/private properties go, is that not what closures accomplish? 
spent 5 minutes on your site and still couldn't figure out what the library actually does. no one will ever use it if they can't even figure out what it does. good rule of thumb is, if you're writing a public library, for every hour you spend coding, spend an hour writing documentation.
There is a `class` keyword and engines use actual classes to stamp out instances, though. It isn't exactly "classless". There also is no "clone" method. You don't create new instances by cloning objects. So, how prototype-based is it really? That side is incomplete whereas the class side will get further extended in the future (e.g. field declarations and privacy). Personally, I'd say that it's nowadays effectively class-based *plus prototype chains* (which most people ignore).
I stand by what I did, comparing tools is outside the scope of what I wanted to convey. I don't say sentry is the only option, I say it is what I usually use (and that is the truth). I don't think it matters so much what the person starts with, but more that they start using a tool, and for that there is nothing better than a recommendation even if it is not the best one. If you read the "Main takeaways:" in the beginning of the post you can see there is no mention of sentry, and that is by design. After they start they can decide for themselves as they get more experienced if whatever they chose is fulfilling their needs or not. And as you can see it takes very little effort to chose something else if you are not happy with your first choice. The point of the blog post was not to say sentry was the best choice (I would have put sentry in the title if that were the case) or to compare tools, but to share the reasons readers should be using a tool, and giving them an example of how simple it is to setup. A comparison would probably lead most users to choice paralysis or a bigger investment of time in setting this up by having to dig deeper in the pros and cons of each. In other, words a comparison would not take 3min to read and 10min to setup, so it would defeat the whole purpose. At most, I can edit the blog post to make it more clear there are more options and sentry is just an example. But comparing them is a separate topic imho.
I wasn't saying it is currently classless, just that when it wasn't written with that functionality from the start. All objects are instances and since no two objects are the same in javascript it would seem that you do create new instances by cloning objects, so it is VERY prototype-based. This isn't something that is debated, javascript IS prototype-based.
Blast that code with console logs
&gt; and function scope (closure) You're confusing concepts here, I think. I'm not complaining about closures. Closures are awesome and I could never live without them. Var, specifically, is bad due to hoisting. No matter where you declare it in your scope, it's hoisted to the top level of the function. This is bad, because it doesn't let you reason about your code hierarchically, and introduces subtle errors down the line if you re-use variable names and intend for them to have a separate scope. let and const are awesome specifically because they reduce the scope of variables and keep code more localized. Now I'm sure you can make an argument that your functions should never get so large that this becomes a necessity. And you'd be mostly right. But. We unfortunately live in the real world where code ends up being maintained by newbie devs far down the line, who will almost certainly end up making silly mistakes with code design and re-using var names, and javascript not telling them what a horrible subtle mistake they're making. Let and const don't solve the issue on their own, since var still exists, but luckily now we can make es/tslint rules to disallow var's usage anymore on new projects. Var was a plague. JS had many great parts. But var was not one of them.
Hey I never said that I didn't want it, seems awesome. Just that I feel there are more important syntax additions
Does this help? https://stackoverflow.com/a/2140723/1695393 
&gt; but once you get used to it you will always prefer it to loops. Completely incorrect. `Array.prototype.map()` is incredibly slow because of the element checks it does to make sure the element is iterable. If you know/don't care about the difference between sparse and dense arrays, a `for` or `while` loop implementation will be orders of magnitude faster. 
Well, private properties, yes--you can do that with closures. It's just a bit different from how you'd do it in a class-based language, so it takes some mental adjustment. They're not properties of the object in other words--merely scoped variables. Protected properties? Not really. I've sort of faked it in the past, but it takes some work.
If you know one framework you can pick up any of them.
they're getting crowded out by all the articles about prototypal inheritance and how all of JS sucks because stupid things happen when you use double equals for comparison.
Redux is great if you're a functional programmer. It forces you to reason about what actions your app can perform at a much higher level, and provides a nice abstraction that provides protections with its pure-function paradigm. It's not applicable in every situation, of course. There's many apps where it wouldn't make sense because you'd explode the complexity of your code. But anything where you can count the number of "actions" a user can perform on a screen on both hands, Redux makes a lot of sense. 
Side note: the link to the 1 part ("in my last post...") looks wrong to me ;)
I would think that those issues about hoisting arise when function scope isn't fully understood. Hoisting can be good when it comes to functions. I bring up closures for the very same reason you bring up re-using variable names that have a separate scope. Again if function scope isn't understood it's understandable how two vars with the same name can end up updating each other with unwanted results. I understand that let limits the scope which is why I say if that makes writing javascript a more efficient task then, by all means, incorporate whatever is going to help you build things you love. Personally, I can't get on this plague business simply because javascript was already incredibly powerful before they implemented block scope. You would be right however in saying that I would say "functions should never get so large...". I love functional programming. If var is a plague because junior devs don't understand functional scope, then the junior developers that don't understand it are the plague, not function scope itself.
1. You can't, because token is a primitive (a string in this case), so its value is copied to the exported object, not a reference. You could instead either export a deeper object (to gain reference usage), or have the internal functions reference the exported object's data (`console.log(services.token);`). 2. You can't. That's one of the features of closures: you can't just arbitrarily go inside them and change their data. Also, even if you used an internal function that extended the external object, you wouldn't get access to the closure data from the new function. The only thing you could do would be to pass in a context object to use by the function instead of defined variables. However, if you are going to allow external modification of internal state in some arbitrary and undefined way, you might as well not use a closure at all: just make everything plain objects and pure, bare functions that operate on those objects.
Try .NET. Internationalization is a dream there. 
try standing on your head and reciting the Lord's prayer backwards. works for me.
JS is already highly OOP. It uses a form of prototypical inheritance much more akin to say, Python than Java, but in the grand scheme of things, that's not a huge difference. If you're used to Python or similarl languages, you won't get too confused. If you're used to Java...you'll still probably figure it out fast, but keep in mind: 1. Javascript's *seemingly* Java-like syntax is going to confuse you. It's not classical inheritance, it doesn't work like Java, and the more you know about the nitty-gritty details behind the `class` keyword in Java, the less sense the **very** different JS `class` keyword will make. Everything is different! 2. ES6 did not fundamentally change the language. The new `class` keyword is just sugar over the old prototypical inheritance. Good, classic, OOP design principles work great in JS. Bad OOP designs fail horribly in JS. If you avoided long inheritance chains in Java (and you should have!) then avoid long prototype chains in JS and you'll be fine. Don't confuse Java-style inheritance for JS-style prototype chains, but do recognize they're doing the same thing in *almost* the same way. The similarities far outweigh the differences, but the differences will get you if you forget they exist. :)
&gt; I wasn't saying it is currently classless https://en.wikipedia.org/wiki/Prototype-based_programming "This model can also be known as prototypal, prototype-oriented, classless, or instance-based programming." I was referring to that kind of definition. &gt; you do create new instances by cloning objects `new Foo()` doesn't clone some object. &gt; This isn't something that is debated, javascript IS prototype-based. Well, yes, there are prototype chains. However, you aren't cloning objects, which is what you'd usually do when you do prototype-based programming. There is no built-in cloning method as you have in Io etc.
It's only faking it if you think about it from the perspective of a different language that is class-based. Perhaps whatever is trying to be accomplished with class-based techniques is not the best way to solve the problem when it comes to the way the web works. I get the mental adjustment thing though. I've been working javascript for a while and am having to go back to C for some work I'm doing. I'm constantly telling myself to stop trying to think about how I'd do it with javascript. 
ok, sorry if I'm being harsh, I must admit I got a bit carried away, too. I think putting a short disclaimer in the article to say it's not sponsored content and you're not affiliated with Sentry would be awesome, as it immediately changes how people read it. There's been a massive surge in rogue advertising articles on Medium lately, and they really piss me off, because they hijack the culture of sharing and openness in tech communities. I'm glad to see you're not one of those people :)
&gt; And you can do that in JS without fancy operators. And many people already use compose functions and pipeline functions in JS. Virtually everyone who uses functional programming in JS includes a `compose` function with virtually the exact same implementation in every single project. It's used enough in the language that it makes sense to many to add it as a standard operator. &gt; It gives you a view similar to that of a switch -case, C-style. Fallthrough, which is just awful. At this point I'm not even sure what you're arguing. That does not look or function anything like a switch statement. It doesn't "fallthrough", it pipes the result of each step to the next step. I'm not sure what's so hard to understand. &gt; A meticulously designed and crafted function is just as easy to reason about as a "pure" function which was thrown together under the aegis of functional paradigm ideas. Program correctness is still largely up for debate. There is nothing preventing a pure function from being "meticulously designed and crafted". All a pure function is is a function that will always return the same output for the same inputs regardless of external state and does not cause any side effects. To effectively test non-pure functions, you have to test how they are affected by external state, and you have to test the side effects they cause. That adds complexity to reasoning about and testing a function. Simply put: "When you give it A and B, it returns C." vs. "When you give it A and B, it might return C, D, E, or F depending on the value of G and it also changes the value of H, I, and J which in turn affect the outcome of tangentially related functions X, Y, and Z." One is easier to test than the other.
const theMapFilterReduceTutorialWeNeed = allJavascriptTutorials.filter(isMapFilterReduceTutorial).map(reviewTutorial).reduce(mixTutorials)
interesting, i took a similar approach with [domvm](https://github.com/leeoniya/domvm), (minus React). i would argue that `this` in React-land *is* already the ViewModel itself. by its nature React is MVVM through-and-through, with each component being a VM - one that's just not externally accessible because components are strictly declarative (except for the root). with domvm, components can be either imperative or declarative and composed interchangeably. as you mention, this allows for state to be in the component without having to be passed down from a parent (which is the same thing redux is meant to solve). also, components can expose a normal API rather than registering in a global pub-sub bus. the result is both flexible and powerful, allowing a very smooth transition from OOP/jquery and other architectures to implement fast declarative vdom without a full restructuring.
I haven't used a class-based OOP language so I guess I'm missing out on what you mean by clone. A prototypical object is used as a template from which to get the initial properties for a new object. Kinda like how slim shady was the template for all his clones. In essence, it clones the object but on top of that more properties can be added to the object when it's created or at runtime. Classes are distinct from instances, and if what you are referring to as a clone is an instance of said class, all objects in javascript are instances.
&gt; Reorganize into reusable chunks Haha, what the hell do you think the `filter`, `sortBy`, `take`, and `map` functions are? And they are way more reusable in the functional programming example because they aren't tied to a useless class with dozens of methods you have to lug around even though you never use them.
&gt; I haven't used a class-based OOP language so I guess I'm missing out on what you mean by clone. No, cloning is a *prototype*-based programming thing. You have some object. You want more instances of it -&gt; you clone it.
To be honest there are already several languages that use `|&gt;` as the pipe operator also the point that you sometimes have to google things can be made for anything new to any language so it's a rather moot point.
&gt; "When you give it A and B, it might return C, D, E, or F depending on the value of G and it also changes the value of H, I, and J which in turn affect the outcome of tangentially related functions X, Y, and Z." How is an operator helping that? It doesn't. Bad code is bad code. That's pretty simple, and we've this absolutely lovely pattern called design by contract. But do go on and pretend an operator is the missing ingredient in JS. &gt;At this point I'm not even sure what you're arguing. That does not look or function anything like a switch statement. It doesn't "fallthrough", it pipes the result of each step to the next step. I'm not sure what's so hard to understand. Case A: unreadable |&gt; doSomething |&gt; somethingElse(x, 100, cats) |&gt; codeGolf |&gt; kittens VS switch (unreadable) { case conditionForDoSomething: {doSomething} case conditionForSomethingElse: {somethingElse(x, 100, cats, unreadable)} ... } It's the same thing, the only thing missing is matching. Pattern matching is essentially your pipes, especially without the BREAK statement. &gt;Virtually everyone who uses functional programming in JS includes a compose function with virtually the exact same implementation in every single project. It's used enough in the language that it makes sense to many to add it as a standard operator. Same way string padding is now a language feature... It's ridiculous how hip, trending stuff is how we judge the usefulness of something, then move onto creating the next golden hammer library and mechanism. This is essentially a short attention span and a spoiled tantrum. "I want that shiny toy now!" Community makes a mistake, and suddenly a language has to bend around backwards to calm the flames. Ridiculous. 
&gt; And they are way more reusable in the functional programming example because they aren't tied to a useless class with dozens of methods you have to lug around even though you never use them. Now you're just being obnoxious on purpose. &gt;Haha, what the hell do you think the filter, sortBy, take, and map functions are? That's maybe a part of it. The internals, the magic numbers, etc. You know, the actual logic? Those should be made available for reuse. But I know, hipstering and copy paste coding is the bess. I'm done. 
Then use those languages! This is a vanity feature, nothing more, nothing less. "They have it, why not have it here?" Because it clashes. Other languages don't have the current stuff JS does, either. Some of it. Not everything has to be the same! &gt;the pipe operator also the point that you sometimes have to google things can be made for anything new to any language Why do I even bother - it's not googling, it's the continuous rereading and going back when humans like reading fluidly from one direction to the other. 
But that's exactly what javascript does, so I don't understand why you're saying it doesn't.
Thanks. So is the only sane way to unit test a closure to use something like this? https://www.npmjs.com/package/rewire
Sorry if I misunderstood the point you were making, the quoted text made it look like you were against having to google things. Anyway for me it reads more natural using the pipe operator but that's probably because I'm used to it. But why do you think it's a vanity feature? It's more declarative than current options in my opinion.
thanks i just fixed it.
Creating a new object (from nothing) isn't the same as cloning an existing one. Check how other prototype-based programming languages like Self or Io do it. Cloning is a center piece. A good example is cloning an array. In JS, you have to abuse some Array method like slice or concat to do that. If objects had a built-in "clone" method, you could use that one instead.
orders of magnitude? really? Are there any metrics for this because that is surprising to me?
Would be nice to have, but in my experience when I need to compose functions it's *because* I have some pipeline, and I'm not likely to reuse the composite function anywhere else. Besides that, I don't think reading/writing `compose(fn1, fn2, fn3)(input)` is *that* less readable than e.g. `(fn1 · fn2 · fn3)(input)`. Maybe you have a use case I don't run across much. It's a real shame when powerful features (in FP especially) get introduced with trivial examples. It's what prevented me as a student from appreciating lambdas for years. It finally clicked when a kind boss showed me cool things you can do with anon classes in Java (of all things)! The proposal shows how we can express `let result = exclaim(capitalize(doubleSay("hello")));` with a few less parens; big whoop. [eccentric_j](https://www.reddit.com/r/javascript/comments/72pbfs/pipeline_operator_has_now_moved_to_stage_1/dnl9920/) gives a far more practical use. Here's another: let result = "bloody mary" |&gt; repeat(3, ',') |&gt; capitalize |&gt; makeIncantation("In front of a mirror, under the full moon"); // compare this mess of punctuation let result = makeIncantation("In front of a mirror, under the full moon")(capitalize(repeat(3, ',')("bloody mary"))); // alternatively let temp1 = repeat(3, ',')("bloody mary"); let temp2 = capitalize(temp1); let result = makeIncantation("In front of a mirror, under the full moon")(temp2); Can you see the difference?
I interviewed Bruce Perens (who wrote the definition of open source). He says the new license is still too restrictive. https://www.programmableweb.com/news/learn-how-intercom-grew-its-developer-program-apis/native-case-study/2017/08/10
&gt; rewrote React 16 from scratch Err, *what*? This is newbie programmer 101 - I don't understand it so I'll just rewrite it! Do I have an overwhelming feeling this rewrite is going to be laden with untested bugs?
You could `import * as vec3 from 'vec3'` const out = vec3.create() vec3.add(out, a, b) No need for a class.
Well, you don't really create a new object from nothing. You create a new object from the built in Object prototype yes? The new object comes with all the methods and properties from the prototype and in a sense is a clone. I don't see why it would be considered abuse to use an array method on an array. And the beauty of the prototype method is you can add that cloning functionality with a simple: Array.prototype.clone = function() { return this.slice(0); }; You instantly have that functionality as a method if that's what you want. As a side note, I've always thought you shouldn't copy or "clone" arrays? Of course, I only think that because I learned to program with C first which obviously handles array by reference instead of value. What exactly are you cloning an array for?
Finish the article
Some of us don't use `this` very much.
Haven't ever thought about using cucumber in a non-seleniun context. My question would be though, is there any real benefit to using cucumber over any other test runner for integration tests? To me the benefit of cucumber has always been the ability for non technical people to write test cases - would they be doing that for API integration testing
I code both functional and object oriented.. in fact I mostly have functional methods inside my objects. I just prefer to use the EventEmitter over Redux. I connect and disconnect signals using componentWillMount and componentWillUnmount. I also use LayoutAnimation quite a bit which I find best used in the componentWillUpdate(). I use the component lifecycle methods a lot.. I have a lot more stateful components than stateless. My stateless components are generally very simple components. Icons, Buttons, etc. Performance wise.. I see Redux as unnecessary overhead. 
I'm getting no love from that page... requires log in?
Wait untill you hear about for and while statements ...
Sweet! How big of a group did you have in Philly? I'll reach out to Kyle and see if he's still interested in helping organize such a group out in SF.
You should assume that they don't, but you can always try or lock the version. 
&gt; Based on the explanation above, find the bug! I came across this in the docs: &gt; Assigning a property on process.env will implicitly convert the value to a string. If I'm correct the falsey bug isn't present if every env. variable is a string? Here: https://nodejs.org/dist/latest-v8.x/docs/api/process.html#process_process_env
My last few builds were 700-1400ms (minor changes, admittedly). Near-default Angular CLI webpack settings
More like start the article, I doubt that he got past the title. 
I would follow React’s normal patterns for sharing data and pass props down to child components because the component’s viewmodel will have any props passed to it. Here’s a contrived example where a prop is passed down to a child, and the child ViewModel uses that prop to provide data to the view: https://jsbin.com/gupiyoxeyo/1/edit?js,output
I don't have more to add than /u/pamblam already said about your website. I looked at your redawn project and stumble upon this horror https://github.com/AutomicJS/redawn/blob/8eab76ad6870e1e0d1af30517eb6a4a375672949/dawn.es6.js#L61 As a general rule of thumb, if you're doing conditional statements that *kinda* look the same or abide to some redundant logic you're better off with a loop. By using an array of mapping object formatted like following : var myPatternList = [{ pattern: /\*\*(.*)\*\*/g, template: '&lt;strong&gt;$1&lt;/strong&gt;' }, .... ] You should be able to write something like this : for(var i = 0; i &lt; lineMatcher.length; i++) { var line = lineMatcher[i] if(line.match(regexBuilderArray.exclusionTag)){ line = line.replace('@!!!', '') } else { for(var j = 0; j &lt; myPatternList.length ; j++){ line = line.replace(myPatternList[j].pattern, myPatternList[j].template) } } } I removed the match against the pattern since the replace will only replace if matched. Since you use es6 you can safely use map/reduce syntax to slim it further down. lineMatcher.map(line =&gt; line.match(regexBuilderArray.exclusionTag) ? line.replace('@!!!', '') : myPatternList.reduce((matcher, _line) =&gt; _line.replace(matcher.patter, matcher.template), line)).join('\n') Anyway you should definitely look into common design pattern to increase your code quality.
empty string is still falsey, but I don't know if it's possible or makes any sense to have an environment variable that is set but also is an empty string.
i hope react's lead dev sees this feedback!
(1) A parenthesis in the if statement (2) you're using template literals with params inside the $\{\} which turns whatever is inside it into a string. EDIT: (3) See what Barandis said about the function keyword. That one completely slipped by my optical orifices.
name checks out
`reduce` is a good thing to understand, but in practice I've very rarely found a case where it was the most readable option, particularly with a good utility library like lodash. Like, sure you can write this like the author does: let count = items.reduce((acc, curr) =&gt; { if (acc[curr]) { acc[curr]++ } else { acc[curr] = 1 } return acc }, {}) But I'd rather read something like: const count = mapValues( groupBy(items), itemsGroup =&gt; itemsGroup.length ); Of course, you could implement `groupBy` and `mapValues` using `reduce`, but the "business" logic is easier to read if it's not wrriten with `reduce`.
First, you need the keyword `function` before `myfunction`, unless this is inside of an object, and there's no sign that's the case. Second, you need a closing paren after `&gt;= 1`. Third, I'm not sure how you're calling this function. I'm going to assume something like `myfunction(null, 'string', 0.000001)` based on your expected output. Fourth, I'm not sure what you mean by `params`. If my function call is correct, then the argument `params` most certainly *is* `["string", 0.000001]`. But `obj.params` isn't; you're embedding the array `params` into a template string, which is going to turn the entire array into its string equivalent. Which just happens to be `"string,0.000001"`. Then, since your template string is inside an array, is resulting in `obj.params` becoming `["string,0.000001"]`. If you want `obj.params` to equal `["string", 0.00001]`, then the assignment should simply be `obj.params = params;`. `params` is already an array, and you don't need to make a string out of it.
Interesting read. But what does dogfooding mean?
It means using the product that you make. It tends to lead to better, more thoughtful software because the developers are the users.
I wouldn’t go from scratch but maybe check out the Vue-cli webpack configs and see if there is anything glaringly different maybe 
Shouldn't the callbacks be called like: `process.nextTick(callback(null, {}))` ?
I recently ported about 3000 lines of JS from the core of our application to TypeScript. It took a day or two, and was an excellent experience. It was fairly easy to move everything across, and I really appreciate TS's type system - sum types are super handy, as are string literal types. The biggest issue has been working with external libraries. They tend to infest code with `any`. The `@types/threejs` module seems to be incorrect in some places, but even more vexing was the fact that it doesn't seem to work if I import specific modules from Three's source directly (which we do to save on bundle size). Guess I know what I'm doing this Hacktoberfest...!
In other news: &gt; How Angular team rewrote Angular from scratch breaking absolutely everything Kidding aside, it helps to have a small surface, focused, single purpose API which the React team wisely kept to (in fact they *reduced* the surface of the API as they gradually removed unnecessary elements like class emulations, as ES6 classes became available). I can't wait for people to finally learn this lesson, so the age of the "overreaching huge monolithic framework" is over. 
MDN is the business
The fact that FB heavily dogfoods their own software, I think, plays into this. When you actually get to suffer the pain caused by your own mistakes, it really puts things in a different light.
........ have you never refactored an app?
I think there are pros and cons to both, but to be sure, I enjoy working with JavaScript, though it does give you just enough rope to hang yourself if you're not careful. It's pretty easy, for example, to accidentally create a property shadow or even change something in a prototype that's shared across multiple instances.
that's what I thought... So it just randomly maps original symbol to an obfuscated symbol right? It's not doing some hash of original symbols to derive a consistent obfuscated version? 
They did so many things right. Definitely showing to my company to have us rethink how we re-write (or even just write) larger codebases.
&gt; What exactly are you cloning an array for? Curious about that as well. The only reason that comes to mind to do it would be to perform some sort of operation on the values, but you want to preserve the original array. In which case, why wouldn't you just loop through it pushing to a new array, or simply use map()? Probably just something I haven't come across (recently, anyway)... 
https://jsperf.com/native-map-versus-array-looping "Orders of magnitude" is an overstatement, but it is definitely faster. That being said, I'd prefer more legible code over slight speed bumps in most of the apps I write. 
I've gradually moved away from classes aside from a few cases where I still find them useful (or haven't learned an alternative I feel comfortable with.) Mostly for polymorphic behaviour. Otherwise... * Try to write functions grouped by module rather than by class. * Use plain objects and functions that operate on plain objects. * Try to avoid encapsulated state. * Look at using streams instead of getter/setter methods. * When you do need instances with encapsulated state, use closures instead of classes. People will try to convince you that performance will suffer. It should not however, because in cases where you have a sufficient number of instances to matter, those should almost definitely be plain objects instead of things with encapsulated state and methods. Your code will be smaller overall - not typing `this` all over the place, less function binding, fewer arrow function callback wrappers - and will minify better. I do use Typescript though. Types are great.
The last sentence is exciting! This is just the rewrite of the core. It’s going to be interesting see what new features we get in coming months/years.
That the dogfood that you make is so good that you yourself eat it. That is, using your own product - eating your own dogfood. 
Thanks for the assist. I'll give it another go tomorrow, and PM you if I run into issues again (if that's alright with you)
if you change code and build many times, run wepback with "--watch" option. the first build (right after running that command) takes as long as normal, but later builds (which are invoked by changing code) are very fast.
I’ve had some trouble with three’s defs in the past and update infrequently as a result. Despite that, once I got it stable, I’ve found it much more pleasant with TS than plain JavaScript, mostly since piecing together how things fit together can be done entirely in VS Code. When I was still new to three, it was extremely helpful.
Yeah definitely. Javascript is easy to pick up which I think is why it's a "beginner" friendly language, but the actual mastery of javascript is something that is more elusive. If you don't understand how prototypical inheritance works you can absolutely get some undesirable behavior from your code. 
Supposedly Google also use Angular a lot. Although they use Angular 1.x, they use Angular 2+, and they use Angular Dart which is now an entirely independent fork, and they use also like a dozen or so other frameworks for JS UI. It's hard to tell how important Angular is for Google, because "Google uses it" may mean 3 out of 4000 teams use it (BTW, yes, Google is that big).
Literally the entire article is about justifying how they built confidence in the rewrite.
Care to explain why you decided to make this change?
Having notes/script to go off will help the flow of your tutorial. Also, obviously increasing the video and audio quality will help.
Google doing something hasn't been an indicator of quality in a long time...
No, yeah, you’re definitely way smarter and a better programmer than the React team. 
Sounds like you're passing an array into the function. Get rid of the ... in front of the params argument and then do obj.params = params
You know, maybe I should give Python another look.
There is no logical xor, only bitwise xor which is more analogous to &amp;, | or ~ (bitwise "and", "or" and "not").
I've also heard it said as "drinking your own champagne" in some attempt to make the phrase sound better.
How are you running webpack? Without seeing some sort of process, its impossible to know why it's so slow. Are you using the incremental build feature of webpack or are you recompiling from scratch every time?
Good stuff, in the django-python word
We only managed to organize one session before we both ended up moving here at almost exactly the same time, but as I recall we had a pretty good turnout, maybe 20 folks? I feel like you could definitely get a good-sized group around here.
Like 95% of the code I write is pure functions so this would be great for me personally. I'm not sure I agree with the argument that because it requires more thinking that it doesn't belong in native. Once you're used to coding in a functional style, it doesn't require any more planning than OOP.
The core of our editor is basically a large state machine that renders an interface using Three. It's a state machine because it's modal. Each mode needs to handle a bunch of different events while active. It was getting quite difficult to refactor the types of events that could be handled. I'm expecting that strongly typing the events themselves, as well as the Mode base class and the expectations it has, will help us not miss things when making changes in the future. Rigorous testing would also help, but we're terrible at it, so this is a way of mitigating that. Documentation would also help (e.g. declaring the properties of the different touch gesture events, somewhere other than just where those events get created), but types are a form of machine-checked documentation already. At some point I'll have to bite the bullet on testing, since types don't help ensure that the implemented transitions are the correct ones. But for now TS will prevent transitioning to a mode that no longer exists, or forgetting to update handlers when changing an event type definition. Another way TS has helped is in separating different types of coordinates. We have to do maths on coordinates in screen space (-1, 1 relative to the editor element), world space (metres on a map), and local coordinate space. I added some interfaces that wrap Three's `Vector3` and `Vector2` classes and prevent mixing coordinates from different spaces. I still cast through `any` when actually converting between spaces, but at least I have to do that explicitly, and can't do it accidentally. The cool thing is that these types don't add anything to the runtime representation - when compiled, it's all just plain `Vector3`s and `Vector2`s. Essentially, I saw a bunch of places where I thought that types would ease the cognitive burden of working with our code (I've worked with typed languages in the past). I think it's paid off so far. EDIT: all of the above said, porting to typescript didn't find any bugs. They'd all been found by users already XD. It was mainly a defensive move so that future changes (of which there will be many) are hopefully easier.
Honest question. I spent a bit of time just now reading up on IO, and I'm honestly not understanding what the difference is between using clone in IO versus Object.create in Javascript. In other words, what is the difference between this IO code: Account := Object clone Account balance := 0 Account deposit := method(amount, balance = balance + amount ) account := Account clone account deposit(10.00) account balance println And something like this in JS?: function clone( base, props ) { const c = Object.create( base ); if ( props !== undefined ) { for ( let propName in props ) { c[propName] = props[propName]; } } return c; } const Account = clone( {}, { balance : 0, deposit : function( amount ) { this.balance += amount; } } ); const account = clone( Account ); account.deposit( 10.00 ); console.log( account.balance ); You can even add on to the prototype chain as much as you'd like: const SavingsAccount = clone( Account ); SavingsAccount.interestRate = 0.01; SavingsAccount.payInterest = function() { this.balance *= ( 1 + this.interestRate ); } const VIPSavingsAccount = clone( SavingsAccount ); VIPSavingsAccount.interestRate = 0.02; [Here's a fiddle](https://jsfiddle.net/jgb/1ggvhmf1/). What am I missing?
&gt; Would be nice to have, but in my experience when I need to compose functions it's because I have some pipeline, and I'm not likely to reuse the composite function anywhere else. I think this is at least partially just code style. I find myself reusing composed functions all over the place, but that's because I start coding the app with that goal in mind. I definitely agree that the pipeline operator has valid use cases, don't get me wrong. Just for me personally, the compose operator would get used far more frequently. Where as you're assigning the result in the example above to a variable, I'd rarely do this. More often my code would look something like this /* bloody_mary.js summon a bloody mary to cure hangovers this file defines some behavior */ const {pipe, always, repeat, capitalize} = require("utils_lib"); const makeIncantation = require("../spells/makeIncantation"); module.exports = pipe( always("bloody mary"), repeat(3, ","), capitalize, makeIncantation("In front of a mirror, under the full moon") ); /* do_magic.js another file somewhere where I'm actually triggering behavior */ const app = require("../app"); const bloody_mary = require("../things/bloody_mary"); app.on("/bloodymary", (req, res) =&gt; { res.send(bloody_mary()); }); 
That's fine by me. ;)
You are totally missing the point here. No ones going to take away your class and for loop, keep on using them.
yeah for sure.
Yeah, that's exactly what it sounds like, though the OP says that he's passing three total arguments. So I'm not sure which way it is. As an explanation to OP: the `...params` means that every argument that gets passed from that point on is going to be packaged up nicely into an array called `params`. It might be an empty array if you only pass one argument (`test`), it might be a one-element array, it might be a many-element array. But it's *always* going to be an array. If `obj.params` is an array inside an array for you, then there are only two possibilities. 1) as the parent poster says, you're passing an array to the function. If your call looks like this: ``` myfunction(null, ['string', 0.000001]); ``` then you're only passing two arguments, not three. The first, which gets assigned to `test`, is `null` in this call. The second is an array, and since `params` becomes an array containing every other argument, it becomes an array whose only element is this array. So if you assign that to `obj.params`, it will indeed be set to `[["string", 0.00001]]`. The way to fix this would be to not pass an array as an argument. It should instead be: ``` myfunction(null, 'string', 0.000001); ``` Then you're passing three arguments, and the last two get packaged up into a two-element array, and everything is right. 2) You might not be assigning to `obj.params` correctly. I only say this because in your original code, you put the value into an array. So make sure you have this: ``` obj.params = params; ``` and NOT this: ``` obj.params = [params]; ``` Since `params` (the function argument) is *always* an array, no matter how many arguments get passed to your function, you don't need to do anything to make it an array.
I'd also heard some very colourful and scatological variants. 
Haha!
I don't know. Do you unit test the private internals of an object in C++? I thought you were supposed to unit test objects as a single thing, treating its internals as black boxes.
Still the easiest framework to setup
Great explanation. Terrible code though. I'd reject a PR with this type of stuff in it. It's unnecessarily difficult to understand. [ 'NODE_ENV', 'PORT', 'DB_USER', 'DB_PASS', 'DB_HOST', 'DB_PORT', 'DB_NAME', ].forEach(name =&gt; { if (typeof process.env[name] !== "string") { throw new Error(`Missing environment variable ${name}`); } }); The above would be a lot more clear.
Not true. Only 1 or 2 products from all Google's variety. 
Oh yeah absolutely. There's no reason to do this in this scenario. It's not even shorter than the equivalent code with an if. The only explanation I can make up is that the author just migrated from Perl where `expression or die "error message"` is a common idiom.
There's an excellent post somewhere in the top of this sub right now called "The State of Internationalization in JavaScript". That might help you on your way.
If you use webpack to run a server then changes update in the browser in real time, then you only need to build the project when putting it into production.
yep, sorry, my bad. Still works in this case :)
Stop comparing React to Angular. They aren’t the same and never will be. Tired of this stupid shit. 
the npm people needs to read that article
Have you heard of Scrimba? https://scrimba.com/ It's interactive screen cast for coding, could be useful to share your framework.
I used to do backwards compatible obfuscation, it wasn't fun and I doubt anyone does that, some minifiers start from a,b,c in every scope, some go through the alphabet throughout the entire program (ending up with very unique names for every thing in the code). There are ways to patch code "from outside", some very simple functions can be just wrapped, like this old trick when people used `window.onload` for things: var oldOnload = window.onload; window.onload = function() { ...some new code... if (oldOnload) oldOnload(); } Some advanced cases can solved by patching the JS with something like with [jscodeshift](https://github.com/facebook/jscodeshift), but this is hard and only worth the trouble in rare cases.
When the majority of JS client-side developers have to choose a platform for building their application UI, they most often choose Angular or React. Those are the two most predominant solutions *by far*. In *that* context, they are competitors for the same job. The fact they're different in other ways is irrelevant in *that* context. So of course we can compare them. Also I can drop jokes about Angular when I feel like it without your personal approval.
Thanks for pointing out the Ololog Library.
Spoken like someone who hasn’t used both in prod. Clown. I don’t give a fuck what you wanna compare or crack jokes that aren’t jokes. Apple to oranges. I’ll just ensure people like you never make on my teams, my companies, making my type of money. And as long as you promote this naive, topical understanding of front end web tech, I’ll continue taking all your work too. A lot of people value logic and understanding tech. You don’t and that’s cool. But if you aren’t gonna apply it, miss me with your dumb ass comments and dev wannabe opinions. Tired of posers like you out here talking stupid. 
I tend to prefer Mocha to some of the fancier and newer libraries (Ava / Jest) As it is possible to run the tests in the browser (using karma). This is particularly important when developing generic libraries that should work on both browsers and node.js. 
100% agreed. Sometimes, it seems that they're doing something just for the sake of it, just to look superbly busy to the public.
It seems you are correct... and that lead me to a TIL &gt; Javascript internally uses ToBoolean and it is possible for a value to be truthy (ToBoolean returns true), but also == false This answer on SO was helpful: https://stackoverflow.com/a/19839953/1695393
No doubt, but recruiters don't understand that.
Hello! This is a reminder to take your pills. &gt; I’ll just ensure people like you never make on my teams, my companies, making my type of money. Now here's someone taking a game of Monopoly dead-seriously.
Agreed! This is better. It is also * Understandable * Extendable for e.x. ensure PORTs are numbers etc. 
Or just someone who knows what they are talking about. Again, your career man. Wanna sound stupid to people that are actually in the game, your call. But understanding tech is a prerequisite for talking tech and you just sound stupid. Or for a cliche: React !== Angular. You wanna talk React and Vue, now you have a candle to hold. 
You didn't say anything of substance above, you just had a mental breakdown over me saying Angular broke B.C. when they rewrote (which is factual). Of course, on the Internet you can have "your teams", "your companies" and "your kinds of money", but with this attitude you'd be lucky to be able to get a job at all. At least not on my tanks, my air carriers and my space-ships!
Ad or not sentry is one of the best things that's happened to my codebase. How else do you guys capture obscure errors like that safari mobile in incognito blocks local storage? 
I agree with the sentiment that the two are hard to compare. About a year ago one of the biggest banks in my country (and quite a big name world wide) approach my company for consulting. They wanted an answer for the exact question OP mentioned: should we replace our legacy Angular.js codebase with ng2 or React? So no matter if you want to compare the two or not; enterprises and their architects do.
Exactly my point. Why are you comparing them? Makes people sound/look like they don’t know shit. 
I've had the pleasure of speaking with a few that did but you're right. Most recruiters and hiring managers don't understand. 
Clearly not someone who dealt with a cutover or upgrade or understands what happened in the more general ES6 cutover with native modules and native components. And please with the attitude. This isn’t something I’d bring into my company or my clients. It’s just something that all of us who actually leverage a variety of tech are tired of hearing in interviews with juniors and, pathetically, people that call themselves seniors. Educate yourself. I don’t like know-it-all know-nothings like you. Fuck outta here until you can talk the tech and not some blog you read one time by some guy that hasn’t deployed shit. We are just trying to get the imposters out. 
You’re being needlessly abrasive, but I’ll bite… It IS a choice in frontend architecture. You’re making the same mistake you’re accusing others of making in saying that it’s a distinct choice due to the differences in implementation. The choice is if you are pushing your business logic to the front (Angular) vs either a) choosing React + something to do something MVCish on the frontend(a mistake in my opinion) or b) choosing to have a lighter but more immutable data structure on the frontend and pushing the orchestration of that to the backing API layer. It’s not just a library choice, it’s an architectural choice. Which is what I am going optimistically assume you were trying to say, while lacking professionalism and manners. 
try https://github.com/amireh/happypack
Sure. But it’s purposeful. I am, along with many others, sick of comparisons that aren’t and sick of stupid shit getting into our ecosystem and realms of understanding. The argument above is tantamount to “Is LeBron a better baseball player than Ruth?” What? Why? They aren’t the same. So stop talking about em as if they were. Educate yourselves. Stop promoting stupidity. React + other shit can attempt to get to Angular. But when people talk React vs. Angular, they are just being dumb. That’s it. Period. End of discussion. 
Well this escalated quickly. Let’s just be cool and understand the diffs. 
Ok, so I’m getting that you’re mad about comparison articles. I get it, it’s click bait sometimes. But you still ignored my points about where these articles make sense in comparing them. So I’m not going to engage in a debate, as you’ve already chosen what you’re angry about, and you’re clearly entrenched. That’s what I get for feeding trolls…
When analyzing solutions, there's an old saying I always keep in the back of my head to help me not miss the forest for the trees: "Nobody really needs a drilling machine. They need holes in their walls." Another way of saying the same thing: "Don't ask how to build a bridge, ask how you can cross the river." When the job is crossing the river, a bridge and a boat are competitors, and they will be subject to comparison. The differences were always there and always understood, but the only thing that matters in the end is the problem to be solved.
Tic tac toe :D
Sure thing , I can try =) 
While that may be the case, it’s up to more knowledgeable people to point out the fact they are not comparable. 
Block level scope doesn't have much to do with oop.
Impressive process!
Good read
BTW this: process.env[name] || (() =&gt; { throw new Error(`Missing environment variable ${name}`); })() Can be this: if (!process.env[name]) throw new Error(`Missing environment variable ${name}`); Someone was really thinking they're a smart-ass writing that code, though.
An hour has past. How's your progress on this going? :)
That is true. But a static will still make for clearer code inside the module. Consider: As an external function: class Vector extends Foo { constructor() {...} somethingUseful() {...} somethingAlsoGood() {...} } function helper() {...} function helperTwo() {...} function addVector(v1, v2) {...} versus the static form - class Vector extends Foo { constructor() {...} somethingUseful() {...} somethingAlsoGood() {...} } Vector.add = ()=&gt; {...} function helper() {...} function helperTwo() {...} In the former case, the class 'action' function is buried amongst the helpers. In the latter, the purpose of the function is more explicit. I would never create a class just to bundle statics, but if the class does exist, and I want to do things to its instances, I think statics make for a simple and familiar way to organise that code.
Make JavaScript memory efficient
yeah but nonetheless when rewriting an app or launching a new one you have to make an architectural decision, and those are nowadays between React and Angular.
Your suggestion would work, but you'd have to write it like so: .forEach((name) =&gt; { if (name) throw new Error(`Missing environment variable ${name}`); }); Which makes it shorter, and easier to read. But, from what I've learned from talking to others is the use of `if` statements in fat arrow functions is a style some functional programmers dislike. I agree though, your suggestion is much easier to read.
You need an initial value on your reduce. 
Nice, code is easy to read and you've got some good tests. A few notes: You can destructure multiple properties with one statement: const { PadRight, PadLeft } = require('./index'); JavaScript functions are idiomatically camelCase, as opposed to PascalCase. Something that doesn't have a toString method will crash your function, so you could add some more error checking if you're interested, for example, using the String() function if toString doesn't exist on the argument. Make sure you understand the trade-offs of recursion vs. a loop. If your runtime doesn't support tail recursion, you can incur a linear memory cost as opposed to a constant one. For string padding specifically, I'd actually argue recursion has no advantage over a loop. Of course it's fun to play around with recursion to see how it works, but it's important to simultaneously understand when you'd actually use it in production code. If you're interested in more recursion exercises, I'd recommend implementing factorial, Fibonacci, and binary search both recursively and with a loop and comparing the implementations. I think they're better examples of recursion than string padding. Another exercise i really like is the two functions printAsc(n) which prints the numbers 1..n recursively, and printDesc(n), which prints n..1 recursively. There's almost no difference between the two functions; it demonstrates really well how recursion works. Happy coding :)
&gt; But, from what I've learned from talking to others is the use of if statements in fat arrow functions is a style some functional programmers dislike. There's no such thing as "functional programmers". There are functional languages, but JS has always been a mixed paradigm language. When in Rome, do as the Romans do. If someone is a fan of Haskell, they can go write Haskell in Haskell style. If they write JavaScript, they should use the best way to write JavaScript in JavaScript style. If they go out of they way to write everything as an expression, even when the result is harder to read, longer and slower to run... this is cargo cult functional programming, and a sign the programmer in question isn't quite sure what they're doing. Be your own self and use what makes best sense to you. Don't submit to the whims of zealots.
A comma also works and makes more sense.
There's a subtle circumstance that arises from not checking the `padChar` to actually be a single char. Say I call `PadRight("hello", 6, "nurse")`, The final length of the resulting string will be larger than `6`. I'm not saying this is necessarily a big deal, but you _may_ want to think about it, as the _documentation_ for the functions says that it will be `6`.
What is it all about? What's the point?
Look on udemy and other training websites for courses. Also, codewars has challenges you can do. 
Amazing response. Very well put. Thank you.
I suggest you learn javascript. Mozilla developer network has good references for HTML, CSS and JavaScript. After learning the basics you could go for a framework like Vuejs, react or angular. Youtube is your friend. TraversyMedia has a lot of good content on javascript.
You seem like a good person to work with.
Work through these - [Wes Bos' Javascript 30 day challenge](https://github.com/wesbos/JavaScript30).
good call 
Snake is also a pretty good project to build for yourself!
If not provided, the previous value in the first call will be the first element of the array and the current value the second element of the array.
I sure do like your username.
Codeschool puts out quality content, but it paid. Also, check to see if your local library allows free access to any paid sites. I found out recently I get free access to the entire Lynda.com site through my library.
"I don't read articles before commenting, not do I understand what unit testing is" -- /u/just_so_wr0ng
Hi /u/miodragon1, For javascript help, please visit /r/LearnJavascript. Thank you!
after 3 years of javascript, i find this method to be the quickest in debugging this kind of stuff
`class` is just sugar over prototypes.
Hi /u/Jay087, For javascript help, please visit /r/LearnJavascript. Thank you!
It has its business socks on.
Hi /u/nokthar143, For javascript help, please visit /r/LearnJavascript. Thank you!
It has its business socks on.
Redux requires you to return a new value. I clone arrays regularly, though usually I use something more expressive like map or filter. Depends on the operation.
Using a calculated value to calculate another value has a bad behaviour in my opinion. Example: C1=A1+B1 D1=C1 If you change A1 now, only C1 is updated: D1 still contains the old value. Only after you switch cells a second time, D1 is updated.
I can't condone the use of `eval()`, but this is a nice little snippet of code. 
I don't know which framework Google uses for the new YouTube, but it's slow as hell. Every fucking thing is a component. Who in their right mind chose this approach? Everything they are doing could have been implemented with vanilla js and I bet it would be a magnitude faster. It reminds me a story about one developer that after graduating from college went to develop a large project with php but choose the oop way. But php sucked so bad at the time that he was forced to completely rewrite the project because php was a dynamic language and the php complier sucked at it's job. Always test if the fancy new technology you are using had bad consequences.
PR rejected: Not enough fat arrows.
And my only point is it’s a false equivalency. React and Angular solve different problems with the only similarity being that each deals with the V. People unfortunately equivocate the two because they are front end tech. 
Have to hand it to you... you handled this angry person very well and made me laugh a few times along the way.
well when it is used across the wire it gets wonky, especially in a server environment (or as a client in a promiscuous server environment), but I've used it before, in fact it was a bunch of obdII formulas that were in a spreadsheet that eval-ed (after string substitution of values) quite nicely. So it is very useful in certain situations. I think this is one of those.
Well that I did not know. Thank you!
&gt; I don't know which framework Google uses for the new YouTube, but it's slow as hell. I think it's their Material library: https://material.io/guidelines/material-design/introduction.html It's probably their most involved/heavy design indeed, because they're trying to emulate on the web, what they do in the Android's native UI. Something's gotta give. &gt; Every fucking thing is a component. Who in their right mind chose this approach? I haven't inspected it in depth, but having everything as a component seems like a good design choice (in the abstract at least). The devil's in the details, of course. 
I think it's their Polymer framework. Material design is just the UI but it can be used with any framework (Angular, React etc)
That's their presentation lib. I believe the new YT is built with Polymer (web components)...?
Having most of your UI as a component is fine. But there is overhead. Every single comment has different components inside. There is certainly overhead here for very little benefit.
Yup. The eternal dilemma of the software engineer: to abstract some more or stop?
&gt; 1) that is not the point of the article This is where the title is misleading. The title and first half of the guide is setting the tone for what frontend error tracking is available and problems that will be solved. It's not until the solution is presented that it's detailed as Sentry and it's a drop in and forget about it solution. The title and tone of the guide should be made clear that it's about how to use Sentry and how it differs from Sentry's existing documentation.
I put an alert in a cell and blocked the window. When I see an eval() I can't resist.
Yeah, I don't personally understand the case for Mongo given Postgres' excellent JSONB support. If performs as well, possibly better and has a much better track record in terms of reliability. Also, why not give yourself the option of having a proper schema in case you need one down the road? If you want to spin out a field from a document so it can be easily indexed, you just don't have that option with MongoDB.
" there was no way to do a run-time feature test to determine if our implementation was faster than the native API." well that is the problem, really anything IS possible, but do you have the time/money/resources to implement and maintain it (and maintain your sanity).
Which basically breaks the functionality of the app. Almost every spreadsheet will need to be doing multi leveled calculations... I feel like I sound like a dick. Sorry OP.
It's not 1995. time to get over the eval phobia. if someone's going to inject js into your app they'll use the dev tools. besides, even in 1995 there were ways to use it safely.
Well, perhaps, but aren't most OOP (java etc) language block level scoped? I could be wrong... it's been awhile since I've ventured out of js land.
&gt; You release things that are successful or you get out. Unless you're part of Google+ apparently.
I know you can use a spread when calling a function but is it really valid to use it in a function definition? I'll have to test this.
There was a tool which were able to resolve many obfuscated symbols with machine learning by understanding the context and meaning of the input code - it was pretty acurate with restoring names etc. However the research team removed it from public - I wonder why :)
I've used vue-draggable which - I believe - wraps this. It's been very good. Only thing I wish was that the detection for when items should be replaced was better. It currently does it by the mouse position. There was an article recently (will try and find it) that demonstrated using the "center of gravity" (I believe they called it) to decide when to swap items, which felt really intuitive!
no, apparently it is not valid. not sure what you were expecting to happen but it doesn't spread the parameters when you use use it in a function definition. perhaps you wanted to spread the `arguments` variable inside the function. 
&gt; You release things that are successful or you get out. Who is “you” in this case? Almost every dev I have known from Google has either not been on a product-releasing team at all or is the code monkiest of code monkeys. 
Yeah but I think in the context of patching code, even if you're able to reason about the obfuscated code and successfully patch it, the next version of the vendor could could have entirely different symbols mapped into the obfuscated version and easily break the patch you've created.
Google has Angular in use in over 1000 internal apps (mentioned at ngConf the last 2 years), all of which run the tip of Master. The Angular team actually runs not only the Angular test suite but all of the test suites for all of the internal apps as well.
 str.split('').reverse().join('') Reversing this way will not preserve non-BMP codepoints mixed with unicode code points (emoji, etc). Try this instead: [...str].reverse().join('') 
Not sharing with children, sharing with components that are completely disparate from one another. Or do you just lift the data that needs to be shared to a model that is in a shared parent of the two components?
Hi /u/ATKS, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Because of the uptick in react licensing articles, the recent switch to MIT created a vacuum for article content. Authors were forced to dig deep into their stash of topics, and here we are
I'm impressed in a way, still a bajillion "edge cases" (not sure if the filesystem is an edge case) I'm sure, and necessarily a bit pokey to load, but swing to browser wasn't trivial I'm sure. http://reportmill.com/cj/RMStudio/swing/
Doesn't work very smooth on mobile
Gross
If you look closer, it says you can pass by reference using object or array.
If you are on a Mac you can open up simulator which is part of Xcode from there you can the dev console 
You are wrong.
You are right, not making it clear could rub people the wrong way.
Onclick should work if the html element is cursor:pointer, if that doesn’t work.. try ontouchstart or something like that 
All object and function expressions are references. So if you use any of them, their value is a reference rather than the literal object or function. e.g. var arr = [1, 2, 3]; console.log(arr); //[1, 2, 3] function abc(a) { a[0] = 5; console.log(a === arr); //true return a; } console.log(abc(arr)); //[5, 2, 3] 
copy + pasted from my browser console const x = [1, 2] undefined typeof x "object" So, an array is an object.
&gt; And my only point is it’s a false equivalency. React and Angular solve different problems [...] I couldn't agree more with you on this.
I can't use dev tools to inject code on another client. I *could* use this if there was a way to share spreadsheets or I could convince someone to paste it into a cell - which *should* be a safe operation. And frankly I've seen this, or things like it, often enough that I'm not sure it isn't from 95.
You can also use desktop Safari dev tools with an iPhone plugged in via USB.
[removed]
The effort:value ratio from this is great but IMO it's more important to have a PR builder. If your unit test suite is large adding a precommit hook can discourage good habits like committing frequently. More importantly, precommit/prepush hooks won't catch bugs or broken tests introduced by merging. If you are good about rebasing on master before merging this won't be a problem, but it's an additional hassle. If you use them, Github and Gitlab automatically create merged versions of your PR (it's how they flag conflicts) which your CI setup can use for testing. For Jenkins there is [ghprb](https://github.com/janinko/ghprb) and [glmrb](https://github.com/timols/jenkins-gitlab-merge-request-builder-plugin). It's considerably more effort to set up and maintain but it lets you merge PRs with a lot more confidence.
you're right, my point is that it's lack of sanitation that's dangerous, eval is not inherently dangerous. checking for numbers, periods, math operators is all that's required.
Thanks very much for the detailed feedback, really appreciate it. Will have a try with some other exercises to. 
Interesting idea. We use ducks at work and it's easy to get lost sometimes, specially for newcomers to the project. 
Your comment confused me so much at first (I interpreted "the business" literally). That said: yes, yes it is. 
Cool, thanks, I wasn't sure about it as others seem to not have bothered with a check for it either. You are right though, that will have the possibility to lead to a larger string than expected. I think adding a check too see if it is a single char would be valuable for correctness.
You _could_ do that. Or you could "cut it at `requiredLength` at the end". I mean, it's another option, and it would let you do things like... PadRight("Hello", 15, "xo") // "Helloxoxoxoxoxo" PadRight("Hello", 14, "xo") // "Helloxoxoxoxox" ...which may or may not be useful to you, of course. But it's an alternative I've seen used sometimes. In any case, do what better suits you, of course :)
We use ducks too ! With this structure in place, it becomes very easy to reason about the app. 
And here is [RMStudio in the Browser](http://reportmill.com/cj/RMStudio/) (300k+ lines of Java UI code via CheerpJ)
Very true, that would be a lot more flexible than just throwing an error if the padChar parameter wasn't a single character. Will give it a try later on. 
Do you have any examples or posts with explaining the tradeoffs with recursion or where it it's best used? I didn't spend much time, but a quick Google didn't show anything. I probably didn't search for the right thing, or tried to make it too specific to JS.
In JavaScript, everything is passed by value. There are no pointers, nor ref/out mechanics that would allow you to pass a variable by reference. However, _object references_ are just that... References to a location of memory in the "heap." So, first off, a recap: There are two main places where data can live: * Stack: a block of memory allocated on every function invocation. The stack contains all the memory needed for a function to execute, and all local variables (defined with let/const/var) and parameters are on the functions's stack. The stack for a given function is allocated when that function is invoked, preallocating enough memory to contain all local variables to that function. Ever get a stack overflow exception? That happens when too many stacks are allocated and the VM runs out of memory for calling another function. Also note that the entire functions's stack is deallocated once that function returns, and the memory where all the local variables lived is recycled. Although variables in a function's stack can be hoisted via a closure, for this example just pretend that they are isolated in that function. * Heap: this is where dynamically allocated data lives. Every time you use the "new" keyword (or the object/array literals such as [] or {}), you allocate memory on the heap. Data on the heap _does not_ disappear when the function returns. Instead, the garbage collector will reclaim that memory once it detects that _no references_ to that data still exists. This is in contrast to languages without a GC, such as C or C++, where you must manually deallocate any data you've allocated on the heap. Secondly, you have to understand how parameters and return values are passed. They are _all_ passed by value. Meaning, when you invoke a function (or accept a return from a function), the data of that variable is _copied_ from source to destination. You can see that in action with function doStuff(myVar) { myVar = 20 } let stuff = 10 doStuff(stuff) console.log(stuff) // &lt;- prints "10". The "myVar" parameter was _copied_, not passed by reference. So what happens when you do something like: function doStuff(myObj) { myObj.name = "whoa" } let stuff = {name: "hey"} doStuff(stuff) console.log(stuff.name) ? Well... The output of that snipped will be "whoa". "Wait!" I hear you say... "You just said that all variables are passed by value and copied! How did that function change that object?!" The reason for this is that the "stuff" variable _was_ copied. Except the "stuff" variable is _not_ an "object" per-se. The "stuff" variable is a _reference_ to an object. The "stuff" variable _itself_ lives on the heap, and is copied into the doStuff function. But the "stuff" variable is nothing more than a memory reference. The actual object, created by that object literal, was allocated on the heap, whereas the reference to that object was allocated on the stack. Think of the heap as a massive, disorganized, book that is shared by all functions. The data in the object literal is printed somewhere in that book. The "stuff" variable is only a bookmark to where the data in the object literal lives in that book. Here's another example: function doStuff(myObj) { myObj = {name: "whoa"} } let stuff = {name: "hey"} doStuff(stuff) console.log(stuff.name) Can you guess the output? See, in this case, we're * Allocating a new object ({name: "hey"}) * Assigning "stuff" to a reference to that object (let stuff =) * Calling doStuff and _copying_ the reference into the "myObj" parameter * Allocating _another_ object ({name: "whoa"}) * Re-assigning the _copy_ of "stuff" (called "myObj") to the reference of that object Since "myObj" is a copy of "stuff", the object that "stuff" points to is not changed when "myObj" is changed, even though they started out pointing to the same thing. The output of this script is "hey". To answer your question, /u/slmyers 's /u/jcunews1 's and /u/lunny93 's answers are all incomplete because _everything_ in JavaScript is an object. Numbers, Dates, Strings... All objects. So to say this code works because an array is an object, and objects are passed by reference, is not only technically incorrect, but misleading. So if everything is an object, even numbers and strings, why doesn't the first example in this reply print "20" instead of "10"? Well, that's because numbers and strings in JavaScript are _immutable_. Meaning, you cannot change the value of a number or string in-place. When you say "myVar = 20", you're doing the same sort of thing as in my last example. You're re-assigning the local variable to point to a new "object reference"* With an array, however, you _can_ mutate it in place. So when you invoke a method on the array, the data that is located on the heap changes too. So, basically, any variable that you mutate in place, by not using the "=" operator, will mutate that object's value on the heap, and therefore the changes will be visible outside of the scope of that function. Since you mutated the array directly, instead of copying it, the data was changed in place. \* Aside: I know that scalar values (strings/numbers/etc) in JavaScript are optimized away in most engines into "true" non-objects, ala unboxing in C#, and most people do not refer to strings/numbers as objects. However, they technically are. They have prototypes and methods and can be extended. As far as the language is concerned, numbers and strings are just as objecty as user defined objects.
Huh, I thought the commit time part was a satire. It isn't. https://blockchain.info/charts/avg-confirmation-time
Newbie question: Does this mean that there can be at most ~7 bitcoin transactions per second at the moment? What happens to the other transactions? I am assuming there are a lot more than 7 bitcoin transactions per second world-wide.
In my company we used blendid (former gulp starter) for some projects. It does similar things you want to do. check it out: https://github.com/vigetlabs/blendid
JA^JS VA &lt; "Kill me"
thank you, I'll include a link to your comment in my blogpost :) 
A bitcoin block gets mined (added) every ten minutes (1000+ transactions get bundled into a block). See https://blockchain.info - for example - for real-world (live) bitcoin blocks. The recommendation is to wait for six confirmations, that is, six blocks, that is, about an hour. Happy blockchaining. Cheers.
&gt; Var, specifically, is bad due to hoisting. No matter where you declare it in your scope, it's hoisted to the top level of the function. This is bad, because it doesn't let you reason about your code hierarchically, and introduces subtle errors down the line if you re-use variable names and intend for them to have a separate scope. Over the years, (mostly because of hoisting) I got into the habit of declaring all of my variables at the top of functions. I kind of liked doing it, to be honest. I could keep everything alphabetical or group them by purpose, comment the ones that needed it, etc. It was kind of like looking at an abstract for the function. Also, just in the interest of cleanliness, I kind of hate having function definitions scattered throughout a function. Having to deal with const really leaves me emotionally torn. ;) Because really, most variables I use seem to be constants. And it vexes me that I have to assign them at the same time that I declare them. But you know...I gotta, because a lot of the time, it doesn't make sense to put that overhead at the top of a function (e.g., you might return out of the function before you even need a thing, or pass it over entirely based upon a conditional), or I simply don't have all of the information I need yet to assign them. So now I'm back to having variables littered throughout my functions, and it makes me a little sad, even though for somebody else reading my code, it's probably better. Of course, nobody ever reads my code, because I work alone!
No problem. [Here is an example I found as well](http://2ality.com/2015/01/es6-strings.html#handling-unicode-code-points).
You should take a look at useref [here](https://www.npmjs.com/package/gulp-useref) or [here](https://github.com/jonkemp/gulp-useref).
Current numbers seem to be about 1800 transactions per block, this is do to a size limit of 1mb per block (may be increased in the future). Each new block is close to 10 minutes apart. So it's more like 3 transactions per second. There's no guarantee the block will include any transactions, it's up to the miner to include them. They will get a bonus from transaction fees if they do though. 
As the author of the post you shared, I really don't recommend you use this in production. :D
Maybe not strictly related but check Lerna by Babel
Webpack takes these script tags off your shoulders. You never have to chase after your dependencies again. You simply import whatever you like: could be npm modules or your own modules. Webpack will analyse your code and include only the bits and pieces that make your app run. In the end it spits out a bundle, which you can compress. Include that in your html and you're set. Try it out: https://webpack.js.org/guides/getting-started/
I've attempted to make this realistic -- more so than other lander game/ challenges: gravity, the atmosphere, and the parameters of the probe are close to being accurate. I'd be happy to know if you succeed. I still want to do more to this, though: perhaps doing graphics in three.js, and perhaps a little more if you succeed.
Hmm it's mostly understanding the call stack and stack frames, i.e. what actually happens in main memory when you make a function call. You could start by reading up on "call stack", "stack frame", and "tail recursion", as well as asymptotic analysis i.e. "Big O" notation. There's a LOT of stuff so don't be super worried about absorbing everything, just keep it in the back of your mind to come back to when you feel like it. My short version of everything is: recursion can often simplify your code compared to a loop, but potentially at the cost of more memory due to more function calls. You have to decide which is more important based on your environment and use case. If I find something a bit more comprehensive, like a blog post, I'll link it here.
That is awesome, thanks very much for the helpful responses. 
Dude, it's a link to a youtube video and a transcript. It's not some paywalled rubbish. He's sharing what he's made for those that might be interested in the subject. So what if he hosts paid content elsewhere on his site? Besides, his shit is doap.
There seem to be two major approaches to organizing software - one is to have a folder per file type (components, scenes, actions, reducers, images, css, etc.), while the other is to have a folder per subsystem. The fact that subsystems can nest makes the second approach more scalable, for sure. This architecture seems like a hybrid of the two - you have things separated into four top-level types, but within each type, you have a nesting structure. This makes sense, since the four areas naturally have different sub-structures. The state, being normalized, usually doesn't correspond to the GUI layout, for example. On the other hand, I know that some teams like to think of their projects as collections of "little apps" that all plug together. If you drawing app has a chat area, the drawing app and the chat app are treated as two separate things that just happen to live together. With a true nesting architecture, it's not too hard to make this work. With your architecture, it seems like each of your sub-apps would need to be split into four pieces to fit into the `pages` / `modules` / `components` / `utils` breakdown. I'm not saying this is a problem, but I curious to hear your thoughts on this.
"I don't have anything to contribute to this discussion so I'll just personally abuse somebody" -- /u/ThePsion5
You are trying to access My_Items on null. Essentially your code is doing this: ``` null.My_Items ``` Are you certain that your myObject is being passed in properly by the Redux store. I think if you change these lines: let index; myObject.My_Items.map(item =&gt; { to this let index; console.log('myObject', myObject); myObject.My_Items.map(item =&gt; { you'll notice the myObject is null.
You can program addition manually by interpreting the aligned characters in the string and building a new string. "19" + "9" "9" + "9" = "18" push "8" remember "1" "1" + "1" = "2" pop all "28" 
I helped work on this a little bit! It's a way to build ARKit apps with just a few lines of JS. Here's what a demo looks like: https://i.makeagif.com/media/9-28-2017/gMnJTj.gif If you have a recent iPhone with iOS 11 and the Expo app installed, you can try it out on your phone instantly here: https://expo.io/@nikki/dire-dire-ducks We actually made it simple enough that you can play around with putting basic shapes in AR by just editing a few lines of code in your browser here: https://snack.expo.io/Hk1C_YqjW LMK if you have any feedback or questions :) 
You'll want to use a big number library ([math.js for example](http://mathjs.org/docs/datatypes/bignumbers.html)). Proper BigInt support [is coming to JavaScript](https://github.com/tc39/proposal-bigint) but it'll probably be a few months before implementations support it.
The drawing app and the chat app need not split into the four sub systems. The utils and modules are interfaces which are supposed to be consumed by the ui. And think of app as only the collection of relevant UIs that consume a certain set of predefined interfaces to do things outside the scope of rendering ui (ex fetching data from an api). If you have these two apps being rendered on Home.js page, then your folder structure will look something like this : app -src --pages ---Home.js ---home -----Chat.js -----Drawing.js -----chat -----drawing Here Chat.js and Drawing.js are two separate, self contained UIs that depend on common external services. This system works beautifully with one or many such external services. If your app has a single api, define an api util to expose the endpoint. If it has multiple micro apis, define multiple api endpoints in api util and import the relevant one in relevant components. This helps you make infinitely scalable react apps. There also might be some cases where the entire app has to be segregated into two. In that case, having the entire structure cloned is the best way to go: superApp -childApp1 --src ---pages ---utils ---modules ---etc -childApp2 --src ---pages ---utils ---modules ---etc 
https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
Firs, you want to break up the number you're adding into 4-digit blocks, buffered by zeros. For instance, you want to convert `20` to `[0020]` and `33 000` into `[0003, 3000]`. Then, you want to add each block together, carrying anything greater than or equal to `10 000`, eg if you have `9900 + 300 = 10200` then you'd carry to `1` to the next block and leave `0200` in the current block.
Thanks for clarifying that; it helps explain what you are doing a lot more.
that's why you should mentally ignore the names when patching. just consider the surrounding code structure.
Would I be able to do: * { cursor:pointer; } Are you able to test it for me? I don't have one. =(
I'd love to have someone to test a few things for 5 minutes - I don't have an iPhone. =(
Another option you should check out is Gulp ( [docs](https://github.com/gulpjs/gulp/blob/master/docs/API.md) ) Instead of trying to take the contents of 1 html file and output another html file, it would probably be best to use gulp to watch a directory(s) and when there is a modification to one of the files its' watching re-bundle the code. So basically you will just have 1 html file and as the bundled file keeps getting re-bundled the name of it never changes so you can just leave it in 'index.html' for example as `&lt;script src="bundle.js"&gt;&lt;/script&gt;` &amp;nbsp; `$ npm init` - you dont need a node project to use the package manager `$ npm i --global gulp-cli` `$ npm i --save-dev gulp-concat gulp-uglify gulp-sourcemaps gulp-minify-css` &amp;nbsp; Create a gulpfile.js in your root directory: // gulpfile.js var gulp = require('gulp'); var concat = require('gulp-concat'); // bundles all files into 1 var uglify = require('gulp-uglify'); // jumbles your code up for security var sourceMaps = require('gulp-sourcemaps'); // so your errors make sense consider code is jumbled var minifyCss = require('gulp-minify-css'); // You will want to modify these paths to match where your js/css is // right now its watching all js in `./src/javascripts/&lt;any_dir&gt;/file.js` and `./src/javascripts/file.js` // and the same for css var sourceFiles = { js: ['./src/javascripts/**/*.js', './src/javascripts/*.js'], css: ['./src/stylesheets/**/*.css', './src/stylesheets/*.css'] }; gulp.task('default', ['watch']); gulp.task('js', function() { return gulp.src(sourceFiles.js) .pipe(sourceMaps.init()) .pipe(uglify()) .pipe(concat('bundle.js')) .pipe(sourceMaps.write()) .pipe(gulp.dest('./public/javascripts')) // The destination of the bundled file &gt; `./public/javascripts/bundle.js` }); gulp.task('css', function() { return gulp.src(sourceFiles.css) .pipe(sourceMaps.init()) .pipe(minifyCss()) .pipe(concat('bundle.css')) .pipe(sourceMaps.write()) .pipe(gulp.dest('./public/stylesheets')) }); gulp.task('watch', function() { gulp.watch(sourceFiles.js, ['js']) gulp.watch(sourceFiles.css, ['css']) }); &amp;nbsp; To get it to watch, in your terminal: `$ gulp` &amp;nbsp; It should output some stuff and hang there. Make a modification to a file being watched (specified in `var sourceFiles ...`) and you will see it output some stuff and you should have a newly re-bundled file. I hope this works, I pulled it from an old project and didnt test it to see if it does. If it doesnt im sure you can look at the docs and figure it out.
I've tried with ontouchstart... but it's still not working. I can't test much at all - I don't have an iPhone.
/u/tyler-mcginnis you rock, man! You essentially single-handedly taught me React. Keep it up!
If you have an iPhone can you please get it going with the code? The touch events don't work!
#EDIT! #PLEASE HELP TO FIX! If you have an iPhone - could you PLEASE get the click event at the start to work? I don't have an iPhone to test it - but someone's said it doesn't work. PLLLLLLLLLLLLLLLEASE!
 How do you patch if you can't target a consistent symbol value? 
if you know the names of variables are going to change, but the overall structure of the code you're patching will stay the same you can try to detect the place you want to chage by different means, like the structure - what follows what in the code. In a life of death situation, I would have tried to do this with a library like jscodeshift I linked before.
Very very cool!
Thank you! You're very welcome. Glad I could help.
Awesome! Can't wait to check it out. Your package has saved me a lot of time thus far, and adding component will unmount support will make it usable for the entirety of my application.
But you patch by overwriting a symbol with a new implementation. If you don't overwrite it, it's not patching
Thank you, exactly what I needed !!
Word!
Thank you so much. I wish I'd seen this earlier, I spent the whole day learning gulp and ended up with something similar after a lot of issues. I do need to use the single html loading just 1 js/css because its a static site and I want to avoid multiple network calls. I also had issues since my code is ES6 and uglify doesn't work, I tried to use babel but finally found uglify-es. I also added imagemin and htmlmin so now its pretty decent flow and I have greatly reduced the bundle size. Now I'm looking for a way to strip out unused css/fonts since its using bootstrap and fontawesome which are both huge. Gulp so far seems very nice. 
If you are on a mac you don't need an iPhone 
I'm too poor for one. So I got a PC instead.
This is dope. I've been looking for something like this.
The author pointed to it being a code golf challenge (https://github.com/xem/ama/issues/14). As such, it's a wonderful example of squeezing a ton out of the language. Just looking at the code makes my head hurt. I can't say whether his use of eval is a concern or not, I'm not smart enough - nor do I have time to get smart enough. I'm very sorry for blindly condemning the use of a feature without first finding a security vulnerability in it. 
Is there one of these that works with code splitting yet?
And sometimes it means [this](https://youtu.be/bSUNWMXbbT8).
Explain please
the rest of us figured out that server side rendering was a bad idea a decade ago... https://medium.freecodecamp.org/heres-why-client-side-rendering-won-46a349fadb52
Your article is talking about traditional server-side rendering. The article posted is talking about rendering a modern web app built with React to just HTML on the server, which then gets hydrated back into HTML+Javascript on the browser. This is mostly done for SEO and is a common and often times required practice today. Lol.
and SEO is the job of the search engines, LOL. That is why they parse JS now, and always should have (and if they don't they lose). Everything in the article still applies, lol.
Use webpack dev server with hot reloading. It sounds like you’re doing a full build with any change and refreshing your page after, which is terrible. 
Check out /r/learnjavascript
If you use FireFox try [enabling web components](https://developer.mozilla.org/en-US/docs/Web/Web_Components#Enabling_Web_Components_in_Firefox).
I honestly can recommend: vanilla-js.com Just try to create your own helpers! When it comes to Reactive Programming Frameworks i cant think of something really newbie friendly. Most of them require fundamental js knowledge and will try to push you towards functional reactive programming, which is a completly different beast by itself. Talking about streams which are a core part to reactive i can recommend the library flyd! Thanks to its small code size you can try to understand what is going on in the background. But you asked for "frameworks"...: CycleJs with xstream.
I'm definitely doing dev server. The first build takes a ridiculously long time. I'm using this webpack encore thing which abstracts so much away that I have no idea what's going on. 
well, I ran it in the profiler (performance tab) in firefox and clicked a bunch of times, and there is a lot of garbage collection going on. Also there is an error in the console on the chrome version (doesn't appear in firefox), maybe the errant code isn't making as much garbage?!? dunno, but much less garbage collecting going on in chrome, but wtf is this? index.build.js?_v=e035244686036893856b6d56968038a7:27 Uncaught TypeError: Cannot read property 'postMessageCallback' of undefined at constructor.parsePostMessageQueue (index.build.js?_v=e035244686036893856b6d56968038a7:27) at constructor.index (index.build.js?_v=e035244686036893856b6d56968038a7:27) at constructor.executeContext (index.build.js?_v=e035244686036893856b6d56968038a7:27) at constructor.initialize (index.build.js?_v=e035244686036893856b6d56968038a7:27) at new constructor (index.build.js?_v=e035244686036893856b6d56968038a7:27) at Object.&lt;anonymous&gt; (index.build.js?_v=e035244686036893856b6d56968038a7:1) at e (index.build.js?_v=e035244686036893856b6d56968038a7:1) at Object.&lt;anonymous&gt; (index.build.js?_v=e035244686036893856b6d56968038a7:1) at e (index.build.js?_v=e035244686036893856b6d56968038a7:1) at index.build.js?_v=e035244686036893856b6d56968038a7:1 do some more debugging.
Ahh gotcha. Are you using any type of front end framework? React, angular, vue etc?
Definitely doing the incremental build. The first initial load takes about 1 minute. I'm using pretty much the stock [webpack encore setup ](https://github.com/symfony/webpack-encore) with dev-server. I spent another two hours trying the boilerplate webpack config that vue-cli sets up and couldn't get my directory structure to work. Part of me is regrets using an abstracted tool like Encore but the other part of me just doesn't want to deal with any of this. I'm wondering if the fact that I'm on a 2012 MBP has anything to do with it. I've tried running other basic webpack configs and they're faster but they're also hello world apps 
&gt; Most of them require fundamental js knowledge and will try to push you towards functional reactive programming, which is a completly different beast by itself. If that is the same thing as "fundamental CS knowledge", then I'm fine with that. I think I have it. I also have (non-production) haskell experience, and I like FP approach, if that's what you mean, so that shouldn't be a problem either. When I was talking about "newbie-friendly" what I really meant is I don't want the outlandish arcane syntax of angular2, which I've tried to learn some time ago, and gave up eventually. The problem with angular is not the fundamental concepts, but the magic by which it operates in effort to make it easier to use once you've ramped up. But I shouldn't be ranting about angular here. I know vanilla js, but I was hoping something better suited for the task has been invented over the last years. I don't necessarily need frameworks - it's more like I don't differentiate between "frameworks" and "libraries" very well. Will check out flyd, thanks! 
If you want to get into a large framework I recommend vue.js. It has a nice learning curve.
Yep--using Vue. I tried using the Vue cli template and gave up after two hours trying to migrate my project to use it. I'm sure I'll figure it out but it's hard to justify putting any more time into it. 
You can learn most of React by looking at a few examples. The new site FB made for it for instance shows you 4 code fragments, covers maybe 90% of what React is. This Egghead lesson is about an hour: https://egghead.io/courses/react-fundamentals The learning curve is small because it has a minimal api surface (you'll be needing just *one* most of the time), a documentation is often not needed, the new concepts are few, the api is stable and not subject to wild changes from version to version.
Most numbers in Javascript are [IEEE 754 double-precision floating point numbers](https://en.wikipedia.org/wiki/Double-precision_floating-point_format#IEEE_754_double-precision_binary_floating-point_format:_binary64). That means the largest integer you can accurately represent is 2^53 (AKA `Number.MAX_SAFE_INTEGER`) Most coding challenge authors know that there's an upper bound on the size of integers you can easily use. There's often a trick to get around having to compute very large numbers, but that depends on the rest of the question. And yes, you could just a big number library, but that's usually too slow for the challenge. By the way: `9.999e+23` means 9.999 * 10^23 . It's very common notation for displaying large numbers on computers.
Interesting concept. But is it practical?
I agree - Vue is really good for slowly getting into something like that. It's easy to add reactivity to just one thing at a time.
React does indeed look nice and much less scary than I imagined. Thanks a lot! It seems I'll go with it!
It’s not “informally injecting an array into a function” it’s making calls to functions with numerous arguments by constructing those arguments at run time, and is able to apply them to a function with unknown length. The whole point of the examples is that they’re not “your” functions - you merely are decorating them with your own behaviour. You cannot do that with an object or whatever you’re proposing. As for JIT, it makes no difference. And your example of adding properties to an object with a loop can actually hinder performance. I’ll say it again: there’s no way of doing the things in those examples without apply. And secondly, you don’t always get to rewrite the functions in the way you’d like. I suggest that you haven’t fully understood what apply does, how JIT optimisation works, or written much useful, higher order function-based library code. If you had done the latter, you wouldn’t be raising the points you are raising.
Wait – does this mean that you need to wait an hour until your bitcoin transaction is confirmed? How do the ecommerce sites that accept bitcoins operate – do you need to wait an hour after the purchase until your order is confirmed?
Hi /u/N_Dangel, this question is 1) a little too vague and 2) does not fit very well in /r/javascript. You're going to have to prove that you tried something before, what that is and pose it interestingly. With your current post, it's highly unlikely that you're going to have a contructive dialog with the rest of the community.
Take a look at Browserstack in that case
You have to wait a month for your credit card or more :-) No charge backs etc. exist for bitcoin, for example. The more confirmations the more secure. The recommendation is to wait for six confirmations. Every block added makes the transaction more secure. The blockchain is public and forever (unchangeable).
Thanks for you opinion! I completely agree that for some people it's no problem learning JavaScript and a JavaScript Framework at the same time. But for some it can be really overwhelming to learn it at the same time! Next time I will people advice people, I will take your thoughts with it ;-) I will update my post with your thought! Or if you want to put this in the comments it's also good!
I think the state management is more interesting than the view part for this. You can easily create an array of objects in js where each property matches a column in your spreadsheet. The problem is that with 2-way databinding (vue, angular, and others) change detection and re-paints are connected directly to the model. In a spreadsheet changing one cell value might cause another cell to get a new value which will cause another cell to update. And so on. This may cause messy code with 2-way bindings. Probably solvable but messy and you might end up separating the view model from the real model and then the bindings won't help much anymore. In contrast to this react is often used with single direction dataflow. You can search for the flux pattern for more info. Nowdays people are using redux more than pure flux but they are similar. Here you have a model somewhere and then there are actions that will update the model (no other parts should do that) and the view will just reflect what the model contains. It might be called to repaint itself many times from one use click. This is probably more in line with what you want. The first action, a cell-value-change, will be sent from the ui and the model will be updated. In redux the update is made by a reducer and in mobx it is done by an action method. The reducer or action can continue to update the model until they are done. When they are done the ui will show the result with any number of changed cells. This makes it easy to just write plain js code to handle all the logic for the calculation and tracking dependencies between cells.
A little clarification. I think this would work with react+mobx (my default choice), react+redux or vue+vuex. A lot of other combinations could work as well like cyclejs+mobx.
great answer and the only things I can think of right now to add is that the teams attitude and the experience and attitude in the organization also affects the choice. If most of the team knows angular but are very interested in vue it might be good to use vue. If most of the team knows vue but the rest of the organization is using angular you have to check if you are allowed to use something different (vue in this case) or if that is just gonna make everyone else annoyed and make it harder to let people switch teams. If the team is split between react and angular knowledge I would choose react since it is easier to learn but could compromise on vue since it is more similar to angular which will please half the team but still more modern and easier to use, like react, which might somewhat please the rest of the group. For teams without any clear experience and organizations where you can choose anything I would personally use react since it is very popular, powerful and easy to learn but in this scenario you should try to see what you and your team prefers.
As you know haskell elm might be up your street. 
Multiple cursor editing?
One more: `Object.getOwnPropertynames()` Similar like `Object.keys()`, but need to iterate within the object's prototype chain in order to get all properties.
not smart enough? don't underestimate yourself. sql injection is a much bigger threat in general that eval injection but people still put user input into databases every day. It's not complicated, you are smart enough. sanitize input and everything will be ok.
Amazing. Just wondering if their is some way of getting around the const classname = css`` syntax for every individual class.
I wish there was a prettier way to iterate over key value pairs. Something like: for(const { [key]: value } of myObj){ //... }
Hi /u/ratancs, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
it's much easier now. They actually discourage bubbling now, and encourage closure actions (meaning actions are props). The separation of 'concerns' is also a little more flexible. Like, you can use the store and the router now if you want from a component -- via 'services'.
Well if you consider a `for` loop pretty you might do something like for (const [key, value] of Object.entries(myObj)) { /* ... */ }
Nice dude, it's so amazing.
There is plenty of weird stuff in this article: * Using .map for side effect when there is .forEach is really weird. You're constructing an array for nothing. It is not explained the difference between the two of those and they are randomly used depending on the first method... * for ... in actually goes through the prototype, so this is not the same thing. Edit: Also Object.entries is ES 2017, not ES 2015...
You have an interesting definition of "pretty" if it includes for-loops.
Also performance, React is much faster when it's hydrating an already pre-rendered html than when it's rendering from scratch. Especially in React 16 where there is ReactDOM.hydrate which in the best cases only attach events.
Yeah, well, sadly search engine crawlers don't work well or at all with deferred html. 
Nice. 
Yeah the only reason I can think of why you might use `.map()` for side effects would be to maintain chainability, but then you'd at least have to return the element again...
says who? what engines?!? Sounds like they need to fix that, not every single page in existence. Quit being so goddamn accommodating and make them do their job.
That's just keys though...
I think it's prettier than calling a static function to get the entries of an object as an array of arrays and then looping over that
Most languages are block level scoped, it's just that the main enterprise/main stream languages are OOP these days. Javascript is also OOP compatible, it just doesn't force OOP.
Anyone know how this differs from `emotion`? They seem similar. https://medium.com/@tkh44/emotion-ad1c45c6d28b 
You might like [Object.entries](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) Object.entries(obj).forEach(([key, value]) =&gt; { console.log(key, value) }) Be aware it's an ES2017 feature and still needs transpilation.
It’s interesting how a blog entitled “Mr Frontend” isn’t responsive and cuts off on mobile. I can’t read the code blocks. iPhone 7 with Chrome latest. 
This is the uglier way mentioned in the article that I was referring to
Honestly, some people *really* shouldn't be writing blog posts.
Thanks for mentioning the problem! Can you post a link to a screenshot? I don't have a iPhone 7 😉
I thought .map was marginally faster than .forEach for some reason
https://i.imgur.com/2kTSCYp.png You can also open up dev tools in chrome and force the iPhone user agent. Please tell me you know this...
You [don't need a phone](https://i.imgur.com/BDXK04q.png) to reproduce this kind of thing.
Offcourse I knew 😉 ... I just was wondering what you exactly ment! ... Gonna change it!
The site has a lot of problems on mobile, friend. https://i.imgur.com/NibXflO.png this is what happens when you click on the menu. The whole site is pushed to the right. Also, consider using em units in your section spacing so when responsive kicks in things aren’t miles away. https://i.imgur.com/8bBfofa.png If you’re trying to start a business teaching people development, I’d say you need a bit more experience yourself. I personally would be upset if I paid money for bad advice. 
https://medium.com/@satya164/how-is-linaria-different-from-emotion-42e420a3984f
Thanks for letting me know! I appreciate all the message with feedback about the website!
No problem. Take care
Ok, thanks.
Even if it is currently, it may not be in a future update to the js interpreter, so that would be a bad reason to use one vs the other. Edit: I wanted to add a link to a relevant section of YDKJS - [microperformance](https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch6.md#microperformance)
I'll ask someone at work - I have a Sony Xperia XZ Premium and it works fine. . Showed it to someone last night that said "Goat's eyes don't look/move like that". . Here's a video: https://www.youtube.com/watch?v=2gb7tmHrTdg 
Having separate variables for each rules is better as it allows your linter to tell you about unused styles and typos, and it also plays nice with typecheckers such as flow.
You can use webpack for codesplitting: https://webpack.js.org/plugins/extract-text-webpack-plugin https://github.com/callstack/linaria/blob/master/docs/BUNDLERS_INTEGRATION.md#webpack
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [callstack/linaria/.../**BUNDLERS_INTEGRATION.md#webpack** (master → 15d7c80)](https://github.com/callstack/linaria/blob/15d7c80b78991bc275158aa4437061c18f778d45/docs/BUNDLERS_INTEGRATION.md#webpack) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dnoazy7.)^.
You're right
In the cell formula I put: =alert(A1) And an alert would pop up one after another until you close the tab.
If I recall, the animate function in jQuery takes an additional argument that is a callback that executes onces the animation is complete.
Yup, here's an example from the docs $( "#clickme" ).click(function() { $( "#book" ).animate({ opacity: 0.25, left: "+=50", height: "toggle" }, 5000, function() { // Animation complete. }); });
Thanks for the link!
Hi /u/FirstEvaDehumidifier, For javascript help, please visit /r/LearnJavascript. Thank you!
Thanks...wasn't aware of that subredit.
This interpolates at build time, would be pretty amazing to see a way to link interpolation with css variables... Not sure how feasible this is though.
good to know, thanks!
Hey try not to be a jerk to people learning and trying
Quit being a terrible developer. 
Yea, we're thinking about it https://github.com/callstack/linaria/issues/106
I frequently use .map for side affects to return an array of promises. i.e. (async (listOfIds) =&gt; { const returnObjectPromises = listOfIds.map(id =&gt; fetch(`some-url.com/api/object/${id}`).then(({ data }) =&gt; data)); const returnObjects = await Promise.all(returnObjectPromises); return returnObjects; })([1, 2, 3]);
&gt; I also don't necessarily need a "framework", and a "library" will do (I do not differentiate the two very well). [rxjs v5](https://github.com/ReactiveX/rxjs) is probably the most mainstream reactive functional programming library. Honestly, I would take a look at [angular](https://angular.io/) for a framework. It uses [typescript](https://www.typescriptlang.org/) and DI, so it could be more familiar for backend devs -- although I'm not sure with respect to the languages you've listed. It also has a nice [CLI](https://github.com/angular/angular-cli) for quickstarting a project and is heavily integrated with rxjs, ie you can integrate reactive patterns relatively easily.
[removed]
here is the link for slush: http://slushjs.github.io/#/
I feel like you’re getting a lot of heat about this blog post and the site, so I just want to say that while the comments aren’t wrong, some of them are pretty rude. Starting a blog and putting yourself out there is a scary endeavor, and I applaud your efforts. Keep getting better and keep posting blogs, because in the long run you’re going to learn a lot, and maybe one day you’ll get your name synonymous to “expert dev.” In the meantime, I think you’re being very positive to the overly-criticizing criticism, so bravo.
Yeah, but you’re returning, so those aren’t side effects. If you were initializing the promise array before iterating over it and pushing promises in, you would want to change that .map to a .forEach. Since you’re not, it’s not a valid comparison.
Hrm, I'd expect to see a setProperty call somewhere in there to update the value on fn invocation. This seems more about setting a calculated value once, rather than over time, maybe I'm misunderstanding it though.
I'm okay with people being jerks to novices pretending to have some authority over a topic.
[Cool](https://media.giphy.com/media/NvgkEvycaWhPi/giphy.gif)
Looks good, fast, and linking to MDN is very helpful. Lots of .html urls though
It'll extract the dynamic parts to a template, dynamically generate the CSS string from the template at runtime and insert it to the CSSOM. This is so that it works in browsers without CSS variables support. If the browser already supports CSS variables, it'll just use them. You can already use inline styles to set CSS variables with Linaria if browser support is not a concern. https://github.com/callstack/linaria/blob/master/docs/DYNAMIC_STYLES.md#css-custom-properties
It looks really pretty. I love the font. But why do they have to accordion the headers on the docs? Just introduces a pointless extra click.
wow. and people think *i'm* a douche bag.
Awesome! What is that live jsx editor?
It's noticeably fast, switching pages is almost jarring.
Think they did that so the whole section is fixed to the viewport (with a fallback for small screen devices). But agree, it's not the best solution.
I mean, this seems to me pretty elegant, as far as JS goes: Object.entries(obj).forEach(([key, val]) =&gt; { //do something })
Not sure why you're being downvoted, you are responding just like someone ought to in a situation like this.
Anyone know what color theme that is on code snippets?
How am I being a jerk?
Is there anything wrong/bad/"worth considering" about `.html` urls or is this more of a preference thing?
It is a mistake that they exist in the first place but really it's just an extra 5 characters that do nothing in the url
I don't think so. Unlike `.forEach()`, when you call `.map()` you must create an additional data structure and then copy into it. Both builtins are generally slower than for loops though if ultimate performance matters.
You can check this article https://developers.google.com/web/fundamentals/media/capturing-images/
if the connection is spotty on a mobile network, immediately retrying will probably not work unless the user teleported to a spot with better reception in the seconds between requests. I'd get pretty annoyed if I caught an app or website doing that.
I miss RFCs. :(
That's a great example for avoiding chaining.
You're not full of cynicism and superiority? There's no way you're a professional developer.
sounds like you've worked with a shitty API and you've embraced the hacks you've done to make it work and used them ever since. No I don't ever do this. Spotty mobile connections are for the browser developers and operating system engineers to figure out. Let them do their thing, they are much better at it than you are, trust me.
Both `keys` and `getOwnPropertyNames` only consider own properties. However, `getOwnPropertyNames` will return symbol properties where `keys` does not.
lol I've only been developing for 2 years (this month is my 2-year anniversary, in fact), but I don't think I could ever be like that. I've been writing "code" for years through AutoHotkey scripts, and I don't think I could ever look poorly upon it. While I don't like poorly-written code, I understand if it's someone that doesn't know compared to someone that doesn't care. Also, I know some decently-well-known developers, and the have all said the same thing: if you want to be known, you have to start a blog. While I feel I have a knack for writing, I always feel like what I would write about has already been written, so I like to encourage those that are starting out to continue on their journey. I've been told my coding is excellent - especially compared to my lack of years of experience - but I'm still not confident enough to start a blog, and I won't lie: this thread didn't make it any easier. ha ha 
they should have used .htm 😊
Well, Gatsby IS a static site generator. There's no reason to write off the .html. We live in a world where most people bookmark pages or search for them. No need to memorize urls, and therefore no reason not to have a .html extension.
If you need to implement retry then you should include a [backoff strategy](https://en.wikipedia.org/wiki/Exponential_backoff). 
So, no reason to have it then?
Think I saw that it's Oceanic Next. 
Willing to bet everything was on the table when it came to load time. And that includes rewrite rules.
Use let.
github button is broken
You could run the site in an automated browser (PhantomJS, Headless Chrome, Selenium, etc) and then actually 'search the search bar' or do whatever is needed to pull the data from the site on-demand. It's called web scraping, and I personally wouldn't recommend it for numerous reasons I don't feel like listing. Your best bet is either to find an API that you can get the data from. You could also scrape the data once (and periodically update), save that data to a local database, and then build your own API to pull the data from.
Looks cool. The code gave me cancer though
Thanks for answering :D I only have one question: Web Scraping is somehow bad for the website or is it more because it is not something so optimized? Sorry, but I'm not very used to servers so I do not understand much of the subject, I believe that if I make the bot access the website the same amount of times a person would access when searching something would cause no problem
Very nice to see more and more libraries migrating to TypeScript or being written in the first place using TypeScript :) 
They look ugly and have no benefit to the user... I think they should be left off, too.
I personally don't like ES6 style, but that's just my personal preference. I think I would like to mention the way you initialize an empty array. It's a much better cleaner style in my opinion to write `var arr = []` rather than `var arr = new Array;`.
So I was excited about Gatsby awhile ago and looked into using it until I discovered its dirty, dark secret; that the whole site was _always_ loaded in whole on first page load. Does anyone know if that's changed? I saw some people _trying_ to solve the problem with some hacky solutions back then... Is code-splitting and loading routes async a first-class thing in Gatsby now? If so, I may give it another look.
Turns out I was actually using an imagemin plugin. I think that plus copy was causing some issues. I switched to laravel mix and the difference is night and day. Webpack is incredible. Also purifycss is ridiculous. 
Haha. To be fair, OP warned us that it's messy. 
&gt; unless the user teleported to a spot with better reception in the seconds between requests Moving to in or out of a cellular dead zone, switching networks, pivoting from wifi to cellular, etc. I originally started doing this first when I built an iOS app that booted from an api call. The splash screen would load, and the app absolutely had to make contact with the home server in order to progress to the next screen. We tracked the frequency with which the app would fail to connect, then added the retries, and saw the problem drop off steeply. So in the wild, back in 2012, on iOS, this was warranted. I'm just not sure it's warranted anymore or under browser/JS application contexts.
Very small detail, but is there any particular reason your Integral/Derivative functions are using a different naming convention than your other functions (capitalizing the leading character)? I suggest sticking to a singular convention (camelcase being my favorite); if not for yourself than for anybody using/updating your code in the future :)
Agreed, you don't want to hammer a non-responsive server with retries - though it need not be complex: we just set our XHR attempts to fire 4 seconds apart, and quit after all 3 failed or if none of them return within 15 seconds from the first one.
&gt; Web Scraping is somehow bad for the website or is it more because it is not something so optimized? It is error prone, so if the site you are scraping decides to redesign their page you may need to change all of your scraping code in order to support the new site. Their could also be an issue of load on the server, but you don't really have a way of knowing that if you are not the server admin. You are mentioning a Wiki, so changes are they are using some well known Wiki software like MediaWiki, in which case try and find an API for that wiki software.
Entering an extention-less url will direct you to the correct html page.
I had a look at your website and it isn't the onclick function that is causing the issue. The issue is caused in your last script with the keyword, 'let'. I'd recommend you to review the block scope of the entire script. For more details: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let
Let me rephrase... the point of this library is to generate separate CSS files with little or no JS overhead. And every other CSS library I've seen with code splitting uses strings of CSS in JS, not as separate files (e.g. Create React App does this ... there's external CSS for the root bundle but CSS-in-JS for every code split). So my question is: Is yet a CSS library that generates separate files and that works with code splitting? 
Yeah, I usually do that. I just wanted to see people's reactions if I did that, and see if the general consensus is for or against it.
I usually capitalize functions that have more "advanced" parameters, like, in this case, a function taking in other functions. I also capitalize the first letter when I define objects using object constructor notation. Although, I will stick with *your* notation from now on.
Most style guides/books/linters etc will point you to creating new arrays with literals so `{}` and `[]`. 
Font is a little too big for my liking (luckily there is browser zoom), and scrollspy on the nav would be a massive QoL improvement for the tutorial. Other than that seems pretty good.
yeah im sure :)
In javascript you should only capitalise the first letter of a function if it's a Class. That's the standard. // ES6 class Foo { constructor () {} method () {} } //ES5 function Foo () {}; Foo.prototype.method = function method () {} new Foo()
I can mostly confirm that. I exclusively use that in all my editors and it looks just like it.
Yes, that's what I was talking about. Thank you for the correction.
It's a lightweight wrapper we wrote around react-live. Source is in the React GitHub, under www.
The creator was kind enough to let us use it on the site 😊
I can pass `prevState` to `setState` and access previous state?? What?!
thanks for the follow up! Yea, i figured SOMETHING was wrong given your description... it should be blazing fast! Glad you got it going.
o/
check the games wiki. perhaps it has an API you can hook into. that will be easier and faster than scraping their site (and easier on their servers). If not though, you'll have to scrape it. What discord bot wrapper are you using? If the javascript one check out: https://github.com/rchipka/node-osmosis that should get your started :) EDIT: as others have mentioned, it may be beneficial to get the data from your OWN api that you query a database for. Then your scraper can just be used as a every now and then thing making the whole thing much more robust. 
you can get the consensus looking up a popular javascript style guide in a much quicker way 
Just the ES6 or TypeScript
Got your ES5 and 6 backwards
Well, yes, I could have. But I also just wanted to see people pick apart my general coding style other than that, so that I could kill two birds with one stone.
it's mostly pretty good. just make it consistent in every sense of the word. 
no. sounds like a pain in the ass for no gain. 
Yes. That's for decoupling setState from the component.
what are we talking though a few dozen milliseconds? 
.ht would've been a little shorter to type.
My preferred method is to use "for of" and "Object.entries" for( let [key, value] of Object.entries(obj)) { ... }
As u/dotted mostly said already, web scraping is bad because: - If the site updates their HTML structure your bot either breaks or starts collecting invalid data. - The site might rate limit or ban entirely your IP. Then you have to deal with proxies to evade that. - Loading the entire site within a browser (or just downloading and parsing the HTML) is a lot more complicated and resource-intensive than an API. - Web scraping is most likely against their TOS.
When I’m interviewing someone for a senior frontend position I don’t expect them to be able to spout off the arguments to defineProperty or all of the methods on document. I expect that they’ll be fine just looking it up. However, if they don’t understand when to use a class or how to build a class (logically, I don’t mean whether they have memorized the syntax) or if they don’t have at least a high level understanding of how something like jQuery or React works then I wouldn’t hire them for a senior position.
The official troll comment built with no logic.
Having the side nav on the right bothers me more than it should ... it's fine, just unconventional - my eyes aren't used to looking to the right of the screen for navigational information. It's like putting a site into rtl.
can you elaborate on that? The reason is, is the only place where I'm using OO is extending React.Component. There's a ton of patterns for composing React components, some of them more functional in nature (like Recompose or function as child) so it's like I see positions that are like "must know raw javascript" but it's like what does that even mean? And where the heck am I going to be creating classes without extending? I for sure know about composition but that's more of a functional thing. It's very easy for me to learn but it's very hard for me to learn things of which I don't even know their immediate usage. I can't think of any reason (if I'm using react) that I would need to build constructors, extend them, and do all of this stuff. And I think we can both agree that not every company is going to be smart in their hiring process (e.g. I was failed on a non senior job interview 2 years ago for not understanding prototypical inheritance but it was funny because I asked the guy when I would need to understand this for working on basic React component and he said 'oh never for the most part'). I know my current company for sure has an asinine hiring process... I know for sure I'm effective at what I do, my team looks to me for all the answers, I make all the architectural decisions... but we all know companies are going to ask stuff like "ok what does console.log([] + {}) output" and it's just super super hard to prepare for all of these different things. So my questions to you would be, how much of that do you agree with? Understanding that there are companies not asking the best of questions, what are some things I can learn to ensure I get in the door for these types of companies, and how can I best learn them?
You're using `let` in a lot of places where `const` would make more sense.
It's still warranted IMHO but devs just do not care. They work with optic fibers and optimal wifi, and think the rest of the world is perfect.
It's a pain in the ass for sure, but the gain is there, even if only a smallish subset of users.
Thanks for all the answers, I'll try to find another way to search the information in the wiki
While I prefer writing free functions over classes, classes are something that is used in my company’s code because they encapsulate state with the operations that work on that state. My interpretation of knowing raw JavaScript is that you understand how libraries like React and jQuery work at least from a high level. I would expect that you would know how to build something with relying on jQuery or React even if that’s not something you’d do because knowing that is a proxy for knowing how to properly use your library, what its limitations are, and how to work around those limitations. When I look for a job I don’t attempt to study for silly questions like what [] + {} evaluates to. If I were asked something like that my answer would be that I can easily find out in a browser’s console or jsFiddle and that if I saw code like that my priority would be to fix that code since such a thing is - at best - someone being too clever but much more likely is a bug. If the company doesn’t accept that then I’m fine if they don’t hire me. I’m interviewing them as much as they are interviewing me. That said, I’ve never been asked such a question.
Bug on the home page. In the section: &gt; ### A Component Using External Plugins &gt; React is flexible and provides hooks that allow you to interface with other libraries and frameworks. This example uses \*\*remarkable**, an external Markdown library, to convert the textarea's value in real time. `**remarkable**` should ironically^? be rendered as markdown → **remarkable**.
Gatsby is a static site generator built with React
Yea, that has change. That was added with 1.0 a few months ago. 
You don't need to know all the JS browser API by heart, but you do need to be proficient in programming theory. * OOP (classes, interfaces, inheritance, composition) * Design patterns (observer, decorator, etc) * functional vs imperative * SOLID principles Specifically on JavaScript: * closures * higher order functions, currying, etc * ES6 and ES7 * advanced project configuration (webpack, node npm scripts, gulp, etc) These are the kind of things I look for when hiring a senior. I also expect proficiency in other programming languages. If you have only been exposed to JavaScript you are not ready to be a senior IMO. [Eric Elliot has a lot of articles on advanced JavaScript](https://medium.com/@_ericelliott).
General guidance is that you shouldn't need to put artifacts and by-products of your build in version control. Likewise, you shouldn't need to commit your emitted JavaScript code to version control
I was given a code challenge during a white board interview once. The guy wanted me to extend the array prototype with a string reverse method. I balked and said I don't typically work with prototype extensions, but said I'd give it a go. I asked a lot of questions and asked for validation while I worked on it. I thought I'd bombed the interview, but I got invited to a few more after that &amp; eventually got a senior gig there. In that job, I never had to monkey patch anything. They weren't simply testing my understanding of prototypal inheritance, but rather my ability to grapple with problems I didn't have easy answers to, and to communicate with others while trying to solve problems. The way I prepared for this level of interview was by reading Cracking the Coding Interview by Gayle Laakmann McDowell, who has screened applicants for some of the Big 5. It's pretty dense, but the first several chapters were incredibly enlightening to me as a self taught dev. FWIW, I don't think the trivia interviews are really worth worrying about. If some dipshit thinks knowing arcane facts like `[] + [] === ''` matter for the job, it's probably not a place you want to work. Use interviews to screen companies like they're screening you,… some places just aren't good fits for you. Lastly, watch out for arrogance. I don't know you personally, but a lot of your statements above sound kinda cocky &amp; defensive. One of the most valued traits amongst devs is the ability to quickly say when they don't know something &amp; ask the right questions to better understand. Arrogant devs tend to spin their wheels in futility on the company's dime when admitting knowledge gaps &amp; asking for help could make them smarter &amp; solve the problem in a few minutes. 
Hadn’t heard of Gatsby before, but just looked over the docs. I feel like I’m missing something about how this works. Aren’t static site generators and single-page applications kind of different things for different use cases? Or does Gatsby somehow bridge the gap and slow you to build some some parts of the site static-ly and load the rest of the site while the user is using static parts? I’ve been thinking recently about rebuilding some static sites using create-react-app, just for simplicity of building and deployment. But that initial react library load is a bit of a pain point, especially if you aren’t actually using it for much. Gatsby feels like a perfect fit for these projects. 
HTML file containing embedded code: https://pastebin.com/gFNkaajV Inspired by Kung-Fu Chess, Jutsu is a project I've spent the last 6 weeks or so designing. I'm a hobby programmer without a CS degree. Any feedback about gameplay, bugs, interface would be appreciated. I'd also like new ideas about game modes, features, art, etc.
&gt; Lastly, watch out for arrogance. I don't know you personally, but a lot of your statements above sound kinda cocky &amp; defensive. I have a couple of responses to that. Usually whenever I see a critique of the interview process anywhere on the web, it's always with this "well an interviewer wouldn't want to hire you anyway with that bad attitude" sort of deal and I assumed I'd hear it here as well. I don't see how that line of thought is necessary. I'm not a beginner at this necessarily. Maybe on the Javascript side, but I'm well seasoned (like over a decade) css engineer as well as being a skilled designer, project manager, etc. Only in the past couple of years have I tried to really get into the more senior technical side of Javascript. But I'm still a Senior in what I do currently. I think a certain level of confidence (and possibly arrogance) is appropriate as long as it's tempered with empathy for others, and an understanding of your pitfalls and weaknesses. Simple enough. I get a lot of new devs on my team who are absolute masters at interviewing but end up leaning on me a little bit too much as they don't have the field experience. I think many people would admit that interviews sometimes are inadequate of assessing an individuals skills, and more about memorization. Not that some people don't ask the right questions of course. I recently interviewed for a Senior position and I wasn't given a code review, just asked about process. I aced that. My realization is simply, when in rome. It's super easy for me to read some of these books and get the knowledge I need. If I can read a book in one week (or 3 books in a month) that help me ace an interview, that doesn't necessarily prove my expertise as a senior, it just means I've memorized a ton (essentially my argument is, if I knew the interview questions in advance, I could easily ace the test). Which is fine to me though! That's easy... just give me an overall template and I'll read whatever books or articles necessary. But I'd be doing that understanding that it's somewhat of a necessary evil. Again, that's just my experience in the hiring process and the interviewing process though. Not a big deal. Just to clarify though, I think a fundamental understanding of a lot of this stuff is important, but for what some employers are asking for (e.g. like my current job) we're asking more about theory and less about "ok here's a design of a grid, lay that out in css for me, describe how you'd lay that out". The questions are more like "what's specificity" or "what is an id's numerical specificity, would .blah.foo.blah.bar override an id selector" and it's just more book knowledge oriented rather than actually solving a problem. That's what i'm trying to get at. &gt; I was given a code challenge during a white board interview once. The guy wanted me to extend the array prototype with a string reverse method. Yeah I can do stuff like that. I'm more scared about them asking about much more obtuse stuff, but this at least gives me a bit of confidence. I think the main thing I need to do, is just build some simple app with nothing but classes. The other thing is, we're not really taught which way is the best approach for something. You have some people using classes for lifecycle methods in react, then you have some people creating higher order components for life cycles, or people just using recompose. You have people who consider redux functional or object oriented. It's sometimes hard to handle etherial questions like these when I can't find any worthy dialogue of it anywhere on the internet :D
I think its more to do with updating the correct version of state. `this.state` might be stale.
Hi /u/BaelDozer/, I just analyzed your comment history and found that you are a super positive commenter! Congratulations! [view results](http://ruadick.com/user/BaelDozer/) - Ranked #1723 of 154344 - I took the liberty of commenting here because you are an extreme outlier in the Reddit commenter community. Thanks for your contribution to this Reddit comment sentiment analyzation project. You can learn the ranking of any reddit user by mentioning my username along with the username of the Redditor you wish to analyze in a comment. Example: /u/opfeels/ /u/someusernamehere/
I have grown to hate OOP. But yeah. You should be familiar with the concepts, and when they might be appropriate to use (_never_). 
This wall of text is not helping your case. Take the constructive criticism and move on. People with higher-than-normal levels of subject matter expertise can always been from a reminder like you were just given.
Honestly, after reading this and your original post; it's your attitude more than any potential lack of knowledge that would make me question hiring you for a senior level position. You seem averse to learning OO because you don't seem to understand how it can help you become a better programmer, nor do you really seem to care. The best advice I can give you is this: check your ego. I'm sure you're a perfectly competent programmer, but you don't know what you don't know. I can tell you with 100% certainty, learning proper OOP/OOD will make you a better programmer; even if you only ever write jQuery or React. It will change the way you think about problems and give you more tools to come up with better solutions. As for your other question, I would say learn the language not the library. React is cool now, but the "benefit" of being a JS dev is that we get to use all these fancy new frameworks and libraries because what is cool changes so quickly. Knowing Javascript will allow you to adapt to these changes quicker and keep you employable longer. No one wants to be a Backbone dev in 2017.
Thanks, this Osmosis looks good and fast (or is what they promise haha), but i will try find a way without scrape as everyone is recommending, maybe get data (if that is not against terms of use) and make own api (and link original website/wiki/database) is the best option
yeah that's true. I think the hard thing is, understand what is worthy of learning and what isn't for screening purposes. Like I may run into the employer that will have me fully understand the DOM. I actually tried to get a job that used ClojureScript which is the functional approach and I've actually come to love FP and I use libraries like Ramda in production and people like Rich Hickey have these talks that expouse the evils of OO, so then in my head the question is like "ok should I ignore companies that require advanced OO understanding and go for companies that openly in their application advocate FP". But who knows if I have enough knowledge to know what I should screen and not screen for. So my current approach is to learn everything but I have to prioritize at the end of the day.
I couldn't agree more. 
There is no ego. I don't get this comment. I'm here to get advice. My position is job listings have a LOT of requirements they want of potential candidates. I'm not adverse to learning, it's that I understand there needs to be a prioritization as I can only absorb so much information. I'm currently doing courses on unit testing, on functional programming, on node.js, I just bought a book to learn SQL. It's not a "to learn or not to learn" approach. I just can only fit so absorption of knowledge into my head in a given period. One of the other commenters in this post essentially said it perfectly. There are some questions an interviewer can ask that essentially looks bad for them. Like if they spend the entire interview asking about nothing but coercion. So I'm mostly interested like the post says if OO is worthy of my time to learn.
If you want to bone up on OOP, read Practical Object Oriented Design in Ruby (POODR) by Sandi Metz. You don’t need to know Ruby, your strong background in JS will make it readable. It’s a quick read, she writes in a very pleasant, comfortable way that I find very enjoyable, and the approach to explaining OOP will stay with you, regardless of language. As for how much you should know, I’d say it’d be good to be able to confidently say when classes are and aren’t appropriate to use in a JS. (My rule of thumb is essentially “when an object has its own state, lifecycle, and behavior,” but there’s more to it.) Maybe be aware of how OOP can go wrong and why it often gets a bad rap. Regarding the sense that nobody uses them in JS, FWIW, I am responsible for a large React webapp and where I use classes, they are fantastic. There are dozens of us! DOZENS!
can you give me any examples or posts specifically extolling OO's usage in React? Are you referring just to extending React.Component, HOC's, or something else? I'll definitely check out the book. thanks.
FWIW, if this is how you roll in your interviews, you'd be a no hire on every hiring committee I've ever been behind. You're throwing negative signals in attitude &amp; self assessment. 
I have to respectfully disagree. I always appreciate the constructive criticism but like I said, even outside this specific post, people should be allowed to critique a process without someone making an assumption of ego. Your comment just shuts the conversation down. Don't we come to places like Reddit to talk about these things? I felt like I made an adequate case, albeit a rambly one, but was based on a digression of the original conversation anyway.
took on a legacy project with a committed bundle, I encountered merge conflict issues when 1) working in a team and two members give separate commits of the bundle and 2) when committing two separate branches (like when working on 2 tickets at the same time). just one thing less to worry about. 
It's not. Fortunately I have an opportunity to be a little bit more authentic here. I can say it in a nicer way sure, but there's definitely a big focus on passing the interview in some positions rather than being equipped for the job. I'm apart of hiring in a lot of situations as well. Again, I said at the outset that the conversation would devolve into this but I'm more interested in just having an authentic discussion but it seems someone is always dead set on bringing it back to the 'if this is your attitude, you wouldn't be hired' sort of line. I'm just concerned with how much object oriented programming is apart of senior level js. But thanks for your input. Edit: as far as arrogance, I think there's a bit of a misnomer here. Senior developers don't work by democratic rule. They are relied upon for distilling what is right, and what is wrong. If we take the positions and authority away, the senior should technically believe he is the right person in terms of providing value and guidance to the team otherwise why is he designated senior (i'm also not precluding the fact that the senior isn't leaving a lot open for discussion of course, but at the end of the day a lead makes the final decision given a difference in opinion).
I can't think of anything off the top of my head, unfortunately. My OOP approach comes from spending years with Ruby, where it is the law of the land. I can think of maybe one spot in my project where I extend `React.Component` to share some methods and I mostly regret it, that code is always harder to read and reason about. Here's my example of how and why OOP works well in my JS project. The most crucial parts of my OO code are something else entirely. My web app is used as a client for a hardware device. The device has a limited number of "modes," essentially, but each "mode" needs to respond to the same commands and give appropriate feedback. ("Start," "stop," "what mode is this," "on error do this," "on success do this," return other metadata, etc,..) A class hierarchy is great because I can use an abstract base class to outline all of the things that a class must do, and then I subclass it to set specifics for the various modes. Even though each subclass does the same stuff, the way it does it or the specific side-effects might change, but the things they can do and the ways they respond are consistent. There are plenty of other ways I could approach this but classes allow me to create single-responsibility objects with state, lifecycle, and behavior that are easy to grok, use, test, and maintain. I'll add that this didn't happen overnight. A lot of people hate OOP because it can lead to wild over-engineering. In my case, I played with a lot of different ways of handling this and it grew organically, albeit with a lot of regular refactoring. YMMV.
Gatsby is just a static site generator that you can write using react. So if you are used to using react, like the way they do components etc. It allows you to write react, but have a static site generated instead. Gatsby would be better than CRA for a static site (and if you have a small amount of dynamic content, that can easily be added too. Just not as react code).
thanks. this helps a ton.
Looks sexy, still not a fan of JSX although i already bundle shit with webpack, which in turn uses babel :/
I've interviewed a fair number of people and hired a few--some of them have been great. The best hires I've ever made have been the people that demonstrate the ability to handle a new challenge with curiosity, asked good questions, and helped me understand *how* they solve problems. That is at least half of being a "senior" in my book. I do expect someone coming in at a Senior level to have some mastery of advanced ready to show off, and ideally be able to teach me something in the process. That said, I haven't yet interviewed anyone I would consider a senior JS engineer with only two years of experience in software engineering. (CSS is coding and can certainly be complex at scale, but it's a different set of skills than a programming language like JavaScript.) Have you already interviewed for senior-level positions? If you have and aren't getting offers, you may be getting too caught up on getting the answer right instead of showing how you think and learn--and by extension how you could have a multiplier on a team. I'd do your best to balance time spent on books with practical experience solving problems outside the jQuery/React ecosystem. Contributing to OSS is a great way to learn from others and gain varied real world experience. Even better if you're squashing bugs! They're often harder than any interview question someone will throw at you.
The AI seems quite stupid - sometimes it moved the king into check, and it plays quite slowly, and has a propensity of questionable moves in the opening on a and h line. Would be interested in playing against humans. *How to Play* does nothing for me when clicked. I think the pieces are quite hard to read. I would very much prefer a more standard set, like [this one](https://pbs.twimg.com/media/DCcbEYGXcAIwTnD.jpg). I found it hard to distinguish pawns and bishops. Same goes for the color scheme - I'd prefer the standard from lichess, chess.com, or basically any decent chess program.
Nah, both serve their purposes right now. Coordinating scripts and version management with lerna will keep it around for a while, I'd wager.
Obligitory [Beware](https://www.reddit.com/r/javascript/comments/6q2lk0/why_composition_is_harder_with_classes/dku34cl/)^1 [referencing](https://www.reddit.com/r/javascript/comments/5c5lkq/what_eric_elliot_wants_to_say_can_somebody/d9u6tv3/)^2 or [learning](https://www.reddit.com/r/javascript/comments/3x91ac/why_not_to_hire_people_who_like_es6_classes/cy2o6zj/)^3 from Eric Elliott.
Eh, packaging and dependency management is a nontrivial problem space. I suggest you try to write a better one and tell me how it works out.
&gt; The reason is, is the only place where I'm using OO is extending React.Component. &gt; It's very easy for me to learn but it's very hard for me to learn things of which I don't even know their immediate usage. &gt; I'm well seasoned (like over a decade) css engineer as well as being a skilled designer What a bunch of bullshit. You obviously have no idea what you're doing and your arrogance is going to be a hindrance to you.
Consider it like this: you know that OO is a major paradigm and you know that people talk about it and you see very popular libraries use it. This should be enough evidence to say that it is an important thing to learn. If you don’t, how can you know whether the talks about the evils of OO are true? You’d only be able to regurgitate what someone else has said but it’s nearly a certainty that an interviewer prodding past the surface would see the lack of knowledge. If I were that interviewer I don’t see how I could come out of that thinking that that person would be a fit for a senior position. OO is in a very different category of knowledge than something like the DOM: it’s a strategy for how to build software rather than a library or API. It’s a general concept. Libraries and APIs can be learned or referenced with documentation but strategies require experience to understand.
Drop it man. I'm here asking questions so I'm obviously not that arrogant am I? Just message me privately if your sole goal is to insult me so we can keep the discussion here focused.
Why do people still follow him when he's proven to be wrong constantly?
I haven't interviewed yet. Just to give you the full explanation: I don't get that much time to actually study Javascript because I'm constantly just solving problems at my job. It's onboarding people to the current business logic, it's solving this css problem for that person, it's interfacing with QA and Project Managers, Code Reviews, and that's not counting any features I'm working on, or how much I get slacked. I work 40 hours a week and there's not too much energy to work on OSS outside of that. While I have only been doing it 2 years (admittedly not that long and not super advanced) I do act as the lead on the front end. The urgency is I feel I'd have more bandwidth at another company to grow as a developer during the 40 hours, rather than my current position in which I have to give up most of my weekends to go over material, articles teaching new paradigms and best practices so that I can make the right type choices. It's not necessarily a rush to keep up the jones' per se, I just know that there are different types of seniors and given my current responsibilities I want to get a job that forces me to grow as a developer, rather than that being squarely on my shoulders outside of work. I know there are senior front end positions that have a big focus on UX and CSS similar to my current positions, so I'm trying to find that happy ground of finding a position that can take use of those talents, while giving me enough room to grow as a JS developer. I think if I try to get just a regular position as a front end engineer then I wouldn't be given that room to grow, nor be able to make the type of decisions I should be making to prepare myself. Every Senior position need someone to already have senior experience essentially. That being said, I recently did a general screen where he essentially asked me questions like if I managed a team, how I go over code reviews, why I choose some of my tech stack. I feel good about the review... I may end of passing on that job as they require maybe a little bit too much seniority but I'm just looking for that happy medium, if that makes sense.
yeah. I think we're mostly in agreement. I definitely want to learn more and more javascript. I just wouldn't be too happy if I got in the interview and we spent 30 minutes talking about async approaches (thunks, promises, etc). I can easily dedicate like 2 weeks to learning a huge portion of OO, building a sample app, and then I'd be able to talk to it a lot better. You're right, it's a big aspect of the language so I should put a more central focus on that. The only thing I want to say, is I'm not lazy :) I literally bought like 6 books, I'm just having a hard time figuring out what to read. But I think I have my answer now. Thanks.
I agree - AI seems stupid and reacts slowly. Nevertheless overall concept seems cool, but it's just not very playable right now. 
Okay, that makes more sense. Read through the tutorial as well. So Gatsby isn’t intended as a replacement for a standard data-driven React app, but rather as a way to use React tooling and architecture for static (or misty static) sites?
Damn, I shouldn't code late at night. Thanks.
The site needs local and session storage permissions, and when you don't allow it, it simply does not render...
Thank you for your feedback! I changed from unicode pieces to transparent PNG images, and used a vinyl green color scheme. The AI mostly picks random moves right now, as I'm still researching search and evaluation. Multiplayer likely will come after I implement a tutorial and add an options menu. Learning sockets and node will be fun :)
There seems to be a bug where the player's turn is skipped if they double click on a piece.
Correct. CRA (and similar) uses React to make webapps (Single Page Apps). Gatsby uses React to create a website (Static Page Site).
Learning OO is great so you know that you should avoid it and why. 
I know a bit about all of these things and I can't find someone to hire me for my first jr position. :/
None. If a javascript job requires OOP knowledge you should avoid it. If it doesn't but they ask for it anyway, you should avoid the company. I interviewed for several senior developer jobs earlier this year and wasn't asked a single OOP related question. In one particular interview I got positive feedback for completing the coding tasks in a functional style, and they even got back in touch several months later asking if I'd reconsider my decision to accept a different offer. There are people here who'll vehemently disagree because Reddit seems to have a very pro-OOP culture. In the real world people have moved on to functional programming, and any job that has you writing a lot of object oriented code it going to be bad for your career.
Link no workie 
Whoops, looks like something went wrong.
I have not still got my head around graphql being readily available in components. Feels a bit magic happening there.
Do you use OO at work? In that case, none. I suspect that, by your running to reddit to ask this, your company is not advanced enough to use such things.
it seems like because random people link to him and say "here's a lot of articles about this" and then newbies think he knows what hes talking about
I would personally find it very concerning if an interviewee for a senior position didn't understand constructors (or even for an associate level back end position), however I am coming from the viewpoint of a back end developer, so I realize that is not necessarily fair. I would not consider myself qualified to interview a front end developer, plus I know that the division between the two varies by company. At my company, most of the front end devs do mostly CSS and just occasional JS. I don't see the "bad interview question" of prototypal inheritance as ridiculous, at least not in the way you are presenting it (when do you need it for understanding a basic react component). Are you planning on only ever working with react in your future work? Front end frameworks are always changing, even more than other areas of programming. Not to mention that within a certain job, you might sometimes be expected to work on stuff that may not be the library, framework, or even language you are most comfortable with. As a developer, I actually expect it. I also saw that you are thinking of learning some SQL. Which is fine, SQL is fun, database work is my favorite part of the job. But I would say that learning some OO would be far more likely to be beneficial in your day to day, as well as for interviews.
&gt; I can't think of any reason (if I'm using react) that I would need to build constructors, extend them, and do all of this stuff. Right - as long as you're playing around within one, small, tightly-defined framework or methodology you're happy and comfortable. The thing is that a **senior** dev (let alone a lead) should be comfortable in *multiple* frameworks, methodologies and coding styles (functional, OOP, etc). Junior and regular devs can work within the established guidelines - senior devs have to be able to step outside and compare and contrast multiple frameworks, methodologies and coding styles to decide which are most appropriate for a given project. If someone can't do that then they have no justification calling themselves a senior/lead dev. At best they're simply unready for senior responsibilities, and at worst they're just a hack with a [golden hammer](https://en.wikipedia.org/wiki/Law_of_the_instrument). The problem here is that your team is working in one library/framework, and you've got very experienced with that in isolation. That doesn't make you *general* senior engineer material though, if you don't even understand *how and why* you might ever use OOP, let alone be comfortable doing it. Senior engineers should be skilled carpenters who can choose their tools appropriately. You're apparently a really good hammer-ist, but that's not at all the same thing as even a middling carpenter, let alone a skilled one.
[removed]
The previous poster was rude so his point was lost. I'll try to phrase it less rudely, but it's an inherently unflattering one for you, so it's still going to sting a bit, for which I apologise: Anyone who will use a phrase like "seasoned... css engineer" in a software engineering discussion doesn't have the faintest clue what being a real software engineer involves. It's like showing up at Basic Training in the army and claiming you're a "seasoned veteran" at running around in the woods pointing sticks at people and going "pew pew pew". It doesn't get you respect - it just gets you laughed at because it highlights a complete lack of comprehension of what you're actually involved in. Don't get me wrong - as a full-stack principal software engineer who's been building websites since 1995, CSS is more complex at scale and definitely has a higher skill ceiling than most JS developers understand. However, it's basically still *remedial* level logic and engineering compared to programming. Front-end devs don't call themselves "seasoned CSS engineers" in the same way office admin assistants don't call themselves "fully literate" - you should be able to do it just to take the job, and it's far too trivial a discipline to specialise in, let alone brag about online to try to establish credibility or authority. If you're talking about software development, all your experience in PMing, CSS and man-management counts for exactly nothing because they're completely irrelevant skills. Reading through your comments you're apparently in a team leadership role because of age/duration of employment and soft skills, but that doesn't necessarily even make you a *good developer*, let alone one who's qualified for *technical* leadership.
Thanks for your comment! Means a lot to me! 🙏 For me, it is just about sharing! And I can't know everything, but I will learn a lot while doing this! So thanks for your support! I will continue even some of them are rude or not. Some don't mean it like that and some will mean it like that! But I embrace failure as a part of life. And when someone is on a good way, people will have comments and criticism! So because of that I will continue 😉
It doesn't matter. Use whatever you would be most comfortable with. Honestly, I would recommend making your game in Unity and building a WebGL target if you're already familiar with C#. 
console.log(“am I cool now?”) Edit: I guess not :(
You might want to take a look at phaser.io. It's a pretty cool JS game engine that's built on top of Pixi. 
Just a quick two cents. Senior level engineers study their craft on their own time. Not just on the job. Additionally, why do you feel you need the "senior" title if you feel you'd learn more at a different company? As a senior, a company would expect you to come in with the knowledge, not learn it.
I am a senior engineer in a .net shop, but I am the primarily Angular, typescript and JavaScript dev. Senior engineer roles are different in every company, but the common theme is that you will need to understand OOP, especially in a JavaScript role. JavaScript in particular has to be built to keep the global namespace to a minimum and that means a lot of mother objects, child objects and iife. I did not need to give text book answers to prototypical inheritance in my interview, but a lot was spent of modular code, objects, and ‘this’. I see that you have experience with popular frameworks and that’s always going to keep you well paid and employed. But imo a senior must be able to make code future proof, testable, and above all easy to read. There is simply no other way to do that without highly modular code that heavily pulls from OOP principals. I hope that helps you out.
This very statement shows otherwise. You still have a lot to learn before you should start considering a senior position. First, you should already be familiar enough with OOP to understand it's usefulness. Second, you do not have enough experience, period. A couple of years working with react and jQuery does not give you the experience you need to be a senior developer. This is evident in the fact that you hardly understand the DOM, let alone the other intricacies of the language, nor do you see it's value. Additionally, it doesn't sound like you're doing any studying on your own time. You will never get to a senior level without doing so. You get what you put in.
I don't really understand why a front-end developer needs to know about OOP. JavaScript has poor support for it. OOP is more than just classes and inheritance. It's about building better abstractions by hiding the representation of the data and limiting edit access to a few high level functions that model the object's behavior.
Its not common for me. My "diagraming" consists of writing some quick code. I generally think better when I start chipping away at a solution and then the flaws or ideas develop from there. All that being said I used a flowchart just last week and it really helped me out. I was working on a pretty complex set of requirements that could take different paths with different inputs and it just made sense to. Really helped me stay on track. My advice is use one when you think you should. 
[removed]
At some point, projects will become too large to hold in your head. Flowcharts, diagrams, and other documents are helpful for 'building' the app before one actually even starts to code. I'm working on app right now that although it has a fairly simple database, working it out on paper allowed me to visualize ways to better structure the tables.
7 years in the industry and I’ve never heard the title “CSS Engineer”. What exactly is he Engineering in CSS? Anyway couldn’t agree with you more. Well said post. 
Thank you for all of this! I will edit it right now.
Oops, must have mistyped. Thank you.
Of course, thank you.
You can use any and it will work great. Personally, I love typescript, but at compile time, it transpiles to JavaScript so it's essentially the same final product. There are some older browsers that don't support ES6 features, like classes. In typescript, the classes and typing you use get compiled into JS w/o classes, making it safer for all browsers. It may seem a little obtuse to go through the trouble of typing and making classes, but all of types are checked at compile time and if there are any issues (wrong parameters, assignment/declaration errors) the compiler throws an error before it transpiles to JS. The type safety is amazingly helpful as your project grows.
imo you need 10 years of experience programming and scripting on various projects before you can call yourself a senior. the definition of a senior is to be a mentor, so you should be able to properly teach your juniors, help them setup unit tests and e2e tests, solve problems no one else can figure out, or at least put your team members in the right direction. Depending on the company or job you would also have project management responsibilities etc.. so it suddenly is not just about being able to code. imo you would be ready to apply for a medior function. depending on what kind of company you're applying for. commercial agency? for sure. IT solutions production company? I don't think so, as you would be competing with Java graduates who switched to JavaScript for example. they will have an edge over you regarding code. Then again, there are more facets to that ofc. like are you a nice guy? you play FIFA or Overwatch? For me it's the first and mod timportant question I ask during an interview. Ah and stop using jQuery please. It's hardly needed anymore except if you need promise support for legacy browsers or something good luck and bless you. 
game development team at my company use phaser library and use typescript. they compile the typescript to es5 for compatibility reasons. their background is Java. so I suppose it would suit you.
I have now refactored my code with all of the suggestions. If you still have something to say, please feel free to comment still.
&gt; Personally, I love typescript, but at compile time, it transpiles to JavaScript so it's essentially the same final product. There are some older browsers that don't support ES6 features, like classes. In typescript, the classes and typing you use get compiled into JS w/o classes, making it safer for all browsers. I'm not sure why you're describing this as some sort of advantage of TS over ES6, when ES6 is also [compiled](https://babeljs.io/) down to ES5 by most people who use it in production today.
Good advice. I had a Computer Science class in high school, and we (the students) were taught to write pseudocode for *every* project no matter how small. 
For smaller projects, do **you** personally find flowcharts insignificant? 
Keep in mind that Pixi is just a render. Phaser uses an older version of Pixi (and I think is trying to move onto its own renderer) but also has physics, sound, controls, camera, etc.
Remember this: Rich Hickey is phenomenal at OOP. He understands it at a fundamental level, and he sees the value in it. He also sees how we can gain the same (or better!) value by applying the same principles in other ways. If you study and understand what OO programming *actually is*, you'll understand that you can leverage the benefits of OO in FP languages, and vice-versa. What he rails against is not OOP as a concept, but *the way* OOP is used in the industry. Funnily enough, functional programming is gathering the same cult-like following that OOP has had for the last thirty years. I'm sure in 10 years people will be writing blog posts about the bad practices that FP instills in its users and how OOP, or data-oriented programming, or some other paradigm is better. ¯\\\_(ツ)_/¯ The fact is that much of the world runs on C++, Java and other OO designed systems. If you can't even see the value in at least learning how to build, use and improve those systems, you're not only not ready to be in a senior or leadership position, you're not ready to work in many, many positions in the industry. The saddest thing is: you can probably find a company that will hire you on. I know plenty of "senior" developers who are framework monkeys; they can spout off the buzzwords and do the ceremonies, but they don't know *why*. They know what they've been *told to say* when asked, but they don't actually have the experience, wisdom or understanding to see the tradeoffs. Any good decisions they make are made accidentally; they happened to hop on the right hype train for the problem they're trying to solve, but it could just as easily have been the other way. Don't be them. Make good decisions on purpose! The scary thing for them is going to be when the industry moves on to the next paradigm/technology/framework-of-the-month, and they've invested so much capital (time, money, reputation, etc.) into the one thing they "know", and suddenly their framework-/technology- specific knowledge is worth a lot less. So here's my advice to you: go learn the DOM. Learn Java. Learn Clojure, and TypeScript. Learn SQL. Learn functional programming, object oriented programming, and other ways of thinking. Learn how to design systems that scale - with load, with scope and with development teams. Make actual decisions in your job about how to use these tools effectively. Make fuck ups, learn from them, correct them. Then you will be a *senior* developer. It sounds like what you actually want is to change jobs to a place that would allow you the ability to *learn* more, which is totally valid! Your current job is stifling your growth as a developer. You're shoe-horned into a position where you can only think about one thing (React, UI development, for a certain business), and that's bad. You should try to find a job that will put you in a position to work with smart people and work on different kinds of problems. I don't think you'll be successful in finding a place like that if you are seeking the title of "senior developer/engineer".
I diagram frequently, but it’s rarely in the same format. For work, I do it to visualize new sections of code I haven’t worked on before. For side projects, it’s a way to get the idea out of my head quickly so I can focus on each piece individually. I have several whiteboards hidden around my house, and carry a large boogie board in my backpack just for diagramming. To me, it’s and essential note taking and communication skill. 
i don't really mind. All that makes sense. I don't necessarily think mastering CSS makes me equipped for a senior JS role. I put this in another comment but my take is this. We have a current Senior at our job and I'm a fair bit past him. I feel like certain companies ask for a Senior but they really just want someone with development experience, who have put out production work. My thing, is to get a job, you have to already done the job. Like I said, I've been doing this a while, and in the jobs I have worked in, it's not the easiest thing for a person even who is great in CSS to transition over to the type of job I'd like. So my post specifically isn't "am I ready to be a senior". I just understand if I don't get a role with more responsibility and more room, then I'll just never have that experience. Even if I take a role as a general front end engineer, many companies in my experience will still look for leadership experience. So. My goal is to find a Senior Position that essentially acts as a Mid Level position. I know tons of Seniors who have more chops than me sure, but I also know a bunch who are just fantastic at jQuery, React, and have a bit of Javascript chops and get by. You get what I mean? Unfortunately this post has sort of turned into a "dude you're not senior level yet!" and "dude you can't have that attitude!". 
yeah see this is what I was sort of trying to ask. I'll make a super silly analogy but you know how there are people who believe the world is flat? I'm not one of them but I certainly believe there are enough people who have the basic knowledge that the world isn't flat for me to doubt it, and I doubt most of society could on the spot make a great argument without googling. A bunch of people have essentially said "oh even if you don't know OO you should learn it so you can talk to why you should or shouldn't use it". But I've heard enough people just vehemently be against OO that it's like... I think my point should at least be entertained that if enough people think the world is round, e.g. if enough people think OO is bad, then maybe I can skip it. People make similar arguments when it even comes to computers: 'you should know how a computer works'. But in my experience I've never needed to know bytecode. I'll most likely end up tempering what I learn with some of what was said, along with what you're saying. I do think a lot of companies will end up asking me about OO but be entirely ok with me taking a functional approach. And maybe at my level I should be more focused with just getting in the door, and then I can be pickier down the line. Thanks for the answer. Edit: just to clarify, I definitely should learn OOP. I just don't want to learn it just so I can get an OOP job.
To be clear, I’m not saying you’re lazy and I think that this thread has been significantly harder on you than you deserve. That said, I agree with the others that wouldn’t put you as a senior. You’ve gotten by, you are the resident expert, and perhaps you have the soft skills that you say you have. These are all very positive things. However, not knowing OO is a pretty large hole in knowledge. I get that you’re trying to prioritize your limited time but you should consider it required even if it doesn’t get used in an interview. My advice would be to look for junior or mid-level positions. This will give you a chance to continue learning while not adding the burden of needing to be a technical leader when really you’re looking to learn the skills necessary for that leadership.
There are plenty of professionals that deal only with CSS and are well regarded in the community. Nicole Sullivan is one of them. They have different names for sure, but there specialty is with dealing with CSS in gigantic systems. Take something like Bootstrap 4... sure there's some Javascript there but it takes people with tons of CSS experience to create something like that (and even the previous Bootstraps). Think about what Bootstrap brought to the game in terms of grid systems before Flexbox, before people being able to drop support for IE9. So it's easy to make comments like yours but they're rooted in arrogance I'm being accused of.
Reading through your post, it sounds like your company doesn't have a lot of experience in software development or have many senior developers. Senior engineers are not developer only, they are designers that are expected to be familiar with design pattern, system architecture. Idk about senior front end web dev, but most senior engineers don't concern themselves with most cutting edge tech because those are things intern can Google and do in a week, they solve problem thinking of scalability, maintainability, and bunch other illities. To be able to think at that level and have a vision from the over all project is what makes the engineer senior in my opinion, oo is just the very basic gate to introduce you into that path. Sorry if I'm being brutally honest and sound harsh, but the fact that you are asking this question doesn't show me you are ready to be a senior engineer. Like the other post say, senior engineer care about their craft, it's an art and passion at that point, and to be that way, you should know what you should know. From the companies I've worked with I can see you as a solid junior developer/engineer. But if you truly believe you are ready for the senior position, then don't let other people's opinion hold you back. Worst thing is they reject you and you learn some lesson, either way win win situations, maybe... Lol 
I don't really gain anything by flowcharts except in the very very abstract. Formal uml makes me understand the problem LESS. I do better with an ordered list of what should happen, or even an expected input and an expected output description.
Good to know, actually. Being pretty exclusive to TS when working w/ JavaScript, I wasn't aware most ES6 is also compiled down.
I rarely create diagrams as a part of the design phase anymore, I iterate too fast and they get out-of-date shortly after I create them. Sometimes it's useful to just get thoughts down, but those types of diagrams are temporary and rarely get shared, something like [ERD's](https://www.smartdraw.com/entity-relationship-diagram/) and [DFD's](https://en.wikipedia.org/wiki/Data_flow_diagram). Sometimes, for larger projects, I'll create some diagrams post facto to convey complex topics to team members. Flowcharts are the most basic, I usually go for [Use case diagrams](https://en.wikipedia.org/wiki/Use_case_diagram) and [Activity diagrams](https://en.wikipedia.org/wiki/Activity_diagram) instead; they're good for showing workflows and can highlight any missing steps. And [Sequence diagrams](https://en.wikipedia.org/wiki/Sequence_diagram) are good to convey the timing of things, which can help highlight interactions with the backend.
I've use Typescript with Pixi and it works great. Even the Pixi plugins I've used for animation (pixi-spine, pixi-dragonbones) were written in TS and have types. I strongly recommend it. For audio I've used Howler.js and it also has types.
I wouldn't. It adds like 50MB for a hello world and doesn't support mobile browsers. Using pixi for a 2D game will give you a much more efficient result. Plus it's easy to set up hot reloads and use HTML/CSS (along with React, Mithril, Vue etc.) for the gui.
It almost allows you redux-like central state handling as well, which is pretty neat: https://twitter.com/dan_abramov/status/824308413559668744
I stand corrected. Just hadn’t realized the title before. Figured it all fell under front end. It’s all pretty ambiguous anyway. 
I find flowcharts are useful on any sized application that has user roles (user vs admin vs seller vs customer), or defined steps (like a survey). I'll also use logic diagrams for individual functions (like a survey that calculates a single outcome/suggestion). 
I 100% agree with everything in your post. My only hope is that I don't learn OOP and then that gets me in the door with companies that are using OOP the wrong way, and now I'm stuck continuing in that way. I'll just have to be diligent about that and ask the company "how does your company use OOP vs FP and why". The points about Rich Hickey are enlightening though, thanks. Working with FP, it's clear that it can devolve into a bit of obtuseness... you have all these well defined functions that are unit tested, small, but the problem is, if anyone wants to do anything, they need to spend like a couple of weeks studying all these functions before they can work on the system. I can definitely see how using Recompose to compose a component potentially could get seriously out of hand (oh let's just decorate this component with 6 or 7 higher order components, instead of just using a class. That's just silly). I do have some basic understandings in terms of OOP dealing with domains that probably should have coupled methods, and FP mostly being concerned with transforming data? That could be wrong but I'll continue learning. &gt; he saddest thing is: you can probably find a company that will hire you on. Oh yeah that's what I've been trying to get at. I've done interviews previously. I know what type of questions are asked. I know tons of Seniors who don't have the experience I do, even if I myself can't technically be considered a "senior". The only goal is just to level up, it wasn't to get on Reddit and be like "hey guys I'm a senior right? I have css experience" but a bunch of people always foam at the mouth and turn it into that. I definitely without a doubt can pass most of these OO screens. Define a method on a reference type (e.g. [].customMethod)? Sure I can do that. I can study for those type of questions and ace them. &gt; You should try to find a job that will put you in a position to work with smart people and work on different kinds of problems. I don't think you'll be successful in finding a place like that if you are seeking the title of "senior developer/engineer". This is tough. I've been looking around and I really can't find an adequate place like this. Every single job dealing with the type of JS I want to deal with is asking for seniority. I'll be honest...I probably make senior type of money. My company needs me as I lead the charge in a lot of different aspects. Finding a company that let's me leverage the non js experience I do have, while giving me the chance to make architectural decisions (which I'd need for senior positions), while still making close to 6 figures is going to be hard. I'm willing to take a pay cut but I'm sort of between a rock and a hard place. I'll tell you this though... if I can find a job even remotely close to that, then I'll jump at it. My current goal (unless I can find that) is sort of leverage my experience developing mobile friendly responsive sites and acting as the lead and having experience with React / Redux focused architectures to make that transition. But again, if I can find anything like what you're describing, I'll jump at it. Edit: I'm finding some stuff. I'll give it a shot. Thanks again.
The difference between you and op is that you confidently know or believe one way or the other. That's the level of understanding senior position should have.
I'm ok with studying on my own time. It's what I've done for many years. I just want to have a life outside of being an engineer. The past year has been 5 days of work, then 2 full days of studying. I just would like work / life balance and being able to have a bit of a life.
Early on, I’ll write a user story and either create tasks for the high-level steps or just jot them down in my notebook. If I’m working backend or dealing entirely with business logic in the client, I’ll write some tests as soon as I’ve identified testable behavior. That’s usually it. Sequence diagrams are excellent tools when you’re trying to learn a large system and understand how pieces fit together. I’ve used them for both new codebases when trying to get acclaimated and for my own refactoring.
They're only really helpful to communicate your ideas to others. If it's solo work, I never make them. 
I do draw quite a bunch of different formal or informal diagrams. I sometimes draw them for myself, to better reason about some general idea, but most of them I draw to communicate to others either how they should do something or how something is currently working. One thing I've found about these is that most of the time I draw them with the other(s) person(s) in front, while explaining, and it helps their understanding. They are temporary and understood to be so; they can _live_ for a few days or for a couple of months. I do sometimes draw some diagram that "survives" longer.
Are their docs now running in gatsby?
No.
I moved two times and the AI started moving without waiting for my turns hahah https://i.imgur.com/MNRWPJy.png
The boogie board takes dedication, my friend. I never thought about using a whiteboard for diagrams, but it sounds like it could really help.
The boogie board takes dedication, my friend. I never thought about using a whiteboard for diagrams, but it sounds like it could really help.
You don't find the "expected input and output" too simple? Granted I don't know how much experience you have.
Seems to be that diagrams = awesome communication method. I myself am more of a lone wolf, however. It's not like I would take a picture of my flowchart and upload it with my GitHub repo, that just doesn't happen. Teams usually rely on clean and commented code... Interesting views.
For those unfamiliar, this is Netflix's data-fetching system, similar(ish) to GraphQL, which they developed for their own JS clients and open sourced a couple years ago. It made a big splash back them, but carried 0.x and "dev preview" labels ever since. Both those labels have been removed, quietly, within the last week, and in fact there's a 2.x release candidate in the works too. It's a battle-tested and kickass library which I highly recommend. I just wish Netflix would beef up the team and promote it a little better!
I still wish they supported search via query string parameters so I could add it as a search engine in chrome.
If you're looking for a "better Backbone", then the [Ampersand.js library](https://ampersandjs.com/) (which the author Henrik Joreteg helped create) is kind of like a Backbone 2.0 in a lot of ways. However, while Backbone/Ampersand may still be useful in some cases, time has exposed a lot of the weaknesses in Backbone's approach, and the Backbone community and ecosystem have mostly died off. At this point, I would highly recommend learning React instead. (It's worth noting that Henrik Joreteg has switched over to using React as well.) So, let me pass on a few resources for getting started with React, and modern web dev in general. The article "A Study Plan to Cure Javascript Fatigue" ( https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1 ) is a great place to start. It gives an excellent series of steps for tackling modern Javascript concepts one piece at a time: Javascript, React, ES6, and state management. There's also a "Front-End Study Guide" based on that article that's very good, at https://github.com/grab/front-end-guide . For React specifically, you should start out by reading through the official React docs and tutorial at https://facebook.github.io/react/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. There's an excellent post called "Simple React Development in 2017" ( https://hackernoon.com/simple-react-development-in-2017-113bd563691f ) that gives some more specific instructions on the actual steps to follow. For an even simpler setup, CodeSandbox ( https://codesandbox.io ) is an online editor that lets you build entire React projects right away. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, Redux, and much more. I also published an "Intro to React (and Redux)" presentation at http://blog.isquaredsoftware.com/2017/02/presentation-react-redux-intro/ , which is a good overview of the basic concepts for both React and Redux. Finally, the Reactiflux chat channels on Discord are a great place to hang out, ask questions, and learn. The invite link is at https://www.reactiflux.com .
What aspects of Backbone are you asking about? The library has lots of different concepts that can be used in different parts of an application (eg. routing and history, models, event handling, views [albeit, limited, you might wanna use Mariotte.JS instead, which is an extension of Backbone Views], misc utility functionality, etc). Vue and React are *only* view-centric libraries, so if you are needing to manage 'state' or complex data, then you'll have to supplement those libraries with additional libraries (eg. a common library for React applications for this is Redux, and Vuex for Vue IIRC). If you want routing, you'll again have to supplement React and Vue (right?) with additional libraries to get this functionality, etc. Angular and Ember have more of this state management, routing, etc, that might make for a more 'holistic' learning experience. Ie. it might be more confusing to learn about React, Redux, React-Router, etc, for getting a simple application going, when something like Angular can do all of the things the previous 3 can do. But keep in mind of the tradeoffs associated with a large and encompassing libraries - the short-term convenience might lock you into a corner down the road. If sometime down the road you decided that you wanted to change one small aspect of your stack, like swapping out Angular templates/view with another rendering/view library, it would be much harder to do so with these larger libraries than the smaller more specific libraries.
I use them. Even for small projects. The chart may not look the same though. E.g.: A small project might just be words with various lines. A big project might be a formal chart with differing shapes for to indicate some logic. 
Thanks a lot. Yes, whilst I haven't been advancing (been doing other things) I have been into react.js for a long time. But, I just started reading the human js book and the idea of playing with building my own framework slash code oraganization workflow sounded as a good learning experience. Not for production, just **I tried looking under the hood of react js and I get lost, so thought looking under the hood of backbone and replicating some of it** might be a good way to learn javascript and hence know more about how react (and future js frameworks) work under the hood. Do you think it's a good idea for me to do what I thought of doing? That is, try and do something like Henrik did with Ampersand (I assume) take backbone and make it better. But in my case, take backbone and learn how they did that they did. **It might be easier then taking react and learning how it does what it does** Or will the links you provided teach enough that I do not need to go through this
I'd use es6. It's got a lot of nice features and if you use babe it can backwards compile. Also how long until you come out with a game? Over the next few years browser's will get better and old tech will keep dying. Build in what is fun to build with.
Of course each circumstance may be different and require different approaches. To me, though, code is already a product and the diagrams help _before_ that point. Not that code can't change, of course, but there is usually a time before going into coding where there's a lot of talk and discussion that, sometimes, is better done over a table with some paper or boards. But, again, there is no right or wrong approach, just one that works better for that circumstance.
Yes most people do this using Babel, but running ES6 code in an old browser won't work, while running transpiled TS code into that browser will, so there's still some advantage there. In an ideal world no one would have to use Babel ever.
you can use any of the vitual-dom libs to create your own structure/architecture and still benefit from modern best practices (declarative, reactive, fast, ssr/hydration). some other things would be harder without significantly adding to the workflow/tooling, like code-splitting, HMR, css scoping &amp; optimization. Mithril is a good one, [domvm](https://github.com/leeoniya/domvm) is what i wrote and use. there are plenty of other good micro options in [this list](https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html) that won't make you swallow a lot of pre-defined conventions. 
From my point of view the difference between a senior and junior is his best practices and business Know-how. From a junior developer I would expect that I could dump a Api in there laps and in ~2 weeks they are up and running with constant questions and directions given A senior I expected to be able to help us evolve the development cycle. Self learn the needs for the project. Acting as a mentor for juniors in the project. Be able to tackle the hardest parts. And be able to be first on the scene setting everything up according to best practices. Your decisions will make or break the timeframe. I was recently on a interview for senior QA and by showing just key points then talking about project setup and how I would do it I landed the job. (I’m both fronted dev and QA). 
Why? I'm not a company built around being a package manager. npm stomped out the competition by being first and getting packaged with node and then stagnated until yarn came along and forced them to actually improve.
Yes, indeed. I also expect a senior to be able to distinguish between the bs and the good articles he has.
Sure, but if both TS and ES6 can be (and are) transpiled in production for browser compatibility, you can't really use that feature to argue that one's better than the other. Hell, not that it matters, but you could even argue that ES6 is better in this respect because TS _has_ to be transpiled to run in the browser, whereas ES6 will (for the most part) run natively in modern browsers, and only has to be transpiled to support legacy browsers. 
So it's like a query language / framework for json data? I still don't get it :\ 
https://i.imgur.com/l2ShMe1.png Whoops, looks like someone needs to do a bit of Laravelling.
The inimitable Jafar Husain has given a number of talks on the hows and whys of Falcor, for example [here](https://www.youtube.com/watch?v=nxQweyTUj5s).
$('javascript').find('Something cool')
Yes
As much as I find this interesting I hate it when the readme does lack an abstract about what the content of the repo is supposed to do. 
Why ts over es6
I've been developing for a while now and I'm still not really sure what the hell is the point of classes. I lean heavily toward functional programming. Can you give me an ELI5 what the real benefit is for using classes?
You could really do both. They work in tangent with one another and don't really compete. TS gives you your type checking, es6 gives you everything else.
Not usually. I rarely need others to tell me how to accomplish the goal. As the head (and only) UI programmer at my company, I usually am the one to come up with the way to solve the problem, minimizing user confusion. So just knowing what the user and server expect is all I need 95% of the time.
Sometimes I make some simple unstructured diagrams before I start programming, or when I decide to restructure a program. Diagrams are a good way to check that your dependencies and control flow look good, or just share your ideas with other people for sanity checks. They might be useful for documentation, too, but often I find that they're either too abstract, or disagree with how the code actually works.
When I think of diagram, *abstract* is the word that comes to mind. I feel like the only way a diagram can ever be completely **awesome** is if it has every little detail about the project.
Neat. I think some people may not understand what's going on. The game is RTS (real time strategy), there are no turns and you can move as many pieces as you like at once. When a piece has moved it's put in cooldown mode so you can't hop around the map. The AI appears to only make a move once every 4 seconds which makes it very easy to win. 
Classes unify a set of related operations and the state that those operations work over. They help to make using that data and those operations more natural and intuitive. There is a false dichotomy between OOP and FP: they are not mutually exclusive and can be used together. In fact, the best use of OOP minimizes the number of operations on a class and relies on generic functions for the rest. In my opinion, the C++ standard library is a great example of the right way to use classes and objects (when you ignore older parts like iosteam and basic_string).
Depending on what parts of Backbone you're interested in, but MobX may be worth a look if it's the observability side of it (and generating derivations and views from it automatically).
I use react, with webpack and all the up to date tooling. The problem is that I'm still a beginner - maybe an intermediate. My thinking is, if I go through the process of creating my own structure/architecture by copying something like backbone, I might be a bit close to understanding more advanced javascript. 
It looks like you are running Windows, but are using a linux-style path for babel-node. Recheck your configuration. At quick glance, it looks like step 6 of that guide is likely where you went astray.
The closest I get is to "diagram" in code comments. My project will start out looking like this. // TODO: Check if an email address was passed // TODO: Check if the email address is valid // TODO: If there is a matching record // TODO: Load the record // TODO: Create a new record I indent it a little differently but you get the idea. Once I've written the code I take out the TODO but leave the comments.
Calling it a "query language" is a bit of a stretch. The goal is more to be able to interact with your data model as a normal JSON object, but with a few extra niceties thrown in. See the link posted elsewhere in this thread by /u/bterlson_.
I coded a chrome extension for colleagues at work. When you click the icon, it tells you when the next free-food event is and which team is in charge of organising it. I tested my code to work until year 275000. I'm also happy about the design of it. 
Yeah me too. But I never do it. However, I usually think tasks through in a detailed manner before I start, so kinda using pseudocode in my head.
[removed]
&gt; My thinking is, if I go through the process of creating my own structure/architecture that's true &gt; by copying something like backbone you'd likely be better off creating complex React components, learning streams, promises, immutable structures, etc.
One of the few answers I have actually never thought about. I guess comments can be used for more than just "what x and y does". Might use this technique. 
Saw the video you mentioned. Thanks. &gt; which I highly recommend Since you've used it- isn't is more difficult to maintain code when you are requesting data based on string? (Like those get-value functions you are passing JSON syntax but as a string)
I honestly thought it had been abandoned. I remember researching it and GraphQL about a year ago and deciding that GraphQL had way more support from both Facebook and the community; are more people using Falcor now?
Phaser is cool until you start getting memory leaks. Edit: I'm serious. Sometimes you have to spend as much time fighting memory leaks as you do for actually developing game features.
Jump on TypeScript, you'll love it.
Best idea is to never push builds!
They’d get a lot more traction with Falcor if it wasn’t so domain-specific. 
Anyone that says they have no ego, is indeed a liar. 
Just the source plus * tsconfig.json if you're using TypeScript * .babelrc if you're using ES6 with Babel * the appropriate config file if you're using something else so that whoever pulls a certain commit gets the same output.
Im unsure why you're looping so much for such a simple thing.
I'm trying to let the user enter as many grades as they want until they want to stop. I'm sorry, I'm still new to this.
lol it seems like... you just know react like knowing basic OOP stuff is probably a minimum for seniors and the fact that you're saying 'i don't see any use of OOP outside of extending React.Component' means you're very very far from senior
Not only is that an exaggeration, it's just an extremely ignorant comment, and doesn't actually reply to the actual point I made.
[Lossst](http://js13kgames.com/games/lossst/index.html) was amazing!
I hate you for this.
If it has *all* the details, it's basically code sans the great tools. And unless you are generating one from the other, they are bound to get out of sync. That's why I find diagrams to be most useful as a design tool, *before* the code exists.
I think it's mostly a relic from lower-level languages and worse tools. Pseudo-code loses its meaning when real code can be as readable and *faster* to write.
If I understand your question correctly, in Falcor a JSON path can be represented either as a string `'genres[2].title'` or as an array `['genres', 2, 'title']`. And then most of the time in your code one or more of those elements will be a variable: `['genres', idx, 'title']`
Not sure if it addresses your concern fully, but their main documentation site isn't the repo readme, but the github page: http://netflix.github.io/falcor/ I only linked the repo because it mentions the 1.0 thing front and center.
&gt; I honestly thought it had been abandoned. Haha, nope! If you think of it this way, Netflix accounts for 1/3 of internet traffic planet-wide, and Netflix's clients use Falcor. Granted, the content streams, which make up essentially all of that traffic, don't flow through Falcor, just metadata, but still. &gt; are more people using Falcor now? Not sure, but I think it's safe to say GraphQL has more visibility in the JS community at this point. *[edit for clarity]*
let FoundSomethingCool = false; console.log(“Will edit this comment when I find something cool”);
I use diagrams only if the architecture is complicated. My primary objective creating architectures that do not need diagrams at all.
With such a bold statement like that (entirely kidding), wouldn't your project be less than 200 lines of code? (just guessing)
Here: https://codepen.io/anon/pen/pWrvMm
I think you're right. Never thought about it that way. One of my co-workers actually ended up writing Cobol and he used a lot of diagrams and pseudocode to plan his programs. Cobol isn't exactly intuitive to write the way modern languages are and it helped him immensely 
I find flow charts very useful when explaining a system to someone who is new to working with it or if someone needs to understand the root cause of a defect. It is also helpful for documentation to sum up all of the moving parts nicely without having to be too verbose.
1. Do not commit artifacts to the source code repo. 2. Make sure you are using npm &gt; 5 or yarn so the TypeScript version used to compile will be locked via the package-lock.json or yarn.lock file to provide a consistent env across all dev machines. 
When creating a new flow or product stream for a commercial project, yes, I always ask for wireframes. How a user moves from entry, conversion, and finally exit is a big deal and everybody needs to be on the same sheet of music. For personal projects bullet points are enough planning for me, even when working in teams. The scope of effort tends to be more narrow even if the work is typically far more challenging.
Hey, it's better than ads.
Yeah, the internals of React and Backbone are a tradeoff. One of the things I _do_ like about Backbone (and Ampersand) is that the internals are small, straightforward, and synchronous. It's entirely feasible to put a breakpoint in your own code, step through Backbone's internals, and keep stepping until you reach your own code again to see what's happening. However, Backbone has weaknesses around things like composing child Views, event chains triggering random behavior around an application, managing nested or relational data, and updating the DOM. There's a few hundred Backbone addons that try to help with the various use cases, but many of them clash with each other's behavior. On the other hand, React's internals are still basically a black box to me. While I've glanced at the source a few times, I've never tried to seriously go through the implementation to understand exactly how everything works internally. However, **React provides me with a fundamentally superior mental model for how my app will behave**. So, when I do make a mistake and see an error, I can generally ignore the React-specific lines of that stack trace. Instead, I can look at the error message React gives me, think about what happened relative to my components and my data, and trace the data flow back upwards through the parent components. That means that I don't have to actually know or care how React is implemented internally - I just need to understand how my React components behave. Now, if you're really interested in how React works internally, my links list has a whole section on [miniature "build-your-own React" examples, and the real React implementation](https://github.com/markerikson/react-redux-links/blob/master/react-implementation.md). But, **I would encourage you to first learn how to _use_ React**, and _then_ try to understand how it works under the hood.
&gt; If you think of it this way, Netflix accounts for 1/3 of internet traffic planet-wide, and Netflix's clients use Falcor. Sure, I meant more from a community and platform standpoint; e.g. when I was looking at it a year ago, there were no libraries for native Android or iOS, and very few guides in integrating it into an actual app.
Thanks. I looked it up to find what this was about. But even so there should be an abstract at the top describing the use case or at least a link to the main project page if no one can be bothered.
I strongly recommend TypeScript VS Code is the natural TypeScript IDE, and makes for an exquisite developer experience when properly configured In my experience, TypeScript is like "babel plus", and usually when you're considering babel, you're already transpiling code, you may as well benefit from the typescript features
Whatever you think of Falcor vs GraphQL from a technical perspective, Falcor should be avoided as a dependency in any serious software project due to it being terribly under-supported by Netflix, a guaranteed lack of native SDKs for mobile, the team's poor communication with its community, and the nearly non-existent ecosystem. This 1.0 release is little more then Netflix picking an arbitrary point in time to slap on the 1.0 label. Just look at the changelog. I say all of the above as someone who has spent the last year building out and supporting the data layer of a real world SaaS app built on Falcor.
But isn't state pretty bad? Functional programming is teaches to never mess with state. Just look at it, replicate it temporarily, and output something else. Plus, the constructs in OOP make it very hard to change the application's structure later, doesn't it? I guess I also don't see a point. Why would I want to unify a set of related operations at all? Why wouldn't I just make small reusable functions and use them wherever and whenever I want?
I published a new version of [React Animation Frame](https://github.com/jamesseanwright/react-animation-frame), a React higher-order component that invokes a callback in a wrapped component via `requestAnimationFrame`. This was to fix an [issue with unmounting children](https://github.com/jamesseanwright/react-animation-frame/issues/3), so I finally had [an opportunity to play with React Native](https://github.com/jamesseanwright/react-animation-frame-native-example)!
&gt; It’s not “informally injecting an array into a function” it’s making calls to functions with numerous arguments by constructing those arguments at run time, and is able to apply them to a function with unknown length. Agreed. This is bad. It is sloppy from a planning/organizational perspective and horrible for performance. &gt; The whole point of the examples is that they’re not “your” functions - you merely are decorating them with your own behaviour. You cannot do that with an object or whatever you’re proposing. Then I would create my own functions to perform the work in a predictable manner. Destroying performance for developer convenience is a hallmark of an immature environment. &gt; As for JIT, it makes no difference. That isn't accurate. There is a performance hit for both variable length arguments and for accessing the *arguments* property of a function. There is an actively maintained list of things that break JIT compilation in V8, but I am having trouble searching for it right now. Object literals are extremely well optimized in the various JIT engines. It seems at compile time (I am guessing here) that object keys are cached in memory in a similar capacity as the relationship between reference declarations and their respective scopes (which is extremely well optimized). I had to do this research against large object literals in order to validate whether my approach to a new diff algorithm was practical from a performance perspective: http://prettydiff.com/guide/unrelated_diff.xhtml My initial assumption is that properties in object literals are slower to access than indexes in arrays. While that assumption might have proven technically valid the performance difference wasn't enough to qualify one over the other, at least in the case where write operations were segregated from read operations. &gt; I’ll say it again: there’s no way of doing the things in those examples without apply. I provided you with alternatives. It seems you can clearly read but either do not understand the material or reject it without independent evaluation. Either way I read this as a problem of low confidence. --- This is your code. You can form any opinion you want and worship any belief system you want around that code. I don't care. I would recommend performing independent research and evaluating the evidence before necessarily working from faith in a convention. There is a lot in this language that works amazingly (surprisingly?) well, but there are also many popular conventions that don't work as well.
&gt; "Origin null is not allowed by Access-Control-Allow-Origin" - The browser is saying that the server is rejecting your request, via CORS: [wikipedia - cross-origin resource sharing](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) - This stack post encounters a similar issue: [stackoverflow - origin null](https://stackoverflow.com/questions/3595515/xmlhttprequest-error-origin-null-is-not-allowed-by-access-control-allow-origin)
Instead of running the html files from `file://...`, you should run a local web server — the browser won't allow CORS requests from the local file system, it needs a real web server Install node, and then run `npm install -g http-server` Then cd a command line window into your project directory with the html files, and run the simple command: `http-server -p 8080` Then visit [http://localhost:8080/](http://localhost:8080/) and browse to your html files
I think that's a little harsh, but agreed the lack of plans to open-source their native iOS and Android clients is a show stopper for many. I keep hoping someone outside Netflix steps up and contributes something in these spaces; it isn't a terribly difficult problem to solve. Beyond that, having myself built multiple production systems on this tech over the years, I feel like the responsiveness on the Github issues list has been decent. (Browse it and you'll find me popping up quite often!) Also, Falcor is conceptually pretty simple and (IMO) doesn't need an extensive library ecosystem.
Yeah i found that, only the checked answer actually doesnt say what to do. Is there a 'proper' way to pull RSS and display on a page?
I’d prefer a glass wall with silver marker 
Maybe something along these lines? const factories = { person: item =&gt; new Person(item.name), actor: item =&gt; new Actor(item.name, item.movies), worker: item =&gt; new Worker(item.name, item.jobs), }; const factory = factories[item.is]; if (!factory) { return null; } return factory(item);
What's your app?
See [adjacent comment](https://www.reddit.com/r/javascript/comments/73gohn/trying_to_display_rss_data_on_webpage/dnqdewx/) I think you should be able to do an HTTP Get, however you'll want to run it from a local server so you don't have `Origin null`. The server might still reject you, in which case you have to look into setting up a little node express server and proxy it or something
&gt;Edit: as far as arrogance, I think there's a bit of a misnomer here. Senior developers don't work by democratic rule. They are relied upon for distilling what is right, and what is wrong. If we take the positions and authority away, the senior should technically believe he is the right person in terms of providing value and guidance to the team otherwise why is he designated senior (i'm also not precluding the fact that the senior isn't leaving a lot open for discussion of course, but at the end of the day a lead makes the final decision given a difference in opinion). I could not disagree more with this belief. A senior engineer is not all knowing and should not carry the belief that they are the right person or has the right answers. What happens when there are multiple seniors with differing opinions? You are describing ego, plain and simple. Ego has no place in software. A senior engineer should know their limits and recognize that they aren't all-knowing and that anyone can provide value to the software they are working on. They should be able to discern such value above all else. I've been around engineers like you and they don't tend to go far in this industry. The senior engineers that prosper tend to check their ego at the door and come in with an open mind and a willingness to constantly learn above all else. I've been a JS dev for 5 years now. I'm still learning to this day and I will never stop learning. Understanding that knowledge has no limits has helped me thrive in this industry. 
&gt; Netflix accounts for 1/3 of internet traffic planet-wide, and Netflix's clients use Falcor &gt; (...) but still That "but still" tries to embellish how biased the original argument is :D. Throwing out the filler words, the progression of your comment is: - Netflix accounts for 1/3 of all internet traffic - Netflix uses Falcor - BUT "essentially all of that" does NOT use Falcor - "but still" "Well here's an argument - essentially it's entirely irrelevant, but still." (Don't get me wrong, I see that you're just enthusiastic about Falcor. Netflix using it should be a good enough argument for its viability on its own, but I found your comment a bit comical.)
Is what im doing not an http get? No idea how to do the server thing, seems way beyond the scope for something so simple. Hm
Another take on things: class Person { is name constructor({is, name}) { this.is = is this.name = name } } class Actor extends Person { movies constructor({movies, ...more}) { this.movies = movies super(more) } } class Worker extends Person { jobs constructor({jobs, ...more}) { this.jobs = jobs super(more) } } const factories = {Person, Actor, Worker} function createHuman(item) { const Human = factories[item.is] if (!Human) throw new Error(`unknown human class '${item.is}'`) return Human(item) } 
yes, you are attempting http get, but not from an origin that chrome or the server want to allow you to do so
I made a lib that did a lot of this once. Generators were (are?) _really_ slow, unfortunately. Comparatively, anyways. Conceptually it worked pretty well, though.
Ah, the good old "it isn't always a bad thing therefore it's never a bad thing" argument. It's certainly fine, obviously, .html is all over the internet and always will be. It's just not as good as functioning without it. It exposes visitors to implementation details, it's longer, it distracts from real information with non-information, it's less memorable--and you're just dead wrong about people not remembering URLs. When you want to visit a subreddit, do you look through your bookmarks, google it, or just type it? The only URLs people don't remember are ones that aren't memorable.
https://redom.js.org/documentation/ I added a better mobile support to RE:DOM documents. It now has a nice overlay menu with animations. It also automatically scrolls to the current menu item if you have scrolled the content and open the menu 😎📱
Is the font size/line height really not bothering anybody else? On my 13" laptop I get about 15 lines per screen, it's like trying to read a blueprint through a toilet paper roll. I've shut up about it on brand websites, I figure the point was never to see the whole picture, but can at least my API documentation remain information-dense? (And yeah, I know about page zoom of course, I still think their choice of default bears discussion.)
I published worka last week. Feedback welcome. Try it. I use it for path finding in the background. https://github.com/GrosSacASac/worka
You don't need else when you return in the previous if. consider storing the is for shorter internal use. The global variable Worker already exists in the browser so maybe rename it. As kumiorava suggest you can use a js object for your example. However be carefull this works only for 1 to 1 mapping. const { is } = item; if (is === 'person') { return new Person(item.name); } if (is === 'actor') { return new Actor(item.name, item.movies); } if (is === 'worker') { return new Worker(item.name, item.jobs); }
you can use a retry if it is too complicated to refresh/relaunch the page. In any case, use an intervale in between retries and stop after a set number of failures 
State can add complexity and complexity makes it more difficult to build and maintain a program but you can’t avoid all state. A program without state is an uninteresting program in most cases. OOP exists to help manage and reduce the complexity of state by segregating it into smaller, more easily understood chunks. It does not make it more difficult to change your application’s structure later: how easy of difficult it is to do that depends on your application’s architecture. Why not have only small reusable functions? For a few reasons, the major one being that not all operations are small or reusable. For example, in order to abstract away complexity, a database object relational mapping may maintain a cache of currently loaded objects in order to make repeated reads of those objects fast. As a result the select operation that it provides cannot be a free function because it needs to know about the implementation details of that cache.
Were you ever *required* by a boss to make a flowchart?
But don't you think that in the beginnings of a flowchart, *anything* could be a root cause of a defect? I mean, until you narrow it down.
It's not when greedy hosts have it jacked so high it makes your CPU slow or hangs up your browser.
Seemed interesting, but couldn't even get the 'Getting Started' sample on http://netflix.github.io/falcor/ to work =\
i do this too! too many times i finished process 1 and went, wait what do i do with this data?
I get the feeling that Angular2/4 was built with consulting in mind, so the developers deliberately made the framework bloated and obtuse. More that can break by doing it the "wrong" way, the most lucrative consulting contracts they can get from Enterprise software companies. 
ts is es6, maybe not as complete as babel, but should be enough to not add the extra tooling bloat on top, and you get the typo checking
The origin being the domina I'm on? I guess I'm just confused as to why I can download the RSS manually with the browser, but I get some weird security issue with Javascript. I guess downloading data from outside the current domain in JS is an issue? 
I really enjoyed using a Boogie Board Sync for a while. I found it hard to carry around but the writing is much smoother than a stylus on my large phone (which just doesn't have the touch sensitivity). The Blackboard by Boogie Board looks pretty interesting.
I made pubg.js for Node.js A clean and fast PlayerUnknown's Battleground's stats API wrapper. Easily access and sort vast amounts of player data with a few lines. Contributors and suggestions welcome! Github https://github.com/ickerio/pubg.js NPM https://www.npmjs.com/package/pubg.js
Are they helpful? yeah. Are they necessary? nah not always.
I've stolen; your semicolon!
I find [UI flow](https://signalvnoise.com/posts/1926-a-shorthand-for-designing-ui-flows) diagrams to be very useful. I usually employ them but not at the beginning. Edit: darn autocorrect. 
Thanks for your response! I will go through and try removing some stuff to see if it solves the issue.
It all depends on the size of the diagram. Quick circles and arrows work well for a boogie board. Full ER diagrams need a whiteboard.
it's a bit like asking why isn't English more like Russian.
The reason I am asking is that JS is so embedded in the web that it could benefit from some better design decisions.
Hi /u/fanysf42, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
They seem extremely similar to me? Especially with es2016 and since semicolons are optional. So which differences are you talking about?
Hi /u/RRetoxx, that is _java_. This sub is for _javascript_. Though similarly named, they are very different.
Because they decided to be more C like. 
if it says anything I've converted a personal project from python to Javascript ( for performance ) with about 12-15 find/replace operations and just a little manual touchup 
JS doesn't predate Python and I don't have firsthand knowledge of this but I'm reasonably confident saying: 1. Eich wasn't aware of Python at the time (it didn't really hit popularity until ~2000, JS is 1996) 2. Netscape marketing was pretty excited about riding the Java marketing wave when Java was new and cool so JS is in the Java (C-like) syntax tradition.
You really seem to coming at this from the side that Python is the one true way. I disagree, but either way it is hard to have a discussion since you haven't given concrete examples.
In an ideal world we wouldn’t have to transpire TypeScirpt either - but we do. What a bizarre argument. 
“Yes”, then. 
I wish you guys used camelcase :/. Can’t stand that underscore ish but it’s personal preference. I’m not gonna ask all you python folks to make your code look more javascriptish. 
&gt; I know tons of Seniors who have more chops than me sure, but I also know a bunch How do you know such vast numbers of senior developers? Is every developer you know a senior css ninja rockstar engineer?
Based on the way you use "OO" in your comments, I am absolutely certain you have no idea what it actually means. Its just a buzzword that you toss around because you think it makes you sound like you know what you're talking about. I would bet any amount of money that if someone asked you to give an explanation of OO design, you would have no idea what to say. You would attempt to quote articles and internet comments you've seen about it without having any understanding of what it actually means. For your benefit - good hiring managers can detect bullshit from people like you a mile away. You are clearly not as intelligent or capable as you present yourself to be and when people discover your deception, they will think of you as a fraud. Also: &gt; I can easily dedicate like 2 weeks to learning a huge portion of OO, building a sample app, and then I'd be able to talk to it a lot better. No, you absolutely, 100% cannot do that. I know people like you and people like you are full of shit. You are intellectually incapable of setting aside 2 weeks and building a sample app that demonstrates your understanding of OO. I know this beyond a shadow of a doubt. But go ahead, prove me wrong. Build something and link it to me in 2 weeks. You won't do this because you know you are incapable of it. /u/throwaway-aa2 
I think for it's original intended purpose, JavaScript did what it was supposed to do: make dynamic pages that didn't need to be refreshed each time to get menus, buttons, and other trivial tasks. Python was created in 1991 and JavaScript in 1995. It was unlikely Python was popular enough at the time to justify making JavaScript like Python, and like other readers have suggested, the syntax is more closely related to "C" style syntax, to make it easier for people with Java and C/C++ experience to get used to the syntax. It was probably never marketed for beginners. Over the course of the years, JavaScript has slowly become increasingly complex to facilitate the various needs of users and developers. That being said, successful programs have been written in both languages, and "better practices" are often relative to the language.
The creators of JavaScript probably didn't consider how ubiquitous it was going to be in 20 years time.
Thank you! Hm, it needs some rewriting. I've made a change - hopefully it's working now.
It's the let? Ah. Is it working now?
The Java part of *Java*Script is not innocuous. Java was the shiny new &amp; popular kid on the block, with heavy corporate backing, and Netscape thus decided that its web language should look somewhat similar. That's also why it has objects and inheritance despite the original inspiration being Scheme. As an aside, Python wasn't exactly well known either at the time. 
I don't have any HTML linter solution for you, but I would like to point you to PUG. It's an amazing framework for parsing HTML from self closing tags. So if you write this: .my-class This is some PUG code. div.my-other-class This is another line, with pug code. And that turns to this: &lt;div class="my-class"&gt;This is some PUG code.&lt;/div&gt; &lt;div class="my-other-class"&gt;This is another line, with pug code.&lt;/div&gt; You never have to worry about closing tags. And if you have a lot of code, it's much cleaner to work with. Check it out on https://pugjs.org/, and if you have any questions just ask :)
I usually just try imagine what I'm doing. Notice: not `start coding an idea ` but try to think about this first, imagine all moving parts, flow of data, all possible edge cases. I usually want to construct some mental model in imagination before I start coding (often I even "code in my mind" - using functions, objects, loops etc.) But my imagination is limited. So last few days: - when I was learning machine learning I drawn some diagrams on the paper and "ran algorithm on paper". It helped me with understanding issue. - I had to figure out proper architecture for my side project, so I started Blender and made some simplistic 3D scene and put some basic shapes like boxes or cylinders - they represented objects and dependencies between them. I also put some texts with method names. So... basically I made 3D code diagram ;) 
So basically pseudocode ;) 
It's not a great solution, but there is [http://validator.nu](http://validator.nu) - change the input type to 'text field' and paste your code in. If you are using templating engines or dynamic stuff you can also do 'view source' in your browser and paste the output into the site.
JavaScript itself (ES6+) feels already like a pseudocode (it's expressive enough to be used as such). 
Correct me if I'm wrong, but it presents a virtual JSON object that you can look up values in, which are then cached. There is no support for mutating the object, you have to do that via another protocol. So this is like GraphQL-lite, it fits their use case very well but not mine.
Works for me as well (latest Chrome and Firefox, Ubuntu).
Indeed, I consider diagrams and mindmaps to be write-only. Coming back to them later, most of them don't make sense, but they are really helpful while thinking about problems.
You can do code splitting for the CSS generated by Linaria with ExtractTextPlugin, like you'd do with normal CSS files. Configure it generate multiple files based on the chunk name, i.e. new ExtractTextPlugin("[name].css")
this is not a support forum afaik
It's more like having an elegant and simple structure. You can write lot of code, but you always know exactly where it fits in the general scheme of things. Having to "get" the project structure in my mind facilitates the process. 
You can use [htmlhint](http://htmlhint.com/) for this.
Of course it's better to know about something than not to know about it, but there are only so many things we can learn. A lack of OOP knowledge isn't going to impede your career as a Javascript developer these days because only legacy frameworks require it. Bear in mind that this sub is very defensive when is comes to OOP. Most contributors have built their careers on it, and they're terrified of becoming yesterday's men.
In addition to most answers above, I also want to add backwards compatibility. 
What kind of IDE are you using that doesn't have HTML validation?
I did a quick overview of Node's/Express' request object: https://medium.com/@theden/node-express-request-object-path-url-broken-down-cheatsheet-6f38fb702fc4
It is. Well done.
Maybe not, but I'd rather read this than another effing "Angular vs React" article.
Google.
[removed]
Thank you for your help. I was able to finally ablet build with babel. 
The W3C validator is not a great solution from the creators of HTML?
This is reddit. Every time such a question comes up, the typical response is, "I never knew there was such a thing!".
I don't think I've ever needed more than can be found on https://jasmine.github.io/edge/introduction.html 
First, what is your goal? Webpage front-end, backend, desktop, games, extending other applications like office, what?
The goal is to know enough javascript so i can do all of the above, besides games.
No. In a company that really values planning they will hire people to do that called *information architects*. In companies that don't value planning they won't ask for planning of any kind.
I first learned JavaScript when I was involuntarily reassigned from a design job to a development job at Travelocity, because decent UI developers can be challenging to hire. At the beginning I learned through the school of hard knocks on the job being assigned work and just failing until I the code did something else. Now when learning new things I prefer to write code directly into the browser console to test things out. If need network services or am learning bigger things I prefer to learn with Node by writing command line utilities.
http://validator.w3.org If you are working locally change the file extension to *.xhtml* and the browser will perform much of this validation for you.
I first started with some basic tutorials to get a foundational understanding but the most helpful way to learn is to just build something using JavaScript. Sure you'll have to lookup a lot of stuff as you build it but you'll have concrete examples of how to implement various things. If you are focusing on front-end development, I recommend using jQuery to begin. As far as other frameworks, I've been developing with JavaScript/jQuery/Ajax for about a year and am now looking at some new frameworks (Vue, React, and Angular for front end and Nodejs for backend)
I’ve found the best for me to learn something new is to pick a project, personal or work related, that you are passionate about and can sink time into with out worrying about a deadline. Then do it over and over and over again - pouring what you learned the previous time into the next effort. I think the basic process is the same for everything - you just need to be good at breaking the big problems down into smaller problems and solve those. It’s gotten much easier now days with blogs, stackoverflow, YouTube and paid courses ... but I think a good paper book, one of the O’rielly ones, is still great to have. Going at JS from the browser migh be the best since you can “see” more direct effects. 
Because it was made to look like Java. Personally, I'm not a fan of significant whitespace. Curlies plus auto-formatting is the more robust option.
What's the patent story? If it's better than graphql, then I'm quite interested.
I already had experience from other languages and education in comp sci, so to learn the language itself I mostly relied on experimentation. If I had absolutely no idea than I looked up tutorials or the documentation or looked for best practices. I also checked out code other people have written to get a feel for how people use the language
fyi, the [command pattern](https://en.wikipedia.org/wiki/Command_pattern) is the canonical way to encapsulate a switch statement
We use this similar pattern: function createHuman(item) { if (isPerson(item)) { return new Person(item); } if (isActor(item)) { return new Actor(item); } if (isWorker(item)) { return new Worker(item); } return new Human(item); } myHuman = createHuman(item); 
I learned HTML and CSS when I was a teenager, but never really did anything with it. Then, a couple of years ago, I had to make a website for my band, so I learned some rudimentary JavaScript to work with the Soundcloud API. I found that it was easy to learn when I had a specific goal in mind. Since then, I've built on that basic knowledge whenever I think of an interesting project.
I would start with these two sites [javascript.info](http://javascript.info/) [eloquent javascript](http://eloquentjavascript.net/) 
If you think it's never appropriate to use OOP concepts you might not actually understand some OOP concepts
Advanced can be a plethora of things. What are you looking for specifically? Mocking? Test suits? What?
why would you need to change the file extension?
Is there a plug-in to make search more comparable to Atom? I’ve been trying to get into VS Code, but that’s the biggest letdown for me so far. 
What features are missing with search? I can search by project or within the file just fine. 
So, why do I only see a blur of a site?
The code you've posted looks okay, but the real question is what you're going to do instead of console logging the response. The reason frameworks exist is because state management is the hardest part of developing a front end application. If you're planning to store state in the DOM, you're likely to find that your application is buggy and hard to maintain.
Sometimes you want this at the version control level
Why so? Any specific areas where I'll experience bugs and issues in maintenance? Just as to point out, I am just starting out web development.
Okay this will sound weird but i really advise starting with NodeJS on some totally non web related projects. Try to develop a simple CLI program or some such. I see lots of people struggling with javascript cause they try to dive into web stuff immediately, but there's a metric shit ton to learn if you want to do that : client server architecture, complex tooling, browsers / the DOM, frameworks... It's way too much for a beginner, so i suggest learning js the way you'd learn Python or Ruby : by creating your first console scripts, with few if any dependencies. Do a CLI to-do list with an sqlite or JSON backend, it will teach you the basics without drowning you in information.
GraphQL spec and implementation were relicensed using licenses without patent grants.
what drives me crazy is that VS2015 has better extensions than VS2017 wtf...
Somewhat related I think, I hate how beginners today still learn ES5. Even half the React tutorials that use JSX are still using `var` and anonymous non-arrow functions. Drives me crazy. Like, I *know* you're using a transpiler. Actually use it! 
It's the same as using global variables. The DOM is mutable and can be changed by anything at any time. If you find that it's not in the state you expect it to be in, the problem could be anywhere.
http://eloquentjavascript.net/index.html https://github.com/getify/You-Dont-Know-JS For getting into backend stuff: https://nodeschool.io/ Probably the best free resources for the language? Go through some generic js/html/css book/tutorials until you are comfortable making functions, loops, have some comfort with scope and ^this . At some point I think you will feel comfortable enough with JS to make "stuff" but you won't necessarily have an idea of what next. Then maybe get a project you think can hold your attention that will teach you the next thing you feel might be useful. Maybe you want to learn how to use react or how to use a database. It'll probably be more manageable to do one concept at a time. Find some tutorials, follow them to get comfort with that concept (react, db's, etc), start rewriting the tutorial stuff to fit into what you want to do with your project. You are going to want to do more than the tutorial offers and figuring out how will help you learn. And basically do that to incrementally learn concepts. Eventually you will probably get to a point where you feel like you can do just about most use cases, given enough time. 
Okay, understood it now. And this is exactly where React and Angular shine right?
What you want to do is to send a respone and not a redirect to the browser. Well its all about what aproach you want to code your app in. SSR with template engines like Twig or SPA with Vue or react. I'd advise to look into building rest api's and have the ui react on that respone. 
use vim. /thread
https://www.reddit.com/r/node/comments/730omb/how_massive_companies_use_nodejs_at_scale/dnn6mte/
do javascript30 by wes bos as soon as you can. after a week of hacking about on your own you should be ready. the best course in the world. and its free
Most of sites I vist have normal ads, which aren't annoying and stuff. Those miners rapes my CPU. How is that better?
There already is a Draggable: https://greensock.com/draggable 
Any link to a tutorial that teaches that in brief
lol good job going into my post history! hardly the same context as the person i was responding to referred to all front end devs as "kiddies", shitting on node, whilst glorifying themselves in their "superior backend abilities". I've just said "use vim". Good try.
There is a subscribe overlay with opacity: 0, wtf
Has this happened to you?
People need to be paid for content otherwise it wont exist. Advertisers on the net have had their chance and have failed totally. This might be a way if it's used with restraint.
I'm going to go against the grain and say what you've posted is pretty much fine. Personally, I would change the `else if`s to `if`s like /u/GrosSacASacs suggested or maybe use a `switch` statement, but that is is. The current top comment is probably the best answer to the question you asked, but I think it's a question you don't need to be asking. Unless you are actually operating at a scale where every `ms` counts, your goal should be readability and I think `if`s or a `switch` delivers that better since every developer knows what those statements do. The top comment's post makes the code look cleaner, but I think it obscures the purpose of your code and makes it actually harder to understand what is going on. It's easily understandable here, but in the middle of a large file months after the code was written, you're going to have a moment of "what was I trying to do here" that you wouldn't have with a `switch` or group of `if`s. Simplicity should be your goal, not complexity.
I just miss the real refactoring features (extract method, constant, move function to other file/class, etc...) from VS Code, and I think without those, any editor is just not good enough for actual work, people will just not take the time to break complex code down...
.mjs stuff is crap how was it so hard for parser to read if there was call to modules.export vs import when using react with babel your code would be in .js files but now you'd to rename to .mjs to use it on backend, because wtf xyz. 
What kind of animation do you want?
so it was easier to change whole internet than have nodejs do what babel does for react projects. how is it isomorphic, if to use same code from frontend you'd have to rename all modules from .js to .mjs .. wtf
It won't even pay monthly server bills.
It's supercharged with VS Code. That's a speed blur.
I'm still in the process of learning, but freecodecamp has really helped me get the basics, along with a lot of google and resources like eloquent javascript. Following tutorials can help as long as you take time to understand why you're doing what you're doing (don't mindlessly follow along). Learn how to read through the entries on Mozilla Developer Network-- you're going to have to refer to them a lot (and that's okay). YouTube can also be a good resource.
Neither will visits from users with adblock activated.
You are C# developer, so I would recommend going with TypeScript, because it's more class-oriented and statically typed. 
https://code.visualstudio.com/updates/v1_16#_javascript-and-typescript-refactorings
I can't reproduce this! Sorry guys it's the default ghost theme, lol
This post is about Visual Studio Code ...
My usual early process for learning a language or framework: 1. Just Start Coding some microscopic side-project in it, usually a command-line tool or tiny app, researching whatever's needed from online articles as I go along. Make lots of blunders. 2. Finish micro side project. Step back in horror. 3. Get a tutorial book on it and read that cover to cover. 4. Work through an online from-scratch tutorial, if available. Timespan: a couple of days. Then: * Start a more substantial project, writing much better code. * Read the official specification * Join some online communities to bounce thoughts off Timespan: weeks Later: * Start a commercial or OSS project in it * Read the source code * Blog Timespan: months to years This is an upward trajectory of beginner/journeyman/expert. The identifiable pattern is I usually try to be hands-on at a given level, _before_ undertaking any kind of learning activity at that level. I think that is quite typical for an autodidact; personally, I learn better this way. I have friends that do not, and vastly prefer to sit in a classroom being tutored. There is no unified model of human learning, no one-method-fits-all. For Javascript, I would suggest start simple, avoiding all frameworks other than Node. Maybe a task-specific data extraction and formatting command-line tool. I think the colossal range of side-effects and sheer scale of the web API that browsers offer is like being given the entire contents of an artist's supply store, when what you needed was a pen and paper. 
This thread is almost dead but I wanted to say thank you to OP. I have a decent amount of programming experience with Python, and I've been struggling to find a good way to learn JS without being forced to go over programming fundamentals again, and the second part of this tutorial (how JS interacts with the DOM) is **exactly** what I was looking for. This whole thing is really well done, thanks again.
If you just want to get up and running fast I'd say use jquery for ui changes and button event listeners and sending post/get requests. Then use express as you are doing but with res.send({message: 'User created', success: true, statusCode: 204?? }). And check if success is set to true or false in the ui, and finaly show the message in a div, and maybe have some other logic for handling errors. Probably the most quick n dirty web dev you could do. Look into twitter/spotify etc api doc's to se how other form their apis with data structure, error handling, http statuscodes. Also look at other peoples code at github!
There's a space in ONE here: (' '), though I can't tell at a glance why that would make a difference because allcodeononeline (not a fan of ternary here). ONE also has this on the next line: "};" while TWO has just a closing brace. Without more context, hard to say why that would break things. 
You'll get a lot more help if you: 1) Tell us what you expect the code to do 2) Tell us what is happening that you do not expect 3) Format it so it's readable
I'd be much obliged if someone could point me in the direction of this material in video form. 
they're slow on windows and os x as well. it's because electron is slow. and bloated. slack consumes about a gig of memory on my work macbook pro i personally find vs code too sluggish and laggy when compared to sublime, even on windows
+1 In fact having a set of ifs or switches is normal for the abstract factory pattern. https://en.wikipedia.org/wiki/Abstract_factory_pattern#PHP_example Since OP seems to be worried about performance, remember to code first and foremost for correctness, readability, and maintainability. Only if profiling identifies a bottleneck should you try to optimize (because optimizations tend to degrade readability and risks correctness), and even then make sure benchmarks prove your optimizations had the desired effect -- our intuition is often wrong.
Add a framework for state management as others have said, plus get rid of the .then()s and use await. 