If you add this line to the end of your `picture` function, I think it'll help you see where you're going wrong. context.fillText( "Y: " + y, 10, 10 );
Thats what Im saying, amen amen!
Right, a source-to-source compiler, also sometimes known as a transpiler. If Anders Hejlsberg wants to call it a compiler, I think that should be proof enough you're being an enormous pedant.
The hoisting explanation is either wrong or really poorly worded. This is hoisting: [YDKJS](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch4.md#chapter-4-hoisting)
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [getify/You-Dont-Know-JS/.../**ch4.md#chapter-4-hoisting** (master → 6109cfe)](https://github.com/getify/You-Dont-Know-JS/blob/6109cfe89e307a8a08e4906784cb7292f3fcb152/scope%20%26%20closures/ch4.md#chapter-4-hoisting) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhf6bec.)^.
Hi /u/harendragusain, I'm curious what your involvement with javascript is? I see you've been a redditor for 6 years, but you have only ever posted 2 comments, both of them today, and both in javascript subs... which wouldn't be odd, except that you've never commented or posted in any programming subs before today, but now you are all of a sudden? Stranger yet is that both posts you commented on are for `getpocket.com`, wow, what a coincidence!
Hi /u/mlukaszczyk, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `graphcms.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [graphcms.com](/search?q=%28and+site%3A%27graphcms.com%27+author%3A%27mlukaszczyk%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|9|90% [self.api](/r/api/search?q=%28and+author%3A%27mlukaszczyk%27+is_self%3A1+%29&amp;restrict_sr=on&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|1|10%
Interactive resume where everything is tabbed and page oriented. Save selected pages in localStorage and sync it with redux state. Easy and practical.
The problem is that when `y` is greater than a value (say it's `500.01`), you subtract 0.2 and (so now it's `499.99`). THEN, the very next frame it is no longer greater than `500` - so it doesn't subtract anything more and just stops: it's not greater than 500 and it's not less than 300, so the y axis doesn't change. What you need to do is have another variable for the `direction` of the boat: if (y &gt; 50) { yDir = -1; } if (y &lt; 30) { yDir = 1; } y += yDir * 0.2; If the yDir is -1 then the speed (`0.2`) will be multiplied by -1, so the y axis will be have `y += -1 * 0.2`. The boat will move up the screen. Once it gets to a minimum (`y &lt; 30`), the direction changes to 1 so `y += 1 * 0.2`: the boat will move down the screen.
omg.... i feel so stupid now... well thanks man really helped me out. apreciate it
That's not very nice.
I'd tend to agree with this. Lots of "it's just syntactic sugar!" thrown around about this topic, but what does it matter? Lots of languages have "features" that are technically syntactic sugar.
No problem... also, try this: y += Math.sin(Date.now() / 100) * 0.3; Instead of moving in straight line, it will move the ship in a nice sine wave (100 will change the speed of the cycle, and 0.3 will change the amplitude!)
Here's the [Test Double wiki on testing](https://github.com/testdouble/contributing-tests/wiki) - they make [testdouble.js](https://github.com/testdouble/testdouble.js). TD is a consulting company that embeds and trains engineers and managers on sustainable practices. I like their talks on reasonable amounts of testing and how to do it well, so hopefully that's a helpful primer.
yeah but im in school atm and teachers keep saying if you wana be good programer never repeat code. so il try to use the for loop instead. gotta lern it eventualy. we use it in c++ so cant be that much harder to do in javascrip. thanks for the tips really appreciate it
I think TJ was more prolific with Node.js related projects. Rich focuses more on frontend-oriented tooling.
Cool. Nice work
You can keep a little scratch project directory (don't spend hours and hours configuring webpack or whatever) that you use any time you want to figure something out. Somehow remind yourself to jump out of your big app and into the isolated test area. Just use the built in _assert_ or maybe _tape_ with a watcher and TDD your function. 
Hmm, React and NodeJS has been pretty practical for us, as well. I would also use Koa v2 in place of Express ... and Postgresql in place of Mongodb. If you're gonna revise MEAN .. revise all of it. :)
That's an unfortunate (read: 13yo keyboard warrior) tone just because your (and apparently Anders'!) opinion is not shared by me.. and a fair amount of the computer science community. Whilst I respect Anders' work a great deal, I don't think that's reason to just follow all they say. Do you also think it's correct that some popular JavaScript libraries put releases in a 'bin' folder? There is marked conflation of terms. Adherence to a single definition helps reduce ambiguity.
Also known as `callbacks`.
Embarrassed to ask: but is there​ a better way?
yeah, that's how it works — it's just a dumb regex replace. A fairly common pattern is to use `process.env.NODE_ENV === "development"` everywhere and replace `process.env.NODE_ENV` — Rollup knows what to do if it sees e.g. `"development" === "development"` ([demo](https://rollupjs.org/repl?version=0.41.6&amp;shareable=JTdCJTIybW9kdWxlcyUyMiUzQSU1QiU3QiUyMm5hbWUlMjIlM0ElMjJtYWluLmpzJTIyJTJDJTIyY29kZSUyMiUzQSUyMmlmJTIwKCUyMCU1QyUyMmRldmVsb3BtZW50JTVDJTIyJTIwJTNEJTNEJTNEJTIwJTVDJTIyZGV2ZWxvcG1lbnQlNUMlMjIlMjApJTIwJTdCJTVDbiUyMCUyMGNvbnNvbGUubG9nKCdpbiUyMGRldiUyMG1vZGUnKSUzQiU1Q24lN0QlMjBlbHNlJTIwJTdCJTVDbiUyMCUyMGNvbnNvbGUubG9nKCdpbiUyMHByb2QlMjBtb2RlJyklM0IlNUNuJTdEJTIyJTdEJTVEJTJDJTIyb3B0aW9ucyUyMiUzQSU3QiUyMmZvcm1hdCUyMiUzQSUyMmNqcyUyMiUyQyUyMm1vZHVsZU5hbWUlMjIlM0ElMjJteUJ1bmRsZSUyMiUyQyUyMmdsb2JhbHMlMjIlM0ElN0IlN0QlMkMlMjJtb2R1bGVJZCUyMiUzQSUyMiUyMiU3RCUyQyUyMmV4YW1wbGUlMjIlM0FudWxsJTdE))
I think a lot of people in this thread are confused about Promises. You don't execute a Promise. A Promise is a **value**. You can have functions which when executed return a Promise, but a Promise itself cannot be executed. So when calling Promise.all() the values in the array you pass to it are already Promises. They have already started doing whatever it is they're supposed to.
Yes you're on the right track. The tricky part about automation is you usually have to write your own automation framework. There are training videos available online for this. Never go down the record and playback route. You want to use the keyword approach. It's a chilled job. You're usually left alone. You'll spend your time writing tests (I strongly recommend you write your tests in Excel so semi-technical people can write them for you), building and extending your automation framework, running the automation suite and interpreting the results.
I think thats what the OP was asking. What to build ? I have the same issue. I have a hard time coming up with ideas. End up making clones of things that already exist. =/
Having almost failed my last year of IT engineering because of the AI part (which included neural networks) I would have loved working on such technologies, because my teacher only gave us a scientific article about a neural network algorithm and asked us to implement it with Netlogo, which was a huge pain in the a*s to work with. Whereas with this library I understand the code and therefore the logic behind it almost instinctively. So to the people behind it : good work, and thanks !
Oh yeah Im familiar with the Pluralsight course, it uses C# if Im correct? Do you mind me asking what kind of training you had previous to your positions as an automation engineer?
A valid point but fixing all that stuff and optimizing for real-world usage is next on the roadmap.
Still sorry that you are a PHP dev :P
Techdebt here is what I call that percentage of time to the team is doing stuff to "catch up". That includes time spent improving code as well as time spent fixing bugs. Obviously I prefer more of the former than the latter. With low test coverage, my experience has my team spending close to 30% of each sprint on story points that are in some way technical debt... A vast majority of those are bugfixes, with less time free to actually improve code. With high test coverage, our techdebt target is about 20% of our sprints. Usually, most of that is actually necesary. For the rest...nothing "specific". It's not that "well-encapsulated" means "a special style/pattern". I believe hard-to-test code is often badly-written code.
Not in a provable way, unfortunately. There was an added variable of a full-team ramp up of a new team that coincides with it all... Some amount of the velocity improvements is almost certainly related to a ramp up. However, here's the numbers we had, in terms of relatively consistent SP-per-sprint: Start of process (before test impovements): 29sp per sprint After most test refactors, with coverage requirements: 35sp per sprint At the end (no other changes I am aware of ): 38sp per sprint This was over the course of a little over a year. It's a 30% increase, but not all of that could possibly be test vs no-test.
I meant in the process of debugging, testing is a whole other kettle of fish. I'm pretty much in the same boat as op, tbh.
Yeah, that could be very easily fixed in a number of ways, just by not shading the sea or by shading it less-so than the mountains to make it still look kinda choppy.
Thanks for the data! We don't have numbers that big, and we have too much noise anyways. &gt; Efficiently adding tests to a large codebase without tests is actually quite difficult. At my company we're currently switching to a mix of selenium (end-to-end) as well as unit-tests a lot (instead of "nothing"), and it's been a pain to implement. It's a 5 year old CakePHP 2.9 codebase, and as you can imagine it's not readily testable, but we're getting there. However, testing did allow us to catch some bugs faster - and with the added confidence we're now deploying immideately after merging to master, instead of the old bi-monthly release cycle, which has added a lot of percieved velocity for our stakeholders. The added confidence of the tests is a huge bonus that isn't mentioned as often as "Helps you structure your code" and "Faster development speed", and even harder to measure. 
Testing is zen level debugging... When you are debugging your code... Do you spit out data to "prove" that its working. &gt;Yes console.logs So you are modifying code, with code to test it. &gt;Yes Is it possible that later in the week you may have to debug that code again? Or maybe next month. &gt;Yes absolutely! happens often enough. Well when you were debugging it what did you do with all of the code you wrote? &gt;It was just console logs I could look at and some conditions to check the state. What if instead of throwing away that effort you made it external, and instead of looking at console.log's you verified the data was what you expected with conditionals That's one angle of testing it means you're not tossing out work. You dont need a testing library to get started, although they help... Just write a new program, import the module to be tested and execute its function compare the expected behavior and spit out messages. Stop "in-utero" debugging.... For JavaScript you may want sinon right off for its mocks and function spies. You may need to consider dependency injection, or just write something to make it work.
Already asked many times on the internet, just last year on Reddit for example: https://www.reddit.com/r/javascript/comments/4i5msl/good_data_table_library_without_jquery/
I just wanted to express my understanding of where I went wrong. I agree that using array.push would be better.
\o/
So it's console.log if typeof != Expected_type? Or matching the output with a control value having expected a specific (known) result?
Since waterfall isn't part of the ES6 Promise spec, it would be helpful to at least mention a Promise implementation that supports this.
That's a great tip. Quite elegant.
Does this need the initializer if you always give at least one to reduce?
You shouldn't let thought leaders dictate what works best for you and your application, but to at least somewhat answer your question: Classes are fine; if you need them, use them.
Sorry, I'm not sure I understand. This is what I was talking about: const promises = [promise1Func, promise2Func, ...]; const promiseChain = promises.reduce((promise, callback) =&gt; { return promise.then(callback); } /*, Promise.resolve()*/); I guess what I'm saying is I don't see the point in having the initial resolved promise in that call to `reduce`. I'm not sure what your logic with the ternary operator is accomplishing either.
The point is that's how you make a reducer work. You need an initial value, otherwise promise will be undefined in the first iteration. Therefore you can't .then() it. Therefore your code fails. (And if you truly aren't familiar with reducers, in the next iteration promise will be the value you returned to the last iteration.) The ternary version checks if promise is undefined, which it would be if you don't give it an initial value. And if so, calls the callback and return its value (a promise). But if that initial promise function doesn't return a promise, it's the same problem.
Hi dug99! Thanks for the question! Please check my response to tlareg for a bit more on Britecharts vs C3
And your point is? The same argument that a language doesn't actually have a feature, but in some way the feature is just emulated, can be applied to so many features across so many languages as to make the argument pointless. It's like duck typing for languages. If from every external viewpoint it looks and acts the same who cares if it's actually different under the hood? Does the abstract idea of a class act like it is supposed to and support the patterns that a class enables without undue burden? Great, then when it makes sense use it. And arguments about speed are overblown. For 99% of application code the speed will be completely imperceptible to a user. If you are actually doing something performance dependent then you worry about these kinds of things. But not before. Premature optimization and all that.
OP you need to learn to at least format your code pls, three backticks will start a multi-line codeblock. You are trying to use a for loop that runs 10000 times, which is past the limit of the environment it's running in. What you need is [generators / iterators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators).
+1 for Vue!
Why stop at classes? JavaScript's functions, under the hood, are a different beast than Java's functions. Clearly JavaScript's functions are fake, merely mimicking real functions. JavaScript's objects, under the hood, are a different beast than Java's objects. Clearly JavaScript's objects are fake, merely mimicking real objects. /s Moral of the story: Just because a language feature is implemented differently than in Java doesn't make it fake or useless.
JavaScript has classes. There is no such thing as a real class. JS classes are no more or less "real" than C++/C#/Java/SmallTalk/CommonLisp/whatever classes and no language owns what it means to be a class. Classes are also native to JS engines and there is no "mimicking" or "adjusting" that occurs, unless I misunderstand what you're talking about.
https://github.com/wilddeer/stickyfill is the smoothest `position: sticky` shim i've found - tiny, 0-dependency and works with no jank on my 5 year old phone in an Android browser on 4.4.4 KitKat
FWIW, React is fine and easy to use like this. You can user it to render the whole page or just a widget on part of one page of your traditional multi-HTML-pages site.
eye-gull?
Today it's mostly (but not totally!) syntax sugar but this will become less so in the future as more features are added to classes (eg. fields and private slots)
All I know is that Bluebird is faster than native promises (or was a year ago). It also has a cancellation API I'm dying to use as soon as I get my shit together and port my application to using Bluebird. I wish you luck in creating a better promise library, but I can tell you I'm planning on using Bluebird to replace the library I'm currently which I wrote myself. Btw, in your docs, you should mention whether or not Aigle is A+ compliant.
Check out Eratosthenes Sieve
in case you missed it, i recommend you read through the numerous level-headed comments of people who've been there and back: https://www.reddit.com/r/javascript/comments/68mavc/why_im_moving_on_to_web_components_and_not/ TLDR; the tech is very far from mature (almost universally unsupported) and even in a mature state offers little if anything over modern best practices. &gt; Been trying to figure out the webcomponents thing for a week you could've had a full app prototype coded by now using a mature framework that took 6 hours for fluency.
The slide appears to be on top of the link. Adding ` style="z-index: 100;"` to the link made it clickable for me. Not entirely sure why yet though :)
Can you post the code you're using? Most APIs return JSON not plain text so if you're hitting a public API I would like to see it myself. If you're actually getting plain text there's a few ways to parse it. You could split on \n and then on : or even create an object from it. 
Try [wiki](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Pseudocode), it's explained well there. Below there is also description of incremental sieve, which you need in your case (because for arbitrary nth prime you don't know upper bound). But since you know your n, you can simply put some large-enough upper bound, and use simple sieve.
Try this: http://phantomjs.org/screen-capture.html
By the way, here's a talk by my colleague, André Cruz, who was in charge of NPMS.io. In this talk he tells us the story behind the whole project, its architecture, and how it got to be adopted by NPM itself. There's a cameo by Benjamin Coe, from NPM itself, really worth watching. https://www.youtube.com/watch?v=B1Zz4Vu2eSE
vue has been getting a lot of hype not always substantiated. i think it's important to get a bit of a critical viewpoint too.
Find, some, and a for loop are all I can think of offhand. 
That's great
no demo???
In this example the promises array is an array of functions that return promises, not an array of promises. Foregoing the initial promise results in calling `.then()` on a function instead of a promise, which is an error. Basically equivalent to the following: const pFunc = () =&gt; new Promise(r =&gt; r()); // Forego initial promise - results in error [pFunc, pFunc, pFunc].reduce((promise, callback) =&gt; promise.then(callback)); // Equivalent to pFunc.then(pFunc).then(pFunc); // // Include initial promise - works fine [pFunc, pFunc, pFunc].reduce((promise, callback) =&gt; promise.then(callback), Promise.resolve()); // Equivalent to Promise.resolve().then(pFunc).then(pFunc).then(pFunc) EDIT: I do agree that the ternary is pointless though. There's no reason to use reduce in this way with an empty array. If for some reason that did happen though, the initial promise would prevent any errors.
Thanks, is there any transcript? I am on slow internet, so videos are off limits for me.
Your reduce will produce NaN. It would have to be something like this: candyArray.reduce((prev, candy) =&gt; { // Because undefined++ === NaN if (!prev[candy]) prev[candy] = 0; // Return the object, not the incremented value prev[candy]++; return prev; }, {});
I mistyped my first comment, it should be frequency &gt; 1 not 2. If they appear once then only the brother *or* sister gets that kind of candy. Since they ask for the maximum you need the ceiling of half the number of candy types that only appear once. So given candies A, A, B, C, D it would split as follows: Brother: A, B Sister: A, C, D = count(freq &gt; 1) + ceil(count(freq = 1) / 2)
Why not just make a div with a fixed size, and bind the HTML inside?
This doesn't scale well beyond a few users, but you could have a separate canvas element per user, and stack them on top of each other using CSS absolute positioning. Canvases are transparent by default (unless you fill them with an opaque color), so this should work: &lt;div class="container"&gt; &lt;canvas id="canvas_user_johnsmith" width="640" height="480"&gt;&lt;/canvas&gt; &lt;canvas id="canvas_user_rickmartin" width="640" height="480"&gt;&lt;/canvas&gt; &lt;canvas id="canvas_user_judyconway" width="640" height="480"&gt;&lt;/canvas&gt; &lt;/div&gt; Then use CSS to position everything: .container { position: relative; } .container canvas { position: absolute; left: 0; top: 0; } Note that you need to get a different context for each canvas. That way the paths are kept separate, and multiple paths can be drawn at once by different users. Good luck! 
Aha! Somehow I missed that "find" had a callback function. I was using some to do the same thing, which felt like it was just weird as hell. Thanks 
Sure, I mean, I normally have a pretty good command (i think!) of most of the new stuff (except generators!) I just somehow missed that "find" has a call function. 
113, slightly blurry ``` &lt;canvas id=c&gt;&lt;body onload=for(s=c.width=c.height=1024,n=s*s;n--;)n/s&amp;n||c.getContext('2d').fillRect(n/s,n%s,1,1)&gt; ``` 115, not blurry ``` &lt;canvas id=c&gt;&lt;body onload=for(s=c.width=c.height=1024,n=s*s;n--;)n/s&amp;n||c.getContext('2d').fillRect(0|n/s,n%s,1,1)&gt; ```
I could write a blog on it. :) 
Yeah I was thinking about this. But like you said it doesn't scale well
I tried to be fancy and use filter to count uniques, and I wound up with the same issue as you (timeout) /** * @param {number[]} candies * @return {number} */ var distributeCandies = function(candies) { return Math.min( Math.ceil(candies.length / 2), candies.filter((candy, i) =&gt; i === candies.lastIndexOf(candy)).length ); }; Switching back to just using forEach and an object fixed it. /** * @param {number[]} candies * @return {number} */ var distributeCandies = function(candies) { const u = {}; candies.forEach((c) =&gt; u[c] = true); return Math.min( Math.ceil(candies.length / 2), Object.keys(u).length ); };
There are still a few benefits to using function/prototype. It's nice to be able to wrap up complex variables, seal them, make them non-enumerable, non-writeable, then have multiple cascading object.defineproperties on the prototype for the getters/setters. It's an easy way to have observables, easy to consume inherited parameters with apply/call, all that fun stuff. You can template out "interface" a function for inheritance by making the accessors unwritable but the private vars or function returns writeable. And dynamic monkey patched prototypes are like nightmare candy. The old ways are going slowly away, but I enjoy prototypes for the potential to do some amazing things like mixins.
Sorry, yeah, haven't had the time. Its super easy to try out tho.
For breaking iteration early? There's also `every` and `findIndex`. `find` is for sure the right choice here, though. Side note, I really wish `some` was named `any`.
And why do you even need to use the JSX with React? https://facebook.github.io/react/docs/react-without-jsx.html &gt; Alternatively, you can refer to community projects such as `react-hyperscript` and `hyperscript-helpers` which offer a terser syntax. 
Oh yeah! Same. I have a .NET background though 
Yeah, I almost made a comment on XSS, because realistically, you should never bind HTML. I'm not sure about scaling or implementation, it sounds easier to me. Performance is hard to say? 
yes
Because they describe the shape of an Object, not a scope. Doesn't make sense to have things inside of the class declaration that are not part of the Object.
Just in case you're not aware, local functions are convenient but not performant. Every time `Foo` is called `stuff` has to be reinitialized, e.g. it's creation is deferred to each time `Foo` is invoked. There's plenty of articles about common anti-patterns that are commonly used, so [here's one of them](https://code.tutsplus.com/tutorials/stop-nesting-functions-but-not-all-of-them--net-22315). Sure the performance is negligible if `Foo` is not a function that is called often, but I'd consider it best practice to avoid local functions as the norm.
I would try to write it without using `class` using just a plain function and extending `HTMLElement` using prototypes. Hope that helps. But, honestly is there anyway you can get away without supporting IE? Webcomponents are pretty bleeding edge... I don't think it's really the right fit for IE. 
This was the very first thing I looked for and had the same reaction. 
Sorry, I was confused because the term "local function" as I've heard it is used to describe functions like baz: just a function declared inside a function.
wish i was thereeeee D: will try to attend next year !
One school of thought would say use neither.
You do that exactly in the same way you'd do it in ES5. Scope your class declaration and write your private functions and variables inside of it. How would you do it differently in ES5? Using a closure (what your'e calling a "local function") inside of a constructor function doesn't make them accessible to the functions on the prototype.
It is French. I'm not a native speaker, so this site would help you. https://www.howtopronounce.com/aigle/
I understand what you are saying. I don't read the question in the same manner. I think it's too ambiguous as written to make a definitive statement. But yes your way does solve the problem the way you are interpreting it.
Meh, what can I say? That code in perl works. I've never tried to make a frequency map in Javascript I assumed it would act the same. But yeah it's just a matter of initializing new values to 0 as you said. What? You expected me to actually run the code before posting it? ;)
Exactly. I don't use public repos without one 99% of the time. I get the time constraints but it is hard to take a package serious without one. It's the same with those request a demo apps. Literally 0 screenshots of their app with a whole lot of empty promises failing to back it up. 
If you are taking user input through something like an API then yes you should write fuzz test. But I would still have to write those same API test in something like Java or C#. 
You could also implement it in ES6 doing something like this if simply documenting private methods isn't enough class MyClass { constructor() { this.myPrivateMethod(); } myPrivateMethod() { if (!(this instanceof MyClass)) { throw new Error("myPrivateMethod called from an invalid context"); } // Do something } } Though you'd probably be much better off using a closure const MyClass = (function() { function myPrivateMethod() { // Do something } class MyClass { constructor() { myPrivateMethod.call(this); } } return MyClass; })();
&gt; IE specifically seems to have a problem with the word extends. I have tried using an ES6 shim Well, you cannot really polyfill class syntax.
I can't tell which side of the fence this guy is on... His irony/sarcasm is way too deep for me. 
The lookup is always O(1) but the actual performance depends on the underlying memory representation. Objects in Javascript are largely used in two different ways: as classes on one hand and as dictionaries on the other. The js engines have largely adopted a technique the v8 team calls "hidden classes." As fields get added onto an object, the memory representation transitions between a set of classes with corresponding fields. This changes property access from being a hash table lookup to being an offset from the pointer to the base object. This is massively faster and was one of the earlier optimizations the engines picked up during the engine speed battles back in 2008. If an object changes its field set too often (or historically if you `delete` a property), the representation under the hood switches to a hash table. If you really want a hash table and it matches your support profile, you're likely to get better performance out of the new ES6 `Map`, which gets to skip some overhead created by object semantics (e.g. prototype chain walking for a missing field).
I've had success doing this with babel and https://github.com/github/babel-plugin-transform-custom-element-classes
What exactly are you trying to accomplish?
Nope. I've taken quite a few jobs with them. They are a little flakey as webdevverman mentioned, but they have a ton of great positions listed.
/thread
try the `w3c ajax tutorial` (google it), but. you need an ajax library or jquery, then you can do things like `myajax('http://www.someurl.com/something', PostData)` with jquery its a little tricky the ajax documentation are not clearest, you sometimes need to pass flags to it, specifically `url, type and data` (i think), and expected return content type (otherwise it just doesnt do anything...). THEN u have parse the return type which is JSON usually. request = $.ajax({ url: "/form.php", // url type: "post", // 'get' or 'post' data: anyFormData, //your POST data, ex forms or fields, totally optional }); // Callback handler that will be called on success request.done(function (response, textStatus, jqXHR){ // Log a message to the console console.log("Hooray, it worked! data:", response); //optionally parse json? //data = JSON.parse(response) }); from here: http://stackoverflow.com/questions/5004233/jquery-ajax-post-example-with-php
Does it support touch events?
To solve this you'll need to learn some basic HTML and JavaScript DOM manipulation. Try starting here: http://stackoverflow.com/questions/1750416/insert-remove-html-content-between-div-tags
Wonderful answer. Do you have any resources we can read up on these optimizations?
Cool, thank you :)
Ok you convinced me: https://cdn.rawgit.com/fresheneesz/drip-drop/master/demo.html
I can't thank you enough for rollup! It's an amazing piece of technology! Butternut seems to share the same elegance. Really curious how this will further develop +1
It's a dsl resulting in generic js, nothing more nothing less. This is what allows it to have and know scope, to refer to other components without having to put them into a global namespace or register them locally. As for Andre Staltz tweet, his opinion and preference i guess, hyperscript is nice, too.
Invest your energy in something productive
Doesn't work on mobile (chrome, ff, brave).
&gt; The same argument that a language doesn't actually have a feature, but in some way the feature is just emulated, can be applied to so many features across so many languages as to make the argument pointless. And I'm not making that argument at all. &gt; If from every external viewpoint it looks and acts the same who cares if it's actually different under the hood? You should, because under the hood there is *native* mechanism that does the *same* and you can access it "over the hood". Why making and abstraction on what is already an abstraction to do the same? &gt; Does the abstract idea of a class act like it is supposed to and support the patterns that a class enables without undue burden? Great, then when it makes sense use it. There is a burden, compared to native beahavior delegation, It' is slower and requires more code. That's the whole argument. Go write couple of classes and an "instance" of them, with class mechanism and with behaviour delegation pattern, then test it on jsperf. You would suprise yourself. Delegation is up waay faster. If your code creates number of instances the behaviour delegation is much faster, and even if you don't need it why bother to write slower code?
It's probably better that you go to /r/learnjavascript and ask for some general resources for beginners. I'm sure they'll have something there that can help you.
I don't follow you. What you wrote is valid JS. I don't see any `if` expression there. BTW, also `do expressions` have nothing to do with JSX. It is just a syntax, no more, everything compiles to proper JS, so you can just use it instead. :) &gt; This has everything to do with using functions for layout. It is not possible in template frameworks, they wouldn't know scopedVar because there's no scope, which means no components you can refer to also. That is why they circumvent with D.I., computed methods or component registrations. The link I provided shows how to do it properly, functionally pure, with scope. There is no "template framework". 
C will probably be a language that can be compiled to web assembly. I would suggest that you search for clang. From my understanding Clang is a c front end for llvm
Of course it transforms into JS. But you cannot write comments as in JS, and neither as in HTML, yes, I know you can do with 6 extra characters but that is not the same as writing JS. So you write something else that compiles to JS. But you cannot write JS literally. Your example with do is taken from https://babeljs.io/docs/plugins/transform-do-expressions/, literally. Which you can transpile into JS without any JSX. The if-then examples you give I can write with ternary expression in one line and in pure functional style, whereas writing like this is imperative and hard to test. And again, I have never mentioned Templates. Neither Angular and friends. You can write all of React without JSX. It is just syntax. 
I just spent the last 20 hours at a hackathon doing just this! I was working on a vdom library rust. I think rust is a perfect fit for this environment. There's already some pretty nice libraries and tools for working with wasm/emscripten. https://github.com/koute/stdweb and let's be honest no one wants to start large new applications in C and the thought of C at the top of my stack is a terrifying thought for internet security. Rust can be a little daunting to learn but is quite achievable and compared to C you'll enjoy the improved ergonomics. That said C will be here forever and everyone should probably know it, though for me learning rust made me a *much* better C programmer.
https://translate.google.com/#fr/en/aigle Click on the speaker icon in the bottom left corner of the French text box.
Git is still on my to-learn list, somehow :\ Perhaps it should have taken priority over the WebAudio API haha
https://medium.com/powtoon-engineering/a-complete-guide-to-testing-javascript-in-2017-a217b4cd5a2a
A good read if you want to learn more about this stuff: http://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html
I absolutely agree. JavaScript didn't need classes, but make the language feel more like Java and there are people strongly pushing public/private declarations because they don't know and don't care how the language works. If you understand the scope model you already have public/private capabilities.
&gt; Of course it’s no suprise that Javascript is slower than C++, but how much slower is shocking to me. comparing strongly-typed low-level compiled languages with javascript is pretty dumb, if you ask me..
They identify different types of bugs. Javascript being loosely typed can lead to some weird interactions that a type system is invaluable at detecting. Unit tests are still useful.
Of course it is fucking slow compared to almost all other languages. In professional high-traffic environments it's just the wrong tool to use. But that's not the point. People can sell it to their customers. It's a buzzword one can drop to get money for it.
 const O = () =&gt; { const a = () =&gt; {} const __b = () =&gt; {} // private method return { a } } const o = O();
Here's one: You know JS and you're comfortable with it. You don't want to or can't take the time to learn something new. Here's another: You join a team that's already using NodeJS Here's another: Your organization decides that it will use NodeJS Here's another: You want to
Sorry, to clarify this is in a hypothetical "pick one" scenario.
Unit Tests. If you're following TDD then it can really help drive the design of your code. I'm a huge fan of typing too, but if I had to do one or the other it would be Unit Tests. 
Static typing is for somewhat better developer experience (autocomplete) and indeed solves few classes of bugs. But tdd solves many more and uglier classes of bugs.
Underscore has been around longer ... but every major project I've touched in the last year or two has used lodash. It rocks.
I wonder what the results would be if the server had to do more than just spit out some text. Like what if you had to hit a db, make an api call and then parse data etc. 
That’s extremely helpful feedback. Is there anything you would add to that first paragraph? I definitely overthink simple questions-- or in this cane complicated questions that im unsure of level of detail). i get paralyzed and end up giving really shitty answers, or going totally mindblank. (Cause where do i even start)
So, I'm not 100% certain on what you're trying to achieve here, but the biggest issue is that you're comparing the wrong thing. when you do document.getElementById, it literally returns the dom element with the id you specify. Not the the value/contents of the dom element. The DOM element is an object, with a bunch of properties on it. One of which being value, which is what you want. http://jsbin.com/tuvemakuva/1/edit?html,js,output heres a very basic example. Also, the comparisons operators you are using aren't great. value returns a string, so your comparison should probably read; if (a.value === '') alert('SVP') the triple equals means, literally equal too, and should be used when doing hard comparisons 
You already have private methods via closures.
https://developer.mozilla.org/en/docs/Web/API/HTMLInputElement Check this spec, it will tell you everything available on the element to be used.
I'm the author of the article. Thank you for the kind words. In near future I will publish continuation with even more interesting (I hope) examples. Make sure not to miss it!
It probably wouldn't hurt to summarize what you explain below in another sentence - something like, "Prototype hierarchies can be defined for objects through pseudo-classical object instantiation using the `new` keyword with a constructor function, or through a more manual approach using methods like `Object.create`". This would go to show an understanding of the implementation side of things beyond just the concepts around how it works.
Who gives a shit about script execution speed? Fast web apps is all about limiting IO delays and having an effective caching strategy. Some of the biggest sites on the net run on slow-ass synchronous Python just fine.
&gt; ES6 provided up with the ”class” keyword, but this too under the hood relies on the same prototype delegation approach, rather than a traditional class. (Me, as the interviewer) "How are 'traditional classes' implemented under the hood?"
Hmm. Should I not say that? I don't actually know any traditional class-oriented languages, this is what i've gleaned from reading and practice. I can't speak to how traditional classes work (except the distinction that they rely on actual copy behavior, rather than the prototypal delegation-style approach -- they create actual copies, where JavaScript does not).
No, don't even go there. 
&gt;nodejs of course has the slowest performance beacuse it's built on JS. NodeJS is an implementation of the V8 JS engine written in C. It's built to run JS. It is not built on JS. 
Mmmh, okay. I always thought it's JS running JS somehow. TIL :) Then I don't understand why it's so slow compared to the other systems.
Here's another: for a particular project, you decide that speed of development is a greater priority than speed of the program.
I stopped using partial, because arrow functions are shorter and often easier to understand... const array = [1,2,3,4,5,6] const add = (a,b) =&gt; a+b array.map(partial(add, 2)) array.map(_ =&gt; add(_, 2)) With arrow functions you can also partially apply the middle of 3 arguments. 
Upvoting this just because there's a Bane voice changer.
I have to agree... I'm having a hard time seeing a case where a partial or curry is easier to reason about long term. Does anyone have good examples?
It's eventually going to be single quotes, because linters like eslint will gripe about double quotes being used over single quotes (unless you're quoting tick marks? then again those can be escaped), and many of us who work on teams have git hooks which run eslint before commits to contend with. 
To add some support for single vs double; double quotes requires a shift key + " to write (e.g. 2 key presses), whereas single quote requires 1 key press.
Thats only true for qwerty keyboards i guess. On a qwertz keyboard you still need to press shift. I personaly use single quotes for javascript and see them more frequently than double quotes.
Writing an article complaining of overcomplication to feel like a smarter person. If you actually put some effort into learning the tools, maybe they wouldn't seem so inaccessible to you. In actuality, it's not that complicated. It just has a steep learning curve at the beginning.
Because it's still running JS. Which brings us back to /u/recrof's point: &gt;comparing strongly-typed low-level compiled languages with javascript is pretty dumb, if you ask me..
It's mostly hyperbole in the long line of "X is dangerous" style articles. It uses inflammatory language that distracts from the performance data later in the article. Meaning that the people the writer intends to reach will likely be turned off before reaching the usable content. Performance is not the only measure of the utility of a language. One of the large benefits of JavaScript is its pervasiveness. Almost every internet enabled device on the planet can run JS. Likewise, a huge number of developers have at least some experience with it. Therefore it is both easy to staff and easy to get deployed. Then you have a large number of big public companies and organisations that have enabled their products with it (Amazon, Netflix, Github, Paypal, LinkedIn) and companies who are creating frameworks and VM optimisations for it (Google, Facebook). That's all empowering the developer experience over the user experience at times. It's an attempt to balance things out. There are plenty of languages and frameworks that are faster but at the cost of the developer experience (i.e. configuration, hardware constraints, deployment frustrations, lack of support, lack of qualified candidates, lack of documentation and examples, etc.) Not that NodeJS or JavaScript, in general, is perfect, but it has seen some serious updates in the past couple of years which has greatly improved the developer experience. Examples: the V8 engine, Electron powered Apps like Atom and Visual Studio Code, even something like Cloud9 and other online IDE's. Type checking with TypeScript, configurable linting with ESLint, not to mention an abundance of testing frameworks, books, and online resources to help people produce better code quality than ever before. So while JS is a flawed language in some regards, it's also a highly accessible and useful language. That accessibility to laymen and experts alike is what makes it popular. 
Not specifically `lodash` but in `ramda`, I use `curry` or `curryN` all the time and it has helped me reason about code long after I wrote it. However the way I use it seems to be different than the above: const add = R.curry((a, b) =&gt; a + b) const plus2 = add(2) const increaseBy2 = R.map(plus2) increaseBy2(array) Being able to define the basic steps of `add` and `map` and having them curried, I can pass them around and let the information eventually finish the job.
Sure, you can essentially do the same thing with an external, non exported, function as long as you don't use 'this' (or you use bind before every call, or [this](https://github.com/tc39/proposal-bind-operator) is implemented). OP seems to want the convenience of doing that though. (As well as declaring them within the brackets of the class for ease of reading) 
It won't mangle it using a Symbol and make it non-enumerable? (I haven't checked, it just seems like it could) 
Hm. I think I've never seen a distinction between compiler, interpreter, and JIT that similarly clear and succinct as the section about them in this article. To put it on my own words: An interpreter is the most efficient way to translate and execute sequential code (e.g. glue scripts that just call other programs with certain parameters), because all steps between source code and execution are tied together and there's no overhead in creating intermediate formats. But once you have loops, a interpreter has to repeat work, while a compiler can spend time thinking about the most efficient way to execute the loop. A JIT is the best of both worlds, since it can interpret pieces of code that only run once and compile the loops.
Just keep in mind that Phantomjs project is being discontinued.
In the scope model privacy is a product of where something is declared in relation to a point of access. If a reference is declared in child function it is private to that function and thus unavailable to the parent function, but public to descendant functions under the child function.
Try to keep things out of global. I would just build the list everytime and manage the contents of the list in an array. This is closer to how you would manage it in React and other data driven frameworks (under the hood); so it could be helpful to start thinking of frontend components in this way. Unless its important to maintain other state within the element (aka selected text)
Slower, but not stupid hugely slower: http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=node&amp;lang2=gpp The performance gap between JavaScript and many of the slower languages tends to be much wider. Here is JS versus Python3: http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=node&amp;lang2=python3
JS Loop? 
I guess bringing attention to it till it gets fixed is one way to do it. Upvoted. 
Would have been way more relevant if he had compared node to django, rails and/or some php framework.
Do it like google - https://www.elliottsprehn.com/preso/fluentconf/#/
&gt; Javascipt has no such thing like class, that is what classes are by concept and by mechansm of how they are implemented in other langs. Don't be so sure. Classes and inheritance can have wildly different implementations from one language to the next. In Python, for example, a class is itself an object, and inheritance from instance to class to superclass is done by delegating down a chain of objects. Just like in JavaScript. &gt; Insted we could use javascripts engine default mechanism, behaviour delegation . It looks to me like you're using slightly different syntax to do exactly the same thing. Foo is your "class", init is your constructor, `Bar = Object.create(Foo)` is your "extends", `b1 = Object.create(Bar); b1.init("Albert")` is your "new", and `Foo.isPrototypeOf(b1)` is your instanceof. Ultimately the object structure and order of events is exactly the same as if you had used the class syntax.
Only true on US / UK keyboards. On German keyboards, for example, you need shift for either.
As someone who's used several statically typed languages over the years, if I see a "thought leader" recommend static typing OVER unit tests, I get the impression he is either lazy, over-confident or not coding anything interesting. A good type system is a great way to formalize how the various parts of a program interact, and it definitely helps by forcing you to [think more about data structures](http://www.goodreads.com/quotes/1188397-bad-programmers-worry-about-the-code-good-programmers-worry-about), but it's not gonna help you much with those subtle off-by-one/inverted-condition bugs. 
OP already said that this was a "would you rather ..." situation, but in real projects one should you both. In my experience since I started using static typing the number of unit tests I have to write is reduced by half. Typing can also function as a compiler-verified documentation.
Unit Tests, in a heart-beat. The only time I've _ever_ run into problems with Javascript's type system is thinking a string was a number or vice versa. Easily caught and solved by Unit Tests. I appreciate the benefits to tooling that static typing adds, but I actually like the loose typing Javascript uses. While Javascript is full of a lot of foot-guns, I think they can encourage a developer to be much more mindful of their work instead of relying on a compiler or type system
Hi, I'm aware that this is a bit old thread right now, but it inspired me to write an article in reponse: http://lukaszkups.net/2017/05/12/Is-is-Vue-js-worth-a-shot/ enjoy!
wat?
If you're looking to translate touch events into html5 drag events, check this out: https://www.codeproject.com/Articles/1091766/Add-support-for-standard-HTML-Drag-and-Drop-operat
I still don't get why anyone uses lodash when ramda exists.
Amazing
I wouldn't surprise myself because I said classes might be slower. The issue is what sort of "slower" are we talking about? Oh wow classes could be 100% slower. So it takes 6ms instead of 3. So what? And you absolutely did use the argument that Javascript doesn't actually "have" classes so they shouldn't be used.
Moreover I can tell that there is no good reason to develop some bullshit. Just do not do it and very likely you do not have to use Nodejs as well as other technologies. Nodejs does not feel slow and developing in and for it is much easier (imo) than using other technologies. I wish I have more patient and can spend more time to develop in C++ or Rust...
From my experience using US layout is generally preferable even on a non US keyboard, takes a while to unlearn your normal layout but once it's muscle memory it's so much better. Default keyboard shortcuts make a whole lot more sense with it (e.g square and curly brackets are reachable with a single hand, on a Norwegian layout it's a contortion of right alt + shift + number keys).
Just use a single 'master' range slider to bind the volume of all the elements. var master = document.createElement('input'); master.type = 'range'; master.min = 0; master.max = 1; master.onchange = function(event) { var elements = document.querySelectorAll('audio, video'); for (var i = 0; i &lt; elements.length; i++) { elements[i].volume = master.value; } }; 
One further question. everything i know about class inheritance in class oriented languages is from learning about prototypal inheritance in javascript, and the way it differs from classical inheritance (rather than actually knowing a class oriented language) That said, should i only describe prototypal inheritance, since i dont know a class based language? i cant go into much further detail on that subject (other than knowing generally about the distinction of delegating behavior vs copying)
Hey guys, I built this.. thing :) nspider.net is my latest project; a news aggregator. Currently nspider has over 150 newspapers which it 'spiders' every 45 seconds for new news, which it then adds to a database. The API uses some funky queries to extract that data and the comments and pushes it to the front end. It's completely built in Javascript, created with a NodeJS API and a NodeJS worker and an AngularJS front-end. To pump data between the back and frontend I'm using Socket.IO websocket services encrypted with an AES key which is negotiated for every session. If you're interested [here's a link to the bitbucket](https://bitbucket.org/cgraamans/news-spider). :) I hope you guys like it. Edit: Shit.. it's Showoff _saturday_, not friday.. sorry lads. Should I delete this post and post it in a few hours?
It might just be me, but the forwards and backwards buttons for changing the date seem reversed. I expect that the right arrow will move to the future and the left arrow will move to the past.
Forgive my sarcasm, but I still don't get why anyone would comment on an article he hasn't read. In the end of the article I'm writing about Lodash/fp (https://github.com/lodash/lodash/wiki/FP-Guide), which is Ramda-like (auto-curried iteratee-first data-last) variant of Lodash. 
So... the solution is for npm to encrypt your credentials better?
I read the article, the point stands. Ramda provides everything lodash fp provides, with less overhead. If I understand it correctly, lodash fp corrects a fundamental flaw in the lodash library by adding more code. Can you provide a reason why you'd use lodash over ramda if this the case?
&gt; Classes and inheritance imply copying of properties from class to an instance. No, they don't. Again, you're treating Java's implementation as if it were the one and only implementation. It isn't. Classes and inheritance can have wildly different implementations from one language to the next. And just because a language feature is implemented differently than in Java doesn't make it fake. If it did, then we'd also have to say JavaScript's functions and objects are fake, since they too are implemented differently than in Java.
There's so much noise in the Node community that I have to assume that only the more decent reputation packages rise to the top. With enough people taking a half-assed glance at the source you probably end up getting *somewhat* closer to full-assed coverage...
Yeah it definitely wouldn't be easy. I think the way to do it would be to make some kind of utility package that looks super simple and is used only once in your project. People will review your code but they'll rarely review your small dependencies. 
Well the technical issue was that npm allowed unpublishing packages :D
That's nonsense. It's set up whichever way the team set it up. Only beginners are afraid to leave it untouched. I've never heard of a team saying "We'd love to use double quotes, but sadly eslint is set up to single quotes, _and we don't know how to change it_"...
And teams, if you've ever been on one, will go with what makes sense and is based off their own experiences and the best practices accepted by others. Eslint out of the box, because it's the right way to do it, will disallow double quotes if theyre unnecessary (I already gave a use case)
how can I integrate this where the html is... &lt;input type="range" orient="vertical" id="volume-bar" min="0" max="1" step="0.01" value="1"&gt; and the .js is... volumeBar.addEventListener("change", function() { // Update the video volume video.volume = volumeBar.value; });
Nobody uses eslint out of the box. Most use the airbnb setting overriding the bits they don't like. Eslint is not what will decide which quotes will prevail in the industry, which us what you were claiming in the OP. &gt; And teams, if you've ever been on one, will go with what makes sense and is based off their own experiences and the best practices accepted by others A banality that doesn't really explain anything. 
Who's talking about Java ... ? I have no argue about different implementations of classes and inheritance. &gt; And just because a language feature is implemented differently than in Java doesn't make it fake. If it did, then we'd also have to say JavaScript's functions and objects are fake, since they too are implemented differently than in Java. That language feature (class method) is *not implemented differently*, in fact parts of it you have to emulate manually like one can see if one cares to read code from example above. That language feature *can be implemented to some degree* and only because of native mechanism. One more ilustration. Below are type checks that yo might need to perform to determine relations between b1, Foo and Bar from example above. class/functional stuff: // relating `Foo` and `Bar` to each other Bar.prototype instanceof Foo; // true Object.getPrototypeOf( Bar.prototype ) === Foo.prototype; // true Foo.prototype.isPrototypeOf( Bar.prototype ); // true // relating `b1` to both `Foo` and `Bar` b1 instanceof Foo; // true b1 instanceof Bar; // true Object.getPrototypeOf( b1 ) === Bar.prototype; // true Foo.prototype.isPrototypeOf( b1 ); // true Bar.prototype.isPrototypeOf( b1 ); // true Vs (delegation from example above): // relating `Foo` and `Bar` to each other Foo.isPrototypeOf( Bar ); // true Object.getPrototypeOf( Bar ) === Foo; // true // relating `b1` to both `Foo` and `Bar` Foo.isPrototypeOf( b1 ); // true Bar.isPrototypeOf( b1 ); // true Object.getPrototypeOf( b1 ) === Bar; // true Oh look, no instanceof operator. Less code. Then why not just use native mechanism...
and I've been doing const [ data ] = arr.filter(e =&gt; e.id === search_id) all this time...
None.
6/10.
But what if your local machine is linux? :D
If your default machine is Linux, then we aren't talking about a novice programmer anymore. lol
I literally know all of these things and more and my head is just fine. You don't actually need to know even half of this for modern web development.
Most of these things are incredibly interesting and I love the fact that I get paid well to learn more about them. I could never be happy with a job or career that didn't encourage me to constantly enrich my knowledge. You can probably forge a decent career for yourself if you just learn the basics and stop, but that sounds like a pretty unfulfilling existence to me. You have to find the things in life that make you happy, maybe Web Development isn't one of them.
Hehe, I actually like it pretty much, because of the same reasons you mention. But sometimes I'm just overwhelmed of all the stuff, hehe ;) Just so much things I still want to learn.
https://www.youtube.com/watch?v=QOuCpn4e4CI
Those two are vastly different. Google Translate is a service which you send the API text you want to translate and the language and it will send you back the translation. On the other hand, I18Next is a utility to help with displaying multiple different languages in the same application. I18Next doesn't do any translations for you, you have to set all of that up yourself ahead of time. It would highly depend on what you are trying to do as to which one makes sense. Here are the examples of how you would use each: [I18Next](http://i18next.com/translate/) and [Google Translate API](https://cloud.google.com/translate/docs/reference/translate).
Or just Array.prototype.includes (current browsers only).
If you learn _all_ of that though you've essentially mastered web dev and are going to have a great career.
&gt; there is no good reason to learn vim Totally true. It still makes my head spin that people actually think vim is more productive than the alternative. Completely archaic systems, single-threaded, hard to read language and weird plugin system, little to no integration with the terminal, despite LIVING on the terminal. Anyways, use Neovim.
?? I require the high schoolers I help to run Linux, anything else is unsupported and they're still novices. Ubuntu 17.04 is extremely easy to get started with. I don't think perpetuating the myth that Linux isn't for beginners will help us get anywhere. 
I understand where you are coming from. But I have also met 12 year old kids who are proficient in C++ but that doesn't make it the norm. I know that Ubuntu is extremely user friendly. But simply due to the fact that most people are familiar with Windows from the time they are very little, it's much easier to jump into Windows. And even so, in this context talking about vim, it's not the most user friendly editor by any means, it has a crazy learning curve.
Like Windows, Mac comes with a built-in virus scanner that runs by default. 
 function foshizzel(a,b){ return b.includes(a); }
Sorry, sent from the phone - part was deleted. I meant: "that is not a serious remark". How TDD safe refactoring time? But maybe, I wrote once a small project in JavaScript until I had all the tests, I couldn't change a bit of code without breaking something else. But again in Java or even Python it is not the case. On long term writing tests after code should have the same effect as tests developed with TDD. Other time I tried TDD with python and ended up with completely unmanageable code because I tried to make everything testable and started to adjust code to it, but maybe I have two left hands. I don't have too much experience, but from experience I have - too much tests slowing development down. Critical areas need to be tested, API, modules. Otherwise you need to refactor tests and the code. To help refactoring important to structure of the code: separation of concerns, encapsulating, etc. 
I'm new/naive. Is this like mongoose?
&gt; an external, non exported, function in what sense? &gt; OP seems to want the convenience of doing that though. I wouldn't know what is more convenient than closures :) &gt; (As well as declaring them within the brackets of the class for ease of reading) Thisless factories are even shorter and easier to read, with all the additional benefits ;)
It is not just the problem of not being able to inline private function. It is worse than that -- there is no more private local scope. With the functional syntax, you can reuse the local scope and e.g. write the identity functor container in single line: ``` const Id = x =&gt; ({ map: f =&gt; Id(f(x)) }) ``` How many lines would you need with classes? :)
In the last 12 months R has had less than 80 commits to its repo and only 3 releases (each with breaking changes). To put that into context, Underscore, which hasn't had a release in more than 2yrs, has had nearly as much activity in the same period. Lodash has more activity, releases, stability, &amp; enhancements. The FP modules of Lodash are completely configurable and, while they wrap Lodash methods, they are specially optimized to reduce overhead. This enables Lodash to be faster than R (even the FP flavors) in many cases. Lodash FP has several R method aliases so folks switching from R have a familiar API as well :)
You forgot about learning the protocols for packetizing and transferring data! HTTP, HTTPS, HTTP/2, SSL/TLS, DNS, WebSocket, TCP/IP, UDP/IP. Plus all the tools that are required to analyze those protocols - most of those things are baked into the web browser's developer tools Network tab these days, but it used to require a lot of external tooling (e.g. Wireshark). And then don't forget about comprehending all the IETF standards surrounding the various protocols. "Oh and yeah, for editing files on your production server, you need to learn vim" - Use Pico if you can't stand vi/vim. "native dom api sucks" - Well, it is getting better: http://youmightnotneedjquery.com/ But, yeah, it's still not quite as elegant as jQuery nor can you use the zillions of useful jQuery plugins out there without jQuery. 
Please note that while Google translate is impressive it also leaves a lot to be desired. We aren't at the point yet of having computers be able to reliably translate idioms and other forms of speech. Google translate is just doing a 1 for 1 word substitution and minor grammatical checking. The results are often nonsensical in the language the text was translated to. It *might* be OK for very simple menu options but it will be hilariously wrong for any real content.
 const CheckIfArrayContains = (needle​, haystack) =&gt; { let contains = false; haystack.forEach(hay =&gt; { if ( (typeof hay === typeof needle === "number") &amp;&amp; hay === needle ) { contains = true; } return contains; }
If nothing else can access it then, meh.
That's right, use behaviour delegation. There are no classes in Javascript. Read [this &amp; object prototypes](https://www.gitbook.com/book/escher/you-don-t-know-js-this-object-prototypes/details) , if you think otherwise, educate yourself.
`const b = JSON.parse(JSON.stringify(a))` Careful though, making deep copies is a bit of a code smell. and your lets, should be consts, and your vars should probably be consts too.
JSON.stringify would not work because 'a' has properties that are functions. carMake and carModel cannot be *const* because they change. The others, sure. Thank you. 
You could use the prototype pattern: In the factory, give the car a clone() method which creates a new car with the same properties. 
Can we make a generic method that is supposed to work on all objects though? Like angular.copy? Or Lodash deepClone? Thank you.
Yes. Or a ES6 class. As gremy0 suggests, deep copies can be a code smell.
No it wouldn't. We have modules with imports and exports for exactly this reason. Start leveraging them instead of trying to mash together es6 methods we used in es5 because we had no choice (IIFEs).
 function isIn(x, array) { return array.indexOf(x) !== -1; } Works in every browser :) 
Oh, didn't look properly, sorry. Your functions use the scope in which they are defined to reference variables, you need to rewrite them to use `this` i.e. `setMake` references `carMake`, you're asking for something that can; look at `a`, copy that function, and update the function's internal reference to `carMake` to the new version of `carMake`. But there's no way to tell that `setMake` is doing this, nor where the new version of `carMake` is.
Yes, at least in the open source community you *only* have to worry about your peers and you can all see what each other is doing. If someone got up to mischief it would get spotted pretty quick. Unlike the likes of microsoft who continually do whatever they like with your system and have access to all your data to do with what they please, entirely without your knowledge.
Then again you can publish your package with completely different code then what you have in github and no one can see it until they download it.
You can. JIT Babel or JIT tsc
Well, yes, but I wouldn't say JIT transpiling is the same as a polyfill.
Ups, fixed and tested the live version in FF, works now :)
Thank you so much for mentioning promise chaining! It's awesome - I made this changes: https://github.com/krzysztofzuraw/all-roads-lead-to/blob/master/script.js#L19-L31
Yeah. Now it works :)
&gt; (Additional note: It would help a lot to have some sort of pause or a drawing mode and a running mode. Some way to be able to draw a full starting pattern.) It's already there actually just didn't add the buttons for them *yet*, looking for suitable icons and whatnot on nounproject, so for now you can pop up a console: pause = true; // stops time; which stops everything passive = true; // stops the simulation from evolving, but keeps playing notes.
You missed Docker and Continuous integration(Jenkins, Bamboo, TFS) tools plus Git.
Could you elaborate on "fine-grain" control on tokens? Looking at what GH currently has it seems solid enough. Or you want control down to the exact repo level that things are allowed to touch?
&gt; Or you want control down to the exact repo level that things are allowed to touch? Exactly that. One token cannot simply allow access to all repos. I have/ had admin access to repositories of large corporations. Leaking my token once would allow an attacker to get access to all of these codebases. This is unacceptable.
For more flappy bird experience (viral) make jump as high as long you press spacebar. That will play with their minds :D
&gt; Jeez, how hard is web development Not very hard based on what you mentioned. You mainly listed a bunch of tools and libraries, which take experience, but are easy enough to pick up considering the 3832320137032+ guides on the internet. If you were a cs major, all you would need to understand everything you mentioned would be CS101 and a database class and maybe algorithms and data structures. That's why learning fundamentals is so important. People feel overwhelmed by the JS ecosystem because instead of the important stuff that never goes out of style, they try to learn every single new technology. Also, that's what the high pay is for, unless you live in Europe :( Seriously, why does the pay for devs suck so bad over there
Why do you need to pick up a new stack? Are you looking for a new job? If so, see what most of the jobs are asking for and learn that. In the interim, start following people like Addy Osmani, Dan Abramov, john resig, etc. or read JS blogs regularly. IF you aren't on github, join and explore. Join slack and discord channels on JS. Sounds like you may need a course in Algorithms &amp; Data Structures.
This is a holdover from the era when all you needed to know to be a front-end dev is HTML, CSS, and copypasta JS. They never learned by first principles and this is the source of all the whining I've seen about the JS ecosystem becoming too hard to learn. I recommend going even more basic than learning a new language. Learn basic theory. you can find free classes by looking at Stanford's, MIT's, CMU's, etc. curriculum for a CS degree. Then you really won't feel anxiety because you'll have the confidence to pick up any language, tool, library, framework, etc.
Thanks I'll be sure to keep that in mind, is it a profession or just an hobby
why is Microsoft invested in this 
Pretty solid right up, I'd say it's far from comprehensive though. 
In what sense it ain't easy?
No, you don't need to learn Vim to edit files on a Linux server (there's always nano or, like you said, FTP). That doesn't mean there's no good reason to learn Vim. It's just another editor/IDE with a different style of editing. If it's style works for you then you can be a lot faster. 
macOS does not have a built-in virus scanner.
I only use vim to edit files on the server and I only know the commands to do so. :a =&gt; edit :wq =&gt; save and exit I can't stand the nano editor and only use it for commit messages (one liners).
If you're looking to learn React, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, and much more. I also published an "Intro to React (and Redux)" presentation at http://blog.isquaredsoftware.com/2017/02/presentation-react-redux-intro/ , which is a good overview of the basic concepts for both React and Redux.
React will drive some of their desktop and mobile apps. Skype and Office Fabric are the first out. ReactXP probably replaces their UWP/Xamarin/Electron/cross platform efforts in the future. https://github.com/Microsoft/react-native-windows https://github.com/Microsoft/reactxp
Looks good! Much cleaner.
I have built a digital logic simulator (called BOOLR) for a high school project with Node.js &amp; Electron. I've worked on this for a year with 2 other guys, I have built the simulator and they have built a working 8-bits computer inside BOOLR. I am really proud of it, our mentor told us the project would be impossible, but we did it and we got a 10/10 grade. Project &amp; download website: http://boolr.me On github: https://github.com/GGBRW/BOOLR, I'm new to programming so don't blame me for the ugly and messy code.
The nano default has these highlighted shortcuts and vim is plain jane. It's silly but it's really the deciding factor. 
When you list it like that it does look ridiculous, but for those starting out - keep at it for a year or two and lots of these things will seem like second nature. You already know countless billions of things - this is just a few more.
The amount of vitriol some people spew for having to learn over the course of their career is amazing (and frankly cliche, at least in communities like r/javascript). One of the most appealing things about the tech industry is how fast it moves and that there's always new ways of thinking that allow us to build better, more performant and complex software. The pace of advancement is literally why software development is a good, stable career and why good developers with the wherewithal to embrace positive industry trends (instead of complaining and dragging their feet) are so valued.
"Because React on its own does not provide built-in support for state management..." I'm confused; isn't that what setState is for?
Component state, not application state 
Looks interesting, too bad they decided to ship with redux 
Aah, okay.
That's curious, the Skype team at Microsoft uses [ReSub](https://github.com/Microsoft/ReSub) for state management.
In addition to `typeof` not being needed, the expression you have will never evaluate to true: `typeof hay === typeof needle === "number"` The first comparison (`typeof hay === typeof needle`) will evaluate to either `true` or `false`, so the total expression will reduce to: `true === "number"` or `false === "number"` Neither of which will ever be true.
What a cool article. Loved the illustration at the end. I don't really have a need for d3 at the moment but I'm looking forward to the journey when I do. 
This is great, thank you!
What's your gripe with Redux? I'm genuinely curious. 
Added pause and randomize buttons, so it's a bit less awkward now ;)
ES6 has far more functional features than OO ones. Arrow fns, spreads, default parameters, rest operators. All of these make functional programming easier in javascript.
Pretty simple really, just show the icon at the start of the function that handles the ajax request, then hide it again after the response has been handled. const loadingIcon = document.getElementById('loading-icon'); loadingIcon.style.display = 'block'; window.fetch('some/url', { /* options */ }) .then(checkStatus) // See https://github.com/github/fetch#handling-http-error-statuses .then(res =&gt; res.json()) .then(json =&gt; { /* do stuff with json */ loadingIcon.style.display = 'none'; }) .catch(err =&gt; { /* handle errors */ loadingIcon.style.display = 'none'; })
Are you looking for a client generator?
You mean if one element has two classes, how to make the styles of one override the other? On option is to simply change the order in which the classes are defined in your css. All else being equal, the last defined class will override the others. Otherwise, you'd either setup your css to handle cases where both classes are present, or use js to remove the previous class when you add the new one. If you want to have to have multiple classes present and directly have your js choose which one takes priority, I'm not sure there's any practical way to do that, that's usually something you'd handle within the css. 
What does Koa offer over express? 
Possibly? I don't need to POST/GET/etc. I just want to do the following: If a schema property has an enum, create a drop down. If a schema property has a string, create a text box. If a schema property has a reference, resolve it. Upon updating the HTML page and hitting submit you get a JSON object, representing your choices based on the schema. Is that what the client does? Thanks for responding!
Thank you for offering this opportunity. I was more hoping they would do without one so I could insert whatever would work for that particular project 
http://swagger.io/swagger-ui/
Socket.io is a framework built on top of WebSocket. I haven't used it in a long time, but I think it also supports fallback to non-WebSocket transports (ex: long polling). It has reconnect, etc. All built into it. It's a bit clunk though and from what I remember and the implementation was a bit lacking. You can use Server-Sent-Events (i.e. EventSource) if your needs are not complicated and you just want to push basic text. It doesn't really support binary messages. One of the benefits it has over WebSocket though is that WebSocket is blocked by some corporate firewalls, while SSE is pretty much passed through. Both have their place. Personally, I utilize nChan and configure that to handle the transport details with the pool. The added benefit is that it supports clustering via file system, redis, database, etc. This makes it so that my application server(s) don't have to know about the transport details. Client-side, nChan works natively with whatever transport you want to use, and it also provides a thin JavaScript client to add a few extra features. Just my $0.02.
http://www.jongleberry.com/why-you-should-and-shouldnt-use-koa.html https://medium.com/@l1ambda/why-you-should-use-koa-with-node-js-7c231a8174fa Also, the author of both frameworks, TJ Holowaychuk, stated on Quora that Koa is better. :)
I feel like a troll bringing this up from time to time but what you're describing is a big part of what makes Ember so great.
Not bad at all for a newb. Some creative thinking here, I'd say you're a natural. I'd do this with CSS. Each time you begin "typing" a new string, assign the span a class like `.red-text` or whatever. For the cursor, try [this](https://css-tricks.com/almanac/properties/a/animation/)
The documentation for the non-react version of fabric was garbage last I checked. 
Does this support hot-reloading? Last time I looked at create-react-app there was no hot reloading.
This guide uses it.
I agree. Setting up the project is usually a one time thing you do and then stick with for months or years ... so it seems like a waste of time to become an expert in the setup of the tooling ... just give me something that works and let me focus on solving business problems, not tooling problems.
I built an app that generates a full branding kit for a business based on just a few inputs. You can start by generating a logo, or upload your own. https://app.builtbyemblem.com/ It's built on React/Node. For the logo editor (you have to sign up to see it), I built a dynamically resizing artboard for it. I haven't seen anyone make a graphic editor this way (photoshop etc are all fixed artboards), I quite like how it works for building a logo, I'm curious what other people think of it.
How is uncommenting the logo an error and why is ti crashing the app? const logoView = &lt;img src={logo} className="App-logo" alt="logo" /&gt;; {/*logoView*/} Failed to compile. Error in ./src/App.tsx (8,9): error TS6133: 'logoView' is declared but never used.
Part of why I love Vue. It was such a breath of fresh air. I'm insanely productive with that framework. It's a joy. 
&gt; honestly, the PHP behavior is more surprising It's actually normal. C#, Java, and C++ all behave the same way in this regard. &gt; you can always do... Sure. But then your private var isn't really private. And getting true privates is supposed to be a major selling point of factory functions.
&gt; It's actually normal. C#, Java, and C++ all behave the same way in this regard. Huh, what possible use-case is there to this class-centric "private" vs instance-centric? Why would another instance of this exact class specifically need access to private members of other same-class instances? If there is any use case at all it seems extremely narrow to me. Linked lists? Other data structures?
I have, every job I've had. I work for an ISV now, and all 6 of us know everything on that list, well. I'd say most companies with &lt; 100 people or so ... it's sortof assumed you'll be wearing a lot of hats.
I am about to finish a bootcamp where we learned the vast majority of all this. My brain is exploding. 
You might want to read my two recent blog posts on that topic, which discuss what's actually required and why: [The Tao of Redux, Part 1 - Implementation and Intent](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/) and [The Tao of Redux, Part 2 - Practice and Philosophy](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/).
For an `isEqual` method, of course. Also a `compare` method or `clone` method or `swap` method are a few others that immediately come to mind.
&gt; Later you find out, that for getting a job, you are better off learning laravel Really?
It literally tells you in the error message. You have a const defined but its never actually used (because you've commented it out). ... Welcome to TypeScript.
It's really not that hard. I don't see what you're complaining about.
I have to agree, there is an awful lot of boilerplate.
While I get the joke, throwing like that is not a good practice, it should not be encouraged imo: if (enthusiasmLevel &lt;= 0) { throw new Error('You could be a little more enthusiastic. :D'); } 
Not a single link to RFP?
Thank you! 
&gt;The reason we need to do so in this case is that getElementById's return type is HTMLElement | null. Put simply, getElementById returns null when it can't find an element with a given id. We're assuming that getElementById will actually succeed, so we need convince TypeScript of that using the as syntax. I find this confusing. What exactly does it affect? I cannot observe any difference when removing it.
Hmm.... never used that before. I'll read up on it a bit!
 const Thing = (()=&gt;{ const somePrivate = Symbol(); return class { constructor(){ this[somePrivate] = 42 ; } isEqual(otherThing){ return this[somePrivate] === otherThing[somePrivate] } } })(); let thing = new Thing(); console.log(thing[Object.getOwnPropertySymbols(thing)[0]]); // 42
http://i1.kym-cdn.com/photos/images/newsfeed/000/353/279/e31.jpg
I have been working on turning some code I have been using in side projects into a reusable library. It aims to provide a pretty raw approach to handling two things in redux apps: - Track api statuses (pending, success, fail, timestamps, slow connections) - Manage your normalised data (storing, editing, optimistic updates) Lately I have been working on finishing off the documentation and making the code/api more straightforward. I would love some feedback if anyone has the time to take a look! A bit of a heads up though, I am still hacking away at it, so api will change at will atm... https://github.com/AlexRobinson-/Redux-Fetch
This article is a pretty basic, shallow introduction into Promises and async/await, but has basically nothing to do with React specifically.
I don't know how your web server is configured, but I have created both pages with both PHP and Node.js that accept both POST and GET requests. Really the only difference is where the query parameters are located.
tried moving function declaration higher, still no fix
I fixed it. I had to change the debugging protocol vsCode was using to inspector instead of default, I guess it was using a legacy protocol that node no longer supports and vsCode is not smart enough to realize that without help.
Thanks for sharing, I'm starting a job soon that'll involve some d3 but I haven't really had my hands on it before. This is perfect to help me jump in.
&gt; So, back to that JS code, maybe the "problem" is that Factory is an intention, while using a closure to encapsulate private/scoped variables is just a mechanic, and a very specific one. Maybe this is why I've never felt too comfortable saying "private" instead of "local"... So... if I'm reading this right... you're ultimate point is that using locals to represent privates is the wrong mechanic?
&gt; Also if you wanted a copy in a Factory function, you can always try this. -ish. That only works when there's an exact 1-to-1 match between constructor arguments and private variables. An extra private variable would screw up your copy. function carFactory(make, model) { let carMake = make; let carModel = model; // can change over time, and not a constructor argument let milesDriven = 0;
Would that also remove the warning? Or is there a way to keep the warning but not the error?
Can you explain the difference between function based and feature based? 
If you're using express for your server, all you need is: ` app.get('/image', (req, res) =&gt; {` ` // handle get` ` })` ` app.post('/image', (req, res) =&gt; {` ` // handle post` ` })` 
This is why I switched to Angular
It actually didn't work for me with arrow functions..seeing your example I will revisit the code..because it worked with a standard function
If you already have a reference to the parent element, then: parentDiv.querySelectorAll(":scope&gt;.one").length; Otherwise: document.querySelectorAll("#parent&gt;.one").length;
Functionality based: all controllers together Feature based: all files that belong to one component together
Functionality based: all controllers together Feature based: all files that belong to one component together
If you want less boilerplate, go with MobX. Been using it for a recent client project and it has all the stuff you'd expect from redux with one third the code if you setup your stores, and injects properly 
Yes, it's my go to state library, love the simplicity of it compared to many others
What's not hard?
Jquery: $('#parent').children('.one').length
In express you can attach multiple verbs to a given route... app.get('/images', (req, res) =&gt; { /*etc*/ }) app.post('/images', (req, res) =&gt; { /*etc*/ }) I'm going to assume you are using the implicit grant flow in spotify. Implicit grant doesn't support refresh tokens, so once it has expired, user will need to auth again.... you can also implement one of the other auth flows that has refresh tokens. It's a bit more work, but will make the UI a bit cleaner as user's wont have to login again/again.... I think token expiry is an hour, (if their example responses are to be trusted, says 3600 seconds).... so that should probably be fine for you. Seems to me you have 2 cases -- first is the path of least resistance: (1) User has authorized with spotify (i.e. you have an access token and it hasn't expired)... you can post to both emotions api, and spotify -- and do whatever you need to with their respective responses prior to rendering to user. (2) User has not yet authorized with spotify. Keep track of what they posted and the response from emotion api. Show some kind of message, "you need to authorize!" clicking that message redirects the user to spotify where they login and authorize your application. When they come back to you via `redirect_url`, it can be a `GET` to the `/image`, that is fine.... you will have `access_token` and `expires_in` in the query string. In the GET request handler, check for this information and save it to user session for later to get path #1 above. The `get` version of /images can work identically to the `post` one -- with a few differences: in the `get` version, you verify you have the info you need (access token, expires_in, previously requested image url, previously requested response from emotion api) and if not redirect to `/`. If you DO have all the information you need, do the same thing as `post` but using previously saved data instead of POST data. Also, make sure to nuke this data afterwards so hitting `refresh` on the page will just redirect them to `/` -- except now user can post to `/images` and you have all the tokens you need.
Great feedback, I felt like it was too short/shallow myself but wasn't sure where to go with it. I've included some more examples and scenarios :) 
Async/Await only seems to work with arrow functions when using babel, if I try the same in Node, I git the same issue, updated the article to include a note on that, good spot! 
Found a chrome extension for this: http://github.com/yuanchuan/game-of-life
With `:scope&gt;.one`, it only matches child nodes. If you just use `.one`, then it could potentially also match deeper levels of descendants too.
You're missing the point of TypeScript. It is intentionally much stricter than traditional JS development so as to get you thinking more about the code you're writing. Think about it, it makes no logical sense to have declared a constant which remains unused. The TS compiler isn't at fault here....
It is ok to be stricter at the level of warnings, for which there are many reasons beyond the scope of TS. I do uncommenting constants all the time and know exactly which ones are not used and why. It is absolutely not ok to crash my app throwing errors that would be swallowed by the JS. Give me a warning and leave it with me. Anything else is plain invasive and must be the cause of grief I have with some people's code, because they didn't bother to clean the warnings but still the TS should let me run their app with or without errors. Not to mention that very often those errors are due to the new TS version and absolutely not fault of their authors. 
It's already preped for Redux, it's not like they installed the package and said "hey, you know what, you do the rest"
its basically "this element", like &amp;&gt;child in Less
So the answer is No?
Does anyone know how to plug in jsfmt?
 function groupSequentialTimes (times) { return times.reduce(function (memo, time, i) { if (i === 0) { memo.push([time]) return memo } if (times[i - 1] + 0.5 !== time) memo.push([]) memo[memo.length - 1].push(time) return memo }, []) } groupSequentialTimes([7, 7.5, 8, 8.5, 16, 16.5, 17, 17.5, 20, 20.5, 21, 21.5, 22, 22.5, 23, 23.5]) Results in: [ [ 7, 7.5, 8, 8.5 ], [ 16, 16.5, 17, 17.5 ], [ 20, 20.5, 21, 21.5, 22, 22.5, 23, 23.5 ] ]
You need to wrap your strings in quotes: document.write(user.username + '&lt;br /&gt;'); document.write(user.password + '&lt;br /&gt;'); document.write(user.email + '&lt;br /&gt;') 
Nah dude I still get a blank page even if I write document.write("Hello World");
OMG LOL I missed spelled &lt;/script&gt; XD ok everything works now!
There is [page.js](https://github.com/visionmedia/page.js) if you just want a router.
Sadly learned that the hard way🙃
Personally for me, the location of the files is pretty inconsequential, but for those who really mind it you can use the pod structure in ember to get what you'd want. In my editor it'd be the same to me more or less because I just find by filename.
I've tried to use vim mode with all kinds of editors/ides, and all of them leave tons to be desired. Here, let me show you how I program. And I want to make it very clear that, while my method of programming is objectively superior to any other method ^^/s, I don't expect anyone but the most elite programmers to be able to handle it (read: it's not for everyone; it just works way better for me than anything else I've ever tried) http://i.imgur.com/Wjx1ieC.png As you can see, I start off by having a particularly high res monitor (I have a 2560x1440 monitor on my laptop, but I usually use a 4k when I work) and super small font. Then I open about a billion split panes in my neovim instance. At the bottom right, I have one or two terminal panes for running the server, doing git commands, installing packages, etc. That's pretty core to what I do, so that's the kind of integration to the terminal I need that vim does not provide but neovim does. You can also see that the splits are placed whereever I want them to with an extremely small profile (1 character tall/wide borders). I also don't use my mouse for anything in this entire configuration. So... I'm pretty sure I can't replicate that with any other editor. I guess I probably could with emacs, but I already know vim and I have all my plugins.
I'm more curious how this can be called "lightweight" when it is required that I ship the entirety of react, react dom. If proper tree shaking isn't done (haven't looked too deep) then it also brings a fetch implementation, immutable just, etc. This is some serious heft.
What have you tried so far?
First, you need to indent all your code with 4 spaces so that reddit renders it as code: var array = [ {Name: name1, Company: Company1, Id: id1}, {Name: name2, Company: Company2, Id: id2}, {Name: name3, Company: Company3, Id: id3} ]; function myfunction() { var myname = document.getElementById("name").value; var mycompany = document.getElementById("company").value; for (var i = 0; i &lt; array.length; i++) { if ((myname == array[i].Name) &amp;&amp; (mycompany == array[i].company)) { alert("Here!"); } else { alert("Not here!"); } } } So, do you see any errors in your console? You probably do, because of this: var array = [ {Name: name1, Company: Company1, Id: id1}, {Name: name2, Company: Company2, Id: id2}, {Name: name3, Company: Company3, Id: id3} ]; The following are all invalid: `name1`, `Company1`, `id1`... and so on for `name2`, `Company2`, etc. You're trying to set those values as variables, but no variables have been defined for them. What you probably wanted to do was set them as strings, which you do by quoting them with either `'` or `"`: var array = [ {Name: 'name1', Company: 'Company1', Id: 'id1'}, {Name: 'name2', Company: 'Company2', Id: 'id2'}, {Name: 'name3', Company: 'Company3', Id: 'id3'} ]; If you insert that into your code, it should work as expected. If not, check your console log for errors, and then fix those if there are any. If you're still having problems, please recreate the problem using [jsfiddle.net](https://jsfiddle.net/) so that we can more easily help you!
Interesting, but try and provide more substance than just "Vue rate component" in a link post OP.
me too..it was working nicely..but a lot of ajax, jquery..and events :D ..happy with react router so far :D
Sorry for the messy code, here is it in jsfiddle: https://jsfiddle.net/ApplePie125/ron1mpm1/ The problem is that right now, nothing is working, even after adding the quotes :(
I am impressed how it deals with millions of records, but it is more like list control instead grid.I couldn't find options like paging, searching and sorting for some reason works only for up to 10k records.
This is very trippy and works in a mobile browser nicely
It's not angular and it does not replace angular. It is a web-components authoring plus data binding, making React disposable. And it's 25K.
Oh, I see. It works perfectly now when I add the break statement at the end of the if and else conditions. Thank you very much.
Look, maybe I was out of line by saying it was similar to Angular because I don't know slim and I don't really know Angular. But this library uses strings to represent HTML to represent the DOM as well as string interpolation to do data binding. I don't even know why you're comparing it to React. It seems like you're just picking the most popular web view out there and saying "look, this is even better than that!" 
To expand, React has at least 3 things slim does not (as far as I can tell, anyways) 1. Prop propagation throughout a lineage of components 2. Virtual DOM 3. Rendering through JS variables (as in, you must define a variable and access it locally to use it, rather than just saying "&lt;my-component&gt;" will always correspond to a certain rendering behavior). This enables static analysis and makes it much, much easier to follow code paths. You want to kill React by making a smaller, faster variant? I'm pretty sure Inferno and Preact are smaller than slim but have almost identical APIs to React. So good luck. 
It has easier syntax than React. It does not need tool chain like react. Just use the standard debugger. It is faster than react. It leverages web-components and does not replace the DOM rendering mechanism. It works on the actual elements on the DOM and not on a virtual representation of it, therefore plays nice with 3rd party libraries like jQuery.
Syntax ease is debatable, and I see no benchmarks. All of your other points are valid and irrelevant. Most of the things you're saying React has that slim does not are things people *like* about React. The virtual DOM was the original selling point of React. 
Mag-fuckn-neato 
Thank you so much! People like you are exactly what's right with Reddit, and I'll never stop being surprised that people actually want to help on here. If I had money for Reddit Gold you would get some. &lt;3
1. Slim has scoped variables within a template 2. Irrelevant. Virtual DOM is just one approach to performance. 3. I'm not sure I follow you. Can you give an example? I'd like to hear opinions.
That's alright. P.S. Generally a simple thanks like this is much more appreciated (at least in my case :) )
here's a quick benchmark: https://embed.plnkr.co/UlrfL6ocFdHjAegsS6wp/ check it with chrome and open the console to see the timing. 
You could also use Backbone's router: http://backbonejs.org/#Router
React killer it is not.
Sure.
the current standings are here, btw: https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts/table.html looking forward to seeing slim.js's performance.
I feel your pain, when I started off doing web dev security was the last thing on my mind. But as I started to dev more and more it become apparent that I needed to learn it to prevent randoms from getting into places they shouldn't be. I can't really recommend and security tutorials but what is basically happening is this: 1. A user updates a package that now has malicious code in it. 2. You update that package and use it with the malicious code. 3. If you have logged into npm with `npm login` it steals your token. 4. The malicious coder uses your token to replicate his code into your packages and update them using your token :( 5. All websites start to fall apart cause NPM is so relaxed about token auth 6. The world is on fire.
I use Aurelia and the ui-virtualization plugin that allows me to virtualize my tables for optimal performance. Other than that, I usually only show X initial rows of data and let the search and filters I manually create with value converters hone in on specific data being searched for (debounced API search calls on the ui, virtually rendered tables)
&gt; There are tons of javascript grid controls online that have built in sorting, paging, filtering etc. if you're looking for a grid control that does server-side requests, you're not really gonna need any of these features. you just need a control that can display a variable amount of rows and can be updated as a result of some ajax request to the server. all the sorting, pagination and and filtering will be done server side (as they should be for massive datasets). This is simple enough to implement in vanilla javascript, though a view layer can be helpful. I would not pick a framework based on how well it can render a grid from server-fetched data - they can all do it very well. Here's a grid display i thew together in 10 minutes and 50 lines of code with clickable columns and prev/next buttons: https://jsfiddle.net/0qyrko9k/. In another 20 minutes it can be hooked up to a backend w/ajax requests to display filter/sort/paginate server-sent datasets. The demo uses a [generic view layer](https://github.com/leeoniya/domvm) that i maintain, which is geared towards devs who are more-or-less comfortable with Javascript, which is something you'll inevitably need to learn with any frontend framework.
You can add that to your tslint rules
Let's see how demand for slim developers compared to React developers is looking in 12 months before you declare it a "killer".
&gt; 'create-react-app' This is even a good starting point for those not doing React (although of course you'll have to remove those dependencies after init). It has a sensible Babel config and support for Jest testing and Flowtype, and code splitting. 
awesome!
No I agree with you in terms of `create such and such app` and not really understanding it, but what I am talking about is what I knew about setting up a `webpack.config.js` 4 months ago no longer applies. The way you set up alias, resolvers, loaders, plugins change over time. I understand webpack/babel and what it does, but that doesn't mean I don't have to look up at the documentation again as they changed around the API or what npm packages I need to install that works with version `@x.x.x`. Configuring what prepossesses, polyfils etc is great which I 100% agree with, but I would be great to also skip the step when you know you're just going to use the most common use case(Take already existing features in ES2015 and use package it together with the support for the common JSX `import` system ) and create an excludable bundle that works just fine. Whether someone just wants the core package and configure it, or use the basic use case and add a few extra things to it could still happen, I just would rather not have to read several forms of documentation for each tool just so i know how to get them to work together properly so that I can create a silly app idea I am making for myself. &gt; And finally: hang in there, yo. I know this stuff can be frustrating, but "being frustrated by software" is pretty much the norm when figuring out any new programming domain, so at least you're not alone in the sentiment. :) It's not about being confused by webpack or babel, I have been using them for a long time, it's just if you look at my `package.json`, I have two dependencies for the actual code, but 10 just for the "Tools" which do nothing more than transpile standard `ES2015`code into ES5 into a big ball. The ability to customize and add what you need is great!, but I just sometimes would like to get up and running quickly. 
improvement 1: var answerCounter = 1; and remove the initial answerCounter ++; improvement 2: why have two answerCounter ++; in the loop? answerCounter +=2; ? improvement 3: remove redundant variable initialBounce; - just use thisBounce? you never use initial bounce again
Ah well, that's fair. I've really only worked at places with 2000+ employees. We have a lot of specialization, our ops team for *just* our project is 11 people and all they do is server maintenance and deployment. Then we have 4 other people for QA, 2 developers who only write tests, a PA, a PM, a scrum master, a project owner, and various stakeholders, then 5 subteams of about 6-9 people a piece. Then there's the design team who I'm not directly involved in but I know is fairly large itself, plus the off-site teams that we liaison with. All in all, no one is tasked to do more than a small piece of anything.
This is the right answer. I did something similar recently with a smaller but still substantial data set; think a few hundred k of results per table, and if the front end is only ever dealing with at most a few hundred results at a time then it doesn't matter too much what framework you use they should all be able to handle it. I used angular 2 and am happy with it. But I did have to implement most of the functionality myself as most of the prerolled tables assume that you deliver the entire data set to the front end and the front end is responsible for filtering, pagination, etc. So whatever you go with you might end up rolling your own solution for display but most any modern framework can handle it no problem.
Have you tried babel-env? It's the one on the [babel frontpage](http://babeljs.io/). { "presets": ["env"] } It picks the transforms relevant for you. Later in prod you can pass it a browser support target. You shouldn't have to worry about right versions and deprecations. As for webpack, do you use version 2.x? It should be trivial, unless you're doing out of the box stuff. I often copy an old config because they usually don't change. 
I did it a bit differently. I built action creators for fetchTodos for example. This example would first dispatch FETCH_TODOS_STARTED then send the request and after that dispatch FETCH_TODOS_SUCCESS with the todos. This way it can be used by different components and I have all my api calls in one file (apiActionCreators)
As person who published once library and got ZERO upvotes and stars - I will upvote you just for the sake of your effort. I did not yet test and see your library.. But for the sake of effort. Also, trendy viral titles like "react killer" nowadays just making people agro React is not only library, it's also infrastructure, ecosystem. Also about 25kb... There are better react killers if you know what I'm talking about: preact, inferno, hell even riot.js Also, where are benchmarks and repl if we want to play with it?
 class Thing { somePrivate = 42; isEqual(otherThing) { return this.somePrivate === otherThing.somePrivate; } } let o1 = new Thing(); let o2 = new Thing(); o1.isEqual(o2) // true
[removed]
was also thinking of going backtick, looks like babel is pretty conservative on the transpile, only making functions out of tagged literals. more investigation needed though, sorry about the massive link: https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-2&amp;targets=&amp;browsers=&amp;builtIns=false&amp;debug=false&amp;code=const%20tagged%20%3D%20(strs%2C%20...vars)%20%3D%3E%20strs%0A%20%20.reduce((r%2C%20s%2C%20i)%20%3D%3E%20r.concat(s).concat(vars.splice(i%2C%201)%5B0%5D%20%7C%7C%20'')%2C%20%5B%5D)%0A%20%20.concat(vars)%0A%20%20.join('')%0A%0Aconst%20p%20%3D%20%60No%20interpolation%60%0Aconst%20q%20%3D%20%60%0A%20No%20interpolation%0A%20Multiline%0A%60%0Aconst%20r%20%3D%20%60Interpolated%20%24%7BMath.random()%7D%60%0Aconst%20s%20%3D%20tagged%60Tagged%20%24%7BMath.random()%7D%20is%20func%20%24%7BMath.random()%7D%60%0A%0Aconsole.log(p%2C%20q%2C%20r%2C%20s)
I think the author needs to read [https://www.toptal.com/back-end/server-side-io-performance-node-php-java-go](https://www.toptal.com/back-end/server-side-io-performance-node-php-java-go) 
Thanks, but the tests are still outside?
You're still no Graphics Artist. Sure, smaller or less experienced companies may not necessarily make the distinction, but that's not what was being discussed here.
Maybe use rollup instead of webpack and https://github.com/rollup/rollup-starter-project? Edit: typo
I'm not talking about making graphics. I'm talking about UI design, UX design and cognitive psychology. Front end developers have to work closely together with UX specialists, interaction designers, graphic designers. You can't work together if your knowledge is not T shaped.
If your pdf is available publicly you can use Google docs in an iframe to open it. `&lt;iframe src="https://docs.google.com/gview?url=[PDF_URL_HERE]&amp;embedded=true"&gt;&lt;/iframe&gt;` Not sure about accessibility features but it may be worth investigating if it meets your needs.
Why are people hysterically afraid of maybe having to type a few characters more? BOILERPLATE!!!1 All of the arguments for having named constants are sound, especially if you are developing with a good IDE. I don't need to type the named constants imports, the IDE autocompletes and auto-formats them for me. It can follow usage across my project, renaming constants *is* a lot easier, I can just go into my constant definition, rename the constant and it will be changed everywhere, somewhat safe, whereas the string replacement is just that: brittle string replacement. ("Oopps.. that name was also a sub-name in that? unfortunate..) He miuses Cargo Cult Programming for this architectural pattern. Cargo Cult is when you do stuff that you apply magic value to without being able to explain how it works. As I said before: There are valid reasons for this, just because you choose to ignore them doesn't make it Cargo Cult. &gt; More often than not, the best solution is the simplest one. Or it produces brittle scripty-hacky programs that need to be completely rewritten next year. edit: If you're code-golfing your silly TODO app examples, go ahead. Personally I wouldn't be using redux if I didn't need it to write maintainable applications of non-trivial complexity.
Yeah, autocompletion is indeed powerful.
just added slim via PR. I'm looking forward to see the results.
*I think the Conclusion on the Link mirrors that even the Author wasn't really sure about which point he wanted to make.* If you use imported constants for strings that are only valid in a single functions context - then yes - maybe you are over complicating something. But even then I would say that it's better safe than sorry. I treat each string in a function as a [magic number](https://en.wikipedia.org/wiki/Magic_number_\(programming\)) as long as I'm not totally sure that it can not be taken out of context. As Example (pseudo code for brevity) function retrieveTableByClass(class) { return document.getBySelector(`table.${name}`).item(0); } The html tag name `table` will never change as long as the task of this function is not changed. If this string is changed by mistake Everyone will know by the context the function provides.
I agree with everything so here's an upvote instead of me formulating the same reply
Microsoft embracing Google's JS minifier for their competitor to Google Docs, which is a competitor to MS Office. Yeah, wouldn't have expected that in 2012.
Also agree here and honestly couldn't the problems he describes very easily fixed by ES6 classes with static constants? That way you would not need all those silly imports and keep the constants to their specific regions like ```import EventConstants from './EventConstants.'``` ```case EventConstants.loadRequest``` ```case EventConstants.addFailure``` etc etc
The website is ugly as f**k. :/
&gt; All of the arguments for having named constants are sound, especially if you are developing with a good IDE. Exactly, not to mention `eslint` and the like won't be able to warn you if anything is wrong if you just use pure strings.
&gt; You can not import * as constants from './constants' because then, if you make a typo, you won't get a ReferenceError, the value will just be undefined. Instead, you must do this: Of course you can, and then when you start typing `constants.` your IDE will auto-complete it for you. You are also missing some other reasons - for example to avoid cyclic imports. You might enjoy reading an article /u/acemarke posted recently - http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/
Not really. Just naming a magic number doesn't make it less magical. `setTimeout(foo, 1000)` vs ``` var oneSecond = 1000; setTimeout(foo, oneSecond); ``` vs ``` var timeToWaitForNetwork = 1000; setTimeout(foo, timeToWaitForNetwork); ``` His point in the article is that it just adds more complexity that you now also have a variable named the same thing as a string. And without any real benefit.
Sure thing! :)
Magic numbers are dangerous because you don't necessarily know why those numbers were chosen, or what role they fulfil, making the code fragile and hard to reason about. This article is arguing that changing a predefined (and perfectly self-documenting) string to a symbol *with exactly the same name* is stupid make-work, and that the added "flexibility" it gives you (the ability to have symbols with different names to the underlying string) is just a confusing antipattern that isn't really a benefit at all.
Sorry about not being precise enough with the post title :)
Yes, and it really just points up the lack of decent `enum` types in JavaScript. It's unfortunate that Redux has to use string constants like this.
Who knows what he's going to think is "just easier" next? Might be reducers with side-effects.
With HTTP2 the response headers are assumed to be the same between responses so the server only has to send the headers which have changed.
This is why I use RequireJS, I'm starting to use Web Pack but this has the same effects.
yep know of it. how's the quality and whatnot? Will I see performance degrade? Can I choose the chrome runtime and are mobile controls like a virtual joystick possible?
This is the framework that everyone should use, both as a means of building front-ends, as well as interviewing candidates.
If you don't want to overcomplicate things... then maybe don't use redux unless your project requires that.
The question is: choo has 1 state for all components?
Very true. I'd like more control than google docs provides since I'd have to set the google doc to "public anyone with the link can view". For example, others can save the doc to their drive and embed it where they like even if I turn off copy, print, download for viewers. Did google docs kill off these other HTML5 viewers?
Lately what I've been doing is just 'cp -r latest-project-that-works-with-similar-target some-new-project' and then in the new project directory, 'rm -rf .git' as well as all the source files specific to the old project. So essentially cloning a boilerplate, but tools change so fast, I'd rather just iterate off of my latest build set up. Obviously you'll have to remove project specific package.json dependencies, but your devDependices are going to be roughly the same. And then I'd do a fresh npm install as well. I've been doing this with a lot of webpack + jest with target of node, so no babel stuff, but if you have a project where you've gone through the set up once, it should work too. 
Hi /u/DudeDogDangle, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your work/homework for you.
Thank you!!!!!!!!
This is cool, thanks.
That is super strange and I have no idea what's going on. Looking at both of those accounts it appears that they're just spam accounts that take a title and repost it after modifying it a bit. Why? I have no idea.
Make a simple Node.js Express app, which could serve static pages along with upload handling?
There are only two hard things in Computer Science: cache invalidation and naming things.-- Phil Karlton Use your gut, byt generally keep them short I would say. 
...and off-by-one errors
Brunch masterrace
If naming references is your biggest challenge in programming then either you aren't solving hard problems or likely shouldn't be programming.
I'm already interviewing 10 people right now. Asking them about choo-choo http://scontent.cdninstagram.com/t51.2885-15/s480x480/e35/c68.0.608.608/11849995_513001898863748_341750284_n.jpg?ig_cache_key=MTA3MTI5MDA2MTk2MDcxOTk5Ng%3D%3D.2.c
Title mentions React Native but 80% of the article is about a 3rd party cloud compiling service and the hardships the author faced because they tried to develop a iOS RN app without owning a Mac.
Interesting - I didn't think browser imports were going to work like this. I had assumed you could use modules, but that you'd have to load them via &lt;script&gt; tags first. I guess it makes sense as modules can include modules, but just thinking of the process a browser has to go through to parse JS, see the module, stop and load that module and then parse that JS recursively makes me think it's going to be an inherently slow process noatter what. All that said, the weird pauses (18 seconds?) is just broken. 
Ramda is a contender because it's curried by default but potatoes, *potatoes*. 
Looks like you're doing something else between when that array is logged and when you're inspecting it in the console. The first line is representative of the logged state of the array (blockArr) while the rest is representative of when you started to manually inspect it (the i icon is your warning for this). You can see that the length of the last two arrays both change from 2 to 5. So is there something else going on adding a NaN (or some other value) to index 4 in those (maybe all) subarrays?
I would reccomend backbone. Very unopinionated compared to a lot of other frameworks and would plug in very well with your existing codebase.
nice and clean :)
Don't overcompile javascript 
IIRC Chrome's console is only "semi-live"... I don't know if that's still the case (don't have chrome here now), but it used to work that what you see is the value _at the moment you inspect it first time_, not when you log it. It's weird and confusing so they may have changed it. Firefox's inspection is clearly _live_.
Those dependencies you mention? They're all part of `express`'s dependencies. And the reason `npm` installs as many things as possible in `node_modules`? It's to solve [this issue](https://github.com/nodejs/node-v0.x-archive/issues/6960). `pnpm` is actively broken on windows.
Thanks :D
they're saying "it doesn't really occur to me as a use case" but implying that there doesn't exist a good use-case for it at all. It'd be more convincing if you described such a such case, even broadly. The way I see it, Redux is undebatedly boilerplate heavy. This interface layer between strings and constants isn't more burdonsome than the other Redux abstractions, but it's utility is not necessarily as apparent. 
I'm home-rolling my own engine over canvas.
Angular 2 is the enterprise option for front-end development. It is a combined effort of Google and Microsoft. Angular 2 is the feature filled option of SPA frameworks. However it is very Opinionated and uses TypeScript. Your mentor can hate it all he wants but it's not going anywhere in fact for the corporate world it is likely to be come the defacto SPA everywhere except Facebook. Even if you don't plan on using it I would grab the Angular-CLI and build something on it. 
`MAX_PATH` is still a concern even with symbolic links. Maybe you should actually read the issue I linked? The problem is that nested hierarchy leads to exhausting the alloted space for `MAX_PATH`.
Solved it, it was an issue with my later code and misplaced object notation, a common theme in my JS life. I wouldn't of spotted it had I not known about the console and it's liveness. Thank you!
Good question! You should ask [rpominov](https://github.com/rpominov) :)
Pretty sure it wraps around a canvas. I'm using 2d anyway and frame rate appears fine. Threw any computation in webworkers
To be honest, I'm unclear on how it got this reputation. It certainly *feels* more "corporate", I guess, but the biggest SPAs on the web are built using React more often than Angular. It's older, has a bigger community, and can be switched to incrementally more easily. I hear "it's the enterprise" option a lot, but I see little evidence of that and even less reason for it. Is it because all the tutorials are in Typescript? Because you can use Typescript with React... 
Angular brings a lot of really great ideas together. Typescript is a godsend for large code bases. Rxjs is a really nice and very powerful way to handle data and control logic. The dependency injector is capable of doing any of the things you want to do with di. Css is handled in such a way that component scoping is trivial while not breaking the normal Css conventions. And decorators make it easy to tell at a glance what a particular class is for and how it is used. The cli supports creating a new project, skeleton code generation, and building the app in very easy to use commands. That's not a comprehensive list of all the good things in Angular but it's a broad overview of the features that stick out in a good way. Not to say Angular doesn't have its bad parts though. The templates aren't nearly as bad as a lot of people will claim. But they aren't a joy to work with either. They will be familiar in general terms to anyone who has done WPF or Android development. And they do provide the tools you need to create whatever interface you need to. But it's a bit too easy to fall into the trap of handling too much logic inside them. It usually takes some experience to learn that the best templates are the simplest ones and logic should be inside the components controller as much as possible. Also, while the layout of an Angular app makes logical sense in having Components, Directives, Services, and Modules it is a lot of plumbing that other javascript frameworks shy away from. It's inevitable when the framework is trying to address so many needs. But it can feel needlessly complex until you get used to it. And there are still a number of sticking points in the framework. They can be worked around but it sometimes feels like all the edge cases haven't been ironed out yet. A good example of the above is the init cycle of the component combined with change detection. Change detection is how Angular determines that bindings have had their value changed. So during init the first thing Angular does is check those bindings. Then it goes through a couple of init processes with optional callbacks. But if the bound values change at all during this init cycle the changes are ignored. It does make sense, basically Angular doesn't read changes during init so that it doesn't get into a continuous loop of "check changes", "do init", "something changed during init so check changes again", "the changes mean part of the init has to fire again", "during the init more changes happened..." to infinity. But what's missing currently is a final life cycle method after all other inits have completed where you can safely change values again and have the changes recognized by the component. Anyway I'm rambling now but the point is that overall there is a lot to like. And the framework is still young so I expect we will continue to see better and better things from it. And even if you end up not liking Angular, once you've used it you'll have an informed opinion about it. Being experienced in multiple tools can only make you a better developer even if the only thing you learn is how *not* to do something. If you do try Angular and have questions /r/Angular2 is a better sub to ask them on than here. Good luck. Oh and use the cli.
To add to what /u/Shadowvines said also Angular isn't even a year old yet. Of course there are more react spas out there. It's been around more than twice as long. I'm not sure Angular will ever be truly bigger than react. But it could easily be of roughly the same market share. Angularjs was in many ways the first javascript framework that got enough attention to gather a critical mass of developers. And since it was first it had little competition. I don't ever expect, or even want, a single framework to have as much market share as angualrjs had. Competition is good for the market. But there is also plenty of room for Angular, React, Vue, and $YourFavoriteFramework to all coexist in a market as large as the Internet is.
Yea. This should be titled Expo for RN; lessons learned. I've built RN apps for a good year now and have never touched expo. But I use a MacBook for work. I do hate Xcode tho. 
 most definitely if anything Angular 2 is the best evidence of that as it borrows heavily from many other frameworks as those frameworks did before. I tend to shift frameworks like subway cars I ride one for a certain distance until its either not going the direction I want anymore or its the end of the line then jump on the next train to keep moving forward. 
Never loaded for me on chrome, but ran fine in Firefox. I assume the floor will not accept a portal, since that's how it behaved. Pretty cool!
Surely you don't care but it was about:config dom.webcomponents.enabled = true that breaks it. 
The closure compiler relies, afaik, on comments. Comments get inserted into the javascript produced by tsc verbatim. So the closure comments would still be there.
Here is the console log. My chrome version is 58.0.3029.96 (64-bit) THREE.WebGLRenderer 86dev nunu.min.js:164 THREE.WebGLRenderer: Error creating WebGL context. nunu.min.js:164 nunu.min.js:129 Uncaught TypeError: Cannot read property 'getExtension' of null at Object.get (nunu.min.js:129) at new ce (nunu.min.js:165) at NunuApp.run (nunu.min.js:2084) at nunu.min.js:2082 at nunu.min.js:2083 at XMLHttpRequest.h.onload (nunu.min.js:1798) EDIT: I noticed I had a pending Chrome update, so now it's version 58.0.3029.110 but the error message is the same. Hope it helps UPDATE: Got it working. Had to enable hardware acceleration (settings -&gt; advanced -&gt; system)
Thanks a lot! :) What GPU do you have? Since it runs in firefox you might have a GPU that is blacklisted in chrome!
Hey /u/sunny_harris. I've been writing JavaScript tests using mocha, chai and sinon for the past few years and know quite a lot about it. Drop me a DM if you've got any questions. I've worked on 3 Node.js applications for a large media company here in the UK so I'm happy to answer any testing questions. Our apps have hundreds of requests per second so we ensure we write solid code by some pretty thorough unit and integration testing. I've been mentoring a few people on Twitter via Google Hangouts sessions so shout if you fancy pair programming one night and I'll help you to learn more and answer any questions. I've started a testing repo on GitHub where I'm expanding it out and writing articles on my site as I build out the tests to help people. Take a look at it here, especially the Express API tests where you can see how I mock the HTTP request and response objects: https://github.com/MarcL/js-unit-testing-examples I'm also in the process of writing a course called "JavaScript Testing Made Easy" and it'll include how to unit test production code like Express servers and Twitter/Facebook bots. I'll also be including how to mock external services if needed (e.g. database calls or 3rd party APIs). If you're interested then I'd love to get you on my mailing list so you can take a look at it when it's finished. http://www.marclittlemore.com/courses/javascript-testing-made-easy/ I've written a few articles on my website but I need to start writing more. You can also check out some of my answers on Quora where I've been trying to help people out. https://www.quora.com/profile/Marc-Littlemore Anyone else who reads this, feel free to DM me if you want some advice on advanced testing or just some beginner's getting started tips. I'm writing a PDF on this at the moment so I'll send it to you when it's done. Cheers!
Do not adopt Angular just for the router. Angular is very opinionated and will likely compel you to change other parts of your project. When I first started using routers I really struggled to find one with every feature built in that I wanted. Nesting, named and position based arguments, async, etc. With more experience though I've found that I prefer routers to do as little as possible. I want them to be unopinionated and stay out of my way. After reading this article [http://krasimirtsonev.com/blog/article/A-modern-JavaScript-router-in-100-lines-history-api-pushState-hash-url](http://krasimirtsonev.com/blog/article/A-modern-JavaScript-router-in-100-lines-history-api-pushState-hash-url) I started using just a few lines of my own code to handle routing rather than a specific library. It's really easy to do and you don't need all those other features. If you really want a library though I've also used Director in a few of my production sites for the last couple years with great success. 
Oh I see... My bad. Still, it's just a bunch of NPM packages anyway right? You could throw your own together, surely?
That's great! Works fine for me on chrome and firefox, though the console talks a lot.
A cool thing I always need when using localstorage is time expiration for the data.
Pixi.js (the renderer Phaser uses) does 2d webgl with a canvas fallback. The webgl version is capable of rendering ~200k sprites at 60 fps on my computer. If you don't need the extra performance it's probably not worth it, but it's definitely fast.
Typescript!=JavaScript 
So let me get this straight. You just want another static page that your client can upload photos to? Why not create an s3 bucket or some such hosting platform and have the static site pull from there? 
I know you said it doesn't run on mobile but I thought I'd let you know it was buttery smooth on the iPhone 7+. All I could do is look around and fire the portal gun which showed just a black circle. I knocked the cube around and it danced away very nicely. I was pleasantly surprised at how well it performed even though I couldn't do much.
**LESSONS LEARNED:** 1. Develop for iOS on a Mac. 
People have already given you advice on the code, I just wanted to add: this is exactly what Babel was made for. It takes Javascript written in a newer standard and transpiles (converts it) it to Javascript compatible with whatever older browsers you need. 
Babel sounds like what I need. I'm still relatively new to this though, so I have no idea how to use it. Sounds like it's something that needs to be set up. I'm reading through the docs now, trying to figure it out. 
Then pnpm isn't deduping dependencies in the same way, which means it's generating a third (fourth, if you count yarn) incompatible dependency tree. It's as simple as that.
Yeah I took note of that. But I verified that i'm testing on IE 11. As someone new to this, I really hate IE. In any case, I fixed the problem by changing some of my code to ES5, but created another problem in the process :/ I updated my OP. 
please, share your results here when ready :) I'm working on Gecko and would love to help filing bugs if there are any performance issues with modules.
Sorry, for some reason I misread.
Yeah the "naming" thing in the end especially in private code is often as useful like a refactor no one asked for. When one thinks too long about naming, he isnt solving the important problems and therefore not getting shit done. But for libraries its somewhat different. As an lib author its important to think about naming because it will change how your users use the product.
Ugh, I hate the this keyword so goddamn much. It creates so much confusion and so many bugs for zero gain. You can achieve the exact same result, while being much more simple and predictable without using "this" or "new". The worst part about React is that we have to use JavaScripts shitty object orientation..
How many modules are you loading? Lodash is loading tens of them, in parallel. It may be that I am overloading some pipeline in the code, overloading that does not occur in your use case. And I agree that it's absurd, but I could not find a fault with my code. Given that it's all on Github, you can replicate (or find fault) with my findings.
As I said above to somebody else that does not have my experience - how many modules are you loading? Lodash is loading tens of them, in parallel. It may be that I am overloading some pipeline in the code, overloading that does not occur in your use case.
Excellent, thank you! Please, CC me if possible in the bmo bug (autocomplete on `:gandalf`).
You can do a lot in react with stateless components, especially if you combine it with redux / react-redux
Thanks for all the work by the moderators, BTW! Not glamorous, yet it makes /r/javascript much more enjoyable.
It even partially works on mobile. Seems performant, just lack of controls. Great job
People have been urging me to create bug reports, so here they are: * Chromium: https://bugs.chromium.org/p/chromium/issues/detail?id=722728 * Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1365187
What's the idea here? Are you attempting to build a layer of abstraction so that people can switch analytics tools or use multiple at the same time easily? Are you just trying to make the current APIs for various vendors easier/safer/whatever?
Or If you use ES6 anonymous functions.
I taught myself promises by implementing the Promise class from scratch, maybe [my code](https://github.com/jsoendermann/LagouPromise/blob/master/LagouPromise.js) is useful to you.
Great tool!
Care to elaborate?
How does "this" need a whole video explaining it? I mean, pretty much everything you need to know is in the word "this".
See video
Dumb version of http://www.jazcash.com/a-javascript-journey-with-only-six-characters/ (October 2016)
Wow, that's a lot of work. Amazing stuff. Have you seen what the guys a WhiteStormJs have been up to? 
no, thankyou for your input. You're alluding to the fact the ember includes everything required from day one right? with CLI tools and so on
[removed]
Check these GM repositories. https://greasyfork.org/ https://openuserjs.org/ https://userscripts-mirror.org/ (archive for now-dead userscripts.org) 
Wow thanks so much for the reply. I will certainly check out your repo and the other links and get in touch when I have some questions. Really appreciate the gesture! 
No problem. DM me if you have any questions or want to arrange pairing on some test examples. ^ This applies to anyone else reading this too.
Hi, yeah that is whats happeing, thanks for reporting i will have to change it to support booth mouse and touch input at the same time. Thanks a lot, i will fix it soon!
Thanks :) 
Thanks! 
When I was new it made no sense. But yeah now that I understand it is pretty damn simple. I blame it on not being explained very well from the start. 
I understand how this works in c++, but I had no idea this was an option in JavaScript! Great video, extremely informative and gave me some new concepts to try coding with!
There was 0% ES6 used.
No worries glad I could help out. Looks great otherwise!
Hey /u/carlosgrodriguezl, I'm think you're looking for a way to automate your testing but not write any code right? If you're looking for something to hit the API with via a web interface then have you tried Postman? That's what I use for manual testing of APIs with Chrome: https://www.getpostman.com/ It allows you to create collections which are a useful way to group your API calls together into different groups. If you're looking for something more programatic to test your API, have you considered using Mocha, chai + supertest? You can use them to send requests to your API and set expectations on the results. You can then run these automatically as part of your local build or continuous build server. I've done lots of unit and integration testing with JavaScript so send me a DM if you need any help. 
&gt; Object doesn't support property or method 'find' That's a pretty straightforward error message, no? Assuming `cars` is an array, looks like IE doesn't support `Array.find`. http://stackoverflow.com/questions/37788536/the-find-method-is-supported-in-ie
It's correct until it's subtly not. Then it's pretty much impossible to understand the problem. I'll stick with `npm`, thanks.
Hi /u/dmitry-budko, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/live_alone, this post was removed because it doesn't appear to relate to javascript. Also, while I have you here, thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `medium.com/@rohitkhatana`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [medium.com](/search?q=%28and+site%3A%27medium.com%27+author%3A%27live_alone%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|8|100%
Super cool, I watched a couple presentations on PostGREST a few months ago and was really jazzed about it, but couldn't get the higher ups at the company I was working at then to even contemplate how it would be a good idea to move to a new architecture. Definitely starring this repo and playing with it when I get home tonight.
A nice and clean interface, but dropped you an issue courtesy of my own experiences with the fun that is Safari Private Browsing.
Cool! let me know if you hit any problems, it's early stage but an easier way to get started with PostgREST based backends.
Ignore IE? :-P What version of IE is it failing on?
Negative. Nothing is popping on the console.
IE 11. This is for a business website and needs to be cross-platform compatible. My first suggestion was to ignore IE too!
Yup, exactly.
What is the failure state?
1. Is the script being downloaded by IE? 2. Does the script use language features or browser features that are unavailable to IE?
1. No, I don't believe so. The script being referenced wasn't written by me, but by https://www.cisecurity.org/rss-syndication/ 2. I also don't know. I think the issue is in the script, but it's 4,000 lines and I can't find the creator posting it anywhere else.
Maybe the image is there but you can't see it. Try giving the container a real height maybe?
We use ag-grid. It kicks ass and the team is constantly improving it. Additionally, if you purchase an enterprise license (cheap), you get access to the developers, who are very responsive to feature requests. They've given us everything we've asked for so far.
If you use OO for anything other than export default class extends Component { You are doing React wrong. And don't ever let me catch you extending a component that's not Component. React is a functional library.
I gave the graphic a real size and it still failed to show.
is your nick Ten Tone or Tent One? (= I'd love to help you on this in . . . whatever way. My JS is kinda weak, but I have a design and game design background, so perhaps I could help with interface concerns or by doing demos. Either way, I'll prob have a bunch of questions about things. I don't know how much I can do. How long have you been working on it and approx how much per week? 
Thanks for looking into it, but no dice.
You can put the factory in a factory and give it a shared state object. 
See http://stackoverflow.com/questions/18808226/why-is-typeof-null-object - `null` is a primitive type and not an object
is that all it does? maybe I have poor coding practices (likely) but I don't know when 'this' throwing an error would be helpful when you're going to get an error regardless and find your mistake. Is it a concern that references to 'this' might work *by accident* and now you have a window obj floating around you're unaware of?
You always want to `use strict`, without exception. (pun not intended). Errors are a good thing. More errors are better. Errors let you know that something isn't right. Here's a simple example. Misspelled variables. Without `use strict`, a misspelled variable will just silently be given the value `undefined` and maybe you'll be lucky and notice the bug right away, but it's entirely possible it'll be something somewhat subtle that either only happens once in a while or only happens in very specific circumstances. If you had strict mode enabled, it would warn you immediately that you're using an undeclared variable. Really, the only argument against it is if you're doing something with legacy code and aren't allowed the time to fix it properly. And even in that case, whenever possible you should try and enable strict mode where you can (e.g. writing a new function? use strict. Updating a function? Use strict and fix any issues in that local scope).
A while back, I saw someone on reddit mention that understanding `this` is kind of a watershed moment in a JS dev's career. It's not a complicated concept by any stretch of the imagination, but for some reason it's really difficult for people to internalize until one day it suddenly clicks.
The WeakMap solution, yes. That's how it would have to go.
Soon to be another primitive - BigInt. You could also consider the various typed array types as primitive types even though they are converted to floats on access so you can't really observe them behaving like distinct primitives.
The page is giving an error 403 forbidden.
thanks. appreciate the insight. &gt;Strict mode changes previously accepted "bad syntax" into real errors. seems worth learning. 
Angular or angularjs? I don't have enough experience with angularjs so I can't say there but for angular and react it's basically impossible. They use different formats for, we'll, everything. It gets a lot of flak. And a lot of it is well deserved. But your best strategy at the moment might be polymer components. They are compatible with angular and I would assume react as well though I've never tried it.
Always. No exceptions.
&gt; I will never understand why people want to slow themselves down with videos. It's almost as if people learn differently in different ways. Videos and hands on training work best for me, reading books and articles not so much.
Why are people always so enamored by complexity? You could literally just pass the data being referenced by "this" into your function in order to achieve the same result: const sayName = ({name}, lang1, lang2, lang3) { console.log('My name is ' + name + ' and i know etc..'); } OR if you prefer an Object Oriented approach: const Person = ({name}) =&gt; { return { sayName: (lang1, lang2, lang3) { //no this required console.log('My name is ' + name + ' and i know etc..'); } } } let p = Person({name:'The Dude'}); p.sayName('english', 'french', 'spanish'); Now there's no longer any need to worry about "this" being bound to the global namespace. Everything is explicit and you could even add validation to the Person function. ---------- edit: You'll also notice that any data we pass into the Person function is encapsulated. ie: There is no way of changing a person's name without first exposing a changeName method via the returned object literal.
Yeah. I remember many years ago this confused me, nowadays I don't even need to think about what this points to at a given place. Experience goes a long way.
Ok man, it's a simple explanation. People will slow themselves down in order to gain a more solid understanding, because that way of learning suits them better. Time is a valuable asset, sure, but if I have to re-read the same article 2 or 3 times to really grasp a concept, then watching the video is probably a better use of your time. But I'm just piling on.
It's pretty trivial to wrap React components in Angular stuff, and mildly annoying but possible to make Angular stuff wrapped in React components. But unless your company is really heading one way or another (in which case a compat layer would be ideal. Its what I did at a company switching from Angular to React), you have a text book example for using web components.
Just added 2nd PR with latest version of slim.js 10K items generation (multiple clicks): 1st round: React 2.5sec Slim 3.5sec 2nd round to 5th: React ~2.5sec Slim ~0.8sec I'm not sure if multiple clicks on 10k is part of the benchmark but it's worth testing.
I created something like that for React native (https://github.com/tiaanduplessis/react-native-modest-cache) so adding an expiration time shouldn't be too difficult. Will start working on it as soon as I have time. Thanks for the suggestion :)
C3.js is a good library that is based off of D3. Really solid features and a good set of examples and docs.
On my phone so I can't test but could you try changing onClick to onclick on the button?
Just checked the commits. Looks nice. I understand what Apple were trying to get at with Private Browsing, but it frankly stinks when you have to work around a browser. Times haven't changed since Netscape days of old. :)
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [getify/You-Dont-Know-JS/.../**ch1.md** (master → 6109cfe)](https://github.com/getify/You-Dont-Know-JS/blob/6109cfe89e307a8a08e4906784cb7292f3fcb152/types%20%26%20grammar/ch1.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhncojk.)^.
It's working for me. https://codepen.io/dfrehner1/pen/LyBJKR I cleaned your code up a little, but didn't change any logic. I also separated your JS to it's own file. In the future, I would refrain from using '==' and instead rely on using '===' unless you are specifically going for type coercion. also I would change your if statements to look like '!(num1%2===0)' that way you aren't mixing types. 
Was overall good, I just thought the introduction with all the history of Schema and C++ was a bit off-topic. Presentation was good you just need a bit more confidence to make it flow better which comes with practice - keep it up!
The onClick button seems to be working fine-- the issue that keeps recurring is that I'll input two even numbers and sometimes it'll say "Both numbers are odd" or "One number is even and the other is odd" so I'm wondering if it's an issue with the equation?
&gt; https://codepen.io/dfrehner1/pen/LyBJKR Thank you! So this is actually an assignment for a course and since the instructor hasn't introduced "===" yet, I didn't use it (although he didn't introduce ==! yet either so...) So in your example of '!(num1%2===0)', putting the exclamation mark on the outside negates the whole sequence on the inside right? Like it'll parse it as number 1 divided by 2 doesn't equal 0? If so, is it possible to write the whole if condition as the following: !(num1%2===0 &amp;&amp; num2%2===0) Thank you so much for your help!
&gt; One thing as of May 2017 engineers are still wait on is for fetch to be able to cancel request. It is supposed to be added in the future. I wouldn't count on that coming any time soon. The cancelable promises proposal that feature was waiting for was dropped.
That still doesn't make sense, if you are watching a video and get distracted you are going to need to re-watch it. Again the same content will be much longer even if you need to re-read a portion of a book or article several times, it will still be quicker than watching a video. In the case of videos talking about programming, which is the context here, it makes even less sense, since you need to READ the content (examples and such) in the video. In my original post I cited watching videos for things like Blender and even in that case posts and articles which take the time to do screenshots and write explanations are much quicker. Finally you've given no evidence that you will actually retain more information or understand quicker when watching a video. Until you've proven that anything that follows is kind of pointless.
You do you, keep on trucking!
Enums are not the solution here. That would just reduce the need for strings in action creators. But action creators + action constants are constructs that together replace type structure of the kind you see in Elm. String enums are just a way to make the work around less verbose. Just being able to create types that you can pattern match on (even if it's not static typing) would actually add value (reducing bugs, etc), not just how many times I have to smack the keyboard (which is overrated anyway)
&gt; A [quine](http://en.wikipedia.org/wiki/Quine_%28computing%29) is a computer program which takes no input and produces a copy of its own source code as its only output. For example: function $() { console.log(String($)) } 
This looks like it's merely an alternate syntax for function calling. It'd be promoted *only* on a practice used in React. It may be convenient for people familiar with those paradigms, but it sounds exceptionally ill-conceived as a general standard.
This (hah) is a not-insignificant reason why functional programming has become so popular in Javascript these days. If your functions are pure, you don't have to worry about 'this'.
That's the thing – it's not a practice that could be applied to only React. Anyone could create helper functions that create raw DOM nodes or anything else (especially for NodeJS). Furthermore, it could allow developers the chance to pass properties with deeply nested objects to web components without needing to conform to HTML legibility to do so without a build step.
Hi /u/cookieman91, please include code -- preferably a reproduction on jsfiddle.net. Reply to this comment when you have done so, and I'll unfilter your post. Thanks!
&gt; It'd be promoted only on a practice used in React. I don't care that it *could* be applied more generally. I care that literally no one else feels that it should be applied. React is solving a very specific problem. JSX is a language bridge to connect JS and HTML. There's no reason this syntax should be adopted outside of this specific use case. The strong binding between JS and HTML is an unfortunate (in my opinion) byproduct of the history of each. If JS is going to continue to grow and improve, the community should either embrace the notion of middleware bindings (and let JS be its own thing) or move towards other UI bindings (and let JS be its own thing). I understand RSX and accept it. However, I don't understand why it should be accepted broadly. If and when you can explain *why* this syntax would be necessary or useful in a general context for JS, I'd be willing to listen and reconsider.
And what they're saying is that you aren't accounting for the hidden weights inside some people's neural nets that make it so that reading isn't better. For instance, if it takes five minutes to read, and ten minutes to watch, read is clearly faster. *But* what if their principle method of learning is visual, and reading requires multiple passes to actually fully get? Watching still takes ten minutes, and reading takes five *times* the number of passes. You see?
&gt; Other than learning how to get D3 to interact with React properly Can you give any pointers? I have some charts that work with d3 but they all seem like a hack and hard to test :(
Honestly that seems insane at this point. If the application warrants a framework / library discussion then "vanilla JavaScript" just screams"unmaintainable and hard to hire for" for me I could however be totally wrong! I just smoke that react crack rock hard these days
This doesn't really state anything meaningful. How do you know if a project "requires a ton of DOM patching"?
I just want to point out that balking at the dependencies for a JavaScript project is strange considering that stuff is basically acting as a compiler, and compilers tend to be big. Luckily, that file size doesn't matter, at all. It's not going to the client. If you compare other languages, their compilers are often much larger than a typical node_modules directory.
Oh, no worries! You didn't come off sounding that way at all. I wasn't trying to imply that you might not be either. Simply stating a list of things that I personally find essential for creating a large, maintainable vanilla application. It is a bit ridiculous. Honestly, as an angular developer who has since jumped ship, the current state of angular leaves me hurting a little. That being said, I haven't looked too much at angular 4, so this might be completely misplaced 
Was planning on commenting exactly this. 
I was paranoid about making my code minimal and clean, and doing everything myself, so I decided to use vanilla JavaScript for a few projects. A couple of months later, I realized how much of an idiot I was for doing that. It's just a waste of time. It took me so much longer to do everything and I was limited on what I could do, and I had only saved like 50KB. Not worth it. 
The ecosystem is super volatile and you should absolutely protect yourself by saving local copies of your dependencies somewhere for use in case someone pulls something you need off npm. That said, the frameworks are awesome once you've got them working together. They are built on a super rickety frame but I couldn't imagine not using one over vanilla javascript. That said, there are some small places you can switch to vanilla, such as ES6's promises. I've found they're all I need to write promisified apps.
you can do that to save a bit of typing, but if you do named exports, you can always import * as foo from './constants' to get an object with all of your constants (and good editors will autocomplete that even without static typing, which is nice). And in the event you have a lot of constants in one file (probably not a good idea to have too many, but let say you did), you could import them individually and easily find unused ones for scrapping.
The content of many videos, especially those about programming, still require you to read the code or slides, they simply have an additional auditory aspect, so if anything auditory learners would get a boost from videos. You state that it may take multiple passes to understand some content, this is correct, however you don't need to re-read the entire chapter, only the parts that are important. While you can do something similar with videos I find you need to include a small buffer so you do not miss the start of the content you want, occasionally, if I have skipped around I just restart the entire video. So far this is just a direct comparison of a video which is of the same content as say a book. When you factor in that a narrator must pace themselves, may add additional verbiage that is not needed and that a video may be poorly edited, there are vast amounts of time that are simply not needed or have no value beyond entertainment. IMO reading is at WORST log(n) and video is at BEST log(n). Some additional points: * You can get better at reading, the more you read the faster you will get at it. You can go the speed reading route but through my research and experiments you will retain much less. In any event the video is the video, and that's how fast it goes. *Actually you can speed up videos but from my own experience with audio books your retention goes down dramatically, even more than speed reading* * Textual content can be put in formats more easily digestible to visual learners. Who doesn't love a **table** or a nice **list** of content. Mix in some graphs or diagrams and you got yourself a stew. * Videos, Audio books when combined WITH reading make comprehension and retention even higher. I do this all the time. I read along and listen to a book. In this way you can speed up an audiobook but not lose retention, up to about 2.5x. * Text content is easier to update. * Text content is searchable I personally don't see what the big deal is about reading a book or an article especially since programming involves constant reading. 
Thank you for filing the issues! I'll follow along there. I'm very curious as to how that's possible.
The text within the first `if` statement will never be visible as the execution of the second `if/else` block will override it. You need an `if/else if/else` block, what you have is two separate blocks; an `if` block and an `if/else` block.
Oh well. I believe eventually these people will come to the same conclusion as me, especially since I have tried all this stuff before.
So then I have to rewrite that without using Array.find which IE doesn't support. How do I go about doing that? What else can I use?
Done
Thanks! Btw, the HTML should go in the `HTML` box, at which point you can hit 'tidy': https://jsfiddle.net/75kecu5m/2/
Can we pretend I didn't do that? Thanks for being nice.
So I'm not seeing where you have any JS, all the script tags are either empty or malformed: &lt;script&gt;&lt; /script&lt;/td &gt;
Exactly! All the examples I've seen were "toy" examples. But modern web apps (and node apps) transitively use tens and hundreds of dependencies, so I was curious to see how it would behave in "real world" situation. Once this issue gets resolved in the various browsers, it will be time to see how we can figure out how to deal with the networking issue. The usual solution is HTTP/2 Push, but I'm very curious on whether this is a satisfactory solution.
So if I had more than just the single line of return Promise.resolve(data); or return Promise.reject(err); within the then or catch, respectively, before passing the promise back up, then it would make sense to use those calls? Otherwise, as just those single lines, they don't add any value?
And certainly wouldn't eat up as much RAM. What's with everyone using Electron? Every Electron app I have eats way more RAM than it needs, is much slower than native code and usually comes with a ton of weird bugs
It's sad to see a big company replace a highly performant native app with a glorified embedded browser.
Is there any way to go about fixing that? Because the html in the link is just a copy of what the source website has.
so i see you use ecmascript 6 in many place (const, let, lambda), so why not use string literal template and maybe classes? It's make it more simple i think, more readable, and easier to develop. https://codepen.io/anon/pen/BRPbEL 
Functions are slightly different than objects in that you cannot call an object. And type of. 
Full disclosure. I'm the author. In the past, I've come across C++ folks wanting to learn JavaScript, or JavaScript folks wanting to learn what their language is doing behind the scenes. Here and there, I had written [brief "rosetta stone" replies](https://www.reddit.com/r/learnjavascript/comments/4zh1lp/where_should_i_start_learning_javascript_if_i/d6vs9t2/). This write-up is the same idea but covers more ground.
I don't think it should. The web should be as low level as possible. JSX and functions overall are in a fantastic position now to render UI to targets, and the web is just one of them. By tying it too strictly to the web it would bring dependence (to vendors/committees) again. What makes JSX so great is that it is completely free and exchangeable, considering that it is actually possible to bring the same components to different frameworks and even platforms.
I don't think you would ever want to "accidentally" do anything...
Read JavaScript the good parts or watch some of crockfords talks on it.
if you work for massive company, you might be better of thinking in scale of departments or project groups instead of whole company. Otherwise, its basically quest for the holy grail type of task
I would go with a map from what you are looking for to what you want in the end. let months = {jan: "January", feb: "February", mar: "March", apr: "April", .....}; And then do something like this: let month = Object.keys(months).find(m =&gt; dateGiven.toLowerCase().includes(m)); if(month) dateFormatted[1] = month; else /* more code */
+1 for maps, but then I'd do: var given = dateGiven.toLowerCase(); dateFormatted[1] = months[given] ? months[given] : 'Something else';
Yeah. But this is only if you want to assign something to dateFormatted[1] in both positive and negative cases. I tried to have the same functionality as the code presented, and since I didn't know what "// more code" is I wrote it like that.
is it working fine?
You don't have to return Promise.resolve() or Promise.reject(), because your promise is already resolved/rejected. You can work with your data/error in your original then/catch block, whre you originally returned Promise.resolve/reject.
Really? GitHub desktop is hardly super fast as it is. Now it's going to be even slower?
Would be nice, even if it simply creates dom nodes via createElement it could still be prototype-hooked. But then again, i think this whole thing has brought an end to the standardization cycle that has vendors scrambling for a decade to match a feature across browsers. It is probably for the best if JSX is free from that.
It makes sense to me though, I imagine most developers either use the command line or git tools integrated with their IDE/Editor. I only ever used their native app once before realizing that if I wanted a gui interface to do basic work I'd be better off with my editor. If I wanted to do complex work I'd use the command line. Github desktop app always felt more like an extra selling point than anything actually usefull to me. This way they don't have to maintain multiple code bases.
Another question is: how it got it's 3k stars on github? I did not often see it in trending, also according to benchmarks by /u/leeoniya it's rather slow framework. Is this social experiment to show that any library can get that much stars? Not trying to offend or something, but interested. Also interested in not answering questions here, because it seems that in this thread's case - /r/javascript was used as marketing platform.
&gt; (pun not intended) http://www.thebestpageintheuniverse.net/c.cgi?u=puns :*
Cool idea! Now to write a small program in C++ that equates to a JS equivalent, then run it in the browser via WebAssembly! lol.
Yeah for sure! That's part 2
I just structure my tests by the type of testing that needs to be done. DOM tests go in one bucket, file system tests in a different categorty, core utility tests independent of API in their own section, and so on. If those big categories of tests can be further broken down and you have bazillion tests then so be it.
So, redux?
stars in JS dev are almost entirely about marketing. projects with a nice website, cute names, lots of flashy examples and nicely formatted docs have a lot of stars. until recently, every framework author made his/her own benchmarks to show off how "fast" it was relative to someone else. initially it looked like Glimmer's dbmonster example was a good measure, but that was also a very narrow benchmark that only tested `.className` and `.nodeValue` dom mutations, making it overly simplistic and not representative of real-world perf. there was also /u/localvoid's more thorough`vdom-benchmark` and `uibench` which the general public never heard about because - as before - lack of marketing. at least now we've somewhat normalized the playing field so you don't have to believe anyone's bullshit speed claims. i've been helping out with this bench, including getting it some additional exposure that utility projects like this need.
I don't see anything indicating that the sorted_high_score array has been given a default value. Which invalidates the loop as you have incorrectly assumed the length of your array. Give it a default value or restructure it a bit and see if that helps. 
won't your other tests use the constant instead of the value? (DRY) This will mean that the value isn't used directly so there is no test which will cover the value change
[uhh](http://vignette1.wikia.nocookie.net/glee/images/4/47/Sweats_nervously.png/revision/latest?cb=20150113163917)
Won't your other code use the constant instead of the value?
You are correct, that was the problem all along. I did that out of habit and inadvertently 'fixed' it. 
Note that the point of a constant means the value doesn't actually matter – if all your code references that constant, it will all agree on the value it cares about. For that reason I don't test this. A good test, however, is to make sure you reference this constant (either through an action creator or directly) when you're testing your reducers. 
Makes sense. Thank you 
If you have a constant then presumably you're using it. There are two cases I can see where changing its value would cause a problem: when there are places in your code that aren't using the constant and when you change the value so that it matches some other conflicting constant. If you're using the constant in your tests and change its value then the places in your code where you're using just the value presumably won't behave the same. Tests will then fail. If you change the value do that it conflicts with some other constant then, again, code will behave differently and tests will fail.
A bit of looking around, and it seems as though Woocommerce uses OAuth 1.0 one-legged configuration. You would not want to do this using client-side code only, as it would expose your credentials to pretty much anybody. Instead, if that was your hope, you should be using server-side code to bridge between your client-side jQuery and the Woocommerce REST server.
DAAAAAAAAAAMN.. sorry you.. I just can't believe what i'm reading and what's happening... ;/ hashtag #WATTHAFAK
why would you NOT minify/gzip, if it saves every client initial download time? to your last point, no - cached assets are not the whole point of a SPA. 
First of all /u/Neaoxas was absolutely right, I changed the logic and made both if statements, one if/else block, that is why it is working for me. Second, I didn't mean to get ahead of your instructor's lessons. If they are having you use '==' by all means continue following their lesson. Also note that '==!' isn't a 'thing' its just something that worked for you, you want to use '!=='. Javascript can be very loose in what it allows you to do, so sometimes things 'work' for the wrong reasons. No that example you gave would not work. Because you are using &amp;&amp; you want to evaluate each statement separately. One of them being false will make the entire statement return false, and we're checking to see if BOTH of them were false. The &amp;&amp; and || evaluators can get really tricky, and it will take a lot of practice to use them correctly and effectively. I'm fairly certain you haven't learned about type coercion yet, but one last advanced topic to keep in mind for the future. The only thing the ! does is give an opposite Boolean(always a Boolean, no matter the type coming in) value for whatever it is evaluating. In your original example: number1%2==!0 the !0 is not evaluated to "not zero" it is evaluated to "true" as the opposite boolean of 0. So essentially you are asking number1%2==true which will not act the way you expect. 
Checkout Timeline/Profiles/Audit tab in Chrome Dev Tools and read about them and try to use them. You can't discuss performance without context. There are several factors in enhancing an application's performance. You can almost always minify images and scripts to reduce the download time but not in every case. Sometimes your application relies on high quality content. Sometimes your application has a lot of function calls which in most cases can be optimized. A lot of basic codes can be optimized as well. Using for instead of while, or map instead of for may not cause such difference in an application with no lists. But it definitely shows when you have a lot of data to be rendered in different places. In general dev tools profiling tools can always help. They show you what function took longer to run and you can decide if it can be optimized. Sometimes the dev tools even shows you if it's not already optimized but you can't rely on that. Lookout for memory leaks. Check the memory allocation and see if something is out of place. For me it almost always is, lol! Read about JS compiling and runtime process too. A lot of great points you can find out there.
I do agree with you about caching
minifying is not about payload size (gzip mostly takes care of this). minifying is about parsing performance [1]. SPAs are not mostly about caching, they are *mostly* about maintaining smooth UI state and not flashing/resetting scroll while changing state/pages within an app. the idea is to mimic native app behavior. [1] https://medium.com/reloading/javascript-start-up-performance-69200f43b201
so OP subbed to a BaaS/DBaaS and is complaining when the company behind the service decided to change how they calculate costs? Its a bit of a dick move on firebase side but still well within their legal rights to do so. Firebase &amp; other DBaaS/BaaS should be used to get off the ground quickly and probably shouldn't be used as the cornerstone of your app imo because shit like this will happen sooner or later. To not totally harp on OP, it would be nice to set thresholds in these types of services to say I want to be on "pay as you go" but i want to set a max budget of $x/mo and either shutdown my services or at least alert me when i hit that threshold. 
Is it still important to only have 1 css file and 1 js file if you're loading with http2?
not *as* important, but it does still make a difference. and it's very easy to do as part of even the most basic build pipeline.
I'm experiencing a situation where my company picked AngularJS for a site that should be mostly static pages. They're considering a rewrite. For a long time I was pushing for react just because I like it, but I decided to leave and I recommended they just switch to static pages. I'd be curious to hear the opinion of others though. The site is https://roomiapp.com
&gt;Script size is important, but it isn’t everything. Parse and Compile times don’t necessarily increase linearly when the script size increases. this text is actually highlighted on that page... 
Welp there goes another memory-efficient native app that I used to enjoy using. To be fair, I'm sympathetic to the cost-benefit of using electron. However, as a user, I am not sympathetic to the hundreds of MB of RAM all my electron apps are using up and their tendency to treat my battery in very unpredictable ways compared to native apps. I can only have a few open at a time. They are better than Java Swing ever was, but my god can't they share their browser instead of bundling a custom browser with every. single. app? Efficiency is so important in a world where we need to reduce carbon emissions, but instead we keep using computing power to allow us to be lazier and lazier. I want to be able to be lazy *and* use computing resources efficiently.
That is one potential benefit of a SPA, but certainly not The Whole Point. And cached assets are certainly not unique to a SPA, as others have noted. &gt; it's practically zero Reducing payload size absolutely has a clear and measurable impact on performance.
operative words: necessarily &amp; linearly they *do* increase in a vast majority of the cases. perhaps not linearly. why risk it when the extra insurance is so cheap/easy?
If your business depends on their product you can usually haggle with these companies. 
thanks for sharing, that sounds like a huge headache
I think there is a line where testing something is pointless, and this is way over it.
&gt; everyone in this thread is ignoring the fact that OP has specifically asked about single page applications. actually the OP asked about improving frontend performance in general. my interpretation was that "SPA's etc." was simply an example of "improving performance".
*If you don't understand TLS They (and probably a lot of other companies) were costing Firebase a lot of overhead, so Firebase included this overhead in the bill. Fix your shit and the bill will go back down to $25. The only thing I'm surprised with is that they didn't send out a notice first, so that companies could fix the problem before the bill arrived.
Interesting statistic: Not a single startup in Paris at the moment runs a .NET stack.
There is a much more thorough discussion of this post on r/programming for those interested (not that I'm trying to prevent anything from happening here - you do you). 
fetch() is almost here for ajax and stuff so no need to learn axios. 
Thank you for the advice. I only posted here after I did what you described. I did a lot of googling and looked at stack overflow. 
`my.weird.Promise.prototype.catch = my.weird.Promise.prototype.thenCatch;`
(I'm not the author, just shared because I found the "lazymorphic" approach very interesting) Isomorphic-webpack seems to be a really cool project! That said, I want to play with a "pure-client" JS Web App, without having a dynamic server - only a static one (that just serves static files). Can Isomorphic-webpack pre-render everything to static files? 
PSPDFKit requires a commercial license but is a great PDF viewer that's improving rapidly: https://pspdfkit.com/web/ *Disclaimer: I work on this product*
If you send your requests to a server that makes the request to the API, you can just change there. Makes a lot of sense, but has it's own costs. The thing is: should you even bother using such a service for your product? When I first heard about firebase, the first things that came to my mind were: that's not open source, I can't be sure they won't data mine it to bits, I'm not using it. Should I be less paranoid? Probably, but sometimes it can save your butt.
Basically never useful. It might be if you want to add properties to a number, but then you'd be better off making just a regular object with a key that is the number. Example: let x = new Number(123); x.y = 1; print(x.y); // 1 let x1 = 123; x1.y = 1; // no error, number is auto-boxed, property is added, and then the object is thrown away. print(x1.y); // undefined But if you want the former behavior, you'd be better off doing: let thing = { num: 123 }; thing.y = 1; 
I'm not sure that fixes their situation still, though. They were complaining that they can't get anything out quickly. That would mean the code needs to already exist so that it's just a configuration change. Even then, there has to be a data migration or people will still be pissed. In the end, the easiest solution is still to fix how their app connects to the servers, instead of trying to connect to a different kind of server. With the kind of foresight they're claiming they should have had, they could have just implemented this solution correctly the first time and spent much less time and effort.
I am kind of confused. Why do you need it to be `.then(...).thenCatch` and not just `.then(...).catch`? 
interesting, so it basically copies your files to the the correct location based on the route?
`if (x === x)` Wait? Why does this break with `NaN`?!? I thought testing obvious stuff is pointless.
Showing the source around that error is necessary for anyone to understand what the issue might be.
They could just use Qt.
 C:\Users\PPS\Documents\Programiranje\reactJS\examples\ReacJslearning\table.js:2 rows.map(function(row)=&gt; ^^ SyntaxError: Unexpected token =&gt; at createScript (vm.js:56:10) at Object.runInThisContext (vm.js:97:10) at Module._compile (module.js:542:28) at Object.Module._extensions..js (module.js:579:10) at Module.load (module.js:487:32) at tryModuleLoad (module.js:446:12) at Function.Module._load (module.js:438:3) at Module.runMain (module.js:604:10) at run (bootstrap_node.js:390:7) at startup (bootstrap_node.js:150:9) [Finished in 0.5s]
It uses a trick: any unmatched page (like asking for site.com/doesnotexist) will redirect to a 200.html file. That 200.html page loads a JavaScript that uses the current route (address) to decide what to load. Is a "Single Page Application turned into a Static page". 
Thank you. I forgot.
Super cool!!
Redux uses a similar principle (store the change, not the state), but otherwise this has nothing to do with Redux. Might be cool to see a project relating Redux to databases though. 
Why not just draw on canvas? 
I find this... Strange. I work on a MacBook, but I also have (and regularly use) Ubuntu and Kali Linux on my machine. Same goes with most engineers on my team.
&gt; Can Isomorphic-webpack pre-render everything to static files? In theory, yes, you could use it for that. In practice, you'd allow isomorphic-webpack to do this on-demand.
This is a tough problem because objects use methods in different ways, and methods can be defined in different ways which can in turn influence their behavior. Prototyped methods, for example, are shared among instances. Many instances, one method. If you're deep cloning an object, would you then want to still continue to share that method? Or have a completely new version of that method defined? Deep cloning the method would mean a derivation from the design of the original object, and all though it would be a clone, it may not behave the same way if, for example, that original method were to change (affecting the original object but not the cloned). var meth = { logName: function () { console.log(this.name) } }; var orig = Object.create(meth); orig.name = 'foo'; var cloned = { name: orig.name, logName: eval(orig.logName) }; orig.logName(); // foo cloned.logName(); // foo // change shared definition meth.logName = function () { console.log(this.name.toUpperCase()) }; orig.logName(); // FOO cloned.logName(); // foo Arrow functions and closures also pose a problem because they reference contexts or variables based on where the function is defined. You can attempt to clone these functions, but chances are you'll be cloning them in a scope where those values would be different or not exist at all. And if you copy them, they'll reference the values in the original object rather than those unique to the clone. function Orig() { var name = 'foo'; this.logName = function() { console.log(name); } this.setName = function(value) { name = value; } } var orig = new Orig(); var cloned = { logName: orig.logName, setName: orig.setName }; orig.logName(); // foo cloned.logName(); // foo cloned.setName('bar'); orig.logName(); // bar cloned.logName(); // bar So you, as a developer, generally need to decide and make the call on how you want your cloning to happen. And if not working with generic objects, the way cloning is implemented should be specific to the object getting cloned (i.e. having a clone() method for your clonable object making these calls and implementing as necessary).
They could have done a lot of things. 
What happened with Parse?
They shut down.
are you using template strings? compiled octal literals may be causing an issue with `strict mode` on
Put all this logic in a function, and for organization you are likely wanting to create child functions. This way it will execute when you call the function, where right now it executes immediately as soon as the code is parsed. Your function can take arguments, such as your operator and numbers.
You can access the src property on the image directly. Grab the Img tag in js, and then store Img.src in a variable. Then, whatever function you are using to actually upload the image I would just call with the image src if you can. 
Make sure the way that Babel polyfills the Es6 functions you are using is supported in ie11 
I'd set an item in localStorage after the code runs and have your function check if that item exists in localStorage before it executes, opting not to execute if the value exists. 
Right OK I'll try that!
If you're running the script on your local machine it may be a security issue &gt; Check out http://msdn.microsoft.com/en-us/library/ms537628(v=vs.85).aspx &gt; If you want to run in the Internet zone add this to your HTML source: &gt; &lt;!-- saved from url=(0014)about:internet --&gt; &gt; If you want to run in the Intranet zone add this to your HTML source: &gt; &lt;!-- saved from url=(0016)http://localhost --&gt; [Source](http://stackoverflow.com/questions/8146926/why-does-ie-restrict-the-javascript-files-of-local-html-pages)
Google is one of the harder companies to haggle with.
Isn't it open source now? 
I just did a quick and dirty test of 2d webgl vs canvas using PIXI.js [here](https://www.reddit.com/r/javascript/comments/6bar7k/created_a_desktop_2dcanvas_game_with_pure_js_is/dhm1c57/), and webgl appears to be anywhere from 20-50 times faster than canvas for simple sprite rendering.
The made it a library as a middle man. It's still a good middle man. But everyone loved the free database. Easy to format, way more stuff for free compared to firebase
So, is it officially bad practice to use semicolons now?
You would be testing the method that contains this for expected results. I would not consider that "obvious stuff".
Yeeeah, them responding to an issue of a blogger that exposed them to media after ignoring him totally means they're cool again. Let me build all my apps on their platform now! HAIL CORPORATE!
and a better title
I also liked her talk at NodeConf on super-in-depth [performance profiling for v8](https://www.youtube.com/watch?v=LX7PzH1Cn4s) (get ready for assembly).
IMHO, I'm against any vendor lock-in. AWS is fine if you're not using anything of theirs that locks you in. Yes that makes it more difficult, but it frees you to switch platforms overnight or use multiple cloud platforms at the same time for redundancy. 
I'm with you 100%. In their defense, they're pretty embarrassed about their lack of support in general. I wouldn't be surprised if this makes things better, but I also wouldn't be surprised if nothing changes. 
I think Netflix might be paying more than 200k a month
True, it's still on their server. But I'm usually a lot more confident around open source software, even if I'm paying for a service
That's the problem though. You can't give out infinite server for every product and half idea out there. There's electricity and space costs. Plus like you said ---&gt; way more stuff for free&lt;--- without a plan to monetize and be... more sustainable in meeting their own cost even at the worst case scenario. Facebook shut it down but they gave it away to the community to develop further. Facebook has had mishaps but in terms of parse it could have been a lot worse. 
Never inform your credit card to Google or Facebook. Pay special attention to their APIs usage, they collect your credit card in exchange for "free quota increase" then you are actually authorizing them to bill you on other APIs.
Couple things. They only gave away the middle man code for the community. Which is just basically added to a huge pool of similar services. what made parse great was the storage. it was intuitive, easy, and had realistic pricing. hell it would have been worth it to give money to parse for services if an app got popular. whereas shit like firebase. you can only send like 5 messages a second and to scale is a huge increase in price. and the portal is so fuckin stupid and confusing. if there was a company that could have ran parse, it would have been facebook. them running parse would be no skin off their noise. this is the company that wants to provide wireless internet via solar power plane to third world countries.
When Apple did a similar animation they had one very tall JPEG with lots of frames of animation and they scrolled through that (so they didn't use an MP4 like you might expect). How does this work? Are those `.pack` files just bits of jpegs or something?
Hm... I can't seem to get this method to work with `CommonChunkPlugin` using the async option.... It always includes the common async pieces in the split points. Not sure if OP is author or not... either way, I added a ticket to the linked github repo.
How is this different than Windows programming or iOS programming? I haven't done GUI programming in a LONG time, but I recall that state management was a tricky problem then too. Is it just that our standards are higher now, and machines are faster so we can create new DOM trees on every user interaction? (even if we don't render those DOMs) 
.. I mean, yeah, if writing boilerplate is just what you do and nobody can stop you. If you'd rather write no boilerplate, that's fine too - `document.queryselectorAll(".foo[name=bar]")`.
It's actually not too bad for production service. But you're right this is meant to be for prototyping..
Facebook bought it and killed it.
http://motherfuckingwebsite.com/
I don't like Firebase, but I also don't like Medium articles and random rants. So I saved you a click :) 
Valid cases. Now that you are saying it, none of them apply for my case. So, maybe yeah, those kind of tests are pretty useless. If a massive refactor would take place and your code would be mixed with values and constants, maybe then it would make sense. However it's not hard to do a search and replace all. So yeah, case pretty much closed. Thank you for the replies.
Four spaces to format the post as code.... Arrow function isn't just syntactic sugar -- it changes the `this` binding to be from the parent context. You reference `this` in the function, but it is not bound to `Grid.prototype` because of the arrow. i.e., it's sort of like writing Grid.prototype.whatever = (function () {}).bind(this) in this case, `this` isn't the grid instance, it is `window` or `global` or whatever else, depends on the context the code finds itself in. The error you are getting `TypeError: Cannot read property 'NaN' of undefined` is basically saying there isn't a `spaces` property on `this`. Also it's NaN because `width` and `x` and `y` are all undefined - multiply undefined by undefined, you'll get NaN.
Technically, at least in the case of react, it does not create an entirely new DOM tree for every change. Instead, it selectively modifies the DOM only as needed due to the diffing process.
The DOM is really slow. This is the part that actually make 'javascript' slow by human standards. The shadowdom allows you to keep a copy of the dom to manipulate and then only render the difference between the two in batches at a given time instead of completely rerendering the dom on every change. As I understand it.
Nothing really if you are careful, detail-oriented, and diligent. But, most programmers aren't, so it's better to use a library or framework to protect you from yourself. 
- http://bettermotherfuckingwebsite.com - http://evenbettermotherfucking.website
I think this was quite funny, but true: https://twitter.com/AdamRackis/status/844289020372901888 Views influencing and depending on other views, dumping and reading state in dom nodes, attributes and classes. It gets even worse if you have to orchestrate, if animations need to be awaited, async stuff, etc. State being scattered is one evil, but creating complex user interfaces with a soup of divs, that is *without components*, is kind of *wild* if you think of it. With the above mentioned viewlayers your UI goes out of the way. UI is a function of state now, a simple dress that reflects it. Logic is separated and can be orchestrated in its own domain. That also makes it re-usable, portable and easy to swap out visuals or components. 
Its usually referred to as a "Virtual DOM". Shadow DOM is for having encapsulated areas of the actual DOM, usually helpful for libs/plugins
I hate to bring this bad news, but the "evenworse..." name might be more appropriate for the second one.
Ah yes. I guess I had been conflating the two. Thanks for the clarification. :)
Frankly -- throw out the GitHub desktop UI,and hire a UI designer. Platform is not the problem. The ui for this app is about as clear as Blender. 
Qt would actually be a far better choice. The web is built to display documents not user interface stuff. And I'm a career web dev .. 
When you're targetting developers many of those concerns go away. If you're not using a beast of a machine to develop... Why ?
&gt; The DOM is really slow. It isn't. It's pretty fast if you know what are you doing and you are willing to use rather unpleasant API... And main point of _virtual DOM_ is that you don't have to know what are you doing, because framework will take care of this - DOM is fast but POJOs and primite types used by frameworks are faster. 
It's easier for me to keep up what I am doing when I use arrow function
Since you are such a careful and diligent programmer, please show me your big application written entirely with jquery and plain js. Let the other non-careful programmers be the judge whether it's a worthy app.
no problem :D
I agree. The point of StandardJS is don't spend time on choosing rules, just pick ones and apply them. If you want to use StandardJS but still use semicolons, there is another standard called Semi-standard ;) https://github.com/Flet/semistandard
bad example sorry.
Obviously, but that's because you missed its message: You can *even* get all the hipster bullshit without making your website bloated and slow.
This attribute (`innerHTML`) is very basic and works in Chrome like it does in FF. It would be interesting to know a bit more about the context of this code. When is this specific element created/appended and when filled with more content and finally when runs your code? I'd guess, that this is a timing issue. **Edit** Regarding your edit: see also [here](http://stackoverflow.com/a/27545633/2092322).
The same thing that's wrong with global variables and spaghetti code with no modularisation or isolation - it's not a problem in small, simple cases, but as your system complexity grows it rapidly becomes untenable because every part of the system can affect every other part, and you can't abstract away any part of it into a simple interface that lets you reason about it abstractly without getting mired in the details.
&gt; careful, detail-oriented, and diligent The business term for that is "expensive".
I'm working on a side project at home and intentionally not using react. I feel like I need to understand a bit about how to roll my own before going to a library specifically for that. 
It's not wrong and it can be the superior choice if you want to build something quickly with little overhead. As many people mentioned though, using such a framework yields a lot of benefits as your project starts to grow, those frameworks will do the DOM manipulation for you but in a much more optimal way, they will also influence your application design pattern positively. Your states will be managed entirely by Javascript, such frameworks also encourage you to build components which can be easily reused in different projects later on. In the end the framework value is what you make out of it, if you put time &amp; effort into learning the framework only then you'll truly appreciate the benefits it provides, you'll also find yourself able to bootstrap applications much quicker.
where it gets confusing to me though, is that you also have to keep state in a database (usually). So now you need a way to sync the database "state" with your view "state". There is no diffing algorhythm for that. So essentially, all of the comments here talked about various "states" your app can be in and tracking them, but in reality most programs are made up of add/modify/delete a thing. thats really all of the states we need for the most part, usually. and if we are going to save a thing to the database by directly modifying it, why is it so hard to directly modify that thing's dom as well? 
There's no getting around having a centralized store to persist state (database) but if there are solutions to syncing state from your client model to your view then its one less thing to worry about unnecessarily. If your app is extremely simple, then you're right, may not be worth pulling in React or Vue.
Thinkabout it this way; with React, you update the STATE of your app only and the rules you've programmed into your components will adhere to that state accordingly. Example: You want your navigation to open out and when that happens you also want everything else to fade back and perhaps for other actions to occur too. In a manual vanilla world, you'd you have to find these elements in the DOM and add / remove classes. With more functionality down the road, this can get hairier and hairier. You will have to know exactly where each moving part is. In React, you might just update your STATE object. i.e. { navOpen: true }. Providing everything in your components knows what to show and hide when this state property is set, it will all move automatically in REACTion to this state change. Hence the name React I guess. Vue and Angular all work off this principle too. State becomes the rule of truth, which it should be. 
I wish I could upvote your answer twice.
&gt; if you are keeping your state only in the js, then you need to keep the view in sync with that anyway. I used to struggle with this. Instead of using a framework to solve this problem I managed it through the DOM directly, but both are the wrong answer. If you have built your application correctly it completely doesn't matter if you are using a framework or not. Here is the solution that works for me: 1. **Always specify a default and be explicit about it.** Have a default state in your application code that matches the default conditions in the DOM (set through the HTML and CSS) as though the application code is absent. All these default settings should be bundled into a single central location in your app. 2. **Only manage changes once per change.** When an interaction occurs that changes some state somewhere change it in your application and apply this change back to the DOM immediately from a single piece of code in your application, typically an event handler. This means there are changes made to the DOM, but you are only observing state in your application and not in the DOM. 3. **Centralize state settings in your app.** There are likely to be many various event handlers in your code responding to all manners of changes, which is fine. The default settings should be in a single central location. That single central group of settings is your entire state settings. When changes to state occur they overwrite the default value in this single central bundle. Everything that needs to know about state will read from this one central thing. 4. **If you need to preserve state then do so uniformly.** If you want to save all your user's interactions so that they can close the app and come back later with everything looking exactly like the app was never closed then fine. Perform a single save operation of all state data from that big single central settings bundle when you need to save settings. In the browser this could be as simple as writing a JSON.stringify on your settings object into localStorage. Some things to keep in mind: * You aren't managing the DOM at all. All you are doing is responding to changes inflicted by the user. If this means the DOM becomes out of sync with the settings in your application then you have failed. Either you have violated a separation of concerns or you could have a race condition. Solve your application problem and the DOM will be just fine. * Your settings (state) are a single central thing, which means they cannot be associated with any single library in your application. The settings must be completely independent of other application logic or you will end up with either race conditions or bias. *edited for grammar corrections.*
your &lt;tr&gt; are not closed in the string in showAppointment, that fixes priority and date, but not the others, and I guess you really don't want to sort the headers, that is another issue
There's nothing wrong with direct DOM manipulation, but it becomes difficult to understand and maintain the code as your code base and/or # of teams grow.
If your site analytics show that the browsers that are hitting your site support the features you want to use at a high enough percentage to satisfy your requirements, then the answer is "yes". Otherwise "no". If the site is not live and you're building it from scratch than replace "site analytics" with "caniuse or whatever".
&gt; How would you go about testing the method that detects node versions? What exactly would you be testing here? That the NodeJs version in questions documented API actually does what it says? I would just use semver to be able to do semver.gt('1.2.3', '9.8.7') //false and write a basic unit test that ensures the right code is returned based on the results of the above.
[Math.js](http://mathjs.org/). Go to the docs in the parsing section. Basically it receives a string and returns a JS function. EDIT: Cleaning the mess I made writing with the phone.
I could, but it's behind a login screen. It has about 200 database tables, around 5000 sql statements, and around 500,000 lines of code. I work for a Fortune 150 company and we work in vanilla JS, CSS, and HTML. 
I only did a bit of GUI programming a long time ago, and as I recall yes you would've had the same problem. Widgets and databinding were built in, and layout styles were designed specifically for apps so it wasn't as complicated as CSS, but otherwise I would miss using a VDOM. If JS and the GC were slow, the VDOM approach might not be feasible. Fortunately they're fast. :)
Yeah, sorry if I was unclear, my statement above was basically saying *you would be testing Node to ensure that a documented api actually works as documented* which is pretty pointless imo. &gt; Edit: Nevermind, this can be mocked. I think even calling it a mock is a stretch, would you agree? Just write a unit test for the function and pass it a few different version numbers.
From my experience working on a front-end team, managing state gets complex -- so testing and refactoring becomes harder.
We all know DOM manipulation is SLOW. His question is what is wrong with DIRECT Dom manipulation.
Yeah that makes the most sense. You're correct, calling it a mock is a stretch for that.
&gt; Its not that difficult Juggling a single ball isn't difficult either, the problem is that of **scale**. React and other frameworks let you easily scale your application up to large amounts of state and logic. When your rendering code is a pure function of state it's easy to reason about. When your logic goes into the DOM and messes with elements directly you easily end up in situations where you can't reason about your application because you don't know where mutations are coming from any more (i.e. 10 different pieces of logic manipulate the same element). With "vanilla JS" you're either going to not structure your rendering and end up with a giant mess, or you're going to develop an ad-hoc framework that's going to be a buggy implementation of either half of Angular or half of React that you'll be stuck maintaining. Why not just use a proper framework? (Obviously if you're doing simple there's nothing wrong with vanilla. Everything has its place.)
So then what part of DOM manipulation makes it expensive in your opinion?
What is wrong with direct dom manipulation? Dom manipulation is slow thats whats wrong. I dont understand the downvotes but ok i wasnt clear.
One of your biggest issues would still be import / export. If you are writing everything without modules you're good to go. Otherwise support for modules is lacking and super slow in the current preview forms.
Absolutely, with enough discipline and careful programming you can build complex applications that handle DOM state management, without using a framework. But for a lot of people just don't have that level of discipline (or really, the experience: I don't mean to make it sound like some developers just lack willpower or something) to execute that sort of strategy properly. And when it goes bad, it can go really bad. And especially if you've got a team: a junior developer on the team will have a hard time grokking all the nuances of managing state safely and properly. And especially if you've got an embedded designer (with minimal JS expertise), a framework is generally going to be much easier for them to work with, in my experience, than raw JS. And, frankly, even if you're disciplined and careful enough to keep it clean, I've often found that a framework ultimately reduces a lot of boilerplate over manual state management.
For me, the moment at which I truly understood the point of React was (well, the whole video, really) here: https://youtu.be/x7cQ3mrcKaY?t=908 
Looks interesting and well written. Do you mind explaining what the benefits are vs using the native canvas API?
That would test how good the graphics card was.
Modern frameworks use diffing algorithms on DOM operations because DOM operations are very slow, relatively speaking, so we want to do as few of them as possible in order to be performant. When we're working only with data, we're not limited by the DOM, performance-wise.
You still don't understand. The question is NOT about Dom manipulation. It's about DIRECT Dom manipulation. The problems with DIRECT dom manipulation would still exist even if dom manipulation was instantaneous. The problem with direct dom manipulation is that it makes the DOM your application state and then your application state can be manipulated from any function in your entire application. When you find a problem in your application state (the DOM) then you will have to potentially have to search every function in your application to see who it was that messed up the DOM. When you use a small and explicit state (model) and then declaratively specify your DOM (view) based upon the state then when there is a problem in your DOM you only need to look at the single file location where you specified declaratively what the DOM ought to look like based on your model. Does this make sense? That is why you are being downvoted. You were not answering the question.
I have created something in JavaScript called SpanText that manipulates web text based on user interaction. It operates by direct manipulation of the DOM, and I'm interested to know what more experienced programmers here (I am basically a hobbyist) think of my methods, if anyone is interested in checking out the source code. As I was coding, I did run into one of the primary problems discussed here: preservation of the original data state. Had I known to use React, I might have. Instead, I figured out how to temporarily save each element's state directly within the script on each change, so that nothing would get irreversibly altered. Good problem-solving task for learning, but it seems to point out the need for a better way of handling this. Related to that, I'm also in knowing how scalable my code is by the standards being discussed here: for instance, if these sliders were manipulating several hundred thousands words instead of just a few paragraphs, would I exceed the maximum calls? Demo is at: http://www.spantext.com Code is at the GitHub on the download page.
The "wrong" part is that when doing direct DOM manipulation, you're most likely not documenting how to apply self-discipline, so if someone else comes into the code (because teams), they are likely to do their own thing, which ostensibly works but does not take into account some unspoken architectural choice (e.g. a centralized data store, or how DOM update snippets are grouped in complex actions) Frameworks typically have idiomatic ways to structure code which are either officially documented or informally by community presentations, and code the deviates a lot from idiomatic form is often awkward to write. Also, popular frameworks allow you to structure coding interviews more easily. With that said, frameworks are not a silver bullet. It's still possible to write code that violate self-discipline guidelines of a project even with all-encompassing frameworks, and hiring for them isn't particularly easy for even the most popular frameworks.
And yet he wants to roll his own but is being told not to. This always comes up on reddit where redditors will say you must use React and Vue cause you can't do it on your own. I would hate to be the person who first thought of and wrote React or Vue but came here to ask a similar question.
No, because it would work like this render component -&gt; props are updated -&gt; render component While now it works like this render component -&gt; props are updated -&gt; render virtual dom -&gt; compare with previous vdom -&gt; figure least amount of steps to get there -&gt; render necessary steps 
Bare with me, I'm not good at languaging and computering. Direct way: 1. make JSON request 2. JSON arrives 3. parse JSON 4. wrap the data with some fancy tags 5. append it to \#chatbox 6. add +1 to \#unread_message Less Direct Way: 1. make JSON request 2. JSON arrives 3. parse JSON 4. pass it to a Module 5. mark it as unread and insert it to a $message_pool in Module 6. count the length of unread message in $message_pool 7. wrap the whole message pool with some fancy tags in Module 8. replace (re-render) \#chatbox 8. replace (re-render) \#unread_message &amp;nbsp; With Module, I can do some_calculation(), CRUD(), sort(), filter(), search(), paginate(), or anything() because I have total control over the content of \#chatbox which is $message_wrapped_in_fancy_tags. I still can make changes the \#chatbox accidentally or intentionally. But when the Module, re-renders it will removes those changes because any changes to the \#chatbox have to be done via Module API unless I set it otherwise. That's the yay. &amp;nbsp; There's a nay. Inserting elements to the DOM is expensive. It makes no sense to replace the whole \#chatbox especially when the length of $message_pool becomes bigger. The \#chatbox will start to flicker. The sign that rendering blocks (the painting step I guess?). I noticed this when I tried to re-render 20 x 2000 cells table and add another 20 x 1000 cells. A plain table with empty cells and without cheat.. There has to be a way to add/remove and it has to be done by comparing $message_pool with children of \#chatbox. That's what I think diffing is all about. It deep-scans through the \#chatbox nodes to remove unwanted children and to apply necessary changes. &amp;nbsp; For me, diffing is important in single page web apps when I don't have to load another HTML page everytimes I click on a link. Really. I only need the content. Just give me all the available templates and the JS controller so all I need to do is to request the content and you will give me the content.json and probably some ads.json I'll most likely block. I don't need the whole HTML plant pot. /endrant &amp;nbsp; So, re-rendering with diffing is better than re-rendering the whole \#chatbox. But I still don't think it helps when I try to add 1000 new messages at once. Because rendering blocks T_T 
I think transpiling isn't going away, es2017, 18, 19, 20, it will always have features that take a long time to distribute, and as long as ie11 is still around there's no way around it even if you wanted. Getting to run features in the real world before they're 100% drafted also feeds back into the cycle. With todays tools it's also easy to create separate bundles that detect evergreen and serve raw esnext or es5 for older browsers. And even beyond the basic necessity, i see transpilation as a major strength. It also frees JS completely from the vendors or committees grip. &gt; CSS preprocessors or postcss-cssnext will die when CSS2017 Doubt it. I think we'll rather observe the fading of css alltogether at some point, just like JSX made HTML pretty much irrelevant. At some point there's just no point any longer in dragging these antiquated things around. Like how many years has css had to come along, and it's still the most troublesome when it comes to serving various browsers. That we think if things like auto-prefixing and css-resets as "normal" is absolutely insane.
The best way to get help is to show what you've already done. Post the code that you've tried that doesn't work or give us more detail about what the project entails. Are you working with the HTML5 Canvas or just a DOM image?
Many inhouse developers don't realize what they're doing and at what price. A small team of developers maintaining a web presence cost what? Half a million per year plus overhead? Having basically infinite time, only organizational deadlines, most likely a constant core of developers that can get used to the most arcane and complex ways of doing things. &gt; measured by the time needed for new guys to get into it. .. and the ability of the system to absorb change without requiring rewrites.
TypeScript is actually a superset of JavaScript. "switching to a new language" implies a bigger shift than it really is.
Nothing wrong with it, carry on. Vue and React are supposed to make your life easier. If they aren't doing that then ditch them. But, someday you'll be building an app and think to yourself: This thing has grown so much that its become its own framework. And that framework kind of sucks because I sort of accidentally wrote it around my website. Also. . . Whisper: "React and Vue look good on a resume." 
Sounds like they're comparing browsers. 
Right. So why would it matter whether it's the CPU or the GPU doing the work?
Yep and you can write directly to the DOM in which case the entire DOM becomes both your "model" and your "view" or you can keep a small, manageable and verifiable model and declaratively specify your view. If the entire DOM is your model and you write directly to it then any error in your application requires you to potentially search every single one of your functions which may have messed up the DOM.
The DOM is your VIEW. If you directly (imperatively) modify it then the DOM has also become your MODEL. When there is any problem in the DOM then you must search every single one of your imperative functions which may have directly manipulated it. If however you use a reactive, declarative DOM description then debugging becomes far easier. Either your much smaller MODEL is wrong in which case you can add validation to where it's set at in order to locate where it went wrong, or else the error is in your declarative description of what the DOM should be in which case you jump directly to the file or template which declares what it ought to be.
There's nothing wrong with it. It's much better and more performant.
Hello everyone! I would like to introduce you to my project i have recently been working on. I always wanted to make a 3D Engine/Renderer myself since i have quite a bit of experience with modelinng. So i decided to try it in Javascript, and here it is, all made with Canvas Api, no WebGL or other plugins used. It is still pretty WIP, but for now i have, 4 primitive objects ready to go, face normals, debugging mode, and simple shading, single point lights working. Future plans are: smooth shading, importing .obj files, more complex commands, multi point light shading, textures and perspective view. Feel free to ask me anything! :) 
How useful would it be how useful world it be for Angular?
[GIFV link](https://i.imgur.com/GrUDxky.gifv) --- _^I ^am ^a ^bot. ^[FAQ](https://www.reddit.com/r/livven/wiki/gifv-bot) ^// ^[code](https://github.com/Livven/GifvBot)_
'Let's compare Saker with other hot template engines.' proceeds to compare pug and handlebars... Do you mind adding a 4th column in your readme showing what the syntax looks like for Saker. I'd like to see how it compares against Pug since Pug is already very terse.
It depends on the app, but LogRocket captures the user DOM, console, and network request / responses, so it helps give more context for bugs / issues. We also hook into libraries like @ngrx/store: https://github.com/LogRocket/logrocket-ngrx (disclosure: I'm the post's author)
It looks more like an object, but not an array. Parse your JSON string to object with `JSON.parse(yourJson)` and then iterate through object with [for...in](http://devdocs.io/javascript/statements/for...in) ~~or [for...of](http://devdocs.io/javascript/statements/for...of)~~
Oh, ok i will wait, i am new here and did not know, sorry :)
turns out I was able to iterate through it with: for (var key in obj) { obj being the JSON object. for some reason "key" is value 1 in the list and obj[key] is value 2. I have no idea why...
This sounds really cool! Does tracking all of this affect performance at all? Also, is there any interest in supporting Vue/Vuex?
Wonder which intrumentation is setup
This thing is an object, not an array. Try this: `Object.keys(yourjsonobject).forEach((index) =&gt; { var key = yourjsonobject [index]; //key is your key at this index. Do something with it });` 
Well, it was dropped but it's "duties" are going to be rolled into webasm
You can't get the length of the list because it's not an array. The .length method isn't available on objects. 
It says this records *everything*, how does this handle stuff like passwords? Are the key strokes recorded or is it just like recording form values (so the passwords remain hidden)?
Yep, we record "values" and hide DOM nodes where `type === 'password' || class === '_lr-hide'`, so you can control what gets recorded.
Cool, it sounds like a neat library. I'll probably give it a try eventually.
I've got it working, just needed help understanding how this object works, thanks for your help
This is cool from a technical standpoint but a huge privacy problem. I doubt many users would be too happy to know you record their entire stay on your page.
And honestly that makes sense. While I'm sad that I won't get to use SIMD directly from JS, keeping it in webasm is where it feels like a better fit, and if that doesn't work out then it's not like the work you've done here so far is useless, y'all can pick it right back up.
I won't say 0 overhead, but it is minimal. All of the data is compressed in protobufs in a Worker thread and sent in batches to the server. 
And by superset of JavaScript you actually mean C#. Don't get me wrong, I like static typing myself and I can definitely see the benefits, but saying that: protected, public and private access modifiers, interfaces and abstract classes are a superset of JavaScript and not a different language is a bit of a stretch, don't you agree? Just call it what it is. People who see the benefits in that will still use it anyway. 
Demo here: http://grapesjs.com/demo-mjml.html
Hi again-- thank you for this answer. Again, I'm sure this is solution, but not so sure about how to execute it. If I made two if/else blocks, would I make each 'else' condition output the same result? (i.e. would they both refer to the instance wherein one number is odd and the other is even?) Thanks again for your help! UPDATE: I've figured it out-- I needed to use "else if" for another if condition following the first. Thank you for all your help!
It's literally a superset of JavaScript. All JavaScript is valid TypeScript, but not all TypeScript is valid JavaScript.
can you post the code that makes the `POST` to `/buy/?product=bundle` ?
tetris, asteroids, missile command, breakout, pong
thanks il check em out
Honestly, I'd advertise this more as a tool for internal testing.
Also, to add to what /u/grinde said private, public, etc are *just* more type hinting for ts. There is literally nothing at runtime stopping you from modifying a member marked private in ts. However the tooling will complain that you are modifying a member marked private when you compile. It's not *exactly* the same thing as a type but it is a similar idea. A compile time only constraint that let's you know when you are doing something you "shouldn't" be according to the code.
Agreed, and who renames their files from .js to .ts just to make use of... tslint instead of eslint? Or what would be the benefit of TypeScript if you don't actually use its features? Why bother with it then? It's the whole ecosystem of TS that is actually quite a shift. You cannot just start using TS in your project while keeping your old configurations, for example. So yes, while it's a superset, switching to it means that you're out of the JS environment and you've hopped into a new one. And this is what I don't like about it. It's being "sold" as a very easy transition while in reality, it's really not. So people who understand the benefits of OOP and really know what they are doing will just use TS and that's it. But trying to tell all JS devs that they can switch and there won't be any big shift is actually a lie.
Does it only work on SPAs or does it auto send on page onbeforeunload for request/response apps/pages? How far back does the IE support go?
..... what is going on here
F
Always nice to see Vue being taken care of in this crushing tide of React!
I have the 4th column of the compare table, maybe you ignore the horizontal scroll bar.
It's really useful for inheritance like one might do in a classical OO language: MyObj.prototype = Object.create(ParentObj.prototype); MyObj.prototype.constructor = MyObj;
Millions of rows? Lol. Bad design for a **mobile** app.
Have you looked into using the Twitter API to do what you are talking about? I feel that would make your task much simpler.
Umm, not to be the bearer of bad news - this is what every major organization [facebook, google, amazon, financial institutions, ebay, you name it, etc] (via platforms similar to what google offers) does (they store all your activity and target ads for you with this process =&gt; basically, every time you hit a page, it creates a unique id, that id then gets fed to a central database and also stored as a cookie in your browser =&gt; then when you visit other pages that subscribe to the central database, they have an idea of your activity and where you've been/visited, and voila - that is how you get targeted ads from companies/sites/etc you've never even visited before). This whole concept is a MAJOR business that isn't discussed much frankly because of the scrutiny it can bring =&gt; that being said, these processes don't store any real information (like name, address, SSN, bank account numbers, etc) =&gt; they just store your preferences, assign a unique id to match you up between your browser and a server hit, and then feed you things they believe will align with your preferences.
Sounds like FullStory. What benefits does it have over FullStory? 
It's a great tool to ensure your application is actually working. You can only predict/build so much error-controlling in to your application, but when you have a fallback that can catch errors, showcase what lead to the error, etc - that is a big selling point to QA/debug teams.
[Here](https://dev.twitter.com/rest/reference/get/followers/list) you go!
https://www.reddit.com/r/javascript/comments/681g6p/how_we_approach_testing_and_qa_at_old_st_labs/?st=J2VA8S53&amp;sh=1ac62fc4
That's not reflected on your website :-(
lol every site for every company I have ever worked for does this. 
I know all of that and this practise already received much scrutiny and bad press.
Love the name, but the page is a bit scarce for preordering
Is your task to create a function that changes plain text into cipher text, or to create a system that analyses and deciphers text? If it's the former, first build a map of all letters in the alphabet and their corresponding cipher letter. Then loop over every letter in the plain text message, replacing it with its equivalent cipher letter. The string you have after the loop is your cipher text. If it's to analyse and decipher some text, without knowing the map of letters, this is well beyond your described scope, and would require frequency analysis.
Alright, so if you want to have the access modifiers and interfaces which are part of a more object oriented approach, couldn't that be that better suited for the usage of TS? Or let me put it in a different light, so perhaps you will finally grasp the concept: If I don't care about using classes or any OOP whatsoever in my application, why should I go for TS instead of Flow? Let's say that I care only about the static typing. Oh and yes, I want to use all of my eslint configurations and such. And please don't imply that tslint and eslint are on par because you know and I know that it is simply not true. That means that I don't want to make use of yet another moving part in my build chain which converts my current codebase in ESLint trees and whatnot.
Interfaces can describe anything with fields not just classes. Why should you use flow instead of ts? I don't care. Use whichever you want. But ts handles return types and implicit types and even has no null values now too. You want to keep using flow? Go ahead. I didn't respond to you to convince you to use ts. I only corrected your assertions. As for actual reasons to use ts though the fact that it is fast becoming the defacto type system with many large libraries written in ts, not flow, and with many more providing ts support explicitly, and not flow, would be reason enough for me to choose one over the other since the other differences between them are so minimal. And I don't know where linting ever came up in this conversation. But if you want eslint so bad there's nothing stopping you from running eslint on the output of the typescript compiler. But that has nothing to do with the rest of this so I don't understand why you even brought it up.
tl;dr Immutability, and Flow. Debugging mutable data structures and side effects is a nightmarish hellscape of pain.
Fantastic
Without state management you tend to end up with [huge monolithic designs even for relatively simple applications](https://github.com/prettydiff/prettydiff/blob/master/api/dom.js) and your [main dom drawing can depend on a fuck ton of fragile if then else tests.](https://github.com/prettydiff/prettydiff/blob/master/prettydiff.js) Jesus fucking christ on a cracker. This is actually "good" js too, there's much worse out there. It shows just how complex state management via the dom can get once you get past a simple todo app. You could do this a lot better with more 'modern' JS like ES6+ via modules and classes, but it'd still end up being very manual and extremely error prone. You'd probably end up creating an event dispatch store system similar to redux or its ilk once it got complex enough just due to how useful of a pattern that is. A modern framework will just enforce further separation of concerns: state goes here, view goes here, state transitions go here, etc. More importantly though it gives you a standard procedure for doing things like adding a view, adding an action/event, etc. This is the real advantage of using a structured system from the get go.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [prettydiff/prettydiff/.../**prettydiff.js** (master → 5f6ed5e)](https://github.com/prettydiff/prettydiff/blob/5f6ed5e048513d673475a4387b078c77efd2709c/prettydiff.js) * [prettydiff/prettydiff/.../**dom.js** (master → 5f6ed5e)](https://github.com/prettydiff/prettydiff/blob/5f6ed5e048513d673475a4387b078c77efd2709c/api/dom.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhrbrmq.)^.
As of now, Chakra is faster/best stable JS engine. However, within weeks V8 should take back that title.
I see my.url.com and myurl.com. I know you're obfuscating, though, so probably nothing.
I'm... I'm not in /r/knitting. I was *super* confused for a minute there.
Why? What is wrong with using create-react-app directly? This seems like pointless indirection. Am I missing something?
I suppose they wanna unify the API between all libraries. Kinda like how before ES6, every other library had its own way of making a class. 
But not all scaffolders are conceptually simple enough to follow that format, they may take options or have multiple binaries for different setup tasks. And even for those that do follow the simple create-react-app format, this adds virtually *nothing* to just using it directly. It feels like a classic case of "I want *my* CLI to be the one to rule them all" instead of focusing on doing one thing well.
There's create-react-app, but i'll create my build-vue-app, and little johnny there will build his conceptualize-angular-app. I think centralizing it is neat, it's clearly a pattern, why not abstract it away?
Because that is multiple steps that have to be ("install create-react-app -globally-, then `create-react-app ...`, etc.), and this makes the interface between different frameworks consistent. Think of it like a convention, just like `yarn test` (or `npm test`) are a more predictable way to find out how to start an app than having to find out which Grunt/Gulp/Jest/whatever command you have to run to run a project's tests.
[Image](https://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 4518 times, representing 2.8569% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dhrj322)
Options are still passed on. As for the multiple binaries, a project can still use those, but that _will_ mean a higher barrier to entry than for projects with a `create-x-app`. Which is a trade-off you might be willing to make.
You only need to install create-react-app once. The yarn test convention (or npm test) makes sense to me because yarn and npm are basically interfaces to managing a package.json, which is primarily about dependencies and scripts (like start and test). This just invents a whole new area of responsibility that doesn't really relate to package.json or dependency management. It's project scaffolding. I feel it is not necessarily within a package manager's remit. But if it added something genuinely useful, then great, I just don't see what's useful about this. I'd much sooner run the binary myself than type a wrapper command that essentially just interpolates the word "create-" into a binary name for me (and passes through options I could have just used on the binary directly). Not every tiny thing needs to be abstracted away. At some point an abstraction is so small that it's just indirection.
Interesting! What sort of data do you capture on the client? ie. are you sending state diffs which are then rendered-server side, or are you logging everything direct-to-video so to speak on the client and sending that?
So the author concludes aurelia is probably best designed but since react is a bigger buzzword he decided to settle with that?. Not a very convincing argument. Why not join the aurelia community and improve on the few things that need to be improved on (documentation)
Unfortunately we don't currently record canvases, but could definitely in the future.
What would be the benefits of not installing it globally?
You can't iterate objects. You have to loop through all the available keys and (ideally) check that they aren't provided by prototyped parents of the object. let item, idx; for (idx in obj) { if (obj.hasOwnProperty(idx)) { item = obj[idx]; // idx then becomes sac5bhmY and item becomes: 123467890 // next time through loop idx becomes jPerR4uP and item becomes 617364 } }
How about svg?
Not sure if parody or parody of the parody.
I usually use Mongo or PostgreSQL with Sequelize
Hi /u/ilmari2k, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/stephensxu, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/CheeseDrizzle1, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your work/homework for you.
&gt; You only need to install create-react-app once. Well, yes, but every instruction needs to include that step. Note that Yarn here still is just an interface to packages - the scaffolding is still done by create-x-app, it's just that Yarn creates a shortcut to installing and running it. And you _can_ still run the original create-x-app, if you know what it's called. This just makes it more likely that it's in the create-x-app format. Note that the entirety of create-x-app is _already_ an abstraction to hide what is happening behind the scenes until you're ready for looking at it. This just provides a standardised way to do so, so that you know where to look if you're ready to take a look - just like I know to look in the `package.json` to find out what commands are exactly involved in running the tests, rather than having to go to the project's website and hoping that they've documented it somewhere.
i suspect you'll discover that going in reverse will require that you specify loops, conditional branches, etc in custom attrs so that you can reverse-generate the js code that will then be capable of properly continuing to diff &amp; mutate the dom. the resulting html will look a lot like what you already see in html-esque template DSLs that try to avoid having users understand too much js.
Oof. I'll try to do better next time!
I think people are being a bit melodramatic about this. It's essentially just like running `npm start` instead of a specific build command: it just standardizes the command while leaving all the implementation details to the packages themselves. Of course, it's not a prefect analogy - `npm start` runs a command in the current package, while `yarn create` installs a separate package and runs a command on it - but it's the same general thing. It's just creating a standardized command for a common task.
https://pastebin.com/uxAfhT5g bot.js https://pastebin.com/FT569Ucr bot_manager.js 
I have used mlab for hosting my mongoDB when using a node/express backend. They have a free service which should give you enough storage to do what you need. 
That's unfortunate. SIMD is quite nice in Dart. There are cases where it lets you beat Java by quite a margin. Well, it's a lot less cool without types and operator overloading. To be fair, the overlap between cases where SIMD makes sense and those where Wasm makes sense is fairly large. Maybe SIMD.js isn't really needed in environments where Wasm exists.
Interesting.
I can't emphasize how useful and important create-react-app is for the ecosystem. The first and obvious benefit is being able to quickly create new projects without having to think about build infrastructure, which is honestly the most painful part of building a modern React project. create-react-app makes all the hard choices for you and gives you a reasonable set of defaults to work with. It's convention over configuration, kind of like Rails. It's a huge game changer. The less obvious benefit is that it forces developers to fall into the pit of success by making it easy to do the right thing. Flow is supported out of the box, so adding type checking to your app is trivial. Jest is set up for you out of the box, so you have no excuse to not add tests. This new version includes support for code splitting, so there's no reason to ship bloated JS bundles to your users. Building a PWA is easy, so you start thinking about offline-first right at the start of your project. I can't thank the team behind this little tool enough for making it so easy and so much fun to build React applications!
Let's first examine your stack trace: events.js:72 throw er; // Unhandled 'error' event ^ Error: listen EADDRINUSE at errnoException (net.js:901:11) at Server._listen2 (net.js:1039:14) at listen (net.js:1061:10) at Server.listen (net.js:1135:5) at Function.app.listen (/var/www/Bot/BOT/node_modules/express/lib/application.js:534:24) at /var/www/Bot/BOT/bot.js:220:6 at Query._callback (/var/www/Bot/BOT/bot.js:255:11) at Query.Sequence.end (/var/www/Bot/BOT/node_modules/mysql/lib/protocol/sequences/Sequence.js:86:24) at Query._handleFinalResultPacket (/var/www/Bot/BOT/node_modules/mysql/lib/protocol/sequences/Query.js:137:8) at Query.EofPacket (/var/www/Bot/BOT/node_modules/mysql/lib/protocol/sequences/Query.js:121:8) Bot stopped with code 8 We can see that the stack trace "bubbles" up from bottom to top. So you must examine the trace line by line until you find something you recognize. `at /var/www/Bot/BOT/bot.js:220:6` Oh! We know this file. Now if we examine `bot.js` at line 220 we have the following: `app.listen(3000+account.id);` So somewhere around here your express app is throwing a `Error: listen EADDRINUSE`. Now a quick google for that error leads us to http://stackoverflow.com/questions/9898372/how-to-fix-error-listen-eaddrinuse-while-using-nodejs which says: &gt; EADDRINUSE means that the port number which listen() tries to bind the server to is already in use. That is your issue.
And how can I do this now? sorry Iam not a pro :(
Aw, just got rid of that garbage. Now it's back because npm couldn't do lockfiles properly.
So this command automatically downloads and executes node scripts? Time to create a `create-react-ap` package and see how many people download it.
Sounds like we have different standards for tips that warrant being thankful for. It's also part of my opinions not to make strangers on the internet my source for homework, unless they produce reasonable arguments. You haven't even attempted to produce a reasonable position, all your energy is going into avoiding the topic which is multiple things; including totally fine. It just wetted my appetite and then left me hanging.
[removed]
Thanks, free stuff! Ill check it out.
`yarn create-wanna-cry`
It tracks console logs and network requests.
Knex seems an interesting alternative to Sequelize
Haha I came to complain about this. Iirc I added the yarn global bin to my PATH.
Is firebase a bad option? GraphQL
Yeah, I hear this is a pretty common thing. What would you say is the main reason you don't have time? Boss just doesn't get it?
Simplicity is a fair point. If you don't need to develop something further (eg. maybe it's just a short term one off type project), then yeah not a huge amount of value. I'm wondering though, you say too many tests slow down development velocity... what makes you say that? Wouldn't more tests reduce bugs and help you design a system better? Not saying you're wrong or anything, just curious :)
 var employeeInfo = [ [ ['firstName', 'Joe'], ['lastName', 'Blow'], ['age', 42], ['role', 'clerk'] ], [ ['firstName', 'Mary'], ['lastName', 'Jenkins'], ['age', 36], ['role', 'manager'] ] ] var converted = employeeInfo.map(row =&gt; { let obj = {} row.forEach(keyPair =&gt; { obj[keyPair[0]] = keyPair[1] }) return obj }) console.log(converted) 
GraphQL data API starter `yarn create data-api`
Yep sounds pretty familiar :) Have you tried changing their minds about it, or does adding tests slow you down too much in your experience? It's actually fairly interesting in the sense that while I remember discussing automatic tests often with bosses and such if it mattered, but none of them really cared a whole lot and were just "you just do whatever you need to make sure it's not gonna be buggy and broken". They tend to care about it not being buggy and broken more than whether I'm adding unit tests :P
Yeah, I've yet to see a *really* good method for dealing with UI. It seems currently snapshot testing is somewhat of a hit, but I don't know if it really is without its issues. Don't even get me started on how complex Selenium is :)
Maybe you forgot to register that router in your application? app.use('/', router); I assume you are using jquery, did you try without that trailing slash? You can also pass the query params as an object: $.get('/q', { order: 1, id: 2, q: 3 }).then( ... ); 
&gt; The target right now is the browser, but if it works as intended, &gt; I'd like to port it to Electron (which I think it won't be &gt; much of an added work). If you want to make easy porting of your project you must keep your application logic independent of specific environment. Don't assume too much. Platforms differ. For example Electron API has some cool features like access to files or menu bar, but if you will use Electron API all over the place, it won't work in browser anymore. Good idea is to separate environment specific API from the application logic (I use often "adapter" design pattern or pub-sub for this). This way you could program your app logic independently of whether it's in Electron or browser. Good idea is also to not assume browser environment at all(!). Don't assume that there would be `window` or `document` object. Try to code in pure JavaScript (in pure JavaScript there is no such thing as `document` or DOM). This way you could then test/run your files in NodeJS. If you have to call DOM (directly or e.g. with React) or some environment specific things (like Electron API), extract special module(s) for this kind of operation (like SQL queries on backend - you rather don't want to have SQL queries all over the place, so why call DOM from all over the place?). I think Model-View separation is important and overally separation of various layers of your project (for example Electron/browser layer, view layer, model layer, user interaction layer etc.) &gt; with added functionality like being able to do calculus &gt; and manipulate numbers. such functionality could be implemented as plugin (by "plugin" I mean architectural pattern of making some features pluggable and not coupled with the core of your application)
has a lot to do with proliferation of software due to the "I know, I'll make a new one!" attitude. 
Agreed. Seems to be a lot of that at Facebook these days. 
Does it actually parse c++ code now? Or soon. No more compiling via emscriptem then?
It depends a lot on whether your application is functional. That sounds dumb, but this is what I mean. When I was working for startups, including one that I started with a good friend, tests weren't our immediate concern. We focused on code quality, and producing a functioning application that we could get to investors and market faster, and then began to write tests in combination with beta tester feedback. Unless you're already funded, or have a lot of time, tests just don't take priority. Now at a larger corporation tests are a mandatory focus for my team. Unless we need to immediately push a feature, that feature will be intimately scrutinized and tested before release. However, a large part of this comes down to being efficient at selecting what is worth actually writing tests for. For example we use react on the front end and we don't end up testing a good number of our components. We will test the hoc that have the responsibility of passing props and ensure that their conditions are met and props are passed properly. We don't test our actions, but we do test our async action creators. Reducers are hit or miss. If there is a lot of data handling (which we try to avoid) then we will test these to make sure everything is functioning and getting stored as it should. It really just comes down to time to market and funding vs project deadlines/efficiency for me personally. 
Without digging into it too deep there's https://api.data.gov/
Before we switched to a proper CI we were using webpack for bundling and gulp for deployment. All of our tasks were initiated in gulp though. Maybe I'm not understanding what you're looking for, but webpack allows you to write whatever spec of ES you like with imports. Doesn't that tick all of your boxes?
Oh I agree it's been well designed. It just seems to me that they suffer a bit from NIH syndrome. Mostly referring to Flow, which I could be wrong about but I don't see any benefits to compared to the far more mature TypeScript. But I digress. 
My management didn't get it until I explained that spending a little extra time on testing is like investing in the future features. Luckily (or unluckily) it's been pretty easy to demonstrate that to them -- maybe they are more tech savvy than they let on.
Sure, send me a link. No promises but I'll try to take a look later tonight. Maybe you can point to the relevant section of code.
This is golden, especially rule 3. With native observables coming this will be even better. Creating an "event emitter" and handler that can respond to more agnostic events and can redirect the data to the right place is paramount in maintaining a vanilla js application at scale. A+
No, AFAIK compiling to wasm is still required by developers and V8 will only decode/parse JavaScript and wasm.
Node API with mLab for database and Heroku as a deployment platform. This will allow you to focus on actual development and minimise frustrating configurations and setups.
It's yarn global add. I'm pretty sure I've accidentally locally installed a module called global hundreds of times due to that... 
Being offline-first/PWA by default is the best addition this version brings!
Sequelize?
Interesting selection of statistic too. Is that just where you happen to be, or is there deeper significance to Paris as a benchmark? Does this mean the .NET is generally in decline? Out of curiosity, what are Parisian startups using?
Nice https://github.com/maggiepint/proposal-temporal I'm in support of this... At first glance, it appears to have a similar api to moment. It would be so nice to have this built into the language.
Glad to hear! There is a fair amount of pushback against this proposal within committee. One alternative idea is that we don't standardize a library but standardize that all the data tables (tz info, leap seconds, etc.) are exposed on some object (say, Date.data?) and leave libraries as the (only) way to use a rational Date representation. Doing this would allow Moment to ship a much lighter version as it wouldn't have to carry its own data around with it. Thoughts on this approach? Also, I guess someone should submit that proposal as its own post. Curious what reddit thinks.
I think built in is the way to go. Am curious what the benefit of leaving it up to libraries would be? Or why you couldn't do both? 
Aha fair enough! I guess the "both" option would be insurance against the built in not being an ideal backing store in certain cases? I'll stay optimistic that it could be informed by great libs like moment and date-fns. Ultimately a solid Date just means another dependency I don't have to worry about or add to my bundle size. 
people have lost their damn minds. Asking for Mars time in the core of JavaScript is about as insane as people signing up for Mars One. How about you fork whatever language you want on your way to live in a bubble.
When is V8 getting shared memory and atomics?
I'll use React or Vue (not sure ATM which one) because some of the functionality will be almost needed and indeed wanted. But hypothetically speaking, if I were to go without none of those, couldn't I structure my code someway somehow? That's what I'd like to study. DRY, SOLID, etc. are "just" general programming principles, just like KISS. I understand nobody can tell you ideal strategies, but just like with frameworks, there must be the top 3-4 ways to high-level code structure?
I'm thinking it's more likely people will live underground. Bubbles are way more complex and failure prone than a tunnel.
Wow, that's a pretty big difference. I wanted to remove the browser from the equation so I ran the same test from the command line using a `chakracore` pre-release build of node. I used the `jsperf` module to test Node 7.10.0 against [Node 8.0.0-pre with ChakraCore](https://github.com/nodejs/node-chakracore) and there is a pretty massive difference there as well. `Node 8.0.0-pre` was compiled on macOS 10.12 using the instructions here: https://github.com/nodejs/node-chakracore#building-node-chakracore The exact command for kicking off both tests was simply `jsperf run cached-trigonometric-functions 1`. `jsperf` was installed globally. **Node 7.10.0** Version info: &gt; process.versions.node '7.10.0' &gt; process.versions.v8 '5.5.372.43' Test results: 8 tests completed. Normal trig functions x 9,323,913 ops/sec ±1.00% (54 runs sampled) Buffered trig functions x 811,758 ops/sec ±2.37% (58 runs sampled) Buffered trig functions - no prototypes (THE ONE TO USE!) x 16,786,427 ops/sec ±1.03% (57 runs sampled) Buffered trig functions - no prototypes - no negatives x 19,354,795 ops/sec ±1.05% (55 runs sampled) Buffered, Math.round(), + &amp; - x 14,497,372 ops/sec ±0.83% (61 runs sampled) Buffered, Math.round(), + only x 15,947,766 ops/sec ±0.78% (61 runs sampled) Buffered, % to round, + only x 1,211,951 ops/sec ±2.36% (56 runs sampled) Buffered, % to round, + &amp; - x 1,137,573 ops/sec ±2.36% (51 runs sampled) *Player 2 has entered the game:* **Node 8.0.0-pre with chakracore** Version info: &gt; process.versions.node '8.0.0-pre' &gt; process.versions.chakracore '2.0.1.0' Test results: 8 tests completed. Normal trig functions x 16,195,696 ops/sec ±0.44% (75 runs sampled) Buffered trig functions x 495,498 ops/sec ±0.67% (73 runs sampled) Buffered trig functions - no prototypes (THE ONE TO USE!) x 90,035,809 ops/sec ±1.18% (70 runs sampled) Buffered trig functions - no prototypes - no negatives x 122,922,978 ops/sec ±0.43% (71 runs sampled) Buffered, Math.round(), + &amp; - x 26,171,809 ops/sec ±0.35% (72 runs sampled) Buffered, Math.round(), + only x 32,131,481 ops/sec ±0.38% (70 runs sampled) Buffered, % to round, + only x 808,433 ops/sec ±0.42% (72 runs sampled) Buffered, % to round, + &amp; - x 766,851 ops/sec ±1.38% (72 runs sampled) I will definitely take a very close look at node with chakracore when it's out in a production release. Not to mention that chakracore has a feature called [Time Travel Debugging (TDD)](https://github.com/nodejs/node-chakracore/blob/xplat/TTD-README.md) which lets you step forwards and *backwards* while debugging. TDD could make debugging code a lot easier since. 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [nodejs/node-chakracore/.../**TTD-README.md** (xplat → b60c024)](https://github.com/nodejs/node-chakracore/blob/b60c0243d43ec1e7e5875f516c88599d4077490f/TTD-README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhsmgu9.)^.
This was one of the first posts. I read the whole thing and looked everything up. I like the idea of Koa because it's by the express people. But now I think you must have been joking since your post does exactly what I said was confusing In the OP. And yeah, it seems that most of this is perpetuated by Facebook and people who use their libraries. Either way I'm happy that you showed me all these libraries. 
Then use Earth Time as any reference to the positioning of the sun is irrelevant. problem solved. seriously, we still live in an era of daylight savings and you guys want Mars Time. smh
https://github.com/Level/levelup is the easiest to get going. It's a npm package!
Daylights savings isn't a standards problem it's a government problem. Call your legislators! In the meantime, don't worry. Earth is obviously the priority, but Mars deserves to be considered too. (In before "But what about the belt?!?")
Momentjs is good for that
This is a little reductive but if things are hard to test then you can use it as an opportunity to write code that is easier to test. It leads to code that is more well organized and better structured for reuse. 
I liked that it doesn't seem to force you into schemas but haven't use it much to say more.
So, first of all, I could not get your code to load the data files because of chrome's CORS policy, does that work for you? What browser is it? However, here are some notes on issues I found immediately: - do all data fetching at the beginning (right now it's being done on every slider change event). If you have to, set the resulting json to a global variable, then you can access it inside your `createMap` function - the slider sends a `from` and `to` value, so adjust your `createMap` function signature to expect an object: l 78: `function createMap (options) {` - change your createMap call in the `onChange` handler to send an object instead of just a single value. Use these properties from the slider: l 159: `createMap({ from: data.from, to: data.to })` - then change your data filtering to remove years below and above the limits: l 105: `.data(json.features.filter(function(eruption){ if(eruption.properties["Start Year"] &gt;= options.from &amp;&amp; eruption.properties["Start Year"] &lt; options.to) return true})` Cool little project, I hope this is enough to help you get it working. 
Sorry it's not a school assignment or anything just something I'm doing on the side for my company I'm not really a programmer 
I haven't played with Heroku much, is it just a UI or can you get under the hood?
Heroku is a platform-as-a-service where you deploy your app. They provide the heroku-cli which allows you to deploy and run your app with just one command from your own terminal. You can get more details from their documentation.
I'd be weary of cross compatibility of dates across libraries if you did that, if every library ends up with their own date objects...
Another option is [Bookshelf.js](http://bookshelfjs.org/), which is built on [Knex.js](http://knexjs.org/). I have never used Bookshelf, but I use Knex all the time, and it's fantastic.
Thanks a lot. I'll try to change the code when I'm home. We worked with firefox. 
I always fully intended to write tests, but timeframe requirements made them a low priority. However, I did have enough time to write the code correctly the first time (for the most part). With my natural inclinations towards ultra dry code, testing all code paths manually as I write, and functional style usage, though my code has very few tests, it rarely is the source of bugs. At least, the bugs that do occasionally occur are things a unit test wouldn't help with: subtle interactions between different systems. The one benefit that I would gain with unit tests would be the ease of refactoring. As it is, complex systems that need refactoring are more difficult than they would be if there were more tests. Overall, most of my functions are maybe 4 lines of code. Unit testing all of these simple, pure, often branch-less functions is probably bordering on overkill. All that said, I haven't had the chance to actually work a large project with significant tests, so I might enjoy it after all. Getting started, however, is understandably difficult.
Hype driven development. Everyone says use react so people do that - popularity matters for any project.
Seasoned JavaScript developer here. This is the first time I've heard of this library. 
[removed]
`temporal` being lowercase bugs the hell out of me.
1. Have a discussion about supporting Mars time in JS 2. Consider it a serious topic 3. Think it's such a good idea that you tweet about it That's some solar system sized circlejerk right here.
*epitome...
Raw speed is not the only criteria.
We need stardates.
What, package managers?
In fact, I think that's a sore point for NPM packages in general, and it's a wonder that it hasn't been massively exploited already. You can also just create a package `reactt` or something, and put something malicious in the postinstall script.
Just please no. I know it's a fun mental masturbation exercise but it is impractical and unrealistic.
Javascript is one of the languages with the smallest standard library out there, what exactly are you referring to as bloatware?
Knex is absolutely brilliant
Depending on what you're trying to do, you might want to either use or study [youtube-dl](https://github.com/rg3/youtube-dl/). Don't let the name fool you, it will download most videos from most sites. I know I'm committing a faux pas because the program is written in Python and we're in /r/javascript, but this project is one of the most comprehensive, open-source video downloaders that I've found that nearly always works. It also has some nice features like "get auto-generated youtube subtitles for language X" that can come in handy. You could always try to re-implement the parts you need in JS, but just keep in mind that youtube-dl has [724 extractors](https://github.com/rg3/youtube-dl/tree/master/youtube_dl/extractor) that pick apart the pages to get the video stream. It does have some generic extractors that you could reference, but just be aware that some of the videos it downloads have to be remuxed to work properly as a video file.
Okay, so, those aren't all the same thing. Mongo is a NoSQL database. Horizon is an access layer for RethinkDB, another NoSQL database Firebase is a SaaS for document storage (and more) GraphQL is a way of accessing data. Imagine REST, but you don't need to build every path of the API manually. So, the choices you will have to make are how to store your data, and how to access it. You can use Postgres (as recommended in the comments) or Mongo or RethinkDB as a self hosted data store if you have the skills to set them up securely. Remember that if you store user data, keeping that safe should always be a priority. For small projects and prototype stuff, Mongo and Rethink are fine. For bigger stuff or things you expect to grow, stick with Postgres if possible. You could then build a GraphQL adapter for either of these, or in the case of RethinkDB, use Horizon to access the data. The third option is building a REST API. What's easiest depends on your choice of data store and your needs for accessing it. If all of that is too much, consider using Firebase. Then your data is stored on their servers, but you can access it rather easily from the browser as well as your node backend. Have a look at their pricing page first, because this works differently to self hosted stuff.
&gt;**Preact** killin' it FTFY
I've already tried that, it still comes up with something. Here is the url if that helps: http://sandbox.api.simsimi.com/request.p?key=d6d26a0c-59e2-496e-9f54-c0d3ad5ae88d&amp;lc=en&amp;ft=1.0&amp;text=hi
Do you think we should all just follow UTC all over the world? My boss argues for this but I haven't heard many others say it. Most people just accept turning the clocks as something we just do. Maybe it is weird that we do...
I've really liked snapshot testing react components, but by definition it's impossible to do tdd with snapshots. I do think behavioral tests like 'should fire fn on click' are the best tdd targets for ui components.
Because i can't wrap my head around this for my use case. Most likely because i lack good code isolation or test case creation. In my case its really about realtime and interactions, i run a virtual classroom which is based on multi students interactions and teacher video feeds. I guess if i had a "calculate my taxes" classes i could wrap my head better around it but right now i mentally use the multi-user full system as a excuse. Writing a new version, right now. hope to have better isolation and then possibly tests cases i can make
If you want to build canvas stuff use createjs
Weird, it's valid JSON.. :/ what does `console.log(data)` output?
I'm sure this is well-intentioned but think about it as if we were having the conversation 40 years ago about implementing Moon-time because the way things are headed, people will be living on the moon by the mid-90s. I have two words for the idea of supporting Mars time: Feature Creep. 
yeah
Well, at least you only need to _use_ one, as opposed to when Bower still was a thing :) (There are two of note, though: NPM and Yarn. But you're not missing out on _that much_ if you only know one of them, so don't worry.)
stardate 6174219: i've accidentally displayed advanced knowledge of temporal physics to a species who sometimes still believe their planet is a flat disc, clearly in violation of the Prime Directive. but honestly, i can't stand being down here any longer since the last election. just teleport me into the sun.
Please let our time lords handle this. Don't let some JS committee try to design a time system.
This looks promising - I have been looking for something a bit simpler than redux-form. I will try using it for a project I am working on atm 
Agreed. If your JS code which handles UI events is a thin layer that delegates most of the logic to a "plain JS" object, then you indeed can easily test it with just "does clicking this button call this function" :)
In which kind of changes do you typically run into this? I must admit I've not had a big issue with this myself, unless I'm completely changing how a certain part of the code works :)
feathers is a decent option
That doesn't sound dumb at all :) I would probably take a similar approach - if I was just prototyping something similar to how you describe, it probably wouldn't be worth having the tests just yet. But I think there could be some smaller parts of the prototype which could have tests though. For example, if I had a smaller module with some functions doing some fairly specific re-usable task, then it could make sense there. I think the biggest "problem" with this is that there comes a point when tests start to be more necessary. It's hard to accurately say something like "ok three months after you get your first paying customer, you must add tests!", but at least in my experience, eventually the codebase just becomes difficult to manage, testing it takes a long time, random things start breaking with unrelated changes... that's when it's like "oh I should've added tests for this" :) Sounds like you've also had some issues dealing with UI tests. I wish I could find a good solution for this - I think webdriver could be it, but at least so far, webdriver tests are just way too complicated to deal with most of the time. Not to mention they break so freaking easily...
&gt; write the code correctly the first time But how can you be sure if you don't have any tests? - I just jest (terrible pun is terrible) Anyway - it definitely makes sense that if your functions are "pure" in the FP definition, they are less likely to have bugs. On the other hand, those types of functions are also the easiest to write tests for in my experience. Whether it's overkill... hard to say, I'm sure you know that in FP style, you can fit a lot of stuff even in 4 lines :) It's definitely something where the developer needs to use their own judgement. &gt; Getting started, however, is understandably difficult. Let me play the devil's advocate here for a moment. There are articles showing you how to start writing unit tests, what's so difficult about it? 
Not going to lie, this was inspired from having some disagreements with Redux Form. Where the latter is a more magic high-level abstraction, this aims to let you retain complete control of your form, just skipping wiring it up. Be sure to let me know how it goes, I hope to continue improving this in whatever way possible.
Install the aXe extension and check the demo pages for accessibility issues. Demos should always set a good example of accessible form design. The main issue I see is the lack of contrast between the text and background. The NVDA screen reader picks up the placeholder text but aXe recommends labels as well.
Yeah, the thing with `baseUrl` for typescript is it doesn't actually affect the runtime behavior, just the typechecking logic. If I've got a baseUrl of `"baseUrl": "src"` then when I do `import bar from 'foo/bar'`, the type checker will look at `src/foo/bar` to find the definitions for `bar`, but when I run the program, it'll still try to pull the code from `foo/bar`. So you've got to use `baseUrl` for the typechecker, combined with some other mechanism to actually get your files from the right place, like `NODE_PATH`.
Basically, absolutely the same like the Atom's plugin. That's why it is on the same repository. Didn't see any so complete snippets, but probably it is because I'm new to VSCode. Actually, I'm pretty impressed by the VSCode! And for the first time in years (4-5+ years linux user) will use something from Microsoft. It feels soo more faster than Atom and it is really faster with more features - mainly the IntelliSense is most big feature. Didn't use such feature for years, back than I was using NetBeans for PHP development. edit: One big deal for Atom would be to extract their engine (like VSCode has Monaco highlight enigne) and create separate editor mainly for Javascript, CSS and HTML, without so many things and compatibility things. I'm starting to think for fork haha. Atom just not feels good when using Chrome and have lower RAM (like 4GB).
Are all of them using server side rendering? Because otherwise the times don't mean much as a comparison.