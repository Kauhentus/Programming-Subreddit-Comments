It would be. But it seems to me that all languages are either popular but verbose and bloated (e.g. Java), too fringe (e.g. lisp dialects) , or too low level (C++, Rust). JavaScript is at least acceptably lightweight and easy to use. Maybe adding some kind of type hinting would make things more palatable, I think. If we are to replace JavaScript with something, we need to find something concise and succinct, not big and bloated.
Slightly noisier, but I meant easier to comprehend. I don't need to scan to the next line to understand a line or learn someone's indenting style.
Hi /u/jonathanmh, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Thank you for such detailed feedback, I really appreciate that. I will look into each and every part of your comment and try to either fix it or explain/expand more, I raised [this](https://github.com/MartinChavez/Javascript/issues/2) issue to track this.
Add the "download" attribute to the download links. This will make the download dialog show up. The "content-disposition: attachment" response header can also be used. I'd add a '-' to the values in the improvement column: "-1764 bytes (-3.36%)". Do Brotli next. It already landed in Firefox and Chrome will soon follow.
&gt; They aren't required. http://www.ecma-international.org/ecma-262/5.1/#sec-7.9 Sounds like they are required.
I wasn't sure which of those 6 threads, you opened about your repo, should I answer on but this one got some replies so I figured, it's the best shot. I only wanted to tell you, I hope you don't get shadow banned and I enjoyed reading this and other learning repos, linked at the end. :)
Only way is to add the web app to the home screen and launch from there.
Charles is great but it isn't free.
Exactly. The fact is though, if you talk about coding without semi on Reddit, nobody cares what reasons you have, you'll be down voted regardless. It's not possible to have an intelligent unbiased discussion on the subject here.
They do not lead to errors if you are compiling with babel or typescript, which is the practical way people are using ES6 now. It will just compile the javascript to have them, while your source can remain without them.
That research you speak of shouldn't be done in a vacuum. In the real world, you'll also need to ask clarifying questions. If one can't be bothered to do this in an interview, such a person is going to be less useful on the job than someone that is willing to get right to it and asks those questions.
 https://www.npmjs.com/package/core-decorators also implements this
Ah, so it does. Oh well. I'm sure there are probably a few others out there that also implement the same. It happens. :)
I was hoping for a JSFiddle link or something... 
I figured it out. I will be posting to code pen soon. I have an new issue. $(document).ready(function(){ $(".board-cell").click(function(){ if (playersTurn == true) { $(this).text( playerChoice ); playersTurn == false; } else if (playersTurn == false) { $(this).text ( computerChoice); playersTurn == true; } if (checkWin(playerChoice) == true) { playerScore += 1; $('.playerScore').html(playerScore); alert("Player wins"); resetBoard(); }; if (checkWin(computerChoice) == true) { computerScore += 1; $('.computerScore').html(computerScore); alert("Computer wins"); resetBoard(); }; if (checkTie() == true) { alert("It's a tie"); }; }); }); How come this is not working EDIT: the boolean statement to check if player turn. it is always player turn......
I will be uploading to codepen soon.
you never set playersTurn, you only check for equality, also there is no reason to check if a variable has equality with true as just putting the variable on its own in the if statement would have the same effect: if (x) { } if (x == true) { } // these two statements are essentially equivalent
I set the players turn at the beggining of my document. Before the document.ready It will not update the player choice variable.
 playersTurn == false; that statement does not set playersTurn
It doesn't "fix" ASI problems, for example: function broken() { return { name: 'foo' }; } will still return `undefined` even when compiled with babel or TS, since ASI sticks a semi colon after `return`. You still have to be aware of the pitfalls of ASI.
Just because the ASI is putting them in for you doesn't mean they aren't required.
You're misinterpreting me entirely. I don't want you to change your usage at all. I just want you to admit that it's possible to do it safely. You act like my code is flaming and crashing constantly, but it's not. We have 90+% code coverage and we're in prod just fine. I also used semi colons plenty before. They never made me feel any better and certainly didn't improve code quality. They're just a single character. I've been doing it for a year. The water is fine. 
&gt; They do not lead to errors if you are compiling with babel or typescript Mh? They are bound to the same rules. If they magically guess-fix your code, it's a bug in the compiler. Try: var x = function () { console.log('2') } (function() { console.log('1') }())
"May be omitted in certain situations" does not mean that they are optional.
No, I'm not saying that your code is broken, I'm saying there's no reason to not use semi-colons. Yes, it's perfectly safe to do it _except when it isn't_. And the specific patterns that aren't safe likely won't be caught by linters because they're valid code. Saying "don't use those patterns" requires specific knowledge that plenty of new devs don't have. Even worse, which is more common: "use them but be sure to add semi-colons when you do" Everything else is opinion, though I think yours is ridiculous :P
When the bot for this sub messaged me about updating flair for a help post it made me notice the post flair menu was calling functions in that file. So, I'm guessing it's part of the Reddit web suite.
43 devs on my current team. Our back end is almost all groovy without semi as well. I agree mixing preference isn't a good idea. I fact, I was using semi before but this team doesn't, so I adapted. We of course have legacy teams, but they're dealing with stuff like delphi and java. Our team is given luxury of new technology, cloud, and freedom to bring I new things that aren't even necessary proven yet.
Just as an FYI, that example does not compile in TS. It does emit in babel, though. It also strikes me as a little odd to use an example like that when talking about not using semi colons. I could just as easily contrive an example where semi-colons are problematic, like: if (false); { console.log('what?'); } People who don't use semi-colons also write IIFEs like this: !function() { }() Which does not have the same issue.
Not to put too fine a point on it, but if you don't have to do it, how does that make it required? The spec says you don't have to do it always. You can omit them sometimes. It's not required.
Bower is also all but dead. So you're down to 3.
&gt; Please do not be disingenuous to me. I know you can see the red compile errors in your screenshot. That's an arity-related warning. Here, let me fix it: http://i.imgur.com/YPQA4qZ.png
This is pretty old (~3 years ago) but this [ycombinator](https://news.ycombinator.com/item?id=1547647) makes it looks like those who _do not_ are in the minority (about 10% back then). I suspect the growth in popularity of Babel and Webpack may have narrowed the gap a bit but I'd still guess more people prefer them than don't.
I kind of hate this example. Use a named function and invoke it. Problem fixed.
It doesn't really have to to with mutating for speed. In v4 lodash-fp will be merged into the primary `lodash` package as `require('lodash/fp')()` and the fp methods will not mutate values.
React is meant to be the V in MVC and Angular is MVC and I believe that they are / will be compatible 
This is it.
Right, but these languages use newlines as statement terminators, so there's no ambiguity. It's the not knowing whether the statement value is used on the next line that slows you down reading the code.
I just have a few issues I'd like to raise. https://github.com/MartinChavez/Javascript#anonymous-closures This section I would avoid calling "closures". This is better-known (and should be learned) as an IIFE, an immediately invoked function expression. This creates a closure, but all functions in javascript can utilize closures; an IIFE is just a special case of a function and does not have unique access to them. --- https://github.com/MartinChavez/Javascript#prototypes // By setting a parent object as a constructors prototype, objects build with that construct gain access to // all the methods on that object, including the methods on its constructor prototype. Baby.prototype = new Person(); This is correct, but not that useful in practice. It is more usual to just inherit from a parent prototype, not all of the instance properties on that parent. Like this: Baby.prototype = Object.create(Person.prototype); This will be especially frustrating to people if they attempt to use the pattern you indicated on a constructor with arguments which it validates. --- I'd also suggest just re-reading through your examples and fixing some of the formatting to be more consistent. I noticed that things like spaces before/after commas were inconsistent, as well as whether or not you used `function()` or `function ()`. A good proof read is in order! 
Here's a tip that will help you in the long term: Try to split the UI stuff from the heavy logic in your program. Don't be afraid of using functions; in fact, it's better to have many simple functions than a big complicated one. Use functions that you can test independently (this is called unit testing, btw). Test those functions with sample data before testing them live. Once you find your algorithm works, then do the UI stuff. See, programming shouldn't be about finding bugs in your code, but about designing good algorithms and modeling the real world problems you want to solve in the first place.
Your linked "bad mojo" says that arguments in Function.prototype.apply is fine. https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#what-is-safe-arguments-usage
The TL;DR of the article seems to be "use JSPM if you're using SystemJS; otherwise use NPM". Seems about right.
Author here: this is a very simple way to achieve hot/live style code reloading on the server. This module does not do any magic, it just uncaches your module and requires it again for you. However, in many cases (especially for stateless modules), this is enough to achieve hot code reloading.
Ext JS do this, a very famous javascript framework. the reason for this is, you can't use function(){}(); because it's not a valid statement, so why not use var xxx = function(){} xxx() or function xxx() {} xxx() it introduce unnecessary global variable xxx. that function is used for initialization, should stay private(anonymous) and been called only once.
Your AI is pretty bad, but it's a function al game, congrats!
[XmlHttpRequest2 supports file upload.](http://www.html5rocks.com/en/tutorials/file/xhr2/)
I feel like an x's and o'2 genius.
The reason I keep looking to move away from backbone is because of the immense amount of boilerplate, enhancements, abstractions, and third party library integration I need to do in order to get it to work the way some of the more "full featured" frameworks do. I had a junior dev take a look at the code from a recent project and he couldn't believe the amount of "supporting" code in there that wasn't directly related to the business logic. He almost quit when he had to trace through it to find a problem. What's worse is that the code is well organized, commented, unit tested to some degree, and made to be very modular. But the fact that there's a massive amount of code for one of these "stuffy business" type apps is daunting no matter what your level. And because I wrote it, and I think I wrote it well, doesn't mean the community or even the next guy is going to agree. So the quandary boils down to this: &gt; Do I build a custom framework that I'm happy with and that I have complete control over but has a massively steep learning curve for the next dev? ...or... &gt; Do I give up some of that control and intimate custom framework knowledge for a larger product that's (relatively) well documented, tested, and easier for my successors to work with. When I was young and didn't give a shit about anyone else, I would kill myself to make my custom framework as comparable to the relevant third party product just to claim some sort of personal moral victory. Now that I'm a little older, a little wiser, and everything in the JavaScript world is obsolete in 6 months, I don't have the stamina nor motivation to try and compete. At least not by myself. It seems now that my task when starting a new client project now to determine the lesser evil of the that fits the project. From what I've gathered so far, if I'm the only dev, I'm going to lean toward React and have my markup in JSX. If I have to work with a designer or someone maybe not as seasoned in javascript, I'll likely fall back to Angular. For my personal projects, I'm using my own hacked together franken-framework and there's nothing anyone can do to stop me!!!!! &gt;;)
I did this a few weeks ago (Rails, React, Paperclip). Basically I created a form and used a JS FormData object to send across my form data, including the Paperclip upload. The trick is getting your form data exactly correct, as your Rails controller expects it. Let me know if you'd like a code example and I'll dig it up.
[removed]
Couldnt find where to post it ;( 
Ye
Where do I post it? 
/r/java You know that Java and Javascript are 2 different languages, right? Double-check to see which you need or want. 
Thanks for your suggestions - I will change the website accordingly. Brotli compression was already added, just go to the details of a library (e,g, http://minime.stephan-brumme.com/react/0.14.2/ ) and scroll down to "Non-DEFLATE Algorithms".
IMO, separation of concerns. NPM is for node running on the serve, bower is for JS running in the browser. If you need a package in both places, it should be in both files.
I have a bit of difficulty with the idea of HTML in my JS files, aside from referencing DOM elements and events. Meteor.js and Handlebars still feel comfortable for me. Also, there are nice HTML processors, like Jade, which may not be possible to use in JSX. Is there a component framework that still allows separation of languages? 
Welcome to js! If you really do want feedback I've got a few basic critiques and an uninvited opinion (and some bonus tips for you): in general if you use var x, y = 1, z = 0, k = ( y + z); it's a little faster than var x; var y = 1; var z = 0; var k = ( y + z); try to use ===, !== as much as possible, it probably does what you think == does anyway ( === says "does a equal b", == says "is a something I know how to munge into b")... for example (1 == '1') and (1 !== '1') are both true because 1 is not "1"... this starts getting weird around null and undefined when using multi-line ifs, strings, and similar, put the operator on the end of the line instead of the beginning of the next line... this usually won't break things, but it's good to be in the habit b/c if the multi-line statement starts with a 'return', some js engines will insert a semicolon and ignore the following lines so that the following outputs "a" on some browsers; ;(function(){ return "a" + "b"; })(); lastly, jquery seems like overkill for this and may just be making it more complicated. Even if you want to learn all the latest frameworks and all the cool stuff jquery can do, it's worth learning the basics so you know when you need (want?) a framework and when you can just go w/ vanilla javascript. (though it is a pain now having to always google "how to x in javascript -jquery" so wan can hardly be blamed for thinking jquery IS the basics) bonus: - in case you didn't pick this up yet: 'var's are scoped to their function, if you don't use var you get a global. (w/ es6 in newer browsers except safari, variables defined with 'let' are block scoped... look it up, it's worth knowing about, understanding scoping will save you a lot of trouble) - use regular for-index like 'for(var x=0;x&lt;y;x++)'(+- swapping 'let' for 'var') whenever possible instead of for(x in y)... for-index is intended for arrays while for-in is for objects, and for-index way faster than for-in, and last I checked forEach was similarly slow
Is there some sort of corollary to the Turing test that speaks to the intelligence of the human being after being outsmarted by random AI? :) 
I think if you are posting a java item in a javascript forum, it doesn't mean good things about your future game project. Take the url, and change r/javascript to r/java like so: reddit.com/r/java
It's a pretty nasty implementation, but keep at it! You'll level up fast!
sounds like everything keeps running and require fetches the new file rather than the cached version
Brotil is already in Firefox Dev Edition, by the way: http://i.imgur.com/yPWVSeo.png
True, It's really easy to get stuck in the premature-optimization-triangle :) 
Right :) Updated version: function pascal(k) { var lines = [[1]]; if (k &gt; 1) lines.push([1, 1]]; for (var n = 2; n &lt; k; n++) { var line = [1]; for (var i = 1; i &lt; n; i++) line.push(lines[n - 1][i - 1] + lines[n - 1][i]); line.push(1); lines.push(line); } return lines; }
Have you tried profiling it? Chrome can easily show you when the GC kicks in.
Is this the first project from GA's WDI? 
nodemon kills your node application and restarts it. this allows you to reload modules one by one, as you change them, while the app is running.
It's fun, but the Ai in an idiot. I purposely leave chances for it to win and it never picked it. 
How is this different from "piping"? And good job btw.
I made a Chrome extension with an AWS lambda back end that creates a montage of Marvel comic book covers every 24 hours. I don't consider myself an expert in JavaScript but found the whole process easy. AWS has great tutorials. [Link to chrome extension.] (https://chrome.google.com/webstore/detail/wall-of-marvel/lbjipikblijeahgenjlenchakampaglh?hl=en) 
Does it work for native modules? What about modules that add event listeners (like [node-syslog](https://github.com/schamane/node-syslog/blob/master/node-syslog.js#L62))?
What is that? I coded this from scratch with minimal knowlege of JavaScript and jQuery. I mostly used google to help with the syntax.
It's a first!
Thanks for the input. I am very new to JavaScript. That was my first attempt at creating something in it. I am pretty decent with java. I am also going to check into "let" seems pretty handy.
I was very, and I mean very tired when I wrote this. I was coding for a few hours and getting hungry. What is the model-view seperation. I thought the timeout would be a good feature as well. I have no idea how to create divs and such without document.write That was my best idea to loop to create something.
Thanks, to be fair, I lost quite a few times myself.
npm3 is maximally flat. The nesting is there for a reason: to handle conflicting dependencies. With npm2 + dedupe and browserify you already minimize most of the duplication, except when it's actually needed. 
1. Your problem is you execute both methods immediatly. You need to wrap them in a function so RxJS can call them for you in the order you specify them. 2. Why are you using RxJS? What are you trying to acomplish with it? Just plain JavaScript: some_dir = path.resolve('./some_dir') rimraf(some_dir, function() { mkdir(some_dir, writeToSomeDir$) }) The RxJS way would look more like this: some_dir = path.resolve('./some_dir') rimrafAsync = Observable.fromNodeCallback(rimraf) mkdirAsync = Observable.fromNodeCallback(mkdir) rimrafAsync(some_dir).map(function() { return Rx.Observable.defer(function() { return mkdirAsync(some_dir); }) }).tap(writeToSomeDir$) But I don't see the benefit from using RxJS here. Looks more complicated than it needs to be. RxJS is all about manipulating a stream of asyncronous data. If you just wan't to execute 3 tasks in a sequence it is a bit over engineered.
Local variarables have little impact on performance and almost none on GC. Performancewise, "this.x" is maybe a tiny bit worse. But this is all clear premature optimization. It might make sense if you e.g. have a game and in when its complete you go and analyze things and then *maybe* come to optimization on this level. GC is mostly influenced by the amount of complex objects you create and don't reference. So in the ramp-up phase, it might take more time to prepare elaborate data-structures speeding up things at runtime. And it will also lead to more memory usage, but the GC will still not be affected because you create all those objects *and keep* them. Temporary objects are what creates the load for garbage collection. Temporary strings. Stuff like vector objects in games etc. There it can be helpful, e.g. to have a pool of objects that you keep recycling to e.g. represent the positions of your current on-screen objects in a game. But again, don't prematurely optimize. If you're on this level of optimization, it might also be in the range where it may be beneficial to use something like [asm.js](https://en.wikipedia.org/wiki/Asm.js).
why not just throw some money after reddit gold? i mean, if you are using reddit enough to need/want this you might consider supporting them? 
if avoiding GC is the goal one way is to create pools of objects and allocate/deallocate from the pool so you never release on object to the GC. 
https://github.com/blueimp/jQuery-File-Upload This is one of the most popular AJAX file upload libraries. It has the ability to upload directly to S3.
&gt; Just use semicolons like everyone else. No one cares for your desire to be a unicorn. Source code is the worst place to show others your uniqueness. Don't be inconsiderate. Just chiming in to say that the I think the debate has nothing to do with someone's desire to be "a unicorn" and "everyone else" isn't doing it, although from what I can tell- the majority of people do use semicolons. The whole argument here started because one person was irked by the fact that someone else used a slightly different coding convention than he did. Let's keep it in perspective. ;)
Holy crap that's awesome. Installing npm3 beta now :)
I don't think anyone actually avoids primitives on the stack in the mark phase, to my knowledge: you just instantly move on because the primitive by definition cannot reference anything. It just makes them quicker to GC than an object (where you have to enumerate over all properties).
Variables on the stack are still marked by the mark-phase of the GC, as they're GC roots (i.e., you have to keep alive anything they reference, and they can reference things on the heap).
What concerns are you even trying to seperate?
To be honest, this was part of /u/zuko_'s starter kit that I just left in because it seems to work. What would a good alternative look like?
Hi /u/mr_wiffles, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/tates911, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Upvotes say this is likely the best answer. That said, I'm a hobbiest and I'm simply not privy to how this plays into uploading a file. Mind ELI5 what steps are being taken with this approach? It sounds like it's literally sending the image data directly from the form somewhere? Perhaps explaining where I'm at will help. Here's what I thought happens: * A user uploads a local file into the browser. They click submit. * ajax uploads the file directly to S3 * in the meantime, Rails creates a new **Item** * S3 stores the image and returns a URL. On success, the URL is stored as an attribute, say *avatar_url*, of the newly-created item. * React then uses the *avatar_url* to render the Item's images.
Thanks for this. And pardon if I'm not making any sense, I'm a hobbiest: When using this approach, how would I update the "avatar_url" in my User model? I figure that's the end goal so my view can render images. Does the HTTPPost approach somehow have a return trip that would update the model via Rails?
Id like to discuss how this pattern can lead to bugs, and how it might be avoided. As SPAs become more mainline, page content comes in and go out in the lifetime of the page, requiring that objects can clean stuff up. They can cancel fetching, clear out store state, remove event handlers, etc. This requires that we implement lifetime cleanup methods like dispose(). When dispose is called, the object members are disposed and sometimes nullified. If async operations execute after dispose, they can access those things and nullref. So, then we would have to check for isdisposed on every callback... Or, we could solve this at the async helper to avoid executing code in a disposed state, eliminate the boilerplate and make it impossible to have that type of bug. What we have done in the past is to pass in an IDisposable to the async helper, to give the debounce/throttle/settimeout calls something to check before executing the callback. Something like: @debounce(this, 300) ... So now if this.isDisposed is true we can avoid executing async code, and elliminate a whole class of bugs. The solution isnt perfect unless the debounce solution can cancel async operation when isDisposed mutates. That could be solved with mixins that append dispose logic to the existing dispose on the prototype, or event listening on the IDisposable, or observables. 
This is the kind of guidance I was looking for, thank you. So in a React+Rails SPA that *does* have image uploading (avatars, etc), what's the best approach? Maybe just using an ERB file just for the New_Item_Form? Thanks!
Always. If a form is required, I'll be given a design for it. If it doesn't show error handling, I'll ask for a version that does. If I don't know what level of validation it should have, I'll ask.
Thanks for this. And pardon if I'm not making any sense, I'm a hobbiest: When using this approach, how would I update the "avatar_url" in my User model? I figure that's the end goal so my view can render images. Does the HTTPPost approach somehow have a return trip that would update the model via Rails?
I came here for cute lambdas, where are the cute lambdas?
An alternative to what? A `switch` statement? The alternative would be using the `createReducer` function that's in your project but unused. Then your reducer is an action map instead, [like this](https://github.com/stevengoldberg/UberByCity/blob/master/src/reducers/chart-reducer.js#L21).
&gt;Are my concerns overblown? I think so. &gt;Will the RoR focus take me off track? I don't think so. Do you want to be a web developer that happens to do JS or a pure JS developer?
Sure. So in my case I was creating a new Message, and the Message has_many Attachments (check out the Paperclip docs for adding multiple attachments to the same model). - [React Component](https://gist.github.com/raquelxmoss/98a4d5b052f913ccbdb2) - [Rails Controller](https://gist.github.com/raquelxmoss/d28ac0679c2c96281379) Please note that there's some fairly freakin' quirky code in here, particularly in the React side. I was under a lot of time pressure and had to learn React on the fly. There's a lot that I would change here, is what I'm saying, so be gentle ;-) I've pulled out just the relevant bits for you. Hope it helps, and I'm happy to help further if none of this makes sense. In my case I'm not using S3, but from what I gather that's just some configuration on the Paperclip side and should affect your controller or front-end. Correct me if I'm wrong though!
Pure JS is the goal, simply because of the flexibility with one language front and back. I also see a lot of companies moving towards the JS stack. Not saying RoR is legacy by any means, it just seems like sentiment is shifting towards a front/back that can be handled with one skill set. Maybe I'm not seeing it right, so feel free to correct me. 
Check out http://www.freecodecamp.com/ if you want full stack Javascript. It'll give you a solid foundation for developing apps with the MEAN stack.
Watch [this](https://www.youtube.com/watch?v=HkFlM73G-hk&amp;list=PLoYCgNOIyGABs-wDaaxChu82q_xQgUb4f) series on modular JS, specifically the first two videos in the playlist.
&gt;it just seems like sentiment is shifting towards a front/back that can be handled with one skill set. I can't say this is true or not. From my experience there is a difference between server and client side JS. Just because "it's the same language" doesn't mean the problems being solved are the same. If you don't have a job in the industry I think it is more important to focus on learning what can get you that first job. If it is pure JS, pick up node/express and a front-end framework. A lot of ruby shops are hiring, do rails. Etc. I hope this helps.
You may be right. I haven't upgraded to Node 5 yet.
Use local variables rather than messing around with the properties of some object. Local variables are cheap and they give the compiler the most freedom. Anyhow, as usual, before you optimize: measure. You always have to measure and compare. Otherwise, you won't be able to tell if you've actually improved anything. **Edit:** https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/?hl=en
I've never used Rails, so excuse the different terminology, but this is how I do it: The library has a hook that is called once the upload to S3 is completed. In this hook you can make a request to your Rails app and give it the S3 key of the uploaded image, and an identifier that it can use to associate the uploaded image with a user (such as user id). Then it builds a User object and returns it back to the client side app via JSON. $input.on('fileuploaddone', function() { $.get('/register_avatar_upload', { data: { s3_key: s3_key, user_id: user_id, }, success: function(data) { var user = data.user; console.log(user.avatar_url); } }); });
I'd be interested in seeing that app. Thanks for the link.
Good work, buddy. I think that what you're doing -- asking for a code review from a community -- is perhaps the most valuable way to learn programming techniques, styles, and conventions. As a JS developer, I'd write your code something like this: $(function(){ // Waiting for document ready. /** * Slidebars. */ $.slidebars({ scrollLock: true }); /** * Focus on search icon click. */ $('a.search-icon').on('click', function() { $('.sb-right input[type="search"]').focus(); }); /** * Fluid video embeds. */ $([ 'iframe[src*="player.vimeo.com"]', 'iframe[src*="youtube.com"]', 'iframe[src*="youtube-nocookie.com"]', 'iframe[src*="kickstarter.com"][src*="video.html"]', 'iframe[src*="screenr.com"]', 'iframe[src*="blip.tv"]', 'iframe[src*="dailymotion.com"]', 'iframe[src*="viddler.com"]', 'iframe[src*="qik.com"]', 'iframe[src*="revision3.com"]', 'iframe[src*="hulu.com"]', 'iframe[src*="funnyordie.com"]', 'iframe[src*="flickr.com"]', 'embed[src*="v.wordpress.com"]' ].join(',')) .wrap('&lt;span class="fluid-video"/&gt;'); /** * Headroom. * Fixed navigation when scrolling up. */ if ($(window).width() &lt;= 927) { $('.site-header').headroom({ "offset": 55, "tolerance": { down: 0, up: 20 }, "classes": { "initial": "headroom", "pinned": "subiendo", "unpinned" : "bajando", "top": "topando", "notTop": "noesarriba" } }); } /** * HC-Sticky. * Fixed sidebar when scrolling. */ if ($(window).width() &gt; 944) { $('.sidebar-primary').hcSticky({ innerSticker: '.mysticky', followScroll: false, responsive: false, }); } });
&gt; although from what I can tell- the majority of people do use semicolons Yes, the vast majority uses semicolons. All popular style guides also recommend to use semicolons. E.g.: https://github.com/airbnb/javascript#semicolons https://google.github.io/styleguide/javascriptguide.xml#Semicolons I also skimmed through a few others (jQuery, Idiomatic, etc). They all use semicolons. &gt; The whole argument here started because one person was irked by the fact that someone else used a slightly different coding convention than he did. It was started because you didn't use semicolons. You're using different coding conventions than *we* do. "We" being 95+% of the JS community. You are of course free to hate JavaScript's syntax as much as you want, but we'd still prefer it if you'd do this properly. For example, personally, I prefer to use tabs (size 4), but Dart's official conventions, which everyone and dartfmt is using, uses 2 spaces. When I write Dart code, I use 2 spaces. What I personally prefer isn't relevant. What's important is that my code looks familiar to others. Anything I do differently will only serve as a distraction.
`async` functions are a game changer
I always thought that Promises are easy enough to use, but it’s not only about code being more concise, it’s also about the ease with which you move between async and sync.
Calm down, man. I don't "hate" EcmaScript syntax. I've literally been writing it full-time for 10 years (counting ActionScript 3). I'd guess this is longer than most commenters in this thread, although I don't say that to brag, just to let you know that you can drop the condescension. As I said in my original response to the person who grumbled about my lack of semi colons- it's only something I've recently adapted to because my team at work uses this convention (and I find it difficult to flip flop between conventions when at work and at home). Don't make this an "us vs them" thing. I never once tried to convince anyone else to change their coding conventions. And honestly... yours is the first comment in this thread that has even riled me a little. Learn to live and let live. PS When I contribute code to any project I make sure to follow that project's style guide. Your examples are all irrelevant though because my choice in style for this small library literally affects no one but me. Should you choose to use it, you'll be consuming the Babel generated version of it- which contains plenty of semicolons.
Break it down to the simplest possible thing first. Does `document.getElementById('LunchMenu')` return an actual element? What happens if `document.getElementById('LunchMenu').innerHTML = 'Hello World';` is run? Then just work your way up to what you have now to find the part that is broken.
[removed]
If you wanna learn javascript, learn javascript. No need to add extra steps, you can always learn Ruby later. Plenty of free resources for learning to program exist, and learning to read and absorb documentation is part of the craft of programming too. Not everything we need to know is available in blog format, being able to pull knowledge from any source is a super useful skill. 
A lot of that has to do with the pull ex-MooToolers have in the TC-39 (a few of them are actively drafting proposals.) Kind of annoying, seeing as how MooTools is effectively dead.
So is it using the NPM repository and installing packages to node_modules so that I can use it as a dropin replacement for NPM? If so, concurrent installation sounds awesome.
So it's the new fetch API but it defaults to JSON? Any reason I should use this over the new fetch API?
Thanks for this! Looking into it now. If you have a moment, would you mind ELI5 Paperclip? I'm not sure that I understand what it's doing / what benefit it is bringing. Thanks again.
You pass the elapsed time as normalized value (0 - 1) and you get something back which starts at 0 and ends at 1. function linear(t) { return t; } function inQuad(t) { return t * t; } console.log(linear(0.0), inQuad(0.0)); // 0 0 console.log(linear(0.5), inQuad(0.5)); // 0.5 0.25 console.log(linear(1.0), inQuad(1.0)); // 1 1 Typically, they are used like this: startPos + (endPos - startPos) * easingFunction(elapsedTime / duration) E.g. from 100 to 200 in 4 seconds, 2 seconds have passed, and we're using the linear one: 100 + (200 - 100) * (2 / 4) = 150.0 150 is in the middle. With inQuad, we'd be at 125 at this point in time.
I disagree. [I am writing one](https://stefanoborini.gitbooks.io/modelviewcontroller/). The amount of variation and complex problems involving MVC is mind boggling. Everybody knows the idea behind MVC, but when it's time to apply it in the real world, it's a damn nightmare. 
I am finally starting to understand it! Thank you, maybe I'll find a way to add it to that library I linked.
Yeah, it was pretty disappointing to read that. The committee shouldn't be making the API worse just because some library monkey patched in an awful way.
Generally speaking, yes. Installing packages works fine, publishing them is not implemented yet. Scoped modules are coming next week. You can also configure a custom registry if needed.
Hi /u/SilverSeven, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
For real, I wasn't aware of this until now and can't believe what I'm reading. This is a decision that is going to be making people [WTF](https://stackoverflow.com/questions/3314989/can-i-make-a-button-not-submit-a-form/3315016) 5, 10 years from now - and the steering comittee doesn't care because it will break things in the short term?
I normally don't like being the Thought Police, but is an [IED](https://en.wikipedia.org/wiki/Improvised_explosive_device) really what you want this otherwise-useful project to be associated with?
I've actually already been bitten by this a few times. Writing "contains" because it's called "contains" everywhere is a very easy mistake to make. In conjunction with JavaScript's shitty tooling, it's really annoying.
Lovely, thanks!
Your beef is not with TC39 but with browser vendors and, in some sense, web browser users. No browser wants to be the first to make a breaking change like this because users will just switch to another browser that works better for them. TC39 should not be in the business of standardizing things that won't get implemented, so here we are.
Thanks, that's a little more like the insight I was looking for. I've been playing with meteor off and on for a year now, mostly using telescope. I like it. RoR just seems so heavy and out of place in comparison. This is why I was asking because I'm seeing quite a few companies using React and Angular and I feel like jumping into a framework that seems to be lessening in demand, requiring a completely different language, would be a complete waste of time in the sense of working towards a full stack JS position. 
Pretty sure GP is a parody of TC39 conspiracy theories. There's the MooTools lobby, the revolving door with implementers, the secret society of SmallTalkers...
So you're saying that document.getElementById('LunchMenu').innerHTML = 'Hello World'; doesn't work, but document.getElementById('LunchMenu').innerText = 'Hello World'; does?
&gt; Asking JS devs about algorithms is pretty inappropriate most of the time. Unless you want them to also do back end stuff if the need arises. I have yet to work at a company where I haven't done front and back end stuff.
&gt; I also think it's probably because it makes them feel smarter. That's a completely asinine assumption, probably made just to make you feel smarter. The idea that everyone who asks about big oh notation, something taught in a few different classes in a standard CS education, is doing it simply to stroke their own ego is preposterous. It's certainly not like the devs doing the interviewing can just mandate that they are going to follow some new, all day process.
I hope you know the ternary statement is superfluous there. You're not getting extra points for bloating the code.
His can easily go far above 50.
I think with the whole java method accepting a string arg gets an int will cause an error, unless you overload your methods. Like Public static void method1(string a){} and then do public static void method1(int a){} This way they are two separate methods but the complier will know which to choose. Not sure if this is what you are looking for.
You did a good job. Try pong next and post it again.
Please explain to me how obscure algorithm questions find out any of the things you listed? If someone can ship product they can do everything on your list so I agree with you, but you don't find that out with an algorithm/complex technical heavy interview. Same with your poisoned apple thing, I 100% agree, but you don't find culture fit by asking if they know about algorithms for half of your interview do you? 
Rest/spread properties are really key for me when it comes to passing around named args, in the same way that rest/spread params were key for variadic functions. They're ridiculously expressive. Really looking forward to them being promoted into the standard.
Working on a duck type shooting game. Pong seems pretty challenging for me right now. I have no idea how to set up something like that.
Hmm.. I just tried it in my actual app code, and it didn't crash because of my app's error handling. However in the the example it does crash as there is no try catch around the request handling code. I could add a try/catch inside the reRequire function, but it is also useful to let it throw so the error shows up. Not sure what to do about it for now.
Hmm, I haven't tried it with native modules yet. For event listeners, I think it may not work properly as the event listeners might not be properly cleared.
Thanks! I'm not exactly sure how piping works, I could be mistaken but it looks like it watches all files and on any change restarts the whole process, kind of like nodemon except it is in a module form. re-require-module on the other hand will reload code changes for specific module(s) without restarting the whole process.
I am a developer. I have experience of working in different programming languages like C#, Haskell and Javascript. I noticed that all of them has similar library. Prelude for Haskell, Linq for C# and Undercore, PreludeLs for Javascript. A lot of functions are common: map, filter, concat, join and so on. In daily life I need work linux shell and got the understanding that this kind of library can be applied in shell as well. So I rolled my sleeves and implemented the prototype. Please checkout http://nixar.work . It would be great to read your comments. Thank you
This fetch api? https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API It looks like it isn't well supported across browsers. I am not sure that would be an option for major sites, right ? 
Huh cool, I'll check it out.
Nope.
I just tested `document.getElementById('element-id').innerHTML` on Safari with iOS 9.1 and it works fine for me. Do you have a webpage anywhere where you can reproduce this issue?
Can you build this in codepen or something similar and post a link to it? It looks like this uses an external file so no one can grab the code and run it and the description of the desired behavior is kind of confusing.
Hey, thanks for getting back to me with that coding example! That is a nicer solution. I will update my code. :)
The consensus is that you use `Proxy` instead. 
Does Proxy have same functionality? What's the difference?
"includes" ~ that's intuitive...
The method doesn't always exist. For example Object.create(null) will create an object without a prototype, so dest.hasOwnProperty would be undefined.
&gt; The Proxy object is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc). https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
Use XMLHttpRequest to send the form. Example here : https://github.com/maxbeatty/aws-s3-browser-upload-example/blob/master/upload.html You can listen for "load" event (when upload is completed) and make a call to your backend there.
First, you need to get a reference to the input field you want to change the border color of. You can do this using a variety of methods such as [document.getElementById](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById) or [document.querySelector](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector). Then, you can edit the values of the [style property](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style) of the input field. In this case you'd be editing the borderColor property. I make a [quick JSFiddle](https://jsfiddle.net/joy2hxy6/) demonstrating this.
Yes, I saw the textured face, I think I saw it working.
what are the solutions to these?
document.getElementById('id-name').style["border-color"] = "#000AAA";
well put.
Side note, but I also like to use ["element.classList"](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList#Browser_compatibility) (IE10+) in javascript, instead of directly changing CSS
Thank you!
Yeah, it's definitely a bit cleaner to go with class toggles if you're dealing with a finite set of colors. 
&gt; x ** y Argh, is this really necessary? I get that some people write code that's more math-centric than I do, but it's not exactly the primary domain for JS. I really don't need us to end up with the equivalent of [this](http://www.ozonehouse.com/mark/periodic/)
That comparison seems a little unfair. Exponentiation is hardly unusual in programming, many languages already use `**` as the exponentiation operation, and it's a backward-compatible change. It's not as if JS is about to become Perl6 or Haskell.
Can you elaborate on what you mean? Every prototype chain ends in null, which is an object. (See `Object.getPrototypeOf(Object.getPrototypeOf({}))` which is null)
If you're doing WebGL there is a good chance of that being very relevant. On the other hand, most of the time you just want to do `x^2`, which could be written as `x*x`.
I know. It's making me cringe a little and wonder where we are really heading with JS when you need a million frameworks and libraries. I don't like all this complexity being stacked on top of complexity because someone says 'I love library X but I think we could do this bit a little differently' then you end up with a library and bolt ons strapped to it.
No null is not an object. Null is a literal which represents an 'empty' value. https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/null The prototype of an basic Object is null (i.e. empty). If you create an object with Object.create(null) it doesn't get any of the standard object methods like hasOwnProperty. These are all added in Object. https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object
I don't know what RxJS does, but if you have async methods, you will want to have a look into [Promises](http://www.html5rocks.com/en/tutorials/es6/promises/). 
There is worse. Promises do recursive thenable assimilation because jQuery has a broken promise implementation. Which in turn means async/await will be broken with anything that isn't a promise, and you will be forbidden to add the `then` method to any object that might need to be wrapped in a promise (or essentially, just "any object"). (Its worse because it wont break any existing code, yet its still deliberately broken to be "compatible") Fun stuff, TC39. Fun stuff.
Why would you want to do that? Adding a bunch of non semantic markup to add inline-styles which we generally want to avoid anyway does seem like a step in the wrong direction.
You're missing a `)` after `.val()` Other than that: - Always cache jQuery references - You can just do `.change(setFullname)` - Get better field names :)
Curious about this, because my experience is... completely opposite. Yes, RoR feels old and boring. And it is old and boring. And also, a whole lot of people have made a whole lot of mistakes with it, documented them and created solutions for them. I love Meteor, but every time I'm working on a project with it, it feels like I'm on the very frontier of development. How do you add additional authentication backends to `accounts` package? The entire documentation on that thing is three paragraphs, and I ended up hunting down couple opensource implementations (also undocumented) and trying to puzzle out what are the important things in them. In RoR land, there's `devise`, and first hit in google for 'devise custom authentication` brings you [here](https://github.com/plataformatec/devise/wiki/How-Tos#custom-authentication-methods). Deployment? What do you use for meteor? `meteord` docker images that download the whole (latest! not the one you specify in app!) meteor installation on every deploy? `mup` that has bugs out of the wazoo, no concept for zero-downtime deployments, no built-in rollback strategies? `mupx` that's not officially released? Just build the app and copy it by hand? And how do you integrate that with CI platforms? Come to think of it, how do you install the precise meteor version you are using on your app on the CI service? On RoR side you have Capistrano with detailed documentation, hand-holding blog posts, or official docker image. As for testing, that's my main beef with Meteor. The old and boring RSpec + Capybara duo popular in RoR land is a breath of fresh air after spending days puzzling out why sometimes Velocity decides to launch multiple tests in parallel that step on each others toes and trying to understand cryptic `beforeExample timed out` errors when in reality the selector you are looking for does not exist in the page. I have RoR and Meteor apps in production. I feel safe running working on RoR apps. I know that if something breaks, I'll know why, and be able to either push a fix quickly, or determine and roll back the changes causing problems. Meteor? My heart is racing on every push to production, and I'll be nervously checking the metrics and error reports for an hour or two afterwards. I love working on small Meteor projects. Side stuff for myself. As long as your use cases are simple, it works beautifully. But holy hell is it not ready for building important, feature-rich apps in! 
Thanks for a quick response! We already have jQuery references when the page is loading from the beginning. I also noticed the missing `)` after `.val()` but that didnt solve the problem. Getting better fieldnames would be a nice solution but sadly thats not possible :)
No it's backed by the good old XMLHttpRequest because the fetch API support isn't good and all use cases are not yet implemented (and consistently). 
Is this smaller than github fetch polyfill though?
What browser are you using? Depending on the browser you use offsetX, offsetY (Chrome) or layerX, layerY (Firefox). The standard practice seems to be to check if one is defined, and if not, use the other.
offsetX works in firefox (see above) unless you're &lt;= 38.
I almost always keep [Repl](https://repl.it) open. If not, I also have [Node.js](https://nodejs.org/en/) installed, and if that's not enough, remember that your browser is a JavaScript interpreter. Assuming you're using Chrome, it's just a `Ctrl + Shift + J` away.
Generally I would consider this a bad practice. What is he guarding against, really? Someone doing something dumb. Dumb people will find a way to fail, so guarding against them is a waste of time. Instead of it blowing up on this line, its going to blow up somewhere else. At some point you have to just say, yeah we get that JS is ridiculously dynamic and you can do all kinds of dumb things to shoot yourself in the foot...and if you do this will blow up...so don't do that.
Console is your friend
np. If you have anymore questions about them, feel free to ask.
FYI, karma is just for the browser, so the opposite of node.js. If you're testing code for the browser, you can use karma + jasmine, for node, you just want to use jasmine.
Another good testing framework is [Mocha](https://mochajs.org/). It's similar to Jasmine, but I find the syntax a little easier to read in Mocha (w/ Chai). I'm not a fan of camelCase and prefer the dots between each word. 
Its not changing the value from field1 into field2. Ive checked the debugging but no errors so the code for this might not even be the problem. Thanks for your input! :)
Good compilation
The only logical explanation I can come up with, if you're not getting errors, is that there's another event attached to the `onChange` of that form element that's stopping the event before it gets to your code. You can check in Chrome's web inspector to see if there are other events here, as well as what they are.
I would be fine with duct taping LAMP with some JS for UX. Shit gets done then it is done.
That code doesn't work actually. You need a timeout between actions for the server to register it.
something like document.querySelectorAll('p').each(function (p){ var TextInsideLi = p.innerHTML if (TextInsideLi == '0') p.innerHTML = "New" else p.innerHTML = "Old" }) or with a for loop for (p of document.querySelectorAll('p')) { var TextInsideLi = p.innerHTML if (TextInsideLi == '0') p.innerHTML = "New" else p.innerHTML = "Old" }
i'm working on a larger mean.io project that I believe uses swagger and jwt for it's auth and api calls. After sending login credentials to the login API, I receive that token, but am expecting a jwt. Sorry for not being more clear, I think i'm a little over my head as I'm trying to piece together how this all works.
At what point did I say obscure algorithm questions find those things out? You're arguing just to argue.
I used this code (JQuery): $('canvas').mousedown(function(event) { var x = event.offsetX, y = event.offsetY; }); 
Thanks again for answering, and sorry for my "stupid noob" question! :)
&gt; And we have to trade, whether we like it or not, since frameworks aren’t free. This talk is very diplomatic about an important and extremely sensitive subject. Even hinting at the idea that developers may not need frameworks causes people to lose their damn minds.
Beautiful work, and looking at your changes I can see just how close yet so far away I was. I'd like to chalk it up to me looking at the same code for way too long, but I'm not entirely sure how accurate that would actually be!
Tape + TAP + Faucet... Keep it simple. Use Node.js. You can also use Cheerio.js as a lightweight, non-bloated jQuery drop-in replacement to test dom functionality on the server without doing all the work with a browser &amp; html you mentioned. Jasmine &amp; Mocha are both useful also, but they have way too many features... too much freedom to test things in complicated ways. Testing should be simple so that people can get into doing it without it being a painful process. Try doing some of the exercises in the javascript or ecmascript branches on http://exercism.io. It forces test-driven development practices and will expose you to good ideas about how to go about it.
I disagree that any of these 3 points are unique to frameworks: &gt;Learning it. You have to take time out to learn any new framework: what it means to write “idiomatic” code for that framework; its patterns, practices, and ways of doing things. This is no different to the web platform itself. There’s no free ride, you’re just swapping one set of issues for another. Unless you are working 100% on your own, forever -- you are likely going to have to learn how someone else writes their code and conform to it, or pick a pattern yourself and teach other developers about it. Patterns, practices, etc. are important parts of all good code, not just frameworks. &gt;Re-learning it. One day you’re just bimbling along, developing your app, and in the console you see a warning telling you that there’s been a deprecation, and that you need to update your code. That often requires figuring out what the latest version of the framework needs you to do differently, and that may also mean updating projects that shipped with older versions of the framework. I have to re-learn my own code all the time. At least when React or Angular deprecates something, they clearly document it. It's a crapshoot if other developers will do the same for their custom bit of code. &gt;Debugging it. Frameworks, like any software, have bugs. That’s to be expected, and it wouldn’t be any different if you went vanilla and wrote your own. Debugging a framework, however, often ranges from difficult to impossible. If you find the issue, you may have to keep your own frankensteined version around with a monkey patch applied until the real fix lands in the framework’s production build. Again, this seems to be written with the assumption that custom code won't be difficult to debug or require monkey patching to avoid rewriting entire sections.
I'm very open to suggestions for features as well as bug reports. Thanks :)
To be fair, Ruby calls it `.includes?` as well. :/ /u/edwardjbeckett 
True that! It's also part of the reason that I didn't code the array for-loop ```arguments``` copy into the example (since as you mentioned the for-loop ```arguments``` copy is not necessary when using Function.prototype.apply for V8). I mentioned the "bad mojo" since the example introduced the ```arguments``` feature which can have some hairy issues if you are not aware of them. And you are totally right, the use of Function.pototype.apply in this case shouldn't cause any issues in V8 engines (like used in Chrome or Node.js), but hopefully more people are aware of potential performance problems the usage of ```arguments``` may incur. ♒★The More You Know ♒★ :]
I need the code to run in Firefox.
Thanks for replying but I don't know any JQuery yet so I was hoping for a javascript solution.
You can accomplish all of this with a Makefile as well. I understand that people often finding writing JS easier, but I prefer not adding a bunch of dependencies that just make whatever tool you are using Gulp/Grunt compatible.
The complexity of the actual UI to be built needs to be factored in to the choice of framework (or no framework). For small / simple UIs like Todo, it's easy to argue that the bootstrap time of whatever.js framework is an unacceptable trade off. But what if we're building something like Gmail or the main Facebook feed or the Starbucks mobile app?
Last commit: 5 months ago
This is not new. Nothing has been updated since the [reddit post from June](https://www.reddit.com/r/javascript/comments/38l1t0).
Where's mithril? It would wipe the floor with these other frameworks.
If you are writing something that needs more than 200 lines of jQuery, you probably need a framework. 
http://imgur.com/nJWHoel
I think it's important to keep in mind that while startups today might be using all the newest stuff, the successful startups from 5-10 years ago are still kicking around and by and large will still be using their original tech in some form or another. These can be very nice places to work as they're more settled. But sure, if it's the excitement of a new startup you crave, then it makes sense to be looking at what's being used. You're right though, Node and Python back-ends seem to be pretty big at the moment. Python by the way is a great language too, I've used it for some side projects and it's great fun to work with. Node is only confusing in as far as there are seemingly unlimited ways to tackling a problem. The Ruby and Python frameworks try very hard to establish a methodology, whereas Node is all about picking and choosing a variety of small packages to custom build your own toolset. I'm a fan of both approaches, IMO if you're not hugely familiar with MVC then Node suddenly becomes a double edged sword and you might find yourself trying to reinvent the wheel. If you're comfortable with it though, then it's amazingly fun to use, and just feels super creative. I know that sounds fairly critical, so I should probably balance that out by saying that while I think Ruby on Rails can be pretty great (and it's super quick to get up and running), it's also very much a "my way or the highway" framework, meaning there is exactly one way of using Ruby on Rails, and if you try to go too far outside that then it will vomit on you. So anyway I guess what I'm saying is - sure Ruby on Rails is still relevant, tons of great companies are still using it. And Node and Django are great too. My two cents, learn to use Node alongside either Rails or Django. And stay away from Meteor, no matter what anyone tells you.
There's another reason besides defensive coding you'd alias a prototype method to a local variable - access speed. If you use the default `dest.hasOwnProperty()` call, the value of `hasOwnProperty` method is resolved like so: - check the instance - get the prototype of the instance's constructor - check the constructor's prototype - get the prototype of the constructor's prototype's constructor - check the constructor's prototype's constructor's prototype... - ...all the way up to `Object.prototype` And since `hasOwnProperty`is an `Object` method, it's literally going to find it the last place it looks. All those pointer hops between property references are fast, but add up quickly. Looking up a local variable is one of the fastest things you can do in Javascript, so the alias is faster. Of course you get the additional overhead of two function calls instead of one (`hasOwnProperty.call`, which invokes `hasOwnProperty`), but the use of `call()` here is also indicative of a speed optimization, as `call()` is [miles faster](http://stackoverflow.com/questions/23769556/why-is-call-so-much-faster-than-apply) than its cousin `apply()`. Add to all that that this code looks like it's designed to be called a LOT and it's pretty likely they're optimizing for both safety *and* speed.
I think one of the tricky parts is that most apps don't have a clear cut "we're done adding features". ToDo is is such a contrived example, but even ToDo apps like [Wunderlist](https://www.wunderlist.com/) are continually adding new features, meaning your code base is going to continue to grow indefinitely. So while the initial prototype or concept may be simple enough that a framework will add some (development) overhead, you will save time in the long run as the project continues to grow.
"Learning" is such a weird argument for me to hear *against* frameworks. You pay that cost once for frameworks, and then you can reuse that knowledge to immediately understand another code base. When you avoid frameworks or hand-roll your own, you don't get this benefit - or at least, anyone else looking at your code base doesn't. VanillaJs only gets you so far in terms of handling application complexity, sooner or later you'll need some kind of structure.
I think a lot of people would consider mithril, riot, vue, etc. to be more of *libraries* rather than *frameworks*. Mithril openly invites you to make your own micro framework to sit upon it to abstract things like `withAttr` away. Contrast this to angular, which has "the angular way".
It always takes me some time to fully understand the structure of the code of someone else. The example you've given doesn't really bother me though.
I think swapping click to onmousedown would solve this better
&gt; Possible Objections &gt; &gt; * “TodoMVC isn’t idiomatic.” &gt; * “TodoMVC isn’t my use-case.” &gt; * “A Nexus 5 / iPhone 5S isn’t what our users use.” &gt; * “It’ll be better in the next version of &lt;insert framework here&gt;.” Interesting set of possible objections, however, I feel it is missing one: &gt; They're don't tax the system that much. We're still talking about file sizes smaller than 1MiB, that's probably about the same as all images **(Please note, I am referring to the total size of all images here)** you have and considering this is at page load I suspect there's not much of a latency overhead. Secondly, I doubt anyone is going to really notice that additional &lt;1s bootstrapping time. Some of the apps (eg: Facebook) start slower than that.
There are other benefits that frameworks give you. Where I work, there's not a lot of strong, in-depth knowledge of how to do front-end development. So angular or other such highly-structured framework allows someone to contribute to the code base without having a deep understanding of things, since it's just MVC, and a lot of people know MVC. Plus, if you want to hire someone new, they will have a tremendous advantage if they already understand one of the cookie-cutter frameworks that are being used. I can make assumptions about how an angular or backbone app is structured that I can't really make about a mithril, knockout, vue, etc. app. So like everything else in javascript, it's a more nuanced decision than anyone would like it to be.
As soon as I read "Parse HTML ...", I was reminded of this famous StackOverflow answer: http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454 
It can be, but that's often why we have code standards and style guidelines. Everyone writes code just a little bit differently, but if your team has a consistent way to write these things it can be mitigated.
lol
Key point I preach over and over: &gt;For me the results are pretty clear: there appears to be a pretty hefty tax to using Frameworks on mobile, especially compared to writing vanilla JavaScript. From the comments, it appears most, if not all, of everyone here do not know Paul Lewis.
This actually reminds me a lot of mithril (in livescript since the link is in coffee): m 'p' 'Hello there' // produces &lt;p&gt;Hello there&lt;/p&gt; or people = [ {name: 'Joe'}, {name: 'John'} ] m '#container.wrapping-class' [ m 'ul' people.map -&gt; m 'li' it.name ] // produces &lt;div id="container" class="wrapping-class"&gt; &lt;ul&gt; &lt;li&gt;Joe&lt;/li&gt; &lt;li&gt;John&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;
X-Post referenced from /r/programming by /u/metlhead05 [Aurelia Beta 1 Released today!](https://www.reddit.com/r/programming/comments/3t2ikv/aurelia_beta_1_released_today/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher)
Your canvas element has an offsetTop as well as an offsetLeft. It also has a width and height. These combine to give you a "box" that represents your canvas element. It should be mathematically trivial for you to see if your mouseX and mouseY is within this box, then perform logic.
That might be true for the developer, but I think the author is pointing out this convenience to the developer comes at a cost to the end user. Its not about whether frameworks are right or wrong, but rather how far can you acceptably abuse your users.
Edge 13 is a big improvement. Their score on HTML5test.com also made a big jump. They really did a great job. I really like this trend. If they keep it up, Edge 14 will be amazing.
` var __someVariable; or var _$;` in particular looks like the output of an automated JS compiler. That project might be using CoffeeScript or Babel, and you're looking at the compiled output rather than the source code.
What does it matter if a reader knows the author?
npm + tape
👍👍
Have tried Mocha, Jasmine, CasperJS, but have had the most success with [QUnit](https://qunitjs.com/) It was made by jquery guys so you just check for states of jquery selectors. Use SinonJS to replace any api call and you're gold. I also appreciate how it has the state of pass/fail icon in title of the browser, so you can keep an eye on it in another tab as you are updating code. 
I think the real question here is 'how many of us are actually doing that?' The issue is more that people often throw frameworks at everything, for various reasons, and in doing so are damaging the end product. You can have structure without using a framework. But yes, for huge applications like those you mentioned, they certainly have their place.
I feel like the more experience you get, the less you care (or have opinions about) syntax, spacing, casing, where parenthesis or commas go, if you have underscores or unicode-piles-of-poo for variable names: the only important things are consistency and sound architectural choices. Reading lots of code in lots of different languages helps you get out of the "my way, else it's garbage" mentality and makes it easier to comprehend and assess new codebases.
Some are disagreeing with the author as if they would know better. One would be less likely to disagree with Crockford than with Joe Blow. The author is not Joe Blow.
Paul Lewis is a smart dude and has evidence to back up his conclusions. However, he doesn't understand every persons organization and what developer 'ergonomics' means to them, and that's what people are discussing in this thread... "investing in knowledge of the web platform itself is the best long-term bet" may not really apply to someone whos building a one-off utility app, or a startup moving quickly, or whatever other scenario you might come up with where the cost to the user of framework bootstrap time is worth the benefits.
I'm sure he's not trying to tell everyone in every situation how to do what's best for them. However, his points are true in every case I've touched in my 11 years of doing this and the wise developer would follow the points he's outlined.
You're probably right.
It is also nice to add a new item to the end of the list (the place where list additions usually end up). This results in a minimal diff in your vcm as well.
Have you measured that? When I was at Google, we had fairly precise models about how much $Y in revenue we would lose for every X ms in additional latency. The exact numbers were very confidential, but I'll say that 20ms of additional latency would be enough to make a material impact on the stock price. Obviously, it'll differ from business to business - 1s of loading time for GMail is negligible, but 1s of loading time for Google Search would basically kill the company. But it's often *a lot* higher than people think. [Amazon reported](http://www.fastcompany.com/1825005/how-one-second-could-cost-amazon-16-billion-sales) 1s of load time would cost them $1.6B in revenue. Many smaller publishers or SaaS vendors have reported increasing revenue by hundreds of thousands of dollars just by gzipping and minifying their pages.
Any reasonable editor and linter should give you a notification if you miss a comma. 
&gt;is so much easier to see when you miss a comma I use a linter for that. 
I said weeks rather than months, so, 4x. `Never` isn't about taking 100000000x longer, its about taking longer than the business deems worth it. No clue what you're trying to say on the second point in relation to this discussion. 
This highlights the importance of deciding on a style guide before starting a project. I've worked on a project before where I pushed for a style guide but it got shot down as "we dont have time to deal with code style", this resulted in every js file looking insanely different to the last, and even every function within a file looking different, 10 different ways to do the same thing. CoffeeScript made a huge difference because of it's opinionated significant whitespace style. Luckily, eslint is now really good and airbnb have open sourced their style guide to plug into eslint (https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb) . This keeps me inline, and also means that everyone else writes code in the same style. You can check out the airbnb style guide here https://github.com/airbnb/javascript
Yeah... 99% of my underscore/lodash usage was _.extend. Babel now has an inline replacement. So... I don't use _ anymore.
nodebrew?
&gt; or if you want to comment something out temporarily. [ thing, //thing, thing ] It just changes the top vs bottom being the weird one, but in this case trailing commas are usually okay except in old IE.
There are also style guides and training for handwriting. I'd say the metaphor still stands. 
I will admit, my 1MiB size was high, however, an important thing to note here, especially your argument is "stop eating my data limit" is JavaScript is cacheable. It doesn't change as much as dynamic content, which you presumably have if you're putting in the effort to learn JavaScript. Additionally, &lt;1s bootstrap time is acceptable if the business deems that it is not worth it to spend the money to gain that less-than-a-second speed boost on page initialization, which if you're using a framework, you're opening yourself to implement a SPA much more easily, mitigating subsequent init times.
&gt; at all I don't think that this kind of dogma is helpful consisting that GP posted an example of a _very_ common app that takes longer than a second to start.
Provide a test case. If you'd added the event listener to the canvas element, clicking elsewhere won't have any effect. **Edit:** I demonstrated it with [that demo](http://jsfiddle.net/m3yw1gu7/): http://i.imgur.com/UE01RyQ.gif As you can see, the pink rectangle doesn't move if the cursor is outside the canvas. The canvas doesn't receive any "mousemove" events.
Holy shit! Awesome! I'm so happy! Unfortunately I'm not sure about the S3 side of things, as yeah, I was just using Paperclip to store things locally. Looks like you're nearly there though, well done!
&gt; So while the initial prototype or concept may be simple enough that a framework will add some overhead, you will save time in the long run as the project continues to grow. I may be misunderstanding your argument here (and apologies in advance if so), but it *sounds* like you're missing the whole point of the article. The point is that frameworks *always* add runtime overhead, regardless of project size, and that that overhead stays consistent or even grows as the product gets larger. Frameworks will *always* add runtime overhead compared to vanilla JS, by definition - properly-designed vanilla JS designed to do the job at hand can't ever be less efficient than a framework, because in the limit case you're just developing a framework yourself that does only and exactly what you need with no additional wasted code or abstraction in it. Frameworks certainly reduce *development* (rather than runtime) overhead for larger projects, but Lewis explicitly addresses this very tradeoff himself in several places all throughout the article, and his general gut feeling is basically: &gt; It seems to me that developer ergonomics should be less important than our users’ needs.
it's a common SQL convention, where the tools aren't as friendly (or weren't 20 years ago). I've also heard web developers defend it by saying adding a new line only produces one line on a diff (instead of producing two lines for trailing commas - the previous line with a new comma would also be included). Not that I think that's a reasonable justification for using that style.
God damn it JavaScript.
The thing that drives me nuts is that there's different ways define "classes". Some use prototyping, which I've never taken the time to figure out, and others use closures out the wazoo. I used to be scared of closures, but then make sense to me now. Typically class def for me now: var ClassName = (function() { var privateConst = "whatever"; return { publicFunction: function (var1, var2) { ... }, someOtherPublicFunction: function() { ... }, ... } })(); Phew. That was not so fun to type on my phone...
Thanks a lot I'm glad you enjoyed it! Wrong info loading is a bug i'm working on kinda annoying at times lol.
I'm talking about development time, so we are in agreement. All abstraction layers add runtime overhead. Updated my comment to be more clear.
&gt; Frameworks are fun to use In the same way that burning yourself repeatedly with a lit cigarette is fun. Although I suppose compared to keeping front-end state consistent using jQuery or vanilla JS, using a framework is fun. But that isn't saying much.
&gt; Frameworks certainly reduce development (rather than runtime) overhead for larger projects I'm not sure everyone would even agree with that. One challenge with larger projects is that as they evolve they may go beyond the comfort zone of any specific framework they were built around, even if that framework seemed suitable and proved useful at some earlier stage of the development process. While frameworks may make it easier to do whatever they were designed to do, they typically also make it harder to do other things, and because of the natural lock-in effect you're stuck with that overhead even if it turns out that you really need to do some of those other things.
How could it possibly be that you are advocating developing everything that a framework provides while also saying that people who choose to use frameworks couldn't possibly further develop them to suit their evolving needs?
Similar conclusion our team made recently. A framework SHOULD NOT restrict your choices in the future. Your JavaScript code should be able to withstand time. We're now refactoring with the intention of being able to use any framework with the same code base. So if one day we want to use Angular2, Ember, or Polymer, the same code should still work. How do you do that? 1. Extract all your JavaScript logic into libraries/services, so that they can exist separately from the view (ie. in Angular, your directives and controllers should be used only for binding already calculated schemas/models). These files can then be used within any framework. And your only job to switch a framework will be to update the bindings. 2. Don't use native framework functions. ie. in Angular we have native functions like angular.extend, angular.merge, angular.isArray, etc. If you use native framework methods, you lock yourself to that framework! Use underscore.js instead and import it into whatever framework you choose to use. 3. Don't bind your logic directly to framework methods! ie. in Angular, don't connect your logic directly to $http, $broadcast, etc. Create an intermediary layer that is used throughout your code. Because then if you switch to a different framework, you only have to update the binding methods within your custom layer, instead of updating every single instance where you used $http, $broadcast, etc. 4. Split your code into self-contained modules that don't rely on external dependencies, ie. an Angular service that relies on the presence of 10 other services. Any relationship link/dependency should be passed-in as an argument. I think app development, ie. Android and iOS, has given those developers clear patterns they can use to create clean applications, including defined patterns for local db, handling network issues, using services (like gps, camera, etc). This sort of "completeness"/structure is something that JavaScript has been lacking. And I think we're slowly bridging the gap to a point where JavaScript is taken more seriously in Enterprise development.
Good job man. Work on improving the JS more.
YAGNI doesn't really make sense when you're talking about what tools a developer uses rather than what features they produce.
Babel transpiles to valid ES**X** code thought.
I don't see how you can make the case for vanillaJS always, or even usually, being more understandable than the equivalent implementation utilizing a framework. Part of what makes a given framework worth using is the semantic structure it provides. If you feel MV* pattern is overly restrictive for developing UIs, I'd be very curious to hear that argument.. On the topic of needing to relearn ones code.... how often are you accepting breaking changes of the libraries/frameworks you use, really? If this is really such a big deal, and we're advocating hand-rolled solutions, just fork it... In the mean time, enjoy replicating all of the work that's going on in the open source framework BETWEEN breaking changes that you now have to replicate. 
S'all good, thanks!
This part of the article most resonates with me: &gt;I have heard from many developers who have told me that they accepted the argument that vanilla JavaScript or microlibraries would let them write leaner, meaner, faster apps. After a year or two, however, what they found themselves with was a slower, bigger, less documented and unmaintained in-house framework with no community. As apps grow, you tend to need the abstractions that a framework offers. Either you or the community write the code. Something I found interesting in the previous discussion is that complexity was totally ignored or at least pushed to the side. But this article brings up the conversation I feel is one that's more appropriate to have: hand-rolling your own framework versus adapting one off of the shelf. I just don't see the option of "well don't use any frameworks at all" to be a very tenable or maintainable solution. At some point or another you're going to write abstractions and helper methods to make it so you write less code --- even if you're still using only vanilla js --- and you've suddenly created a framework. I wouldn't be surprised if this is how some frameworks came to be - some like angular certainly exhibit signs of growing organically like this. But, off-of-the-shelf frameworks can't anticipate all of the problems in your domain and their abstractions aren't for free. Some times it's a costly abstraction. It really comes down to a question of the right tool to use in the right time in the right place. * Only targeting modern browsers and your app is just a clock? You probably don't need angular. * Have an online database design tool which pulls in thousands and thousands of rows? You probably want something pretty performant. * Need to rewrite an application that your business and other members on your team are going to use for years down the line? Probably not a good time to hand-roll your own framework. And so on and so on. The conversation has so much more to it past just "stop making your users wait another second on their mobile phone". 
&gt;so maybe MS just doesn't have the money to spend Microsoft not having money? Completely ruled out possibility. They have been open sourcing some interesting projects recently, who knows that one will in the future...
&gt;I know the Windows+Office monopolies aren't quite the cash cows they once were, so maybe MS just doesn't have the money to spend on IE these dayas? You're asking this question on a thread about a major update announcement for edge. 
\- sent from my iPhone
Well if you saw me complaining about IndexedDB support in Edge, you should know better than to get me started complaining about Safari :) Root problem might be the same - both are proprietary. I know technically Chrome is too, but Google at least keeps it 99.9% the same as Chromium.
No mention of es6 modules. (shock!) 
A colleague always put his vars like this: var my_thing = 1 var my_second_thing = 2 var my_third_thing = 3 1 ctrl+k+d later and he never did it anymore.
Yeah. It can be humbling to move between different languages, particularly to something that has *nothing* in common with the language you use a lot (like a functional one). Unfortunately you'll still see a lot of otherwise well-intentioned people getting quite upset about semi colons or not or significant white space or not, or whatever language or syntax feature they don't like. Hell, the top comment on this very thread is complaining about comma prefix style... even though this thread has nothing to do with that! So I think experience in other syntax is important for reducing the gut feeling of "this is wrong", but it'll still take some effort to keep an open mind.
The original argument against this was that it breaks in IE8 and below. But yeah, with modern browsers and modern dev tools minifying the code anyway, this is probably not a concern now. :)
I'm of the opinion that if you have so many variables that you feel a need to organize them that way, you probably have too many variables in one function.
Perl solves this elegantly: You can end a list with a comma and a closing paren/bracket.
yes, I wish there was a standard format like go fmt
Comma-first makes sense if you use `var` or `let` in the case where you declare multiple variables at once because of the way the spacing looks, e.g. var x = 1 , y = 2 , z = 3; Granted, I'm now of the opinion that you should declare you variables on multiple lines all the time, e.g. var x = 1; var y = 2; var z = 3; It's clearer, everything lines up just as nicely, and you aren't beholden to declaring your variables before they're needed. Also, you can even declare different types: const x = 1; let y = 2; var z = 3; _Note: I recommend `const` or `let` over `var` if you are using ES6, preferring `const`._
JS devs don't all use reasonable tools. They use whatever tool came out today or else they will be left behind!!
Unless you are making thousands of large objects or millions of small ones, its not going to matter. 
It took me a little time to understand the structure of the sentence of you.
Cool man. Incidentally, I see you did DBC :-). I used to be a self-taught WordPress dev, then I did Dev Academy in New Zealand, which uses the same curriculum as DBC (incl the EE curriculum). I then taught at Dev Academy and did code review for students. These days I'm a Rails/JS dev at a dev shop. Small world! Ping me if you ever want a code review or if you're stuck on a question :-D And yup, pass it on!
The [module loader spec](http://whatwg.github.io/loader/) isn't quite done yet. You can use [this polyfill](https://github.com/ModuleLoader/es6-module-loader) or [SystemJS](https://github.com/systemjs/systemjs) in the meantime.
 my @list = ( item1, item2, item3, ); When you need to add more, you don't need to futz with commas. 
I also definitely agree, except that in a diff, you have @-1 +2 var x = 1, - y = 2; + y = 2, + z = 3; Whereas if you simply use `var` on different lines: @+1 var x = 1; var y = 2; +var z = 3;
Ah, thanks for the recommendation. I haven't looked at Meteor in over a year, so I'll definitely check it out again. I like that they've added integrations with Cordova, Angular, and React. Awesome!
&gt; The Random Song Generator is **is** powered by Spotify and gets you short clips of new music for you to listen
Thanks man!
That's probably because firefox [is going to the WebExtension API](https://blog.mozilla.org/addons/2015/08/21/the-future-of-developing-firefox-add-ons/) everyone seems to be going to.
Small feedback: When I click into an image, I am presented with the image in a modal-like interface, yet without the usual modal-like close button to the top right of it. I would suggest adding/moving the x to be close to the top right of the image. 
It's sad but true. But that doesn't mean it's ok. Something every programmer needs to think about: "am I being good to future me?" Code should be read like a normal letter/story not a science thesis or a girl scout secret message. I tend to be more descriptive with my naming. Though I do fall into the trap of writing too long annoying names. What makes easy to name vars/functions is making sure they have single responsibilities. 
That's just bad syntax. You can make that argument for any characters - or anything really. If you use it incorrectly, things break.
Visual studio reformat code.
Yup, which is exactly my point. It's just silly to worry about semi-colons or not, since they both have bad (but valid) syntax you can't use with them. They can both cause bugs.
Closures are definitely the way to go in most cases.
How did you install gulp? If you installed it via npm then you already have the package.json file. Other people then just run &lt;npm install&gt; and it will install the required modules itself. Oh, this applies only if you used the -save flag when installing.
Install and configure ESLint for the project. You can use something like Airbnb JS style guide as a base and override things. You can also install plugins for Sublime/Atom to get the common style validation in the editor before saving. It's impossible for people to write consistent code with each other if the build process and/or editor won't highlight the problems with one shared configuration. With static analysis tools however, there's very little "handwriting" to it and it mostly boils down to which design patterns different people use to tackle their problems.
You can hack it with 20 lines of javascript code. No external library required.
So all the text lines up 
[this site](https://www.gitignore.io/) is pretty useful for generating a `.gitignore` file, which every git repo should have. For example, a project using [node on mac or windows](https://www.gitignore.io/api/node,osx,windows)
&gt; syntax, spacing, casing, where parenthesis or commas go, if you have underscores or unicode-piles-of-poo for variable names I do not care at all if a certain language uses a certain convention, but I do care if you try to create a new convention just because you don't want to follow the best practices of a language. There are definitely certain ways of writing code in certain languages. Those conventions should be followed unless there are some damn ***GOOD*** reasons otherwise. "I think it's prettier" is not a reason. &gt; underscores or unicode-piles-of-poo for variable names If you actually believe that variable names (especially something idiotic like unicode symbols) don't matter then I can't possibly take the rest of your post seriously.
/r/tinybiome
I am working on a testing library and wanted to replicate the behavior of Mocha. You can return a Promise and it will wait or you can call a done() callback on completion of the test. I came across this great gulp js library [async-done](https://github.com/gulpjs/async-done). I forked the library and added synchronous and generator support. Hopefully other people will find it useful.
Karma + Mocha. And I use CoffeeScript to write the tests, because it's faster to write and easier to read. *I like CoffeeScript dammit!* But I use ES6 for the code.
There seems to be few libraries that do something similar with functions, but none that has done this with objects (none that i'm aware of, anyway). This seems bit strange, since syntactically objects look much cleaner. The reason, I guess, is that theoretically this shouldn't be even possible, since JavaScript specs don't guarantee property order in objects: http://stackoverflow.com/questions/5525795/does-javascript-guarantee-object-property-order But this is pretty theoretical. I'v used JSON like syntax for years, and I have never come across browser that wouldn't have properties in the order they were defined (either with literal syntax, or by assigning). So ordered object properties seem to be de facto standard.
&gt; frameworks represent an inversion of control. Then literally any code that you don't write is an inversion of control. I can understand the angular source better than I can understand some of the shit my coworkers write and thankfully the angular code is usually tested, unlike everything at my company.
The duck doesn't even have a chance setInterval(function(){$(".duck img").click()}, 10); 
My short description is "code with state" or "each instance of the function and the functions/objects it creates remembers the context in which it was called". Then I start waving my arms around and blathering about stack frames or things being a bit like objects, at which point I think my verbal explanation loses clarity and I have to resort to drawing a diagram instead.
Sometimes the decision regarding images is out of your hands, speaking from experience. You can push for them to be highly compressed but they want those images and they don't know how to make them in SVG when that would be appropriate, so you're a bit stuck. Niche situation to be in though I concede.
I don't know the history very well (IE6 wasn't it?) but they shouldn't have deviated from the standard no matter how big of an improvement it was - they should have attempted to influence the standard itself going forward.
A closure is a nested function (a function nested inside of another function). A nested function inherits the arguments and variables of the outer function. We could say that the inner function "closes over" the scope of the outer function. 
Have you tried it? What is your take. BTW there's now [AVA](https://github.com/sindresorhus/ava) by Sindre Sorhus and company. 
... is the jam
He's well-known among JS developers. He's probably most famous for his compat table: http://kangax.github.io/compat-table/es6/ He also wrote some in-depth articles like this one: https://kangax.github.io/nfe/
&gt; the days of IE8 and 9 (those were dark days) _Those_ were the dark days? How about the days of IE6?
And all of these people talk like they will be the only ones who ever need to touch their code. 
&gt; no vanilla js written by a terrible developer will not be better or probably faster than the open source framework written by a large community of amazing developers That's absolutely true - my comment (and I'm pretty sure Lewis' article) depend on the assumption of "a sufficiently competent developer", which may or may not be the case for any development team (let's be honest: usually not ;-). As I mentioned [elsewhere in the comments](https://www.reddit.com/r/javascript/comments/3t19ou/the_cost_of_frameworks/cx2osfh?context=3) on this article, frameworks are great for imposing structure on solutions, and thereby saving less experienced developers from themselves. However, for a sufficiently skilled developer (or team) or a sufficiently knotty problem-space I suspect they offer diminishing returns beyond a certain point. It's worth noting here that neither myself nor Lewis are arguing you should *never use* frameworks here - only against the blithe but beguiling assumption that third-party javascript frameworks are a *cost-free* choice, or *always* the best option when starting a project.
Off the top of my head, here's how I would define closures: "Closures are lexically-bound, first-class functions." Any feedback is greatly appreciated on this hastily-submitted post. Thanks!
A function remembers all the stuff that was created within the scope it was created in.
When you create **function-B** inside **function-A** and then **function-B** "leaves" *(function-B get's returned or passed as an argument directly, or indirectly by getting stored in an object and that object get's returned/passed)* **function-A**'s scope and **function-B** refers/uses variables/functions from outside of it's scope, the values of those variables are captured/closed over/remembered/stored in an "anonymous object" *(you can't get a reference to it)*. One caveat of the captured variables's values is that you can't serialize them because they are stored in an "anonymous object" *(which you can call a closure)*.
That is some ugly code... [ thing, thing1, thing2 ] That's better...
And, as Microsoft's "best browser ever!" it still doesn't hold a candle to **today's** Chrome, Firefox or Opera (http://html5test.com/results/desktop.html). Those three browsers have always beaten out Microsoft browsers, and always will. &gt;Their score on HTML5test.com also made a big jump. A big jump over their previous score. Being better than shit is still shit.
&gt; If you're serving images of 1MiB, then you shouldn't be writing for the web. Or it is. Sorry if I'm being pedantic.
&gt; Edge 13 is feature-wise pretty close to Chrome and Firefox. [Not hardly](http://html5test.com/results/desktop.html) [Not even close](http://caniuse.com/#compare=edge+13,firefox+42,chrome+46,safari+9,opera+33) 
But everything else, Edge is the worst of them all except Safari. Even Opera has more support for more HTML/CSS features and functionality than Edge does. The other browsers have always beaten Microsoft browsers and always will.
No. It has nothing to do with it. It's one thing to serve 1Mb images and think it's OK. It's another thing to serve those images cause your boss tells you to or you'll lose your job.
Here we go again. The annual "&lt;insert Microsoft browser here&gt; best ever that will crush all others!!!" that we've been hearing since IE7 and redditors swallow hook, line and sinker.
I have heard that same thing from alcoholics (more than 1).
&gt; have to run the entirety of Ember's codebase This is a highly misleading statement. For TodoMVC, yes you aren't using much of Ember. For a more complex application if Ember wasn't providing features you would be writing that code yourself. I've seen backbone apps at a full megabyte payload, and I've seen Ember apps under 200K gzipped. Boot and render performance is more complex than "Ember is big". Tom's blog post is not about Ember, so I'm not surprised he didn't address it. The Ember team is still working to improve performance. 2.2 is as fast as any release we've had for initial rendering and for rerender performance. There are parallel efforts to make the boot time of Ember on v8 better (v8 gambles with optimizations very aggressively, and it massively trolls our module loading system) and land a refinement of the glimmer algorithm that is expected to improve initial and rerender performance again. The improvements of this summer and fall were delivered to users incrementally without breaking their apps, and the next round of changes will also be delivered with backwards compatibility. We've got four and five year old apps that went from a plain Handlebars rendering engine to Glimmer with a clear path forward. Changing out the rendering and loading systems of a framework powering real apps is not trivial, we're making progress though :-) I'm excited to talk about how big the improvements were over a year at EmberConf.
By whom? There is nothing wrong with the standard model. The only thing wrong is with those who can't figure out, and are totally bewildered by, the fact that "width" encloses the content.
What I'd like to see with this is also some additional data points. The roster of each team at game time, who scored goals and how many minutes in, how many fouls were in the game and when cards were given, which refs were officiating, to name a few. Simple scores is a good start, but I'm thinking that the most interesting analysis will result from those points. To be fair I haven't looked at the raw source of the data yet to see what's available, but I would love to play with the result if we can get some more of these in there. 
Disagreed, though it depends on what your goal is. If it's for some sort of display purposes, sure an API is useful. This seems more for statistical purposes, in which case an API is much worse. You'd much rather have large datasets local. 
Instagram, Airbnb is also using react for some part of its application. You can install a chrome extension to see what sites are built using React, while you visit them.
I can't find the Dallas Cowboys or the 49'ers in there
You just missed Nodevember in Nashville
Percentage width + padding. Super simple stuff. Can't do it with content-box. (Unless you use calc().) Content-box was the wrong default. Border-box can do all of that and more. It's gives you more flexibility.
Global classes are convenient when you first develop something, but they are also global variables. Maintenance is a bitch, just like global vars in your code. Changing or deleting styles after your codebase has grown is very difficult, because you don't necessarily know what all it's going to affect (thanks to the "cascading" part of css). Inline styles isolate styles to a specific DOM element, so you can change or delete them without having to figure out if anything else broke. Maintenance is much easier this way. I'm not saying it doesn't introduce other problems, but that's the problem inline styles are designed to fix.
There isn't a single browser which supports module loading.
Has nothing to do with my points. Your excuses for Microsoft are common.
Please read the comments in this branch again. Try to stay on topic.
You are the one going off topic. You are the one bringing up things that have nothing to do with what I said.
come on and SLAM!
Again, please read the comments more carefully. /u/ogurson said that it was the wrong default. You said that there is absolutely nothing wrong with it. I explained what's wrong with it. You thought they were interchangeable. They are not. Content-box doesn't let you do some things. E.g. you can't make an input stretch to the width of some column with content-box. With content-box, you need to know the exact width. Also, calc is from CSS3, not CSS1. Using calc wasn't an option. Calling something which isn't available for years to come "nothing special" is kinda silly. Content-box's inflexibility was a big problem.
Thanks! I'll take a look. That would be super convenient for me coming from Tampa.
This branch is about modules. The spec was split off ES6 and is still in flux. That's why no browser supports it yet. Modules isn't something other browsers support.
Well, m 'p' 'hello there' Is just a helper function which returns this: { tag: "p", children: ["hello there"], attrs: {}, } This has the important, order-sensitive thing (the children of the tag) as an array, which has guaranteed order.
While you may think the box model is wrong, that's an opinion which I, too, disagree with, and have never had any issues with it. It's not complicated and I don't understand why anyone can't figure it out either.
Ignore me - it's obvious I didn't look at this clearly. 
Ignore the opinion ("kinda silly", "*big* problem"). Everything else I said is factually correct. Content-box was the wrong choice. It only lets you do a subset of the things you can do with border-box. I'm not really sure what you think you said, but you only said that there is nothing wrong with content-box, which simply isn't right.
Good question: It's using a "flat" structure (e.g. de-normalized) using score1 and score2 to keep it simple. The "original" SQL database (e.g. football.db) also uses a "flat" structure with scores as part of the matches (games) table. The team is its own table, thus, the team "table" is nested in JSON inside the matches (games) hash/table. Cheers. PS: See the [football.sql](https://github.com/openfootball/schema.sql/blob/master/football.sql) schema for details. 
 alert(1 + 2);
FYI: Football is the world's most popular sport and in my humble opinion it needs more open data, thus, football.json got started. You're invited to build apps, services, books, etc. Enjoy the beautiful game. Cheers.
Well aren't you pleasant.
Thanks 
Good point. Look for the FC Dallas, San Jose Earthquakes, Seattle Sounders, etc. ;-) For Amercian Football JSON data see the great [nflgame project](https://github.com/BurntSushi/nflgame) by Andrew Gallant (aka BurntSushi) for example. Cheers.
It is the solution to your problem. A book will explain how to declare variables, assign values to them, use operators, and things like that. They also explain all the other things you'll need like loops, conditions, functions, etc.
https://www.codecademy.com/
TJ doesnt use a linter thus fails to the pitfalls it catches, hince the style. So use a damn linter, configure it well if you think its annoying.
Beautify feels the role.
Amen brotha
Thanks for taking another look at our list. About the name of the organization, you know, give names to things is really very difficult :)
Testing is actually one of the reason I like mithril over react. The mithril functions just return objects and themselves are just functions, and we all know how to test functions and objects. Example is using mithril, livescript, and jasmine. # imagine this lives in another file helloWorld = -&gt; m 'p' 'hello world' it 'should render "hello world"' -&gt; {tag, children, attrs} = helloWorld! expect tag .toBe 'p' expect children[0] .toBe 'hello world' This would allow you to test components individually of the children updating, since you are not expecting the entire structure to be the same. You have the attributes object as well, so you can simulate clicking, hovering, etc, all just by calling functions.
You are probably safe either way. The only reason *parse* is less applicable is because the term is so commonly used in the production of programming meta-tools to specifically refer to the process of creating a list or tree of tokens with sufficient description.
GP: Grandparent The point is just that the load or startup time of an app is often not going to make or break it alone.
/me looks at username...
Vague as hell
&gt;It's only a few points behind Firefox in the latest stable Yes. Microsoft's latest and greatest can't keep up with an older version of Firefox. &gt;HTML5Test is also not a real benchmark This is a typical reddit comment. It doesn't matter what test or benchmark is presented, it's never good enough. Yet, any Microsoft test or benchmark is golden. &gt;it would be irresponsible to implement them cross-browser In almost all cases, "cross-browser" means "it doesn't work in IE/Edge". &gt;You see Chrome leading so much because Google (to their credit) has a lot of experimental standards and proposals Yet Firefox and Opera surpass Edge, too. Quit trying to make excuses for Microsoft. It makes you look foolish.
A closure is like the house owned by a nosey neighbor. The neighbor can do whatever he wants inside his house, but you won't be able to see him or what he's doing. However, the nosey neighbor can peak through the blinds of his house and see all the other houses and people nearby. Any information about events and people outside (he can't see inside other houses from within his), as long as they are in the same neighborhood, he can observe and make use of. He can even call up other neighbors on the phone and influence them, based on what he can see. If a person never comes out of their house, the nosey neighbor will not be able to influence them, because he is unaware they exist. Houses are functions, People are variables, Events are operations, The neighborhood is the containing context.
How fortunate, Our Object Orientation Coursework is on a FootballManager, now i have a data set. Thanks 
Would you use this only when working outside of a framework?
Thanks! I was looking into using separate files but would that effect load times since you have to get multiple files?
I wonder if he was interviewed by Java developers.
Unfortunately, I don't think the numbers are very accurate. Benchmarks are tricky and can sometimes be optimized in unintended ways. The numbers being faster as you get larger doesn't make sense. This youtube video gives a great explanation about issues with JS benchmarks. [Performance and Benchmarking](http://youtu.be/65-RbBwZQdU)
Well, you'll probably need to [polyfill](https://github.com/github/fetch) it with its [current browser support](http://caniuse.com/#feat=fetch) being pretty low. It's a good light-weight standard that isn't tied to any framework, though. 
&gt; The mithril functions just return objects and themselves are just functions, and we all know how to test functions and objects. React `render`s just return an object... why do people feel the need to generate the HTML of the result instead of just letting the component render and inspecting the result? You can check what classes are applied, what tag type it is, inspect the children, etc.
Interesting! If you manually use the render methods you can get an object that looks something like this: { type : string | class, props : { children, className, etc. }, key : string | boolean | number | null, ref : string | null } This seems an awful lot easier and more convenient to test than what the article talks about.
This is bizarre. First of all, `self.addElement` will be undefined because the IIFE is not returning anything. Second, it looks like you've worked it out, but the second querySelector probably should have been `querySelector('.bar')`. Assuming you're making a function that takes a target element, appends a new element and keeps a reference to it, why not: function foo(selector) { var target = document.querySelector(selector), child= document.createElement("div"); child.classList.add("bar"); target.appendChild(toAppend); return {target, child}; }
Interesting use of proxies. I wouldn't want to see that actually used in production, but it does show what kind of interesting things you can get out of them.
Fork me on GitHub ;) Don't forget to put a star!
Stuff like that &amp; lint helps, but that has to be decided by an architect, or team, and varies per team. Whereas golang has it by standard.
Love it...
pretty much the exact reply i expected, great job
Thanks for sharing this! It actually gave me some ideas to work with falafel.
that's not what i asked
Python borrowed this as well. It's one thing I miss in JS.
Very nice stuff... Yes football data should be freely available! How current does this data remain if I may ask? 
I do this in PHP for ALL of my arrays with the exact same rationale.
[You sure about that?](http://caniuse.com/#feat=serviceworkers)
I have no idea who the fuck names variables like that. 
As I said, my C++ and V8 are far from amazing -- so if there are ways to improve upon my implementation I'm all ears! I'll definitely take a look at that link. I don't expect my post to be taken as gospel -- I just haven't seen many resources discussing this, and I thought it was a fun exercise.
I got the joke
You'll still overflow the stack regardless of the fact that the number can't be represented in floating point. As tail recursion becomes standard in js engines this will no longer be an issue, as long as developers know how to write the code. But you're definitely correct the number is too damn big to be represented. 
Wow, that's a very enlightening video! For starters, it confirms that I don't know nearly enough about compilers and V8 in general :-) To your point: "I don't think the numbers are very accurate" -- yes, you'd definitely be right, and I tried to address that in my section "Discussion". I certainly didn't expect the numbers to be faster with a larger number of test runs, and I noted that was the item that gave me the most pause. Having said that, Vyacheslav Egorov's advice is "not to micro-benchmark" and instead focus on improving the algorithms being used... advice I could not agree with more. This is more of a curiosity exercise on my part, and now you've gotten me hooked an confirming whether-or-not the compiler is caching, hoisting or ignoring parts of my JavaScript algorithm (more than likely it is). But if that is the case, isn't that also a reason to use JavaScript over C++ in some cases?
FYI: There's a (European) Champions League repo @ [/europe-champions-league](https://github.com/openfootball/europe-champions-league). Last update on Sept/9. 
Why would I want to use `.apply()` for a single argument?
Ah! I'm used to your kind. I date back to getting on Chris Wilson's case back in his day with you. I like to think I took some credit for the day he talked about his depression from all the negativity directed toward him and, soon after, he left MS. Don't worry. We made friends later. Let's not forget my main point. In a benchmark by **anybody**, including the one I linked to, testing overall effectiveness, IE and Edge **always** comes in behind Chrome and Firefox! You can complain about anything you want, but in the same test, IE and Edge **always** trails behind! &gt;you might be interested to know that we outscore all other browsers on the Kangax ES6 benchmark as well as most JavaScript performance benchmarks. We've already gone over that. Doing well on js, while sucking at most everything else, does earn you many brownie points. &gt;We evaluate standards based on demand from web developers, interoperability, and prominence on the web. And now to the core. BS from the Microsoft team! You guys help write the standards! How can you now try and deflect from that to say you're only picking and choosing what you'll support?! As a member of a fourth-rate browser team, you should keep your mouth shut and do the listening. Not that you've ever done that before. Now, run away, as you have now, or I'll make you cry like a baby, too!
FYI: There's a World Cup repo @ [/world-cup](https://github.com/openfootball/world-cup). Can you explain who owns the data that Germany won the world cup against Argentina in extra time 1-0 in the Estádio do Maracanã in Rio de Janeiro and that Mario Götze scored in the 113 minute? FYI: The data reads: (20) Final (64) Sun Jul/13 16:00 Germany 1-0 a.e.t. (0-0, 0-0) Argentina @ Estádio do Maracanã, Rio de Janeiro (UTC-3) [Mario Götze 113']
That would be sweet. It would be fun to write a fantasy football game with this. 
All in good fun :)
This was very interesting! I could see the line between native app and web app blurring quite fiercely with this.
I'm really not sure why you are under the impression that I am an authoritative source on this. All I know is that licenced data was available for a fee, and I recall sometime getting in trouble for reproducing that paid-for data. As I said, that might not have been results data, it could have been telemetry, minute by minute updates etc.
This sounds interesting. It wasn't just typescript right? Just found this list: https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js Not sure if it's helpful
Hmmm, the plot thickens. In mithril, the events are still attached to the object that is returned, so you can just call them to simulate those events. I would have imagined something similar exists for react.
Thanks! Not JSON but I suppose there's a way to parse that using JavaScript.
Sorry - so far the tooling [1] to import the text into an SQL database (e.g.SQLite) is in Ruby ;-) However, exporting it to JSON works like any other league. Cheers. [1]: see the [sportdb](https://github.com/sportdb) project. PS: For some (basic) JavaScript examples, see the [football.js](https://github.com/footballjs) project. Cheers.
Glad you enjoyed it. It definitely made me rethink my performance tests. If v8 is better at loop unrolling, constant hoisting, etc. That might be a reason to use it. I think there are very sophisticated C++ compilers, so I don't think that is likely. In almost every case C++ will be faster than Javascript. The C++ can sometimes be slower when transferring values between Javascript and C++. In the case of your benchmark, I think it might be dead code elimination. That is less likely to happen in real code.
jQuery: $('my-el').toggleClass('myClass'); Vanilla: document.querySelector('my-el').classList.toggle('myClass'); Apologies for formatting, on mobile atm.
Thanks!
This stackoverflow could be some help to you: http://stackoverflow.com/questions/8672709/find-and-replace-by-a-dictionary-using-keys-only-once
What about XMLHttpRequest? This started out as IXMLHTTPRequest inside MSXML, a completely proprietary COM class exposed to Internet Explorer 5. I mean, look at JavaScript - MS basically reverse engineered what Netscape put together, with all its quirks and craziness and called it JScript -- there was no standard... additions were "differences" not necessarily wrong just not what the other guys did. Back then, early 2000s, the bad 'ol days of IE5 (upon release), there wasn't a standards body so to speak.... well, they were *there*, but none of the browser vendors paid much attention. You have to go a few years further until standards gained traction and you find W3C vs. MS methods. By that point, IE wasn't much of a priority for MS and the rest is history with release upon release getting closer to parity, but still leaving incredible gaps between what was expected and what IE did.
The "masonry" layout is hard to scan. Since it's done via JS, the perceived loading time is also very high. Use something else if you can.
An inner function inside of an outer function, that happens to be the return value of the outer function. After getting the inner function as a return value, you can call it. When you call it, it's as if it's being called while *still inside* of the outer function, even though it's not.
Sorry for all the edits: Here's the use case. https://github.com/Reactive-Extensions/RxJS/blob/8f12f812d497acf639588e90f74d504a9fc801ec/src/core/linq/observable/ofobjectchanges.js
We need Crockford's alternative double numbers.
That's awesome! You guys have done some fantastic work and I can't wait to start playing with the library. 
it's hidden under the .mobile-navigation, because it's fixed position 
Because mother nature is a bitch and every wasted computer cycle is another blatant "fuck you"
Naming things is hard. 
Great news, just stumbled upon plotly.js the other day while doing some reading on D3.js.
The only problem is if you're calling setState in your component because you need to mock out the DOM for that. If it's a pure component or using something flux-ish then it's probably fine.
thanks.
Oh you mean soccer.json
And: all functions remember. All functions are closures.
Yeah, you can't do it with flexbox. 
http://www.w3.org/TR/WebCryptoAPI/ http://caniuse.com/cryptography Polyfill: https://github.com/Netflix/nfwebcrypto
Im having a hard time getting into data visualization. Both coding and conceptualizing use cases. It's a bit daunting when I look at d3 code and even this. How do people usually get into it? 
Babel now has an inline replacement for Object.assign. 
Dec64 or something right? I wonder what the largest number in that is
You sound pretty sure and authoritative too, and as far as I know you haven't sayed anything valuable, only questioning your interlocutors' skills. As far as I know, data *can be licensed*. You are free to aggregate your own dataset, of course, and that's quite probably what Wikipedia did, but if you try to use those coming from another place, you have to follow the license they come with. They paid people to aggregate these dataset, they have the right to prevent you from using them. [Source:](http://opendefinition.org/guide/data/) &gt; In most jurisdictions there are intellectual property rights in data that prevent third-parties from using, reusing and redistributing data without explicit permission. Even in places where the existence of rights is uncertain, it is important to apply a license simply for the sake of clarity. Thus, **if you are planning to make your data available you should put a license on it** – and if you want your data to be open this is even more important. (emphasis *not* mine)
FYI: I've added a npm package named - surprise, surprise - football.json. See -&gt; &lt;https://www.npmjs.com/package/football.json&gt; Cheers.
Facebook released jscodeshift which looks like it does the same thing. https://github.com/facebook/jscodeshift I'm glad the JavaScript community is finally getting the tools it deserves.
Any idea what I should do if my script_to_transpiler is in a sub directory? In that case babel seems unable to locate its plugins... :(
node_modules is just a temp folder. It doesn't matter what's inside.
Pretty sure it's football.json -&gt; http://www.sportsmillenium.com/wp-content/uploads/2009/01/2009/05/handegg.jpg :P
Free? What's the catch?
From what I understand, plotly.js is actually built on top of D3.js. Learning D3.js from the ground-up and figuring out how to generate all the basic graphs can be daunting. With plotly.js they've built a convenience layer on top of D3.js so that you avoid a lot of that pain and can get started more easily with visualizing your data.
Omg, I just updated to 5.0.0
Yeah, I'm not saying anything at all about whether or not functional programming is a good idea. I am 100% in favour of using `const`s where reasonable. I'm simply saying that people need to stop acting as though `var`, `let` and `const` are all aliases for the same thing. I saw a guy get confused half way through a live demo at a meetup, because he was getting an error trying to reassign something to a const and couldn't understand why he couldn't use it like a `var` equivalent. You can prefer the programming patterns that const encourages or enables people to use. I do. But it's super frustrating to see people talk about "Oh I use const now, everybody should use const" as if it's just the cool new type of the week. Too few people in the JS world understand the programming concepts behind what they do with the language.
I'm afraid
 expect(this).toBe('bullshit') **ERROR:** Expected `bullshit` but got `undefined`
Yeah, you are right. I didn\`t think about that wide ignorance yet.
Arrow notation to the rescue! 
&gt; Hmmm, that distinction seems more political than practical here. Guessing how the syntax works or googling "livescript", pasting the code, and hitting "compile" is not very practical. Just stick with the syntax everyone here is familiar with. You added a ton of friction for no reason whatsoever. &gt; Would you have me use pure ES5 if the conversation were about coffeescript, elm, or react? This submission isn't about LiveScript. &gt; telling me to only use javascript in this subreddit seems to be throwing out the baby with the bath water. You can of course use snippets in other languages if the syntax or the semantics are the topic as I did here: https://www.reddit.com/r/web_design/comments/3t2jfn/eli5_whats_the_difference_between_java_and/cx2nxo1 Or if to-JS languages are the topic and similar scenarios. In a thread like this one, however, it's just inconsiderate and off-topic.
I think you've missed the point. The "what's inside" is my entire concern.
I use that as my var name, and rarely "other". this, that and the other.
Is there ever a moment when writing javascript where it's not hacky? Usually, by the end of the project, I'm apologizing to the other developers on my team.
I's love to see more info on this subject. On my small projects I also totally avoid those, and I feel fine, but I found some edge case where I have no choice...
&gt; Is there ever a moment when writing javascript where it's not hacky? Yes, in the beginning when you've made the first pass through the design document and your code is a beautiful abstract piece of art with all chunks in their places interlocking perfectly. Then the design document gets 14 scope addendums and the due date is moved up by two weeks and it all turns to shit.
https://twitter.com/bhalp1/status/578925947245633536 - by /u/bhalp1
[**@bhalp1**](https://twitter.com/bhalp1/) &gt; [2015-03-20 14:27 UTC](https://twitter.com/bhalp1/status/578925947245633536) &gt; Sometimes when I'm writing Javascript I want to throw up my hands and say "this is bullshit!" but I can never remember what "this" refers to ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I didnt dv you, but bind has consequences. Ex : the bind function creates a copy that is stuck to the object. function foo() {} obj1 = {} obj2 = {} obj1.foo = foo.bind(obj1); obj2.foo = foo.bind(obj2); how many copies of foo now exist? 3. Sometimes, better to to the prototype way. Sometimes. Gonna uv you cause you added to the discussion. 
I think it's fair to say Vue is a library since it's specifically designed to do only one thing, but Mithril and Riot definitely have larger scopes and a idiomatic way of building blocks upon them. FWIW, Backbone is also generally considered a framework, but it's fairly notorious for *lacking* a "backbone way" and for also inviting people to build their own micro-frameworks as well (via gluing libraries). If you look at, say, threaditjs.com (a todomvc spin off that implements a Reddit/HN clone with a backend, parameterized routing and some other more real life-ish stuff), the Mithril implementation is literally the only one without dependencies. Even Angular uses angular-resource and angular-route, which are always conveniently left out of gzip+min byte count exercises, but that everyone ends up needing in real life
An object can be just a collection of functions. There's no reason to involve prototypes or other OOP techniques.
Use asm.js. I'm arguing for using the tool for the job. If you are making a game physics engine on a website, compile to js from a language designed for that kind of throughput. If you are making a form with data binding, just make a copy of the functions. It's literally not going to be noticeable.
1) as the callback is declared directly where the callback is used, you could argue it's easier to read like this 2) your notation still does not have the lexical `this`, which should have been added in your code using `bind` on the function
Hey cheer up. You'll quickly gain more familiarity with JS, and then move on to saying "self is bullshit".
Sure, and here's Tom Dale's response (you know, pretty famous guy, too): http://tomdale.net/2015/11/javascript-frameworks-and-mobile-performance/ Honestly, though, flip through some of Paul's links and it starts to get somewhat clear that the "benchmark" is more of a gimmick to push an agenda (ooh, and look, he's a Google guy, so obviously we should idolize him). I mean, google "todomvc perf comparison". The very first link is a comprehensive todomvc benchmark, and it shows many frameworks that beat React performance handily, but why isn't he talking about those? He says "I see the ergonomic benefits (and those are important!)", but then he concludes by throwing out the baby with the bath water, even despite there being a ton of good quality open sourced work out there that is a lot closer to his dream of "If we can achieve fast-booting, low-memory, smooth-executing frameworks with good ergonomics we’ll be onto a winner". Seriously, wtf?
Is this the version that fixes/works-around the 260 character path limit for us Windows guys that like to use Node by packing node folders?
Your bullet is now basically an object literal. That means it was just created with (essentially) {}. Is it bad code? No. Can it be better? Yes. Compare / contrast with the prototype way of making objects : function foo() { this.x = 5; etc... } bullet1 = new foo(); Dosent really matter till you realize you want to add functions to the object. Object literal way : bullet.explode = function() { ... } So now you have a choice : place explode into EVERY object, or manually add it to EACH bullet that needs it. Either way, youre making copies of code. Compare and contrast to the prototype way foo.prototype.explode = function() { ... } Now every bullet refers to ONE copy of that function. No copies. Im no expert either, and Im sure some 19 yr old will chime in in 5... 4... 3... with an amazing way to do this proper while schooling me on object creation methods lol. :-)
&gt; And in 99% of applications, this doesn't really matter. Oh I agree! I enjoy the academics though lol. Knowing latin helps in med school. Understanding prototype vs object literal creation helps with js programming.
That would be the npm module which I fhink in version 3.x does that. I think it's the one that comes with node 5
I do dislike having a zillion binds in my code, so I sympathize if people go with self. Thank god for arrows... the way it should have worked from the start.
 $ brew update &amp;&amp; brew upgrade // go back to what I was doing.
then you don't get it ;-)
Check out nvm ( node version manager). Makes changing node versions easy as pie. I consider it a must have on my dev machines. 
Do you ever let people start with pen and paper first? I'm not good at writing on white boards, as silly as that sounds. 
You could use Callbacks for events. var controller = (function() { var completedEvent = $.Callbacks(); function doAThing() { // Things getting done here completedEvent.fire(); } var interface = { doAThing: doAThing, completedEvent: completedEvent }; return interface; })(); controller.completedEvent.add(function() { console.log("Thing Done!"); }); controller.doAThing();
Dude chubby arrows are the best. 
was already posted 13h ago.
Name one and I'll show you a way to avoid it.
Ah silly me, should have checked.
My bad, that should read "a tiny Popmotion plugin". It isn't quite so tiny if you don't use Popmotion! (then it'd be ~13.5kb)
I'll start off with the fact that you shouldn't really every listen to anyone who tells you to never or always use something in the first place. The Javascript "experts" out there just have their own way of doing things and even if some of their reasons are valid, they don't necessarily apply or matter to most developers. It's always good to read up on these topics and learn why people are saying what to do or not to do, but just because it comes from an expert doesn't mean that you have to use it or that not using it is necessarily "bad". Here are some articles on the subject if you want to take a look: https://nemisj.com/js-without-new-and-this/ http://radar.oreilly.com/2014/03/javascript-without-the-this.html 
It doesn't sound silly at all! I already bring a pen and paper for myself, so there's no reason I can't offer that to the candidate. I should try to offer the pad more often, when asking the question. I can tell you that learning to write on a whiteboard is a much easier skill to learn, in that if you don't know algorithms, you aren't going to learn in two weeks, but if you know how to program you can teach yourself whiteboarding while doing your typical / recommended algorithms review.
I see you point, and yes, in my exemple, "move" is duplicated (though I believe there must be some kind of classic JIT engine optimization that would help). But consider this : var BulletModel = (function() { function static_add(x,y) { return x + y; } return { create: function(x,y) { var internal_data = { x: x, y: y } return { add: function() { return static_add(internal_data.x, internal_data.y) } } } } })(); var bullet = BulletModel.create(1,1); bullet.add(); // 2 "static_add" is not duplicated anymore^[1]. Maybe it is overkill, maybe it is just a different way to do things (without "this"). If I find some time I'll try to bench it. [1] but yes I created a small duplicated function to call static_add ; again I would love to know if functions sharing a body but having different environments have an impact on performances...
I've a bit of a lasting shoulder injury, is the problem. Working on it but it's taking time. 
a great way to get an entry level position is to build a few personal projects. if youre using the mean stack that means youre a web dev, so building a crud application with a server is a great project to have (basically proves you know the very basics of a full stack, so it doesnt need to be extremely complex). i'd also recommend building a small single page application with gh-pages using angular (think snake, or tetris) to show off some more advanced / concentrated angular skills. the fact that you know node and angular will give you a huge advantage for shopping around an entry level position. what these two project will do is demonstrate that you know the full mean stack: your crud app will show you know the server, deploy, db, and restful jargon, and the snake / tetris app built heavily in angular will allow you to show off your angular / front-end handy work. spend time on these and constantly refactor them as you get better, and they should be enough to get someone's attention. additionally, when youre applying, try to get them to look at your github to see your code (not just your resume). when you get an in-person interview, try as hard as you can to show them some of your code. have a code sample in mind from a project you were particularly proud of that you can show off, talk them through etc (which means bring your laptop!). a lot of jobs are going to make you do stupid things like whiteboard, or solve algorithms but if you can show them you actually know how to code it will make their job of gauging your skill level much easier. GL!
This is awesome news. I just installed a bunch of extensions I've been wanting from VSCode (linters, language support, etc.). Hopefully someone will make a VIM extension for it! :)
I'm wondering how Atom and VS Code technically compare. They both seem to built on electron using html/css/javascript. Atom using coffeescript and VS Code using typescript. But why is Microsoft investing so much money in this open source editor built on electron, if the world already has Atom? Are they doing something fundamentally different than Atom?
Saying "X is as fast as Y was N years ago" is meaningless. It depends on the code, engine, environment, system load, and other factors. This is a hopelessly overgeneralized statement. My statement is true, regardless, because operation on arrays of integers is going to be faster than operating on high level object interactions, whether the language is c++ or javascript, so use the tools that make this kind of implementation just a compile step: asm.js. You're making a bunch of assumptions about how I code. Let me be specific. I use a 'mostly-functional' style, where data is transformed by functions through other functions. If something goes wrong, I know it is in the function that did the most recent transform after which the data became corrupted. Since my functions tend to be only 3 to 8 lines long, what is wrong is usually immediately obvious, assuming I just didn't do it perfectly the first time, which is how it usually is. All these functions are wrapped in functional namespaces, so there is no spaghetti. Every function usually has only the minimum set of data available to it, the rest protected by closures. I have nothing against OOP by itself. I have a problem with inheritance, which is usually held up as the primary advantage of OOP style. Inheritance tends to move implementation an unpredictable distance away from usage, and is subject to the kinds of issues mentioned in the article. The people who wrote the book on these subjects, state: "Prefer composition over inheritance." That is what I do. I have yet to encounter a situation where using inheritance is hands down better than composition usage for all dimensions, including: ease of writing, ease of maintenance, ease of reading/validation, behavioral flexibility, memory usage, and speed. Inheritance MIGHT provide some memory and speed advantages, but you'd need to test and make sure. For your critical sections, if inheritance nets significant improvement, then by all means, make use of it then.
They are open sourcing software, its a little weird coming from Microsoft imo
This is true, however, you assume that explode must be added to the object. I would normally have an explode function that I pass bullets into. Only one function, and the bullets remain pure data. Further, I could use only one explode function (defined without side-effects) that could perform the explode operation on any data that can explode, further deduplicating code.
It's actually much faster than Atom so they are doing something right. Hopefully now that it's open source Atom can copy whatever magic powers VS Code.
My 2c . Microsoft wanted an editor to attract development on their new cross-platform technologies (DNX running asp.net 5 and the coreCLR, TypeScript running on NodeJS) so they built VS Code, as the VS name is very well known, so big boost in marketing there. It could be an opportunity to show users an environment that would be officially supported by Microsoft (sound attractive to .Net and TypeScript devs). . But, because the community was already very invested in development with Atom (having Omnisharp and TypeScript tooling at an advanced level of quality) they had no choice but to open-source it, or else who would invest time in VS Code? Angular2 guys? lol!! . So we can see it as an investment by MS to have official tooling for their Tech. I very much like that it creates innovation and option, i use TypeScript and Atom because i like Atom's design, other devs might like the VS design or name or whatever makes them prefer VS Code. The option side also gives us the possibility to have a whole new team working in tech that might become better. e.g if VS Code becomes a more attractive development environment (specially because MS is focusing on delivering quality debugging tooling), i'll switch to VS Code. Meanwhile there are devs that do Haskell, F#, e.t.c... where Atom has much better tooling than VS Code so it's a better option. . It's all tools, like drills and hammers, mechanics et al. don't complain (not saying you're complaining) when a new brand of tools or even new tool comes out, they embrace it, it only helps the innovation and might make their work easier, we as Software Developers need to embrace that too.
http://vim-adventures.com/ `vimtutor` Takes 20-30 minutes to learn core stuff in vim. Vim increases your ability to edit text, thus raising value in your effective hour. Which in turn makes you more valuable. It's a worthwhile investment of your time.
React killed React for me: with the patent clause, no way I'm using React in a product. 
vim is fucking garbage. Anyone at a higher level than "Indian code monkey" could give two shits less about how fast they can edit text, because that isn't where they are spending the majority of their time. If you know it, good for you, but the people who defend it and recommend it to others are nothing more than hipsters.
Did two-way data binding fall out of favor because too many hits to the DOM is slow, because there is a better solution, or is this just the JS potato famine of 2015?
Angular 1 ... 2... what ever is a joke. Backbone and React all the way .. 
web components are going to kill react edit: this is meant as completely tongue-in-cheek sensationalism, just like the title
DI, classes, Java-style code, annotations/decorators, class-based rather than interface-based typing (generally), etc. From [Auth0's tutorial](https://auth0.com/blog/2015/09/03/angular2-series-working-with-pipes/): @Pipe({ name: 'tempConvert' }) // The work of the pipe is handled in the tranform method with our pipe's class class TempConvertPipe implements PipeTransform { transform(value: number, args: any[]) { if(value &amp;&amp; !isNaN(value) &amp;&amp; args[0] === 'celsius') { var temp = (value - 32) * 5/9; var places = args[1]; return temp.toFixed(places) + ' C'; } return; } } ... functions masquerading as annotated classes and using inheritance. Just add some AOP and `AbstractFactoryProxyBeans` and we'll be good.
As all settings, they are stored in Drupal.settings. Therefore, for GMAP, you need to see Drupal.settings.gmap.auto1map.markers "auto1map" is the ID of your map, most of the time if you have only one on your page it will be this one IIRC. If you need to access the raw map object from Google Maps, you can use Drupal.gmap.getMap("auto1map") which will return the vars used for drawing the map (vars.markers is a copy of Drupal.settings.gmap.auto1map.markers) and the map property. If you need to extract the Marker data from the actual Google Map object it's a lot more tricky, but doable. Also, if your export needs to be done server-side, you need to find where they are added to the javascript settings, this might depends of you storage layer (for example : the Location module).
All the churn of apps that silently update in the background, without the silently updating in the background part.
Well, you were the one saying that people go around boohooing that all that nitty-gritty stuff is too hard but that knowing that stuff is "learning your job". Realistically, for better or for worse, people's jobs are to finish a project on budget, which in most places, tends to be a goal that is completely unrelated to how much time one spends mastering the javascript jedi arts or whatever earns interwebz points these days. So what if there are people who are more interested in browsing ikea catalogs than learning the intricacies of the MVC pattern, or playing office politics games? They get their job done, they get their money. I get my free-to-use app, and if I don't like it, I can go pay for a better thing or go play outside. Shrug.
In a hackernews post, A ms dev mentioned that they are working on a vim extension. They said it was a high priority too
No, but I appear to have angered some folk. People take comma placement very seriously. I don't even do it in js because I use standard as my linter. I just prefer this
I just downloaded and tried out VS Code on my game code and while it looks great, I found a basic feature that I use all the time in Sublime Text not really working in VS Code. Using "Go To Symbol..." (⇧⌘O) it seems to only recognize certain ways of declaring functions in javascript. The specific example is if I have a function `update` on an object like this: var object = {}; object.update = function () {}; And then I have another function `hunger` declared on an object via this notation: var object = { hunger: function () {} }; If I search for `hunger` it goes immediately to the function declaration. But if I search for `update` it doesn't show up in the search at all. This feature works perfectly fine in Sublime Text but doesn't work in VS Code. Is there a reason for this or is this a bug? EDIT: [Opened an issue for this on the github repo.](https://github.com/Microsoft/vscode/issues/125)
Just waiting on Safari...
My guess is that this happens because VS Code uses TypeScript under the hood to analyze your code (whether it is TS or JS). In your first example, TypeScript cannot infer the type of `object`, since you dynamically add properties to it. In your second example, TypeScript can infer the type of `object`, and that it has a `hunger` property. This allows VS Code to find the right symbol.
That makes sense. I'm sure it'd be fairly trivial to adjust the method of inferring symbols by evaluating the code as a whole and then seeing what objects are declared on the global scope and adding all their properties to the list of searchable symbols if they're also declared in the file somewhere. (I'm also sure there's a more intelligent way to go about this that someone smarter than I can or has come up with.) Sadly that's a fairly major blocker for me to pick up VS Code as a daily driver for JS work. Almost ALL methods in my code are declared in the format of the first example. Mayhap I'll go and create a bug/improvement on the github repo. 
I really like VS Code, but Sublime 3 handles React much better. Hopefully this changes things.
If the only difference is auto-update, then Edge would outdo, or keep up with, Chrome, Opera and Firefox. It doesn't. It won't. It never will.
So slap any ol' thing together. If it "works", it's good 'nuf. 
We developed the application with Angular then they came with Angular2, and no backward compatibility, wtf ?
I think it's related to the rise of React and the idea of single direction data flow. 
Lol, people like to optimize, and since vim mode is available in most editors, I don't need to relearn most of my keyboard shortcuts. Not to mention if I need to edit something through ssh
Prototypes are containers for members that are inherited and shared across multiple instances. In your literal example, you have a single instance with its own, individual (unshared) instance members. Basically, prototypes allow sharing, while instance members are not shared.
If you want to make instances, then instantiating constructor functions is one way to go. In your example, trello is basically a singleton. You can turn it into something that can produce "instances" by wrapping it in a factory function, likely using something that looks like the revealing module pattern.
could you please elaborate?
Great article! Thanks for sharing. btw: does anyone know if the keys "main" and "bin" in package.json can refer to two different files? I'm thinking about creating a module with a .js file and a cli
Agreed! I am thankful we have a language flexible enough for the discovery of all sorts of styles, each with advantages and disadvantages.
It showed no errors and everything seemed to be correct. We did however find bugs in the code for the site it self and thats why it didnt work. Problem solved! Thanks for your time! Much appreciated!
&gt; getting a syntax error on jsonlint.com That's because it's not JSON. Nothing that expects JSON is going to accept this as input. I suppose there's all sorts of ugly hacks you could use to fix the string. You could use a regex: &gt; str.replace(/new Date\((\d+), (\d+), (\d+), (\d+), (\d+)\)/g, ... function(_, y, m, d, h, m) { return '"' + new Date(y, m, d, h, m).toJSON() + '"'; }) '[{"v":"2015-01-16T12:00:00.000Z","f":"December 2015 (forecast)"},null,null,11,null,null,false],[{"v":"2016-01-16T12:00:00.000Z","f":"January 2016 (forecast)"},null,null,12,null,null,false]' This makes a lot of assumptions: - that you wanted that date format - that no string literal will contain something that matches "new Date(...)" - that every instance will use the five argument form of the `Date()` constructor You could also use eval, but that's evil. 
Very cool – signed up and watched the intro. Seems well put together.
lol some things never change
For reference, if it is a npm problem you can update with &gt; npm install -g npm
Because native ES6 imports isn't coming anytime soon. System.js ISN'T required, you can use other things such as Webpack or Browserify.
Different people will often write code according to the style that suits them best depending on the previous languages that they have used and the tools they use to write code and probably a dozen more variables. It *can* definitely feel like you're trying to read someone else's handwriting; especially when folks think that writing terse code is better somehow because you were able to fit it on a single line. Others have mentioned this too, but after devving for a long time, code style is something that bothers me a lot less these days so long as its consistent. What I dislike though is when people write code that is hard to read because they couldn't think of a better variable name than `_x` or `myVar`. My (unsolicited (sorry)) advice to you is: don't be those people/projects. Write your code so that it is readable rather than terse for the sake of being terse, don't be afraid of adding comments, and write in a consistent style so that future you and other devs will be able to easily read your code and understand it.
Node is a javascript engine running outside of a browser. No document, no window, etc. It also embraces CommonJS, giving you a library loading mechanism, and ships with a set of default libraries for things you'd expect from a command line language (filesystem stuff, os calls, etc.) Maybe more importantly, it ships with a package manager called `npm`, which lets you conveniently share your stuff as libraries, typically off of github. Lots of people use it to write server backend stuff. Some people use it to write command line tools.
Yes. Thanks. I get it now. Is there a way to mark it as solved? I'm on iOS. 
You can with `var obj = Object.create(trello)`.
With JavaScript, instead of interacting with browser's and their resources (windows, user events, DOM elements,..) you are interacting with systems (systems that may be serving data to browsers!)
This scary legalese: https://github.com/facebook/react/blob/master/PATENTS Someone else can probably explain it better than me, but the gist is that if you brought a patent suit against FB, they could revoke your license to use react (which may or may not contain patented parts, now or in the future). But it's a bit nebulous as to what they would actually do under which specific circumstances.
The [`PATENTS` file has actually been updated](https://github.com/facebook/react/commit/b8ba8c83f318b84e42933f6928f231dc0918f864) to clarify their intended position--and it seems permissive enough now.
Looks like a lot of components I see in "modern" react codebases. (The masturbatory overuse of exotic syntax features that may or may not end up in the spec)
I threw out the bathwater! Haven't heard the baby crying for a week!
But with Object.create you can't have the constructor function..and I'd argue it's also faster using 'new'.
I generally like to go over some code that shows two things, if the candidate is familiar with some of the nuances of JS and how quickly they can wrap their heads around things. My favorite is to have the person write a loop that will console.log 1-10. easy step. The next part is the clinch that most people walk directly into. I ask them to change the code so that it logs the same thing after a 1 second delay. ( run the code, wait 1 second 1-10 logs in the console. ) most people put the timeOut inside the loop, which is understandable, but it will log "11" 10 times. Seeing how the candidate works with that when I tell them it and having the candidate explain why this is happening tells me a lot about their communication skills and their depth of JS. I then ask what they can change to make it work correctly and it is fun to see what people do. I have a few of these, most less tricky than that one but they cover the basics: hoisting, Closure, currying, type corrosion ect.
No, it doesn't, but I think you've got some things confused here. For starters, even though the syntax for typeof doesn't look like a function, you should treat it like one that returns a string. So, in your first example, you're checking to see if typeof arguments[0] returns a string with a value of "object"; meanwhile, your second example will always return false since typeof ALWAYS returns a string, and a comparison to an empty object will always be false regardless if you use == or ===. Also, like /u/fix_dis pointed out, using {} is shorthand for Object.create(Object.prototype) or new Object(); so, == or === will return false since both comparisons compare value even though === also compares type. If you really want to check to see if it's an object, you can use the instanceof keyword, but typeof will be faster if you're just checking to see if it's an object. Just remember that === compares value as well.
 console.log(1); setTimeout(function() { console.log(2) }, 0); console.log(3); What order do they print? Promise resolve/reject. Talk about both. call/apply/bind. What do they do and when/why to use them. **offtopic** Can I work there?
ah, i gotcha! Thank you!
I'm intrigued. Do most of your candidates know anything about currying before they walk into your interview? I've never worked with someone that really understood currying/partials in JS and regularly receive criticism for using them.
Exactly. There is always a hack, somewhere, that a developer feels terrible about, but there was no way around it at that time with all of the constraints involved. 
Here's a good talk from Guy Bedford on SystemJS and JSPM: https://www.youtube.com/watch?v=szJjsduHBQQ
Pretty transparent guerilla marketing for your product, OP Also, YET ANOTHER EXCEL CLONE IN THE BROWSER?
closures are a way to initialize variables outside of the scope of a function, but is private by default since the variable or whatever was local to the on type function. Normally they're used for things like counting the number of times a function has been called. 
Oh, I agree with him. I wish it was easier to whitelist sites and extensions, and if it was, I would blacklist all sites from their javascript. The default site uses javascript to replace blink and marquee, or worse.
oh I know, but there never is enough IMO. I think interview questions are fun because when reading them I always discover random gaps in my knowledge I didn't know before. they're like riddles, and it's always fun to see people debate and bicker about the most efficient solution. But maybe that's just me. 
I wasn't trying to scold you or anything like that, sorry if it came across that way. Rather, I wanted to point out those posts because they cover a majority of the questions (and types of questions) that you're likely face. Those posts were some of the highest-rated posts we've had in this sub in a long time -- both are in the [top 4 for the entire year](https://www.reddit.com/r/javascript/top/?sort=top&amp;t=year). Good luck!
for spam you could parse for certain clusters of key words they look spamy , I mean whenever I see something like this: Whoa, yeah good article! I agree with Dave, I mean I who would've thought my own grandmother could be making 3000 dollars a day all while working from the comfort of her own home. Thanks to OBVIOUS_PRYAMIDSCHEME.COM she is now making more in retirement than she ever did while working as a nurse!
I always ask candidates to write a general purpose curry function. If they have no clue what currying is, I'll often wait until after we've finished writing the code before explaining what they've written and why it's so useful, so as not to confuse them beforehand. Tell whoever is criticizing you to go shit in their hat.
`===` does a "type check" in the sense that it won't try to find equality between different types through coercion like `==` does. For example `==` will use coercion to allow `1 == "1"` to be true even though 1 is a number and "1" is a string. `==` has that extra coercion step that, in some cases, will allow values of different types (namely primitives) to still equal each other even though they're not technically the same. `===` doesn't do this and performs a stricter equality check that doesn't do any kind of conversion of either of the values compared to make them possibly equal. Either they're the same or they're not. Generally you'll want to use `===` over `==` because it doesn't have that extra step and is therefore more accurate and slightly more performant. For your case, stick with the `typeof` and `===`.
oh I know, and it was helpful, I read through them. Now I have a question should I rent a Tuxedo for the interview?
The correct answer is: "This is not JSON, thus it cannot be parsed. Hit whatever is generating this with a stick until it generates JSON, then parse it." If that's not possible, and you really, realllllly need this to work, then you could try: 1. Writing your own parser. This is very hard. 2. Using a regexp to mangle the output until it works (someone already posted a solution for this), but it's going to be very fragile. 3. Using `eval`. Don't do this, it's a terrible, terrible idea. For reference, the eval solution would be something like this: `a = '[[{"v":new Date(2015, 11, 16, 4, 0),"f":"December 2015 (forecast)"},null,null,11,null,null,false],[{"v":new Date(2016, 0, 16, 4, 0),"f":"January 2016 (forecast)"},null,null,12,null,null,false]]'` `b = eval(a)` And presto, b is now a JS object, so `b[1][0].v instanceof Date` is `true`. Of course, you're literally executing JS code from a third party that you have no control over (because if you did have control over it, you could make it be actual JSON, and skip this entire mess). It's just asking for Terrible Things To Happen, and it's the sort of bad practice that will make people judge you. Harshly. I feel like your question is just a symptom of an underlying problem; there's no legitimate reason why you should ever need to solve this problem. Where is this data coming from, and why can't it be serialized properly?
I was asked in an interview to implement `_.once`, `_.throttle`, and `_.debounce` from the underscore library. I thought those were good JS-language questions that I'd thought about giving in an interview myself, and they require knowledge of how closures work among other things.
Also - Proxy in ES6 which can solve the same problem in a more generic and less obtrusive way.
by title do you mean the content of the comment? And that would seem kinda expensive, is it only compared against recent entries? 
what if a user named OdoyleBro69, has thousands of comments over a long period of time, and lets say OdoyleBro69 wrote **O'doyle rules!!!** once back in November of 2011, and then once again in November of 2015 created a comment record with the title **O'doyle rules!!!** again would that be marked as spam? Also what if one comment was **O'doyle rules!!!** and then another comment **O'doyle rules!** was created would the spam filter catch the comment? 
I may be misremembering the names of the keys, but it's a moot point, right? The question as posed to me boiled down to writing a function that returned an array of all the objects in a `comments` array that had the same values for two particular keys.
You should take a look at this: https://github.com/HubSpot/humanize
&gt; I ask them to change the code so that it logs the same thing after 1 second 1 second between iterations I assume is what you're going for, and not 1 second delay, THEN console log all 10?
Can confirm, was tripped up. Now terrified of using any classical object creation and class patterns in JS since `this` feels unreliable and fragile unless you do explicit `bind|call|apply`. Would much rather just stick with factory functions that return objects and have local closure for privacy (unless I need a lot of them - then a class blueprint will have a far cheaper memory footprint)
I'm actually aware of humanize, but iirc it pretty much just does substring operations correct? I need to fit text into a container in the most aesthetic way, basically insert line breaks and hyphens and ellipses intelligently given container size.
This will work - however you are so close to a nice functional iteration approach that avoids the pitfalls of a global state (and needing to remember to clearInterval. function count(i) { if (i &lt; 11) { console.log(i); setTimeout(function() { count(i + 1); }, 1000); } } count(1); 
That is pretty clever, and it gets the job done. As u/TheBeardofGilgamesh mentioned though, you should clean up that Interval so it isn't silently running forever. It is also worth pointing out that this is not recursion, it is an interval. Recursion is a function that calls itself. ( which could also be used to solve the problem but would be an over complicated way to do so ) It seems I should have been more clear in my comment though, what I have them write is something that will wait 1 second and then log 1-10. So run the code, 1 second delay, 1-10 logs in the console. The process generally goes like this: "write a loop that will log 1-10 in the console" for( var i = 1; i&lt;=10; i++ ){ console.log(i); } "Awesome now change it do log 1-10 after a 1 second delay" Generally the loop gets changed to: for( var i = 1; i&lt;=10; i++ ){ setTimeout(function(){ console.log(i); },1000); } which as stated will log 11 ( in this case ) 10 times because setTimeout is asynchronous. The loop runs, i gets updated all the way to 11, and *then* the timeout callbacks start getting called. We have a good discussion in which I get to see how they handle problem solving and get to asses their ability to communicate programming theory. Then the question "Make it work correctly" **solutions** Most impressive to me is to levy ES6's ```let```. I requires Minimal code change and demonstrates an interest in upcoming technologies. This is by far my favorite solution: for( let i = 1; i&lt;=10; i++ ){ setTimeout(function(){ console.log(i); },1000); } Next favorite is the use of ES5's bind, again, minimal code changes, displays an understanding of manipulating context of a method. for( var i = 1; i&lt;=10; i++ ){ setTimeout(function(){ console.log(this); }.bind(i),1000); } And my Third favorite and probably the best functionally is to avoid the asynchronous problem all together by putting the entire loop in the timeout. Its simple, straightforward and any one who gets to debug this code next is going to understand it immediately. setTimeout(function(){ for( var i = 1; i&lt;=10; i++ ){ console.log(i); } }, 1000); There are two other solutions I can think of worth noting that I won't type out: - using closures to pass in i by copy. - using call/apply to preserve a copy of i for the callback.
&gt; Could this code also be valid? &gt; ({} === {}) false Anyhow, sounds like you want something like optional named parameters with default values. You can emulate something like that with destructuring in parameters (ES6): function foo({a = 'uno', b = 'dos'} = {}) { console.log(a, b); } foo(); // uno dos foo({a: 'foo'}); // foo dos If you want something like varargs, use rest (ES6): function foo(...args) { console.log(args); } foo(); // [] foo(1, 2); // [1, 2]
&gt; The instructions are listed above. As of right now, I can't get my JS to check for nulls in the fields. I need an alert to say "Make sure all fields are completed." I also need an alert to say "Thanks first_name last_name for your order." I also need a total price to come up for this which includes a 7% sales tax.
I'm glad you find it useful and happy to help. In my opinion it is good to have an understanding of how to DOM manipulation natively, But I'm a bit of a purest and a huge fan of [vanilla js](http://vanilla-js.com/). In real life you'll find you very very rarely need to do DOM manipulation by hand.
MDN is my favorite for JS docs, otherwise a good google will always lead you to stack overflow. [here](http://stackoverflow.com/questions/2696692/setinterval-vs-settimeout) is a good question about interval and timeout. 
I'd add: c.call(a); new c(); 
 I wouldn't call it inheritance - its an effect of using a variable from an outer scope and creating a closure.
you're right it's not like there is a class that would make it inheritable, it's just a variable that only one function/functions within that function can access. Thanks for pointing these things out.
The actual issue is that the `typeof` operator always results in a string, not that `{}` will be different from any variable or object property previously set; alternatively, you may not have understood that `typeof` has precedence over comparison operators like `===` (that is, `typeof arguments[0] === {}` is the same as `(typeof arguments[0]) === {}`), so even if the first argument were an empty plain object, the comparison would still be string-to-object rather than object-to-object. Although the mentions of ES6 features are nice, not all JS code is meant to be either transpiled, or deployed exclusively to modern browsers, so techniques like type-checking entries of the `arguments` object are still useful to know.
&gt;I feel like your question is just a symptom of an underlying problem I agree, and I think it's because I'm trying to take the Google Trends data straight off of their page. They don't have any API to offer developers and really enforce their quota limit - if I hit the page more than five to ten times in a minute, they block me out. &gt;Where is this data coming from, and why can't it be serialized properly? They have a variable chartData that contains a javascript object with all the dates and values to draw the graph, and I'm pulling that from an XMLHttpRequest responseText. 
Jeez, this boilerplate is immense... /// &lt;reference path="typings/angular2/angular2.d.ts" /&gt; import {Component, View, bootstrap} from 'angular2/angular2'; @Component({ selector: 'pipes' }) @View({ templateUrl: 'pipesTemplate.html' }) // Component controller class PipesAppComponent { date: Date; constructor() { this.date = new Date(); } } bootstrap(PipesAppComponent); There is only one line of meaningful code in these 15-some-odd lines. Something equivalent in vue would be like: Vue.filter('now', (_) =&gt; new Date()) Even angular 1.0 wasn't *this* bad.
Right, which is why I said "most". Re: classes in React, I doubt they will remain in vogue for too much longer for large swathes of most applications. You can now write `const Button = () =&gt; (&lt;div&gt;&lt;/div&gt;)` instead of `class Button extends React.Component { render() { return (&lt;div&gt;Holy shit&lt;/div&gt;); } }`.
It really does remind me of when I did some Java programming. I remember how painful Java was and I don't wish upon anybody such a painful fate.
&gt; The actual issue is that the typeof operator always results in a string, not that {} will be different from any variable or object property previously set That "whatever === {}" will always be false is a fairly big issue, I daresay. &gt; you may not have understood that [...] I didn't actually read the rest of the code. I saw the "=== {}" which is always false. The end. &gt; Although the mentions of ES6 features are nice OP didn't say what they wanted. I guessed and provided modern alternatives. &gt; not all JS code is meant to be either transpiled, or deployed exclusively to modern browsers, so techniques like type-checking entries of the arguments object are still useful to know. If you want to see an ES3/5 answer, write it yourself. Keeping outdated browsers on life support isn't in my interest.
Hmmm, I suppose the distinction between the two could be a little bit muddied by things like mithril and riot, which both have tiny routers and have at least a small opinion on app structure, but have otherwise very small APIs. I'm certainly not complaining that mithril has a tiny router built in, but I can see your point how that might disqualify it from being considered just a *library*.
What is System.js used in?
Your point is valid, but off topic. jQuery is not a framework, it's a library. Straight from their homepage: &gt; jQuery is a fast, small, and feature-rich JavaScript library. Framework in this case would indicate something like Angular, React, Ember or Backbone. Tools that add structure and reusable patterns and standards to how your app is created, maintained, tested and deployed. I see enough posts here explaining the ups and down of both sides so I'll leave my reply at that.
Poor form (no pun intended) to post your assignment here, I'm sure the employer would not be appreciative.
I understand how it could've come across as this, but I was really just looking for random tidbits from different people rather than all the info from one person.
Yeah. There's also things like mithril which take that concept a bit further, so we might see a shift towards more functions returning JSX literals instead of classes being overused so much.
I'm aware of what jQuery is and isn't. My comparison was merely to show an example of a tool that is widely regarded as not worth its weight in many use cases. In that light it should be easy to see that there is an argument to be made for libraries which go far beyond the needs of a particular app. I don't believe it's an argument with a single answer or else we wouldn't have so many frameworks. No tool, or any tool is going to fit every use case. 
It stays in the same page because it returns false, I guess.
Try a little harder, I'm sure you'll find the answer out there! Remember that [MDN](https://developer.mozilla.org/en-US/) is a great resource (and will often answer your question). As for you having difficulty checking the inputs, try [this pen](http://codepen.io/anon/pen/qOvKVL). It's broken down to the most basic components so it shouldn't be hard to follow. But if you have a question still, feel free to ask. P.S. Post your code in codepen or jsfiddle so that we can help you
Why doesn't anyone bring up Brackets in these discussions ? It's a text editor aiming for the same use cases and I like it damnit :(
&gt; That "whatever === {}" will always be false is a fairly big issue, I daresay. It wasn't the issue brought up by the OP's code.
Atm i'm building an angular + es6 + webpack application. So this and the [NG6-starter](https://github.com/AngularClass/NG6-starter/) is helping me a lot.
It's there in the second example.
That's why you should reload only the modules changed: https://github.com/capaj/jspm-hot-reloader
&lt;button type="button"&gt;Masukkan&lt;/button&gt; Just to make sure it is not a reload thing
Even though it's true that a comparison against a newly created object will always be false, the main issue was that the result of `typeof` is a string and that it was being compared against an object rather than the string `'object'`.
What is the future of Javascript and Node.js?
Wow. A copy'n'paste of a [Wired article](http://www.wired.com/2015/11/i-turned-off-javascript-for-a-whole-week-and-it-was-glorious/)? And even removed the real author of the post?
no decorators?
The way the question is asked would make me think you're expecting me to provide an answer with a promise (wait 1 sec THEN log). So I would go full ES6 and do : var q = new Promise(function(resolve) { setTimeout(function() { resolve(10); }, 1000); }).then(function(m) { for(var i=1; i&lt;=m; i++) { console.log(i); } }); I might go as far as making a generator instead of the for loop.
Or for the (possible correctly) pessimistic: Embrace, extend, extinguish. Open source does thankfully make that much less of a fear.
6 months is sort of short for an LTS release, right? I have only really ever paid attention on OSs so I am not too sure.
Perhaps I'm having a massive brainfart here, but can't you just copy + modify an object like so? var a = {foo: 'bar', moo: 'hah'} var b = a; a.yo = 'hi'; b.foo = 'bbb'; a; // {foo: 'bar', moo: 'hah', yo: 'hi'} b; // {foo: 'bbb', moo: 'hah'} Or do layers of complexity somehow not make this possible? I know Mongo can be a bit funky with this sorta thing, but that's an issue with Mongo rather than JS afaik...
It's pretty yes but I think the vscode guys put more thought into it. 
Couldn't you just construct 600 objects with the same arguments used to construct object a? So just make a loop with the constructor and the code to modify the new object in it. ``` var myObs = []; for (var a=0; a&lt;600; a++){ var newOb = new ObjectA(1,2,3); newOb.id = a*4; myObs.push( newOb ) } ```
This doesn't work so well for nested Date objects. The deep lodash.clone() seems to work but it still pisses me off that I have to download a library for what I feel should be an inbuilt function.
lodash's deep clone seems to be working well for my objects so far. It still bugs me that I need to download a javascript library for what I think should be an inbuilt function.
That's fair. 39 would kill me. Sleep well
easy! JS uses Array[index] to get an element from array. ex: `list1[0]` is the first elem. old: list1workings = [(Math.random()*list1.length)|0]; list2workings = [(Math.random()*list2.length)|0]; new: list1workings = list1[(Math.random()*list1.length)|0]; list2workings = list2[(Math.random()*list2.length)|0];
Listen to what you're saying. You said I'm absolutely right while complaining I'm jumping on people for saying the opposite. Talking out of both sides of your mouth, aren't you? &gt;The company has been making some dramatic changes over the last couple years. Been hearing all that since IE7. Been hearing, "We will be good", while they take Linux to court while advocating open source. They're a fourth rate browser but claim compatability. Been hearing about "the last couple of years" for a decade now. And the evidence is clear. What's really bizarre is, your comment is the same BS I've heard on forums two years ago and more! Two years of claimed changes don't cover up for two decades of proven bad behavior on two continents. And the guy I railed against is a Microsoftie who is in the same position of a guy I'm close to. I know his kind. You kids don't know the past. I recognize their behavior. Note this: Microsoft is opening up their software to Linux development, yet, have no Linux products and have Linux distros in court right now. Hmm. Microsoft is our friend?
Thanks. does nodejs support this?
You'll have to use a transpiler like Babel to gain access to that method.
It's an excellent post and I sometimes use closures like this, but can someone clear something up for me? Towards the end of the article, he starts to export multiple functions. Now traditionally, when my code enters this territory I feel like it's time to use a class (ready the brigade). Is this right? Because with the prototypical implementation, all instances that have a method `foo` refer to the same method `foo`. But with this guy's example, each method `foo` would be brand new. Which I assume is worse for performance? And if so, what rule of thumb do you guys use to decide when to use each pattern?
&gt; But why is Microsoft investing so much money in this open source editor built on electron, if the world already has Atom? I suspect a certain amount of "not invented here", but if the goals/direction of Atom sufficiently diverge from MS's plan then that is valid reason to roll their own rather than enhancing or branching Atom especially if they are sharing code with other projects within MS so they were not starting from scratch and/or are feeding useful code into work elsewhere. And there is no harm in a little friendly competition between similar products to inspire/drive improvements! FYI: I've not used either product yet, but intend to try both shortly so I'm keeping an eye on how they develop.
I've had a lot of job interviews where I've been asked what a closure is, but I've always struggled to answer in a convincing manner, despite using them everyday. How would you phrase your answer in a verbal manner? "A closure is a ... "
Bro, do you even run code? &gt; a; { foo: 'bbb', moo: 'hah', yo: 'hi' } &gt; b; { foo: 'bbb', moo: 'hah', yo: 'hi' } b just points to a. Its the same object because javascript passes by reference.
You confused me for a whole 30 seconds you bastard.
Another possible syntax available via Babel (still experimental, but my favorite): const foo = { foo : 'foo', bar : 'bar' }; const notFoo = { ...foo, foo : 'notFoo' }; console.log(foo): // { foo : 'foo', bar : 'bar' }; console.log(notFoo): // { foo : 'notFoo', bar : 'bar' };
 for( var i = 0; i &lt;= 10; i++ ) { (function(i) { setTimeout( function() { console.log(i) }, 1000*i); }(i)); }
Sure it is, instead of including `bundle.js` on the page, you include your entry javascript file directly which uses all the imports in it.
It's a function value which contains references to the environment: here "the environment" can include local variables at the point of definition, which doesn't make sense for traditional top-level functions. I think wikipedia gives some good reformulations at different levels in the [article on closures](https://en.wikipedia.org/wiki/Closure_%28computer_programming%29). &gt; Operationally, a closure is a record storing a function together with an environment I.e., basically what I proposed. I really like this one (under Anonymous functions) for OO programmers: &gt; a closure is an instance of a function 
"A closure is when a function retains a reference to its lexical scope that existed at define time." "What this means is the function can use references that may be out of scope at call time. This is useful for callback functions that are called long after they are defined, and for hiding functionality from a public interface"
You're right, only upside of system.js is that you can use it for dynamic imports as well. Whereas with webpack/browserify, you need to solve it yourself. And if you bring in a lib for that, that lib stays with you even after System is native.
Just tried this in Node v5 and it is indeed supported.
Interesting. To be completely honest, I haven't used or looked into System.js, all I've ever seen of it was watching Egghead.io stuff where they use it.
If you use babel you can use the spreads operator. const a = {wow: 'wow'} const b = {cool: 'cool'} const c = {...a, ...b} console.log(c) // {"wow":"wow","cool":"cool"}
My mistake. I thought you were saying v4.2 was LTS until v6 came out in six months. I think I misread it.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Looks like Github's Atom is officially going from coffescript to ES6 (x-post from \/r\/javascript)](https://np.reddit.com/r/programming/comments/3tftgm/looks_like_githubs_atom_is_officially_going_from/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Okay, I'll try it. Thanks.
To be clear, this isn't an official roadmap announcement or anything like that. An official plugin for atom moved from coffee to ES6 and someone asked if it was symptomatic, to which the response was "we're pro (the movement to ES6)". 
No worries. v4 is LTS, v5 is NOT, v6 is LTS. v7 is NOT, etc.
Feel free to be more specific.
Yeah but I don't think they should be updating major versions that fast. I share the opinion from Linux development, they say it's only a number and if they followed semver they would be on version 30 already. They should update some number but be updating major numbers it's bad on big software. I would rather have more significant updates on small version bumps. I miss when we were stuck on v0.10 and we knew v0.12 was a big update and couldn't wait until it got released. That in my opinion was better version management number. Now it doesn't mean anything to have v4 or v5. Take as an example to other programming languages, Ruby, Python, PHP, they all have small version numbers compared to their age.
For copying a mass number of items with minor changes between them, try using immutable.js. It will ensure that you get a new copy for every change without duplicating the similarities.
that is javascript object notation. { key: value, key2: value2, .... }
I have had some problems with the performance of Atom, but it's possible that is only a Windows problem. It seems a good bit slower than Sublime.
Are ES6 features already supported by electron?
No, but they're using Babel as it shows in the linked commit. 
Hi /u/connexionwithal, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
On OS X, I tried Atom for a while for web development. Its performance was just not up to par with Sublime Text. Fuzzy file search &amp; open was slow &amp; laggy, and sometimes if a file was much too long for the jscs-lint plugin, the whole editor would freeze and I'd have to kill the app's process via the terminal. I haven't tried Atom yet for a few months so maybe it's improved, but snappiness in an editor is absolutely critical.
I've been trying to find answers in this area as well. This really surprised me: ~~Look at this [jsperf](http://jsperf.com/nested-named-functions)~~ EDIT2: [This is a much better version of that jsperf](http://jsperf.com/nested-named-functions/47) It appears in this little example seems to show (on some engines - like Windows Chrome/V8) a ~~90%~~ large speed difference with inner functions However, firefox seems to not really care about the differences - yet is much slower than Chrome in both cases. There seems like there would have to be some overhear with nested functions. Like how they sort-of "capture" variable references in their parents scopes. Exactly how much I suppose can vary on the engine's implementation. ~~[EDIT: or are these results due to parent scope variable references and not so much purely a nested function thing, I'll try to make a new branch of this jsperf.]~~ There's a speed difference, but not as big as the broken original version I linked to. I have more questions as well: Does a 1000 line function have more overhead then a 2 line function? Does a function that references 1000 variables in its parent scope have more overhead then one that references only 10. What about variables in a grandparent's scope? 
In as few words as possible: Crossing a scope boundary to access a reference directly.
This is a good and acceptable answer as well, IIFEs are pretty handy. I give full points for this answer. Bonus points if you can tell me what I don't like about this answer, ( and for that matter what I don't like about the ```bind``` approach as well )
OK, slightly more challenging. Array.prototype.monkeyPatchReverse = function(x) { var result = []; while(this.length) { result.push(this.pop()); } return result; } "123".split('').monkeyPatchReverse().join('') // 321
this is reversing an array not a string though
Ah, okay ... the way you phrased it, I had the impression you weren't allowed to use ```for``` loops.
It works! I can honestly say I have never had someone use promises for this questions during an interview. If someone *did* then I'd probably segway into a conversation about why they choose to use a promise. What I'd be trying to get at is the difference between "smart code" and "clever code". *smart* code: doing something complicated in a simple way. *clever* code: doing something simple in a complicated way. A promise is an extremely useful tool and has many many applications. For this example, however, it is a bit overkill. Possibly the candidate was wanting to show off their ES6 prowess and deep understand of an involved concept. In that case, "points" should be rewarded as long as it is understood that there are simpler ways that this can ( and should ) be done. 
That makes sooo much more sense. I too was assuming you were asking Juniors to write recursive prototype methods.
10/10 would subscribe. (although only the map function is meant to be a prototype function)
i am happy! cus this is a great answer lol
What themes are that?
༼;´༎ຶ ۝ ༎ຶ༽
As of Electron 32 (based on Chrome 45) it supports most of them: enhanced object literals, method shorthand, Symbols, const, let, classes, arrow functions, Promises, Iterators and for...of, generators, template strings, and a few more. When Electron upgrades to Chrome 48 it will get rest/spread and new.target.
Ah, yes, so you mean it breaks (or rather, works as expected) for everything not allowed in the JSON format. Why are you expecting anything different? I mean, this is akin to putting your car on a runway and being upset that it doesn't fly. It's not a hacky solution to OPs problem - it's a solution to an entirely different problem. The solution isn't wrong or inadequate or even hacky - the Problem Exists Between Keyboard And Chair; someone chose something they didn't fully understand and declared it hacky because they thought it should work.
I would use it (do a lot of TypeScript), but it doesn't even have code folding yet. For me, it isn't ready. [Here is the roadmap](https://github.com/Microsoft/vscode/wiki/Roadmap) I use Atom at the moment. Love the tooling and styling of it. I don't find VS Code to be equal just yet. But, the direction of Code is exactly what i'm looking for, nice debugging experience and performance. MS is doing a great job, very happy that it's OSS and they are investing in extensions. I'm waiting for code folding and ui extensibility, then i'll surely move.
Oh yeah they are supporting a version of Node that was released earlier this year. I think from January 2015?
You can't show us that and not tell us how to get the same look. :)
http://www.reddit.com/r/javascript/comments/3tfpxa/githubs_atom_moving_from_coffeescript_to_es6/cx5vtvj
I would love them to move. I would have written a few plugins by now if it didn’t require learning CoffeeScript.
It doesn't require learning CoffeScript, you just rename your `.coffee` or `.cson`files to `.js` and `.json`. Your JS source files need to have this/these at the top in order to be compiled with Babel. 'use babel'; "use babel"; /** @babel */; [source.](http://git.io/v4Sb0)
&gt; They don't need to. Told you, they can update minor versions, they don't have to be major, I would prefer v4.30 than v30.2. What do you do if v4.25 brings a new feature? Nothing, new feature doesn't really make or break your app, updating is fine. But v4.27 brings a breaking change, now what? You going to vet every version manually before upgrading? Doubt it. Semver fixes that. Whether it's v4.30 or v6.4, the number positioning doesn't matter, it's all about keeping your system from breaking. Don't want to update so much? Don't. Nobody says you have to use the latest and greatest. I'm sure there's still plenty of people using v0.10 in production. I don't use v5. I am on v4 LTS and will be until v6 goes LTS.
Future coders must be aware that your implementation is flawed (eg, adding a date to the object upstream somewhere breaks it). Becoming aware of this most likely means they have to track down a bug until they come across your code. That is bad for maintainability and a hacky solution. Using a pre-written deep clone function is going to save you from these problems and will be faster too.
If you are deep copying huge amounts of data and then modifying parts of it, then immutableJS or mori will probably be more space-efficient in addition to being easier to setup and use.
Excellent article! Thanks shiroyasha23.
What's it look like to consume? Like calling a normal dart function?
Took a second pass of the readme before I realized it was not an Oauth library lol
Yup, you can consume it then like a normal dart function. @JS('google.maps') library maps; @JS() class Map { external Map(Location location); } Then consume it like: import 'package:google_maps/maps.dart'; main() { new Map(...) }
I did something like that using highcharts. http://www.highcharts.com/demo/scatter 
Have you looked at [d3js](http://d3js.org/)?
It's so hard to let go of Sublime Text. So that's what made me stick with it... If it ain't broken don't fix it, so when Atoms gives me same things as Sublime, plus something extra, I switch... Btw I do not do anything in JS/HTML/CSS or web related so, maybe it is more geared towards those people...
I have never tried Atom. What languages does its linter work with?
This doesn't sound right. It's single-threaded. An event won't be handled while you're inside some loop. It also won't interrupt a loop. My guess is that your observation isn't quite right.
Where are the specs for Standard and semi-standard? I looked, couldn't find them quickly.
Slide deck navigation is generally done via the cursor keys. Left/right being prev/next. "Clickers" (wireless presenters) also use those key codes.
Here's standard: https://github.com/feross/standard/blob/master/README.md Here's semi-standard: https://github.com/Flet/semistandard/blob/master/README.md It's just Standard with mandatory semicolons. 
Or if you have code you can't access from one way or another from the outside, maybe it should be rethinked...
tl;dr: the algorithm powering V8's Math.random() is very poor quality. For many use cases you can't safely pretend its output is actually random. Don't use it for anything non-trivial that you care about. It should probably be fixed. In the meantime, use crypto.randomBytes() or crypto.getRandomValues() instead edit: words
Well, you can get a web browser in Atom, does that count as something extra?
Why are people downvoting the bot :(
It's slow for me on OSX but fine on Windows 10. 
For now I'll just post [how the event queue is managed in JS](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/), but I know that there is strange and absurd exceptions... I'll find that ! EDIT : [There you go !](http://stackoverflow.com/questions/2734025/is-javascript-guaranteed-to-be-single-threaded/2734311) It doesn't concern your problem, but I hope it will help you understand what happens. (PS : please provide samples if you want some help !)
/s
Good article, bad clickbait title. Math.random() is not broken. It's a crappy algorithm, but it does exactly what it's supposed to do: http://www.ecma-international.org/ecma-262/6.0/index.html#sec-math.random Anyhow, I recommend to file a bug. People expect it to be on par with a crappy LCG. So, it should be at least as good as one of those.
Yea you definitely shouldn't use Math.random() for anything crypto-related, but even for lots of non-crypto purposes where a good non-CS PRNG should work fine (like Monte Carlo simulations or generating shuffles of an array) the implementation of Math.random() in V8 can be problematic. There are better algorithms than MWC1616, which V8 uses, that have zero drawbacks and avoid these problems. So I don't see any reason for V8 to keep the current implementation. Same goes for SpiderMonkey's use of the Java LCG (although at least that generator is fast).
It's hardly surprising as a choice if they were using coffeescript before. Though this is in the context of babel; your semi-colons will exist in the compiled code one way or the other. I don't see why it bothers you so much.
Fair enough... it's a bit hyperbolic. "Crappy" is probably more accurate than "broken." However, the generator is bad enough that I actually think it's debatable, especially given the intended audience and environment. At what point is a "crappy" generator considered "broken?" MINSTD was the baseline in the 90s, and MWC1616 is worse than that. These days the baseline seems even higher -- Java's SplittableRandom requires a period of 2^64 and no failures on Dieharder. The spec is shitty, and it'd be hard to argue that V8 violates it. But neither would the simple LCG in the article. There's really no excuse to use such a poor generator when there are better alternatives with no drawbacks. I think the baseline should be "will a typical developer ever need to worry about this not being random enough?" There are generators that are as fast and memory efficient as MWC1616 that meet this standard. By this standard, Math.random() is broken.
Started using standard a few weeks ago. The code looks real nice without the semicolons but it was hard to break the habit. 
You will lose un-json-ble properties doing so (ex : function, ES6 Collections, ...)
I just saw your quiz but I'm at the point in life where I don't have to take quizzes anymore and definitely with your tomfoolery. Suffice to say, I could do it easily if you paid me. I never do anything for free.
d3js looks promising, thanks!
I would solve that by adding one more level. VERSION.MAJOR.MINOR.PATCH major, minor and patch can still mean the same but now you don't have to be bumping you version number that fast. That's idiotic. By the way I just found something that sums up my thoughts entirely https://gist.github.com/jashkenas/cbd2b088e20279ae2c8e Now you get the fear out of your head of breaking semver. It's not the bible. EDIT: Here's an issue that talks about exactly what I think https://github.com/mojombo/semver/issues/213
Is that something that's actually useful though?
Don't feel bad, the bot don't care.
Haha that's right, it helps :)
Be wary though, in node 0.12 `crypto.randomBytes()` will throw an error if there isn't enough entropy. https://nodejs.org/docs/v0.12.0/api/crypto.html#crypto_crypto_randombytes_size_callback
Coffescript looks much more clearer than "stock" es6, in my opinion. I hope they won't switch.
Great post!
Still have to understand coffeescript to look at atom's code and understand what's going on. I don't know about you, but I don't just blindly start developing plugins for something I don't know how works.
If you want to use semicolons, go ahead. Just use [`standard-format`](https://github.com/maxogden/standard-format) when you're done to comply with `standard`. 
Heh. That's lame. There should really be access to a good CSPRNG that doesn't block (or throw) like urandom.
I've tried Dart sometime ago. It is a good language, better than JS but not better enough. My biggest disappointment is no support for non-nullable types: https://github.com/dart-lang/sdk/issues/22 (same for TypeScript btw). All other modern languages have this feature (Flow, Swift, Rust, Kotlin, Ceylon...).
Auto formatters are always really nice when you have a standard.
Technically isn't CoffeeScript =&gt; ES6 conversion a glorified search and replace (ie. syntax replacement but no unsupported features)? Is there anything in CoffeeScript that isn't supported by ES6 that would make this conversion more than an intern's week work? ((btw I understand that more than just doing the work and committing is needed, even more at this scale, what I'm saying is that they could do it file by file and be done at some point in the short term))
[Perhaps this will help](https://gist.github.com/JohnathanWeisner/c27367def46f1729ab68) It's a JS sudoku solver I wrote a while ago.
Great explanation. Thank you for writing this!
unless you want to write a ui, in which case you must extend cs classes, using cs specific custom 'inherit' code.
You're ignoring part of what I'm saying: &gt; What react and any other guy will hit is that the "first" page is still kind of slow to load. No, the first page won't be "kind of slow" -- React is _not_ a bottleneck to rendering the first page, and it _is_ rendered on the server. 100-500ms is ridiculously slow though...
&gt; Great explanation. Thank you for writing this! You're welcome! :) :) :)
Coffee's class syntax is where you can mostly clearly see its influence on ES6. I imagine out of all of the things in coffeescript, classes are not going to be the thing that is hard for ES6 people to read and understand.
Another crypto API written by someone who didn't know what they were doing. Tracking entropy input [is simply wrong](http://blog.cr.yp.to/20140205-entropy.html). 256 bits of entropy is enough to safely generate all the numbers you'd ever need.
standard also badly (meaning nobody does that) enforces a space after a function name: class Foo { name (arg) { ... } } function name (arg) { ... } Instead of: class Foo { name(arg) { ... } } function name(arg) { ... } Recuring complains about it: - https://github.com/feross/standard/issues/311 - https://github.com/feross/standard/issues/89 - https://github.com/feross/standard/issues/217 - https://github.com/feross/standard/issues/318 - https://github.com/feross/standard/issues/164
To me, they look exactly the same. Then again, your formatting is messed up, so they could be different. EDIT: never mind, its the space after the function name. I think it's consistent with having spaces after `if`, etc
Wow. I literally write my code opposite of 90% of that standard.
This is the same principle on which section 3.2.3 of SICP is based https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%_sec_3.2.3
Unless you need a shim.
Use hardware random number generators: https://www.random.org/
You're right, I am trying to achieve optional named parameters and the ES6 technique looks clean and I like that! In terms of transpiling, what are you recommendations for writing ES6 code and making it work on other browsers. Would I be looking at Closure for example? 
The confusion was arose because I didn't know typeof was returning a string. I have seen code written like so: if(george === underfined) { //do something } I thought could get away with writing code which was similar to check against an object. 
You can use Babel or Traceur. Babel seems to be more popular and it has plugins for all kinds of things. I also recommend to give TypeScript a try. It supports most of the important ES6 features. If you compile anyways, you might as well use TS which has much better tooling to offer. Refer to the Kangax's compat table if you want to know exactly which features are currently supported by browsers and compilers: http://kangax.github.io/compat-table/es6/
I got it. Thank you kenman.
There is a single "=" in your `if`. You need 2 or 3: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#Equality_operators Well, since that function returns a boolean, you don't have to compare it with `true` anyways. if (hasNumber.test(userName)) {...} Pro-tip: Don't use negated names like "noError". They make the code confusing to read. Use "valid" or "isValid" instead. **Edit:** Always check the console for errors. Press F12 to open your browser's dev tools and then go to the "Console" tab. Your invalid assignment should have resulted in an error.
I prefer http://www.ractivejs.org
I am checking the console. Its not showing any errors but it still isnt working. 2nd attempt: hasNumber.test(userName) if (hasNumber.test(userName)){ error == false;} else{ alert("Missing #") } }
I'm thinking this is what he's referring to: your-project-directory/ public/ node_modules/ package.json node_modules/ package.json So you have two `package.json` files, one for the backend in your main directory, and one for your front-end files in the `public` directory. `public` is just a common name for "these are the files that the browser will use" directory.
http://jsfiddle.net/d7enxq3y/ http://i.imgur.com/MB2sD7c.png
Why would you open MB size files, though?
You thinly wrapped [findAndReplaceDOMText](https://www.npmjs.com/package/findandreplacedomtext), which more accurately describes itself as a utility, added an additional 51 lines (including whitespace formatting) that restricts the functionality down to creating links out of three types of social media formats, and called it the [mentionify](https://www.npmjs.com/package/mentionify) library. Well done. Here's 10 lines that does the same thing, with zero dependancies. var createLinks = function (element, prefix, target) { var re = new RegExp('\\B(' + prefix + ')([a-z0-9-_]+)\\b', 'igm') var texts = document.evaluate('.//text()', element, null, XPathResult.ANY_TYPE) var text = texts.iterateNext() while (text) { var content = text.textContent var parent = text.parentNode text = texts.iterateNext() parent.innerHTML = content.replace(re, '&lt;a href="' + target + '\$2"&gt;\$1\$2&lt;/a&gt;') } } Example usage: &lt;p id="twitter"&gt; My Twitter handle is @canokiid! &lt;p&gt; &lt;p id="reddit"&gt; My Reddit handle is /u/canoj! &lt;/p&gt; &lt;script&gt; createLinks(twitter, '@', 'https://twitter.com/') createLinks(reddit, '\/u\/', 'https://www.reddit.com/user/') &lt;/script&gt;
Except some of us don't put a space after `if`.
That's an extra step and we're all too lazy to do that. 
[Google does](https://google.github.io/styleguide/javascriptguide.xml?showone=Code_formatting#Code_formatting) [Airbnb does](https://github.com/airbnb/javascript#7.4) [idiomatic does](https://github.com/rwaldron/idiomatic.js#spacing) [Crockford does](http://javascript.crockford.com/code.html#if%20statement) [jQuery does](https://contribute.jquery.org/style-guide/js/#spacing) Don't get me wrong, I think excluding spaces between function identifiers and parentheses should be mandatory, I just see where they are coming from.
I'm not so sure automatic variable scoping is a feature you'd want to preserve. It would be surprising to use a variable, and thereby accidentally make a nested function 100 lines later close over it.
What?? The primary benefit of arrow functions is that they capture "this" in a closure when they are passed out of scope instead of basing "this" on invocation. 
It's telling how the author had time to write that long an article, but no time to file a bug against V8 on their bug tracker.
Yes. At least you will not get confused with global this.
What is the difference between ractivejs and Vue.js? Just looking at their websites them both look extremely similar. 
yes, it's not 1980.
Does anyone have an example of an actual implementation of GraphQL all the way from the schema down to the database queries (ideally SQL)? I've seen a lot of posts about the request format and the schema and why everything about it is amazing, but I have no idea how it translates the request into actually retrieving data on the back end.
Thanks
CS always compiled to js. It was hard to see the intent of the code.
check out [jspm](http://jspm.io/), you can install packages from bower or npm. it makes separating client / server code a breeze. you can use the same package.json file and jspm will manage its deps and devDeps inside
&gt; In fact they can't be closures because they are executed in the same scope in which they were defined ehh. My understanding is that, behind the scenes, *all* functions have an associated list of free variables that they have access to, whether or not they are executed within their own lexical scope. So in a sense all functions are/have closures. I think the easiest way to understand closures is just to understand lexical scope and that functions never lose access to their lexical scope no matter how you pass them around. That's all it is really.
A query language that outputs data in the structure you ask form. It's like the 80s again.
I use it at work and home and I am very happy with it.
Love the enthusiasm, really looking forward to part 2. Thanks OP!
I'm not really seeing the point. Why would you use the feature? To what end?
If it's of any value, DeSandro pretty much says to move to `npm` https://twitter.com/desandro/status/667417324123774976 https://twitter.com/desandro/status/667417871799164928
[**@desandro**](https://twitter.com/desandro/) &gt; [2015-11-19 19:01 UTC](https://twitter.com/desandro/status/667417324123774976) &gt; @tomdale I hear you. But a noble death still requires people to manage a funeral ---- [**@desandro**](https://twitter.com/desandro/) &gt; [2015-11-19 19:03 UTC](https://twitter.com/desandro/status/667417871799164928) &gt; @tomdale We're realistic — moving to npm is right thing to do. I want to get to a state where that's an easy transition ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
&gt; I am checking the console. Its not showing any errors but it still isnt working. &gt; You're now using two `==` for an assignment. This should only be one. ``` if (foo == bar) ``` ``` if (foo === bar) ``` ``` var foo = bar; ```
&gt; intern's week work Let's have an intern move our *entire* code base from coffee script to es6?
I dunno...I'd argue that if its sole purpose is to do X (i.e. generate random numbers), but you cannot rely on it to do X, then it's broken.
VS Code opens a bundled js instantly. Atom lags and sometimes hangs on it. I ditched Atom afterwords. That is last week.
https://github.com/basecamp/trix https://github.com/neilj/Squire Both very decent/modern editors that far surpass things like TinyMCE
Consider the article a thoroughly researched bug report. I don't understand the problem. The most likely outcome of a short "Math.random() is broken for me, plz fix" bug report is a closed-wontfix. Hence the research into the problem, analysis, and suggested alternatives. Sorry I didn't submit it through their system, I guess?
Good to see the excitement. I hope it turns out to be as good as you claimed it to be! I will give it a try to.
It's not "the" standard, it's just somebody's opinionated standard. The space after function name thing or no-semicolons are not the popular choices anyway in the community atm.
There are tools: jspm, rollup (need build pipleline) and library: system.js (which jspm used)
I was vehemently against the space, but after using standard for half a year now, I love it. Can't go back.
Maybe find a pre scaffolded project on yeoman?
IMO, stylistically closures with multiple exported "methods" is much easier to grok and read, since all you need are functions and closures. One benefit is that you never ever need "this". BTW this style is also recommended by Crockford, so take that with a grain of whatever. My rule is that if I need 1,000,000 instances (or some arbitrary high count) like particles or vertices, then a prototype is a way to go since a lot of memory is just wasted. However in nearly all of my use cases, especially with functional JS code, my "closure classes" only number in the single digits of instantiations, and *computers are fast* so I stopped worrying. Anyhow, here is a [jsperf](https://jsperf.com/prototype-vs-closures/109) comparing classical vs closure objects. Surprising to me the first time I saw it, closures are faster than prototypes in reads and writes, by a factor of two or more. However initialization is slower by a factor of five according to the test I just ran.
Yes, [JSPM](https://github.com/jspm/jspm-cli) with system.js fits your requirements very easily. You don't have to set up any pipeline at all, only change needed is that instead of a script tag you have to use System.import to load your project into the browser.
That's an incredibly interesting jsperf for sure. It feels like it's ultimately irrelevant then, but not having to use `this` would be just bloody cricket.
But he was showing it off in a plain JavaScript file, so it looks like you can take advantage of the IntelliSense features without committing to TypeScript, and thus also without using the TypeScript compiler. So I'm enthusiastic about being able to use those features in a plain JavaScript project, but less so if it means I have to commit to TypeScript after all (even if those comments are the only place where it leaks through)...
I moved from CoffeeScript to ES6 for my last project, and I'm really glad we decided to drop semicolons in the new standard. Really, what's the reason you want to write semicolons? They don't do anything.
Boy do I miss comprehensions. It's much more performant to use comprehensions than to use array forEach, map, etc.
Also JSPM makes is almost insultingly easy to leverage NPM and ES6: jspm init [ ... answer a few simple questions ... ] &lt;script src="jspm_packages/system.js"&gt;&lt;/script&gt; &lt;script src="config.js"&gt;&lt;/script&gt; &lt;script&gt; System.import('js/main') &lt;/script&gt; Done! Just bundle for production as appropriate. Really the only advantage bower has is that it manages styles, but to be honest I don't really see any reason to have styles managed. I don't want to auto update them, they don't have crazy nested dependencies and if I do want to update it's usually pretty trvial.
It was for a friend because it was the last option as it was due now. I used an array with comments and every time it used a comment it would splice that particular comment out.
To separate where you need what modules. If you have a project with front-end and back-end. You could then have the modules install where you need them (and package them if needed). Looks likea great idea to me.
Yeah, I fear you're right. Thanks for the insight. I'm still hoping they might open this up a bit more to pure-JS developers in the future though. In theory it should be relatively simple, just have a project/settings file that indicates something like "treat all files in this project or directory as if they contain these or these definition references" (kinda similar to how a `.jshintrc` can also specifiy which variables should be treated as globals for an entire directory)...
Lol. Fight me IRL m8
It really isn't that hard to read and mentally translate into the JS equivalent (at the end of the day you can always look at the compiled code), most things can be worked out intuitively leaving you with very little in the way of things that actually have to be "learned". It's not like you need to be familiar enough with it to write it fluently, you're just reading it.
This has nothing to do with the problem GraphQL is solving. GraphQL is a data query language, jsonapi is a data output spec. The biggest difference is that GraphQL allows the client to define the graph of data it wants and the server is then responsible of assembling all of that data and returning it as one reply. Jsonapi on the other hand still does things the old way: pass all data (but in a more or less defined way), even the stuff the client has no use for.
I just tested the TypeScript reference thing on my VSC install. It appeared that VSC would automatically scan the project folder for all `.d.ts` file (TypeScript definitions) and provide suggestions / IntelliSense for your JavaScript files. I didn't have to add any TypeScript reference comment to my JavaScript files for VSC to do that. Also, TypeScript (and VSC IntelliSense) had full support for ES6 features since 1.6. Upcoming ES7 features are being developed. You can find about them in the [TypeScript Roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap). I don't use JSX, but I just tried loading some JSX files to VSC and it worked fine, syntax highlighting and code suggestions. TypeScript also have a TSX version that you could try.
Whilst Webpack will require a build it does work well for traditional, multi page, websites --https://webpack.github.io/docs/multiple-entry-points.html
It's still up to the backend (i.e. developer) to assemble the data, but the client defines what it wants. Instead of having REST endpoints that basically dump a fixed set of data, GraphQL negotiates the data requirements between the server and client. Anyway, the GraphQL site has good documentation, there's plenty of tutorials, articles and conference talks available, I suggest you check them out. All I wanted to do was point out that throwing jsonapi.org in here shows a lack of understanding about GraphQL.
I've been enjoying it. It's free and open source. It probably wouldn't hurt to download it and spend a day using it to see if it's a good fit for the way you work.
You do not need those /// reference lines to pull in d.ts files, they introduced a config file (jsconfig.json?) that you can add references to instead. Still a pain for me since I don't think you can have workspace references, but they may open in up more in the future. They actually introduced plugins a couple days ago, so it's extremely new, but there are already several linters (I believe joshing is one of them) and after a couple months I'll bet the major ones will be available and stable. I'm assuming the plugin library will look very similar to atom's pretty soon, which is good enough for me. As for es6 features, typescript is a superset of es6, so any es6 features should work, along with some es7 (decorators). And typescript isn't going away for a while, so I'm sure they'll keep it up to date as JavaScript progresses.
true, but there is anyway only a certain type of object that can be easily cloned. As soon as closures are involved, it just won't work. As soon as the object contains loops, it won't work. So i think it really depends on the use-case and what needs to be achieved. 
&gt; More generally, how's the plugin ecosystem coming along? Well that bit only launched in the last couple of days... I'm not massively experienced with VSCode yet, but it seems to be able to use practically anything as a build tool. Grunt, Gulp, MSBuild, you name it. From that point of view, it really doesn't matter whether you run JSHint or ESLint.
&gt; It seems the IDE is very tightly integrated, which can be a double-edged sword. For example, I want to use ESLint for linting and I use a build service that enforces the project contains no lint errors. But I got some projects that are still on JSHint. It's not tightly integrated - you can configure your "workspaces" (JSON like config file in project folder) to use whatever tooling you prefer.
Is it something we want in ES6? Probably not. Is it something you have to keep in mind when converting from coffee to ES6? Sure is. Is it something you can get a find+replace to convert for you? Nope. This is one of the things that actually got me to stop using coffeescript. Though I'm happy that one of its descendants, coco, decided automatic variable scoping was stupid, and added a new operator `:=` for modification so that `=` is always a declaring/shadowing assignment. Coco's changes live on in livescript, which I like for other reasons.
Cool, good to know!
Thanks, think I'm gonna give it a try :)
&gt;It definitely has some things that I like, but I also noticed some things that made me cautious. Which you can say about anything but it's not a reason for you to switch. The only reason you're considering this is because it blew up on reddit and it's something now free from Microsoft. Otherwise, you would never have given it any thought. If it was important to you, you would have sought it out. Did you? No. So it's probably not worth your consideration now. &gt;The things I liked from the video that might pull me over: IntelliSense (obviously) Obviously? No. IntelliSense was created to manage the tens of thousands of things Windows programmers need to program Windows. You don't need it for anything else unless you consider typing physically and mentally exhausting. &gt;Personally I really dislike it when I have to change my sources for the editor Now you're getting it. Microsoft's trap open to the unwary. &gt;It seems the IDE is very tightly integrated Snap snap! &gt;Does anyone know how far they are in supporting ES6 features? Do the linter and IntelliSense correctly handle all ES6 features? An observant redditor. How unusual!
This re. search and replace conversion. Your conversion tool must be scope aware to put the var declarations in the right place. You'd need a tool that feeds on the CoffeeScript AST to do a proper translation. Edit: If I had to do such a translation, I'd massage the CoffeeScript AST to replace comprehensions with clean, native js-looking code, and tweak the code emitter to produce ES6 (fat arrows...).
I had the same concern about adding TS comments and made this post: http://visualstudio.uservoice.com/forums/293070-visual-studio-code/suggestions/7756962-externalize-node-code-completion-includes?tracking_code=caeac823284fd3f8a60f52ad12756c55 I haven't gone back to see, but based on the response this isn't an issue any longer?
For fun.
Is Visual Studio Code really an IDE and not just an extensible text editor? Either way, if you're looking for an IDE for front-end development, I can't recommend WebStorm enough. It's simply excellent. 
Did they fix the intellisense? Sublime's intellisense is... both dumb and aggressive... but it does work fairly well for within the same file (and some addons help). I tried VSC about a month ago and had to switch back to Sublime because it was so much worse. It couldn't even find the functions I had defined in the same file. 
I use Code at home and work out of personal preference. At home I write ES6 and Code works wonderfully. Git integration is good but I hope they integrate it more in the future. It has two bugs that I do find annoying: * JSX is not supported inline in normal JavaScript code. I believe it is supported in .jsx files, but I don't use .jsx files. * Selecting text does not always highlight all locations of that text in the file on the scroll bar. It does sometimes and I haven't figured out what the context is. I wish it would always highlight.
[Plotly.js](https://plot.ly/javascript/)
With regards to the video at 4:25, he does add a specific reference to a definition file in his JS but it is not necessary. I believe you can create a [jsconfig.json](http://blogs.msdn.com/b/vscode/archive/2015/07/06/vs-code-es6.aspx) (similar to a tsconfig.json). You put the jsconfig.json in the root folder and VSC will read/interpret it. For your second concern, VSC only started supporting plugins with this release. I would expect it to take some time, but it will be getting all the tools you need. Random Question #1: The link I sent you about the jsconfig.json also includes information about ES6. JSX Question: I do not use jsx so I'm no expert in the support. I do know that VSC at least supports JSX colorization. My progression of JS coding (in chronological order) has been Visual Studio (I was a C#-to-JS convert) &gt; Webstorm &gt; Sublime &gt; VSC. I love(d) Sublime, it eliminated a lot of the bloat that comes with VS and Webstorm. I feel that VSC accomplishes the same task. VSC is just as lightweight as (if not more than) Sublime. Now I am a little biased since I use a TypeScript workflow, and the VSC TypeScript support is on point as expected. Honestly the developers of VSC seem really enthusiastic about building the best lightweight IDE possible. I downloaded VSC the day it was available for the public. Initially there were some flaws, but I haven't really looked back since. 
The worst part is googling something about it, because every article about visual studio also has the word "code" in it somewhere. They should've called it something more unique. Visual Studio CodeFart or whatever. Other than that, solid editor.
Exactly, they are working against over a decade of Visual Studio questions! I would suggest just searching on SO directly using the [`vscode`](https://stackoverflow.com/questions/tagged/vscode) tag.
Like i said, for things like native apps that use NodeJS itself, you would have a developing environment which uses a couple of modules and a package.json, plus a project inside it with its own package.json and modules. So you have to set it up twice. Plus separating front-end dependencies with backend-dependencies is much clearer and more organised. A module might be shared but might break in one place but not the other. And like i also said, packaging the app requires to write custom rules on what files to or not to include which is quite a hassle if you have some dependencies that split many things up. Node Webpack is something i'm not using, i use gulp right now (and used grunt). I've set it up how i want, i'm not looking to move to something different. I and my projects don't require it like that. Plus you seem to be forgetting that it will require the one that is used by the current project. If you run front-end, it would seem to me that it would find the one listed in front-end and thus the node modules directory inside it. It doesn't change anything. Like many things Node, it would be nice to have the option for the people who want to use it. You don't seem to need it, so you would skip it.
since when a free course surprises you? There are lots of free courses out there, some of them really outstanding.
This is from the same company who have named their APIs "COM" and ".NET" over the years. I'm sure they've done it just to fuck with people searching their problems on the internet.
I've done limited gulp stuff, but I remember it working fine. Code's gulp support is very good, ill give them that.
Glad I read this! I bailed on VS Code since it wasn't picking up my JSX (which were in .js files). Saw mention of JSX support, but couldn't get it working - and no mention of the file extension bit. I really enjoyed it for Angular, so I'll pop on back for React and rename my files!
A `&lt;table&gt;` element? - https://developer.mozilla.org/en/docs/Web/HTML/Element/table Or something like this - http://handsontable.com/
This work? http://codepen.io/anon/pen/BoELaV It's not really switching the positions, but it looks like it is...
OSX, Linux, or Windows? Atom runs best on OSX and worst on Windows. It's not even usable on Windows, imo, but is good enough (though slower than VS Code) on OSX, with a lot more support, like others have said. I like some things about VS Code, but I don't care about TypeScript and don't like the extra configuration files you have to use. The debugging and intellisense features are nice though.
yeah that'll work perfectly! thanks! 
He's right in that built-in RNGs are never intended to be CSPRNGs. At best, they are a less-crappy non-CS PRNG, and that's what developers should expect and be aware of.
Pretty cool. As an extra, it would be cool to have some custom syntax so that you could define the the type of username inline. e.g. {DaveRobson}(github) and the lib replaces it with the link and in this case adds the @. This would remove the need for configuration in the script tag. 
Thanks!! that's kind of it. I just need to make it update data dynamically and control permissions on various parts. That should be possible right?
Or as of yesterday, `document.queryAll('body').forEach(body =&gt; body.classList.add('test'))`
What about static JS? Is there an alternative to Math.random() for non-Node apps?
I stand corrected. It seems a closure is created anytime a function references variables defined outside the function itself. Good to know. So then technically the very first example in that article introduces a closure.
I love it. Switched over from Sublime. I've tried out Atom as well but it was sluggish and requires too many plugins for basic functionality. Advantages: * Better autocomplete/intellisense * Tooltips (hover function call to see definition) * Nice git integration * Debugger * Open source That said, it isn't as flexible as the other two but for my uses it is perfect.
It looks better to me. It's an explicit way of ending statements vs the implicit way of line endings. If I don't see the semicolon, I know the statement isn't over, and continues on the next line. I can't use that in ASI.
This is just nonsense for most of the devs working in JS: "With jQuery out of the equation these days..."
Google "C#" instead of .NET. I know that they are not the same, but in 99% of the cases the keyword fits. 
Vanilla JS is the thing you use before you realise you have two dozen other devs working with you, a plethora of stakeholders demanding impossible things, and no time to actually get shit done. Then you switch to libraries and frameworks and start taking scalding showers to wash off the impurity of using non-vanilla javascript.
I also don't prefer that particular spacing rule, but it was the only difference Standard and between the style I had already been using. I can live with it, it's really nice to have a tool that will just handle the formatting. Semicolons can suck it.
I wish i was this smart
How resource heavy is it? I love the lightweight was of sublime so no matter what IDE I use, I always have sublime too for quick edits. 
The plugin system was just released a few days ago so maybe we'll see more support for HTML shortcuts. It does have a built-in shortcut system that seems similar to Emmet. I personally prefer Emmet style shortcuts to what Visual Studio (proper) comes with so I haven't had a problem with the HTML editor. 
&gt; CoffeeScript Yeah, good luck with that
How is this different from the use of any query language to obtain data from the backend? It seems we're going backwards here: whereas a REST API typically abstracts out your query logic, GraphQL is structured around you using query logic straight from the client side.
I find it to be a very solid alternative to Sublime Text. I use it primarily for Python code and I switch between Sublime and Code right now because Code is still missing some functionality I like. That should change in the near future now that plugins have been added. I am looking forward to using next time I do something with Ember and Node. Also, this should answer your questions about linting: http://i.imgur.com/XNL3Oty.png. There is also already plugins for ESLint and JSHint like there was in Sublime if you do not want to use the Code ones. I am not sure how to configure them as of yet though. EDIT: Also, Code is very lightweight. I do not have numbers, but I do not ever notice a performance impact on my system, even on my crappy work computer. 
Ah ok thanks for correction. They just look very similar for me.
You're not wrong, but there is value provided in creating a "plug-and-play" API from thinly wrapping other code.
I've simulated clicking other elements with .click() This is what I'm talking about: http://www.w3schools.com/jsref/met_html_click.asp 
Anyone know how to show indentation guidelines similar to how sublime does? http://wesbos.com/wp-content/uploads/2013/07/ss-2013-07-24-at-4.02.52-PM.png
I'm on OSX and Atom takes anywhere from 8 - 15 seconds to boot up this massive Angular project I'm working on. Sublime and VSCode are much faster.
Classic Microsoft naming... trying to build on their "brands". Morons. I'm surprised it's not "Microsoft Visual Studio Code 10 Open Source Edition Windows Azure XBox One 2015". I'm noticing it's being referred to as 'vscode' - try searching for that.
I've been developing js apps for as long as there have been js apps, and I have never had to work on production jQuery code. I was using Dojo back in the day when jQuery arrived on the scene, but it seemed so limited in comparison, and then I somehow managed to skip directly to modern frameworks without ever having to touch jQuery. I somehow also managed to avoid PHP and Ruby, went straight from Perl to Python with a brief stop at AS3 and on to modern Node, Java, and Clojure. I don't know if it was forethought on my part or just dumb luck, but it's certainly worked well career wise to skip certain technologies by evaluating them on their engineering rigor rather than popularity.
From a UI pov, it's a table that has scrolling. Now if that scrolling works horizontally(time) as well as vertically (channels) , is up to the dev. I would most likely, emulate TV Guide's listing page and make the time slot require a page reload. Here's a jsfiddle showing a scrollable table : http://jsfiddle.net/hashem/crspu/555/ Now if you want it to autoscroll ... will have to write some custom code if you use a scrolling plugin or not.
&gt; Of course it can be made without that. And that's why you don't say how. Anyhow, even if you had a lengthy workaround (which you don't), it would still support my argument that content-box is the wrong default. &gt; You're being fooled into thinking you can't just like most redditors think they need frameworks and jquery to make web pages. There is no need to fluff up your comments with filler garbage like that. Nice try, but it won't fool anyone.
Just curious, what don't you like about editing HTML in it?
Where does Falcor fit in?
Yay. More config files. I'm going to end up with more IDE config that code soon. *I say this tongue in cheek but I have noticed a lot of config in recent projects.*
i tried it out with a highly structured single page webapp and found the intellisense to be severely limited. webstorm is much better, and netbeans is somewhat better (netbeans 7.2 is almost as good as webstorm, but is quite old at this point) i believe i filed a bug report related to this, but can't find it now (MS moved the bug tracking to github) 
&gt; That fits the criteria Does it? http://jsfiddle.net/nt8eg732/
Oh yeah, I forgot I also somehow managed to avoid MySql too. I used Postgres and Sqlite from the beginning. Damn, lucky I missed that iceberg. Used the Perl DB adapter from CPAN that correctly used prepared statements while PHP had a crappy MySql API bolted directly into it's core and used string escaping instead of prepared statements with placeholders. Perl also had a nice taint mode thing that provided automatic sandboxing around any user input, while I remember having to deal with input safety manually in PHP, which was a pain in the ass and error prone.
Interesting. I've heard of brackets through reddit, but have since forgotten to try it out. I'll have to give it a go. Thanks for the suggestion.
The top answer on [this StackOverflow post](http://stackoverflow.com/questions/32057785/what-is-the-difference-between-falcor-and-graphql) explains it very well.
&gt; I did check and there were already a bunch of existing closed-wontfix issues on the V8 tracker about Math.random() being problematic. [No there's not](https://code.google.com/p/v8/issues/list?can=1&amp;q=Math.random)? There are a few about seeding, but that was from embedders not knowing how to seed. Again, it's weird to use an open source project in your day-to-day business and post about what that open source project "should" be doing, but refuse to engage with the open source project itself. &gt; Without the post this would not have been fixed. Again, the post was good. Research so you can write an informed critique and suggest alternatives is good. Just *also* file a bug next time. It's really not a big deal.
I tried it and I liked it. Especially the git integration and intellisense. But I'm so used to and efficient using the keyboard shortcuts in SublimeText that I went back.
See my reply here (https://www.reddit.com/r/javascript/comments/3tfpxa/githubs_atom_moving_from_coffeescript_to_es6/cx7h68a).
Ok, that's cool. I still would like to promote WebStorm though because it's just that good. 
Ehh, you are right, sorry. I'm not sure you can trigger a file upload that way though. Here's a [StackOverflow post on that same issue](http://stackoverflow.com/questions/210643/in-javascript-can-i-make-a-click-event-fire-programmatically-for-a-file-input), maybe it will help.
Whenever you refer to a name in JavaScript, first the local variables are checked to see if there's one by that name, then the variables in the next outer enclosing scope, and then the next outer enclosing scope, et cetera, and if still none is found, then finally the global scope is checked. `window` is the global object (at least in a browser setting, not necessarily under Node.js), and properties on `window` are the global variables. So in this case there's no difference — assuming you haven't defined a local variable named `alert` (nor a closure variable.) And this is not in any way specific to `alert`. `window.document` is the same as `document`, for example. You could write `window.document.getElementById(...)` if you really wanted to, but nobody does because that's just extra typing. 
No, just no. He's 100% correct. A language's built in PRNG should never be used for anything that requires strong randomness. This is like [Crypto 101](https://cryptocoding.net/index.php/Coding_rules#Use_strong_randomness). Always assume the language's built-in PRNG is broken, and work from there. Always. [E] I should clarify and say that the writeup is indeed quite interesting and detailed. I rather enjoyed the read. My point is more that it's not really anything new, and is rather the latest in a long string of similar discoveries about nearly every other default PRNG. Hence the general rule of thumb about avoiding use of any language's built in PRNG.
Does it not have support for React syntax?
Hmm, the example code suggests that the order of the iterable lists returned reliably matches the order that the object properties were defined in. Maybe that was unintentional. But now I'm wondering what the order of the arrays returned by the `entries` and `values` functions will be, or if it's still unpredictable like `for` `in`.
This guy gets it 
Premature optimization.
What?! ok. I'm downloading it now to try it. 
At least COM predates the explosion of the web... but yes. That said, I find search engines smart enough that they can tell the difference between pages about Visual Studio and pages about Code.
Your editor doesn't matter for live reloading. Just use browser-sync or livereload. (Bs is the best)
Yes, easily depending on where you are pulling data from. On mobile so I can't link, but you're looking for ajax.
While that may be true, Brackets is based on Node.js and has that functionality built in. It's a text editor primarily intended for front end development and just includes some conveniences (like live previewing your work in Chrome) I'm sure there are a lot of tools that work with node.js to make development easier, I just had some good experience with brackets because I liked it over notepad++ for that specific task. Browser-sync does look neat though, and I probably would use it if I was a front end developer that needed to test things in multiple browsers.
var match = myString.match(regex); match.length; Sorry for formatting, on mobile.
I downloaded it and watched a 20 minute intro on youtube (by microsoft). I tend to hate IDE's because of too much magic. But VSC seems to have just the right amount of fairy dust. I think I'll like it. 
It's not very good, and has some strange requirements. I suspect now that they have released plugins, that will change very soon.
They both use Atom's open source shell, Electron, but the text editors are completely different code. It's not a clone.
It's free. JuSt download and try it. I switch to it myself.
I have noticed this too, I have a trivial 'Trial user name' generator that matches a makes a random user name from a list of adjectives like 'hypothetical' for example and a list of nouns like 'sideburns' , so that a suggested user name could be **hypotheticalSideburns**, or any random combo of adjectives[N] and nouns[N]. But I noticed that it consistently landed around the same range of words. But this isn't a problem because of two reasons, 1 I have a chron job that deletes all of these trail accounts after 24 hours, and if the same trail name already exists I just append a number. For example i once had 4 records of the trail user name **upscaleBathroom** be created during a period, so I just append a number like 2 and if that is taken then i'll add another random number. This could be an actual issue if I had more than 3 DAU
Yeah, I think this is really cool but it has to be used carefully. You can't sacrifice usability for flashiness. Or Flashiness.
&gt; Custom build for the current project's needs. Bye bye large file size overheads. having a loading screen doesn't really enforce that idea much @_@
I've been using [Greensock](http://greensock.com/examples-showcases) for these kinds of animations and think it is a very mature and performant platform. How is this library different?
Medium is like Tumblr, anyone can write an article there, which means the content can vary. 
Participate in the competition by creating a [3D WebGL engine for Freeciv](http://play.freeciv.org/blog/2015/11/freeciv-web-webgl-3d-engine-competition/), or post your suggestions here about how to make this possible! Thanks redditors.
For one, licensing, and the warm fuzzy feeling of open source projects.
Try to make a grid game. Grid games are for example match 3, tetris, or that Lights out thingy. Worth mentioning is also Convway's Game of Life. Just create an html table, give each cell onclick attribute perhaps, and try to come up with some cool new concept.
[removed]
This guy is trolling you. He is literally just disagreeing with everything you say: it's not even the funny sort of trolling
And additionally: Greensock is well-known for its performance, and ability to handle overlapping tweens, something that many, many other motion libraries fail to handle gracefully. How does mo.js compare?
How is this different from [Pusher](https://pusher.com/)?
This is really cool, I wanted to see more but only the 'path easing' docs link seems to work.
No, but all engines do it anyway. Programs became dependent on that behaviour, so it's now in the spec.
I for one wish this comparison between things and Angular 2 would stop. Angular 2 is in alpha. It is not ready for production use. Yes, Angular 2 is exciting, but there's no point in pretending it's stable and comparing it to stable libraries when it probably won't be production ready for 6-9 months (according to latest rumors, keep in mind there's not even a projected release date yet).
This is cool. How to easily change the text in this demo to something else? http://codepen.io/anon/pen/MaRQxO
It is messing up my treetab in Firefox.
FREEcodecamp.com ;)
I can't imagine a situation where finding a string representation of a sequence than just using RegEx is not an option. Could you demonstrate the advantage of your "library" over simply using RegEx? The example you give with the list of numbers and a pattern of [first number must be less than 10, 0 or more even numbers, last number must be greater than 10] can be testing in a single line of JavaScript with zero "library" dependencies. /^(\d),(\d?[012468],)*(1[1-9]|[2-9]\d|\d{3}\d*)$/.test([1, 4, 8, 44, 55].join(',')) 
React Redux and Webpack with a babel transpiler.
Thanks for the reply. Maybe I'll just stick to what I know - Angular 1.x. When Ill have the basics coded and publish what I've done maybe I'll start thinking about upgrading it to React + Redux.
If you're really savvy, check out falcorjs' redux adapter, and then you can seamlessly use http OR web sockets with your models, treat your local data as remote data, with eventual consistency. Next-gen data fetching with redux-encapsulated-state goodness
[removed]
Not only that, angular 2 has been in development for over a year now: https://github.com/angular/angular/graphs/contributors It should be a big red flag anyone considering this framework if it's going to still be in development for another 12 months. 
There are all kinds of people on the internet and many of them aren't the most reasonable human beings. There are many who have a really hard time admitting being wrong. Being "right" about everything gives them some sort of comfort. I do suspect that this one is some kind of alt/sock-puppet hybrid account, but I don't think that they are necessarily trolling. They might be the kind of person who bluff and try to derail the conversation in order to be able to internally retcon it into some kind of victory at the end. I also do think they they honestly believed that content-box is just as good as border-box and that having to do some math is the only downside. Anyhow, to make this comment a bit more useful, here's a handy list of CSS' mistakes: https://wiki.csswg.org/ideas/mistakes Box-sizing is of course included.
The other option being GraphQL (subscriptions are now a thing: http://graphql.org/blog/subscriptions-in-graphql-and-relay/). Either way the future is looking awesome :)
Angular 2.0 might be the most "up to date", but that's fairly meaningless way to measure frameworks, imo. If you're already familiar with angular, try [vue](http://vuejs.org/guide/index.html), which took quite a lot of inspiration from angular and uses a lot of the same terminology while being much more simple. If you're looking for something a bit different, I would say react is a good choice.
σ(τ('.size')) ?????
just a shorthand for `simulacra($('.size')[0])`, or anything `simulacra(&lt;Node&gt;)`. update: thanks to your feedback i replaced `σ` with `bind` and `τ` with `$`. 
If you want to show people your work I suggest using Codepen.io People are much more likely to look at the code if they already know what it does.
Is webpack worth ditching gulp? Can they be used in conjunction? 
ha ha ha the bottleneck is on the http data requests of course ! rendering per se is always ridiculously slow !
I started using webpack and it's pretty simple to set up. I still kinda miss gulp though lol. Yeah, you can `require('webpack')` and use it in a Gulpfile. 
Webpack in many ways replaces grunt/gulp/etc, but you can still use them in conjunction. Most of the tasks for "building" will end up being replaced by webpack, though. I have npm scripts for the various webpack configurations, such as building a production versus a dev version, or watch mode. I could also see you having gulp tasks for running unit tests, especially if you then did things like code coverage from those tests.
you misunderstand, it has nothing to do with class names, you can even use data attributes if you really wish to do so, but then your node lookup would look like this: `$('[data-id="foobar"]')`. the only restriction is that you have to pass a dom node into the function, so it doesn't matter if you do `node.childNodes[0].nextSibling` or however you want to select a dom node, basically it has no preference.
While I haven't used webpack, I don't think you can get the same versatility out of it as you can with gulp. Also when I first heard of gulp, there was literally no docs available, which turned me off instantly.
heh, we're using that where I work. We're also using Jest and redux-form. We mostly use gulp with webpack and a couple of projects use browserify with babelify. The tech is really cool, but the tools and help are a bit bare.
The most "up to date" tech stack is the one some guy just wrote 20 minutes ago that doesn't work. The answers you'll get in here will be people promoting their tech stack of choice. "Up to date" is not a valid approach to choosing tools. You'll get hipster bullshit that's abandoned in three weeks.
OK I wouldn't submit either as they were - I would rather receive 50 lines of well written code than 500 I couldn't read nor understand. I would extract a small part of one of these scripts and do the following: * Make the code style and formatting consistent - use http://jscs.info/ * Use JSHint until there are ZERO errors or warning * Aim for no more than 10 lines per function, 50 total for your example * Avoid badly named variables (`var arriz ???`) * Cache your selectors * No console.logs Don't worry about what the code *does* so much - these are the things I look for when hiring: * How easy is the code read/understand? * How easily could the code be changed? (is it well abstracted?) * Knowledge of JavaScript / Framework idioms (read the docs) * Finally...does the code do what it's supposed to do? (bonus points for writing unit tests) If you make it to interview get out of the habit of making excuses if you can - it's OK to still be learning something. Excuses may cast a doubt on your honesty. Instead of "I'm not good because of x" try: "I'm hoping to improve x". Good luck!
ok, will do. Can you provide some examples or maybe a github profile of someone who has good looking code?
I reiteterate :P &gt; If you make it to interview get out of the habit of making excuses if you can The variable name was the result of you being sloppy - doesn't matter how you were feeling at the time.
Aurelia with ES6/ES7 or TS via Babel. http://aurelia.io/
Your message board example now redirects to reddit - tee hee
You can but it's not recommended. I switched to webpack and it handles 100% of all the stuff I used to do with gulp and it takes so much less time to setup.
I meant that you'd need some server-sided counterpart. Some server-sided logic which stores the scores and replies with a list of them if asked for it. Well, you could use something like Firebase, I guess. https://www.firebase.com/ Anyhow, the main problem with global highscores is that they are easy to manipulate. If you just post some name + points pair to some ULR, everyone else can just post whatever they want. If you want to do the server-sided stuff yourself, look for a [Sinatra-style library](https://en.wikipedia.org/wiki/Sinatra_%28software%29). They are the easiest option for writing small services.
Maybe I don't quite understand what is required here, or maybe I explained poorly. I was basically just going to have the game (very simple HTML 5 game, really nothing fancy or complicated and tbh doesn't matter if it gets hacked or manipulated or whatever) read the lines of a text file and get the high scores to display on a high scores screen. Then, at the end of each game, new high scores are written into the arrays and the arrays are written into the text file. If that text file is in the root folder of the game (along with all of the images used and such) and that root folder is hosted, should it not remain static and therefore be global? EDIT: I'm totally not against using something like Firebase! It would probably be really cool and good for me to learn, but I'm just curious if there is a simpler way. EDIT 2: I should also mention that the game is using PIXI.js, so everything is handled on one .html page.
You said werds. Wtf is redux
Server side rendering time on my projects are ~5ms on average.
srsly. My first interview question is "Can you tell me what the jQuery function returns" 99% of people cannot answer that. I will 100% of the time take someone who is a solid programmer and teach them javascript over someone who can rattle off the names of the flavor of the month libs. Does anyone else remember scriptaculous, moo tools, prototype?
I personally use http://www.jsbeautifier.com but whatever does the job is all that matters
When you host your game on some server, and point the browser to it, an http request is made for the file you first request. If no file is given, such as when requesting example.com, most web servers will redirect or serve an index.html file. This file is even downloaded and parsed in the browser. Other resource defined in the html file, such as JavaScript file or CSS files are then made in separate requests and also downloaded from the server. With a "stock" http server (that serves static content). Any file can be requested, and in JavaScript this requests are made via XHR or more commonly referred to as Ajax. With Ajax you could request your high score file, but you will not be able to modify it. To modify it you will need a custom server side component that will accept your requests and make the appropriate modification to your score file.
Adrenaline seems to add GraphQL support to Redux. Full disclosure I haven't used it yet so I have no idea how useable it is currently: https://github.com/gyzerok/adrenaline 
It is free as the name suggests.
Lol roasted
ok then
It's compiled code that is meant to be optimized for size, not legibility. I don't really see what's "hacky" about it.
Java : JavaScript :: Car : Carpet
Agreed; you're better off familiarizing yourself with tools that have gained widespread acceptance and that are actually used by a decent number of companies in production. Beyond that, just try to learn about the concepts behind using JS frameworks. They all do essentially the same thing, but in their own special ways.
&gt; Can you tell me what the jQuery function returns Is the answer "you, to the 1990s?"
I do, but I'm rapidly finding it harder and harder to get work as a JS dev because I don't know React Super Hyper Drive + Hypothetical Transcompiler + Never Pass Continuous Integration Functional Unit Testing. I'm leaving JS based work as a result, and fear other solid JS devs are doing so as well.
Now I'm curious: do you look for more specificity than "the jQuery object"?
you have to essentially stop, rewind, and re-play the audio every time you shoot: shot.pause(); shot.currentTime = 0; shot.play(); 
Security research and lower level programming languages, primarily C++ at the moment 
You're right of course, but it's not helpful to the OP to hear some whinging about the churn rate of frameworks, particularly when their question is: &gt;Whats hot right now? React combined with some framework? Redux? Backbone? Maybe even try Angular 2.0 ? So, people promoting their tech stack of choice looks like what OP wants, to know what they should even bother to look into. 
I have to laugh when I read my own words, same as yours, that I said a year or so ago and got downvoted into oblivion.
That's one reason why I like knockout. It's just data binding. Super easy to build whatever you want around it - in our case, a custom framework that does exactly what we want. So, slower time to ramp up to a project that marketing can poke at? Sure. But now that we're knee-deep in the build, we're not digging through pages of documentation trying to find out how to do one esoteric thing "the angular way". We just built it how we want it to work and rely on knockout for the one thing it does well.
I knew nothing about headless browsers before this. Thank you!
When I interviewed I was asked algorithms questions and told the guy I hadn't done any web dev got hired and then learned enough JavaScript/angular in a few weeks. It worked out fine after about a month I made my first inhouse app in angular. I took a lot of interviews of people asking me what specific things were in specific languages to have that happen though. 
Just make some bs app in whatever is popular. might be worth it. 
Uh, maybe because you don't need the hottest tools, but you do need to keep up with shit. Going to c++ tells me you probably didn't know a ton about front end and where it's going to begin with 
Any javascript embedded on an HTML page will be run on whichever random computer that looks at the page. And (thankfully), random computers can't freely modify your server's files. To have a global score board, you need a program running on *one* computer, which all clients can tell their scores to, and which can track the high score list among them. Firebase provides a service that can do that, which runs on their servers, with their own API. [One of their example uses is a leaderboard](https://www.firebase.com/tutorial/#session/r6i92e84bjp), and it wouldn't take much to modify it to suit your app. Firebase has a free tier, but this has limits on how many people can user your app at a time. Also -- firbase can't read a high score list on *your* server, but that isn't really the point of your question, right? OTOH, the actual answer to your question is that you need to run &amp; program a server that can modify the high score data in response to user request. You can write a server that'll do this in javascript, if you use [node.js](https://nodejs.org/en/) [and it's a decent choice regardless of the language it uses]. The main tasks you would need your server to do are: 1. Make your new server do what the 'default' server does now -- send files across when asked. [Installing 'Express' gives you this behaviour almost automatically](http://expressjs.com/starter/static-files.html). [Note: this is a 'Sinatra-style library' of the sort x-skeww mentioned.] 2. [Handle a 'POST' request](http://expressjs.com/starter/basic-routing.html) from users, so that they can tell you a score, by first checking if it makes sense, and then [opening the high score file](https://nodejs.org/api/fs.html#fs_file_system), and then putting the new score wherever it belongs on the list. 
How quickly should a framework come out of development, in your opinion?
Its all executed/loaded in the global scope, anyways, so (to the browser) it doesn't matter if the scripts are in multiple files. However, the kicker is that if you split your code into multiple script sources you will force some extra http requests. With the current HTTP 1.1, there are definite advantages to putting it all in as few files as possible. A lot of people do that. No need to accuse the practice as being "less serious". I heard Nik Molnar, tools manager at Microsoft and expert with web performance, advise developers to try bundling up your css/scripts. Here is a quote form him: &gt; One of the most simple things that you can do in web [for performance], specifically, is to bundle and minify your assets. So take your JavaScript and your CSS and you minify it, you strip out all the white space and then bundle it, meaning, if you have two or three CSS files that you might have split up for modularity purposes, for example, jamming those things all together [into one file]. 
The minute I learn one thing, there's a new thing. I can't keep up!
First link, Ctrl+F, "objecturl". **Edit:** http://jsfiddle.net/sjmd0xxe/
HTML + CSS + Javascript + Common sense of when to use what Edit: Okay that sounded harsh, I'm sorry. I was meaning that fundamentals are key with front-end. Personally, I'm actually flabbergasted Jquery is still being used AND IS ACTUALLY REQUIRED (GASP) by some packages.
Maybe I'll stick to django, try backend a bit, get to know python and then get the hell out of web dev? :D
I feel like there is room for an open source tool that removes the pain of config files in typescript projects. One smart command to rule them all. 
&gt; Backbone? Backbone was first, but it didn't really evolve into anything after the release. Certainly react. React rullez. I wouldn't be surprised if JSX got standardized as ecma standard in ES2016-2018.
If it makes you that miserable, go do something else. Is nobody's responsibility than your own, mate. 
When I say xml I meant that the content of the specified file will be wrapped into xml tags, sorry, maybe my description wasn't to clear :)
Yeah, sorry, you're right, the point is that you can use html tags (which is xml basically) ^^
[removed]
Lol @ "real programmers". No *true* scotsman would use a framework am I right?
Saw a talk from the cerebral creator recently, fascinating library
Only a redditor would think that.
Well, nobody said life is easy. My advice would be to make a plan to get where you want to be and follow it through. There might be sacrifices, there might be hard times, but when life is tough, at least you are working towards something better. 
Good work! :) I can see myself using this.
Yeah, it looks lie you'll have to be logged in to do that. What you might need to do is create a script with your credentials, send a login request, and store the token. Then find out the REST request used to retrieve the data you want. Then you just request the data whenever you want to refresh, and if you get a 403 error or something, acquire a new token. I don't know if you could make the fantasy team public, but if you could do that, you could avoid having to store the token.
Angular is a framework, backbone is another
Thanks for your advice, friend. I'll think about what you just said, for sure. By the way I just want to make it clear to the javascript community that this has absolutely nothing to do with the javascript language or other front-end technologies. They're all amazing and I love them. Hell, I've been doing this for five years now. It's just the whole "you-must-learn-a-new-technology-or-concept-per-week" that's driving me insane. I'm on a serious burnout.
Never heard of them but I would never use someone else's code. That's what they pay me for.
Has anyone done a comparison between GraphQL and Falcor? Just reading through the docs, Falcor seems more compelling, bug I haven't actually tried either.
Nice and concise :) +/u/dogetipbot 40 doge /u/changetip 60 bits +/u/tacotip 80 tacos
__^[Verified]:__ ^/u/playeren ^-&gt; ^/u/jhgaylor __^₮80.000000 ^Tacocoin(s)__ ^[[help]](https://www.reddit.com/r/tacotip/wiki/index)
Do you not now the difference between frameworks and libraries? Now, I'm sure you're talking about all the hilarious libraries that reddit proclaims "you absolutely must use or no web site can be created without one!!!", though. &gt;I can't fathom the drop in productivity of having to reinvent the wheel a thousand times. Ah, the typical reddit response. Only an amateur thinks professional programmers have to "reinvent the wheel" every time he writes code and you have to have someone else's library/framework to get work done.
Of course I know the difference, but since you said you write all your code yourself I assumed you didnt use any libraries either. So, where do you draw the line? Do you write your own _.partial implementations as well? It's not black and white man. We use backbone as a foundation where I currently work, and run our own layer on top of that. We would have suffered a very real, very unnecessary productivity drop if we would have done everything from scratch. Could we have built it ourselves? Yes. Was there any point in doing it? No. Really slick with the downvoting as well mr code monkey.
I have not downvoted anyone on reddit in years. Reddit voting is pointless and pure nonsense. We write most everything we do within reason. We don't write our own javacript engine as a v8 replacement but we have no need for things like backbone cause we've been doing backbone-ish work for years so anything backbone does, we have code that did that years ago, and ours is smaller, faster, more flexible, etc. Same with all these things you see on reddit. Been there. Do that. Years ago. Have no need for third-party stuff. I noticed this thread cause I just came from SO where I keep seeing umpteen questions about someone's latest framework or library that broke their site, or they can't get it to work right, or whatever problems they now have, that they didn't have before. Today it seems 'bootstrap' is the problem of the day. I'm thrilled we never have to deal with any of it. (Our little company does custom work in the restaurant and entertainment industries. At least one you visit every couple of weeks, I'm betting.)
All webpack does is commonjs which is still perfectly spec compliant. If you use ES6 modules, then I see what you mean, but Babel is the one doing that, not webpack.
Reading, writing, critical thinking 
In that case I'm happy for you. Obviously you have an established codebase that you can extend upon, and that seems to work well. But surely you must understand that people use various available tools for getting up to speed quickly with new projects? Bootstrap is catastrophically overused, yes. A framework for website prototyping which somehow became a defacto standard. Awful. I would recommend you to have a pet project where you go way over the top with every single flavour-of-the-day framework/library. It's useless for production type stuff, but I've learnt a lot from it since they all promote an idea or a way of thinking. 
&gt; Bootstrap is catastrophically overused, yes. A framework for website prototyping which somehow became a defacto standard. Awful. This is one of many reasons why we would never touch such things. &gt;I would recommend you to have a pet project where you go way over the top with every single flavour-of-the-day framework/library. We rarely see any such thing that does something we don't already do. Of course we look at things that seem to show what we haven't tried, a new idea, but, in almost all cases, we find it's not really new or we'd only implement 10% of it. Then we write our own version of that 10%. Using someone else's code to come up to speed too often is similar to a hack that never goes away.
JSPM is nice and well-integrated but it creates humongous builds. I always go with Browserify as it only adds ~200B of constant overhead + ~10B per module.
http://eloquentjavascript.net/13_dom.html
I don't know why you're getting downvoted, you made a valid claim. Any serious person wouldn't pack all their vendor scripts up into their application code and just jam it all into `bundle.js`. Depending on what you're using that file could be MB in size with just vendor code. It's smart to put vendor code in it's own file, and bundle your application code in another file, so that when you update your application code, your users don't need to download another 5MB file, they can download a few kb file because vendor.js is already bundled and doesn't need to update, so they pull cache on that. Anyone who's downvoted you for stating that, has never used a bundler like Webpack or Browserify in production and if they have and didn't think about this stuff, I'd not like to work on their team.