Updates the expiration date on a cookie? 
double click -&gt; next -&gt; next -&gt; finish
You forget await in fooAsync example. Without it foo and fooAsync are not equivalent.
This code is what I imagine hell would be programmed in, it is incredibly, unequivocally terrible. That said, here's what it does: &gt;Remove all cookies but the last cookie in your cookie list, and replace the domain in that cookie with an empty string, replace the path with / and set the expiration date to roughly 3 years ago. I imagine that whoever made this had very very different intentions, and probably wanted this code to do something entirely different, if I was willing to spend enough time on this it would probably become more clear, but an initial perusing of the code honestly makes me question the author's sanity more than anything.
Whaaaat I‚Äôll enter where‚Äôs my drone?? 
Anyone actually work in IBM? The IBM in my country is looking for Angular devs, is it a total bad idea to apply with a React portfolio?
The same as an yoghurt expiration. Don't use it after that date. Most apis will give you a refresh token that you can exchange for a fresh token. 
It‚Äôs shit so that‚Äôs the strategy - Sell it by bottom line enforcement... But they‚Äôre not amazon. With all the fancy stuff.
Awesome üëç
Browser is refreshed upon AJAX request?
Thanks!
Since no one has, I thought I'd link you to the [Promise/A+ spec](https://promisesaplus.com/#point-41), which es2015 promises implements, keeping in mind that `.catch(f)` is sugar for `.then(null, f)`
Finding it really confusing to figure out what this is for... Is the idea to render what a webpage would look like?
Yeah essentially server-side web rendering...why you would do that, no idea
I use sublim text for a long time. Tried all others but ending sticking with it for the following reasons : performance, lightweight clean interface, lots of quality plug-ins. 
Linus Tech Tips did a video on it - https://www.youtube.com/watch?v=mvlETSoBjxk
I‚Äôm a front end developer and was a musician and audio engineer in a previous life. How can I use my JavaScript skills to make open source VSTis?
Oh you have no idea. I worked in a company which made software for our tax office and all they used was IE8. Of course we went on about 10000 meetings trying to explain how IE8 is bad for security reasons but they wouldn't budge. The same situation can, sadly, be found in almost every government related software.
Oh you have no idea. I worked in a company which made software for our tax office and all they used was IE8. Of course we went on about 10000 meetings trying to explain how IE8 is bad for security reasons but they wouldn't budge. The same situation can, sadly, be found in almost every government related software.
This mechanism is called OAuth, and it is a popular scheme for sharing information in a secure fashion on the internet. For example, you write a ReST API &amp; Website that you want to securely access Facebook data for your users. Your website first authenticates it user's with Facebook via Facebook's login/redirect scheme which allows users to say, "I'm ok with this website accessing this data". Facebook then gives you a signed `access_token` once that user has logged in and accepted the permissions requested by your website. You then pass the `access_token` given by Facebook to your server, often via the HTTP Authorization header. Your server then uses that token to communicate with Facebook and retrieve data for that user. `access_token`s are short lived for a simple reason, to prevent malicious actors from gaining access for a long period of time. This is often why a `refresh_token` is also given, which is basically a way for the logged in user (and your website's implementation) to obtain new `access_token`s from Facebook. 
Would I be right in thinking of it as a fallback? Kind of like a default clause in a switch statement?
Ah, the rejection value gets passed to the catch argument like an error would!
Excellent example, thank you!
Dan is better Sunday reading than the comics. 
Once upon a time, this was a journey. These days, not so much. ```css body { scroll-behavior: smooth; } ``` Scroll to the top of the contact section. If it's not high enough to fill the page, then it's the same as scrolling to the bottom. ```js document.documentElement.scrollTop = document.querySelector('#contact').offsetTop ``` 
The upside in most of these cases is they care only about functionality, not presentation, so you don't have to spend a lot of time beautifying the UI as long as it works.
If you use the css scroll-behavior: smooth, then can't you just use anchor links? So just link to an id on the page, and the browser will smooth scroll to that id. No need for JS here.
Yes but the problem is they want us to use a ton of really old technologies that are horrible and don't function properly. I quit the job because it took me more time to fix problems in those technologies than it would take me to write both the functionality and the pretty UI without them.
oh I feel you on that. Seriously using CSS feels so weird even though it's just essentially an object. Thankfully there are so many design libraries out there. 
Oh gosh, that hurt my brain. I hope people don't believe this sort of crap.
Thanks Dan! Can I subscribe somewhere to get emails when new blogs are posted? Thanks for putting in effort to teach people. 
I scrapped the way i was trying not to modify the index code and decided i have to. No other way as far as i can tell. Did checked other similar apps and they did exactly the same. Thank you for help guys.
You should invest in learning a design framework. I'm currently looking into Vuetify for Vue, since I kinda have your same problem. I don't hate CSS, there's just times where I feel I'm spending too much time on it.
I used to feel that way, but now I feel slightly different. JavaScript was the first language that I really got into (aside from 3 weeks with Python to learn the basics), so I'll probably always have a soft spot in my heart for it, but I couldn't stand fiddling with CSS to try and get things just right. Thankfully, with grid and flexbox it's much less of a hassle, and you can focus more on actual work. Also, like with anything, the more time you spend on it, the easier it becomes. So, CSS isn't a terribly big deal anymore, and I actually kinda like it. Now my biggest, least enjoyable roadblock is design. I know that's something I probably won't have to deal with terribly much when I get a job as a front-end developer, but I'd still like to be able to come up with web sites/applications that are as nice-looking as they are functional. I've been trying to work on it, though, and it has been getting better, albeit quite slowly.
Nice to see grpc being used in the wild! I know you didn't request feedback, so I hope you don't mind the following observation: I liked how you specifically validated the incoming arguments in the divide method, however I noticed that you were using a non-standard grpc error code (1000) when the divisor was zero. Personally I would suggest using InvalidArgument (3). You can find the complete list of standard codes [here](https://github.com/grpc/grpc-go/blob/master/codes/codes.go)
I just wish that setState knew how to perform deep copies. Handling nested objects with setState is kind of a chore, but more importantly, if you forget/don't know the particular nuance here, you have a very easy path to error introduction. 
I love CSS. Yes, it's not perfect but it's great! But I'm not really happy about JS, you learn something and now have to do it another way. 
I absolutely love front end javascript and the superior programming language HTML, but I absolutely hate writing css. What's worse is that I hate using css libraries as well, so I'm just stuck with choosing the lesser of two evils.
I'm knew to React. Can you explain the issues with nested objects? Thanks
you can use jquery. https://stackoverflow.com/a/6677069
Use an RSS reader 
with modern CSS and especially UI-libraries like Bootstrap 4, I don't mind it anymore. It used to be a hell of a struggle..
Well being a backend nodejs developer I think I can safely fall under that category. 
&gt;there's just times where I feel I'm spending too much time on it This, this is my exact experience with CSS so far.
This is the paint layer for Mozilla's Servo project and will power Firefox eventually. It takes a list of rectangles and text and draws them on the GPU. In the browser, the display list comes from the layout engine processing styled DOM nodes but this is just the rendering part and you can use it to draw whatever you want. There's been speculation in the Rust community that something based on Webrender could be a good alternative to Electron. If you look through the linked README, the author is in this camp. There's tips for using React and a note that memory use is 20 MB.
If you are struggle with flexbox, I have no idea how your code looks like
Use sass, don't be a crab
I'm old. I did this during the DHTML days. "used to be" before flexbox and all that jazz.
Yes, and most people I work with too.
Please, just, please, don't spam with jQuery in almost 2019
CSS is horrifying to me, but I've gotten used to it. Modern CSS, CSS preprocessing languages, and frameworks like Bootstrap have taken a lot of pain out of it, however.
Its love hate, like with anything it takes time to learn something and be good at it. I usually just look everything css up if its more complicated but i think its easier to use css than js for some animations now as well. 
Rhino (Java based), Windows Scripting Host (bundled in Windows, *technically* runs JScript, not JavaScript), Spidermonkey (Mozilla's JS engine) at least come to mind.
Why not use a utility first framework like tailwind css and have both freedom to express design but the simplicity of predefined utilities, such as flex layout and typography classes.
I hate CSS but I love stylus
/r/anothermediumselfpromotionpost
Something like this?: https://jsfiddle.net/46fm0t1n/ It uses two iframes controlled by the parent, untested in IE, so not sure if it will work XMLHttpRequest with callbacks would be cleaner but looks like it requires IE &gt;= 7 
I love css, I hated it before I could really understand it, but after several good courses and years of experience with it I really do love it and enjoy styling process with css(well actually scss).
Yes, I did until I crossed a threshold of not needing to support old browsers anymore on any of my projects. Then I became a flexbox whore with sprinklings of grid. CSS became very very simple. I'm talking about matching designs from an experienced designer btw, if you're talking about being an all in one dev/designer that's completely different.
Checking in. Love js mostly because of node (from which I earn my bread). Trying to learn vue but the whole CSS crap is irritating.
&gt;Superior programming language HTML Huh?..
Ah, now that you say it, I've heard of Rhino and Spidermonkey before. I didn't think they were for standalone usage, but a quick Googling seems to show that they can be used that way.
Spidermonkey is probably your best bet if you want something that compares to Node at least in terms of features. Rhino and WSH are both fairly outdated featurewise
Hi, Bob! Take a look at https://javascript.info/ for the start. It covers the minimal requirements for the newbies in web development. Also you can find a lot of tutorials almost everywhere in the web
Yeah I've found the most frustrating part of CSS is just browser support and having a fallback system in place. That's when it gets pretty headache inducing 
If you have a state with nested objects, and you call setState to update this, setState will only compare the top level object to determine if setState needs to do anything. Example: state = { parent: { child1: someValue1, child2: someValue2 child3: someValue3 }, regularStateKey: someValue4 } If you want to update state.regularStateKey, you would simply call setState({regularStateKey: newValue}) If you were to do the same thing to update state.parent.child*, one might think that you could simply perform setState on the parent key with something like this: setState({parent.child1: someNewValue1}) But the setState function will not allow you to do this. There are many workarounds for this, some of which involve just mutating the subchildren in a state directly, which directly contradicts the principles of React and state manipulation, however since there is no inbuilt way to accomplish this, I can see why people do it: let parentPointer = state.parent parentPointer.child1 = someNewValue1 This will change the value of state.parent.child1 to the new desired state, but react doesn't know that the state has been updated because state.parent hasn't changed as far as react can tell, so no new rendering is triggered. The other main workaround (what I use) is to make a copy of parent, and then update state to the new one. let newParent = {...state.parent} newParent.child1 = someNewValue1 setState({parent: newParent}) While it does adhere to the principles of react, here are downsides to this as well with regards to performance. Anything with state.parent.child1, state.parent.child2, state.parent.child3 will run through render lifecycles, instead of just state.parent.child1 as one might think. You can mitigate this with a custom shouldComponentUpdate() function, however, your simple update to a nested object is quickly becoming very complex. The official stance from the react devs is that you should just use flat state, but I find that huge single level state objects are not only unwieldy, but can easily lead to other issues that are a whole other topic, so I wont get into it here. Hence why I wish they would just handle deep state comparisons. 
CSS is like painting or sculpting. You have a bunch of roughly organized things, and after countless hours, you can achieve beauty for the eye. Although I moved to backend lately, I still enjoy tinkering on the frontend 'till I achieve that perfection which is -- quoting Steve Jobs -- so good you want to lick it. I will always love frontend despite its many, many caveats and headaches. It is the first impression for a user landing on your application.
TBH, I was mostly asking out of curiosity. I'm happy using Node.
When the token expires it won‚Äôt work anymore. You just need to request a new token before this happens to continue with uninterrupted access . The reason this is done is in case your token is compromised, an expiration means that the compromised token is eventually no good.
Your blog is fire as always 
If you're working in *UI/UX / front-end / presentation* and hate CSS then you're in the wrong field. Developers working in UI should have an appreciation for presentation, pixel-perfect precision, animation, etc. and most strong UI programmers have backgrounds in design and visual arts. There are many programming specialities outside of UI/UX programming that require strong experience in math, statistics, etc., you can (and probably should) focus your talents and interest.
This is not very constructive. What exactly is wrong with the article? Besides, why else would people go to the trouble to write and share free content with you, if not to self-promote? It's a win win.
I'm cool with CSS. Bigger fan of using SASS
Typescript: am I a joke to you?
I dont hate CSS, I find it can be fun to fidget with it actually. What I hate is trying to design UI's; I have little to no creative point inside me so I usually end up using a pre-designed template from sites like wrapbootstrap. It might cost $20 - $35/site for a license but it saves me hours of trying to make something that looks halfway decent. 
That was a joke. I hang out in r/programminghumor too much.
How are trying to do that ?
If you use react, try out Styled Components. They let you get rid of a lot of the stupidity of CSS.
I feel the opposite - hit me up! 
I used to feel that way. Then I got hired as a full time full stack developer. Thing is, if you do it every day, eventually you just get so good at it that it's not hard anymore, and in fact easy and enjoyable. Now I get jealous of my coworkers when they get tickets with CSS and I don't - they're always the first pieces of work to get snatched up. If you hate CSS, you haven't written enough CSS. That being said, definitely use a preprocessor like less, sass or stylus
Designers exist. You won't have to design
Some people combine lots of API's for their stuff... &amp;#x200B; Sometimes I combine lots of snippets! &amp;#x200B; Spooky Text Flame Effect: [https://codepen.io/SarahC/details/mQgLBW](https://codepen.io/SarahC/details/mQgLBW)
Pardon my ignorance, but wouldn't the following work? setState( {parent: {child1: newValue}} )
Ohhhh....... sneeky. $5 well spent! Hehe.
Sweet!
Have you heard of immer? https://github.com/mweststrate/immer You can immutably update an object with mutable APIs. 
I've been on the learn-to-code/bootcamp/junior dev journey since early 2016 and frankly the freakin' bitching about CSS is old. We get it. CSS is now considered a problem requiring solution (styled components...) just so anti CSS devs don't have to spend time studying it like they would any other language or methodology. I like it. I don't find it hard or frustrating. It's part of my role just like Redux is. Either treat it with some respect and learn it well, as you would a fancy new framework, or don't, but that's your problem, not CSSs. Tldr: really tired of all the CSS hate and its devaluing in this industry.
Very tidy! Works perfectly on my Chrome browser. &amp;#x200B; .games TLD eh? Wow...
I like it and if I weren't using for my APIs these days GraphQL I'd probably even use it. 
Anyone here love carpentry but hate measuring and leveling? LOL 
So is Promise.resolve('john') .then( a =&gt; console.log("RESOLVE", a), ) .catch( a =&gt; console.log("REJECTED", a) ) equivalent to: Promise.resolve('john') .then( a =&gt; console.log("RESOLVE", a), a =&gt; console.log("REJECTED", a) ) 
CSS and SASS is OK (post-flex era) Old CSS is atrocious.
I've been a web developer for 19 years and the first half of that time is what we would now call "full stack". Javascript was primarily used for form validation and or computations inside grids. The second half of my web development career has been focused on the front end. And the first framework I used was ExtJS, and it became my bread and butter for 5 years. Say what you will about it, but the *only* thing you do when working with ExtJS, is write Javascript -- it completely shields you from the HTML and CSS. This wound up being a weakness for me when trying to get non-ExtJS work however, but luckily I found something using Backbone (which was big at the time) all sorts of things I hadn't been exposed to yet, requirejs, underscorejs, Node, etc. Even then though I was surrounded by others who were better at HTML and CSS than I was. Finally 3 years ago I took a position where I was the sole developer, and this really forced me to dig in. On an interview a couple of months ago they asked me to rate my CSS from 1-10. They weren't going to take it at face value, but rather probe further, to find out if you think you're worse than you are. I gave myself a 4 or 5, then they asked me some questions and told me, if I know those things, I'm at least a 6. tldr; I don't know that I hated HTML/CSS previously, but I've gotten much better lately, and it's enjoyable to add new skills (most recently for me flexbox)
Brilliant and simple. I like it
Anyone recommend one for React?
&gt;You can mitigate this with a custom shouldComponentUpdate() function, however, your simple update to a nested object is quickly becoming very complex. You likely don't need a custom shouldComponentUpdate, you can just make the child a PureComponent. Also, deep state comparisons are expensive, but if the pattern you use above for immutable updates is feeling clunky to you, you should check out Immer if you haven't already.
Yes. Yes. Yes. Generally CSS doesn't seem that hard, but it's what I fight the most with. Particularly using canvas elements in the flexbox with flex-grow. Set the width or height (not style.width, the actually bitmap width of the canvas) and the whole thing falls apart. I resort to using JavaScript to manually place everything where it needs to go.
I'm with you there... I spend more time getting the css just right than the rest of the project 
Node-ChakraCore is Node that runs on Microsoft's Chakra engine instead of V8. 
Probs better than your grammar 
There are a lot of tutorials on YouTube and other places. [W3Schools](https://www.w3schools.com/) is a great resource and includes other languages as well. [Udemy](https://www.udemy.com/) is my 'go to' for a lot of learning material as well. Finishing up [Modern JavaScript From The Beginning](https://www.udemy.com/modern-javascript-from-the-beginning/) myself.
Same boat here and I did the exact same thing. Vuetify was a breeze to work with, made a large form and content driven app and it made the front end work near trivial. If you need to use their stepper but want a responsive version of it, check out my GitHub repo, I created an nom package for a simple responsive implementation of their stepper component. Have fun!
CSS is "trivial" until you deploy your app and no one uses it because it looks like a janky POS.
That would lose the existing child2 and child3 values. 
Haha thanks! I have been doing web development for nearly 20 years, but never learned js in any real depth. Mostly relied on things like jquery. I'm trying to beef up my client side skills. Thanks for the feedback. I will refactor those into classes. That is my "haven't kept up with language enhancements" showing üòÅ
It has terrible browser-support tough.
Yes, writing CSS is too time consuming for me. 
Same here. 
Yes. I don't care about making things pretty. That's someone else's problem. 
Are you sure about that? That doesn't seem to be how setState works. It doesn't appear to delete variables that are not explicitly updated. Even so, couldn't you just: setState( {parent: {child1: newValue, child2: state.parent.child2, child3: state.parent.child3}} ) ?
I use this npm package to download 5 separate JavaScript engines to test against ... &amp;#x200B; &amp;#x200B; [https://github.com/GoogleChromeLabs/jsvu](https://github.com/GoogleChromeLabs/jsvu) &amp;#x200B; You should also check out [https://duktape.org/](https://duktape.org/) &amp;#x200B;
One way to avoid it is to not use deep object structures, and instead normalize them. That avoids a bunch of other problems (like ensuring consistent edits) too.
You could try [Bulma](https://www.bulma.io). It's CSS only so it works with any JS framework.
Yes, that's the root of the problem. This is basically the same as the spread syntax. Performance implications and yadda-yadda.
Oh yeah, and the application I work on we have to support all three major browsers (IE/Chrome/FF) and then also support an embedded mode of our app. Makes it complicated finding a solution for one thing, and then one of those it doesn't work.
What is a better option? &amp;#x200B;
Same. I have a hard time doing frontend because I don't enjoy it and get frustrated quickly. 
The minute you want to start over writing stuff in Vuetify you realise the CSS has been implemented by a bunch of back end devs. It also has a load of niggly bugs in it. 
I feel the opposite, but that‚Äôs because I started my career as a designer. JavaScript has for a long time been a huge pain compared to other languages. Thankfully recently JavaScript has been getting much better thanks to promises, async/await and classes.
In my case I really love it, I don't spend too much time lately because I prefer to get better with javascript but I find it really powerful. I always have the feeling that people takes CSS for granted and something easy to implement, at the end is just putting colours and change sizes, right? but at the end I think is one of the most difficult parts as a Front end dev. Sure, that it's easy to add those rules at the end of the file or even worst, add \`!important\` everywhere to solve specificity issues but write good CSS is quite hard. I would love to know more about it but for me is something that I spend time with whenever I need to style something. I'll always remember this full stack team leader that used to apply styles to the same html element or either using style attributes, on CSS files or using Javascript.... it was a complete nightmare (although enjoyable) when he was asking me why he couldn't change the \`font-size\` hahhahahah Mastering CSS is a freaking art. [http://diana-adrianne.com/purecss-francine/](http://diana-adrianne.com/purecss-francine/) if you like CSS you'll enjoy this piece of work. &amp;#x200B; 
I love CSS! It makes me feel like a design wizard. Nothing better than taking a bunch of HTML and making it look amazing
JavaScript is unrelated to CSS. They're two different, nearly unrelated aspacts of the frontend.
From what I've seen so far it appears reasonable for my application. I've always been hesitant to use a design framework until now, where my app is rapidly expanding. If there's a few bugs or whatever it's most likely less than what I'd have without. That being said I haven't began re-writing my frontend with Vuetify so we shall see.
[This JS only solution won't work in IE, Edge, and Safari for smooth scrolling though just an FYI.](https://stackoverflow.com/a/48901013/4282688) I would say if you need to support IE, Edge, and Safari with the smooth scrolling look at /u/SoySauceRoosterBrand solution.
Under development, but I think [Deno](https://github.com/denoland/deno) is quite interesting project.
Your development team should be large enough that you can leave CSS styling to someone else.
It only keeps untouched top-level state variables. The ‚Äúproblem‚Äù here is that they want it to automatically treat nested objects like those top-level variables, so that you wouldn‚Äôt need to manage that yourself. Also currently child components you pass something like child3 into will get needlessly rerendered since it‚Äôs technically a new object, even though you really only wanted to change child1. 
This definitely seems like a flaw on React's part. If I could just as easily not have an object and instead put everything flat on the state object, it would be easier, but I'd have a messier project.
&gt; most strong UI programmers have backgrounds in design and visual arts. If that was even remotely true there wouldn't be so many bad interfaces out there.
I think once you get used to how selectors work and the fact that the order that you put style sheets in matters it's not too bad. As long as you understand that a more specific selector will override a less specific selector you can work around it.
Not necessarily, if you're at a large enough company, then there's often roles who specialize in CSS/HTML. We have such people, and they're responsible for generating components and patterns, such that when the layperson implements a feature, 95% of the time all the dev has to do is paint-by-numbers with regards to the presentation. Most PR's have zero CSS and minimal markup.
SASS plus a post-processor make css great for me. (Basically just using modern css) It works great, largely predictable, and with SASS has enough of the dry options available make it easy to work on and manage large projects. Maybe that's just me, I've been working with it for so long it's like second nature.
I still love it. It‚Äôs my job and I‚Äôve got no choice. I love seeing all the changes to it over the years. 
JS is bad, CSS is horrible. I don't even consider CSS as a language.
&gt; should be
Great explanation! Thank you.
Directory selection from file input is quite well supported nowadays: https://caniuse.com/input-file-directory. We've had a lot of success using https://github.com/flowjs/flow.js which supports directories without issue. You can find the server-side example at https://github.com/flowjs/flow.js/tree/master/samples/Node.js.
Thanks! I pulled this from [marklet.com](https://marklet.com), it's from a 2010 post and is supposed to help the user clear all cookies before you close the browser window. I found it while searching for ways to isolate session cookies without having to close all browser windows. &amp;#x200B; I'm really new to JS so I wanted to verify that it did what it said it did lol. &amp;#x200B;
Although not one I share, based on virtually all of my colleagues present and past, the feeling seems to be ‚Äúone is awesome, the other a necessity‚Äù. I haven‚Äôt come across many front end devs who share the same passion and talent for JS and custom CSS. I just want to point out that proper understanding of your markup structure is incredibly important as well in avoiding stylesheet woes. HTML should not be underestimated. I started with CSS/markup and focused heavily on it when I was still learning and had the time to bang my head against a wall over and over again (I also tend to be unusually patient faced with things I don‚Äôt understand but want to). Eventually you get the hang of it. I can blindly send a CSS snippet over slack to a dev knowing it‚Äôll work unless they‚Äôve not told me something important about the context. When I started working at an agency and got my hands dirty with Vue and setting up a headless CMS, it triggered that same part of my brain that CSS had. Now I work in a shop that does large scale custom web apps in React. It‚Äôs an odd feeling because out of the almost 20 JS devs, I‚Äôm in the top 3 as far as knowledge goes but am the only one who can write the markup and styles (after a month I asked that the next hire be someone with strong css and templating skills, couldn‚Äôt get everything done alone). A side note, because it scares me that it‚Äôs actually gaining traction: for the love of god please stop/don‚Äôt go with the css-in-js shitstorm! Or at least explain to me how it‚Äôs better than having stylesheets with reusable/decoupled styles? A few tips and lessons learned from my experience: - you‚Äôre not alone in preferring JS over CSS. - If you don‚Äôt have the time or interest to learn, use a style framework. I don‚Äôt, but if I did [Tailwind](https://tailwindcss.com) seems to have a really nice approach. - if frameworks are not an option (or even if they are), adopt and implement a CSS methodology in your workplace. The most popular and my favourite being [BEM](https://getbem.com) - write less style rules, try and let your HTML structure fall into place naturally before forcing it. When I go to someone‚Äôs station to help them fix some style issue, I often end up removing code without adding any to make it work. It‚Äôs not as complicated as you think, but takes practice. - stop nesting so much. It makes the layout more difficult to control and more prone to breaking. If you‚Äôre using React, embrace `React.Fragment` to avoid unnecessary divs. While you‚Äôre at it, HTML has more than just the div element. Throw out a section or a header here and there just for readability. There is a lot of value in being good at both, for yourself ($$), your team/employer and your products. Just for reference, here‚Äôs that project that got me started: [SPK.rocks](https://spk.rocks). VueJS front end with a custom consumer/reducer for the Prismic.io backend (their JS SDK sucked at the time). Only the design was done by someone else (I‚Äôm hopeless in that field). The only JS powered animation is that morphing shape on the ecosystem page, literally everything else is just Vue toggling some classes.
Yes, I love js but hate building layouts
CSS in JS is a good option in that case. Your kneejerk reaction is probably "ew why would you do that?", but if you remove any preconceived notions of what CSS should be from your mind, it makes absolute sense. CSS has quite a few issues: it's global mutable state; it isn't easily connected to JS; it's incredibly tedious to write. CSS in JS fixes a lot of these issues. First, it's modular by default. No worrying about if your styles bleed out into the global namespace, no worrying about hidden conflicts with CSS libraries, no relying on BEM, etc. Second, it's integrated into the JS ecosystem. Style rules are just objects. Want to make a class centered? Do an object spread from a `{ display: "flex", alignItems: "center", justifyContent: "center"}`. Want to animate a div? String interpolation it: `{ translateX: \`${offset}px\` }`. This has really cool implications. For instance, you can have styles in react-jss depend on the props of a component. Finally, you don't have to rely on the weird, pseudo-ruby DSL that is SASS. No @if or whatever. Just JavaScript.
Practice, really. A family friend asked me to make a website for her home business, so that was one opportunity. And I had another when I was asked to make a page for an interview assignment. It seems to be a process of looking at other sites of similar function, taking note of things you think look good, and trying to integrate them into what you already have.
Yeah, that does look interesting.
Well yeah it's actually so common. I find it more rare for someone who likes JS to love CSS. I think it's partially to due with the prevalence of boot camps and self taught programmers who start with JS as their main language. JS is much easier to learn and ppl love the npm ecosystem so many have elected to stay within JS for backend too. Ppl who began doing backend dev before JS became what it is today usually view JS as a front-end script still. I recommend JS developers to still learn HTML and CSS though. Cus front-end was what made JS into what it is today and a lot of JS quirks had its roots in its scripty days. We owe it to ourselves to learn them as JS devs
zip all the files in the folder then upload the archived folder, unpack on the server if you need to. &amp;#x200B;
The main thing I dislike about css is working on someone elses broken css structure. Its just so easy to get wrong and let things slide and then it becomes the next guys problem.
You can't make a responsive website without CSS. CSS today is friggin awesome and much easier to write than before. With Sass and flex/grids design have never been easier. It's one thing to say you don't like CSS but you gotta give better reasons if you think it's horrible. 
I'm lucky, I work a ton of backend and when I work frontend I only work on javascript using Vue or React, I hate CSS. 
Just so you know, it's weird to introduce yourself by name online.
I am learning to be a nodejs backend dev. I know a bit of mongoose, sequelize, express , validations , async/await etc. . Can you please tell me what else do i need to know to become job ready ? 
Is this what you need? http://usejsdoc.org/tags-property.html ``` /** * @typedef {Object} Window * @prop {string} NewProperty */ ```
https://github.com/karan/Projects
&lt;3 CSS, but lately we've all became lazy using "frameworks" and shit. Back in the days we actually got to write some css, these days there's none of that
Learn everything you can about http and web interactions. Sessions, cookies, tokens, oauth, etags, the different types of http verbs, basic auth, file streams, learn about bash, and scp, and git, learn all your base commands, tail, top, du, cat, gunzip. The list goes on. To be a good backend developer is not to know a language very well. You should but you will learn that as you work if you care about the quality of your code. To be a good backend developer you need to understand how to the web works so you can make intelligent choices about design, and you need to know the tools you have at your disposal. Node will come and go. If you want to know what you need to learn to be better at nodejs thats a different question. 
any helpful resources you have in mind for this ? and also what i need to learn to be better at nodejs? nodejs is everywhere . build tools, backend, blockchain. and i like js a lot . so it's my preferred choice. 
Prime React 
Its not a big deal anymore for me, working with Styled Components makes everything easier (React) 
It's probably fine for personal projects. I'm currently contracting with a company who decided to use it, and now want to eat their cake by making sweeping changes to the material design spec that Vuetify implements. Nightmare.
Nope. The former is two steps, hence two `thens`. To see the difference Promise.resolve('john') .then( a =&gt; { throw Error(a) } ) .catch( a =&gt; console.log("REJECTED", a) ) // REJECTED Error: "john" Promise.resolve('john') .then( a =&gt; { throw Error(a) }, a =&gt; console.log("REJECTED", a) ) // Promise { &lt;state&gt;: "pending" } There is nothing to catch the Error here
Interesting. My project needs to be scalable. From my point of view, using a specified design spec helps that. What kind of issues does it present?
Applied to the job only. Also they can be really bad
You totally can. There are several people on this website that think JS can't do everything that CSS can. But it can. It just require the programming skill.
Designers don‚Äôt write code. Front end devs do. Understanding CSS is part of the job, just as knowing HTML properly is.
Yeah. They‚Äôre called front end developers. The people who do the other stuff are backend developers.
What. Yeah and I can write Javascript with C so Javascript sucks too. Like, why would you? There are rendering engines out there that parses CSS why in the world would you want to port it to use JS. What. 
I see how differences can arise if an error is thrown in the resolution callback. For the sake of argument, assuming no errors occur in `callback1`, are these two the same: Promise.resolve(somePromise).then(callback1).catch(callback2) and Promise.resolve(somePromise).then(callback1, callback2) The earlier example in this thread had one or the other argument of `then` as non-null: I'm just trying to understand what happens when both arguments of `then` are non-null.
Gnome uses a Spidermonkey engine for [GJS](https://gitlab.gnome.org/GNOME/gjs/wikis/Home). So you can do `gjs script.js` much like you would `node script.js`, except that none of the node stdlib is available, instead you have GTK libs.
Why would I use an half-assed stuff like CSS when I have a full-blown language at my disposition.
Sure why don't u do a rotating wheel that goes across a screen in JS and I'll get on the bandwagon. It's like a wha. 2 liner in CSS? 
&gt; Sure why don't u do a rotating wheel that goes across a screen in JS and I'll get on the bandwagon. It's like a wha. 2 liner in CSS? Using events and canvas it's very doable, not in 2 line, but in exchange you get a finer control on what you do and how you do it. I asked you for example of something that **you can't** do in JS and you can do in CSS. Number of line is irrelevant to anything I said so far. 
More like Anyone here love carpentry but hate siding and painting.
I'm sorry, but good looks are important on a professional website or app. The difficulty is not in the CSS, but in getting it look good, and that requires an artistic talent that most people lack, and especially among programmers, and certainly among programmers with a thing for math. That is why it's important to be able to split a program among several people where some only care about functionality, and someone makes it look good.
Can you elaborate on the "bugs"? 
Okay, thanks a lot already! I tried that, but am not sure how to apply it properly. I got this to work: /** * @typedef {Object} Globals * @prop {boolean} [__myFlag__] * * @typedef {Window &amp; Globals} ExtendedWindow */ // or short: /** * @typedef {Window &amp; {__myFlag__: [boolean]}} ExtendedWindow */ then: var w = /** @type {ExtendedWindow} */ (window); var myFlag = w.__myFlag__; But that's not adding a prop to the type `Window` itself but instead creating a new type that inherits from it, then casting the reference to window to this type. Works for now so that's good, but not 100% accurate as in reality not only the reference is extended, but `window` itself. Actually adding to `Window` would be better, but no combination of `@interface`, `@namespace`, `@typedef` and `@property` I tried worked :(
I used to program in c++, which means that most of the time you create console apps, UI are usually a pain in the ass. Then when I switched to web programming, I fell in love with front end(css) since it was so simple and effective.
Yup, just wait for the time when you have to have another team do just the accessibility testing and you're responsible for the full stack and entire project. 
Lol then do it. Anyone can just talk theoretical but can you even pull it off? Do you even have the skill? I doubt it. 
Doesn't that just move the logic from within setState to when you fetch it from the server? For instance, let's say I have a route where we load some JSON: ``` GET /user/1234/ { "id": 1234 "movies": [{ "title": "Star Wars: Episode IV - A New Hope", "release_date": "25-05-1977" }], ... } ``` You'd have to do ``` // in componentDidMount const userResponse = await fetch('/user/1234') const user = await userResponse.json() this.setState({id: user.id, movies: user.movies }) ``` and to update the user: ``` saveUser = () =&gt; { fetch('/user/1234', { method: 'PUT', body: JSON.stringify({ id: this.state.id, movies: this.state.movies }) }) } ``` vs a more simpler way of: ``` fetch('/user/1234') .then(res =&gt; res.json()) .then(user =&gt; this.setState({ user }) ``` and ``` fetch('/user/1234', { method: 'PUT', body: JSON.stringify(this.state.user) }) ```
Exactly how I do it.
So you don't even know it's possible to do that in JS and come discussing about language feature in r/javascript. Why would I waste my time for a nb. If you don't want to believe me I don't really care.
hated it until I "figured it out"... dont: ``` .my-awesome-button { padding: 3px; margin: 2px 4px 3px 8px; box-shadow: 4px 4px 4px #222; etc etc.... } ``` do: ``` .shadowed { box-shadow: 4px 4px 4px #222; } .padded { padding: 3px; } etc, etc... ``` note that the 2nd way is more re-usable. bonus points if you use css variables. 
That's why node.js exists, javascript in the backend. 
`myVar++` will return the original variable and increment the variable. `++myVar` will increment the variable, and return the changed variable. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Increment for more info.
The code on the left returns myVar and then increments it. Try evaluating it again and you'll see it's 1.
To do it in JS means you'd basically have to understand CSS. Otherwise it's like you're saying that you can make a wedding cake with your eyes closed. How do you apply color? How do you apply positioning? It's not by mixing eggs flour and sugar. 
Because you are not incrementing with + 1, you are adding unless you do.. myVar = myVar +1; you should get 1
You don't wanna waste your time cus you can't do it dude. It's fine to admit it. You don't even know where to begin. You prob never even written a canvas or done any vector animation. You prob can't even grasp the complexity of how browsers render graphics and do animations. Your statement that JS can do anything CSS can is as useful as me saying I can do everything JS can with pure sand on the beach. Just gotta construct em into semiconductors first! Easy! Don't talk big. Just accept you have lots to learn and keep learning. Don't look down on other tech. 
It's done through the DOM. It's fairly logic and easy to use once you have seen the doc. 
What? `myVar + 1` is equivalent to `myVar +1`. You might be thinking of using the `+` operator to concatenate strings, but that would only occur if `myVar` was a string itself.
Thank you. This helped.
I probably am, fairly new to coding javascript myself
lol
It gets a bit complicated when you wanna take advantage of the cascading nature of CSS. Cus neither classical inheritance or prototypal inheritance can really model the cascading styles. Let's say you create a class with text size 12. It makes sense for the classes under that class within the DOM also get size 12. But there's technically no relationship between those classes besides one is a child in DOM. This is why CSS is still needed. 
CSS = Cancerous Style Sheets. Some of the frameworks and grid/flexbox have helped a lot, though.
It's odd that freecodecamp only tells you about `i++` and not `++i` (it has a link to the mdn site but who's got the time, right? LOL, kidding)
It is, but there is no real reason for it. CSS and JS are fundamentally different. Thankfully, nowadays, you can use only JS/TS and avoid CSS completely. 
You were nailing it until that last bit about preprocessors. I completely with everything before that though, esp ‚Äúif you hate CSS, you haven‚Äôt written enough CSS.‚Äù
Isn't now pretty much IE11 the only problem? It seems like the rest have mostly supported features (grid and flex.) 
i love css and hate javascript! 
I prefer back-end work more than front-end. But I'd still try to market myself as full stack and do CSS if necessary. It's just not my preferred route of development. 
I think the problem is that CSS is often something that's barely tacked on to a web developer's education - so it ends up taking us years to really get comfortable with it. Yes, flexbox and grid make the basic layout much easier. But most of us just aren't comfortable with pixel-perfect, beautiful design, even though we have pixel-perfect and beautiful desires.
&gt; You were nailing it until that last bit about preprocessors Can you elaborate on your beef with preprocessors?
Checked his post history, I don‚Äôt think he knows what he‚Äôs talking about 
No beef, I think CSS is natively powerful and flexible enough that there are cases where a preprocessor is unnecessary. Just my opinion of course.
On the contrary, &lt;canvas&gt; usage is entirely javascript.
[semantic bindings for react](https://react.semantic-ui.com) 
Are you content with a single, massive CSS file? Being able to split up one's SCSS into multiple, modular files should be reason enough imo.
I'm not entirely sure how that's relevant. Cascading works exactly the same in JSS as it does in regular CSS. Actually though, prototype inheritance would kind of work. Because if you think of CSS properties just as instance variables, the prototype chain is precisely the "cascading" part. 
Lol ok
There‚Äôs nothing stopping you from contracting a designer yourself. It‚Äôs not just something that companies can magically do and people can‚Äôt.
True but depending on the design tools used sometimes the CSS writes itself. The designers where I work use Zeplin for the mockups, which will generate the css you need to make the app look just like the mockups. Sometimes you have to adjust it a little to be less repetitive but it writes about 90% of the CSS.
Yep, those are indeed the problem. IE9 and up isn't too bad. But going lower can have you racking your brain for a while. I'd honestly just be happy with control that flex provides, but the fact that grid exists almost feels like a dream. It does make me wonder what's next in for the display scope.
I actually feel the opposite way. But as someone wrote above probably because I haven't written enough JavaScript to be comfortable with it. 
The cascading function of CSS is vital to effective presentation and rapid UI development. Sure, you can do it without using CSS but it'd make the code bloated, hard to maintain and slow because it doesn't take advantage of native browser optimization dedicated to handling the styles. They serve entirely separate purposes. CSS and JS together leverage the advantages of each other. I'm good with using JS to manipulate the style, but the style is there either way. You can drive a nail in with a hammer, shoe, or rock, but one of those is a better tool for the job. (good luck using rocks for shoes). Just like the cake would be ugly and few would buy it, and those that do just don't know better. 
Just do like a few websites I've seen and say "Get a real browser". (I forget which ones do that.) 
Tailwind is something I've heard good things about, but it has a pretty unique approach.
If that isn't enough, surely you can understand the benefits to DRYing up styles with mixins and functions? Not to mention being able to avoid dealing with browser quirks and vendor prefixing by way of Autoprefixer.
Haha
No. Design is great as a developer. You should be looking at following design principles and how your JS is presented on the page. The artistic aspect should be handled by a designer, not you.
you can also put regular css through autoprefixer afaik. &amp;#x200B; OT: Happy cake day :)
Front-end is a Stockholm syndrome breeding ground.
i think you're agreeing with me. however, I don't agree that the answer is to "get good." most development teams are going to be made up of people of all skill levels. it's important to try and come up with processes that ensures the quality of the code is maintained at a standard that is acceptable to a majority of the team. otherwise TD can result in wasted time down the road. strictly adhering to TDD does solve this problem, and does successfully mitigate some overengineering work. it doesn't eliminate overengineering, as we see in this very article the author is unable to resist adding an unnecessary configuration feature. the client is looking to have different interest rates applied to accounts depending on their total balance, and the author decides to refactor to allow for this to be configured by changing a yaml file. Of course, the client never asked for this feature, and adding it may open them up to unnecessary legal risk as a result of our overly generous developer. my main point is that strict TDD does not provide much real benefit over regular PR and code reviews. How much more is the customer getting? By my measure, not much. TDD is largely a process taken on by developers eager to produce pristine string parsing libraries they can show off to their friends. It represents the pursuit of perfection at the expense of good enough.
Shouldn't it be '/createPDF'? 
You're right. I simplified the code a bit to make it easier to understand.
This may not be the most accurate explanation, but imagine if you took Electron and removed everything from it except for nodejs, IPC and the html canvas element - that's kinda what it's like.
Yeah was conflating preprocessors and PostCSS for simplicity but thou art right OT: thanks!
crockford
Ate you trying to send the data as query parameters, or as the request body? I think the way your code is now, it will be sent as the request body, but if you're successfully doing it from the address bar, that sounds like your using query parameters. 
In case you did not find it (it is a bit hidden I think), this page lists JSDoc support in JavaScript in Visual Studio Code: [https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript](https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript)
You are correct. Variables don't watch the right side of assignments. So you have to assign the new value when the state of your todo list changes. Soo when you remove or add items from/to the list you also have to change the display value.
 I see, thank you.
The problem has nothing to do with JSDoc. It's a TypeScript problem. Because TypeScript is a static type checker, it can't understand expando properties on objects that JavaScript handles gracefully in the browser. The only way to handle expando properties for TypeScript checking is to escape the property: window['NewProperty'] = 'whatever'
I hate Javascript and I think CSS is ok.
Thanks for this information! So there's no way currently, as I never assign the property and thus can't use the escape trick?
I feel pretty meh about JavaScript (I like TypeScript a lot more) but I loooove CSS. I find myself wishing I could just use CSS in my design software all the time. Maybe we could write a dual-resume and apply for a single front-end developer job like Mac and Charlie in that one episode of Always Sunny.
I'll check it out, thank you.
Coming from Xcode, it felt foreign for methods to not autocomplete with open parentheses with parameter options in place (meaning you can simply start tying to input parameters.) Fortunately you can configure VSCode's settings to do this! "typescript.format.placeOpenBraceOnNewLineForFunctions": true, "typescript.suggest.completeFunctionCalls": true, "javascript.format.placeOpenBraceOnNewLineForFunctions": true, "javascript.suggest.completeFunctionCalls": true, _(In the gif, I'm pressing 'a' to bring up autocomplete, Enter to autocomplete, Tab to input x, Tab to input y)_
But it's cute
Reminds me of LightTable
Maybe I'm in the minority here, but I firmly believe that front-end devs should have at least some basic design sense and web/app designers should have at least some experience with HTML/CSS. The latter means you'll never be presented with a mockup that's unworkable as a responsive/interactive website/app, and the former means you won't have to reach out for a new PSD every time you need to make some small addition or change. Although I guess good communication during the design process can kind of fill in those gaps.
Yeah I love CSS, JS is fun but CSS is the best part about development for me. I wish I did that part more, usually it‚Äôs a lot more JS than styling.
Alternatively you can use getElementsByClassName (https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName) on the todo-list and assign it to a variable and count the childNodes. GetElementsByClassName is a HTMLCollection and is LIVE. 
I use Vuetify for dashboards and back-offices, where design doesn't matter and it's okay to have a generic material design. I would love to have the same components without the opinionated style
Me too ^^. JS is great but it's like to try to fix a broken bridge. I work a lot with Es6+ and a lots of things are weird. And I have to know how to use JS the old and the new way. 
Our artworkers know a little HTML/CSS. It's great because they can go in and fix shit bugs instead of creating a ticket, assigning us to do it, we sync and upload etc. But sometimes its a pain when one of them has applied a width of 470px to every p tag in the project because he wanted to fix a modal and wasn't specific enough. Generally works out well though.
Not a big fan of CSS, but I can do it if I have to. I think most of the hate I have stems from always inheriting something at work and having to fix some older jumbled mess.
you should check out immer, its amazing [https://github.com/mweststrate/immer](https://github.com/mweststrate/immer)
I love both but I hate the needless problems we have to face while coding front-ends due to kiddy war games between various browsers.
I use reactstrap
First you need to learn JavaScript fundamentals: prototypal inheritance, property shadowing, event loop, execution scopes etc. Then you need to learn ES6 fundamentals: desrtucturing, TDZ, generators etc. without these knowledge learning any framework is not much useful since you won‚Äôt be able to understand &lt;specific framework&gt; way of doing things 
https://www.udemy.com/share/10008CBUYddVZSRXQ=/ Try this course...it's not expensive and you will learn from the bigening to be expert in java script... Thank you...
You‚Äôre arguing a point I‚Äôm not making. Not everyone has the benefit of working on a team with clearly defined roles and separation of responsibilities. 
I agree, and I‚Äôm quite comfortable with JavaScript, I was just looking for opinions on the best framework to start with really. 
Well... node is a Plattform that can be and mostly is used as the backend-server. Angular/React/Vue are Frameworks for Frontend Tasks like providing a GUI to enter and display and bind data. In its core everything is Javascript. Even Typescript is javascript (+ static types) but needs to be transpilied done to js. 
Definitely. I love NodeJS and even frontend frameworks like React, but once it gets into the nitty gritty of CSS, and all that stuff, I can't stand it. In terms of frontend work, I'm more into dealing with state management and stuff like that (e.g. React/Redux). There's alot of work to be done in the frontend realm that does not involve working with stylesheets, div display types (block, inline, etc.), and all related stuff,
If you're on Node version 8 or above, I'd recommend using async/await instead of callbacks. You can use the try/catch syntax within an async function when calling another function with await.
+1 for Bulma. It‚Äôs been really straightforward and easy to use for my React projects. Also, [Bulmaswatch](https://jenil.github.io/bulmaswatch/) is a great and easy way to add themes to your app if you use Bulma.
I don't really dislike CSS and do love designing/styling stuff, but what really annoys me with working as a front-end engineer are all the browser quirks. Knowing them, thinking of them in the right moment and then finding (most of the time ugly/verbose) solutions that work in every browser.
If you use Sass for modularity and DRY, though, that output is absolutely worthless as production code in itself.
Yep. That's the way of doing it. All you need is the database and someplace to host it, plus some logic to break text apart into words and query the status of the words. &amp;#x200B; When I worked at, well, a large software company they had a tool that would scan the code and resources for any possibly offensive word or phrase in any major language. That had a big database. To give an idea of what it checked: a comment abut "nuking" an object was considered to be possibly offensive in Japan.
Ant Design
I'm the opposite, but I was a designer first and got into dev out of necessity. The part that users see and touch interests me much more than the plumbing that makes it work.
So node is just javascript that can run on a server, not just in a browser. Its used for backend scripting. Its analogous to php in that sense, but the functionality is very different. As for front end frameworks personally i recommend React. It lets you write components which are html (actually its jsx) and then you can reuse components with different data if you want. For example consider this component: const MyComponent = (props) =&gt; { return ( &lt;div&gt;{props.name}&lt;/div&gt; ) } You can then do something like this in a different component: return ( &lt;div&gt; &lt;MyComponent name="steve" /&gt; &lt;MyComponent name="jerry" /&gt; &lt;MyComponent name="sally" /&gt; &lt;/div&gt; ) You can also pass in children to components which have more components inside them. It makes it so you can write all of your code in one place and not have to switch between html, js files. Also note that youll want to learn babel, webpack, and es6 syntax. Its not 100% required for react, but its highly recommended because itll make your code cleaner and easier to deploy
It gives me the correct color codes though and that‚Äôs more than worth it for me. 
I‚Äôm a Director and hiring manager over front-end teams, and I have to pass on tons of candidates who literally only know JavaScript and a framework, maybe a dab of CSS when they absolutely must touch it, and can‚Äôt explain fundamentals such as the CSSOM. Let‚Äôs just say the alternative is designer armageddon because cookie-cutter CSS framework crap ain‚Äôt our thing.
That‚Äôs pretty much the only use that CSS output (in UXPin, which we use) that‚Äôs useful for my team. We get some Zeplin stuff from external creative teams and...same thing. At least it isn‚Äôt Photoshop.
Thanks for that link! Huh, so there simply is no interface support in (VS Code's) JSDoc :( And yep, I'm using this now and it works fine I guess, even though I'd have preferred not having to define a whole new type for `Window` :) /** * @typedef {{__forceFlag__: [boolean]}} GlobalFlag * @typedef {Window &amp; GlobalFlag} ExtendedWindow */ /** @type {ExtendedWindow} */ var w = (window), globalFlag = w.__forceFlag__; 
I really don't mind css because I've used enough to become very comfortable with it. It's a lot of learning and memorizing the cause and effect of css properties. If you use it enough, you're eventually going to memorize them. Beyond just learning though, having to maintain css can be on a scale from pleasant to nightmare depending on how it was written or what browsers you have to support. I feel like hating css is pretty common amongst developers, but maybe its just a vocal minority. If you dislike css because you're not comfortable enough with it/don't know the fundamentals, then a good way to get practice is to go to [dribbble.com](https://dribbble.com/) and recreate some of those shots in html and css. Keep a css reference and google/stackoverflow by your side when you need help. As an added bonus, you can put them on your codepen and link to them in your portfolio for employers to look at (I got my first job from this). Along with practice, I would recommend reading up on things like [ITCSS, SMACSS, OOCSS,](https://css-tricks.com/methods-organize-css/) and [other ways to make css more maintainable](https://csswizardry.com/archive/). I do love JS. It's a weird language, but I've spent a lot of time learning the fundamentals as well as the quirks to avoid. What's left is overall pleasant to work with. Really, it's the same with css. If you learn it and practice with it, it'll get easier over time. 
It‚Äôs 2018
I love css but js....üòú I can figure things out with js and I‚Äôve been improving but the modern frameworks I don‚Äôt know at all. 
You could do this: ``` setState({ parent: { ...state.parent, child1: someNewValue1, } }) ```
Yes I get that. I was just pointing out the silver lining, is all.
Here's a potential database you can use: https://github.com/dariusk/wordfilter
Yeah, that's a way of doing it. Storing a database of words you don't want, and then using regular expressions to match with text. 
Oh, okay. Cool. It can be hard to tell what some of these projects actually *do* by their project names sometimes... üòÖ
We essentially use a variation on your third example, but enforce every error to have a `code`, such as `user.invalid_username`. This lends well to translation and allows us to quickly add "new" error types whilst maintaining consistent error style and detection.
You are passing the data as a body to the request, but get only supports parameters in the url.
[https://www.youtube.com/watch?v=qi9VQqYcXqY](https://www.youtube.com/watch?v=qi9VQqYcXqY)
I think my \`type\` property is equivalent to \`code\`. How do you maintain the list of codes? Do you define them as constants and have an index of them somewhere? Or do you define them locally at the module level?
It's a very common thing and why stuff like CSS-in-JS and bootstrap exists; developers who don't enjoy working with CSS trying to turn it into something that they do; BUT, the good news is that *it's okay to specialise!* You don't have to be amazing at everything - [here](https://medium.com/@Heydon/reluctant-gatekeeping-the-problem-with-full-stack-e9ad836570f6)'s a really good article on it.
Angular
Numbers are perfectly suitable to teach this, using emojis doesn't add anything other than cringe
They're currently maintained per-application (we deploy a lot of micro-services), where each application has a config list of codes it's able to respond with. For applications with hundreds of codes, these may be split into separate files such as `user.json`, `billing.json`, etc. It's pretty crude, but it works really well and allows us to iterate quickly. 
there should be some basic math functions as min, max implemented, it would save a lot of media queries
buzzwords.js
You can just qickly try it in the console :-) If somePromise resolves, cb1 will be run, if it throws cb2 instead
My old employer keeps a pretty nice list of naughty words. Open source and all that. https://github.com/LDNOOBW/List-of-Dirty-Naughty-Obscene-and-Otherwise-Bad-Words
I think the move is still a good one, because you might set state in any number of different ways in the component, but your fetch is only called in one way. 
[This guy made a talking banana](https://www.youtube.com/watch?v=bJ5ppf0po3k). People started making it say bad things. Here he is talking about making and improving his potty mouth filter. Quite interesting video.
Wtf just send out applications. When you‚Äôre ‚Äújob ready‚Äù whatever that means you‚Äôll get one. You are a beautiful human person. Rest of the world are impostors. 
As a project lead, that sounds like heaven. By that I mean I‚Äôll be dead before I see it.
So you like having to write colons and semicolons, and you like taking every new css feature and repeating yourself by typing the vendor-specific webkit prefixes for them? And you don't like the ability to nest CSS?
I use prettier, so does nearly every decent front end dev I know so semi colons aren‚Äôt an issue. Just to clarify, all I said was that it‚Äôs possible that situations exist where plain CSS is good enough. I don‚Äôt know how that‚Äôs not a valid opinion. I‚Äôm also alluding to css in frameworks/libraries like react, where there are better options that use plain css and using preprocessors has basically been agreed upon as being the least ideal way of writing styles. People really took my comment a little too seriously lol. Pretty interesting.
Grid and Flexbox (and calc) are amazing. Made me love working with css. 
Safari is the new IE. 
Yes, I feel this way. I like *programming*, and writing the business logic of a client-side application in JS is fun to me. CSS and presentation is not. Doubly so if I have to make it work in IE.
I like styling things and playing with JavaScript, Css and jquery. What does less give me that I don't have natively? 
My designer writes code. He‚Äôs not a developer but he can script enough to wireframe and he build css for other devs to use. 
Actually, it's super aggravating that you guys are calling yourself front-end now and coming in and mansplaining how you have to "fix" CSS to me after I've spent so much time learning it. Glad you hate it, I guess? Not really, but I'm tired of hearing the bashing, I guess.
It's probably because you never wanted to work on that part of the stack, and now everyone's full-stack because of JS. Not everyone enjoys or is good at the design aspect of development. I just wish managements would understand this.
I recommend learning CSS and then implementing reusable components, and then you can one-and-done most of them.
I don't know about LESS much, but Sass gives you mixins, functions, nesting, etc. So many things. Some of this is now in native CSS with some support, but you can even use the new stuff inside of Sass and get the best from both. There's also CSS Next or something like that which is more like a Babel for CSS.
lol so many tough guys in the online dev community if you're loading css via webkit, like many of us do these days, then you don't need sass for the little files
i love preprocessors, but i mean, you can do much of this in modern css with a bit of postcss just to run autoprefixer and maybe some polyfills i barely ever need actual sass functions, mixins are nice but one tool out of many out there
We need different words now, because guys who hate CSS are now working in the client-side.
Nah everyone's full-stack these days, and you're an unagile person if you think it should be otherwise. So I'm told.
how very unagile of you /s i can bend myself into a pretzel and do the work of 20 people in 5 hours, horribly! i'm the agile-ist.
Not since display:grid became standard in early 2017. Now it's a breeze.
It wasn't a particularly big project, but a while ago I wrote this error creator that gives you a lot of control over when and how errors are called. It allows you to create categories of errors and modify them with specific details at runtime. Or you can pass strings instead of functions if you still need some more simple errors. ``` class ErrorFactory { constructor ({ message }) { this.message = message this._shouldWarn = true this._shouldThrow = false } set options ({ warn, error }) { this._shouldWarn = warn this._shouldThrow = error } get shouldWarn () { return this._shouldWarn } get shouldThrow () { return this._shouldThrow } get message () { return this._message } set message (message) { const messageType = typeof message if (messageType === 'string') { this._message = () =&gt; message } else if (messageType === 'function' &amp;&amp; typeof message() === 'string') { this._message = message } else { ErrorFactory._error(messageType) } } static _error (type = '') { invariant(false, `ErrorFactory: message arg must be string or function that returns a string, instead got: '${type}'`) } warn (...args) { warning(!this.shouldWarn, this.message(...args)) } throw (...args) { invariant(!this.shouldThrow, this.message(...args)) } } ``` And then we have a load different errors of different categories defined using the factory: ``` export const InvalidInterface = new ErrorFactory({ message: 'Invalid object given as Interface() property, must be a valid type() object.' }) export const InvalidType = new ErrorFactory({ message: ({ type } = {}) =&gt; (` Invalid type: '${type}' passed to type(). Must be one of 'number', 'object', 'string', 'symbol', 'function', 'boolean', or 'array'. `) }) ```
It's less "ew" and more "it won't change the fact that you need to learn CSS" in my view. And, I've seen horrible implementations of CSS-in-JS. It's got promise but is not at all a silver bullet. Also, I'm waiting for someone like Coyier or whoever to get behind one of the CSS-in-JS solutions. Someone who actually likes CSS and knows their chops really well.
They typically break the cascade in these apps. So, you isolate your CSS to the components using it, such that the CSS is written directly into the component's JS and then given a hashed class name in the browser. Components are then re-used like lego pieces. If you want to share some code between the pieces for DRY reasons, then you can use a theme provider or whatever. This is very much in React-land, though. You wouldn't do any of this for a basic blog or something simple and one-off.
VSCode is pretty good out-of-the-box for JavaScript development.
spoken like a genius who has no clue what real front-end/UI work is like
LESS is very similar to Sass, but is a strict superset of CSS (valid CSS is always also valid LESS). LESS is also a descendent of JavaScript, while SASS is a descendent of Ruby. If you‚Äôre using Vue/Angular/React, these distinctions don‚Äôt matter much since you‚Äôll be relying on components and the preprocessor tooling, while important, doesn‚Äôt require as much organization.
IMHO : you won't gain much more valuable experience by working alone on toy projects. Apply on jobs, you'll learn much more actually working in the field.
even when you write CSS-in-JS you are writing CSS, dude
this is hilarity on a whole other level
Front-end developer here. I‚Äôm responsible for all client-facing interfaces, including web server (since it defines the public facing APIs), publicly available command line tools, and, of course, the browser UI. On any given day I‚Äôll be writing JavaScript, Python, Go, or Groovy. Our backend devs do data science, systems engineering, network engineering. Would love to have a CSS/HTML specialist to work with who had solid design skills. At my company, that person might be called a frontend dev or they might be called a designer or they might be called any number of other things. I think you‚Äôre being downvoted because there‚Äôs not really a lot of significance in the distinction between frontend and backend per se anymore, since the lines are not cut consistently depending on company.
I hate JavaScript and really enjoy the css. If I could get out of doing js I definitely would. 
This is a great analogy, since great carpentry can look fantastic without siding or painting, and bad carpentry with great painting can make a piece of furniture look great in your home but not something you would ever want to use.
Judging on the post history, this guy is a troll. Mods should probably delete this post.
I was advised that Vue is better to start learning js frameworks with much better documentation. React is the most popular one now with so many tutorials. Node is the most popular in back end.
I find JS (or coding in general) far more intellectually satisfying than CSS. If I had to choose between only doing one or the other, I'd pick the coding side. But ultimately, all these React components people are writing boil down to the DOM - HTML and CSS. Without that, they're nothing. It would be nice to have HTML and CSS as purely implementation details completely abstracted away, but we're not there yet. The appeal of frontend to me is the mix of these two sides - the logical, intellectual coding side and the more subjective visual side. I think there are interesting challenges in both. CSS is a weirdly evolved mess, and has more aggravating cross browser bugs than JS, but in the end, if you really want to be an advanced frontend developer I don't see how refusing to touch it is doing yourself any favours. I find it surprising there seems to be a trend of people only wanting to write JS and considering themselves above getting their hands dirty - I don't think it's unrealistic to be adept at both.
I cannot agree more. Using a framework effectively means understand exactly what that framework is doing for you.
to me it seems like a database would be overkill. a simple word list check with indexOf would probably be more performant than making a whole bunch of transactions with a db server. 
Strong username and post connection:)
I'm the opposite. I'm a designer and love CSS but don't want to go beyond a basic understanding of JS. The shops I've been in that work best have a guy like me that can design and build a static, responsive site and work with devs to wire it up. Unfortunately, it typically leads to the mgr wanting someone that can design, be fluent in responsive builds, know React/Angular/Vue/Node, yada, yada.
Here's the thing. When you care about a project, when it's your own personal website, when you are personally naming every .class name, and you are using SASS and LESS for extremely elegant mix-ins for your design, putting together a stylesheet feels like painting, animation, writing poetry, making music. But try painting a painting with five other people at the same time. Imagine Justin Roiland and Dan Harmon screaming at each other drunk off their asses trying to make Rick and Morty (enough to delay them nearly half a year). Axl Rose can't even stand to be on the same part of the stage as Slash, it's a miracle they even got together for a reunion tour. CSS is fucked when you have too many cooks in the kitchen. Where CSS blows up is when multiple front end devs are working on it, each with different naming styles and conventions, some guys like multiple properties per line where it makes sense while others want everything strictly vertical, there are going to be horrible nesting hacks for specificity issues meaning everything is going to be tangled in a giant mess of curly bracket closures, invariably you'll start getting more and more SASS files each more vaguely named than the last "nav.scss", "ui.scss", "layout.scss", then some guy decides to start writing in-line styles in the HTML, or maybe upper management wants to start migrating to React and then rogue CSS starts cropping up in the JSX components, or even if a dev had the discipline to write neat, tight SASS mix-ins that cover lots of elements of the webpage, it all gets unravelled when the designer suddenly decides he wants the "grey box" which otherwise is exactly 40% of the screen width in every single instance to be juuuust a little wider here, and juuuuust a little thinner there, and maybe juuuust a little wider over there but not as thin as back there, and juuuuuust a... you know what, let's redo everything I just had an epiphany, we can make this look so much better. Then a debate starts and parts of the CSS gets commented out because Designer A thinks that the vibe should be a more gothic, heavy, serious, grounded theme with some GRAVITAS, you know, how will people take our product seriously otherwise? But Designer B thinks we should keep it fun and light and bubbly and go with a breezy, "ethereal" palette. Then the marketing manager starts asking for design changes based on user analytics, and you better TAKE the marketing manager seriously because unlike Designer A and Designer B what the marketing manager is asking for is grounded in HARD SCIENCE and BIG DATA. And then of course the CEO who should otherwise be standing tall about the weeds shows the app to his five year old daughter and she demands that the team change the entire fucking color scheme to baby blue, despite the protests of Designers A and B who are screaming "why are we doing what Twitter and Facebook are doing?!" You know what the real problem is? The real problem is dysfunctional companies of desperate tech professionals cobbled together in cities with way too expensive standards of living all trying to meet impossible deadlines to push insanely ambitious projects so we can all cash off on that unicorn and become billionaires not having enough time to just chill, sit at home, crack open our own personal solo open source projects, and just design beautiful wireframes, and commit beautiful code.
I love CSS and JavaScript both. There are times now things I used to do with JS now can be just achieved with just CSS
https://www.reddit.com/r/ProgrammerHumor/comments/4wq1mw/jquery_does_all_things/?utm_source=reddit-android
Rehux - React state management made simple [https://github.com/djyde/rehux](https://github.com/djyde/rehux)
it really depends on what you want to do but do note that all node does (summary) is it lets you run javascript on the server/desktop and not the browser. it also lets you use `require` which is just a fancy way to import other code. nodejs also lets you do other lower level things such as file management and network and http servers (with no cross origin problems) in general, i would say learn a tiny bit of node js, and check out some of the tools and libraries you can install with npm. npm is just a tool to install other javascript code from the internet (you can also publish your own code). almost all javascript libraries and frameworks are available through npm. once you learned how to use node and npm you could try out webpack, which lets you bundle multiple files into a single file, and use a similar import/export system that node.js does. with this you can also bundle together your code with code from npm, and apply transformations (for stuff like importing css files and stuff) you could then try to explore react or some other front end framework. i have tried react and vue and those two are great (angular is probably good too but ive never used it). with react, you get to write html components in your javascript, and theres some extra javascript syntax (called jsx) that they made to make writing it feel like writing html. you cant run this code in the browser directly, but can transpile that code with a tool called babel, which can be mixed with webpack too (this is why i said to check webpack out). whats also cool about react is you can make reusable components, which can also do fancy logic and state and such, and reacts to when your data changes. it handles a ton of behind the scenes stuff very nicely as well. - now at this point im not really sure what would go next, as theres tons of options, and im skipping over a ton of the actual work it is to learn all these tools, libraries and frameworks. ok well what originally was going to be one sentance turned into... that
answering question: none of them are based on typescript, but i think angular did something with it (someone correct me here)
I usually do this with functional setState: ``` setState((prevState) =&gt; { return { parent: { ...prevState.parent, child1: someNewValue1 }, ...prevState } }); ```
that would be something kind of interesting, a way to make a variable watch the right side. (sort of what vue does in a way)
Do people really see needing _semicolons_ as that big of an issue? Don't get me wrong, I cut my teeth on Python, but I mean, really? I'm seriously not trying to be condescending here. It just seems baffling to me that software developers would see needing semicolons as some huge inconvenience.
I love JavaScript, and have a love/hate relationship for CSS. **What I hate about CSS:** 1. **When designers design without CSS and DOM in mind.** Sometimes I find that I have to do something completely hacky to actually make the designer's design work with CSS. However, this just requires effective communication and persuasion to the designer that it is not a standard. 2. **When the css rule works in one browser, but the css rule doesn't work on another.** This can be said with JavaScript too, though. 3. **When we have to deal with weird quirks, such as antialiasing.** [https://stackoverflow.com/questions/6492027/css-transform-jagged-edges-in-chrome](https://stackoverflow.com/questions/6492027/css-transform-jagged-edges-in-chrome) [https://stackoverflow.com/questions/31109299/css-transform-translate-50-50-makes-texts-blurry](https://stackoverflow.com/questions/31109299/css-transform-translate-50-50-makes-texts-blurry) 4. **(Global Scope) When dealing with other libraries that pollute the global scope and insist on base font styling.** This causes a lot of overrides and the word, !important when laziness comes into mind. This is where CSS-in-JS, CSS Modules come into mind. 5. **When realizing that normalize.css** **is needed to maintain consistency across browsers**. If only CSS was normalized to begin with across all browsers, but can't really fix the past... 6. **Floats and hacks with floats**. Thank goodness for Flexbox / CSS Grid. 7. **When positioning doesn't work the way we want it to.** [https://stackoverflow.com/questions/44446671/my-position-sticky-element-isnt-sticky-when-using-flexbox](https://stackoverflow.com/questions/44446671/my-position-sticky-element-isnt-sticky-when-using-flexbox) [https://stackoverflow.com/questions/2637058/positions-fixed-doesnt-work-when-using-webkit-transform](https://stackoverflow.com/questions/2637058/positions-fixed-doesnt-work-when-using-webkit-transform) **What i like about CSS:** 1. Flexbox / CSS Grid. 2. Reusability of CSS classes across elements. 3. The fact that there are tools like PostCSS, SASS, CSS Modules, CSS-in-JS to make CSS not something to hate completely. Hopefully one day our technologies with CSS will allow us to just make the app come alive given a design - not deal with browser quirks and scope pollution. 
you can just screenshot and get color codes from photoshop or im sure as you know in dev tools if it exists on a current site
Of course, but that's no different than say, SASS. It just removes a lot of the pain points involved in CSS.
You don't need a library. Since everyone is giving you bullshit answers I threw this together for you. Just adjust `AUTO_SCROLL_SPEED` to make it scroll faster or slower. https://jsbin.com/wasuvedigu/edit?html,js,console,output
Inspect outback steakhouse page for a nice list.
I‚Äôm aware, but the designers at my company use zeplin for mockups already anyway, so it‚Äôs already gonna be open when I‚Äôm building from their specs. 
gotcha
Which color scheme?
Shades of Purple by Ahmad Awais https://marketplace.visualstudio.com/items?itemName=ahmadawais.shades-of-purple
 let frustration = 0; while(true) { frustration += mouse_movement; }
React &amp;#x200B;
mJS runs a subset of JS for embedded projects: [https://github.com/cesanta/mjs](https://github.com/cesanta/mjs)
It's hell, but now that browser compatibility isn't much of an issue, it's better. Still feels like insanity trying to align things right though.
I currently use Zeplin, and as a front end developer it is in the same boat as getting PSDs. If the only saving grace of your application is that you get hex codes, it isn't much better than Photoshop. IMO, it is even worse than PSDs because it has some lame always online feature which is terrible.
Less is amazing now. Has all the features of every other preprocessor afaik. And it's completely compatible with regular CSS, so porting is a non-issue.
No. CSS is like creating a Turing machine to do the painting for you.
I think you're missing this script which controls the date picker div: `&lt;script&gt;` `var inf_custom_TentativeDateDatePicker = new Pikaday({container: document.getElementById('inf_custom_TentativeDate_calContainer'),field: document.getElementById('inf_custom_TentativeDate'),format:'MM-DD-YYYY'});var inf_custom_TentativeDateIcon = document.getElementById('inf_custom_TentativeDate_img');inf_custom_TentativeDateIcon.addEventListener('click', function(){inf_custom_TentativeDateDatePicker.show();});` `&lt;/scritpt&gt;` &amp;#x200B; You'll most likely have to adjust the IDs accordingly.
It's more like loving carpentry, but hating finishing and staining the wood afterwards.
Not an expert but quickly looking over the site, the staging website is missing the script code for the date picker under the "pikaday-container" container. Hopefully this helps. 
Angular with material can get rid of a lot of css headaches.
Why sass over less?
You mean Webpack? I mean yeah, I get you but the delineation between a preprocessor and Webpack is somewhat arbitrary given OP's argument
Yeah I'm trying to use vue with either vuetify or materialize. My company has projects in angular and react but all new projects are being made in vue.
given the meat of OP's argument I don't think the distinction between PostCSS and a preprocessor is substantial but you're correct. I will say that I use mixins and functions extensively and they save us a lot of time.
It will take our jerbs!
Hey, Thanks for your reply however I can't find a difference with the code in what you are referring to. Here is the code from view-source:https://staging1.teambuildingmadeeasy.com.au/contact-form-sample/ (working one) &lt;div class="pikaday-container" id="inf_custom_TentativeDate_calContainer"&gt; &lt;/div&gt; &lt;script&gt;var inf_custom_TentativeDateDatePicker = new Pikaday({container: document.getElementById('inf_custom_TentativeDate_calContainer'),field: document.getElementById('inf_custom_TentativeDate'),format:'MM-DD-YYYY'});var inf_custom_TentativeDateIcon = document.getElementById('inf_custom_TentativeDate_img');inf_custom_TentativeDateIcon.addEventListener('click', function(){inf_custom_TentativeDateDatePicker.show();});&lt;/script&gt; &lt;/div&gt; and here is the code from https://staging1.teambuildingmadeeasy.com.au/team-building-activities/charity-billy-karts-for-kids/ (the non working one): &lt;div class="pikaday-container" id="inf_custom_TentativeDate_calContainer"&gt; &lt;/div&gt; &lt;script&gt;var inf_custom_TentativeDateDatePicker = new Pikaday({container: document.getElementById('inf_custom_TentativeDate_calContainer'),field: document.getElementById('inf_custom_TentativeDate'),format:'MM-DD-YYYY'});var inf_custom_TentativeDateIcon = document.getElementById('inf_custom_TentativeDate_img');inf_custom_TentativeDateIcon.addEventListener('click', function(){inf_custom_TentativeDateDatePicker.show();});&lt;/script&gt; &lt;/div&gt; These look exactly identical to me - unless I'm mising something? 
And now you fear every corner you turn you will run into IE
Hi, thanks - but I can't see the difference between the two versions of code in that section. Can you elaborate?
I tend to write errors as exceptions, based on frustrates me to no end during development - bad runtime arguments. Seeing `cannot read property foo of undefined` makes my skin crawl, especially in the context of Angular, where you get no useful information what-so-ever about where the error occurred (Angular stack traces are basically a circus). So 99% of the errors I raise are `InvalidArgumentExceptions`, and I fill them in with as much information as I can possibly collect about what might go wrong with bad input into a function. In the error I include what data type I *expected*, what *value* I expected if applicable, what value and type I actually got, what "context" it was meant to apply to, and what context it was called within. I just assume that Webpack/Angular is going to completely eradicate any semblance of traceability to that error, so I make sure to include when the exception is raised. Then my error handler just catches those exceptions and displays an "Oops, something went wrong" error to users, and if debugging is enabled in the local environment, those exceptions are allowed to show up in the console (else they are recorded by a monitoring service). Any other kind of error (e.g. things that are not exceptional situations), are generally handled by return statements or actual business logic structures, rather than as exceptions (since by definition, they are not exceptions). So basically, my application is either 99% `InvalidArgumentExceptions` with loads of detail as to what went wrong, or standard user errors from say, bad input or what not. 
Welcome to the web. Where backwards compatibility constraints mean we're stuck dealing with the cruft of short-sighted design decisions. I mean, the fact that everything is namespaced globally in CSS should tell you everything you need to know. And if anyone tells you to learn to love the cascade, I swear to god, RUN!
How to increase frustration 100 fold: interrupt the user with a popup saying you've detected that they might be frustrated.
Fcuk Fack Fffck Phuck Basically, a dictionary is useless. 
I have to say, agree or disagree, that was hell of a rant. I‚Äôm impressed...
Well, there is still lots operations in tasks that will be async tasks, like fetch some json data from some server, execute some external commands. Here is an example, before you publish a npm package, you want to test it, build it and generate the API documents, these tasks are all based on executing external commands, and independent, to speed up, we can simply write tasks like this: \`\`\`ts task('preversion', async ctx =&gt; { await Promise.all(\[ [ctx.run](https://ctx.run)('build'), [ctx.run](https://ctx.run)('test'), ctx.run('generateDoc'), \]) }) \`\`\`
Did web development for a few years and really thought CSS was okay, then I started working on app design using Swift. It was like a breath of fresh air having a simple x, y coordinate space to work with. It felt like a foreign concept being able to express in direct, simple terms where I want a thing and have it always work. I get that there are newer tools to alleviate some of the hassle, but at its core, HTML and CSS are pretty ridiculous. Having to use three unique languages to build even the most basic website is counter productive to say the least. I like the idea of being able to write the code that makes a thing work, and the code that defines the thing visually in the same language, at the same time.
I don't mind CSS at all. I've been using it for so many years that nothing's really a curveball anymore. I look forward to solving problems with CSS. For instance last week at work I built a circular progress bar in CSS (Less, technically). It's been something I've wanted to solve for a while and finally a feature came up that needed one.
When I go to inspect the non working webpage with Chrome Dev Tools I don't see the script showing up anywhere (I did a search and found nothing related to the script). When I check the working site, I see the script under the "pikaday-container". Do you have the scripted listed in a js file somewhere now versus in the HTML itself? Possibly not linked to the webpage?
Make sure there is no dismiss button, just a small off-white on white x in the left(!) top corner
Hi, that's interesting. When I do 'View Page Source' through Chrome both the non working and the working version have the same script code. Not sure which script you are referring to - there is an external link to an outbound .js file for the pikaday ui element at the start of the form - but there seems to also be some inline JS. I'll check the Inspect element and see if the script doesn't come up on the non working one in there. 
I used to hate CSS. So, I made it my mission to attack and get a way better understanding. After a lot of frustration, I like it a lot now! (Because it does what I want more when I understand it)
Not at all uncommon. CSS is a deceptively tough language. It's very easy to write CSS, but it's very difficult to write CSS that can be easily maintained. FWIW, I actually quite like working with CSS. I'm quite comfortable with it and the process of building up each component is like... artwork.
I don't hate CSS, but I'm definitely starting to prefer the CSS-in-JS approach. 
You said it. Worst is a client that says something like, I already have the design. So they do, but it's a thing that doesn't have much resemblance to the real world. So you get stuck in this "relationship" that breeds contempt. You become an educator that consumes hours and you have to absorb that very real cost.
More likely it's UC Browser. IE, which means IE 11, can be handled pretty easily, but you dread the client that needs UC support.
Hello. The webpage that is working has an inline script right under "pikaday-container" class container. It's the same script LollipopPredator posted. Hopefully that helps. 
And clicking it will show a confirmation popup that asks you if you actually want to close it
Use SASS. ALso SASS &gt; LESS
Hi, Not sure what you mean - both pages look to have the script to me. I've created a video to show what I mean: https://cl.ly/40abe4f7a024/Screen%252520Recording%2525202018-12-10%252520at%25252005.53%252520PM.mov This is from these pages: view-source:https://staging1.teambuildingmadeeasy.com.au/contact-form-sample/ (working) view-source:https://staging1.teambuildingmadeeasy.com.au/team-building-activities/charity-billy-karts-for-kids/ (non working)
Just realised that video I shared doesn't have audio but you can see both scripts underneath the pikaday-container class div.
&gt; I think you‚Äôre being downvoted because there‚Äôs not really a lot of significance in the distinction between frontend and backend per se anymore Being able to write decent markup and CSS is the distinction.
if it's a website, ok. if it's a webapp that needs years of support and new features then it's perfectly normal to have frontend engineers taking care of architecture and business logic only. 
Interesting. Here is what I am seeing. working - [https://i.imgur.com/an7Yl10.png](https://i.imgur.com/an7Yl10.png) non working - [https://i.imgur.com/X0ED79D.png?1](https://i.imgur.com/X0ED79D.png?1) I am not sure why I am not seeing the script on the no working side
Ah yes, look at that! üòä That looks like a useful case for this type of system. Thanks for the clarification!
Nice. I still miss Flex, such a great, well-thought-out and well-documented framework. I‚Äôd pay good money for a multi-platform re-implementation of the Flash display list tied to V8 instead of Tamarin. 
Is `new Function` disabled, too? If not, you could make this work. Then, you could use esprima (or espree, or whatever is best now) to parse the js and then find the object. Just don't try regex + JSON.parse unless you're looking for trouble.
JSON.parse
I hate CSS. It's a huge factor in dropping projects because the hours upon hours of trying to get the css to work sensibly makes me want to tear my hair out. Sure, if you're doing just a normal site then you can just drop in bootstrap or one of the others, but if you want to make an interface (for an application, etc) you'll have to do a ton of custom css and styling and solutions that just make me want to tear my hair out. The basic idea of 'this is a box, theres margin and padding and the such around it of varying levels' is fine, but anything beyond that just grows into something that makes me want to just create a canvas element, figure out how to resize it to fit the screen properly without scrollbars, and then just design the UI entirely in canvas. I'd love it if I could learn it, because then there would be far less personal projects dropped because I couldn't get something to not wrap to the next line, or other annoying issues.
This was the first thing I tried. It doesn't work.
What was the error that came back?
I really thought this would work (unless I am doing it wrong) &gt; esprima.tokenize(myString); &amp;nbsp; This is the output I get :( https://i.imgur.com/qnn7mbq.jpg 
&gt; SyntaxError: JSON.parse: unexpected character at line 2 column 3 of the JSON data
Four random follow-up thoughts: - I enjoy promise-based route wrappers a great deal. - Why don't you use error-handling middlleware? Won't json parsing (compression, any external middlleware) crash with a standard HTML error response? - Doesn't native await + try-block come with a masdive performance hit? It did last time I checked (real app benchmarks, not some synthetic stuff) - I also like monkey-patching express responses to add formatters in a global middleware, as in `res.err = err =&gt; res.status(err.code).send({ err })`
It's nice of you to link, but holy crap is that list silly. Blacklisted `crazy`, and `insanity`, missing `shit` and `fuck`. Meaning `this is the very definition of insanity` would get a mark - but `fuck you, you piece of shit` wouldn't.
css need time to fix.
Can you access the window? If the object is already exposed at window._configData so just grab it from there?
I love both. Maybe it is because you sux at CSS \^\^"
I can't continue following up right now, but... It seems like everything "executes correctly" but then some other script is cloning some parts of the page to re-paint them. When cloning events are lost. It is _probably_ Masonry, which is used on the second template but not on the first. You _could_ try delaying the execution of the set-up of the _Pikaday_ stuff until _after_ Masonry has done its thing.
The underlying functionalities maybe, but the way you apply it is still in the JS way.
Useless provoking replies are not welcomed, it's not a teenager chat.
Yes, that's tokenized ‚Äî you want `esprima.parse` (see the [demo](http://esprima.org/demo/parse)), which gives a nice syntax tree. You can find the object you need, then escodegen it back. Dirty and overcomplicated, but that would work and be relatively safe. The blocking of eval makes sense if you think about it ‚Äî you want to run random third-party code in with privilleges, allowing for great exploits both by yourself and random people with script tags. What exactly are you trying to do there? You might go with `window._configData` read as the other comment suggested, or embed raw JSON into a webpage, or expose it on a separate endpoint.
\&gt; Why don't you use error-handling middlleware? Won't json parsing (compression, any external middlleware) crash with a standard HTML error response? I do use it. It's errors() method from Celebrate and as long as you use enhanceHandler higher-order function you shouldn't get any HTML response. \&gt; Doesn't native await + try-block come with a masdive performance hit? It did last time I checked (real app benchmarks, not some synthetic stuff) Can you provide a source? To be honest, express itself is not the fastest framework out there but the real bottleneck in web servers are related to data processing, file system access, database queries and aren't solved by tinkering over usage for..in over for..of, callback over promise etc. \&gt; I also like monkey-patching I don't. It's very imperative, harder to type/requires constant checks and guards to use it with TypeScript.
1. A complete list would take up a lot of memory 2. You don't need to do more than on DB transaction per block of text
I am download the entire page then parsing the HTML. 
Oh yeah. This works. That syntax tree though. Do esprima offer a way to search? The extension downloads an entire page, parses the HTML then gets the script tag with the _configData object. That object contains dates, prices, ids etc that I need. 
Ah, yea, I'm using Chrome.
I was very frustrated with browser support too. My (no) solution was slowly transition to a younger client base. Bye bye Opera 45 and IE8 
&gt;This is a word filter adapted from code that I use in a lot of my twitter bots. It is based on a list of words that I've hand-picked for exclusion from my bots: essentially, it's a list of things that I would not say myself. Generally speaking, they are "words of oppression", aka racist/sexist/ableist things that I would not say. &gt;The list is not all-inclusive, and I'm always adding words to it. If you'd like to file an issue or a pull request to add more words, please do so, but understand that this is primarily for use in my own projects, and I may not agree to add certain words. (For example, I have no problem with scatological words, so "shit" and "fuck" will never be on this list.) This isn't really a profanity filter so much as it's the author's personal offensive language filter. It just so happens that a lot of it is also profanity. 
I like js, but having to support ie makes me die a little inside! 
Nice - thanks. I'm not sure exactly how I would delay the pikaday execution stuff until after masonry has done its thing (not sure what masonry is but will research when I'm in front of the computer) 
I get you man. I started doing all my styling in material-ui for my react projects purely so I could write my styling in Javascript (stupid psychological trick but I‚Äôm falling for it) in stead of having to make a CSS file for every single component. Probably have to get back into CSS if I want to style anything outside of react. :(
Got you. Thanks. Looks like the chrome property inspector will have to look into it later. Chrs 
I meant you can use CSS-filters on move. Also masks would be interesting to add. Thx!
A absolutely ~love~ the front-end of CSS and everything related to it. If my programming doesn't have a visual end-result that is a measurable improvement to end-users (and fun to make!) then I get bored easily. Recent jobs have tested my patience with "dev/ops" roles (mostly "ops") where configuring Docker and Jenkins were the #1 responsibility. Then in 2nd place came Javascript. And the front-end? That was an after-thought at best. It was horrible. I love good UX supported by beautiful UI. And I love the fact that designers don't know how to make it interactive, and I breathe life to their creations. They create dead bodies, back-end developers make sure all the bodily parts function as intended, but *life*? I give it life. 
Nicely spotted. I don't understand why you get downvoted. To me it is a valid question. Turns out myVar++ returns the original value of myVar and not the updated one. Keep on coding!
Will try to expand on that later, but as a last resort you could try using `setTimeout` to set up the datepicker.
**Oh noes!** I posted `''sdfgnk h` as the body, and got an HTML response. Fair enough, since the error is thrown by `bodyParser`. You'd have to wrap every middleware with enhanceHandler ‚Äî not optimal. &gt; I don't. It's very imperative, harder to type/requires constant checks and guards to use it with TypeScript. It's good for gradually migrating legacy projects with ad-hoc formatting, though. To make it work with TS, you just extend `Response` and use it explicitly in your handlers. &gt; Can you provide a source? My bad, just ran the benchmarks and it works fine. My doubts stemmed from evaluating some promise middleware on npm some time ago, and it was like +10-20ms per request, which is a big deal. Node is often used as a smart proxy, and in that scenario you want to avoid adding latency on top of what you have.
perhaps use JSON.parse() to extract the object from the string: ``` let json = document.body.children[1].firstChild.data .replace(/\s/g, '') // strip whitespace .match(/.*=(.*);/)[1]; // extract JSON let configData = JSON.parse(json); heading.innerText = configData.config.uuid; ```
hmm... never done this before but checked out the function. Any further input would be much appreciated. Thanks!
That is not at all guaranteed to give you accurate results. 
Just a load of little things. The form labels on inputs use that animation where the label animates above the input when focussed. If a user auto fills the form, the inputs still stay inactive. They have a breakpoint object attached to the Vue instance ($vuetify.breakpoint). It returns booleans at different screen sizes so can be used for things like adding classes. It doesn't work on initial load... So their breakpoint system is broken out of the box. Which I find completely unacceptable. Further to that, their dumb grid system can't handle 5 item columns. And lord knows your client will want 5 item columns at some point. That's just a few off the top of my head but there are quite a lot of them you notice when you work with it.
As a working hybrid of over 10 years, this makes me sad. BUT, as a creator of a system that encourages designers to learn code (through visual association) and encourages front-enders to think like designers to keep things both DRY and modularized *before* a project starts, this gives me hope. (Not a shameless plug, bit more a shameless tease lol)
I think you have all knowledge you need, but you're get lost by overthinking. A few advice. 1. There is a start() function. start() Den f√∂rsta funktionen som k√∂rs. 2. Use your update() function just for reading key press. 3. I made a tiny [example](https://koda.nu/labbet/75335561). 4. Start with a clean sheet.
Css is going into an odd direction for sure, for instance dependency injection for everything ("css variables" ... why???). With houdini it gets even more bewildering, "script worklets". Each and every little feature takes 5-10 years to proliferate, most of it is not backwards compatible. Thank goodness javascript is breaking free from archetypes altogether, crazy vendor specs simply don't matter if no one's using them. A first step is css in js which takes care of the more obvious spec decisions that are wrong.
Most designers can't write good CSS 
I can't really give you any advice about how to solve your problem, because I have a hard time following what is actually happening. I can however give you some general advice, so that next time you ask for help they don't start pulling their hair because they can't read it. - All variable and function names should be english. Don't use swedish words and letters. - Use camelCase for variable and function names. IE showScoreSwitchBef instead of showscoreswitchbef. - Don't shorten the variable or function names. IE brytsuc should be brytSuccess, except for the fact that that is swenglish. - Learn EcmaScript 6 as soon as you can. const, let and fat arrow functions to start with. - Learn, live and breath the [DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself). By that I mean, for example, you have several different switchlvl functions. You only need one and then send in the number of the lvl as a parameter. This makes the code smaller and more readable. Lastly, it seems that this uses some kind of framework. Probably from Koda? There are serveral functions such as clearScreen and picture that is not in the actual file. Which means there's a lof of "magic" going on in the background. This makes it a lot harder for us to help you.
Have you ever heard of **Web(PHP)Storm**?
That's my 5 tons hammer * { box-sizing: border-box; } 
Not in client-side JS. If you are building a NodeJS app, then yes.
&gt; and now everyone's full-stack My staff isn't full stack. Yuk. I need people who kick-ass doing front-end stuff and people who kick-ass doing back end stuff. The breadth of the stack each of them need to deal with is mind numbing and I find it completely stupid to think one person could have a decent mastery of all of everything.
Is this not just intellisense/autocompletion/argument-hinting? How does it differ?
It is more contextual intellisense I think. So the suggestions when returning from a function are different than the if conditional, which are in turn different from inside the block of code inside that same conditional. Basically ‚Äúwe used machine learning to figure out how people tend to write code‚Äù vs ‚Äúwe put in an alphabetical list of everything you can do with a variable of a certain type‚Äù
‚ÄòBEFORE A PROJECT STARTS!!!‚Äô I‚Äôd be happy with a colossal screen and speakers on ever campus on earth that trains coders and dickhead-Luddite-directors. 
Lol I feel that pain, too. Hope the day is/was good to you in spite of it all. (Cheers)
you assume the list of profanity is much larger than the string to be filtered. I assumed the opposite. if the filter string is fairly large that will consume quite a bit of memory as well -esp if you're sending the whole string in a single query.
Weird. You're using npm or yarn?
Do you really need JavaScript? Some other languages like Julia may be more appropriate.
Nice! Seems like it should be the default. 
Build your own, then throw it away. Otherwise I'd probably pick Vue - it's a really nice developer experience. If it's a career choice, go with React, Redux &amp; Webpack.
I‚Äôm sure a PhP developer knows more about UX than the HCI researchers cited.
&gt;What does less give me that I don't have natively? Mostly the comfort of having to type less, because of mixins and nested selectors. Your CSS looks way better and is a lot easier to understand and follow when using mixins and nesting correctly.
The idea is this: You _now_ have this code just after each calendar: &lt;script&gt;var inf_custom_TentativeDateDatePicker = new Pikaday({container: document.getElementById('inf_custom_TentativeDate_calContainer'),field: document.getElementById('inf_custom_TentativeDate'),format:'MM-DD-YYYY'});var inf_custom_TentativeDateIcon = document.getElementById('inf_custom_TentativeDate_img');inf_custom_TentativeDateIcon.addEventListener('click', function(){inf_custom_TentativeDateDatePicker.show();});&lt;/script&gt; Well, then, you would wrap it in this manner: &lt;script&gt; $(document).ready(function() { setTimeout(function() { var inf_custom_TentativeDateDatePicker = new Pikaday({container: document.getElementById('inf_custom_TentativeDate_calContainer'),field: document.getElementById('inf_custom_TentativeDate'),format:'MM-DD-YYYY'});var inf_custom_TentativeDateIcon = document.getElementById('inf_custom_TentativeDate_img');inf_custom_TentativeDateIcon.addEventListener('click', function(){inf_custom_TentativeDateDatePicker.show();}); }, 2000); // [**] }); &lt;/script&gt; Notice though a couple of things: 1. This is using jQuery. This is not a problem since you are already loading jQuery on the whole site, but just keep it in mind. 2. See that `2000` in the line I marked with `[**]`? That means the delay is 2 seconds (2000ms). You _may_ have to adjust that a bit. You may lower it probably to about 1 second (`1000`), but in any case, I doubt anyone is going to load the page and rush to use the datepicker, so a small delay should not be noticed too much. 3. But of course this is just a _kludge_. I cannot offer a more solid solution, since a lot of different things seem to be interfering on this. Alternatively, in time, you _might_ want to consider redesigning your Wordpress theme and templates so that they _don't_ use Masonry. ([Masonry](https://masonry.desandro.com/) is a JavaScript library for doing certain "grid based" layouts. Sometimes it can be easily replaced with a very approximate layout done with just CSS. In your case, I don't see anything that _really requires using Masonry_, though removing it, will, of course, imply some work.)
Thanks.
To be frank, anyone who actually considers themselves as *full-stack* shouldn't exactly be getting tripped up by style sheets.
I am definitelly not an expert, but AFAIK it is webpacks job to decide which packages are neede and in which order. You should not so it manually unless you have some very special requirement
Oh right. I guess that would be useful, somehow. Just hard to see from the gifs and that üòÖ
Yeah you're right I definitely am.
Yep, but some of these libraries are so old that they don't expose any functions and should be tied to window / globals. 
Not saying its the best, just that I worked on it a while ago and it's still in development: [https://www.npmjs.com/package/vectorious](https://www.npmjs.com/package/vectorious)
Yes, writing css or any styling is an absolute chore and not fun in any way. IMO
Using Yarn. We found npm kept failing to fetch packages intermittently through Travis for some reason.
https://en.m.wikipedia.org/wiki/Scunthorpe_problem
This is that pure juice. Thank you.
How can I learn advance stuff in webpack ? 
Yes, use JSON.parse but why strip whitespace? JSON doesn't care about whitespace and if there are whitespace in strings it will mangle the data.
I enjoy front and back end equally, but sometimes prefer one over the other. Also I'm the only one working on my project so I have to do both.
It basically shows up as an array of arrays so you can query it like: var volume = obj["Global Quote"]["06. volume"];
Use `blur`: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/blur Or you could listen to the `event` on either keypress or submit and see what key was pressed. If `event.target` was the 5 key then you could prevent doing the calculation.
In the keyboard event handler, if the pressed key is ENTER, call the event object's `preventDefault()` method.
I tried this also, but it's returning the following: `TypeError: Cannot read property '05. price' of undefined` `at alphaVan.get.then.response (/Users/harrycondron/developer/alpaca-trading-bot/index.js:63:46)` `at &lt;anonymous&gt;` `at process._tickCallback (internal/process/next_tick.js:188:7)`
It sounds like your obj doesn't actually contain a key called "Global Quote" - could there be an additional layer in there? Try looking at the object in a debugger, or doing a JSON.stringify(obj) before you try and access it.
When I try to log `obj ["Global Quote"]` it returns undefined, I've tried using the debugger but for some reason my objects aren't expanding [(‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÔ∏µ ](https://knowyourmeme.com/memes/flipping-tables-%E2%95%AF%E2%96%A1%E2%95%AF%EF%B8%B5-%E2%94%BB%E2%94%81%E2%94%BB)
Hey, that's pretty good!
Your comment reduces down to this: "Individual users couldn't possibly know what they want. Only HCI researchers know what they want". The fundamental flaw in your logic (aside from the ad hominem fallacy you used), is that you assumed I'm approaching this from the perspective of a developer. Maybe adjust your thinking and realize that I'm a user who has used enough interfaces in my life that I *fucking can't stand interruptions, and when I'm already frustrated, interrupts push me over a cliff*.
Actually I think you just didn‚Äôt read the research. A dialog box is never proposed anywhere. Users absolutely know what they want, they just don‚Äôt know what they need.
try just logging obj My guess is your call to download the feed isn't responding what you actually expect - maybe you're getting an html error message back instead (i.e. wanting you to sign in before you download the data)
Are you sure that you want to JSON.stringify(response.data)? Maybe JSON.parse(response.data)? 
The response is already parsed so that would throw an error
Thanks for the tip, the blur function works for me.
 console.table(obj)
&gt; data = JSON.stringify(response.data) &gt; console.log(data ["Global Quote"]["05. price"]) I don't get it. Why are you converting a object to a string?
You're right! There's no need to convert it to a string, and trying to access the obj when it's stringified throws and error. Slow day at the office... &amp;#x200B; Thanks for your help!
&gt;I am using uglifyJS task to load an array of bower and npm dependencies and bundling them in the right order. Same as I would put them in the index.html via &lt;script&gt; tag. webpack does this for you, you don't need to do this. &gt;How I am supposed to tell my app / webpack that I need these libraries loaded before my main app.js file? I think you need to look at: https://webpack.js.org/configuration/externals/ &gt;The externals configuration option provides a way of excluding dependencies from the output bundles. Instead, the created bundle relies on that dependency to be present in the consumer's environment. This feature is typically most useful to library developers, however there are a variety of applications for it.
Hi /u/LingDynasty, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/tibi_co, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/porocode, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/chandu_nainala, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/christine1226, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/DatOneChikn, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/magenta_placenta, this post was removed. If you'd like to post a link, then please use the "Submit a new link" option. If there is additional commentary or links you wish to add, please do so in a comment. Thanks for your understanding.
I did something very like this last year. We had a Require.js-based setup that I converted to Webpack. Long story short, it involved setting up a bunch of aliases and custom loaders, mostly with use of `imports-loader` and ` exports-loader` to either make certain variables (like the `Backbone` global) accessible to that library, or to take the output of that library and expose it as a module export. This was made a bit more complicated by the fact that I have a quirky setup so that all the Backbone and jQuery plugins only get loaded once at startup, rather than needing to manually import them in each file that needed to use that particular plugin. In general, though, it's "just" a matter of telling Webpack where to find each file, and figuring out the right combination of loaders to satisfy the expectations of each module. From there, your app just imports those libraries as normal.
Add it to a .gitignore file
Check out this course from W3C on edX: [https://www.edx.org/course/javascript-introduction](https://www.edx.org/course/javascript-introduction) And this one from UPenn: [https://www.edx.org/course/programming-web-javascript-pennx-sd4x](https://www.edx.org/course/programming-web-javascript-pennx-sd4x) &amp;#x200B; Hope that helps, Josh from edX
Add a .gitignore rule for it.
Node is not JavaScript, but runtime environment. Roughly speaking it's a program written in C++ which exposes api which JavaScript can use instead of browser API. For example: setTimeout it's not something JavaScript does, but the underlying virtual machine (browser or node). What JavaScript does is tell that machine to do timeout and comes back to it when it finishes processing. Small nitpick, but understanding it helps immensly when dealing with callbacks.
Haha, thanks!
...depending on where you are, was my point. Writing a public API does not require either markup or CSS, but may still be the exclusive work of the frontend dev. There is still a distinction some places, and other places, it is not as clear.
Sounds like you should consider a type-checking tool instead of asserting types everywhere, since this is a major problem for you. You use Angular, so TypeScript may be a good choice. I've tried the approach of returning errors instead of raising them with Golang, never seen it done with JS though. That's interesting. It does force you to think about application / business logic errors more when you write the code. Although I personally had struggles with when to append additional context information as the error gets passed up the call chain.
Awesome!
There is no single course that teaches all of that, some cover most of those things, but the sticking points are mainly TDD and how you define "production ready". It would be far too inefficient to introduce React and TDD simultaneously, you really need to learn React before you an learn applying TDD to a React development. A lot of courses might include material on webpack or have a section on deployment, but there can be a lot more than just that in producing a truly secure and optimized production ready app. As far as the Udemy courses on React Stephan Grider's first React course is a little dated at this point and doesn't cover testing. Andrew Mead's course covers testing pretty well and explains TDD including how to use it with a database using CRUD, but doesn't really use that approach in the project, it does does cover webpack. Andrew Mead's is the one I generally recommend. Maximilian's course has an intro to ES6, but the testing section is pretty weak. [This course](https://www.udemy.com/react-testing-with-jest-and-enzyme/) is really good about teaching TDD if you already know React &amp; Redux, but doesn't over using TDD w/ a database or applying CRUD. There pretty much isn't a single course that will complete your wish list, but I do believe that Front End Masters has good courses on all of those individual subjects and a lot more. 
https://www.udemy.com/react-redux/
Also post this to r/privacy
Pagination, infinite scroll? 
True story :)
You're right ‚Äì I'd thought it as higher, but 67% doesn't really cut it.
I don't understand why tutorials always teach people new to node to use MongoDB instead of a relational database. All of the data appears to be a great fit for a relational database. You know the structure and you don't need to prepare for rapid growth because it's a tutorial for express. It isn't like these tutorials prepare anyone for rapid growth anyways. MongoDB definitely has its uses but blindly teaching people to use MongoDB seems lazy. I wish the tutorials would briefly compare MongoDB/nosql db's with relational databases and explain the uses. I don't think you should be using nosql unless you have ran into challenges with a relational databse or have experience knowing the limits. You should learn relational databases before dabbling into nosql. Using nosql over mysql just because you don't want to define a structure is just lazy. Sorry, I always see tutorials on here that blindly tell people to use mongodb and I felt like whining a bit.
Do you have a link to an resources or examples? I don't know much javascript unfortunately. I'm searching online right now, but can't find any good concerete examples
[removed]
I use TS at work. TS is awesome, but the fundamental achilles heel is that TypeScript is compile-time only. It still compiles to plain old JS for its runtime, which means you are still vulnerable to bad runtime data from APIs and user input and what not. Those are the situations where code can break in bad ways, and I've learned to be *extremely* defensive at the integration points of runtime data. I try to keep the rest of my domain based on a solid model where type safety actually means something, and try to keep the fragile shit isolated to one layer of the domain, but at that layer is where I go fucking mental writing `InvalidArgumentExceptions`. Bad data should fail early, and fail loudly, and it should totally bail out of execution of the rest of the application so that you don't wind up with insidiously bad data snaking its way through your runtime (else all the type safety checking from TypeScript in the world won't mean shit). 
I haven't used LESS, but I can tell you, as someone who loves Python, I like not having to use curly braces and just using spaces and tabs to parse everything. It just looks cleaner to read for me. I also just use it at work, so it's more familiar.
Only other option is creating a custom type, as mentioned above. I do do that a lot. You might want to check out an article I wrote on using JSDoc with JavaScript for type checking with TypeScript: https://medium.com/@trukrs/type-safe-javascript-with-jsdoc-7a2a63209b76
Awesome!
It depends. Are the indices important? If you only care about visiting every element then you can use a for-of loop for( const elementA of firstArray) { for( const elementB of secondArray) { use( elementA, elementB ); } }
Very well done! This is gorgeous in its own right ü§ò
can I get this as a screen saver or somthing?
As a user of Draft I would like to point out that development on this project has slowed significantly. Also, anyone who plans on using it should consider pairing it with [draft-js-plugins](https://www.draft-js-plugins.com) since the plugins editor component makes it incredibly easy to build additional features over the core editor.
It is not javascript it is backend logic The api response must contain data per page, page number, total number of pages or that sort of things. Of not it is badly designed. 
jQuery is a valid option here. Relax. There are a number of different solutions in this thread.
If you want to learn Redux, this is a good crash course, and I mean, its by Dan Abramov: [https://egghead.io/courses/getting-started-with-redux](https://egghead.io/courses/getting-started-with-redux)
DM me!
Might want to post this to /r/electronjs too.
You could use a regex and `JSON.parse`: ```js const text = document.body.children[1].innerHTML; const match = text.match(/\{(?:\n|.)*\}/); const json = JSON.parse(match); ``` https://jsfiddle.net/enxr2pta/
You'll probably need an external queuing service (zeroMQ, rabbitMQ, amazon's queue service) at this point. You have a very long-running job, and your ability to parallelize it even with clustering will be limited to the number of cores/threads your system has. &amp;#x200B; The queue would hold the incoming requests, while your main system would query the queue when it is able to process a new item.
Thank u so much theogravity. But isn't there any way for me to concurrently perform the task. I really appreciate u taking your time to answer my question
Did a quick search and it doesn‚Äôt look like their API supports pinning comments. 
If your process is CPU-bound you won't beat one job per logical core at a time. That is as parallel as parallel gets. You can pretend to do more jobs than that at once, but won't see any performance gains.
I can't believe how many up-votes has this post gathered. I think JS and CSS are brothers grown up in the same neighbourhood... it's not good to separate them ;)
Thank you so much! I will try and setup that timeout code and see how it goes. 
What does it do right now? Stay at the same color?
If you have 4 cores/threads, you can run up to 4 tasks at once at maximum speed. Once you have more than one task per thread, you're only creating overhead since now the cores/threads have to switch context. Now, if your tasks are long-running because they have lots of IO, then you can definitely run more than 4 at once - but if they're CPU-bound, you can't get any speedups (and in fact, it will be slower) if you try to run more than one task per thread/cpu.
Yeah.
Also, the reddit API is super simple: just append `.json` to whatever URL you're on.
How does this compare to [https://github.com/prerender/prerender](https://github.com/prerender/prerender)?
the comparison is the same as rendora vs rendertron; please see it here [https://github.com/rendora/rendora#what-is-the-difference-between-rendora-and-rendertron](https://github.com/rendora/rendora#what-is-the-difference-between-rendora-and-rendertron)
Use a server, or find an API that allows cross-origin requests. 
Your function never attempts to change the background color of the button. Maybe start by getting the button (you could give it an id and then use `document.getElementById()` as you have already with the inputs), and then look at how to modify the style of an element ([https://www.w3schools.com/js/js\_htmldom\_css.asp](https://www.w3schools.com/js/js_htmldom_css.asp))
&gt;I've read in the past that fetch couldn't be used to get progress events (for file upload iirc), but with axios you could show the upload %. &gt; &gt;In the past year &gt; &gt; fetch also wasn't able to cancel requests? If that's no longer the case, great, That's why I wrote the article, I had no idea all the stuff was possible. ‚ù§Ô∏è
I didnt fix this via my code, i fixed it through the HTML side. I no longer have a sub-div, so it's no big deal. &amp;#x200B; In the future i may need to fix this with the jquery code but I'll leave that for another day. 
Thanks. :) So I have this now: &lt;script&gt; function myfunction() { document.getElementById("colour").innerHTML= document.getElementById("red").value + document.getElementById("green").value + document.getElementById("blue").value; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 style="text-align: center;"&gt;&lt;p onclick="window.alert('Chris Chesno')"&gt;CLICK HERE FOR MY NAME&lt;/p&gt;&lt;/h1&gt; &lt;h2 style="text-align: center;"&gt;CPS 120 JAVASCRIPT LAB&lt;/H2&gt; &lt;p&gt;&lt;p&gt;&lt;/p&gt;&lt;/p&gt; &lt;p&gt;&lt;p&gt;Enter two-digit, hexadecimal numbers for the amounts of red, green, and blue light you want combined to create a color.&lt;/p&gt;&lt;/p&gt; &lt;p&gt;&lt;p&gt;Enter the hexadecimal numbers in the boxes below.&lt;/p&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="text" id="red" /&gt; Red&lt;/p&gt; &lt;p&gt;&lt;input type="text" id="green" /&gt; Green&lt;/p&gt; &lt;p&gt;&lt;input type="text" id="blue" /&gt; Blue&lt;/p&gt; &lt;p&gt;&lt;input type="button" id="btn" value="Click here to see the color you created" onclick="myfunction(); document.getElementById('btn').style.color = " /&gt;&lt;/p&gt; If I do say, style.color='red' then the button turns red. So I know that works. How do I get my "colour" variable (the created hex value) from the function into that spot? 
Pin to the comments, no. But you could do the next best thing and add a note to all video descriptions I suppose.
Use let
[removed]
Depends if you are trying to target an older browsers. 
Use let in for loops. The difference is that var is function scoped and let is block scoped. When you use var you will be able to access i anywhere in the function it's declared in, even outside of the for loop. Generally you only want to use i inside the for loop so it's better to use let.
Not sure if this is still true, but the fastest method of iteration if the direction of iteration didn't matter was to iterate backwards. &amp;#x200B; let i = 10 while ( i-- ) { &amp;#x200B; } &amp;#x200B; If speed was your primary concern that I would say the above is "best".
Wow that‚Äôs really cool üëçüèª
Basically, in Google Sheets you can share a sheet as a public JSON url. Then, use JavaScript to pull that data from Sheets and display in your page. Here's more on how to do that: * [How to use a Google Spreadsheet as a database](https://www.blockspring.com/blog/google-spreadsheet-as-database) * [Use a Google Spreadsheet as your JSON backend](https://coderwall.com/p/duapqq/use-a-google-spreadsheet-as-your-json-backend)
Even better would be to unroll that loop, but I don't think OP is concerned with speed.
If you want to have I lingering around your function, use var. Let will be out of scope when the loop exits.
Have a look at the documentation: https://m.mediawiki.org/wiki/API:Cross-site_requests You have to add a query paramter "origin" if you want Wikipedia to add the correct CORS headers. If you're not authenticated then you can just use "origin=*"
For those who are looking for an answer please do the following:- 1)require the child\_process module 2)Fork the child process for every request. 3)now run the forked process This will significantly improve the applications performance
why is this so? 
My personal take on that is to use `let` everywhere, just because it reads so much nicer. I also can't remember ever having a bug in javascript which was caused by accidentally making a variable refer to another object.
It's not only to prevent bugs, but to simplify reading of the code.
When I see someone use `let` it communicates to me that the developer is planning on reassigning the value of that variable. It tells me whenever I see that variable it may not be the value I thought it was unless I'm tracking everything that has happened in that variable's scope. This can be a lot of cognitive overhead if you never actually intended to reassign in the first place.
The point is that it tells other devs and future you that this variable will always contain this value. But in practice, almost every variable can be a const in javascript. So what really happens is that devs will se a let, and immediately know that something special will happen to that variable.
&gt;document.getElementById('btn').style.color = " Why not move that to your function function myfunction() { document.getElementById('btn').style.color = ??? document.getElementById("colour").innerHTML= document.getElementById("red").value + document.getElementById("green").value + document.getElementById("blue").value; } Remember too (or not if you haven't learnt it yet), that you can assign stuff like `document.getElementById("red").value` to a variable so it can be reused . e.g. var red = document.getElementById("red").value; var green = document.getElementById("green").value; var blue = document.getElementById("blue").value; document.getElementById("colour").innerHTML= red + green + blue; &amp;#x200B;
We need dark mode code syntax. This looks silly on dark theme.
It's not about causing bugs, it's about communicating intent. Code is written once and read/changed hundreds of times in larger projects. Letting the reader (including future you) know what you intend to happen with a variable helps a lot. It's the same reason I start every method that returns a boolean with a verb like has/is/can (e.g. isAuthenticated, canEditPost). Not doing so won't cause bugs but doing this does communicate intent. "Reads so much nicer" is an okay argument for solo projects but not for team projects unless everyone agrees, imo.
Also I personally disagree that it reads nicer. It's satisfying to lock my code down with a const.
Why does it read nicer?
I agree, the main counterpoint I see is that this 'cognitive overhead during reviewing' is a main argument used for typed languages, yet we flocked to non-typed languages due to it's less cognitive overhead while \_writing\_ the code. So I think it will always be a subjective balance between those two.
Never use `var`. There is no use case for it if you are in an environment that allows `let` (or are using a transpiler like Babel for targeting other environments). And as others have said, use `const` by default unless you truly intend to change the variable's value. You can even use `const` in loops if using `for/of` syntax: for(const x of myArray) { console.log(x); } At least, the latter will work in later versions of Node; I'm not sure if Babel/etc will choke on it.
It isn't more cognitive overhead to use *const.*
Every addition on it's own isn't a significant cognitive overhead.
To add on to that, concrete impls are using the \`cluster\` module or service workers. There was a post earlier in the week where someone created a solution of their own using clusters and IPC. [https://www.reddit.com/r/node/comments/a3tea3/betterthread\_easy\_node\_multithreading\_library/](https://www.reddit.com/r/node/comments/a3tea3/betterthread_easy_node_multithreading_library/) You will still need a queue regardless, it's impossible to be able to process 1000+ requests where each req takes 3 mins to process on a single server. Maybe if you have a super expensive server, maybe, but it'd be very cost-inefficient compared to using a queue service in your stack. &amp;#x200B;
I created a api that i route my requests through that accepts any origin response 
I sort of get that, but just saying "this variable won't be reassigned" is kind of limited in my opinion. I do like the concept of immutable by default like Rust and functional languages do, but const doesn't say anything about mutability. I would maybe have been in favor of making `let` non-reassignable, and having another keyword for reassignable variables, but I think the effect is so small that it's not worth making most variable declarations slightly more awkward to read and write.
Excellent thanks!
Different employers will be interested in different things. Why not contact a few and ask them what type of experience they are looking for? Then, take on projects on your own, or for friends, or even for clients, with the goal of getting that experience.
Your "take" is just wrong in this case, sorry. Most things are open to opinion and discussion, but this really isn't one of them. `const` should *always* be used except for when you need to turn it into `let`
Great thanks
\`var\` is very useful so don't mind other people saying its not. You just have to know the difference between \`var\`, \`let\` and \`const\`. Every one of them has its purpose.
Mind telling me why it's useful over using const or var?
That's not true. Never use var. 
You're never THAT concerned with speed. You shouldn't even think about such things, it doesn't make any sense. 
``` document.querySelector("[name='account_disabled']").selectedIndex = 0; ```
The airbnb styleguide applied to my eslint tells me never to use \`for...in\` loops and instead replace with a \`forEach\` that iterates over \`Object.keys\` or \`Object.entries\`.
Cat.
I'd recommend a .json file with an associated JSON schema, outlined in the README.md
this is a much better and more nuanced answer than the current top one that says use `const` everywhere unless you can't. this explains why you can't use `const` (it's by design) and highlights how people just say "use `const`" without understanding the tradeoffs of using `const` vs `let`
&gt; There is no use case for it if you are in an environment that allows let (or are using a transpiler like Babel for targeting other environments). false. it's useful if you don't want to declare variables as undefined: const badFunction = (value) =&gt; { if (value === 'foo') { var key = 'foo'; } else if (value === 'bar') { var key = 'baz' } return this.statelyMap[key]; }; it's a very very weak use case that can be overcome with better code structure, but to say there is absolutely no use case is silly.
con¬∑stant 1. occurring continuously over a period of time. Const is immutable. Let is mutable. When you let something equal something, you may let it equal something else later. When you define a constant... it's... well, constant. Makes perfect sense to me.
this is a bad answer because while technically correct, it doesn't provide any context or explanation to why you should use `const`. it also doesn't answer op's question.
const and let are different, why do you say its a preference thing?
&gt; yet we flocked to non-typed languages More like we're forced to use it due to browser support.
Never listen to anyone who tells you to never do something :). There is a very good reason var is not deprecated.
Found the stackoverflow user 
It's important to write code that is easy for others to reason about. If you intend to define a constant, use `const`. There is no good reason not to.
I think he's arguing that `const` only indicates the mutability of the reference, not the object itself. See this part of his comment: &gt; const doesn't say anything about mutability.
You could do it without the API, so no $300 for you.
(if you are, use babel)
it depends on if you want it in source control (git) or not. it sounds like you want to have a default settings file that the user can then override with their own values. will these values change based on environment? (e.g. will the person using your project want to have a different user in prod and dev?) it doesn't sound like it. generally environment variables are used if the values differ between environments (think about having a prod database login vs a test database login) it doesn't sound like that's what you want though. you probably want to have a config file that is stored in source control that provides default values. then the user can write their own file that will overwrite any values that exist in both files. the user file should be ignored in your gitignore file so that the user can change their preferences and commit away without messing with the repo. i just want to make sure that you're talking about doing something like: `defaultConfig.js` export default { user: 'example_user' interval: 60 }; and the `userConfig.js` would look something like: export default { user: 'alex-luskiku' }; right? you're talking about changing the values of keys you're defining (not redifining the keys) right? that's how i'd do it (note js is just for illustrative purposes. you can use whatever config language you like: json, yaml, js, xml).
[removed]
I don‚Äôt know what you‚Äôre using to display things currently so I can‚Äôt give you specific advice but you just need to loop through all of the objects in the array and display each one. If you‚Äôre building the html yourself, each loop iteration would add a bit of html to a document fragment or something similar. 
It's not. At least in v8 they will get compiled to identical bytecode for the equivalent loops, e.g., `let i = 10; while (i--) {};` and `for (let i = 10;; i--) {}`
&gt; badFunction trying to follow your example here, but anything of where 'value' isn't captured by the if condition, would return an error. Key would be undefined?
I would love to hear an honest argument in support of var.
It's simple really. Do you want i to be available to the global scope or not? Typically the answer is not, therefore most of the time you should be using let.
Early tells that you're not using Eslint. Use `let` and use `i += 1` not `i++`.
They're all over the internet. You should realize the impetus is on you proving that let can replace it in every single implementation without any impact to existing systems or requiring any effort. But that simply isn't true. Which is why it isn't deprecated.
&gt; yet we flocked to non-typed languages I think JavaScript's ubiquity in the browser has more effect on that. I have only ever met three front-end developers that have done a full project in TypeScript and still prefer Javascript. 
Good info. I learned a thing. Thank you.
Sorry about that, I thought I was posting the question in Java. Thanks for the heads up, however.
Hi /u/MonsieurLeland, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Posts must directly relate to JavaScript, and content regarding CSS, HTML, general programming, etc. should be posted elsewhere. Thanks for your understanding.
&gt; me why it's useful over using const or let? Depends on your design pattern I suppose. If you are using legacy libraries or modifying them, you might be constrained. https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var-to-declare-a-variable-in-jav Some good examples here of the different behavior patterns, especially like this one: // Logs 3 thrice, not what we meant. for (var i = 0; i &lt; 3; i++) { setTimeout(() =&gt; console.log(i), 0); } // Logs 0, 1 and 2, as expected. for (let j = 0; j &lt; 3; j++) { setTimeout(() =&gt; console.log(j), 0); }
Hi /u/fluffycat243, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/asan132, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Only because you asked... At top-level in a script, it's the most idiomatic cross-platform way of declaring a global variable. This justification will disappear once "globalThis" is introduced.
using `let` avoids the common closure issue too
To add a detail, you should use const when doing a ‚Äúfor in‚Äù or ‚Äúfor of‚Äù loop, because there should be no reassignment there. Sorry for formatting, im on mobile
Marked as duplicate.
The ``var key`` definition is [hoisted](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone) to the top of ``badFunction``, so the reference will not throw an error. But you should still never do such a thing, as it's difficult for others to understand.
Let keeps the variable only within a {} scope. After the loop you cannot access index i.
&gt; using const vs let is a preference thing no it isn't &gt; this is the danger of reddit's hivemind stop acting like you know anything, you know nothing 
Look into Greasemonkey and Tampermonkey. 
Right - missed that, badFunction lives up to it's name.
Thanks. This is a much cleaner solution than what I had frankensteined. Could you kindly explain how that regexp is able to do it? 
It might matter. If you're **very** concerned about performance and are targeting &lt; Chrome 59, you could prefer \`var\` loops. &amp;#x200B; Prior to Chrome 59, \`var\` loops performed better than \`let\` loops: [https://stackoverflow.com/questions/40449494/why-is-using-let-inside-a-for-loop-so-slow-on-chrome](https://stackoverflow.com/questions/40449494/why-is-using-let-inside-a-for-loop-so-slow-on-chrome) This has been fixed in Chrome 59, so the performance difference is negligible.
Closed as off-topic.
It looks fine on iPhone
this
I'll do just that. Thanks for the advice!
really? why not? screenshot changes the color somehow?
Besides browser support, why not use const/let? They also declare a variable globally at the top level of a script.
Doesn't matter... It is Javascript and you'll manage to shoot your foot somewhere else.
You mixed the two up, a let-declared variable will be cleaned up after its block ends.
Reddit is fun true dark theme seems fine here
That's not a `for...in` loop.
&gt; false. it's useful if you don't want to declare variables as undefined: `let key = 'defined'`
If using var vs. let/const is the difference between a variable being global or not, that would imply you have non-function blocks directly in the global scope. I would say that's bad practice anyway and that you should wrap stuff in an IIFE or something so it's got a visual context.
I use var to show my intentions that the variable will be used later, when that use case applies. let doesn't work for everything. If I need to use the iterator from a for loop in code right after the for loop, then using var is a good way to indicate that it will be used later. Forcing 'use const or let everywhere' just doesn't always work well, or it forces you to write code in a way that isn't natural just to maintain some false notion of progress. 
Cat. 
If you are using babel to comple this code and performance is important, THEN read this. The `let` version above will create an implicit function (again with babel) to adhere to JavaScript semantics when it comes to `let` + `for` loops. For example this snippet of code is infamous as a "gotcha" JS question, but it is no longer tricky these days because of let inside for-loop semantics. for (let i = 0; i &lt; 10; i++) { setTimeout(() =&gt; console.log(i)); } With `var i = 0;` this used to print all 9s but now it prints the sequence as intended because each iteration of the loop receives it's own let with its own scope! It's a pretty neat bit of JavaScript trivia. [And sure in the above snippet it is what we wanted, but babel will create this extra closure even if the `i` is used in synchronous nested closures. Which again, is fine, unless you did not want that!](https://babeljs.io/en/repl#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=GYewTgFANgpgLgAgJYILwIAwG5kIDwICM2yA1KQJQIDeAUAggNoC6AdALYCGADhBFagB8yClloBfWrViIAkmkxjQkWTnkFia8lToMWHHnwHDZoiUA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Creact%2Cstage-2&amp;prettier=false&amp;targets=&amp;version=6.26.0&amp;envVersion=) Ofcourse defining the `i` outside the loop definition fixes even that edge case (in babel).
Omg dude that worked. You're a genius. Now i get to look smart in front of my client lol instead of like a dude who needs to go to Reddit when things don't work
This isn't a use case. This is bad code. Relying on hoisting means bad planning. This also implies that `key` could be different data types, also a bad practice. Also, what if `value === 'bad with computer'`? I hope you have an `undefined` handler in every callee. I know it's contrived to try and prove a point, but \*don't do this\*
&gt; this is the danger of reddit's hivemind when it comes to answering questions that are based on preference let vs const vs var is not a 'preference'...there are contexts for their use...and contexts not to use them in ...it depends on what you are doing... But it isn't a 'preference'...
Don't listen to OP. `key` is hoisted, but there is no safety net in the `if` condition. Like you said, if `value` falls through, it returns `undefined`. This is an accident waiting to happen.
I read your example and stand by what I said.
You shouldn't use var unless you're for some crazy reason using an environment that doesn't support es6. Always use let if the value will change or const otherwise. If you're not sure go with const. You'll know if something tries to modify a const because you'll get an error
Sorry for no concrete example. Lets say there are 500 items. You should old display 50 items per page. When on page 1 you can make a request to your server like \`GET items?page=1\` Now your backend will have context which page you want and will return the first 0-50. If its page 2 itll be 50-100. And so on
Assuming you mean `let key = undefined`, I agree. Explicit is better than implicit.
Because let is block scoped, and so it should be used within a block only. Using var lets someone know this variable will be used in other places than just the block you are focused on. using let is fine, where it's used only in a smaller block scope, but use var for anything that might be reused outside of an individual block scope. 
clipped from one of my incomplete notes: - Basics - MDN Javascript @ https://developer.mozilla.org/bm/docs/Web/JavaScript - ES6 / ES2015, ES2016, ES2017, ES2018, ES2019 @ http://exploringjs.com/ - NodeJS @ https://nodejs.org/api/index.html - HTTP Headers, Status Codes, CORS, Compression, Sessions, Websockets - TCP / UDP, Clustering, Encryption, Hashing - Cryptography @ https://latacora.micro.blog/2018/04/03/cryptographic-right-answers.html - Frameworks &amp; Modules - Babel - transpiling - Webpack - bundling - Rollup - bundling - Terser / Uglify - minification / compression - Express - web app - React - view - React Router - app-level routing - Material UI - user interface - Jest - testing - Lodash - utils - Moment - date &amp; time - AJV - schema validation - Pako - compression - Tweetnacl - cryptography - PM2 - process management - Yarn - package management - ESlint - code linting
This is the only correct answer. Using cost or let isn't going to guarantee your code is going to be somehow magically 'better'. In fact it can make it more difficult to deal with if someone doesn't know what they are doing. 
Does unrolling loops really make that much of a performance difference? I've been working on a js game and trying to wring every clock cycle I can out of it, but I can't see much change with vs without. Any idea where I can look to find some more info?
&gt; If using var vs. let/const is the difference between a variable being global or not, that would imply you have non-function blocks directly in the global scope. My bad use of words, do you want i to be available to the closure the for loop is a part of (whether that is the global scope, wrapped in an iife or part of module).
Never mind guys, found a solution. 
That is a great way to do things if you don't care at all about performance.
This sub isn't a code writing service.
Even though the key variable is "hoisted" it'll still be undefined if the "if statements" all evaluate to false. Thus accessing statelyMap with undefined as the key will throw an error.
Looks fine on Chrome for Android
Use `let` in loops with reassignment: for (let i = 0; i &lt; 3; i++) { console.log(i); } Use `const` in loops without reassignment: for (const n of [0, 1, 2]) { console.log(n); } There are few if any reasons why you should use `var` with modern JS.
What is an example of `let` not working?
Whoops!
Maybe you should include only the block in question
Not a noob and literally haven‚Äôt had a use for `var` since `let` and `const` were introduced. I really don‚Äôt get what you‚Äôre going on about. Would love to see an example of a time when the new keywords wouldn‚Äôt work for you. 
neato burrito 
just edited my question didn't thought of it
Me IDE tells me I should use const for these variables since they never change in their scope of the loop. Is this wrong? 
Here's a breakdown of the regex: * `\{` Find the beginning bracket * `(?:\n|.)` Match any character `.` including new lines `\n` (wrapped in a non-capture group so they can both be used with `*`) * `*` Repeat the previous group zero or more times * `\}` Stop matching once the end bracket is reached
Cat.
It's really simple. for(let i=0;i&lt;whatever.length;i++){ if (whatever[i] === something) { break; } } [do something else with i (is broken)] Fine, you could also write it this way but it's *unnatural* and forced, just because you *think* you have to avoid var. let i = 0; for(;i&lt;whatever.length;i++){ if (whatever[i] === something) { break; } } [do something else with i (works)] But var still works, and *always will*. for(var i=0;i&lt;whatever.length;i++){ if (whatever[i] === something) { break; } } [do something else with i (works)] Just saying "never use var" creates a a coding superstition. It's dumb. It's uninformed. And it's wrong. 
I need to stop using var, I tend to do it automatically since that's how I learned way back in the 2006s. So use const everywhere you can (variables that won't change), and use let if you have to (variables that will change).
It's really simple. for(let i=0;i&lt;whatever.length;i++){ if (whatever[i] === something) { break; } } [do something else with i (is broken)] Fine, you could also write it this way but it's *unnatural* and forced, just because you *think* you have to avoid var. let i = 0; for(;i&lt;whatever.length;i++){ if (whatever[i] === something) { break; } } [do something else with i (works)] But var still works, and *always will*. for(var i=0;i&lt;whatever.length;i++){ if (whatever[i] === something) { break; } } [do something else with i (works)] Just saying "never use var" creates a a coding superstition. It's dumb. It's uninformed. And it's wrong. 
&gt; Because let is block scoped, and so it should be used within a block only. The global scope still exists, even if the value does not created created on the global object. There is nothing in any spec that states ‚Äòlet‚Äô should not be used in the global scope.
&amp;#x200B;
I'm not even talking about global scope. It's really simple. for(let i=0;i&lt;whatever.length;i++){ if (whatever[i] === something) { break; } } [do something else with i (is broken)] Fine, you could also write it this way but it's *unnatural* and forced, just because you *think* you have to avoid var. let i = 0; for(;i&lt;whatever.length;i++){ if (whatever[i] === something) { break; } } [do something else with i (works)] But var still works, and *always will*. for(var i=0;i&lt;whatever.length;i++){ if (whatever[i] === something) { break; } } [do something else with i (works)] Just saying "never use var" creates a a coding superstition. It's dumb. It's uninformed. And it's wrong. 
It's particularly not overhead if using a programming style that avoids reassignment and loops.
But `var` behaving that way is just some weird implementation detail, it isn't something that everyone understands. Using `let` like in your second example is more obvious and requires less language knowledge. Think of the readers of the code, including junior devs.
You should format it Lines starting with four spaces are treated like code: if 1 * 2 &lt; 3: print "hello, world!"
At this point, var should signal "I intend for this variable to be hoisted to the top of the containing function, because i'm in to weird shit.". Nothing about the use case you described requires var. let i for (i = 0; i &lt; x; ++i) { // some stuff } console.log(i) // ayy lmao 
It's really simple. for(let i=0;i&lt;whatever.length;i++){ if (whatever[i] === something) { break; } } [do something else with i (is broken)] Fine, you could also write it this way but it's *unnatural* and forced, just because you *think* you have to avoid var. let i = 0; for(;i&lt;whatever.length;i++){ if (whatever[i] === something) { break; } } [do something else with i (works)] But var still works, and *always will*. for(var i=0;i&lt;whatever.length;i++){ if (whatever[i] === something) { break; } } [do something else with i (works)] Just saying "never use var" creates a a coding superstition. It's dumb. It's uninformed. And it's wrong. 
Apparently it isn‚Äôt a preference for most people nowdays, and sadly working in a team its just not a viable option because of that. I‚Äôm used to working with `var` for over a decade, I learned its quirks and I used those variables as constants (by convention) either way, so there is little difference for me. I have nothing against the new way, but I did have a situation where hoising would help me, so I used `var` and had to go against the linter and comment the whole thing so others won‚Äôt burn me at the stake for it. Unfortunately, there isn‚Äôt much room for discussion in this topic. I guess because the new declarations are introduced as superior to the old one for some reason. Maybe you can have a healthy discussion in you team, but you‚Äôll get burried on reddit for having a different view
thank you for telling me how to format it! 
&gt;But var behaving that way is just some weird implementation detail Sorry but.. it's not a "weird implementation detail", it is working as designed and has been for 20+ years - the only thing weird about it is your lack of understanding of it. Junior devs need to learn the language, using const and let don't automagically make anyone's code better. 
As a nitpick, references in JavaScript are immutable; what you're changing (or not changing in case of `const`) are either the bindings or the objects that are being referred to.
I'm not really an expert on coding or anything so I'm trying to get this ... if you use `var` in a loop then you can still access the `var` later, but if you use `let` in a loop then `let` disappears later. So in this case, using `var` would be useful if you need to know how many times the loop ran. ... and if you don't need to know how many times the loop ran, then using `let` is okay?
for some reason it wouldn't let me format all the code so i just put directly the link and wrote a comment where the problem is
Okay then indicate it in the post that you have put a comment there. Also, stackoverflow.com could help you if no one responds here
Using just vanilla JS?
It's just a fact of life that JavaScript requires a build step if you don't want to choose between the modern language features and legacy browsers. The features are nice enough that you should choose both and use Babel.
what, TIL
Yes, exactly. A lot of people only like new "shiny" things, so they want everyone to use only let and const, for no other reason than because they are "new" and they maybe don't understand how javascript works that well? Var has been working fine for the last 20 years, but now suddenly the hivemind says don't use it? I don't believe it, sorry. Var still does things that let and const never will, so I'll keep using it where I can leverage its behavior. Everyone has a different coding style, and the ones that tell you to never use var are not the people to trust, they are fad coders with limited understanding of the world of coding. They only want "new, shiny" and shit on anything that falls outside of their insecure little bubble. 
Yes, greasemonkey and tampermonkey to modify websites.
already asked on stackoverflow but no one responded 
It _is_ a weird implementation detail, because it's probably not how most language designers would implement it in a modern language. It's a feature that has caveats. Variable hoisting is just odd and non-obvious. Do you really doubt this? Why is `var`'s behavior often asked in js interview questions? Because the rules around it are gotchas and require some reading to understand. `var` should be treated as deprecated for all intents and purposes. `let` and `const` behave in much more natural, obvious ways. And..yes, `const` and `let` do make developers' code better, because they show intent. This is absolutely not possible to show via `var`, so I don't get why you brought it up since it further demonstrates why you shouldn't use it. You're losing the argument for yourself. 
Coming from C# (java, even C/C++), the natural syntax for that `for` loop is: ``` let i = 0; for(i = 0; i &lt; whatever.length; i++){ if (whatever[i] === something) { break; } } [do something else with i (works)] ``` And it's not forced. var-level scope doesn't exists in those language.
We're not talking about C# or other languages, this is about javascript, and I won't apologize that Javascript isn't C#. It's different for very good reasons. And no, I don't think your example is any better than using var. 
no. he means let key be defined, and never undefined. you know its going to be there..might as well define it with some thing, even if its null
&gt;You're losing the argument for yourself. Says you, but your arguments don't make any sense. I'm glad people ask about how to use var in interviews, because they probably are still using var, and there's no reason not to. I'd ask those questions to weed out the noobs so I don't hire someone without experience. let and cost show intent, but so does var as I've stated here many times. var can be used to show intent to use the variable again later. I've given examples. But go ahead and be a superstitious coder if that's what you want to be. 
const does work though, in node at least, and my IDE tells me to use it there as you shouldn't be changing the iterator in your loop manually. It is only constant for the single scope of the loop, so it should be able to reassign it in another round of the loop. Though personally I would prefer to use let there, looks cleaner, but my IDE gets mad and highlights it so I generally just go with const.
"Implementation detail", weird or otherwise, states that the behavior is specific to an engine; it's not, it's in the specification for the language. An engine that didn't hoist vars wouldn't be JavaScript. Maybe you meant "weird design detail"?
All that's doing is hiding the scope of the variable. You're better off with: let key; const badFunction = (value) =&gt; { if (value === 'foo') { key = 'foo'; } else if (value === 'bar') { key = 'baz' } return this.statelyMap[key]; };
Cat.
Then all is well?
I don't see the problem with example 2. It's completely obvious that the developer had the intention of reusing i. It's explicit and it signals intent. In example 3 you have to judge whether or not the person who wrote this intended to do it. You have to be aware of the hoist and then decide whether or not to trust that the author was also aware of it. Granted if 99% of the remaining code uses let or const, you might be able to infer that it was intentional. But I would still probably feel some uncertainty upon seeing that var. I don't think anyone would question what's going on in example 2. The never use var thing can be rather dogmatic, but I suppose some folks would rather preach that than get into the specific mechanics of why using var can be hazardous.
i just get used to it. i can quickly just [make a thing](https://imgur.com/a/rlXdtry), kind of mininal but it works
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/0nqPxcY.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20ebjdo38) 
Sure, I guess. Whatever communicates the idea that the behavior is so non-obvious that it needs a "gotcha" section of some javascript handbook to explain it.
&gt; var can be used to show intent to use the variable again later. I've given examples. I get your angle, but this logic is muddied by the fact that `var` has been the canonical way to declare variables for the majority of javascript's life. If `let`, `const`, and `var` all existed from day 1 this argument would hold more weight.
Of course the correct way to do that is run .any() ( or is it .some() in JavaScript) on it, and not use the loop at all.
whats so bad about css? it does it's job, applying styles to dom elements. you probably just dont consider css a programming language when you say language, which is true. its not a programming language . its just a way of applying styles.
Var would be deprecated if there were any such state in JavaScript, most likely. Don't be insulting to people "junior devs need to learn". Senior arseholes need to learn not to be arseholes. Var will not exist in virtually any modern codebase, because it is dumb. Use let above your loop, initialize it in your for, or just don't even use a loop. 
Maybe just put a general knowledge of "MVC frameworks and state machines" in your resume, instead of chasing the tail of the dragon.
&gt; I would still probably feel some uncertainty upon seeing that var. If someone can't understand var, or if their functions are too big that they get lost, then they are doing it wrong anyway, and const or let won't really save them. &gt;The never use var thing can be rather dogmatic, but I suppose some folks would rather preach that than get into the specific mechanics of why using var can be hazardous. Javascript isn't difficult to use, and only people who don't know the simple rules have difficulty with it - just like with anything. Javascript was designed to be easy, and it is easy, and it is powerful too. It's funny that so much of the web was built on var, but suddenly it's now a pariah because "it's too hard"? It's hilarious but also sad at the same time. It's superstitious to for people to say "don't use var", and it absolutely shows their non-mastery of the language. 
Use let For better understanding You use create a for loop and write a timeout function in loop. In one case use let and other case use var. You will understand yourself clearly 
I know that it‚Äôs completely irrelevant to the topic at hand also, but they‚Äôre some very contrived examples. Just use findIndex if you want to keep a reference to the index when a certain condition is met.
Weighing in as someone who doesn't primarily code in javascript but the third option, to me, is the most unnatural by a long shot. The fact that you can still use the variable outside of block is more than a little bit tricky and it's definitely more natural to define variables using 'let' in the scope you intend to use them.
Right. Out of scope.
What kind of salary range can we expect from your position?
Because only your narrow imagination can come up with the one solution that will work for every kind of code - even algorithms? Sorry, but no, you're really showing you have little experience about what kinds of code can be programmed into a computer. There are for more complex uses than your simpleton example can cover. 
JS frameworks are mostly fads. You don‚Äôt need to follow every fad. I‚Äôm still using jQuery as my primary ‚Äòframework‚Äô. Yes, it‚Äôs old, but I‚Äôm not in a hurry to replace it, because it still works. Eventually I‚Äôll move to React or something, but I‚Äôll make sure whatever I move to is mature before I bother with it.
oh cool, but for me that link doesnt seem to be direct still
But var does not work in such a way as to imply what you mean. Var there allows i to be used *above* where it is declared, which I'd absolutely not what you want. You're advocating doing something stupid.
If let, const, and var all existed since day 1 I'd still be using var where it is useful, because it is useful. Unfortunately I also understand people who want to be superstitious and who would rather forget var existed, just to make old code seem lame and give them another inane thing they can obsess to make themselves feel superior (when they really aren't). This stuff about only using const and let is just superstition, nothing more. It's basically saying it's okay to not master the language, just use whatever the herd mentality is saying to use - and that's pretty awful. 
You cannot leverage the behavior of var in any possible way that actually makes sense to use it over and above a declaration that is more appropriate in the correct context. Var is the way it is for the same reason as many decisions that were made in the early days of JavaScript : because it prevented people's entire pages from breaking due to stupid errors. So they eliminated the stupid errors and make massive assumptions on what the user meant.
Can a const variable be declared and then assigned ?? Like, const a; a = 10; And similarly for a list ?? const a[]; a[0] = 10; Can anyone explain me in detail of how const works for a list/array ??
Thanks. This was helpful 
Why should you never use var?
I don't agree with your assessment at all. So has all the code written in javascript for the last ~20 years been broken and stupid? Ummmm... no? It's entirely possible to write enormous amounts of well functioning code using var, and that has been the case for a very long time. But here you are saying that it's stupid. That kind of makes you look uninformed, or just... well, stupid. 
I understand where you're coming from, but maybe you don't really know javascript that well, and wish it were more like your favorite language? I quite like exactly how it was designed to work, and I like that it isn't like other languages. Maybe it's a little tricky if you're new to it, but in practice it's been really simple, easy, and powerful to use. 
Is there anything at all in JavaScript that is deprecated? I don't think they do that...
I think your problem here is that the makers of these framework‚Äôs goals (making a framework that solves a problem) and your own (being suitably employable) are not even really tangentially related. Seriously though - if all you know is how to use frameworks, then you‚Äôll be trapped in this cycle. They‚Äôre just tools after all - infinitely replaceable.
It depends on if you‚Äôre writing a for-of loop or an imperative for loop, and it‚Äôs worth distinguishing between the two. In a for-of loop, const does work to store the list item in our current iteration. It‚Äôs essentially scoped to each iteration, so there no issue in reassigning it to begin each iteration. I think it‚Äôs actually a better choice, as you don‚Äôt want a fundamental piece of information (the list element in that iteration) to be mutable in every loop. In an imperative loop, const won‚Äôt work, as the const assignment will occur only once before the first iteration. I agree that let is the better choice here. 
says you. Obviously you're the most correct programmer here! congratulations! you win! I'm sure all of your code is bug free! you are a true master! everyone should be just like you! 
Ffs please stop copypasting your dumbass answer to every post telling you you're an idiot.
On reddit flag ship (I know I know) looks a little weird but nothing seems too bad. 
Oohh it seems I've struck a nerve - where can I hit it harder? I'd like to see you flail around a bit. 
Yet the example that you've pasted to every reply in here calling you out for being stupid, is a stupid example that is better written in every other way, and you cite it as being correct. Get off your Hill, and grow up.
"let" is the right keyword to use instead of var due to scope issue with var because var has function level scope and let has block level scope, so my final advice is to use let over var in case of for loop. 
&gt; What the hell is going on? The great battle between imperative programming and declarative programming.
Wow you're really nice for telling me that. I think I'll sit down and shut up now while you tell us all what a big awesome brogrammer you are. So it seems you don't really know much about Javascript or have much experience with it, what makes you think you're sooooooo smart? 
You don't agree, but you are wrong. Var does not create a variable here, for future use. It creates a variable at the top of the block. You are explicitly writing code that does something different than what you want because YOU don't understand fully. 
You explicitly give an example that is terrible, and say it proves your point. Run along.
I know exactly *where* the variable is created, and I can manage that easily if my function is kept small. It's really not mysterious or difficult to understand, but you sure are blowing it up to be a sin against humanity. It's really quite easy to code javascript if you understand it, but it seems you don't, or barely do. 
I hope you know that just saying that is meaningless *because you have given nothing to back up your claim*. So go piss off you gnat.
This might be old school js but performance. If I‚Äôm not mistaken, using var for the iterator and cache should be faster than let. Of course, with Babel this isn‚Äôt a thing but still
&gt;Sure, I guess. Whatever communicates the idea that the behavior is so non-obvious that it needs a "gotcha" section of some javascript book to explain it. Non-obvious? Did you ever read anything about javscript? It's practically like the first thing anyone ever learns. 
My reason to avoid var is this: console.log(typeof x); //undefined, the variable isnt even declared! typeof operator doesnt throw even if the variable doesnt exist, with let and const the variable is in TDZ and would throw. console.log(typeof x); // Reference error, x is in TDZ let x; In loops, I always use let to avoid closure issues, such as: var arr = []; for (var i = 0; i &lt; 3; i++){ arr.push(function(){ console.log(i); }) } console.log(arr[0](), arr[1](), arr[2]()); 3, 3, 3 and not 0, 1, 2 With let you'd get the expected result of 0, 1, 2: var arr = []; for (let i = 0; i &lt; 3; i++){ arr.push(function(){ console.log(i); }) } console.log(arr[0](), arr[1](), arr[2]()); 0, 1, 2
I'm guessing you've never worked on a large team or massive codebase. If you're doing agency work, you probably can get by using just vanilla js. However, when you work in a codebase of hundreds of apps, with a team of hundreds of developers, you need abstraction. You can't manually push divs around anymore because it's just way too inefficient and repetitive. I'm not sure why you're so stuck on calling yourself "senior", because honestly, from what you've described, it sounds like you don't have a ton of experience beyond simple jquery-type frontend work
Ive been using it as long as it has existed. Id say that I've probably got more programming experience than you have years of life, but it's rare to meet people in the real world that are assholes of your caliber who aren't 60+. So maybe I don't. I've definitely got more social experience though. 
Object.keys(obj) then you could map
Your `data` doesn't appear to be valid JSON...
There's actually a little more to it than that. In any closures created in the loop, `let` variables will be bound to the value from only that iteration of the loop, whereas `var` variables will be the current value of the variable. For example: for (let i = 0; i &lt; 5; i++) { setTimeout(() =&gt; console.log(i), 1) } prints 0,1,2,3,4 for (var i = 0; i &lt; 5; i++) { setTimeout(() =&gt; console.log(i), 1) } prints 5,5,5,5,5
Okay, FormerGameDev, I've been coding Javascript every day for 20+ years, yes, since Netscape released it. And I've been programming far longer than that - so fuck off with your 'more epxerience', because I seriously doubt you do. You want to know who's the asshole here? IT's you for attacking me for giving valid reasons why var isn't the piece of shit you and others say it is. You're more like a fascist than a programmer. 
How would you do this with pen and paper? How about with plain loops? If you have trouble seeing it with higher order functions like map and reduce work from first principles to get there.
Use *var* as much as you want, just make sure it's used wisely though.
Yeah, it's kind of weird. I had thought you had to use `let` in this case, then later I noticed I had inadvertently coded like this at times and it still worked. You still have to use `let` if you use a C-style `for` loop, though.
So you declare it as the string 'defined'? That seems pretty hacky, but whatever works I guess.
So do you really think that the only reason entire javascript communities have agreed to disallow `var` in their common lint rules is because `let` and `const` are "new" features? Or is it more likely that in 99% of cases `let` or `const` make more sense? If you find a valid use case for `var`, then great you just have to disable the rule for that line.
Because hoisting can catch you off-guard at times.
That is a god awful example of terrible code. Can you give an example that might actually be used in real code? 
&gt; I'm guessing you've never worked on a large team or massive codebase. I guess the team is about 10 people and the code base is quite large. &gt; If you're doing agency work, you probably can get by using just vanilla js. I can't imagine the work for an agency that needs to keep all these separate websites up-to-date with the latest breaking changes from Facebook. &gt; However, when you work in a codebase of hundreds of apps, with a team of hundreds of developers, you need abstraction. Can you name some company/companies with hundreds of useful apps with hundreds of developers? &gt; You can't manually push divs around anymore because it's just way too inefficient and repetitive. Who says I was manually pushing divs around? From what I've seen, React architecture is a complete mess by mixing in CSS, HTML and JavaScript all into the JavaScript files, calling that a component, then that calling other components in some Mikado game of components which somehow make a "maintainable" app/site. &gt; I'm not sure why you're so stuck on calling yourself "senior", because honestly, from what you've described, it sounds like you don't have a ton of experience beyond simple jquery-type frontend work Maybe if you got off your high horse, you'd realise you don't need all this "abstraction" to make a useful app/website.
var was fine for decades so don't worry too much.
Not hotdog 
You're an idiot if you are calling that code terrible. It's *a fucking example*. If you think that's "bad code" then you're a dipshit for not even recognizing that it's a fucking example. And is it too difficult for you to understand? because if so then you really are a moron.
I meant _an example that someone might actually use in real code_, not just some example of bad code.
Never say never.
https://dev.to/sarah_chima/var-let-and-const--whats-the-difference-69e
JS runs in way more places than just the browser.
use redditisfun
It's just code, boys.
Although you aren't specifically asking for actual resume document advice I'd actually recommend that you put yours together and use it as a litmus test of jobs that you've found that you like. If you need a template, you can definitely use this one I made a while back: [http://bit.ly/resume-tmpl](http://bit.ly/resume-tmpl) The two biggest tips I could provide to any potential applicant would be: get an employee referral, and cater your resume to the job description you're applying for. Many companies will give priority to employee referrals, so it pays many times over to do your best to network with people from companies you are interested in. This can be done in a ton of ways, but off the top of my head some potentials would be: meetups, tech conferences, contributing to a project's repository, or just being forward about what you'd like to be doing in social situations ("I know somebody" is a common thing even outside of tech circles). The automated systems tied in to a lot of HR departments for hiring can be pretty unforgiving, so the closer you word things on your resume to the job description the better off you'll be for those tools. If you're applying for a job you also want to apply as close to the listing as possible, so don't sit on your application process if you think there is a chance you'd want the position. Finally, it will help you with career/job satisfaction if you find what things you enjoy because that will help you sift through the job postings for the ones with the most enjoyable descriptions. It obviously doesn't guarantee that the job will play out as described, but it'll at least let you filter the noise a bit. Example: I enjoy front-end JS, but actually prefer to use Go for back-end. I probably wouldn't work real hard to put positions with Node.js, as a key requirement, at the top of my pile.
PRO TIP: If you call him Hitler, you automatically win.
Is there a webpage interface? If so, another option might be to present a UI and store data in the browser's localStorage.
try running your code with a bigger loop than i &lt; 10 measure window.performance.now &amp;#x200B;
Use `const` everywhere you can and `let` if you have to. Better still, eliminate `for` loops with `let` variables completely by replacing them where you can with e.g. `map` and `forEach`. You shouldn't need `for` loops often at all for some kinds of programs. Generally less stateful variables makes your code simpler to follow and more robust. 
I agree.. but some people think they can exercise their fascist authoritarian tendencies by forcing their *opinions* on others. It's actually quite rampant in the programming world, authoritarians seem to gravitate towards programming. I don't care if people want to use let or const, or var - use it if you know it. But the fascists among us will tell you that to use var is evil now. And that's absurd. It sets a herd mentality that anyone who *does know* how to use var is uninformed, dumb, foolish, and not part of the herd. My mastery of the language is not dictated by what someone else thinks everyone else should do, but it sure seems like /u/FormerGameDev and many others would like that to be true. 
To arms!
I think I kinda of just did in my other comment to you. And it's deserved.
`var` defines `i` to the whole function. If that‚Äôs intentional, then declare `i` outside of the for loop. `let`/`const` are block scoped, they only exist inside the for block. No reason to intentionally use `var` any more unless you‚Äôre trying to make your code hard to understand.
[removed]
Generally let is the same as var except it is block scoped. A variable declared with let is only valid within the curly braces it's declared in. const is the same as let except you can't reassign variables declared with const.
Mac of PC? I dare you to answer. Let's throw some gas on the fire. ;) 
Not really, no. We've got object and array destructuring, but that's about it. 
Eh... Mac.
/u/ryeguy is saying that `var` doesn't necessarily indicate intention to use the value later and can't be relied on to do so because it was the only option for so long. You keep telling people the reasons for their opinions and seem to have no interest in hearing their actual reasons. Why is that? You'll most likely become a better developer if you stop doing it.
I like that you have a strong opinion, and use some examples to (attempt :P) to prove your point. It sucks that people are just downvoting you without providing a rebuttal. In my opinion, I think using var is a bad practice, it's more unnatural than let for sure. I think most programming languages use block scoping. That's the whole point of a block or a scope. var breaks that rule. In my opinion, the example you disagree with is more clear than using var in your preferred approach. Think about what that block of code is doing with the for loop. You are looking for some match and setting i to a particular value: let i = 0; for(;i&lt;whatever.length;i++){ if (whatever[i] === something) { break; } } [do something else with i (works)] By defining i before the for loop, you make it clear that a variable is being introduced. You can then add a neat comment to it later so people can understand the code easier: /** * index of whatever where something is */ let i = 0; // find index below for(;i&lt;whatever.length;i++){ if (whatever[i] === something) { break; } } [do something else with i (works, as long as you have post condition checking!)]
What code?
Old String.prototype methods were removed, whose function was to wrap the string in a html tag without escaping the string. This was declared a bad practice and deprecated. [String.prototype.blink](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/blink) is an example. Note that deprecated != removed. They already removed it might remove it in a few years. An example of a removed feature is [watch()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/watch) but nobody used it so it was "easy" to remove.
Learning that `var` hoists variable declarations to the top of the scope is absolutely not one of the first things anyone ever learns. This fact is normally left out of tutorials.
playerNumber is an indirection so that it can be dynamic and not be hardcoded 16. var playerNumber = 16; It turns into var player = testObj[16]; Did you mean something else by accessing? 
The array and object are mutable, they are not redefined when adding or subtracting items from them. Assigning the number 10 to a const fails because it is attempting to redefine an immutable variable.
This is the real answer. Let and var are different. What do you want to accomplish OP?
But, even for a variable we are just changing the value in the memory location right we are not manipulating the memory there right ? Also, can we reassign a number to the first entry of the array ?? I.e.. a[0] = 10; Then a[0] = 22; Here a is a const
Any of these https://github.com/d3/d3/wiki/Gallery
This is bad advice, there are still good reasons to use var. Async/Await error handling for example: try { var result = await foo() } catch (error) { // handle error } // do stuff with result
You are mutating the array. That it is an array is constant. The contents of the array are mutable. I would suggest opening up node or a browser developer console, or writing some code, to come to an understanding of what will and what won't work. Hopefully that will help you understand. I would recommend a course, but I learned JavaScript through writing it and having my code peer reviewed, so I don't know what to recommend. Hopefully someone else can give a good suggestion.
If you don't want a value to change, `const` is the best way to express that intention. If you're not the only person working in your code base, `const` keeps things easy to reason about. I use `const` in place of `var` almost 100% of the time. If you don't add the `var` declaration, you're setting a global variable and that code is going to become confusing/buggy so please be a little more careful and set `var` at the very least. Linting tools like eslint/jslint/jshint will help you catch those mistakes that make learning JS frustrating and unnecessarily difficult for beginners and experts alike. Personally, I don't use `var` at all anymore unless I'm guessing at something I'm typing in a browser console/node REPL and want my code to be re-runnable. 
But , the zeroth index of the array is indirectly the start of the memory location of the array right. So,will this case be similar to that of a const variable change if we want to change the zeroth index of a const array ??
No, I figured this out while in the shower. playerNumber isn't accessing anything, but it's set to a value to be used to access something. Now this makes sense.
Being JavaScript I wouldn't suggest concerning yourself with memory locations and pointers, those are implementation details that vary per browser, and could in some cases even be different in different versions of a browser. The contents of the array are not constant, due to the array being mutable. The only thing that is immutable when declaring an array with const is that it is an array, and that can not be reassigned.
Also, `let` declarations are not hoisted, right?
A simpler way to think about it: ``` const testObj = { twelve: 'Namath', sixteen: 'Montana', }; const playerNumber = 'sixteen'; const playerName = testObj[playerNumber];// 'Montana' const playerLastName = testObj.sixteen;// 'Montana' ``` The numbers are the keys and when you do `testObj[16]` you're looking at the object's [16] key. It's confusing in the first example probably 'cause it looks like this notation for strings/arrays. ``` const testString = 'Montana'; const firstLetter= testString[0];// M const capitalM = testString[5 - 5];// M ``` 
 let result; try { result = await foo() } catch (error) { // handle error } // do stuff with result
Thanks for the comment and not just an insult. The example code leaves out a lot of context, probably. Here's another attempt at completely useless code that is only here to provide an explanation of formatting (disclaimer needed because apparently people can't understand that this isn't a coding challenge, it's an example of a coding pattern, it doesn't need to produce useful results or be "beautiful code"): (function(){ var something[0,1,2,3,........,100]; // this is an ES13 feature that fills an array if you use ........ this many periods (j/k). //========================================== function example1(){ let somethingelse = Math.random() * 100; //----------------------- let i = 5; for (;i&lt;100;i++){ if (something[i] === somethingelse){ break; } } if (i &gt; 30) { return i; } else { return somethingelse ; } } //========================================== function example2(){ let somethingelse = Math.random() * 100; //----------------------- for (var i = 5;i&lt;100;i++){ if (something[i] === somethingelse){ break; } } if (i &gt; 30 ) { return i; } else { return somethingelse ; } } //it's an example folks, it's not supposed to do anything useful! })(); I find it "unnatural" to have for next loops written without a first argument. let i = 5; for (;i&lt;100;i++) It looks like a weird reverse happy face (; it looks like there's something missing - oh yeah, you have to go find it, it's above. It's a bit disjointed. That's a waste of my time. I don't really like the (; in a for next loop, I find it one of those programming style choices like using spaces that I just don't prefer at all. Breaking up the for loop assignments is what looks unnatural to me. And it's forced. for (var i = 5;i &lt; 100; i++) Oh look, there's i, it starts at 5, goes to 100, and increments by 1. Very easy to read, and understand. In this case, var works perfectly fine, has no side effects, and has always worked, and will always work. It's a simple functions. Keep your functions *simple*. That's half of all the best practices combined. Rule # 1. if (i === 5) { return i; } else { return somethingElse; } There's i again, okay, no problem, it's easy to see what's going on because the function isn't a million lines long. You don't even have to understand what the for next loop is doing (in this case it's a nonsensical example), but the flow should be entirely clear. If it's a thousand lines long and confusing then it's being done wrong, and const and let won't save you anyway, good luck with that. Can you even see a little bit how breaking up the for next loop looks more unnatural than just using var? I really have to say, my example of var is easier to read than let, and I'm not really sure how that isn't entirely clear - it practically seems like common sense. for (;i &lt; 100; i++) -vs- for (var i = 5;i &lt; 100; i++) There's something missing in one of them, and that just seems goofy to me, while having var inline seems completely natural and expected. I've been coding for 38 years, it's not like I'm just learning this stuff, and it's not like I don't have good reasons behind writing code this way. This lame herd mentality of "never use var" is nothing but superstitious programming. 
Correct (same with `const`)
they all work just fine, stop being melodramatic we need to see your code to see what mistake you made
So, on a high level, is it that we can manipulate the elements of the array (Add, Delete, Update) if it is declared with const ??
Really? You copied and pasted script into script tag into an html document then ran it on a local server?
I'm surprised I had to scroll this far down to read this! Completely agree, for loops should be used rarely, if ever.
https://www.reddit.com/r/javascript/comments/a50jte/is_it_best_to_use_var_or_let_in_for_loop/ebjn7g3/
no, i looked at them in the browser in the gallery. i've also been doing d3 since it was still called protovis. either you can give us your code, or you can sarcastically fight against the people trying to help you, and not get help.
I think you're getting screwed up because JS is weakly typed. JS object properties are mapped strings to values, in this case the property names are 12, 16, and 19. In your example replace var playerNumber = 16; // Change this Line var player = testObj\[playerNumber\]; // Change this Line with var playerNumber = "16"; // Change this Line var player = testObj\[playerNumber\]; // Change this Line You'll see that you it can still access the property and returns the value "Montana" in player. This was a pretty awful example to give if there was no explanation of what's going on here, btw.. criticism of whoever gave you this example. Try this, add a new property to the object: var testObj = { 12: "Namath", 16: "Montana", 19: "Unitas", twelve: "Something Else" }; var playerNumber = "twelve"; var player = testObj\[playerNumber\]; See? You're not really using numbers - which is why this is an awful example. This is why arrays are different from objects by the way (from your other posted question), arrays are indexed by numbers. If you want you can get an array of object keys, do playerNumbers = testObj.keys(); Now you can do your numeric iterations through the keys array and do some more exploring of JS Objects. &amp;#x200B; var testObj = { 12: "Namath", 16: "Montana", 19: "Unitas", NaN: "nanna" }; &amp;#x200B; // Only change code below this line; var playerNumber = 15; // Change this Line var player = testObj\[playerNumber-3\]; // Change this Line var player1 = testObj\[NaN\]; var playerNumbers = Object.keys(testObj); &amp;#x200B; console.log(player1); console.log(playerNumbers.length); console.log("\*\*\*\*\*\*\*\*\*") &amp;#x200B; for(var i = 0; i &lt; playerNumbers.length; i++){ console.log(playerNumbers\[i\]); } console.log("\*\*\*\*\*\*\*\*\*") for(var n in playerNumbers){ console.log(n); console.log(playerNumbers\[n\]); console.log(testObj\[playerNumbers\[n\]\]); }
What is an example of something you would do with i outside of a for-loop? (Genuine question, I'm not being militant) &amp;#x200B; Isn't i only an iterator whose sole purpose is to access array data? What would you want the last value of i for outside of a for loop? (I can see it for the case of implementing a "length" function of an array since it would return the last index of the array, but we already have that functionality. What am I missing? &amp;#x200B;
Holy shit I never knew that thanks 
&gt; If you don't want to change the value, then don't set it up so it gets changed in the code. In addition to what others have said about displaying intention, `const` is a best practices safety feature. Like many such features, they would be unnecessary if people never made mistakes. Instead, they exist to help you catch your mistakes. Suppose you're writing some code and you define a variable `var someItem = ...`. Maybe you have no intention of changing `someItem` so you don't. Then months later, you need to add some logic to the file and because you forgot that `someItem` has been used already, just go ahead and declare it again as `var someItem`. This could obviously introduce a problem which will only show up at run-time, perhaps under hard to reproduce conditions. Using `const` instead of `var` would head off this bug before it wastes any of your time.
Great attention to detail!
In both cases you should probably be doing your stuff with the result inside of the try block. 
Using a linter went a long way towards helping me break the habit.
I wasn‚Äôt being sarcastic at all, I was just asking. I am not sure why it is not working for me.
This kind of dogmatic thinking and inability to accept new ideas is absolutely why older devs have a hard time getting hired. &amp;#x200B; You might be used to var, and yes, if you understand all of its quirks, it works just fine. &amp;#x200B; But it results in code that is less clear by definition. Code is inherently collaborative, and clarity is important. &amp;#x200B; [https://www.youtube.com/watch?v=HMqZ2PPOLik](https://www.youtube.com/watch?v=HMqZ2PPOLik)
`let i;` `for (i = 0; i &lt; 100; i++) {` `return i;` `}` &amp;#x200B; Everyone here agrees that leaving the first argument blank looks stupid. Var is not a solution for that. You're the only one proposing that strawman because it makes you feel like you're right. &amp;#x200B; Using let instead of var lets you express two different ideas that you can't with var: `let i;` `for (i = 0; i &lt; 100; i++) {` `return i;` `}` and `for (let i = 0; i &lt; 100; i++) {` `return i;` `}` &amp;#x200B; Var only allows the first one, and it does it with less clarity than the let alternative. Do you still think it's useful?
It wasn‚Äôt fine. It was insane. It made programming harder for no reason. 
The animation for #2 is wrong. The call to console.log will happen as the promise chain is created so "done" will be logged immediately. No idea where the "null" comes from.
third and final time i'm going to say this [we need to see your code before we can help](gist.github.com)
The array reference is constant, not the array. Same goes for an object
Note that with const, the key is that you cannot *reassign* the variable, but you can still "edit" the variable. I.e. if you declare an array with const, you can add, remove, edit that array like usual but the const declaration will permanently point to that array. It is proper practice to always use the least scoped declaration as needed, and therefore you should always use const unless let is necessary, but var is now considered outdated. You should also look into arrow functions, which should also be used to declare functions with const.
&gt; In both cases you should probably be doing your stuff with the result inside of the try block. Excuse me homedog but your try blocks should have minimal code in them. It's a borderline antipattern to do what you're suggesting.
That's an anti-pattern. Keep you try blocks minimal so you don't catch errors you never intended to catch and hide bugs this way.
Correct. Let me put it this way: 90% or more of what you write will be const. Honestly I think the only time I end up using let is when I'm using a function I know could throw.
 let i; for (i = 0; i &lt; 100; i++) { return i; } This is no different than using var in the context of my example, and it's false to suggest it's in any way better, just because it makes you feel like you're right. Your example is a strawman. 
&gt; This kind of dogmatic thinking and inability to accept new ideas is absolutely why older devs have a hard time getting hired, especially with JavaScript. &gt; &gt; Where did I ever say don't use let and const?? I never did. It's dogmatic to say never to use var. It's the opposite of what you just said.
Pretty much every JS expert agrees: never use var. So unless OP wants to accomplish bad code, he shouldn't use var ever.
i do not hate javascript I love javascript
https://www.reddit.com/r/javascript/comments/a50jte/is_it_best_to_use_var_or_let_in_for_loop/ebjn7g3/ There could be a million uses for it. It's really whatever needs programming and how someone decides to do it. Sorry but react apps account for probably for about 0.000001% of all programming that's ever happened, but javascript coders like to think they're so important and silly things like var vs let vs const are stupid arguments, especially when someone tells you 'never use var'. 
&gt; do you want i to be available to the closure the for loop is a part of let i; /// some code for(i=0;condition;++i) { /* do stuff */ } No reason to use var for this.
Happy cake day!
That's not unnatural and forced. That's the optimal way to do it for readability.
So does sthwt mean you can use the Chrome web store and Chrome web applications?
It already is
Don't worry it'll never do that
This guy JavaScripts
MS rendering engine was actually much much much worse than chrome
That's your opinion, and only an opinion. 
There won't be a windows 11 (or at least not in the next 15 years) . It's reached the end of its naming scheme
I'm well aware you can declare the variable prior to the block, but this was a simplified example. There are real world cases where this becomes impossible / unlegible 
Only answer here that has a cached for loop. I like it. 
But, if the zeroth index of the array is the reference, then changing it will be completely opposite right ??
If you didn't really understand JS
There are still valid reasons to use it. The problem is that many people don't bother to really learn JavaScript and then are confused by scope
Yeah, I've seen you paste that over and over. All I have to say is that it seems like it comes down to what you find more readable and what others find more readable. &amp;#x200B; I believe that if you want to process data in a loop and you want to access that data outside of the loop then you shouldn't declare it within the loop, it should be declared in the scope you want it to be. You can achieve what var does with let (other than hoisting) in terms of not limiting the scope to the block it's used in. &amp;#x200B; Generally, I think the idea is to make it very explicit just by looking at it what the scope of the variable is. If I'm reading a really tall file and I see variables being used and haven't seen it declared, yet and it's declared at the bottom of the file, that's a long time to not know where the variable came from. &amp;#x200B; I don't know, it could just be my perspective from what I was taught in my courses, but to me it doesn't make sense to declare things of ambiguous intent and scope. &amp;#x200B; I saw someone talk about var being used for global scope, but can't you just put let at the very top level? I just don't see the benefit. Var leaves room for interpretation and let is explicit in it's intent scope-wise. &amp;#x200B; I don't know, I'm talking like I am a great programmer, but I'm just a student, so if I got something wrong please correct me, but please hold the cavalier attitudes. 
If the code works, has no bugs, and is reasonably easy to read and follow - then it doesn't matter if it uses let or var. People here are way too stuck-up and wanna-be authoritarians. Some of my closest friends that I've worked with got rich working at a tech mega-corp, they invented literally billions of dollars worth of IP with their programming skills - they're the only ones with opinions that I care about and I have no worry at all that I'm doing anything wrong or incorrectly - so the downvotes don't bother me at all, nor do the half baked opinions masquerading as authoritah. And to the haters here I say, use whatever you want to use, but don't goddamn tell me I'm doing it wrong when I know that I'm not. 
Why does it exist if you should never use it?
Care to give a valid reason? 
No. Understanding the rules is simple. But var is objectively more complicated than let, since it has more rules. That is an indisputable fact. None of the special behavior of var is actually useful, though. So it is only extra mental baggage, no matter how trivial in each individual case. Const is the simplest of them all, and should be used whenever possible. But despite let being more complicated than const, it has useful properties, that makes it worth it in some cases. 
You aren't wrong to use it. But, and I hate to make "You" statements, but you sound very stuck in your ways. Which is fine. You don't necessarily have to change, but I don't know if that's the best attitude to have. It's good to be skeptical about the new buzz words, but it's very clear why the movement is heading towards let and const. You aren't wrong for using it for your own purposes since you've known it for years with your experience. &amp;#x200B; That being said, let and const and var have their uses. I have yet to see a usage of var that let cannot achieve (in this thread), but I wouldn't be so cavalier about your usage of var vs let and acting like there is some fascist conspiracy against you. Again, I'm sorry I'm addressing you directly and not your points, but it's hard not to with how cavalier you are about the whole thing. &amp;#x200B; But, hopefully someone in this thread can provide a practical use case for var that has objective advantages over let that aren't about readability. And since I'm not a heavily experienced programmer, generic functions that aren't practical aren't very easy for me to understand their practicality. Anyways, I digress.
For JSONP, it should be used as the source of injected SCRIPT element. It shouldn't be used with XHR.
Alternatively, since relocating the button to elsewhere on the page is a matter of changing the page layout, you can override the page's style using CSS with Stylus addon.
Because js was really bad at the beginning and a lot of its worst parts were fixed later on. Like var vs let, or == vs ===. The old ones exist because lf backwards compatibility but there are hardly any (none) reasons to use them nowadays.
I might be brain farting right now... let i; let msg = "count "; for(i=0;i&lt;10;i++) { console.log(msg + i); } console.log(i) In chrome console, the final console.log produces 10... but isn't the for loop supposed to break at 9 (middle eval of for statement), why does it also increment?
I am satisfied with this answer, thanks. 
Var was never fine. 
That's only a matter of assigning a new value to an object property. You simply need to get a reference to the IMAGE element's object, then assign one of its property with a new value.
Cat üê±
There is no valid reason to use something that's hoisted to the beginning of the function when declared somewhere in between.
I mean... There are uses for var. They're avoidable, but sometimes it can make for more readable code if you do want it accessible outside the block. In general though if you aren't both 100% confident and also aware you're making a lesser code choice in service of a specific purpose it's not worth worrying about, just use let. 
I'm gonna be *that guy*. I'm sorry. For the benefit of newbies to ES6 reading this, `const`s, can *change* (in object or array mutations for example), but they can't be *reassigned* (they will always point to the same string, object or array in memory). `let` is for values which *can* be reassigned, like the `i` we might use in a `for` loop.
&gt; you sound very stuck in your ways. I use const and let all day long. I also use var sometimes. It depends on what I'm doing. So do I still sound "stuck in my ways"? &gt;I have yet to see a usage of var that let cannot achieve So what, there are things var does that let could never achieve. It's still no reason to not use let, and there is no good reason to not use var either. It's really splitting hairs but people act like let is sooo much more superior and will instantly make your code better - but it will not. 
The getElement**s**ByClassName method returns [HTMLCollection](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection) You want just one element - not a collection. ``` &lt;ul id="month-list"&gt; &lt;li id="listing-March" class="listing"&gt;&lt;/li&gt; &lt;li id="listing-April" class="listing"&gt;&lt;/li&gt; &lt;li id="listing-May" class="listing"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const p01 = document.getElementById('month-list') console.log(p01.firstChild.nodeName) &lt;/script&gt; ```
Use `let` instead of `var`, it's a new keyword that makes variable declarations in line with many other programming languages (block scoped) and in general offers less gotcha moments than `var`. like this is totally fine with `var`: ``` var foo = 3; var foo = 4; var foo = 5; ``` `let` doesn't allow it: ``` let foo = 3;//Cannot redeclare block-scoped variable 'foo'. let foo = 4;//Cannot redeclare block-scoped variable 'foo'. let foo = 5;//Cannot redeclare block-scoped variable 'foo'. ``` e.g. it is also totally fine to use a variable with `var` before it is even declared: ``` alert(foo); var foo = 3;//fine, alert will print undefined ``` `let` errors in this case: ``` alert(foo); let foo = 3;//Block-scoped variable 'foo' used before its declaration. ``` Also, this will print 3 ``` var foo = 2; { var foo = 3; } alert(foo);//3 ``` with `var` they will be treated as the same variable even though there 2 seemingly independent `var` declarations see `let`: ``` let foo = 2; { let foo = 3; } alert(foo);//2 ``` So use `let` ;) Use `const` if you don't intend to *reassign* a variable. It makes mostly sense with primitives like string, number, boolean because for complex types like array or object you can still change its members afterwards like: ``` const myConst = { a: 0 }; myConst.a = 3;//ok ``` `const` only prevents reassigning, so this will fail: ``` const myConst = { a: 0 }; myConst = { a: 3 };//error ``` &amp;#x200B;
This is the juice.
try this https://z-pattern-matching.github.io
You're strangely proud of showing around your bad code.
Please never shoot yourself in the foot, it's a bad idea!
I disagree. Choosing var because you need to access your variable outside your block scope does not make your code more readable. It might look more readable on the surface, but the result is less intuitive, less consistent, and buggier code.
You can't tell an example from code. What do you think this was a coding challenge dipshit? You're pretty dumb if you don't know what an example of a coding pattern looks like -what were you expecting, a fast fourier transform? A convex hull algorithm? Sorry, it's not about the code, it's about a coding pattern and you can't tell the difference. 
Always use it the Disney way: let (it go), [https://www.youtube.com/watch?v=moSFlvxnbgk](https://www.youtube.com/watch?v=moSFlvxnbgk). 
Google how to write unmaintainable code, spend an hour reading it, then talk to me
In my opinion `for of` and `for in` are much more readable than `map` and `forEach`
You could use [`_.groupBy`](https://lodash.com/docs/4.17.11#groupBy) + reduce
As the advocate of "var" in this conversation, I'm pretty sure you're the one who needs to get Googling.
As the other redditor has mentioned, it's an invalid JSON. But chances are that it supposed to be an array of arrays. i.e. [['Jane', 2], ['Kyle', 7], ['Jane', 7], ['Kyle', 2]] But since you mentioned that you can't use `map()` or `reduce()` on it, chances are that you've retrieved the JSON data as is without parsing it. i.e. you've used `responseText` of an XHR, or `text()` of a Fetch response. For XHR, you should set its `responseType` to `"json"` before sending the request. Then retrieve the JSON using its `response` property. For Fetch, you should retrieve the JSON using the response body's `json()` method. Both methods will get you an array instead of a string.
Thanks, I have thought about doing this and I have read about shimming, imports-loader, script-loader, and export-loader. However I was thinking if there is a quick and dirty way just to bundle all vendor scripts in a certain order with webpack so that I can get going and set the aliases and all the complex stuff later? I have the exact same case as you. I am loading all the vendor scripts once in the beginning. Any tips how should I start? I already have other tools set for webpack like less and babel working, but now I only need these vendor files.
You obviously didn't Google what I recommended. It's funny as fuck and the fact that I recommended it completely derails my argument. Hot tip: I never use var, I just hate blanket statements
If you don't want to think about it some lint tools will autocorrect to use const or let for you
If you are good with core spec it doesnt really matter what framework. You read the docs an get at it. Frameworks don't reinvent the language itself. Not to mention that your cursed React doesnt really introduce new concepts. That being said if your 'seniority' constitutes from 5 year iteration of jQuery in repeating 1 year five times, without ever learning actual JS you'll have a hard time. 
&gt; let whatever = [1,2,3,4,5]; &gt; let index = whatever.findIndex( v =&gt; v === 3 ) You're welcome. In case you do find a use case that isn't covered by the standard lib, I still prefer version #2, simply because using var easily turns your code into a bug ridden mess. In case #3, for example, you make it look like you're declaring var i inside the var, which isn't true because it's being hoisted to the beginning of the function. 
In which case a future fellow developer changes it to let and then it breaks and they scream at you. Either that or you add a comment explaining it's fine in which case they just scream at you.
I also dislike blanket statements but I'm having a hard time working out if that one is false. I can't think of a situation where abusing the scoping of var leads to better or easier to read, or more helpful code. When would writing worse code help anyone?
&gt; using var easily turns your code into a bug ridden mess That's hilariously false. But you're also not as smart as you think you are.
Here's a fun video covering stuff like this: https://youtu.be/Nzokr6Boeaw
I don't think you can gain a lot here. The IDs look like ASCII encoded binary data which makes it quite random. Compressing random data will not do you much good. Compression shines when you have text with many repeating patterns, which is not the case for random data. You might try to use a more compact transport medium instead of JSON. msgpack is an easy replacement but won't give you much either. Personally I quite like x690 which is the transport medium used below SNMP. It's very old, and back then every byte counted. Especially for networks. I've written my own implementation of it a while back in Python. It's not too difficult. And it's quite space efficient. If space really is a big issue, you could use that and also leave out the field names. It will make everything more opaque and error prone, but that's the price you pay for more efficient transport.
&gt; But you're also not as smart as you think you are. You're pretty desperate.
It is not what you ask but good to know, use "const" in "for...of"
&gt;Sometimes worse code helps people you work with. Are you a troll? Also, for any newbies: learn as much as you can, then *don't* go on anything called "gut feeling". Rather, listen to community and other professionals who clearly say don't ever fucking use `var`. Source: a "professional"
Thank you for clarifying. I was indeed thinking about optimisations in my typescript backend and it would be strange exchanging for-ofs mit whiles. 
Coming from C++ was how I learned. Bless TypeScript and tslint. (And jslint and jshint for js projects)
In that case, why not use promises?
What's the usercase and what are the expected output? 
You need to find the key using a value on a custom object. Still no use case for var?
I have created multiple roles, the roles are assigned as for ex. 'role: 4'. I want to do different things with different roles so when it has role: 4 do this code, when it has role 3 do that code.
The same user can have different roles? Or why is it in an array?
This is correct. For a time people wrongly thought `let` was the correct approach (browser weirdness?).
Just edited my post. Leaving off field names can be a bit tricky as a result. Might still be possible to separate objects of different *types* first, then ordering the values in a specific manner and leaving empty optional fields as `null` values. (this implementation seems a bit 'brittle' in my opinion, considering the inconsistency of fields. Might try it as a last resort) 
Why? I find for in an for of pretty usefull and pretty sure for loop is faster than map function. There are definitely cases where 'new' for loop is useful and much more cleaner than other options.
No, the user has only 1 role. let's say we have **User1** with role **assistent(id**=**3)** and **User2** with role **client(id**=**4)**. For users with the role **assistent**, so **id**=**3** do this code. For users with role **client**, so **id**=4 do this code. &amp;#x200B; That's it. Sorry for not explaining my situation here.
As an aside, does anyone else hate 'let', not the functionality - just the use of it as a word in the language? 
You're delusional. 
How do you replace map with `for of`? To be honest, I rarely even use `forEach` because loops like that are usually for modifying stateful variables and I avoid stateful variables wherever I can.
&gt;Or why is it in an array? I don't know, that's how the CMS outputs it. I am using Directus CMS
You can loop over the roles property and use a switch/if else statement to handle each case. data.roles.forEach( roleData =&gt; { If(roleData.role === 1){ //code } If (roleData.role === 2){ //code } });
``` const targetVal = 4; const someObj = { a: 2, b: 4 }; Object.keys(someObj).find((key) =&gt; someObj[key] === targetVal); //b ``` That's how I'd do it. Is there a better way?
Well the thing about blanket statements is they're pretty easy to disprove. All you have to do is find a single counter example. Can you give an example where using var gives an advantage like making the code more intuitive?
If you're specifically need var, then you're doing it wrong. 
&gt;Use const everywhere you can and let if you have to. I've been using const like I live and breathe const and just 3 days ago I was mandated to use let for whatever the fuck reason. Kill me please.
 const actions = { 1: () =&gt; console.log('role was 1'), 2: () =&gt; console.log('role was 2'), 3: () =&gt; console.log('role was 3'), 4: () =&gt; console.log('role was 4') }; roles.forEach(({ role } =&gt; actions[role]());
You're extremely cocksure. It's pretty sad you're even getting a single upvote. Your code must be horrible if you can't figure out how to use var. 
I had the same query as a novice, and after reading the help docs, i arrived at the conclusion that using let for the scoping and avoiding name conflict does seem more appropriate
That's not how you use setTimeout for (var i = 0; i &lt; 5; i++) { setTimeout((x) =&gt; console.log(x), 0, i ) } FTFY 
 style.color = '#' + hexstring;
So now all code written with var is suddenly declared to be shit? That's funny, and just plain wrong. 
THANK YOU! I *hate* it
1. Can this be seen working somewhere? 2. When you say "my event listeners disappear", what **exactly** do you mean? Which event listeners? All? Some? How did you notice they "disappear"? Do you see the button in the Devtools inspector with the event listener and then without it? If so, what are you doing when that happens?
This entire post is full of the dumbest comments ever pretending to be the authoritah about javascript. It's pathetic how dogmatic some people are being about anyone who might want to (and know how to) use var. It's just the dumbest thread I've seen here in a long time. 
If you use let, the ‚Äùi‚Äù variable is only avaliable in the for loop block. If you use ‚Äùvar‚Äù on the other hand, you can use the ‚Äùi‚Äù variable outside the block. I prefer using let because I can use the same variable name multiple times without mixing them up.
If you are resorting to stuff like that then it might be a better idea to rethink the structure of the function. I don't think I've used var for ~2 years now and I do not miss it.
No one said "shit", but to be able to have the level of code legibility and certainty of "no gotchas/wats" all code that uses `var` needs to have all variables pre-declared on the top of the function (or file if outside functions), and not all does. Code using `var` elsewhere (i.e. not on the top of the function) is still readable, just *not as* readable and *not as* easy to reason about due to additional mental overload of thinking about non-intuitive function scope. Same goes for `let` and `const`, since JS still does top-of-scope hoisting, it's still required for legibility and intuition that they either be declared on the top of the block scope or, at the very least, right before they're first used. It's just that it's much easier not to botch these rules with `let` and `const`.
Mpj does a good job of explaining the differences [https://www.youtube.com/watch?v=sjyJBL5fkp8](https://www.youtube.com/watch?v=sjyJBL5fkp8)
I too dislike blanket statements (for example the `===` rule *does* have exceptions on data boundaries when used for sanity checks pre-casting and even a few others, all very seldom, but still relatively common), but I too have a very hard time figuring out an example where `var` would be superior. So, given how you are the one with extraordinary claim, the burden of extraordinary proof is on you here.
&gt; edit: i'm on a desktop Hey, why don't you try MyFavouriteRedditMobileApp? /s
Not Cat
&gt; pretty sure for loop is faster than map function You are also right. The wannabe Haskellers in JS are getting ridiculous.
 const array = [1, 2, 3] for (const i in array) { array[i] = array[i] * 2 } // or const array = [1, 2, 3] const newArray = [] for (const item of array) { newArray.push(item * 2) } &amp;#x200B;
that's a good point. I'd forgotten that JSON doesn't care about whitespace!
Think about it like this. When you start some JS code, back in the day you'd just define a bunch of vars first right? Maybe a var to point to a DOM element using jQuery, or a var for an array or something. But here's the thing, if you define them right away they're global scoped, so you gotta keep track of them through ALL of your code. If you accidentally change a var when you're not supposed to, or overwrite one by forgetting that you had already defined a var with the same name, you can end up screwing things up royally, and you'd have to hunt through ALL the code to keep track of where you went wrong. So that's why vars were defined inside functions instead of globally, to limit them as local variables. But of course, it was hard to track exactly where the local scope was because of hoisting: you call a var where you want it, but then JS "hoists" it up to be declared first, and then maybe this fucks up something else, especially with the var i because we reuse it so much for for loops. Let, however, is block scoped, meaning it will only be useful in the block it was declared in. So it won't screw things up outside of the block or even stuff nested further in. Most of the time you're only declaring something to use it within that block, you're not gonna call it again outside, so why not just use let instead of var every time?
as i mentioned in the above comments the problem consists within the lines of 62-88, when am on ginseng.html i can see the eventlisterners of the + - x and when i change to cart.html i can't.
Why don't you showcase a single example where block scoping is superior to function scoping? That would be easy to do and prove your point.
I hadn't realised you could pass params into setTimeout. The classic interview question always expects you to correct `var` to `let`, I might use this version in future to make them think.
This deserves gold
That way works, yes, but I'd say it is ONE of the ways in which you can solve it. for (var key in someObj) { if (someObj[key] === targetVal) break; else key = null; }; More readable, beginner friendly etc. Should also run faster than the code you posted, so where you are concerned with performance, would think this would run faster. I know my opinion is not the popular one here, but all your code is doing is offloading work to functions and I'm not saying this isn't a good way of doing things, but I seriously hate blanket statements. If you have a business where you can afford to hire only JavaScript beginners, I'd take the solution I've presented over arrow functions anyday just for the readability alone.
Point out to me where I said code using var is shit please and I will correct it. I said it's worse than equivalent code written using the more easy to reason about scoping of let and const. Which I firmly believe is completely true but I'm more than happy to be convinced otherwise. So far no one has given a compelling argument for it tho.
Note that some black magic goes on behind the scenes when using let expressions in a for loop's parentheses, and avoid behavior that relies on it, to help with making your program clear to understand. https://youtu.be/Nzokr6Boeaw
I couldn't believe it was true until I executed in the console.
But how does it do it? Can you provide example? I don't require / import any of the external libraries as they are legacy code. They don't work as modules. Some scripts even require other libraries in order to work. Also I don't want to use CDN. 
I didn't understand this quite well. if you have the time, can you please elaborate ?
Why this over `const newArray = array.map(x =&gt; x * 2)`? Unless I'm missing something, it's way more concise and less error-prone with `map`.
From the above answers and in general, in that case you're better off using `let` than `var`. /u/ings0c 's method is far better, not just because it's a one liner but also because it will be faster. Using for ... in ... is kinda slow since it uses reflection (hasOwnProperty) to check each key for whether it's a prototype key or instance key before executing the code block. It also doesn't require you to explicity mutate key back to null if it can't find anything, since the find method will return undefined if it can't find the desired value. The biggest issue, however, has already been covered in that what you've provided won't be async-safe, if you use `var` and an async method inside your block scope, that var will always resolve to the final value, not to the value that you expect.
Of course I ‚Äùcan figure out how to use var‚Äù. Anyone can. I used it professionally for over a decade. I am also humble enough to realize writing perfect code is impossible, because we all constantly make mistakes, and we can use all the help we can get. That is why we have high level languages, garbage collection, types, unit tests and test servers. We don‚Äôt deploy asm straight to production without testing. 
&gt; Writing a public API does not require either markup or CSS, but may still be the exclusive work of the frontend dev. He might call himself a frontend dev, but writing a public api is backend work.
There seems to be a logic problem, I'm afraid. You have two ways in which the cart is updated. One is the block on [lines 7-23](https://github.com/Hikhakk/waffle-app/blob/890624562a6cef228816821d2dfc883f399c41ef/cart.js#L7-L23) and the other is the event listener on [lines 26-44](https://github.com/Hikhakk/waffle-app/blob/890624562a6cef228816821d2dfc883f399c41ef/cart.js#L26-L44). The second one is the event listener fired when an "Add to cart" is clicked. This happens on the `Ginseng.html` page. It gets the [product name from the button](https://github.com/Hikhakk/waffle-app/blob/890624562a6cef228816821d2dfc883f399c41ef/cart.js#L29) to add it to the cart... and when it does add the product to the cart, it ends up [calling](https://github.com/Hikhakk/waffle-app/blob/890624562a6cef228816821d2dfc883f399c41ef/cart.js#L42) `handleActionButtons`. As I said, this works. But the first block on lines 7 to 23 is meant to load the current contents of the cart when the page is loaded. [Carts contents](https://github.com/Hikhakk/waffle-app/blob/890624562a6cef228816821d2dfc883f399c41ef/cart.js#L3) come from `localStorage`. This is, so far, right. But then again, to work, this block [still needs to read](https://github.com/Hikhakk/waffle-app/blob/890624562a6cef228816821d2dfc883f399c41ef/cart.js#L13) the `addToCartButtonsDOM` because [it tries to associate](https://github.com/Hikhakk/waffle-app/blob/890624562a6cef228816821d2dfc883f399c41ef/cart.js#L17) the product name in the cart with the one on the "Add to cart" button to call `handleActionButtons`. But here's the problem. In `cart.html`, **there are no "Add to cart" buttons**, and so [the loop on line 13](https://github.com/Hikhakk/waffle-app/blob/890624562a6cef228816821d2dfc883f399c41ef/cart.js#L13) never executes anything and `handleActionButtons` _is never called_ in `cart.html`. You need to consider the fact that in `cart.html` you won't have the "Add to cart" buttons. You probably need a _different, separate function_ to manage the buttons on `cart.html`, one that only cares about the +/- buttons and the cart contents, but does not update other, non-present, buttons.
C300
In my opinion it's less explicit, especially when the map callback is complex. And if I'm gonna do something when it's complex, I'm also gonna do it when it's simple, for consistency and quicker refactoring.
I find map, filter, reduce etc. more readable in every single case, especially when you start to chain them, it's easier for me to follow than several if statements (usually nested) inside for loop.
Why can't we use let in the above? I'm a JavaScript noob, sorry.
Thank you boss!
That's because the iterator happens at the end of the for loop and the conditional check "&lt;10" happens before start. So it +=1, and then escapes the loop since !( i &lt; 10) since it is now 10. Then the final log happens
Yes, taking a screenshot can change the colour if you don't make sure to load the image with the right colour profile. I've had screenshots be several hue/brightness/saturation points off from the intended original before. [Here's a thread](https://forums.adobe.com/thread/1815636) on how display/colour profiles can interact to make screenshots visibly wrong.
Exactly
&gt; but sometimes it can make for more readable code if you do want it accessible outside the block. Could you provide an example of where you think this would be more readable?
`let` and `var` have different scoping rules. A variable defined with `var` is available to the function it is within. A variable defined with `let` is available to the *set of curly braces* it is within. For example: function example() { let active = true; while (active) { var name = "Milo"; active = false; } console.log(name); } example(); This will output `"Milo"`, because `name` is available anywhere in the function. But if you just change the `var` keyword to `let`, the last line will throw a ReferenceError, because `name` was only ever available within the while loop where it was declared. This has more effects than you'd think. Consider this: var things = []; for (var i = 0; i &lt; 20; i++) { things.push(() =&gt; console.log(i)); } things.forEach(f =&gt; f()); For each number 0 - 19, we define a function that outputs that number, and store it in an array. Then we call every function in the array. If we use `var`, then the result is that we print `"20"` 20 times, because `var i` made a variable accessible throughout the function, and each iteration of the loop reassigned it; at the moment the conditional measured false, `i` was 20, so the reference is to 20 in all those functions. If you use `let`, the numbers 0 to 19 are each printed once, because `let` defined a totally new variable in each set of braces, and each function retains a reference to a totally separate value. The second difference is that `var` is hoisted and `let` is not. 'Hoisting' means that the declaration of the variable (but not the assignment of its value!) is effectively moved to the top of its scope at runtime. That is, this code: function example() { console.log(catName); var catName = "Milo"; } is actually converted to function example() { var catName; console.log(catName); catName = "Milo"; } If you call that function, it will output `"undefined"`, because the variable exists but it hasn't been given a value yet. If you use `let` instead of `var`, it will throw a ReferenceError, because `catName` doesn't exist at all until it gets declared. `const` is just like `let`, but it will not let you assign a new value to it. You'll still be able to *modify* that value, just not give it a totally new value. That is, if `const x = [1,2]`, you can still `x.push(3)`, but you can't `x = 5`. &gt; and you don't have to assign the variable to a value once it is created, but if you wanted to create a variable without a value, why not just do it later? This is true of `var` as well; `var foo;` and `let foo;` are both valid. There are situations where you'd want to create a variable without a value. Usually it's because you want the variable to exist in one scope, but to have the declaration be in a different scope. For example, when you're writing a set of 50 tests, it's common to have a special function called something like `beforeEach` that gets run before each of the tests, to wipe things clean and set up the proper context. That might involve setting up a brand new fresh database object/connection. So you'd say `let databaseConn;`, assigning nothing, in the global scope of your test file, and then assign a new object to `databaseConn` in the `beforeEach` function. You can't just declare that variable from scratch in the function, or it'd only be available in that function. But you don't want to create and assign a database object in the global scope to start with, because it'll just get wiped away by the first `beforeEach` call and waste time/resources. &gt; If you don't want to change the value, then don't set it up so it gets changed in the code. If you don't want something to happen, it's always best to make sure it *can't* happen, that the system will just not allow it. "Just don't change it!" sounds sensible, but when your program becomes big and complex, with multiple people working on it over the span of years, some of those people working on only small parts and knowing nothing about the other parts, yet having to integrate them all? Mistakes happen, and you can't keep the entire thing in your head at once. Things get modified that weren't meant to be modified, or the same name accidentally gets used twice. If you don't intend for something to be reassigned, use `const`, and make sure it can't be. It will help you catch bugs right at the source before they become confusing mysteries. 
If the map function is complex, you can extract the function out if you need to. I think if you're tempted to write a big complex for loop, you'd benefit to breaking it down into map, reduce and filter functions as it's much easier to see what's going on and the individual operations are simpler to understand as well as reusable. Big for loops with lots of stateful variables, continues, conditions etc. are way more complex to me. 
``` for (var i = 0; i &lt; 5; i++) { setTimeout(console.log, 0, i ) } ``` ;)
&gt; for(const key in someObj)...) Using const will not even run, what are you saying? Are you just repeating what others are saying blindly? With regards to the speed, pretty sure you're wrong there. Three function calls vs none and to top it off, 2 function calls per iteration vs none. Have not used hasOwnProperty there if you haven't noticed. This is a very specific use case where it doesn't need to be async-safe. &gt; if you use var and an async method inside your block scope, that var will always resolve to the final value, not to the value that you expect Again you are just regurgitating from others. Let me demonstrate: for (var key in someObj) { (function(key){console.log(key);})(key); if (someObj[key] === targetVal) break; else key = null; }; console.log(key); 
My main and only account since 2012. Just frequently deleting old comments whenever I argue with idiots because its embarassing. But to give credit where its due, I did use var in my comment deletion script to avoid "already declared" errors while refining and repeatedly executing it in the dev console.
You can, and probably should. Besides if you're going to use that pattern instead of `Object.keys()` you need to check with `Object.prototype.hasOwnProperty()` first or you'll run into surprises. Also, I *really* wouldn't think that pattern is faster than `Object.keys()` simply because it requires climbing the prototype chain etc, though I haven't checked. But just because it looks like a function doesn't make it slower than a syntactic construct like `for (in)`
 for (var key in someObj) { if (someObj[key] === targetVal) break; else key = null; }; Hahaha wtf is this. If you find the key you won't know what it was since you do nothing but break, else you assign null to key *in every iteration.* That is a lot slower than what he posted. 
&gt; More readable, It really isn't. &gt; beginner friendly etc. I'm sure that's a plus for you. &gt; Should also run faster than the code you posted, How could you possibly believe this? It runs a lot slower, because you reassign `key` in every iteration.
[Benchmarks](https://jsperf.com/object-keys-vs-hasownproperty/45) don't seem to agree with your assertion. Also those are not interchangeable, you are including the prototype chain whereas `Object.keys()` does not, and in all likely hood, you don't want that, especially if you hire beginners that may not notice this. Also `let` works fine there too. Finally, there is a touch of irony when you say you hate blanket statements yet proceed to announce functions must be slower, that's just not how modern runtimes works.
If you are using es6 anyway, I recommend not using `for` and to use `map`, `filter`, `reduce` instead, and `forEach` if you need have to do mutation/side effects. 
&gt; I think if you're tempted to write a big complex for loop, you'd benefit to breaking it down into map, reduce and filter functions I disagree. I'd rather write: for (const item of array) { doSomething(item) } than use map or reduce. To me "map" and "reduce" are inherently less explicit. Every programmer knows what a for loop is, not every programmer knows map or reduce. Also a for loop literally tells you what it does. For X do Y. Map and reduce don't tell you anything just from reading it. Those two words mean nothing. The only reason they're easier to understand to you is because you've used them a lot. They're objectively a more difficult concept to understand. Loops are the first thing you learn.
thank you for your help! is it better to create those functions within the same js file or another?
Depending on what they're fetching use some naming convention related to that. Firstly, rename "Load" to "Load..." And "Save" to "Save..." Adding meaning to their functions. Also adding comments within the class file can be helpful. Example, LoadUserSettings, SaveUserSettings. 
&gt; Using const will not even run, what are you saying? Jesus Christ you're dumb. [It works perfectly fine.](https://i.imgur.com/klIWq3c.png) `const` is block scoped, the scope is changed in every iteration of the loop. &gt; With regards to the speed, pretty sure you're wrong there. No, you are. Try stuff out by yourself before you make a fool out of yourself. You've clearly displayed your lack of knowledge about JavaScript, just stop commenting.
A clear way to write it, and most of these problems with arrays with properties inside the indices that have to be found, is to make an intermediate object, fill that, and then make a new array from that object. Approach 1, naive, but clear, `.forEach` example: // Step 1. Create the intermediate object. // Note that the example doesn't check for invalid or null values. var intermediate = {}; data.forEach(item =&gt; { var name = item[0]; var amount = item[1]; if (!intermediate[name]) { intermediate[name] = 0; } intermediate[name] += amount; }); // Step 2: create the new array. var newArray = []; Object.keys(intermediate).forEach(key =&gt; { newArray.push([key, intermediate[key]]; }); Approach 2, which does the same as Approach 1, but with map and reduce and some inlining of conditionals: // Step 1. Create the intermediate object. var intermediate = data.reduce((total, item) =&gt; { var name = item[0]; var amount = item[1]; total[name] = (total[name] || 0) + amount; return total; }, {}); // Step 2: create the new array. var newArray = Object.keys(intermediate).map(key =&gt; [key, intermediate[key]]); &amp;#x200B;
It's funny you failed to look closely at your own results. "For in" is the FASTEST result there. If you had looked at my code, there is NO hasOwnProperty check because it's a custom object that I can make sure has unique properties. You say you understand modern runtimes, yet fail to demonstrate the understanding that hasOwnProperty IS A FUNCTION and likely has to check the entire prototype chain and that is what is most probably slowing it down rather than function calls being faster. &gt; Also let works fine there too. Come on guys, at least run the code once before you comment.
Use `const` by default. If you _do_ need to reassign for some reason then `let`. For me, &gt;90% of the time I‚Äôm using `const`. Don‚Äôt often need `let`. I haven‚Äôt used `var` since around 2014.
Actually it will run as the binding is evaluated at the start of each loop. Try it in your console! (eg `const someObj = {a: 'foo' b: 'bar'}; for (const key in someObj) { console.log(key) }` As for the speed, it's a well known thing, [this stack overflow post](https://stackoverflow.com/questions/13645890/javascript-for-in-vs-for-loop-performance) covers the reasons pretty well. The issue isn't what's on the service, it's with the way js engines handle iterating through a `for ... in ...` statement (which is according to the spec). The other way may appear to be 3 methods but the time complexity is quite simple as the methods have a fraction of the overhead of the `for ... in ...` construct since they already know that what they're operating on is an enumerable construct that follows a sequence. Also in the example at the bottom of your code, you're not running anything asynchronously which is where the issue will present itself. Try throwing either a setTimeout or setInterval in there for a simple example and you'll see what I mean. (eg `for (var key in someObj) { setTimeout(() =&gt; console.log(key)) }`) assuming someObj looks like { a: 'foo', b: 'bar' } the result of the above will look something like b b There's a reason everyone else is saying these things, because that's how these things work in modern javascript
It's not especially weird. The loop just accesses `x`; it doesn't modify or iterate it.
Well, both options have their advantages. You could use two completely separate files, and only load the one you need on different pages. The advantage of this is that it clearly avoids conflicts similar to the one you were having. You don't assume a function that works on one page works in the other because they won't be running on both. The disadvantage is that you _may_ have some repeated code in both files (see below). The other option, having it all on the same file has the advantage that you can easily share code and avoid repetition. On the other hand your code may end up being a bit more complex because you have to deal with doing different stuff depending on what page you're at. Finally, there's a third option: You share some files but not others. That is, you split things into: one file which is common to all pages and is always loaded, and specific files which are only loaded in each particular page (if needed). It generally has the advantages of the other two options. Note that you may also investigate code _bundlers_ or _packers_. This would allow you to have the source code in as many different files as you want, but then pack them together to serve them on each page. For a small project such as yours, you may not need this, though. So just keep it in mind for the future, but ignore it for this project, maybe.
Please leave links in plain text...
I rarely think about it, but it's quite odd to suddenly have a verb as a keyword.
I did look closely, here at least `for in` is 30% slower than `Object.keys`. Here is an example of "custom object" that will surprise you: `Object.prototype.yoyo = 1; for (let i in {a: 1}) console.log(i);`. That something is a function doesn't let the compiler be less magic necessarily. Some functions are C code, you can't make that blanket statement, there are many variables in play when it comes to interpretation. `hasOwnProperty` most certainly does not look up the chain and instead looks on the local property hash. I did run the code, `for (let x in {a:1}) console.log(x)` works fine here.
I might have made a mistake but you're pretty dumb yourself mate. Someone else has posted a link with some benchmarks, you should have a look at them. I could also call you names at this point and insult you, but I'd rather have a discussion and hear what the other person is trying to say.
Wut
*Real programmers make their code as difficult to write and read as possible!* If you're trying to ardently convince anyone in this thread that var is a good thing (which it never is), "it's not that much harder to use" is absolutely the worst way to go about it.
As someone who hasn‚Äôt touch JS in the better part of a decade, I‚Äôm wondering, how close are we to just treating machine-generated JS like assembly? Are the source maps and tools good enough that I could do my work while looking at generated JS about as often as a C++ dev needs to peek at the compiler‚Äôs x86 output?
cons allChildren = fileList.map((x) =&gt; x.children).reduce((a,b,[]) =&gt; a.concat(b));
Would be nice if you could `break` out of that `forEach`.
Thank you responding in a civil manner unlike some others here. The const thing is new to me and I did try running it in a console window before commenting, but I must have made a mistake when typing it out, because it failed to run on mine, hence my comment. With regards to the asyn call, all you need to do is to capture the variable value using a function block. Ex: for (var key in someObj) { (function(k1){ setTimeout(() =&gt; console.log(k1));})(key) }
Thanks for the edit. But with that architecture there is really not much you can do. I *definitely* split it up into homogeneous lists first. Lists with mixed types make code a lot more difficult to maintain. Unless you have some kind of "type" discriminator in the object. This would still make it possible to handle it even when leaving out field names. I totally agree with it being "brittle". That was the "trade-off" I was talking about. Speaking of type discriminator, assume the following: [ { "type": "person", "first_name": "John", "last_name": "Doe" }, { "type": "person", "first_name": "Jane", "last_name": "Doe" }, { "type": "book", "title": "SomethingSomething", "isbn": "12345" } ] This could be reduced to: [ ["person", "John", "Doe"], ["person", "Jane", "Doe"], ["book", "SomethingSomething", "12345"] ] I want to repeat again that this *is* a trade-off with maintainability. But given the nature of your data you gave in your example, I don't see how you can compress otherwise. For giggles, let me encode the same examples `x.690`. Should not make a big difference with the small example here, but I'm curious myself... 
Your attitude has been horrible through this whole thread, but as soon as I call you out you start crying? Give me a break. I tried running your code and benchmarked it versus /u/ings0c's code, and your code performed horribly. [ins0c's code was three times as fast as yours.](https://i.imgur.com/SGNtbjm.png) Please, change careers. This isn't for you.
Less hyperbole, more actual experience
 const flatMap = (fn, array) =&gt; array.reduce((acc, x) =&gt; acc.concat(fn(x)), []); const files = flatMap(group =&gt; group.children.map(file =&gt; file.name), fileList); console.log(files); // to log all files as one array files.forEach(file =&gt; console.log(file)); // to log each file individually https://jsbin.com/diqiwedepe/edit?js,console
Yep! That's why I made sure to point out that you can create the closure there for setTimeout. It's something I've been caught out by back when I was still getting the hang of things and is more for demonstration purposes than an example of a good practice (which you're right, it most certainly isn't :P) I'm happy I could be of help! I've been doing this a while and I'd rather see someone enjoy learning something new about the language than be put off by people deriding their lack of knowledge, we've all been there after all!
You're a cunt mate. Happy now?
Ok, I concede my point and stand corrected. Just a tiny correction, 'x', should be accessible outside the 'for' loop.
I am still exploring gRPC so thanks for your advice I am going to fix that!
&gt;flatMap I'm a bit retarded, but what does it do exactly? 
`for in` and `for of` is not the same thing. In the first loop, you're looping over every key of the array object (including anything in the prototype chain), not just the indices.
Not function vs. block scoping, but there are differences between `let` and `var` when used in the global scope. You would use `var` when you want a global variable to be automatically added as a property on the global window object. `let` won't do that. And JS expert Kyle Simpson may have changed his mind by, but [he makes the case for var in this article from 2014](https://davidwalsh.name/for-and-against-let). &amp;#x200B;
Has Kyle Simpson changed his mind? He might just be the world's foremost expert on JS today, and [in 2014 he argued for reasonable uses of var](https://davidwalsh.name/for-and-against-let).
I am also about to start the same course as you in a few days, lets start together and it also might be a healthy competition :) P.S. - I am in my undergrad degree and same like you, it's also my winter break :) Hope to hear from you soon :)
I think it comes from mathematical proofs, where new object are introduced with let most of the time :)
[Here is a nuanced opinion on the use let vs var from JS expert Kyle Simpson](https://davidwalsh.name/for-and-against-let), and it explains in detail how `let` works in a `for` loop. I found it helpful. Note that the article is from 2014 and Kyle may not hold those opinions anymore, but they seemed reasonable to me.
I've always associated it with BASIC
The 0'th index of the array is not the reference.
If all you want to do is print out the names of the children: fileList.map(group =&gt; group.children.map(child =&gt; console.log(child.name)); &amp;#x200B;
Yes, that's wrong - they do change; `i++` and `j++` mutates the reference, which would be an error with `const`.
[`Array#map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) creates a new array by transforming all elements in old array using provided function: const numbers = [1, 2, 3, 4, 5]; const newNumbers = numbers.map(n =&gt; n + 10); numbers; //=&gt; [1, 2, 3, 4, 5] newNumbers; //=&gt; [11, 12, 13, 14, 15] [`Array#flat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat) (sometimes also called `flatten`) "collapses" several layers of arrays: const arrayOfArrays = [[1, 2], [3], [4, 5]]; const flattened = arrayOfArrays.flat(); flattened; //=&gt; [1, 2, 3, 4, 5]; `Array#flatMap` combines `map` and `flat`: const numbers = [1, 2, 3]; numbers.map(n =&gt; [n, n]); //=&gt; [[1, 1], [2, 2], [3, 3]] numbers.map(n =&gt; [n, n]).flat(); //=&gt; [1, 1, 2, 2, 3, 3] numbers.flatMap(n =&gt; [n, n]); //=&gt; [1, 1, 2, 2, 3, 3] Does this help?
So much this! I had a SoundCloud project where i used a for loop (with a var) to display album art with a play button to the DOM. I couldn't figure out why all the play buttons would play just the last song in the array! I spent an embarrassing amount of time fixing the issue. Simply substituting 'for' for 'let' solved the problem!
Ha, I appreciate the offer, but I need to take my time for now. Full disclosure, I just started therapy for anxiety and have some other life-related things to take care of over break. Best of luck, whatever the case! =)
done