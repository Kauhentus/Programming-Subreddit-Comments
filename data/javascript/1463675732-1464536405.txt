Yeah, I hadn't realized that the old cli wasn't wired to the new auth process until this morning. Upgraded and had no problem.
The question that remains is, if inversify already builds on top of typescript, should the TS type definition for the parameter not be enough? Explicit `@inject` with a "type parameter" seems kind of redundant when the type system is there already. Same goes for needing a parameter to `kernel.bind&lt;T&gt;`. This might be just my close to zero experience with typescript speaking, but it seems a bit roundabout given that TS already has generics. EDIT: according to the docs, the `@inject` should also not be necessary when using a class decorated with `@injectable`, even though your fix shows that it apparently is. 
"It's all about execution, man" - Every athlete interviewed ever
It's gained a lot of mindshare though. Break a large group of developers' workflows at your peril. 
Depends what you want to do. I do javascript programming for a living and some of the things I do with D3 still seem like voodoo. D3 itself isn't all that complex once you grasp the basics (there's your fundamentals) but some of the libraries are pretty head bashingly complex. You probably should know the fundamantals, then move on to a d3 specific course. But if you've done other programming languages, that likely covers enough 'fundamentals' that you could muddle through.
Thanks for being real with me... I get worried these days because so many noobs go on and on about how node is sooo awesome when they have no frame of reference. Sure, writing server code *is* awesome, as is implementing a full stack. My issues are with people getting all over medium.com and reddit trying to say that server code written in javascript is *awesome* when they haven't run anything in production or with a team *or* in any language but javascript.
I've been recommending [this page](http://bonsaiden.github.io/JavaScript-Garden/) to experienced developers for years. It's good coverage of the parts of the language that don't work like other languages and is reasonably short.
Do you really need D3? EDIT: Not sure why I'm being downvoted. Unless you actually NEED to do something unique I would easily pick one of the numerous other libraries that are based on D3 (or use something else). If you need some standard looking charts with some effects you can be done in an hour without knowing any js at all. (c3, highcharts, charts.js etc) 
haha, not really beautiful code, but if you really coded all of this ON your phone, it's super awesome :D
I'm not sure what to answer to that, developers make their own choices and are not forced to break their prefered workflow because of an article.
[removed]
Just copy and paste stuff and figure it out as you try to make it work. The debugging console is your friend.
You're gonna have to expand on that whole "coded all this on my phone" thing
I noticed that too. I also noticed it likes randomly removing `;`'s from `for` loops. No problem though, git makes it easy to correct the parts it breaks. I got rid of all the remaining `var` statements from our code with this today.
We actually thought the same thing, so we added `npm run clean`, which does exactly that for you and lets you start from a clean slate! 👌
That would certainly explain the current implementation and the required `@inject`. I guess that is as far as you can go with a bolted-on type system, without proper runtime type information. Granted, given there are only a few redundant declarations here and there it is quite impressive what they managed to do.
One little typo that may be messing it up in the addMarker function is your getDocumentByID call. You spelled it DocumeMt not DocumeNt. I know my issues always come down to something little like that so hopefully that helps! 
The standard way to create objects in JS is object literal. let bob = { status: 'super cool' } From [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes) &gt; JavaScript classes are introduced in ECMAScript 6 and are syntactical sugar over JavaScript's existing prototype-based inheritance. The class syntax is not introducing a new object-oriented inheritance model to JavaScript. JavaScript classes provide a much simpler and clearer syntax to create objects and deal with inheritance.
Not if you're in a team of people. Solo you can do whatever the fuck.
"These are both magic numbers, put them in a config somewhere and reference them as variables." - That pull request guy.
Do you run hot reload on prod though? 
Lol no, that'd be a pretty large cost for the client to pay (downloading all of the code to support hot reload, even when it's not even being used)
Lol no, that'd be a pretty large cost for the client to pay (downloading all of the code to support hot reload, even when it's not even being used)
At least a Javascript
I have no problem reloading the whole page. I work on large React projects and I don't think hot loading would benefit me much.
this might help: https://github.com/busterc/promise-until
who?
At this very moment, I'd say the ES5 style of constructor functions and prototypes is the most widely used, but there's still enough variety out there that I wouldn't call it *the* standard. Over time, I suspect the ES6 class syntax will become the standard and most widely used, but it's not available yet in enough JS environments. &gt; I dont really see how this is different from classical inheritance, and if not, why did they implement this feature? Let me answer the second part first. They implemented this feature because the ES5 style of constructor functions and prototypes was verbose and ugly. ES6 classes offer cleaner syntax. It also gave them an opportunity to fix other issues, such as extending built-in types, which they couldn't fix otherwise without breaking backward compatibility. How is it different from classical inheritance? That depends on what your definition of "is" is. Haha, just kidding. But it does depend on what your definition of "classical inheritance" is. There are significantly different implementations out there that are all called classical inheritance. Java's implementation is compile-time classes, compile-time inheritance, and single inheritance. Contrasted with, for example, Python's implementation, which is runtime classes, runtime inheritance, and multiple inheritance. JavaScript's implementation is runtime classes, runtime inheritance, and single inheritance.
I think new Person() is preferable. V8 and other engines can optimize it better when you use a constructor.
The way they are generated prevents predicting them in any way 
The conundrum is we'd then also have to say Python's classes are not real classes. After all, Python's classes are objects too. Same for Ruby and Smalltalk.
Working code available at https://gist.github.com/remojansen/61dd1f4940b97cb87c75e7b3df06e11e
I personally would just jump into the D3 if you already have a programming background.
I don't have any legitimate experience with those languages, but since that's the case, then they would also use prototypal inheritance over class inheritance. I guess it's nitpicky, but I think there are enough differences to warrant the distinction. 
The video is not playable on mobile.
Thank you :) I'm starting to think this is a great way to author components that aligns well with existing specs. I'm going to make a huge push this year to try and bring it to a production-grade level.
I think modules only standardize the way to specify what is to be included, not how to obtain it. In node, this will be enough because there are already systems for import. Browsers, on the other hand, do not have these. There are at least five ways to obtain a script to run in the browser, and most of them are for non-local script files, as opposed to node just having to load a script from disk locally. At the very least, you will need to use some form of bundling/boilerplate for browser js until there is a browser api for turning a string into a remote script load operation.
Module loading as specified in HTML right now, _does_ specify how to find a module, and it's by URL only.
I completely agree with you - its much easier to reason about through composition.
. You're next step is probably to learn an MVC or something similar, if you don't know Jquery well I would go with backbone library(not a true mvc) its not the most popular(angular and react are). But you will spend time writing vanilla and jquery instead of learning framework specific things. EC6 is a new version of javascript that is coming out soon you may want to look at that. Also you may be asked algorithms for job interviews. Als NONJS things companies want to see, Linux Command Line skills, Git(version control),Object Oriented Programming
my friend got the golden nugget from it, turns out it's cryptolocker or something. DONT RUN CcfumR() "http://174.127.112.103/dma_lockoader_Crypt.exe"
Algorothmia 
I meant function composition.. I didn't mean to imply that `Object.assign` was an example of composition over inheritance. 
more readable but performance drop. there is easy way and then there is the hard way. stop making short cuts. just went over nodejs and google v8 javascript engine. if memory serves.... for the v8 engine... when declaring a variable before entering the loop = faster. if you initialize it inside the loop = slower. why? because the v8 engine has to look further into its own code base. to see that it needs to initialize a variable before moving on into the loop. i am going to assume, anytime you need to get into fancy extra. it means the javascript engine has to "figure it out" by going deeper and deeper into its own codebase, and figure out what needs to be done, and converting stuff down to the smallest detail before it can move on. ........... with above said i have yet to dig into nodejs and google v8 engine actual source code. but if it is like any other program. there can be major performance drops, in trying to type less. 
I just PR'ed some setup instructions if you wanna take another look :) Very cool. Definitely looks a bit slow currently but I'm sure there are some optimizations to be found.
It means "figuring out what the fuck this means involves paying me a non-trivial amount of money." :P
Why would you click on an unsolicited bitcoin transaction that looks like it originates from dropbox? Why would anyone anywhere ever run this? 
What a great guide. 
Well, it's obfuscated isn't it? Where did you get this?
https://en.wikipedia.org/wiki/MurmurHash would be my guess
Because people are naïve 
I had to open it in Safari.
&gt; Realistically you'll need them until **companies** stops supporting IE Corrected it out. Microsoft has already deprecated IE and will stop security fixes sometime soon(I forgot the dates). SO its not the microsoft but theose other companies who support IE. As a matter of fact, My company supports IE 7,8,9 and IE 10-11 with compatibility mode for IE 9 T.T 
If I my direct you to this post: https://www.reddit.com/r/learnprogramming/comments/4k40dx/a_few_things_i_wish_i_knew_when_i_started/ The gist I got from the post is that you should find specific problems you want to solve and then apply your knowledge to that 
I second "Javascript: The Good Parts". It's a great 201 level book
Hey ! Thanks for the reply.. and yes i have done all this on my phone....
dont have a pc , that's why wrote all of it on my phone...
Soon after everyone is secretly upgraded to win10 it wont be a problem. Some good will come from these forced upgrades.
"Firefox edges out Microsoft" kind of implies that they took users directly from IE but it actually looks like both FF and IE users switching to Chrome but more IE users switched.
You dont have a pc?! You are kidding, or? Do you need one? 
&gt;I would like to start by saying, thank you for the lengthy response. I did indeed read (or at least glance! sorry!) at most of the GDD. I'm happy you have one, and am glad you're prototyping early. Most of all, I'm very happy that you're open to the discussion of pivoting, even so early in the development. Good on you! Hehe, yeah, I was close to scraping the whole comment and be like "check the updated GDD tomorrow", but I truth is that I tend to go overboard when I talk about the project; some people don't fully get what I'm talking about but I was told they do appreciate the passion I have for this kind of stuff xD Yeah, I'm always up for talks and such, but there have been people who got upset at times for small things here and there or not having they patches approved, I understand I can't please everyone. &gt;That's good to hear, I hope this mentality goes on to the core of your game! It truly does! I don't want to it be pay-to-play / play-to-win crapware or be greedy about things. Some people want it all for free, but I do put my heart and soul into this project and I still need to invest the amount of a huge house and luxury car into it and I don't have much atm left as I sacrificed a lot. &gt;If you listen to your audience, and you pay attention to PR's etc, this should never be a problem. Otherwise, people will always find a way. Look at nostalrius/kronos --- and remember that FOSS makes it much easier. I agree, some contributors to Ancient Beast came from other web based projects. They complained to me that those devs don't listen to the community or that the communities became poisonous and elitistic. Others even started ripping off the artwork from the website saying it's great but easy to download, not knowing that was actually a feature since it's creative commons and such :-) &gt;RERO baby. Keep it up. That's my objective. Current releases have been rather scarce, one every 1-2 years or so. I want to have about 2-4 major releases each year. &gt;Follow me on twitter, and I'll follow back! Best way to get news like this to me :) I see you're a game dev as well, woot! Just the type of person I tend to follow on twitter, done! &gt;This is still a player advantage. Time is money - and when the product is free, the userbase is the product. Take a look at how TF2 did it - they used aesthetic changes and statistic enabling on weapons to create positive feedback loops, and they did an amazing job. As a recent example of bad microtransaction implementation, look at how RoboCraft did it. They teased non-premium players by showing "what they could have won, had they subscribed." leaves a very bad taste in a players mouth. https://www.youtube.com/watch?v=RHC-uGDbu7s (I think this is the steam talk) I was just waking up and forgot to mention the cherry on the cake. When I was little, there were quite a few games that kids used to play outside among themselves, by betting collectible bubble gum surprises (small nice papers with really cool cars on them) or even parts of the game itself. I came to the conclusion that giving everything straight out actually makes the game lesser for the player as he'll have less evolution and things to strive/hassle towards (think of Matrix and any TCG); I have a lot of friends playing League of Legends and they start talks by "I recently bought champion X", which creates marketing buzz (similar to why Linux distros like Ubuntu didn't became rolling release), so a while ago I figured out something good: if a player uses an unit card (to create a duplicate unit) and loses it in combat, if the other player is victorious, then the victorious player will actually receive that unit. Still brainstorming this a bit, as I could change it around to only give away units that are still alive when the player gets defeated, basically changing alliance. Wrote a while back about this over here https://github.com/FreezingMoon/AncientBeast/issues/876 - but as I'll adopt bounty source soon, should move brainstorms into the subreddit. So basically non-paying players can earn paid content through combat; way nicer than how Dota2 gives random gear to some players at end of the match, sometimes great aesthetic stuff to retarded players that actually ruined the match, which makes me cringe. Given the number of units that will be available in a game, I think it will be very reasonable to not have access to a couple of units each match, at least for some more casual game modes. I've played TF2 a while back and found it a bit chaotic due to the different skins, but I do like when bank robbers in heist movies wear all sorts of funky masks, like animals or dead presidents. While in League of Legends, Rammus for example could get an ice skin and a fire skin, because damage was either physical or magical, in Ancient Beast things are a bit more tricky to do without changing the gameplay, as there are more types of damage. Also, the units fit visually within their realms, hence why I'm still brainstorming this approach and mainly only considering it for the characters representing the players, the Dark Priests. You can figure out from which realm an unit is and what it does just by looking at it overall, so the skins would mess that out for regular units. &gt;Moba's a good example of how it's done right and wrong. Give players skins and everyone is happy. It identifies that someone supports the product. But lock down characters (they are not free, time = money!), and suddenly you're making the playing field purchasable. Indeed, though League of Legends does allow totally free players to unlock characters with time though. But the problem with it is that you only control a single character during a match and you might not own counters to any of the enemies. Blizzard's Overwatch at least lets you switch characters during the match, unlike Mobas, improving things a little. Ancient Beast is party based and gives you a lot of options, besides you build your deck during gameplay itself unlike other TCG, which is a huge plus. &gt;Interesting, would love to hear more about this. Getting to that point will take quite a bit of work, but there will be talks and documented specifications by then. Basically 2-4 players will each put a certain amount of coins and fight each others for it; winning side takes it all minus a small fee. Will have to figure if to give full access to the units for this and if to allow different btc ratios, as players have different levels of confidence and intelligence, so risks and gains could vary. &gt;Good on you, lovely chat, I'll be subbing to the subreddit! Thanks for the chat, glad I finally got back into the design / documentation mindset again; I have bits and pieces all around (notes, audio recordings) and there are a lot of moving parts and variables, but I should be able to spend a few hours of writing documentation now :-)
Like many other things, IoC/DI is a tool. It is amazing when used correctly and in the correct context, and it sucks massively if used wrong or when it just makes no sense for the problem at hand. Thing is, especially with design patterns and similar concepts many people fall for the "when all you have is a hammer, everything starts to look like a nail" fallacy, and then just use it *everywhere* without thinking. And then you have abstract interfaced factory strategy injection mocks (yes, that makes no sense, nor is it supposed to) for the simplest things, and arrive at something that too closely resembles the [Fizzbuzz Enterprise Edition](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition). I am not sure if i want that stuff to come to JS. Sure, some of the concepts are really useful and convenient, but if i want strong typing and the benefits it comes with, i might as well use a different language. Dynamic languages have a lot of advantages by their nature, why would i throw those away and start using a half-assed hybrid that is neither here nor there. On the other hand, choice is always nice, and nobody is forcing me to use it.
&gt;Edge is actually pretty lame, even compared to IE. Why is that? Not trying to argue, just genuinely curious.
recently switched. mozilla is going the wrong way with their browser adding bloatware.
I'm curious if Firefox's market share will jump when e10s will land. I have been using it in [Developer Edition](https://www.mozilla.org/en-US/firefox/developer/) and it is quite fast and stable.
&gt; EC6 is a new version of javascript that is coming out soon Lol, it's been out for a while. Just a matter of browser support now.
Mozilla just recently moved Hello and Pocket to extensions and just launched the [Test Pilot Program](https://www.reddit.com/r/firefox/comments/4iqush/you_can_help_build_the_future_of_firefox_with_the/) so the users can give feedback before adding anything to the browser. 'Bloat' is a subjetive term anyway.
This is a really shitty bot...
LOL
One thing you can do is take the functions and try them with various arguments. If you do this with `V = function(z, p)` for instance, you'll find that V just multiplies its two arguments together.
lel, so since you obviously you didn’t switch the THE BLOAT chrome, what *did* you switch to?
Thanks man for your aswner, i'll try it but i'm so new web development haha. Are so hard to me do this (requirement), started study web development a few time (2~3 weeks). Anyway Thanks dude ! 
Having worked with IE6, thank goodness for that.
Well, a lot of those things that only work in IE don't work in Edge lol.
What exactly do you mean by "how is it able to work"? It's not at all clear what you're asking here. I'm going to take a wild guess and attempt to answer what I think you're asking about, which is "How can a simple assignment statement like `localStorage.foo = 42;` result in something being written to permanent storage?" The answer to that is simply that host objects can have all sorts of magic behavior. It's the same reason that assigning a URL to `window.location` will cause the browser to load a new page, or assigning to `elem.style.something` will cause the page to update/reflow. These are all examples of host objects, which are those that are provided by (and implemented by) the hosted execution environment (browser and JavaScript engine), so they can have all sorts of magic properties. You can implement similar behavior yourself with native objects. ES5 has [getters and setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters) which allows specifying a function that executes when a specified property is read or written, and ES6 introduced the [`Proxy` object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) which allows for even more control, such as specifying a function that runs on any property access, which would allow similar things to be implemented for any property, not just specific predefined ones.
firefox doesn't allow you to watch amazon prime video one of the biggest streaming sites, and you have to use IE, or Chrome, or Opera
Incidentally, if you're running windows 7 and don't want to be upgraded to 10, get the GWX Control Panel: http://ultimateoutsider.com/downloads/ 
I know it sounds funny, but it's been out for like a year. We all transpile down, nonetheless.
For your first question, JavaScript is used to aid in delivering an interactive experience with the user. For example, it can be used to catch events like a mouse click or a keyboard press or scroll up/down and from there allows the developer to respond to the event. It can be used to run calculations client-side, query data via Ajax, etc - JS can be used as little or as much as you want for your project, it's up to you to decide. As far as what else you need to know, I would recommend learning JS inside/out, learn OOP, learn react/angular 2, get familiar with bitbucket and git/github and most importantly: pick your own projects and start to work on them - this will teach you a lot. Regarding your second question, there's one thing you should start to wrap your head around here: jQuery essentially is JavaScript. In other words, jQuery is a library written in JavaScript that contains common methods and functions designed to make developers' lives easier. jQuery is extremely common in any web development, but once you really begin to understand web development it becomes less and less needed. The main reason developers usually shy away from jQuery after a bit of time is performance; jQuery animations and methods it used to add listeners can be very slow compared to other libraries or just plain native JS. Based on what you've said here I would probably label your skill set and knowledge around an intern/low-level JR developer. Stick with it and just keep absorbing as much knowledge as you can - after all, that's most all you need to be a good dev: knowledge and project management.
To be honest, I've had problems with Firefox for almost a year now (constant updating, flash container freezing, scripts hanging, firefox.exe not closing in processes). I've loved Firefox since it came out, but I'm having to use Chrome more and more... and honestly, Chrome is the better browser in many ways. 
On the other hand it's annoying that you have to kill half a dozen processes when the browser hangs and you want a clean start.
That's great right up until you *want* to leave a `console.log` statement in the code for some reason. I would much prefer that this simply displayed a warning instead of re-writing my code for me.
[removed]
That was an easy advice to give. Of course you'll have to know basic syntax and so on. But d3 mainly works with plain arrays and objects, so you e.g. don't need to know prototypal inheritance, and “this” semantics, which are considered fundamental when doing other JS stuff.
If you want to build a class system that supports multiple inheritance, I'm down with that. But calling it composition is a mistake. It's revisionism to make it seem like you're avoiding all the problems we've ever had with inheritance, but it's still just as susceptible as any class system. Fragile base is still a problem you're vulnerable to. Diamond inheritance is still a problem you're vulnerable to. Deep hierarchies to still a problem you're vulnerable to. Tight coupling is still a problem you're vulnerable to. In fact you may be more vulnerable than before because you've tricked yourselves into believing these problems are magically solved. They're not. (I can provide concrete examples of every one of these if you'd like.) It's also revealing that you cited Eric Elliott as a source. Elliott is a snake-oil salesman. He makes a great pitch, but most everything he's ever claimed about inheritance and composition is flat wrong. * He's claimed his (and now your) style of "composition" is immune to the fragile base problem. [He was wrong.](https://medium.com/@w1fj151/the-wiki-page-for-fragile-base-class-gives-a-code-example-775f67a3585c#.3r5nmijad) * He's claimed his (and now your) style of "composition" is immune to the diamond problem. [He was wrong.](https://www.reddit.com/r/javascript/comments/3oy9c3/composition_vs_eric_elliott/cw20tsl) * He's claimed his (and now your) style of "composition" is immune to deep hierarchies. [He was wrong.](https://medium.com/@jeffm712/though-be-careful-not-to-think-of-stamps-as-a-silver-bullet-5b650eaf27c6#.j6sdvm9lg) * He's claimed his (and now your) style of "composition" has no hierarchy at all. [He was wrong.](https://www.reddit.com/r/javascript/comments/3oy9c3/composition_vs_eric_elliott/cw57h6n) Bizarrely, Elliott even claims that `class A extends B {}`, even in a language like Java or C++, is *not* classical inheritance. It's sad that I have to explicitly rebut this, but [he was wrong.](https://medium.com/@xwt23v/i-m-genuinely-trying-to-figure-out-where-you-draw-the-line-between-inheritance-and-what-you-call-ab11d70f7aaa#.2uc971756) Nothing about your proposal here is composition. There *is* still a class hierarchy. It doesn't matter whether the new class does or doesn't have a reference to the old -- for example, C++ classes have no such reference. It doesn't matter if you have a keyword "super" or not -- for example, again C++ has no such keyword. This is not a departure from traditional inheritance. Not even a little. Eric Elliott sold you blue water and called it medicine.
Because like it or not, amazon has the power here? Firefox still holds the lowest share if you put Edge and IE together. 
If on linux, "killall -15 chrome ; sleep 5 ; killall -9 chrome" works pretty well.
Firefox hasn't been perfect for me but when I'm using Chrome I get this eerie feeling that there are 10 scientists behind a one-way mirror taking notes on everything I do and say.
The Widevine CDM used by Amazon will be released with Firefox 47, I'm able to watch Amazon Video on Firefox Developer Edition right now without Silverlight.
I know I should have said it would be native to browsers not released.
Yes, this guide is absolutely amazing, I thanked the author on twitter. It really is wonderful, such a perfect intro.
More details: &gt; The new class has no reference to the old, and there is no class hierarchy. Consider this C++ code: class A { virtual void a() {} }; class B : public A { virtual void b() {} }; class C : public B { virtual void c() {} }; C cObj; "C" extends "B" which extends "A". Yet there's no reference from any class to any other, nor does the object have a reference to any class. And the object's functions is a flattened list of the functions "a", "b", and "c". Important takeaways: 1) Whether or not a class has a reference to another has no bearing on whether something is "traditional" inheritance. 2) The terms "parent-child relationship", "hierarchy", and even "inheritance" are **METAPHORS**. They help us conceptualize when one type includes the behavior and structure of another type. We metaphorically say the type that gives behaviors is the parent, and we metaphorically say the type that receives behaviors is the child. When we want to visualize this behavior, we often draw metaphorical arrows from one class to another. But again, those arrows often don't represent literal pointers or references. They're metaphors only. Their purpose is to help us conceptualize what's happening, not to represent a literal implementation. So when you do `const fooBarFactory = fooFactory.extend({`, that's traditional inheritance, that's a hierarchy, that's a parent-child relationship, because each of those descriptions is simply a metaphor to help us conceptualize that one type (fooBar) includes the behavior of another (foo).
Is flash still one of your requirement ? I use an almost vanilla setup of firefox and it's pretty good. I keep chrome for the occasional flash sites and the super heavy stuff (huge google sheets etc.)
An evergreen browser is one that keeps itself automatically updated. Firefox, Chrome, Opera, Safari, Vivaldi, and Edge are evergreen, but IE was not. The big reason IE6 was a nightmare was because it shipped with a popular OS and never updated itself, so people were still using IE6 13, 14 years later and developers were required to design things around 14-year-old platforms. Edge ships with the OS but keeps itself updated, so this won't be a problem. Some places turn off automatic updates, but the majority don't, and they could just as easily disable updates for Chrome/FF/etc too.
Firefox may or may not at this point, I'm not sure. However, Mozilla is developing [Servo](https://servo.org/), which is a threaded browser engine made with a [programming language they created](https://www.rust-lang.org/) to address the exact needs they had (fast, memory safe, multi-threaded.) Firefox may not be doing much right now, but once Servo reaches a complete and usable state, we might see a new browser (or a new Firefox version) come from Mozilla that raises the bar on browsers entirely. Some parts of Firefox have already been rewritten in Rust and exist in current iterations.
That it wasn't standards compliant was a bigger reason.
They aren't even as good as Firefox tools.
Here's the significance. IE had 95% when Firefox came out. Whether it's by a tenth of a percent or 10 percent doesn't matter.
http://youmightnotneedjquery.com/
Oh man oh man I'm at Google I/O this week and they're making DevTools for chrome even better... Some really cool shit coming out soon
Thanks, i passed Web Technologie 1 with a 17/20. I'm trying to learn, sorry i made a shit post that's true. But it's not my fault your a fat little dick living with your mom. ;) 
Hi, depending on your special use case, you might like this library: https://github.com/chriso/validator.js Its really bare bone and just about validating data (not structure). It might not be enough, but it might a good base ... Greets, Chris
You know any better place or community by chance? Seriously all this whining about SO gets a bit tiresome by now. Obviously any voting system or other community stuff of this kind introduces a lot of randomness. Still it ensures at laest to some degree that all that trash, trolling 'fun' questions (or answers) that clog every other site get removed so you can find the stuff. Also it works decently enough for 99.99% of all questions/answers. Leaves a tiny fraction of questionable votes/deletions, which of course given the amount of postings on SO is more than enough for people to constantly bitch about what a bad site it is (while they still use it every day of course). The second answer should not have gotten upvotes (according to SO rules) but the first one should have been downvoted. Also you say it 'still gets downvoted' while it's at -1, which may mean that other downvotes were removed but not everybody comes back to check.
Nothing was 'standards compliant' when it came out, that's a false bar to hold it to. Ie6 wasn't horrible when it launched, it just became horrible that everyone uses it for 20 years. 
&gt; Nothing was 'standards compliant' when it came out And that's what got IE into trouble. "No one follows the rules" is no excuse to not follow the rules and IE is a third-place browser because of it, in part. &gt;Ie6 wasn't horrible when it launched Yes it was. It couldn't follow the standard. Firefox did and quickly took a large bite out of IE's market share. About 10% within a year, iirc.
Today I see no reason to use Firefox stable over Firefox Developer Edition. I use Nightly and it is surprisingly stable (even more stable than stable :)))) ). I don't get it why e10s it did not land yet in Firefox stable.
The only advantage it has is with working with mobile, but other than that, I agree.
Looks like a leaky abstraction to me.
While it technically is a framework, Backbone is made up of four separate parts, two of which (Model and View) directly map to what you want. Then there's Collection (which lets you work with Model sets more easily) and Router (useful for creating "single page applications"). There's no Controller because Views tend to handle some controller logic, and plain old Javascript functions handle the rest. All of these pieces can be used completely independently from one another, and each one is pretty agnostic about how you use them. For instance, the View can either implement a "re-render after data changes" pattern, or a "modify the DOM in-place when data changes", the Model can be used with some convenience features for fetching data from the sever, or it can be used completely offline, etc. As an added bonus, because of its maturity the library is very robust/stable. Also, if you sort of like it, but not quite, there are several different "Backbone-like" libraries out there (eg. Dragon) which are similarly component based frameworks. 
Great article, I'm looking forward to experimenting with this stuff. :) thank you for taking the time to write this.
working on another project, a website explaining javascript and jquery. http://thatoneguy107.github.io/CodeCafe
Is this anything like rails migrations?
Most likely none, it looks hand obfuscated to me, ctrl + h
&gt;edges out Microsoft i see what you did there.
Is this what you're looking for? http://backbonejs.org/docs/backbone.html
nice find. i don't know of any alternative, but did find [a repository for it on github](https://github.com/epson121/jquery.maphilight).
Nice effort, but FYI [you (probably dont) need jQuery](http://youmightnotneedjquery.com/). [`element.addEventListener(string type, function listener, boolean useCapture) `](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) is supported everywhere, for example. So: $("#randomButton").click(function a() { can [safely be rewritten](http://caniuse.com/#feat=addeventlistener) as: document.getElementById("randomButton").addEventListener('click', function a() { ... ,false); 
Could you provide more detail as to why?
Thank you for your helpful comment.
Can I ask you how you have cleaned the code? 
If you set up a linter to fail on console.logs your pre-commit hook can instead disallow the commit, which forces a human to fix the problem. When you want to allow certain logs through you can mark those uses so that your linter allows them through.
Edge is worse than IE11 in my opinion. I keep going back to give it another try and it just annoys the hell out of me every time. Use Chrome almost exclusively at this point (even on an iPhone because Safari).
Backbone actually has really good annotated source code.
It always puzzles me why people have problems understanding prototypal inheritance, where it is actually much simpler thing than e.g. class inheritance. All of it can really be summarised in one sentence: *Whenever a property (incl. methods) is looked up on an object but is not set, it will be looked up on its prototype.* And to make it work, all you need is: newObj = Object.create(prototypeObj) No constructor, no `new`, no `this`, no `obj.prototype` etc. You might argue there is a need to go the other direction and access object's prototype from the object via `newObj.prototype`? Which is to mutate the prototype from a random object? Is there any valid use case for that in a well-designed architecture? Not that I can think of but I'd be happy to know otherwise. 
oh yeah, it is what I had in mind. 
http://toastytech.com/evil/index.html
I don't see anything out of the ordinary, but first [Math.random\(\)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random) doesn't take any parameters: &gt; The implementation selects the initial seed to the random number generation algorithm; it cannot be chosen or reset by the user. Furthermore: &gt; Note: Math.random() does not provide cryptographically secure random numbers. Do not use them for anything related to security. Use the Web Crypto API instead, and more precisely the [window.crypto.getRandomValues\(\)](https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues) method. Try it again with **crypto.getRandomValues()**.
I don't think that's actually the problem people are having. As you point out, it is dead simple. The trouble I have is understanding what exactly to do with it. What's novel and useful about prototypal inheritance? What does it enable that classical inheritance doesn't? You would never use the objects you import directly (can you even mutate things you import?), so the novelty of there being no "blueprint" is out, because we just unofficially consider certain objects the blueprint to instantiate copies of. The one thing that comes to mind is the ability to "casually" mutate objects, creating subclasses in a very easy way. You can just kind of attach new stuff to instances as you go. But I have yet to see a compelling example of doing anything like this. I just still haven't found a good example of *why*. Articles constantly repeat each other on *what*, but that's not really useful.
A good reason why is e.g. multiple inheritance. Look for articles by Eric Elliott on Medium, he writes a lot about why prototypal inheritance is superior.
For things like angular 1 scopes. Chances are if you use most js libraries or frameworks they do a lot of this under the hood and understanding it helps you use them better. 
Randomness often doesn't look random. 
Check out TypeScript.
That's not very explanatory. Multiple inheritance is enabled by classical inheritance as well.
I think that part of the reason that reduce is harder is because there is more stuff going on. With map and filter, you only really look at one item at the time, but with reduce you also have the accumulator variable which depends on the start value, all previous items in the list and the function itself, which means that there are much more things that you must keep in your head to reason about the function.
Why does that matter? JavaScript doesn't have class inheritance.
I second the "Look at Typescript" recommendation. What you are kind of doing here is a "Roll your own class system approach". While it may work it is not interoperable to the rest of the ecosystem, where objects don't conform do your class/interface declarations. So you would need to build wrappers for everything. Another thing is where to start and where to stop. You are basically checking method names, but no parameters or whether these are functions at all (you can however do this with `typeof object.method === 'function'). The typescript approach has several advantages: - It works with the whole bunch of Javascript and typescript objects (you can write definitions for external code) - It can check really complex interfaces (with all kinds of parameters, generics, "function interfaces", indexers, ...) - It also works on stuff like object literals. E.g. if you declare `var student = { method1: (x) =&gt; {} }` it will know that that object implements an interface. This is often what you want in idiomatic javascript, and not creating new classes for everything and modifying and checking prototype chains. 
Thanks! Glad you liked it.
For arbitrary files on your file system, you would need to go through open/save dialogs. https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications If you don't want the dialogs, if what you're saving isn't terribly large in size, and you don't have a specific location on your hard drive you need the data to be, you can use something like local storage (its like a cookie). https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API Going deeper, you can run a server locally on your machine. Then your page can talk to that server and the server can do pretty much anything you want - save files where ever even without needing a dialog. This can get you started, but its a far more convoluted solution than the other two: http://blog.modulus.io/build-your-first-http-server-in-nodejs
cheers, fixed!
I think you're right, you have to also understand recursion to some extent.
You can also use `if (a === void 0)`. If you use a linter, or are sane, `if (a === undefined)` is fine. If you work on a team that may have written some code that reassigns `undefined`, no coding patterns will save you :-)
This really is an excellent video on leading edge front end development.
And how would you classically implement new class extending two others?
I liked how they actually explore how to apply server side render, web workers optimizations, offline first in multiple frameworks (react, angular an ember. This demonstrate their dedication to make sure their services will work in any single scenario. Bravo.
You should build what interests you and release to the public after. If people want it they'll find it.
In JavaScript syntax?
You said classically, so naturally that wasn't JavaScript.
And what is the use of it when we discuss JS here?
Always like listening to Addy Osmani! Exciting tech, I hope the web wins this native race, because I like the browser API's.
Or Facebook Flow.
&gt; We see our first dog and think it's "sort of like the cat but bigger and obsessed with licking our face". When we do that, we have just applied the idea of prototypes. "This is generally like that, but with this particularity". &gt; On the other hand, classes represent a way of reasoning that, while more organized, is less intuitive and more rigid (too much at times). You'd meet that first dog and you'd think "oh, ok, time to revise my hierarchy of living creatures... there are now two types of the furry things". I don't see how this analogy differentiates classes and prototypes at all. If using prototypes, you might start off with `cat = {}`, and if using classes, you might start off with `class Cat {}`. When you discover a dog, with prototypes you'd do `dog = Object.create(cat, { /* bigger, licks face */ }`, and with classes you'd do `class Dog extends Cat { /* bigger, licks face */ }`. How is that really any different?
&gt; Whenever a property (incl. methods) is looked up on an object but is not set, it will be looked up on its prototype. Which is basically also true for class inheritance, no? 
Patterns are tools. I've had huge success using Redux where I handle local state where reasonable such as when I enter edit mode on a map or form. No need to call global actions every time a field or feature is modified. Only when: I start editing, I apply an edit, I save or cancel the session.
[AugAware](https://augaware.org/) is a project I've been leading for the last few months. It's a marketing site for the up-coming Deus Ex game.
Hmmm - "progressive rendering" where we deliver a minimal view with minimal functionality that allows for basic interactivity as the app downloads, then deliver more code that allows richer interactivity once that view has been rendered to the user? Sounds an awful lot like someone trying to reinvent progressive enhancement. :-/
I added quasi-random shuffle functions to my OS project [Fdrandom.js](https://www.npmjs.com/package/fdrandom). They are designed to shuffle without bias while avoiding collisions or nearness between 1-away and 2-away elements. It seems to be the only quasi-random shuffle utility on npm, which seems unusual because this kind of shuffle or sequence is much more reliable for [sampling](https://hal.inria.fr/hal-00113368/en ) than pure random sequencing is. There is a bit of a writeup on the functions [here](https://github.com/strainer/Fdrandom.js/blob/master/antisort.md) and a chart suite of the lib which includes the functions performance [here](http://strainer.github.io/Fdrandom.js/)
If I understood it correctly, with progressive enhancement you aim for usability when the user doesn't have enough resources or uses old software, so maybe you can have the first part (deliver minimal view with minimal functionality), but only to users that cannot display or run the additional niceties. Once the contents have been downloaded and the view is rendered there is nothing left to do in PE.
Who is stupid enough to use the internals of a library instead of the public facing API? I would love to hear their "justifications" for this type of "logic"
that seems like a big waste of time to be honets
Added a new map to a counter-strike related mini-game I've done previously. You can check it out here: https://bitbucket.org/drk4/cs_spot_names 
Yeash.... I know.... I follow Servo's blog. I built it locally and I saw the web render demos. But e10s will land this year, Servo will not.
A) I am writing gameplay code for a game engine that uses Javascript on top of a C++ core. The only consumers are myself and the development team, so any paradigms we want to adopt are fair game. B) Adding an extra language layer means our version control system becomes more complicated. Do we store both the "compiled" javascript files and the source TypeScript? Do we just store the TypeScript and double-compile everything before testing the game? These are things that I won't necessarily have any control over, so using pure Javascript is probably the best option until I learn otherwise. I appreciate your perspective, and you're right that TypeScript was designed to solve all of these problems. I was just looking for ways to do C# stuff using only basic Javascript as part of learning the language.
I should have specified in my post that I will be writing gameplay code within a game engine that uses Javascript on top of a C++ core. This gives me some flexibility when it comes to the wider Javascript ecosystem. Basically, any paradigm that the development team wants to adopt is fair game, since we'll be the only ones using the code. TypeScript looks really great, but I'm not sure it's something I will be able to use. It brings up a lot of issues regarding version control and compilation that I won't necessarily have control over. Yes, the examples I gave were very short and didn't test everything I could or should have. Javascript just doesn't have the tools to be able to test return values and parameter types as completely as I would want. I was just showing the basic principle behind the idea, rather than any kind of finished production-ready code. My main hope was that I was actually understanding the language correctly and not making any super obvious errors.
I think that statement only applies to business logic Comp Sci stuff.
I feel like you didn't even bother reading my post, you just saw the title and immediately thought of TypeScript. I was attempting to provide useful and fast interfaces using nothing but basic Javascript code. TypeScript can do all this, but I don't think I will be able to code in another language for my new job. Even one that compiles into Javascript. On top of that, TypeScript is a convenience. If I get used to just letting TypeScript handle all this stuff for me, I would have no idea _how_ it's actually being done. If my question is "how can I create interfaces in Javascript?" then the answer "just let TypeScript do it" doesn't really cut it.
Ugh, yea, sorta frustrating that they didn't go the extra mile to stop supporting ALL forms of IE. Not that IE11 is terrible or anything but if it's not being updated with new ES specs then for the foreseeable future I guess we'll need to use Babel even just for ES6.
You're gonna blind someone with that gradient.
Although I hate the [Atom](https://atom.io/) code editor with all my heart, I have to recognize that their project might be a good starting point because of the [DogFooding](https://en.wikipedia.org/wiki/Eating_your_own_dog_food) effect. You will be using the application to modify its functionality writing extensions or improving its performance while putting in practice what you already know about JavaScript and learning more in the process. There is a ton of things you can help with — [Atom Issues](https://github.com/atom/atom/issues).
How does that work with reducers, though? Do you just say, as we did in the playgrounds, "this is what I started with, this is what I did with it, and this is what I ended up with"? Because if you want to play with state, you should always know what gets changed, how and why...
You want to learn JavaScript? That's excellent. But don't run an academic experiment in your production system which adds technical debt your entire team will forever pay off. Everything you need TypeScript can do better and adding it as build step would take literally ten minutes. TypeScript is a superset of JavaScript. You don't need to use any TypeScript features you don't want. If all you're trying to do is declare interfaces then that's the only feature from TypeScript that you have to incorporate. &gt; I feel like you didn't even bother reading my post I did read the post. You're getting defensive over something you asked others to look over. _You_ asked for feedback. You're making wooden wheels for your car then taking issue when someone tells you to get rubber tires.
Thanks, that is a great suggestion! I tried Atom a while back, but went back to Vim later. Maybe this time I can try to improve it so it works better with my workflow :) 
Each subcomponent has a method that validates and compiles it's children's state fractally using their identical method. This lets me take a complex object, break it up to the children that care about the pieces in the form, then when the user hits save, compile the updated object after any mutations and then call a Redux action on that. The transient state is not important to the rest of the app. There's just an enter and an exit to form editing. 
It sounds like you want to build a desktop app with Web technologies. This is exactly what electron is doing! 
The fact the behavior is documented does not absolve an abstraction leak. For example, if we had to handle hardware memory faults in JavaScript in a browser, it would still be an abstraction leak in a number of places (hardware, os, application, runtime) regardless of it being documented.
I wrote a little express middleware that lets PUT commands write files back to the hard drive: https://github.com/ericlathrop/express-serve-writable. It's a security risk, but can be handy for little personal tools.
Can someone TL;DR: this for me?
You are super obsessed with prototypal inheritance, OP.
ah yes I know you're right. I will make some effort to commit properly now you mention it. Thanks :)
Ah that was it - looking slick now
I mean, there's only the bundled files in dist. My reasoning is: because they're not versions of code, i.e., I would never need to go back to a previous bundle, it doesn't make sense to track it. Also they're pretty big (2mb for the map). 
This is awesome!
I don't understand if you want to do such library or ask for somebody to do it. If you want to do such library then yes, I think it would be useful. If you want somebody to make software for you, you should be ready for pay money for it. If you're too lazy to build tools for your work and think that this seems "like a big waste of time", you cannot expect anybody to waste time for you for free. Maybe I don't understand correctly your intentions, but this submission seems very rude (like "I'm too lazy for wasting my time, do it for me, because I want that"). But overall idea to build tool for building landing pages - I think it's good. Landing pages are very similar, so they have high potential for code reuse. The risk is though, that landing pages are rather fad and will disappear eventually (because they give no value for user at all. They usually present boring marketing bullsh*t with the same layout over and over. Landing pages are against of modern web development. Usefulness and information are the future - and landing pages are useless and have totally zero of information value, zero of content). 
deb.js looks interesting, I'll give it a shot. These are useful tips, I'm constantly surprised how few people know they are built in to dev tools.
Any feature can be abused. Doesn't mean it bad or good. You can use knife to kill. Yet people still use knives. 
As far as I can tell, heroku works in such a way that it's an extension of git. To push to heroku, you run `git push heroku master`. In point of fact, anything in `.gitignore` will not be uploaded. So, if I log into my app via bash, the file structure is identical to the repo. Frankly, it doesn't make sense to me either, and I've been stuck trying to figure it out for 2 days now.
Thanks, it is always interesting to see the other side of the coin. But I wish I could see more stuff that would actually help me write better code and be more productive. I prefer to simplify complexity over complexify simplicity ;) And for my purposes, the prototypal inheritance achieves results simpler and cleaner. To be fair with Eric Elliott, I have yet to see a proof that anything he says is "flat wrong". The only real substance in that reddit discussion is about the definition of what "object composition" is. But the only quote from GoF I see is: &gt; Object composition is defined dynamically at run-time through objects acquiring references to other objects. Which is NOT a definition! It is NOT defined here at all, how exactly references are "acquired". Beside, in JavaScript everything happens at run-time including the class inheritance, so that distinction adds more obscurity than clarity. What is also clear, the very usage of the term "run-time" indicates that the quoted "definition" was not even meant for languages like JS. So how can you blame Eric for using his "object composition" in a broad sense in attempt to make it more useful for JS and easier to understand for all of us? But again, at the end what counts is the value you get from reading his articles. I personally found some of his advises really helpful to get things done is a simpler and cleaner way and that is what really matters. Besides I find his JS book one of the best, and very generous of him to offer it for free to read: https://ericelliottjs.com/product/programming-javascript-applications-paper-ebook-bundle/ I am not affiliated with Eric in any way but I have found real value in reading his articles and want to be fair with people who provide value to me. 
It looks like you want summonerName (not summonerId). Other than that, it seems to be correct. What happens when you console.log(name); ?
assuming the structure is: obj = {"participant": [ { "player": { "name": "3card" } } ]} obj.participant[0].player.name
Crockford's old videos (Crockford on JavaScript, and the even older lectures at Yahoo!) make a point of showing how certain things about JS that *look* like C++ actually work differently; below are some important differences I can think of. **TL;DR:** Watch the videos, then come back here; most of this content is covered there, but not all. --- Strings are primitive, immutable values, while arrays are mutable objects; meanwhile, in C++, an array is a special kind of constant pointer and a string is a mutable array of characters. ~~Originally I had a comparison with regexes, but it turns out C++ regexes are even less "literal-like" than regexes in JS.~~ (Okay, for regular expressions and functions in JS, the most important bits aren't mutable, but they still are objects and still can have members added and altered.) --- Functions are first-class values: They can be passed into and returned from other functions, the same way other values can be. Something similar can be done in C++ with "function pointers" but in JS, functions can be treated as values without any special effort. --- It is fairly common to extract methods from objects and call them on other objects (`&lt;function&gt;.call(&lt;object&gt;,&lt;list of args&gt;)` calls `&lt;function&gt;` as if it were a method of `&lt;object&gt;`, with `&lt;list of args&gt;` as its argument list; the `.apply` method of functions uses an array instead of a list of arguments, in case the number of arguments is not known at authoring time, and the `.bind` method fixes the call site and allows for partial application), rather than re-implementing them for each inheritance tree that an object may have; methods that work this way are referred to as "generic" and in particular, the array methods can frequently be called on strings and "array-like" objects, such as a function's internal `arguments` object, and the collections that many DOM methods output. (However, the aforementioned `.call`, `.apply`, and `.bind` methods are *not* generic, but there are only a few corner cases, in a few older browsers, where there are callable objects that don't have the function methods to begin with.) --- Those corner cases are found among "host objects", which the spec allows to have all sorts of implementation-defined behavior; even then, some host objects have behavior outside the bounds of the spec, like the HTML5 spec says that if a browser implements `document.all` for compatibility with oldIE, it must coerce to `false` as a boolean (even though all objects, even `new Boolean(false)`, are supposed to coerce to `true`), and it must be loose-equal to `null` and `undefined` (even though those two values are only supposed to be loose-equal to themselves and each other). Host objects, in particular DOM methods, explain most of the bad reputation of JS. --- There is no compile-time type enforcement, whether for variables or for return values; similarly, there are no enforceable function signatures. However, optional *run*-time type enforcement exists (via mechanisms like the `typeof` and `instanceof` operators, inspecting `Object.prototype.toString.call(&lt;value&gt;)`, and checking a function's `.length` property or `arguments.length` as described below), and this is largely why TypeScript, a strongly typed language that compiles to JavaScript, is possible. --- Functions are implicitly overloaded: For each resolved symbol in a given scope that has a function value, there is just one function, and the code inside the function determines how to deal with different numbers and types of arguments that it may be called with; there is an implementation-dependent limit on the number of formal parameters in a function definition (known as its `.length` property), and on the number of arguments in a function invocation (accessible inside the function as `arguments.length`), but a function may be called with more or fewer arguments than its formal parameters. --- Speaking of scope, most constructs before ES6 are scoped to the innermost functions they're defined in (lexical function scope), or to the global scope if outside any function; the `catch` block has a special block scope for the catch parameter, the deprecated `with` block has such a scope for its parameter, and some new ES6 constructs, like `let` and `const` declarations, follow block scope the way variable declarations in C++ do. --- JS is single-threaded; however, host objects available in many environments, like `setTimeout` and Web Workers, can create or simulate multiple threads, and on the whole, asynchronous programming is common. Web Workers, in particular, use a form of message-passing that prevents many of the issues that can arise when multiple threads can modify the same variable. --- There are no pointers: There are reference values, but all objects (anything but the primitive types known as undefined, null, boolean, number, string, and symbol, the last of which is new to ES6), and *only* objects, are reference values. All function arguments are passed by value: It is possible to modify the members of an object argument, and have those changes persist, but if an argument itself is reassigned, any changes made to the reassigned argument will not persist. All equality comparisons are by value, with comparisons between objects checking whether they refer to the same object value; however, the loose equality operators (`==` and `!=`) will try to coerce objects to primitives when comparing against other primitives, and then the values to be compared are not references. --- On that note, the equality comparisons you're accustomed to are for loose equality, and the *strict* equality comparisons (`===` and `!==`), which do not perform type coercion, are preferred in almost all cases; the major exception is when checking whether a value is either `null` or `undefined`: `val == null` vs. `val === null || val === undefined`. --- Unlike most programming languages, there are two values for "nothingness": `null` is most like what most languages use, and it should be what you use when you want to explicitly set or return a value of nothingness; `undefined` is most commonly seen as a default, like the value of a non-existent object member, or of an uninitialized variable, or the extra arguments of a function not called with the full set, or what is returned with a bare `return` statement or by a non-constructor function that runs through all of its statements without an explicit return (`null` does naturally appear at the end of all prototype chains, however). Another issue with `undefined` in older engines is that it's not a reserved word, so it could be reassigned; this is why many immediately-invoked function expressions (IIFEs, a common pattern for private state) have a final formal parameter called `undefined` and are called with one too few arguments, and why others have just an uninitialized variable called `undefined` (another common pattern for one-off scripts not contained in any function is to use `void 0`; rather than being an indication that a function doesn't return a value, `void` is a unary operator that reliably returns the `undefined` value). --- Numbers are all 64-bit IEEE floating-point, with all of the various NaN values represented by `NaN`, which like `undefined` is not a reserved word and may be reassigned, although `0 / 0` will reliably return NaN (a similar thing is true for `Infinity` and `1 / 0`, respectively); following the IEEE spec, `NaN != NaN`, but `-0 === 0` even though `1 / -0 != 1 / 0` (they are `-Infinity` and `Infinity`, respectively). A new ES6 function called `Object.is` is like the `===` operator except that it compares NaN equal to itself, and -0 and 0 as different. --- The bitwise operators may be hyper-efficient in C++, but in older JS engines, they were slow, because they would cast the numbers to 32-bit integers, and their outputs would be cast back to 64-bit floating-point; however, newer JS engines are able to optimize common patterns, in much the same non-intuitive ways that optimizing C++ compilers can. --- Regarding the manner in which `Object.is` is defined, JS has no proper notion of namespaces, so to avoid polluting the global scope, the spec has defined new functions as methods of existing objects; the `Math` object is full of such functions (originally it was set apart so programs could potentially jettison it if they didn't need the mathematical functions, analogously to Java, but it turned out to be infeasible to allow any part of the JS standard library to load only on demand), the `Reflect` object in ES6 has a few more, and the proposed `SIMD` object will have another such collection. For ES5, the `Object` constructor was the most-used namespace, and most of its new static methods did at least look relevant to objects specifically (like `Object.create` and `Object.defineProperty` and `Object.getPrototypeOf`). --- There are keywords like `class` and `extends` and `super` and `static` starting in ES6, but they don't quite work like classes in C++, and instead they're mostly syntactic sugar around the use of ordinary functions as constructors, directly working with their public `prototype` properties, etc. --- Objects can be created without setting up classes: Plain objects (usually created with the initializer syntax `{&lt;prop1&gt;:&lt;val1&gt;,&lt;prop2&gt;:&lt;val2&gt;,&lt;etc&gt;}`) are much like what other languages call "hash tables" or "dictionaries", and more purely dictionary-like objects can be created with `Object.create(null)`, without even the methods that most objects inherit from `Object.prototype`; this fact makes the singleton pattern incredibly easy. --- I ended up making like 8 blog posts' worth of observations (16 mini-sections), and there are surely more; the overarching point is to **pay attention and not think you basically know how the language works just because the syntax is familiar**.
The abstraction is not just the code, but the contract on how it should behave. If the abstraction contains limitations because of the underlying dependencies, but it succeeds documenting on how it behaves (as counter intuitive as it might be), then it doesn't mean the abstraction leaked, because the user don't need to know about the underlying dependencies or having to think about something outside that abstraction, it means the abstraction is not very good. Of course the abstraction will still be weird and counterintuitive, but if the consumer of it don't need to know why, then it is a successful abstraction, because it didn't unexpectedly leaked to the final consumer.
It is not as simple as that. The article mentions a few cases where undocumented behavior should be considered a legit use case because of the implicit functionality. It is impossible to document everything, and sometimes we need to make assumptions on the consumer, and that is dangerous. As everything, it depends, and it is important to understand the cases where undocumented behavior should be considered an implicit functionality or not. There are even disagreements over the fact that you should treat a library and programming language the same way.
Yes, I think I can try that as well. I happened to use hooks because I did not want it in the src either.
&gt; If the abstraction contains limitations because of the underlying dependencies ... &gt; the user don't need to know about the underlying dependencies ... https://en.wikipedia.org/wiki/Leaky_abstraction &gt; In software development, a leaky abstraction is an abstraction that **exposes to its users details and limitations of its underlying implementation** that should ideally be hidden away. It's a leaky abstraction.
The day I learned about `debugger;` really changed my world.
I would actually argue that if (a === 'undefined') is safer. If it is used inside function with `a` as argument (as in the article), the outcome is exactly the same. However, if used outside or does not match function's argument, the global `window.a` will be checked, which you usually want to throw an error to catch the bug. As opposed to swallow with the type check. And the worst of all if you use it inside a module, deceiving yourself into thinking only your local `a` is checked, where in reality, it becomes global the way modules are loaded with `webpack` or `browserify`.
well you can rest easy, javascript is definitely one of the biggest growing [open source] communities of 2016
Not to be 'that guy', but you're taking an elitist approach. Programming languages is hardly different from real life languages. I may be adept at 6 OOPs and 2 or 3 FPs but JavaScript is in the 'cutting edge' department; there's no real answer to your question besides the same ol' goodies suggested to everyone.
When you bundle your callback gets stashed. The function reference you give to the maps API will point to the stashed entry inside the bundle. .. or I don't understand the question, i never had to put anything in window before.
Do you have an example? By stashed do you mean scoped? It's not a function reference I'm giving to gapi. It's the name of the function via url. eg: &lt;script async defer src="https://maps.googleapis.com/maps/api/js?key=[MYAPIKEY]&amp;callback=initMap"&gt;&lt;/script&gt;
A difference is, with recursion your function calls itself from its definition. With `reduce`, you iterate the function calls, but the function does not call itself on its own.
This sounds like jsonP. Do you have an alternative api to use?
Service workers + Server side render + manifest + cache = ♥ good app ♥
Yes, the callback has to be accessible from the global namespace, so you have to attach it to window. I would recommend keeping the JSONP callbacks in one global object, so you at least clutter the global namespace with only one reference. 
You shouldn't need to push dist, no. You can use a postinstall script to execute `npm run build`. See [here](https://devcenter.heroku.com/articles/nodejs-support#customizing-the-build-process) in the Heroku docs for more info!
Not sure if i see "the problem". Redux state is just that, a predictable state based on state-action reducers. React internal state in react components have literally nothing to do with redux state. The fact that you CAN couple react to redux is just for convenience by way of the redux-react connect binding. As the author of [redux-es5](https://github.com/rook2pawn/redux-es5) I am investigating a broader, generalized connect call that would make binding to react components a specific case of a generalized call, so you could make ANY kind of components you want, and not even have to use react. Tightly coupling is not a requirement of redux or react, and you can use one, or the other, or both, and even if you use both, you don't need to tightly couple: just don't call connect to create container components. I feel that the author may be reacting to something that is actually not a problem, but I do recognize he is hinting at something that may be a problem in the future where redux is assumed to be tightly woven to react, which would be terrible because it WOULD validate his fears that we now have this big-ugly-behemoth framework. Currently we haven't reached that area yet, but good on him for at least calling out a potential concern. 
Of course, I'm not saying the two types of inheritance are identical. But I think it's useful to explain prototypal inheritance in comparison to class inheritance - and your "one sentence summary" does nothing to explain that, because it applies to both. 
You can't really expect one sentence to check multiple boxes ;) It gives a precise essence of what prototypal inheritance does to a JS programmer with some general knowledge of JS. That is all. Comparison to other kinds of inheritance is actually what often causes more confusion than help. Because it is not needed. If you already know classical inheritance well enough, you know it well enough to make the comparison for you. If you don't know it well enough, it will more confuse you than help. 
&gt; Composition is not also known as multiple inheritance. The link you referenced wouldn't even make any sense if you believed that. Unless you think it was explaining the virtue of "multiple inheritance over inheritance". &gt; Ok, I'm not aiming to enter theoretical argument here. All I am interested is the practical use. And for the practice, I find it much easier in JS to use prototypal inheritance to compose properties that for my use cases plays the same role as multiple inheritance would do -- get methods from 2 objects onto 1. If that is not multiple inheritance, then I don't know what is it. As for other languages, whether they give that luxury or not, we are in JS sub here, and the matter is of no use to write our JS code as far as I can see. 
To make it more convincing and less theoretical, all you need is to provide a compelling example showing the advantages of classical vs prototypal inheritance **in JS** relevant to multiple inheritance. ;)
Is that something you are looking for? http://codereview.stackexchange.com/questions/59678/simple-async-google-maps-initializer-with-angularjs
In Israel there is a huge demand for Javascript developers (actually for any developer) 
wow really? I know nothing of Israel I will look into it now, Any place in particular? Do you know people there then?
Do you speak only English?
It is very distracting when you are walking around and the camera is shaking. Other than that nice explanation
I think what he is trying to say is that in React you don't directly manipulate the DOM, instead you change your current state in your component and React will look up what has to be updated in the DOM and then does that by itself. Whereas in jQuery you have to manipulate the DOM all by yourself. So yes, in the context of DOM manipulating, jQuery would be imperative.
Thanks!
&gt; Unfortunately, this is the problem of many similar discussions. Examples are either lacking, or badly designed, or more contrived than convincing. That's because you completely ignored the example I actually linked you to and instead responded to someone else's that wasn't even trying to demonstrate the same thing. Way to dodge the issue.
Nice..!
Not even JavaScript's prototype chain provides multiple inheritance. var A = {}; var B = {}; var C = Object.create(A or B?...) JavaScript's prototypes let us inherit from one but not both. Its prototypes suffer the exact same limitation as its classes. So regardless if we're using prototypes or classes, if we want multiple inheritance, we'd have to implement it manually. And the way we would do that is the same whether we were in JS or C. We'd copy function references around. Multiple inheritance is not a feature of JavaScript's prototypes. It's a limitation of the prototypes. Which is why multiple inheritance is achieved only when we forgo the prototype chain and start implementing inheritance ourselves manually.
&gt; get methods from 2 objects onto 1. If that is not multiple inheritance, then I don't know what is it. That *is* multiple inheritance. But that is *not* composition. It's genuinely important to understand the difference, because the rule to "favor composition over inheritance" means you should avoid if possible even multiple inheritance.
Yes, at least when it comes to the DOM manipulations. What he means by this is that in jQuery you have specify which DOM changes you want and in what order they should happen. `remove` this element, `appendTo`that, etc. Your transformations are a series of commands that must be run in a particular order to achieve the desired result. With react, you specify what the DOM should look like based on the state and props of the component. You don't have to write code to manipulate the DOM yourself; react takes care of that for you behind the scenes. As an illustration, let's say you have a button that you can click to increase a number. Every 10 clicks, you want to output a message, then remove it on the next click. In jQuery this might look something like this ([jsbin here](http://jsbin.com/mojepirege/edit?js,output)) const $increaser = $('#increaser'); const $output = $('#output'); const $clickCount = $('#clickCount'); $increaser.on('click', (e) =&gt; { let count = +$clickCount.html(); $clickCount.html(++count); if (count % 10 === 0) { $output.after('&lt;p id="milestone"&gt;Milestone reached!&lt;/p&gt;'); } else { $('#milestone').remove(); } }); It's a contrived example, but note that you have to imperatively manipulate the DOM to get your desired output. In react, a component with the same functionality might look something like this ([jsbin here](http://jsbin.com/yuxudidaqe/edit?js,output)): class Clicker extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } handleClick() { const { count } = this.state; this.setState({ count: count + 1 }); } render() { const { count } = this.state; const milestone = (count &amp;&amp; count % 10 === 0) ? &lt;p&gt;Milestone reached!&lt;/p&gt; : null; return ( &lt;div&gt; &lt;button onClick={this.handleClick.bind(this)}&gt; Add One &lt;/button&gt; &lt;p&gt;{count} Clicks&lt;/p&gt; {milestone} &lt;/div&gt; ); } } ReactDOM.render(&lt;Clicker /&gt;, document.getElementById('clicker')); The big difference is in the render method. Instead of imperatively manipulating the DOM, you just have to _declare_ what the component should look like given its current state (and props, but this example doesn't use them). React will handle the nitty gritty DOM manipulations for you whenever the state changes.
I think you adress proper problem but nomenclature is weird. Maybe I'm not sophisticated but I haven't yet understand "saga" concept (like in Redux Saga) and now I have to understand fractal saga concept, which seems even more weird. It sounds mega-cool, though. And I think if I understood what it is I would like to buy t-shirt with "Fractal Saga" written on it... But I think this omni-weirdness of modern frontend dev is another barrier to entry for novices...
That's an oddly specific use-case lol. Care to tell your story?
Nice! How did you do the video distortion effect?
Thank you, and noted, you can expect further posts to have that feature :)
Thanks, appreciate it! :)
Glad you like it, thank you!
Do you think I should link the course in the article?
There are many start-ups in Israel, Israel is known as the "start-up nation" these days I am an Israeli Javascript dev 
k then
Yup, the new java :) 
You can use the greater/less than operator [like so](http://jsbin.com/wegofufiru/edit?js,console)
There's a canvas element on top of of the video that uses an SVG source image. There's a a little pre-processing then it randomly renders parts of the "glitched" image. With non-youtube videos it's possible to use frames of the stream as the canvas source. 
Functional Programmer's toolbox and no haskell examples?
Are you referring to this? [reactivex.io/learnrx](http://reactivex.io/learnrx)
Actually, I am just starting out with Elm, so thank you for the link! :)
Perfect, thanks. After looking at you codepen, I think that might work out better for what I am doing. For now, though, the gif fix worked perfectly. For reference: appending ? + current time fixed it: &lt;script&gt; var images = document.getElementsByClassName('img-thumb'); function swapImage(event) { event.target.src = 'http://example.com/images/switch_test.gif?' + new Date().getTime(); } for (var i = 0; i &lt; images.length; i++) { images[i].addEventListener('click', swapImage); } &lt;/script&gt; &lt;img src="http://example.com/images/switch_test_off.gif" class="img-thumb" /&gt; &lt;img src="http://example.com/images/switch_test_off.gif" class="img-thumb" /&gt; &lt;img src="http://example.com/images/switch_test_off.gif" class="img-thumb" /&gt;
The problem with this approach is when you click on the thumbnail you have to wait for the animated gif to load and using gifs the animation is sometimes jumpy which isn't great. I'd definitely look at CSS3 options if all you want is a toggle button as it's the best way to do it.
Very interesting! Thanks for sharing!
I like that various paradigms are becoming more accessible to javascripters. I hope it introduces more people to software engineering and how coding is like 5% of the job.
Yep yep! Do you think I should have one example for es5 and one for es6 or just es6? Thanks for the feedback :)
Nice! One note: I think "takeWhile" is essentially [Array.prototype.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some) in JS unless I'm misunderstanding something so no need for a third party lib like underscore.
It ended up being that I was doing my callback wrong. callback(total) instead of callback(null, total) Thats why I was getting error (2). I was sending the value 2, and it wasn't being caught.
JavaScript isn't virtualized or proprietary, a significant difference.
it was for my learning purposes. i wanted to understand the test process more deeply now im testing the functions and looking to expand it.
Hi /u/Fabel873, I know he started it, but the proper response would have been to report the comment and move on. Please don't lash out again.
I was ready to give up on modern web development if this was really a thing people were doing. Well done lol
No, i mean that we will realize in ten year's what a horrie idea it was. Juxt like java :) 
You are right, I had missed that difference, and rereading how it's useful for sorted lists makes it clear what each is for. 
Oh totally you're right. I skimmed the description and didn't look at the result, just the signature for the callback hehe. 
What we did miss was some kind of Components. Seriously, thinking of complex UIs in Components is naturally saner. However, this requires coupling of View framework (React) with Redux. Frankly, the article is not about problem with Redux, the problem is about problem with Redux in context of real application.
You don't need a separate library to make incorrectly implemented JavaScript code fail at run time, JavaScript takes care of that for you already.
Do not forget to mention immigrants and residence. 
Thanks for the feedback, I appreciate it :)
I am a Czech developer, but I have worked in London and Munich as well. I think London/San Francisco are two best places in the world you can live if you are a software developer.
full disclosure: this is my blog.
2 would probably be clearer with an arrow function and template string than with the iterator.
Remember that getElementById() IS technically a method/function, and it accepts one parameter. Most often, that parameter isn't necessarily dynamic, so we hardcode it as a string (e.g., document.getElementById('someId');) However, if you have a variable/instance variable, such as in your example, that is set to a string, that isn't any different than directly typing a string in as an argument. 
ok yeah i had no idea about `postinstall`. So my postinstall script just needs to be my build script, which is `npm run build`? Or does it need to know to start the server too, so `npm run build &amp;&amp; npm start`? On the docs, they have `"postinstall": "bower install &amp;&amp; grunt build"`. Does that mean it needs to be: `npm i &amp;&amp; npm run build &amp;&amp; npm start`?
I actualy just finished codecademy about a few days ago and jumped into creating stuff through javascript . So my grasp on the languange arent good at all as I only know the syntax of functions/for loops/objects/etc. Is there an article or any learning soruces I can read to gain clarity for this?
Ahh I probably should have clarified that part. The buildpack also generated a "Procfile" inside the slug that tells heroku how to run it. For a node app it uses "npm start". So by the time heroku is trying to run "npm start" for your app, all those things above have happened. This is so "downloading node" "installing dependencies" "generating bundle" "creating slug" "uploading slug" don't have to run every time your app starts - just once (when you pushed new code). Your postinstall script can just be "npm run build".
That function lets someone call, say `gotoDiv("bacon", "eggs")`, which would have the effect of, document.getElementById("bacon").style.display = 'block'; document.getElementById("eggs").style.display = 'none';
Yup! but what im puzzeled on is that the parameter,bacon and eggs, are variables, so why is getElementByID used? as I thought that it is only restricted for id's.
Try https://github.com/reek/anti-adblock-killer
They're not variables in his example, they're strings. Notice they're wrapped in quotes. var bacon = "bacon"; In this example, my variable bacon has the value "bacon". Notice the difference now? In the code that you posted you have a function *declaration* for gotoDiv, which uses its parameters as arguments for the getElementById function. Later, the gotoDiv function can be *invoked* with some strings that point to html elements with ID attributes on them like so: gotoDiv("myId1", "myId2"); This will execute whatever was inside the function declaration, like so: document.getElementById("myId1").style.display = 'block'; document.getElementById("myId1").style.display = 'none';
How did that pass 3 code reviews???
&gt;‘Write more unit tests’ is not the answer to this problem. After all, unit tests were written and the bug still got through. There is a lack of a logical connective between those two statements. I might argue that you should just throw a few values into an array and iterate over a range of inputs to test the outputs. I would also argue, however, that your API is weird, and that's actually a deeper problem. Accepting null and defaulting to 1 makes sense. Accepting 0 and defaulting to 1 is weird. The former allows you to call with a different set of parameters, and get sensible defaults. That's great. But if you see 0 here, that's more likely to be a programming error. You probably didn't accidentally pass 0 directly, and if 0 is coming as the result of other operations, there's a good chance that the user of this code did not consider the 0 case. This is why, while I think `||` can be fine for defaulting when you expect an object, it's probably not a good idea when you're expecting a number. Instead, it would be better to go with `state.enquiryForm.numberOfGuests != null ? state.enquiryForm.numberOfGuests : 1`. A side benefit is that you won't end up accidentally using a bitwise operator.
EVERYTHING MAKES SENSE NOW
Thank you so much for the help guys!
You were missing a period in your selection statement. Your add event listener method was spelled wrong too. Also, when you call clickPointer, you probably want to reference the item that was clicked and not all matched items. See below. var sliderHighlight = document.getElementsByClassName("sliderhighlight"); function clickPointer(){ alert("Hello"); this.style.background = "blue"; } for(var i = 0; i &lt; sliderHighlight.length; i++){ sliderHighlight[i].addEventListener("click", clickPointer); } 
Not composition? Maybe I have a wrong definition ;) Which one is yours? 
 AB = Object.assign({}, A, B) C = Object.create(AB) Can it be easier than that? You can even write a 1-line function `inherit(obj1, obj2)` doing exactly that ;) Or even better - make it polymorphic `inherit(obj1, ...., objN)`, still with 1-liner: const inherit = (...args) =&gt; Object.create( Object.assign({}, ...args) ) Now I want to see the simplest example implementing it using classes in JS. ;) 
The code was indecipherable at first glance but I found the bug almost immediately.
Except that there will be no court bullsh1t if somebody copies the code. Ling live the freedom!
I know I'll get flamed for not knowing this, but is JS efficient enough as a language to handle high end games or media editing suites?
Err yea of course, but.. Err.. Sigh lol. Cheers but I tried that ;) It's like recaptcha.. It needs to be loaded differently or it'll just not show. 
Oh, article by Eric Elliott. No thank you. Mocha is started in 1-2 and then you good to go with your tests. Most of the article is self-advertisement and too much ego to show he knows the stuff. Why did you even considered his article as something sane? Everyone knows that Elliott is full of bshit.
This library seems really strange, and at first glance not very useful, or similar to SQL. There is no such thing as a "JOIN query" in SQL. JOIN is simply a construct that allows you to query multiple tables at once, but you still need a SELECT (or other) query to get the records and fields you want. It would be neat if we could do: query().select('foo.x', 'bar.y') .from(foo) // an object .join(bar) // another object .on('foo.id', 'bar.foo_id') But the only thing this library does is basically zip two arrays together?
OnShape is a serious software. It was made by the team that made the SolidWorks CAD application. It behaves so fluid and focused the original SolidWorks can only compete with features, since OnShape is still young.
I don't think the missing parameter trick is a good idea. Either make the parameter optional or raise a proper error if it's undefined/null/invalid. Then you fold that missing parameter boilerplate into some validation boilerplate, which is more useful.
BTW, I have to say, not only your answer makes absolutely no sense to me, it also inconsiderate to other readers to give such a syntax formula as "answer" not using the language of the forum (JS) and not even mentioning that. It is like I would answer something gibberish in Russian to you, how would you find that? So if you still care, please give a proper explanation accessible to people familiar with JS. 
You should definitively have a look at Angular 2, you get static typing via Typescript. For a Java developer its instantly familiar and you don't need any cross training. It also uses design patterns familiar to Java developers, like dependency injection or the extensive use of classes. You can even use the dependency injection container on the backend as well, and structure your whole application around it. Its possible to render the page server-side, serve HTML to the browser and then the app takes over in the frontend as a SPA, so you get the holy grail of web development: a SEO friendly single page app.
If you like the MEAN stack, I would suggest you take a look at Meteor also. It could be described as a pre-built MEAN stack, but you have the option to also use React or Blaze as front end layer.
Yes (ish) - as a language. Not if it is being interpreted though which is the normal way JS is run. You would need to use an efficient subset and then compile it to LLVM. See Unreal in browser demo.
good tips, thanks. Regarding no-bitwise, I mention that in the 'lessons learned' section. 
I think Deming summed it up pretty nicely: &gt; 100% inspection is only 100% effective if the inspector detects 100% of defects 100% of the time…which is impossible due to human nature. After all, if humans were that precise there wouldn’t be any defects made in the first place.
You cannot access local files via Javascript without prompting the user to select them. What you want to do here is either save it server side and load via ajax, or use the localstorage: http://www.w3schools.com/html/html5_webstorage.asp Apart from that you don't save data in JavaScript files, but in JSON. that way your file would look like this: "{ "theQ": [ "fDate", "dDate", "dDOB", "FirstName", "LastName", "Gender", "DOB" ], "theA": [ "20160523", "05/23/2016", "01/12/2000", "Mary", "HadaLamb", "Female", "2000-01-12" ] }" You can save your items to localstorage like this: localStorage.setItem("theQ", JSON.stringify(theQ)); localStorage.setItem("theA", JSON.stringify(theA)); And get them back like this: try{ var theQ = JSON.parse(localStorage.getItem("theQ")); var theA = JSON.parse(localStorage.getItem("theA")); }catch(error){ // most likely the values are not there, // JSON.parse throws an error if the input string is not properly formatted console.log("following error occured: " + error) } Reading your code further you don't have to use two arrays, simply use an object for storing the key - value pairs: var lastInput = { fDate: "20160523", dDate: "05/23/2016", dDOB: "01/12/2000", FirstName: "Mary", LastName: "HadaLamb", Gender: "Female", DOB: "2000-01-12" } You can iterate over an object as simply as that: for (var key in lastInput) { if(lastInput.hasOwnProperty(key)){ document.getElementById(key).value = lastInput[key]; } }
I don't really see how those imbricated templates const tmpl = addrs =&gt; ` &lt;table&gt; ${addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt; `).join('')} &lt;/table&gt; `; are much better than simply const tmpl = addrs =&gt; "&lt;table&gt;"+ addrs.map(addr =&gt; "&lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt;"+ "&lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt;" ).join('')+ "&lt;/table&gt;"; (yes I know the second one has less spaces)
[but…](http://i.imgur.com/73SL1o7.jpg)
That's just becoming a form of validation. So it may as well just be treated and expanded as necessary as validation. Instead of the default arg method, just validate if the arg is provided by validating if it's the right kind of value (ie. It's not undefined because it is a number greater than 0, or whatever). Now you've got even stronger code for the same amount of work.
because syntax highlighting matters. and /u/rikAtee: why did you pretend gists couldn’t contain multiple files?
well, you can also just swap A(ngular) with R(eact) to get MERN. :) edit: [of couse that's a thing...](http://mern.io/)
Fun fact: some people do not know all the things you know. But now I know, thanks friendo.
https://www.youtube.com/watch?v=wKjxFJfcrcA This discussion revolves around a comparison between prototypal inheritance (what JS uses) and classical inheritance (what some other languages use). The parent of my post asked how classically (i.e. not JavaScript) multiple inheritance is done, so that's what I provided an example of. If we were talking about the differences between gibberish in English and Russian and I asked about what gibberish in Russian would look like, I would fully accept and expect a reply that included Russian gibberish. JS doesn't support multiple inheritance so an example for such a thing does not exist.
I don't see the advantage to doing this client-side. You say you've reduced the number of API's you've built but the downside is you've increased the number API calls you have to make. Also normally you wouldn't send back linked records, just a list of objects that represents the data in a nicer format. If your having a problems that require you to do in-memory joins then its normally a case of having to restructure your data. If thats not possible then the solution is normally to move to a DB that supports joins like RethinkDB or a Relational DB. In-memory joins are generally a bad idea. The major problem with them is that they don't scale. What happens if your tables have a million rows in each? Doing a join on that in-memory isn't going to work. 
Almost all UI work in the AAA games industry is done using Scaleform, which is based on Flash and ActionScript 2 or 3. Since these technologies are going out of fashion, I'm keeping my eye out for webdevs, because JavaScript and ActionScript are both based on ECMAScript.
The [no-bitwise](http://eslint.org/docs/rules/no-bitwise) rule is not part of [airbnbs styleguide](https://github.com/airbnb/javascript). I added it to my own eslintrc file, thank you.
IMO it's nifty because it shows you that you can have function calls in there (at least I never though of trying that), but otherwise it's better to just raise the error from the function itself.
TIL
(I changed my comment to clarify the term: The article you linked to was talking specifically about this type of method chaining without actually using that phrase, but other sources on the Web use the phrase.)
Definitely, I will work on that this week, thank you for the feedback!
Oh, I see now what you mean, great links, thanks! I must have been under "Elliott drug" indeed, maybe he should have at least pointed out he considered his "composition" in some other sense. No idea why he is doing that.... I can understand why it confuses people familiar with it. For my more mathematical background, I have to say Elliott's "composition by merging" would be more natural, because in mathematics a composition of functions is uniquely determined by the functions. The way it is defined here is more a way of calling other objects' method inside another's methods. So it is not uniquely determined by the two objects but also depends on the way you call the other methods. Regardless, if that is the established definition, I am not going to argue... So how then do you call merging methods from two prototypes onto another? Following that nice example from one of your links, if I have `Leg` objects with `hasLeg` method and `Sit` objects with `hasSit` method, I can simply merge them onto new prototype `Chair` and get objects right away having both methods: var chair = Object.create( Object.assign({}, Leg, Sit) ) This is what Elliott seems to propose and I find it very simple 1-liner. If instead you were to implement it "classically" as composition, the way I see, you would first need to create objects of both classes `Leg` and `Sit`, then you would have to import them into the constructor of the new composed object. Plus, you have to write the code for the latter doing all the work -- importing new objects as arguments, saving them as local properties, then writing all methods again, only to call the correct methods from the imported objects. It may be just me, but I find the latter way much more complicated, longer and full of ceremonies. I would say, this nicely demonstrates an advantage of the prototypal inheritance for that particular purpose. It is not to say the other method in inferior for all possible purposes. It really depends on your purpose. And I am only giving an example of one specific purpose. BTW, I have found quite remarkable the amount of "fairy tale magic" in connection with multiple inheritance: &gt; In object-oriented programming, Inheritance is the evil forest. Experienced programmers know to avoid this evil because they know that deep inside the Dark Forest Inheritance is the Evil Queen Multiple Inheritance &gt;Most of the uses of inheritance can be simplified or replaced with composition, and multiple inheritance should be avoided at all costs. &gt;Avoid multiple inheritance at all costs, as it's too complex to be reliable. If you're stuck with it, then be prepared to know the class hierarchy and spend time finding where everything is coming from. &gt;To do this Python uses "method resolution order" (MRO) and an algorithm called C3 to get it straight. Because the MRO is complex and a well-defined algorithm is used, Python can't leave it to you to get the MRO right. I have to ask -- what 's the hell is going on here? Are we still talking about making methods from several objects available on another? Does it really have to be worshipped like that?
&gt; Here is a link that explains higher order functions My fault, thought you want to explain the whole FP concept on one page :D &gt; Do you think it deserves a whole new post I'd move it to a new post to keep this article a bit shorter. As you explain `reduce` in your article, the new post could be about the _advanced usage_ of it. &gt; Post on currying I see you mention partial application in the context of currying. Some people are confused by the difference so you should spent some effort to get into the differences between them.
Well you can't save files from within the browser via script without user interaction for security reasons. If you have a server anyways just send the data to the server and let the server save it as a file - and for gods sake don't save data as JavaScript files. Either do JSON files or store it directly in a database. (PHP has the functions json_encode and json_decode, which convert array/object data into a json string and back)
5 weeks vacation = 25 days? I got 30 days vacation here in Germany, depends on the company though of course. Minimum vacation per law in Germany is 24 days.
Way too large a question to be answered here. It's multi part, and each part would need much more information to be able to help you (which is why you're getting downvoted). If your purpose is not learning, but just actually having the gallery, there is half a million WordPress plugins reproducing isotope functionality, ready to be just downloaded, some of which actually implement isotope itself. Just look for galleries plugins (check screenshots, sometimes they'll have multiple options for display). Some themes come ready with this too. If your purpose is learning, then you need to tackle much simpler things before that. Understand how WordPress templates work, how JavaScript work, how to load js in your template and couple it with your markup. Then, ask a more precise question about what exactly you're not understanding.
There is probably (I need to check the documentation) an out of the box variable you can send with the pageview event that will allow you to categorize pages or content.
I would suggest looking into **[Johhny Five](http://johnny-five.io/)**. You can run your Arduino with java script but you'll need to compile it on a computer. 
good tip, I will update my gist :)
hhmm,, I can see {{Page Path}} as a pre-defined variable in GTM but not exactly content.
Huh, I must have missed that last paragraph. My bad. 
Because there is zero chance you would use the back tick as quote around an HTML attribute. So no escaping required.
The content of the video is not important to the discussion. Here is the transcript: &gt; Mr. Madison, what you've just said is one of the most insanely idiotic things I have ever heard. At no point in your rambling, incoherent response were you even close to anything that could be considered a rational thought. Everyone in this room is now dumber for having listened to it. I award you no points, and may God have mercy on your soul. &gt; Ok, a simple wrong would have done just fine. Also, I have to admit, I am not, and likely will continue to not be, 100% respectful to other participants because I'm not going to annotate all of my responses here for all content not explicitly JS, especially in a context where comparisons are being made between something JS and something not JS where such relationships could be implied. Certainly people without a full understanding of the context could get lost. That's bound to happen. Being a part of a discussion, clarification can certainly be asked for. Just as you have a slow connection unable to fully consume my prior response, my ability to articulate responses can be hindered at times by being on a mobile device or restricted by time. I could I have done better, sure. But I'm not perfect, just like (as we've already established) I'm also not very respectful. It's a hard thing to live with, but I work on it every day. You still seem to have a solid interest in the topic (or ragging on me...) which is good, so lets dig into it. Now that I've gotten on my laptop, I'll be able to provide what will hopefully be enough information to satisfy your interests. Though... I may have to move. I'm in a beanbag chair (more specifically, its a Lovesac if we're trying to not leave anything to interpretation here) and typing a lot in this partially reclined position isn't the easiest thing to do. OK, all better. Now the big question: how much detail is needed? You never know. Obviously I misstepped earlier, so how much deeper do I go? I'll just have to make a judgement call and try to minimize the amount of disrespect I send out to the world. So the discussion of this particular thread revolves around classical inheritance vs prototypal. Classical inheritance uses classes as a compile time construct that determines how objects created at runtime are defined and behave. You see this in languages like C++. Prototypal inheritance, on the other hand, is a way for objects to be defined based on pre-existing objects created at runtime. This is what JavaScript uses. When it comes to multiple inheritance, C++ is able to support it with the following syntax: // C++ &lt;-- see what I did there? Already improving! class A {}; class B {}; class C : public A, public B {}; Now, whats important to understand here is that class C here is inheriting from both classes A and B and that each classes A and B would potentially have (though don't explicitly in this example) their own chains of inheritance wherein each could be inheriting from any number of any other classes which in turn could be inheriting from more. You would have this tree structure parent classes. grandparent grandparent grandparent grandparent \ / \ / \ / \ / \ / \ / parent (A) parent (B) \ / \ / \____ ____/ class (C) JavaScript's prototypal inheritance does not support this. The way inheritance works with JavaScript is that each object references a prototype object that represents an object it will look to for definitions it doesn't have when member access fails to find a value in the original object directly. That prototype object would also have a prototype which could also use when a lookup fails, and so on, until no more prototype objects exist. This represents the inheritance chain in JavaScript. Unlike C++, it's linear. Any one object can only look to one other object for inherited definitions. grandparent (parent's prototype) | parent (instance's prototype) | instance Due to this nature, multiple inheritance is not possible in JavaScript - at least not without some hackery. Its true, any one object can inherit from _multiple objects_, but only from the same chain. That is not what is meant by multiple inheritance. It means what we see in the C++ tree: having a single class inherit from multiple, independently inheriting classes. JavaScript has no builtin process by which it can check multiple objects at a single level of inheritance for different definitions. &gt; As JS perfectly supports ways of passing methods from multiple objects to another Not sure what you mean with this. Could this be the linear prototype chain above? If so then the above description explains how that is inheriting from multiple objects but not being multiple inheritance. ...Or is this more like reassignment through something like `Object.assign()`? That's also possible, but in doing this, what you're doing is copying definitions over at the instance level and not really doing any inheriting. This is more like traits or mixins. In this case you're giving up any inheritance in favor of a copy. This can be a type of single-level inheritance, but you're also not getting the tree of multiple inheritance. You lose the inheritance of the copies. One more thing to address before wrapping this up: "classes". This word, what does it mean? Why does JavaScript [now] have a `class` keyword but does not support "classical" inheritance? You can find a lot of discussion and opinions around this so I'll try to be objective. First, to drill it in, yes, JavaScript does, in fact, _not_ support what is known as "classical" inheritance - the kind of inheritance you see in C++ with "classes". JavaScript has prototypal inheritance (which, in itself, is kind of a misnomer since it uses delegation instead of true prototypal concatenation) which deals with objects. Both approaches determine how objects are created and how they behave at runtime. The idea of "classes" in JavaScript depends on how strictly you define the term "class". What JavaScript allows you to do that is similar to C++ is to create definitions in source code with the specific purpose of defining how objects created at runtime are defined. In JavaScript this entails creating a constructor function with instance member definitions in the constructor body and shared, inherited members in `constructor.prototype`. Instances are created with `new constructor` which even has a similar syntax to languages such as C++. ES6 added the `class` syntax which more concisely allows you to set up these definitions and handles any of the necessary superclass setup in the background. function SuperFoo () {} function Foo () { SuperFoo.call(this); this.bar = "bar"; } Foo.prototype = Object.create(SuperFoo.prototype, { constructor: { value: Foo } }); Foo.prototype.getBar = function () { return this.bar; } vs. class SuperFoo {} class Foo extends SuperFoo { constructor () { super(); this.bar = "bar"; } getBar () { return this.bar; } } _(not including some of the other things the `class` syntax also does)_ Are these definitions "classes"? Is the `class` keyword inappropriate for JavaScript because it's not using "classical inheritance"? You can determine that on your own. But if you're using prototypes in JavaScript and creating instances with `new`, this new `class` syntax is certainly cleaner and a lot easier to work with whether or not you agree with the name. Of course you could always argue that it looks too much like C++ and could imply C++-like behavior, such as supporting multiple inheritance... which is how this all started, more or less (is that even JS? looks like JS... right?).
_Insert "Nicolas Cage - You Don't Say" meme here_
I'll read into the JSON stuff. I have the form saving the data by posting the to a php page which I'm sure once I figure out the commands and details I can save to a different file type. The issue I'm having is pulling the back into the page after the page is done loading. So a blank form page loads and at the top is a drop down list of all the established users/customers. After selecting one of the users I'd like it to open the appropriate JS/JSON whatever page to pull in the array and then fill out the form - so that I can update the fields and re-save. If I save the data as a JSON file would i be running into the same issue I am now? Because when I search for suggestions to my problem the top results are "Dynamic loading of JS" and those articles / posts tell me to use the script I posted at the top where I add to the header a script.
But still... 7GB is insane, there is something wrong there! The biggest amount of memory that I have ever got was 2.5GB, that when I had thousand of tabs open ([Which is definitely something that is not recommended](http://blog.trello.com/too-many-browser-tabs/)).
I have around 20 tabs open, I guess it's because I'm on OSX and have 16GB of memory, might be pre-allocated and not really used.
I don't find the UX bad, but when pulling tabs off to another screen craps out...
Thank you for the long explanation, really appreciate! It does not need to be a long story taking much of your time, but few hints geared toward making your context more clear to JS programmers can go a long way, as you note yourself. As you point correctly, things in JS are "messed up" comparing to other languages, which, unfortunately, makes it easy to confuse others without being very clear about the context. I can see where you are heading with "true multiple inheritance" supporting any deep tree structure. Perhaps I shouldn't have used `Object.assign` that only copies own properties instead of all needed in this case. Also it sort of squashes all properties onto the new prototype rather than keeping both tree structures (you can keep one). So maybe it was confusing to call it "multiple inheritance" after all, instead of the mere task to combine methods from several objects onto one. For that particular task, I find the use of prototypal inheritance shorter and easier. Regarding the true multiple inheritance joining methods from both trees ... again, you need to project everything to JS, where many paradigms get deformed. For instance, there is no compile step. It makes a huge difference, because the whole tree structure for compiled languages only needs to be static, whereas to be suitable for JS, you need the dynamic run-time equivalent. Which means modifying methods at each tree level. This should be much harder to implement dynamically. On the hand, if all your classes are formed and fixed at the compile time (in non-JS case), all methods are also fixed and completely determine the class. Which means, when using the class at run-time, the actual tree structures above it will never make any difference, as long as the methods are the same. In fact, it would have exactly same effect as when all methods were simply copied over the class! Which is precisely what you can do with your JS prototype! Plus, at least one of the chains remains live! Which you would never have in any compiled language simply because at run-time your classes are engraved in stone! So by using classes and imitating the classical inheritance, you are giving away the important dynamic feature of JS. And the only reason I see the classes (or rather their imitation via syntactic sugar) were introduced was to make it easier for programmers coming from other languages to use the style they are more comfortable with. Which is perfectly ok if that will make them more productive and the process less painful. However, as these are not true classes, being e.g. dynamically mutable and not offering proper privacy, using them in JS can only be considered as compromise that comes at a cost. It is always worth keeping an eye on other ways achieving similar results that may have their advantages. 
Thanks! Hope it was helpful :)
Clyp can get you some audio: https://clyp.it/
I'd opt for both as it could be a resource for people transitioning to es6 as well
Don't bother cloning the repo, there's no working demo here. Just grab the lib from the dist folder and follow the ReadMe instructions. 
Avoid MongoDB, it is an inferior db that will just wind up frustrating you and trigger large refactors.
Hi /u/rajayogan27, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `tphangout.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [tphangout.com](/search?q=%28and+site%3A%27tphangout.com%27+author%3A%27rajayogan27%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|23|100%
Try checking out Mixcloud (https://www.mixcloud.com/developers), Audiomack (http://www.audiomack.com/contact-us/api) and Genius (https://docs.genius.com/). +1 on Bandsintown as well.
and the [Conjoined Triangles of Success](https://pbs.twimg.com/media/ChbhW-gVEAAna86.jpg)
I recommend starting at your local liquor barn because you'll spend a lot of time there mid-career as well as the end of your career.
Yes, I already checked Deezer's API, seems cool. The fact I can't play more than 30 secs doesn't really bother me. As long as I can play small song clips it's already great :)
Last.fm?
&gt; So how then do you call merging methods from two prototypes onto another? Following that nice example from one of your links, if I have Leg objects with hasLeg method and Sit objects with hasSit method, I can simply merge them onto new prototype Chair and get objects right away having both methods: &gt; var chair = Object.create( Object.assign({}, Leg, Sit) ) &gt; This is what Elliott seems to propose and I find it very simple 1-liner. That's inheritance. It may not *look* like it because we're not using the language's built-in inheritance mechanisms. Instead, we're hand-rolling our own inheritance. And the reason we're hand-rolling our own inheritance is because we (in this case) want multiple inheritance, but JavaScript's prototype chain supports only single inheritance. &gt; If instead you were to implement it "classically" as composition, the way I see, you would first need to create objects of both classes Leg and Sit, then you would have to import them into the constructor of the new composed object. Plus, you have to write the code for the latter doing all the work -- importing new objects as arguments, saving them as local properties, then writing all methods again, only to call the correct methods from the imported objects. It may be just me, but I find the latter way much more complicated, longer and full of ceremonies. Yes, it is longer, but it's safer, more flexible, and less brittle. * Your chair may not want, nor should have, the entire interface of Leg or Seat or all the individual pieces. Imagine if Leg has a method `screwInPlace()`, which makes sense and is applicable to a Leg, but if Chair inherits from Leg, then now the chair itself has a method `screwInPlace()`, which doesn't make sense in the context of a whole chair. That's why inheritance is supposed to satisfy IS-A and WORKS-LIKE-A relationships. A chair IS-A leg? Nope, so you should avoid inheritance here and use composition (that is, avoid merging objects together, and instead have objects hold references to other objects). You're concerned about writing all the same methods again just to forward the calls to the imported objects, but that will happen a lot less than you think, because much of the interface of Leg or Seat isn't even applicable to the Chair as a whole and *shouldn't* be re-implemented in Chair's interface. * Inheritance lets you have only one copy. A chair is supposed to have four legs, right? But... Object.assign({}, Leg, Leg, Leg, Leg, Seat) ...this won't work. You still have only one leg. Each just overwrote the previous. &gt; I have to ask -- what 's the hell is going on here? Are we still talking about making methods from several objects available on another? Does it really have to be worshipped like that? The issue is that when you inherit (merge) multiple objects together, then you run the risk of collisions. For example, what if *both* Leg and Seat have a method `screwInPlace()`?
I've used Spotify, Soundcloud, LastFM, and used a web scraper and Node server to get music off HypeMachine. They're all going to have benefits/drawbacks. SoundCloud is the most straightforward, what kind of info are you looking for that you weren't able to get from their API?
I mostly want artists info, like, albums list, albums covers, song lists for the albums, some info about the band/artist. mainly my objetive is to get the most info I can to populate my pages with stuff.
Cool. If you don't mind the smaller clips of music for non-subscribers, spotify should be able to get you plenty of info. You said you couldn't get it to work. What errors were you getting? Any code examples you can share? 
I'll get back on that once I'm back home and I'll share my errors, but I can tell you simply that I want to create a simple project for university so I don't want to integrate a login service, I want to use my account credentials to make the requests to the API and I wasn't able to properly set it up... I did see how I could setup the login menu to afterwards use the API but I don't want that menu, I simply want to use my key, secret key, get my token and then get the info and I don't think it's a simple process and after fighting with this I wasn' successfull setting it up :)
literally why
&gt; ...we started with 20,000 lines of CoffeeScript code. When translated that resulted in approximately 50,000 lines of ES6 code. Nice.
I question the use of getter methods as a replacement for instance properties. I also question the motivation for doing this in the first place. I understand that CoffeeScript is falling out of favor, but the semantic differences between CS and ES6 are not so great that they couldn't coexist in the same project, albeit it would require a fine-tuned webpack config. I think a gradual transition as code is updated would be more appropriate and would likely not result in a 2.5x increase in line count.
It's because you're calling the Instafeed function in the head, but the instafeed.js file hasn't loaded yet because it's been called in the body (roughly something like that). Quick fix just to get you going: put the var feed bit in script tags just before the &lt;/body&gt; tag, after the instafeed include. Or put it in it's own .js file and include that under the js/instafeed include. Or put the instafeed include above the function call in the head!
Hey there guys, I just added support for pipes and background processes. You can check the latest commits if curious. Will add installation process later today so anyone who wants to can test it out. Regards.
Besides pure speed (which limits things like physics and AI), there isn't an easy way to access DirectX or OpenGL 3+ (or Metal or Vulkan) from JS. So you're locked out of using a lot of GPU features without writing at least part of your app in another language.
Oh yea. I activated Apache and PHP on my MacBook and all of this is running within the localhost
Consider using [MarkLogic](http://www.marklogic.com/) instead. It's also a document-store database, but adds a lot of useful capabilities ([ACID](http://www.marklogic.com/what-is-marklogic/features/acid-transactions/), [search](http://www.marklogic.com/what-is-marklogic/features/search-query/), [security](http://www.marklogic.com/what-is-marklogic/features/certified-security/), [semantics](http://www.marklogic.com/what-is-marklogic/features/semantics/), [HA/DR](http://www.marklogic.com/what-is-marklogic/features/high-availability-disaster-recovery/), etc.). Still allows JavaScript in all tiers. Stores data as XML or JSON. Disclaimer: I work for them
There are several DOM attributes and methods that you can use to navigate the DOM. Instead of looping over all the pointers, use `this.children[0]` to get the element you want: https://jsfiddle.net/kne4chds/2/
Thank you! but just for future reference, is there any way to do it with classes? (like the one in my code)
In this case the zero in the `p[0]` refers to the first element returned by `getElementsByClassName` so it would always be the first pointer div found within that clicked element. Here's a fork of your JSFiddle with my snippet inserted: https://jsfiddle.net/x7zo8otj/
It needs to be connected. No part of an offline application can be considered secure
Ms, Apple and Google would need to work together by drafting common universal api for their platforms. Right now, we don't even have browser features synced between edge/blink/webkit, I doubt this will happen.
Why?
What is the point of the first for loop? After that loop, the variable y still exists, although for best practices it should be assumed gone once the first loop ends. Regardless, by the time of the second loop, y has whatever value it exited the first loop with, and this does not change throughout all of the second loop. Also, x is declared (over and over within the first loop), but is never once used. None of this will fix the real problem: you never *call* rankInterger. Add, to the very end of your javascript, on a line after your last }, the following: rankInterger(); Also, integer only has one r, so the english in your code is wrong too. Once you add that line your logic will at least do something and you can figure out the rest.
Not on par with cutting-edge technologies, but it surprises people sometimes. I believe Quake Live used it with WebGL to create a 3D, FPS played via the browser. Here's a demo someone else made: http://media.tojicode.com/q3bsp/
Neat! Your introductory paragraph was the only thing that kept me from sharing this. I don't want to come off as "that guy", but cleaning up the grammar will make this seem a lot more legit/professional. I've added my simple recommendation below the quote. &gt; There is a plethora of JavaScript libraries for use on the web and in node.js apps out there. This greatly simplifies, but we need to stay update on security fixes. "Using Components with Known Vulnerabilities" is now a part of the OWASP Top 10 and insecure can libraries can pose a huge risk for your webapp. The goal of Retire.js is to help you detect use of version with known vulnerabilities. There is a plethora of JavaScript libraries and node.js apps on the web. This greatly simplifies the issue, but we need to stay up-to-date on security fixes. "Using Components with Known Vulnerabilities" is now a part of the OWASP Top 10, and insecure libraries pose a huge risk to your webapp(s). The goal of Retire.js is to help you detect vulnerabilities while utilizing different versions of well-known libraries. 
How about http://musicbrainz.org ?
Yes, please scrap Parse from your list.
I wish there was a free trial to play with it..
Thank you for your response. I uploaded the site to my webspace to show it to you: http://caracals.de/katzenjammer It would work now, but I have some issues with the instagram API. New error: Uncaught Error: Error from Instagram: The access_token provided is invalid. Any ideas? 
Agreed. Just use [RethinkDB](https://rethinkdb.com/) if you still want a NoSQL that is much [better](https://www.rethinkdb.com/docs/rethinkdb-vs-mongodb/) than Mongo and has an awesome, functional query language.
&gt; I also question the motivation for doing this ... Technical debt is a very real concern, though the move to straight JavaScript seems an odd one to me.
Hi /u/hihumm. "Hilarious" is the fact that you're commenting on a post that was never made public, using an account that is 8 years old and yet this is the first comment ever. Nice sock-puppet.
Hi /u/froyo_code_yo, if you want to advertise a paid product or service, please visit https://reddit.com/advertising. Thanks.
You might find this tutorial helpful: https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes. Or the one from w3c is pretty good: http://www.w3schools.com/html/html5_canvas.asp. Good luck!
I find fake timer causes nothing but problems. I can't remember the exact details, but I tried to setup a fake timer once to stub out `new Date` -- well, mocha suddenly refused to run the test, looking like a hung test, didn't call cb or something. I ended up just creating a date service, injecting that into the piece of code and stubbing that out to return the proper date. 
For bitmap images, see: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
Thanks. Got it :)
&gt; https://stormpath.com/pricing I swear I am blind..lol Thank you!
Yup, that's the point! I'l love to see for example Rust become a popular choice for writing high-perf things that will need to run in browsers.
&gt; I question the use of getter methods as a replacement for instance properties. Yes, maybe I'm missing something but can't they just define these in the constructor? `this.tagName = 'li';` If they're not instances then perhaps those could be separate, as constants.
Only thing I'd change is &gt; There *are* a plethora As we're dealing with plurality. 
See http://benmccormick.org/2015/04/07/es6-classes-and-backbone-js/ and http://benmccormick.org/2015/07/06/backbone-and-es6-classes-revisited/ for various possible approaches.
One of the most powerful features of JavaScript is that you can overwrite almost any property. One of the worst features of JavaScript is that you can overwrite almost any property.
How do you like it? I remember I interviewed for them about 5 years ago and it seemed like it could've been an ok place to work. 
if it's offline hows it supposed to check with auth0 if the session is valid? it needs to go out to the internet and call to auth0 validate the authentication. 
Firebase is your best bet. Parse is on its way out, literally being turned off in less than a year. That's what I meant by scrap it from your list.
You mean Snap? http://snap.berkeley.edu/
Yes, but I couldn't find its source code.
The link to Snap source code is [well-hidden](http://i.imgur.com/GeaDd1P.png).
Thanks!
It wasn't brainwashing: Fluent APIs really are amazing.
can you paste the actual link?
I can't find out the download URL. When I click on the download link, a new window is opened and I can't see the download URL in the development console.
I found out that apart from Water Bear there is [Blockly](https://developers.google.com/blockly/), which looks nice and has a suitable (Apache-style) license. Is Water Bear better than Blockly? If yes, in what respect?
i don't even see the page you showed
You can see it by clicking on the "Snap" logo. And there is no webpage dedicated to the source, it's just a download link to a ZIP, which is: http://snap.berkeley.edu/snapsource/snap.zip
1. Go to http://snap.berkeley.edu/snapsource/snap.html . 1. Click on the logo in the top-left corner of the page as shown [here](http://i.imgur.com/unOotyc.gifv).
Thanks a lot. The condition isn't always going to be me.charlvl though, so I guess the first option is going to be the better way of doing it. As far as javascript goes is that a good way to write the kind of thing? I'm going to have a lot of those id/condition objects with a heap of different conditions. I used to have the condition at the start of the function so it just ran the function every time and returned true straight away if the condition was met. Thought I'd try and do it differently though.
Please use a working example because channel "blah", etc. is not found.
Looks good, has anyone tried this?
The Chrome Midi API is a lot fun: `navigator.requestMIDIAccess({sysex: false}).then(onMIDISuccess, onMIDIFailure);`
Yo dawg.. I heard you like libraries, so i created one to tell you that your libraries.. Oh wait.
`typeof a === 'undefined'` was a best practice back when browsers allowed the value of `undefined` to be changed, so, theoretically, some other code could possibly contain something like `undefined = true`. Personally I always thought that pattern was silly. Code like `undefined = true` is clearly either malicious or buggy. If you're running malicious code in your context then you're screwed no matter what you do, and if it's a bug then you need to fix it at the source, not repeatedly every place it affects. I never used this pattern and never had a bug arise from it. Anyway, the value of `undefined` can no longer be changed as of ES5, which has been implemented in every browser for ages, so the `typeof` pattern is a thing of the past. `a === undefined` is sufficient.
Why not. Tax incentives a plenty for companies to hire juniors from abroad. If you're good, you'll have no troubles finding employment.
Hired and Honeypot are similar in that both companies want to improve the whole hiring experience. However, Hired is focused on sales and marketing positions also. We are purely focused on tech positions. And like you said, we are focused on Europe.
i cant run simple alert.. btw, can you put an option for auto run? too lazy to press run each time i make modification to my js code.still, good tool
 var Normal = { "steps": [ // Act 1 // Complete den quest { id: 'den', conditions: [me.isLvl(2)] }, //Helper.checkQuest(1, 0) || Helper.checkQuest(1, 1) // Reach level 7 { id: 'cave', conditions: [me.isLvl(7),me.isHealth(90)] } ], "run": () =&gt; { for(let i = 0; i &lt; Normal.steps.length; i += 1){ let step = Normal.steps[i] // if all conditions are met, then continue to the next step if(step.conditions.every(condition =&gt; condition() === true)) continue; // if a false condition was found, then we'll start the step me.overhead('Starting ' + step.id); // starting the step Normal[step.id]() // this will look for any false conditions since the step started and finished // if there is a single false, then break the run if(!step.conditions.every(condition =&gt; condition() === true)) break; } return true } } With the above, your steps can have one or multiple conditions that must all be passed. Have your conditions something like so: me.isLvl = function(lvl){ return function(){ return me.charlvl === lvl; } } me.isHealth = function(health){ return function(){ return me.charhealth &gt;= health; } } To restart the step (if the conditions were not met after the started step finished...) do this instead of breaking: // this will look for any false conditions since the step ran // if there is a single false, then restart the run if(!step.conditions.every(condition =&gt; condition() === true)) i--; 
&gt; This is basically JShint for known bad practices when it comes to security. Am I getting this right?
Sounds like you built your dev/debug environment to your production server, the whole stack is there ;-) Maybe an ENV setting is missing somewhere ?
I do. However, the `.meteor/local/build/web.browser` folder is [importing about 120 back-end Meteor JS files](http://i.imgur.com/44YFW26.png) so I feel like the issue may be something other than a simple `env` thing - this should also not be happening in development... EDIT: Nope, changing to `production` didn't fix it sadly. EDIT 2: All of these files seem to be referenced in `.meteor/local/build/programs/web.browser/program.json`. Any clue on what generates this json file?
thanks.
From just reading the announcement I wouldn't expect too much change for these tests as the reactivity stuff looks to be staying the same. I guess it's down to whether the new VDOM approach vs the current DOM approach. 
I remember seeing performance tests built around TodoMVC and was kind of shocked by how badly React performed compared to solutions like Mithril and Vue. As always it's probably important to always take these with [a large grain of salt](http://vuejs.org/perf/) but it's interesting, I guess. I wonder how this particular benchmark will change with Vue 2.0. Seems like maybe the time spent rendering/painting might be reduced a bit?
I think it would only be reduced if it turns out the VDOM is better at applying operations to the DOM than what Vue does currently, which may well be the case. 
Pretty much. I only expect some changes to the painting times.
not quite what OP is looking for :D
Not if there are fundamental mistakes that cannot be changed once the thing is live.
vue 2 will be slower by *a small margin*. The reasoning being that Vue 1's reactivity causes fast hot updates but cost high (relatively speaking) initial render time. while react's virtual dom causes fast initial render but slow updates. Vue 2 uses a combination of virtual dom and reactivity to lower initial render time which *will* slow down hot updates(by a small margin). Its a trade-off which vue.js finds optimal.
I'm about to look at those myself. What made you go for [sequelize](https://www.npmjs.com/package/sequelize) instead of [bookshelf](https://www.npmjs.com/package/bookshelf)? 
Apologies for thinking it's a problem: it's not. I get 7.0Mb in my browser when visiting the page, first visit is always slow, it's Meteor, it's supposed to build a javascript application that is then downloaded by the client browser when the user accesses the site. Also check your PM's
`Cmd+Enter` is the keyboard shortcut for Run. `alert` won't work because all code runs within a webworker, I could send calls to `alert` through to the main window, though it'd execute asynchronously so it wouldn't work as expected.
No worries. It's a common source of confusion in JS. As simply as I can think to put it, `this` refers to the object that calls a function, from within that function. It gets confusing because `this` changes when the function context changes. But it's handy because you get access to all of that object's methods and properties from within your called function. So with your example code, when you loop through your DOM elements to add your event listener and then call `clickHighlight`, `this` refers to the specific DOM element that was clicked.
I think the is more checking for references or uses of packages/libraries that have know vulnerabilities than a code analyzer.
Ah, right off course. Well, to me that is the description any library needs. Your explanation is clear and consise which a great deal of projects on GitHub really seem to lack.
I _(kind of)_ explained my hatred towards Atom in this post [1] where I was also asking people why would they use it as their primary or secondary code editor considering its performance issues. And more specifically in one of my comments here [2]. [1] https://www.reddit.com/r/Atom/comments/4kj4kb/a/ [2] https://www.reddit.com/r/Atom/comments/4kj4kb/a/d3gck2u
Interesting how much time is spent on rendering/painting vs JS code, but it is ultimately faster. Has Blink gotten fast enough to negate the benefits of a virtual DOM?
No I meant all the different `isFooBar` methods
Nicely explained, thanks! I think I've found a recording (https://www.youtube.com/watch?v=SrZnd6MEHV0) of that meet up. 
Among virtual dom implementors, it's actually been fairly well known that React isn't the fastest of the bunch. I was actually surprised that I was getting a large performance regression in v15 compared to v0.14 when I was updating its dbmonster benchmark a few weeks ago. Vue 2 is based on Snabbdom, and does quite well on dbmon (~36fps on my box, compared to ~10fps for React v15, and ~42fps for Mithril v1 alpha), so I'm not too surprised by the results in this post. 
Yeah, send me your email in a PM.
Hello! Hmm... JavaScript is not the same as Java. And to create an anchor tag/hyperlink/link you really only need HTML. Here's an example: http://codepen.io/anon/pen/ONKYyW More on the &lt;a&gt; element/tag: http://www.w3schools.com/tags/tag_a.asp
http://i.stack.imgur.com/TsJyw.jpg
Wow, clearly I am over my head! Thanks for letting me know!
Yes, I was talking about that video.
 =while(true){alert('hi')};
I think it's more down to Vue being clever with it's DOM updates just like a VDOM is but don't hold me to that. It's to see the painting/rendering taking more time than scripting!
``` switch (format) { case "text": return textStatement(); } ```
For Microsoft stack I use .NET web api with entity framework. Angular $http or jquery $ajax on the front end for accessing api calls. You will need to learn about basic authentication, authorization, http requests (get, put, post, delete), http headers, http responses, JSON content type, etc if you do not already.
Is there any way to use Vue with jsx/tsx files?
how did they count? i imaginge counting `}`-only-lines would easily lead to that number.
As can be seen, react spends much less time rendering. I'm wondering if at this point you are simply seeing the difference between using a mutable data structure and an immutable one. If immutable.js was dropped from the react version (heresay, I know) and instead a mutable data structure was used - would the scripting CPU utilization drop quite a bit?
This is really cool - great job!
Were those TodoMVC perf tests all using optimal production settings for React? Was `shouldComponentUpdate` correctly tailored to ensure no unnecessary renders? I don't doubt that React is a bit heavier regardless, but you can certainly squeeze some more performance out of it. Anyhow, if you want to still take advantage of its ecosystem and you like React's *personality* but think it basically just needs to go on a diet, then you might try [Preact](https://preactjs.com/), which weighs in at 3kb.
Blasphemy! Sounds like something to keep on eye on then.
&gt; Vue 2 is based on Snabbdom, [...] so I'm not too surprised by the results in this post. This test was done with Vue 1.0.24, which uses browser DOM.
thank you
for every tile you need to know about its endings. then after every move to check of every tile in their current orientation has a neighbour opening on their ends.
Just add click and keyup event listeners to fire the display function, and change the alert to code that changes the textContent of the p element in which you want to display the position. http://codepen.io/anon/pen/PNMMaq?editors=1010
http://jsbin.com/xovatukewo/edit?html,js,console,output
Sorry, yeah, I should have included Vue 1 as well for better context. It does about 20fps on dbmonster on my box, which is still roughly twice as good as React v15.
Be sure to check out the PRs on the project that fix some of the slowness in the React version (use production mode in react, fix invalid HTML): https://github.com/footballradar/VueReactPerf/pulls The PR https://github.com/footballradar/VueReactPerf/pull/3 has some good screenshots.
Hmm, this seems to confuse me a little more than I was, no offense to you, just showing how new I am to JavaScript. Can I send you some screenshots of what the game already looks like so you can label it, in either ms paint or something of the like? But my first idea when I drafted the design (for the teacher to confirm) was to give each tile a value in an array, and after each move the code would check if the values in the current array matched the values in the "correct" array. Would this work? The thing with this plan is, I simply don't know where to start. How would I give each tile a value in an array, or is that even possible?
The TodoMVC tests were kinda all over the place, but IIRC the meat of the discussion was that the Mithril/Vue/friends implementations did a lot of perf-related heavy lifting out of the box. Depending on who you asked, batching was considered "cheating" because it was a somewhat new technique at the time that the benchmark never accounted for, and you had to implement it by hand in Backbone, React and some others. These days, dbmonster is the most standardized benchmark, imho. There are both naive and shouldComponentUpdate-optimized implementations for React, but the optimized one doesn't do all that much better unless you rewrite the benchmark's data generator to spit data with a React-friendly equality profile and start doing highly non-idiomatic shenanigans. And even then it doesn't do much better than Vue 1, unoptimized. [This](http://vdom-benchmark.github.io/vdom-benchmark/) is another benchmark that looks specifically at the diff algorithm in virtual dom libraries and you can see React doesn't do very well there either, compared to, say, Snabbdom (the closest thing to Vue 2 in that benchmark suite). The problem with shouldComponentUpdate, imho, is that to get reasonable performance, you need to actively make code sensitive to referential equality, which I think is a big code smell. The here-be-dragons looming danger is that when your data layer implementation changes for whatever reason, it can have a huge performance impact in the view. I had this problem happen to me in an Angular codebase, and it's not fun to suddenly find out that your view library is now doing something super expensive but that your tests have been passing just fine the whole time. Also, there's something to be said about the frequency at which shouldComponentUpdate comes up. In Mithril, for example, using `subtree: retain` (the equivalent of shouldComponentUpdate) is considered a last-resort, avoid-at-all-costs kind of thing. You don't see articles about Vue talking about that kind of optimizations either.
Thank you. I will take a look at 2.0 then.
Just want to point out that dbmon is a benchmark testing only a very narrow subset of possible use cases. vdom-benchmark is more comprehensive, but also only testing the lower level list-juggling manipulations. Real world use cases usually involve nested component hierarchies with complex data structures, which also plays an important role in perf considerations.
Thanks. If I do this, is it possible for the main app and the worker to both include the same module?
The combination of markup and JS is a very good thing when you're doing atomic design. It really benefits the component way of thinking. Additionally when moving the markup and the bindings (not sure if this applies exactly to Vue) to another file, I lose the compile time safety.
Yeah, they each get their own copy of that code.
Yes, it's just a SQL statement. 
I would just use jQuery toggle there is another example here http://stackoverflow.com/a/5252107/94598 Just use CSS to hide the fields by default then toggle to show them.
That's a great point. I actually linked to that benchmark in another comment below. The reason I like dbmon in particular though, is that it happens to be a fairly good indicator of overall performance because libraries that perform well on it tend to do so across the board, and libraries that don't also tend to do poorly across the board. 
Many projects will have contribution guidelines to help you get started, but in general, yes - make a detailed pull request with your contribution and the leaders of the project will look it over.
Adventures in Angular has a pretty good episode about [How to Be a Good Open Source Citizen](https://devchat.tv/adv-in-angular/086-aia-being-a-good-open-source-citizen) that does a really good job of explaining how to get involved the right way. There is not perfect agreement on the best way to go about contributing and it depends on the project. More projects are creating rules or guidelines on how they want contributions. If the project has those, you should try to follow those. If it doesn't, a pull request or an issue are probably the right way to go about it. Finding an issue that a lot of people seem to care about it and creating a pull request to resolve it is a great way to make a lot of friends, but that can be hard because those issues typically haven't been done already because they are hard to do. Sometimes though, it's just one line of code that people figured out they needed to change, but they never made a pull request for it. One thing that counts for a lot is just being respectful. If you are creating an issue, make sure it hasn't already been created or decided that it shouldn't be implemented. Even if you create an issue for something people think is really stupid, as long as you're respectful when you do it, people will generally be respectful back. Work hard. Be nice. Have fun! Open source is a good time! Welcome to the club!
&gt;Also, there's something to be said about the frequency at which shouldComponentUpdate comes up. In Mithril, for example, using subtree: retain (the equivalent of shouldComponentUpdate) is considered a last-resort, avoid-at-all-costs kind of thing. You don't see articles about Vue talking about that kind of optimizations either. This is a very good point. Thank you for the vdom benchmark+info (and for Mithril!) As an addendum, I stumbled across this: https://github.com/footballradar/VueReactPerf/pull/3 This article might see some revising yet.
Vue's ecosystem is also growing everyday: https://github.com/vuejs/awesome-vue Most important pieces you can find in the React ecosystem has a decent counterpart in the Vue world.
Here's the fiddle I mentioned: https://jsfiddle.net/u6mgwk4t/1/
is this can create problems? I tryied to remove the x and y var and put in the "if" directily e.clientX, and it works, but I don't understand why the first way doesn't work!
That was definitely a big oversight in the test, but the comment thread on that PR shows that the Vue test was also not representative - a mistake in the data stream meant that 10x the amount of work was being done - so the results are a bit inconclusive. We're going to change the tests based on all recommendations and update our findings. I wouldn't be surprised if the results are closer, but it's not guaranteed that React in prod-mode will be faster.
Agreed. WebSockets are perfect for sharing small pieces of information very quickly. They are fairly painless to implement and their uses are endless. I use them on the landing page of [my website](http://www.killiangrant.com). A visitor's mouse coordinates are sent to the server, and then all current visitors' coordinates are broadcast back out to everyone.
Cool thanks. This is exactly what I wanted. 
Thanks for sharing this!
The main thing to understand with if() statements is the difference between singular, double and triple equator statements - and from there, how JavaScript attempts to modify types and reach either a 'true' or 'false' result. JavaScript does a neat (and sometimes confusing/annoying thing) of allowing us to be 'less-strict' when coding. So for example, if I use the code... if (1 === '1') {} // this will always equate to false because a triple equator makes JavaScript compare not only the values, but also the types of values (e.g. a number is not a string)... However, if I use... if (1 == '1') {} // this will return true since JavaScript will automatically convert the types and find that 1 in fact equates to 1, even though it was originally comparing against a string... Read over the w3 schools comparing types here: http://www.w3schools.com/js/js_comparisons.asp. For your original question, it's hard to say where it went wrong, but given you're using a variable it could and more than likely has to do with how you are defining the xKey1 variable. Try running your game and simply put console.log(xKey1);, open your console, and look at the results - more than likely your xKey... variables are not behaving quite how you think it should be.
You might need to try and find a "beautyfier" to reformat the code. Chrome dev tools have one built in I think. Haven't used it. 
Sublime probably does not remember changes when you close the editor. It is considered best practice to use a version control system like git to track the changes in your code. With something like git, you could revert back to a previous working version. Anyhow, unless you have anything in a backup or something I can't think of a way to revert :(
i like the lodash implementation of `some` and `every` because `_.some(arr)` is equivalent to `arr.some(Boolean)`. it checks for truthy values by default.
I am using a beautyfier but as I am using Angular, it is giving me some issues, like for example `$timeout`, it returns a stupid thing like this: e(function(){n.noShows=!0},3e3)}
I've been there for six and a half years, which is a personal record for staying at one company. The things that matter to me most (people and technology) are things they do right. I've had the opportunity to move to a couple different roles and take on some different responsibilities. I expect to stay put for the foreseeable future. If you're thinking about applying, DM me and maybe I can help find a suitable role. 
Oh sorry, read very quickly
i know this doesn't help you with this current situation, but it's the same thing as losing any document to a kernel panic or power outage. commit more frequently! in addition to looking for beautifiers, maybe try googling "format minified js" and paste it into a bunch of different online versions to quickly see if you can find one that does what you want
Very thanks, I checked deeply and there is a method that use an x variable. I didn't know javascript could have this sorts of ""bugs"". They are variables from others methods..
I really like [Jasmine](http://jasmine.github.io/) for JS unit-testing. Python has a built-in unit testing framework, [unittest](https://docs.python.org/3/library/unittest.html). Both of these should fulfill all of your needs, especially if you don't really care about testing user interactions with the site. For that, you'd probably want something like [PhantomJS](http://phantomjs.org/).
I should clarify. I need a way to set up the initial connection between the devices. I.e. I need to exchange the user IDs between the devices. Afterwards, larger amounts of data will be exchanged using WebSockets. I looked into audio data transfer, but it looks like Safari doesn't support it.
With this in mind, why have Ive not even heard about Mithril and Vue? I read plenty of tech blogs but I still hear a lot more talk about react than the other 2. Not trying to say the other two aren't good, just want a serious answer because right now I'm learning react, so if there is something else worth learning more, I'd rather switch to it before I get too deep into react. 
Shift-clicking is kinda difficult, but I love the responsiveness. 
This is why you should use lodash/fp const getUser = _.map(_.property('user')) getUser(users)
It looks great. I currently use d3 for such charting. Though D3 is a little difficult to get handle on initially, I like the extreme flexibility it provides to visualize data. How does your tool compare to D3 in terms of flexibility and also performance. Also, are you using D3 as engine for zoomcharts?
After skimming the React code, it looks like there's a ton of unnecessary computation being done. For example, you're including the game time in with the rest of the game data. &gt; Considering all we’re doing is accessing a property in the Game Map then displaying it, there shouldn’t be much need to create a sub component for scores, teams and cards. Your test code *always* increments the time. Since time is always updated, you want to account for this in the design of your data structures and components. Anything you expect to be updated frequently should be factored out to avoid rerendering everything else. In your benchmark, the way you're using immutables looks like it would result in Game's shouldComponentUpdate() always being false. The Player component seems okay though. React has a very general API. It doesn't optimize lists for you. Immutables can help with this. In this case though, where you're always making an update, using immutable objects adds additional overhead. The takeaways need to be kept in context. I'd say the main learning here is that lists are a pain in react. When possible, use something like Facebook's FixedDataTable to handle large lists. You'll save a lot of frustration in trying to factor out hot render paths. In fact, it would be interesting to see this same benchmark executed against a FixedDataTable implementation with thousands of rows.
Maybe the user isn't allowed to select 0 guests 
neither did i, someone else came up with it. i'm dum
It's not great usability but I have had situations with these types of forms (as a user) where I select 0, click next, and now it's populated with 1. Again this is bad usability, don't let the user enter something invalid, and don't change the users input unexpectedly 
Incredible, that whole thread is a perfect example of why one should be skeptical of benchmarks!
Heh, lhorie wrote Mithril. :) As someone who didn't write Mithril, I will say it was the only front-end MVC framework that didn't make me want to roll my own.
This is fairly basic JavaScript stuff. Any tutorial that doesn't cover why `var` is important should be discarded. JavaScript's semi-new `strict mode` helps prevent that particular problem from happening.
it's not js, might just psuedo code, someone correct me if i'm wrong please
I'm not sure I understand what you mean. The run function (or the wrapper, if you do it that way) returns a promise, and you can just yield that. This is how [`Q.async`](https://github.com/kriskowal/q/wiki/API-Reference#qasyncgeneratorfunction) and bluebird's [`Promise.coroutine`](http://bluebirdjs.com/docs/api/promise.coroutine.html) work. Edit: OK, after looking at the second part of the blog post, I see better what you mean. This seems like really marginal utility to me, and like it would have to be wielded very carefully to prevent your code from becoming quite difficult to understand. So I would argue that async functions have made the right tradeoff, because they've covered 99% of cases while having simpler semantics.
&gt; The larger React ecosystem What, specifically, is easier to get done in React than Vue?
Not quite true, consider this: var genCreate = function*() { for (var i of [1,2]) yield i }; var runnable = makeRunnable(genCreate); function makeRunnable(genCreate) { var gen = genCreate(); var fn = function() { console.log('this would call run(genCreate)') }; ['next', 'throw', 'return'].forEach(method =&gt; fn[method] = gen[method].bind(gen)); fn[Symbol.iterator] = gen[Symbol.iterator]; return fn; } function * anotherGenerator () { for (var i of ['x', 'y']) yield i; yield * runnable; yield 'z'; }; for (var item of anotherGenerator()) console.log(item); runnable(); http://jsbin.com/jokocegevo/1/edit?js,console
Read "JavaScript: The Good Parts" by Douglas Crockford, it's a must for JS developers. Also, use JSLint to debug your code, it will point many other traps like this.
Hi /u/janisvolbergs, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Could be! I'm not sure. There are certainly arguments *against* sequelize as well. The library itself is fairly large / complex, but I suppose that's necessary to support multiple databases at the same time. I'm also not 100% sold on the fact that each Model knows how to make queries / calls to the database through internal properties. That feels very coupled to me, and I think I'd rather build a query / insert / whatever from the model, then pass the resulting definition to the sequelize connection myself. But, to each their own. I'm sure there are plenty of people out there that prefer it this way, and I can't deny that it works.
Vue is much leaner and easier to pick up IMHO. And the ecosystem is just fine; I have not found something that's React-only that I really need. That said I don't think Vue should or will replace React. Maybe Angular though...
Check out something like Mozilla's json form library? https://github.com/mozilla-services/react-jsonschema-form
all signs point to xKey1/2/3 not being greater than 700. If you were wondering, the syntax of your conditions look fine. Throw a `console.log` showing each of them before the conditionals and see what comes up. Another option is to include a `debugger` statement - this will stop the debugger at that point. I'm not sure if this function is really hot (i.e. you are inside a millisecond setInterval call or something) so a debugger may not appropriate.... `console.log` is still a good debugging tool though.
I haven't used it, so I couldn't say for sure, but it looks like v2 is based on async functions.
It is, but they can't release it until node supports it in the LTS branch, which could be a long time away. Not sure how that works either to be honest though. 
Really like how part 1 begins: complete realistic example with callback, then the same example as "promised" with reasons for nesting explained, then on to the `async/await` version! Really cool! Everything is clean, all details are there, no fluff, just perfect! ...Until the generator example... &gt; So we conjure a run(..) function that is smart enough. I won’t show the implementation of it here, but it’s listed in the first of those two links, and it’s only about 25 LoC even with comments — not too difficult, but not a detail to get tripped up on here. Uh oh ... smart enough ... won't show the implementation ... listed in the first link ... the dark mystery is creeping ;( And the first link ... is a whole book chapter with way down some huge hopelessly nested function called `run`. Is that the one? Is that the only one? Lost ;( ... And part 2 begins with `function *foo` ... not that there is anything wrong with `*foo`... But now I realise how much I miss the `function getOrderDetails`. I miss the use case. I miss the reason. 
You chained the promise wrong. You modeled the promise methods after the callback methods, but in promise-land you can chain promises so that the response of the function is a promise that resolves to the variable 'order' with 'customer' attached. The resolved promise is always whatever's returned in the last "then". return db.find( "orders", orderID ) .then(function(order){ return db.find( "customers", order.customerID ); }) .then(function(customer){ order.customer = customer; return order; }) .catch(function(err){ // Any of the previous async calls can reject an error, // we'll catch them all here. console.log(err); });
Clone an existing product that people actually use. I'd much rather see some bootcamp students build a Trello or Twitter clone than summer stupid food truck finder or whatever. 
Hey there, I don't know the ins and outs of JScript.NET, but my understanding is that it's a partial implementation of the ECMAScript 4 proposal (which was never accepted as a standard). You can check out http://www.ecma-international.org/activities/Languages/Language%20overview.pdf for information on ES4 as well. From reading /u/kokwang's [comment](https://www.reddit.com/r/javascript/comments/4kt1yu/some_questions_about_jscriptnet/d3hjd28), [their link](https://msdn.microsoft.com/en-us/library/ms974588.aspx) seems to imply that types are only used at compile-time, rather than incurring a runtime check, though I'm afraid I'm not sure.
I do love jQuery, before hand we had Moo and some other stuff to make stuff simpler, because it was a crazy time for JS. But with all the stuff JS has gone though, I think we need to think pure again, but ti's hard to do that for people that have only the experience with the out fruit and are affraid of the inner fruit. With me, I haven't done profession client side programming in so long, I just use what I can do in a day (of course I keep seeing the problems and reporting them). The most annoying thing I see how many "Tab" plug in things there are and 98% of them don't do arrows for when a tab list gets to big. As with JQ, things might be easier to type, but what is the loss in performance vs pure JS. In the "old days" it saved lots of typing, since there were so many browsers (and versions) you had to deal with, which involved many different solutions. That really sucked, buy JQ bridged all of that. Now, we have browsers that more on the same line in respect to JS, which gives use a simpler way of doing things. JQ is becoming more of a wrap that makes things "easy" but introduces more code which introduces overhead. But JQ does try to tackle that issue by keeping up with the times. I will say that it's not as bad as ORMs.
&gt; order.customer = customer; From which scope this `order` comes from? Also why not declare `order` at top of `getOrderDetails`.
I am using this. It's very helpful.
ES6 (ES2015) is a spec related to JavaScript the language, whereas `window.fetch()` is a WebApi (you can use it in the browser): https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API Availability: http://caniuse.com/#feat=fetch
I agree with you. Making something that's actually useful would be better imo as well.
These were my ideas, kind of just hoping someone could help me define which one would be fairly easy but still challenging app ideas Show song lyrics with link to definition (wordnik api) give a synomn and rhyme if possible to any paragraph to make it rapable rhymebrain API Pull data from Rlisten to this and populate in a Spotify playlist Search by word and get random kanye lyric with random picture and number of times he has said that word Using the LifX api and spotify api to turn the lights red anytime a drake song plays Use spotify api to make a mixtape Meatloaf bingo with the bingo API use web audio api Use numbers API to create a site that shows the a random number fact for the day of the week() Building a a synthesizer on the web using the webaudio API type correct text on the screen and first song that comes up in spotify plays(vhs background) making a spotify sampler Use the whoSampled API to display the sample source of certain songs and play spotify song
the whole thing is 3 lines of jquery btw, if u want to use jquery and es6... `=&gt;` is just `function(){` $( () =&gt; $('#section1,#section2,#section3').hide() $('.chk').change( (e) =&gt; (elem = $('#section'+e.target.dataset.formsection)) &amp;&amp; e.target.checked ? elem.show() : elem.hide() ) )
I chose not to use `fetch` because of lack of abort and timeout functionality. I need both in my SPA to be able to cleanly handle connection issues or canceling requests when the user opens a different page. Even when you don't use some large library such as jQuery, using XHR isn't any less convenient when you wrap it into your own function / class and return Promises.
 _.get What exactly I am gaining by using it rather than accessing the path directly?
 var object = {}; console.log(object.path.that.does.not.exist) // Uncaught TypeError: Cannot read property 'that' of undefined(…) console.log(_.get(object, 'path.that.does.not.exist')) // logs undefined
I love how he couldn't resist pointing out how IE was the first browser to introduce XHR. 
He explains in the article why he nested the promises. In the example you provided there is a mistake — you don't have access to `order` inside the second promise. But we can always do something like this to avoid nesting the promises: function getOrderDetails(orderID) { let order; return db.find( "orders", orderID ) .then(res =&gt; { order = res; return db.find('customers', order.customerID); }) .then(customer =&gt; { order.customer = customer; return order; }); } 
Expected not to? xD &gt; ... and now one of the foundational components of modern web functionality ... So much for a merchan.
There's a long discussion about it [here](https://github.com/whatwg/fetch/issues/20) but I agree that without an abort/timeout fetch is pretty handicapped.
As others have said, commit more frequently. But also, be more aware of risks in the future -- and not just coding risks. Consider what could go wrong, and what the consequences might be, and you can avoid some monumental fuck-ups. 
How often do you need that (which would be a one liner in vanilla anyway) ?
You can achieve the same effect but a callback function is required rather than passing an object to be matched.
Maybe you can create some kind of visual app using the Unsplash API? https://unsplash.com/developers
While it's not the same, there is a TypeScript/ES2016 [class decorator](https://github.com/vuejs/vue-class-component) that makes writing single file components a lot more manageable.
No problem. We are all beginners some time. But if you want to get into programming in JavaScript or any other language I suggest you first read Wikipedia articles to get some bearings and general knowledge, the perhaps move onto You Tube lectures. In JavaScript Douglas Crockford is a good start https://www.youtube.com/watch?v=v2ifWcnQs6M&amp;list=PL62E185BB8577B63D
React Native, JSX, the [ever growing number of reusable open source React components](https://react.parts/web) and hot module reloading are a few that come to mind.
There's of course [ClojureScript](https://github.com/clojure/clojurescript) which uses the Lisp syntax.
You would obviously not write each of them explicitly. See http://stackoverflow.com/a/37192597/263525 *(disclaimer: I'm the author of that SO answer)* 
If you are interested in/playing League of Legends, Riot has a public API you can interact with. https://developer.riotgames.com/
Thanks! 1am me didn't think to hit up MDN. 
If I understand you correctly: iOS 8 and earlier will not fire a scroll event while the window is scrolling under its own momentum (i.e. when the user is not touching the device). This is to preserve battery life. Your options are to * use [`position: sticky;`](https://developer.mozilla.org/en/docs/Web/CSS/position#Sticky_positioning) on the element * use a header that is only fixed or only static * use a scrolling library to override the phone's natural scrolling system and replace it with JavaScript.
Trololo lolo, lololo, lololoooo ...
Show us the code. At least the relevant part(s) of it.
I like the idea! Don't really need to use any math though: https://jsfiddle.net/k2m5sjy1/
Or use react native?
NFC like BT low power or some type of pub/sub like Pushr, PubNub, Ably
I've used this API for a little project, real fun
Looks like you have a good list going. Personally, I'd go with the spotify api and make a music player/ui type of thing.
I think Typescript is the one that is the closest to native ES6.
Templating, yeay
You need to train it first - keep your eyes on the cursor and move it around the screen while clicking.
I say go with something you'd use. You mentioned lyrics and Spotify a lot. Why not build a music player which displays the lyrics of the song that's playing. As you learn you can add searching by lyrics to find songs, etc. 
socket.io
IE was also the first browser to have features which we finally got in CSS3, such as transforms. Don't get me wrong, I don't like the fact that MS has to do things their own non-standard way, but at least they were trying to provide the functionality. They are trying to get better.
Was this file backed up by DropBox? They keep versions back 30 days, even for non-paying users. They longer versioning is the killer feature that got me to finally pay them. https://www.dropbox.com/en/help/11 If you're on Windows, Notepad++ keeps versions every time it's saved. 
It's already in browsers though. https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#Browser_compatibility Granted developers don't have to use it, but it's not like microsoft just invented it yesterday. Google and Mozilla have probably supported it since last year.
Vue is more like Angular where the data binding and layout syntax is with the HTML and not in the JS. 
Try searching to see if your idea has been mentioned anywhere else first. If not, throw it up on [ES Discuss](https://esdiscuss.org/) and wait for it to get shredded or dismissed. If that doesn't happen, you have a shot and can write up a more detailed proposal for it. More information for that can be found on the [ECMAScript proposals github repo](https://github.com/tc39/ecma262).
This article is totally right but why does it have to be so long while it could have been just a few lines ?
Definitely impressive but a little bit over my head thank you though brother! 
A fun - and useful - project might be to write a small script that issues numerous jQuery .get() calls to retrieve html, or html templates. jQuery is an API. Or, you might say it is an API that is a collection of APIs. .get() is asynchronus, so not only can your responses come back out of order, they are almost certainly going to. Getting your responses back in order, or reordering them once you get them back can be a real challenge. And it has realworld value because developers in the field are doing this stuff every day.
I know you've already have an answer, but what are you trying to replace exactly? Is it a word? Sentence? A whole section? I think I might have a pretty easy solution for you, and you'll only need to edit one file to affect the whole site..
What do you want to propose?
No idea, but I suggest you check out the docs for slick-carousel. Might help: http://kenwheeler.github.io/slick/
Neat! It would be great to use this to dismiss notifications that require a manual click... perhaps long blink?
Hi! I am part of the AVA team. For 0.15, we've added awesome features such as better test filename conventions (we run `__tests__` directories automatically), being able to submit tests that should fail, test macros, and experimental support for limited concurrency. Hope you like it! Let us know in the issues or [Gitter](https://gitter.im/avajs/ava) if you have any problems.
Thanks for the reminder about scope. I would have put that but the point was more about chaining the promise rather than using a nesting method. Common sense would tell someone to elevate the order variable to the function scope.
Oh.... hahah, that's probably why it didn't look too familiar. I thought I was looking at the js solutions. Now that I've seen the js solutions, I have a similar question: Number.prototype.add = function(n){ return this+n } Number.prototype.subtract = function(n){ return this-n } Number.prototype.multiply = function(n){ return this*n } Number.prototype.divide = function(n){ return this/n } Number.prototype.square = function(){ return this*this } Is the "this" here the value that gets passed to the function? So (3).add, in this case the (3) is the "this" value? 
It definitely introduced unnecessary cognitive complexity for those who are going to review it.
Thanks for the post. As someone learning programming, I'm always looking for new tips and avenues to expand my knowledge.
whoosh.jpg?
Typescript. Because it is a super set of JS. Basically, TS is the latest JS + more features.
[facepalm.jpg](http://i.imgur.com/FwsRdVg.jpg) --- ^(*Feedback welcome at /r/image_linker_bot* | )[^(Disable)](https://www.reddit.com/message/compose/?to=image_linker_bot&amp;subject=Ignore%20request&amp;message=ignore%20me)^( with "ignore me" via reply or PM) 
Best thing to do is share your idea with everyone possible, to first vet and help evangelize it. Keeping the idea to yourself, so you can get "credit" for it, or "submit it yourself", is a surefire way to kill it.
I second ClojureScript. It might even result in a migration from node to clojure 😂
You can use Scala, than you don't even need to care about all the BS of JavaScript.
Anything under 300 words and it gets docked on SEO. Also possible that Medium has length requirements
Awesome, thanks for the resources!
Hi /u/hypekilla, this post was removed because /r/javascript is not a job board.
It's next big thing man.
+1 for position sticky which is the property that should be polyfilled instead. A polyfill can be found on the MDN CSS position page.
Thanks for the reply and fiddle, much appreciated :)
That is pretty unappealing in my opinion, 3 methods for what should be a single method call.
I would caution using .toggle() if you're using the event listener on numerous elements (like 30+); jQuery's toggle() method is considered one of the slowest animation transitions out there: http://www.learningjquery.com/2010/05/now-you-see-me-showhide-performance. Otherwise, for small apps. and design in modern browsers, it's not too much of an impact (about 8x slower than native JS).
The first line is declaring a new function, the second line is calling that function. In practice, it really improves readability (and reusability) because you'll see a descriptive function call instead of a chain of map/filter/reduce with complete with inline anonymous functions.
I ninja-edited out the part about 2 lines, because that's not really what bothers me... &gt; In practice, it really improves readability (and reusability) because you'll see a descriptive function call instead of a chain of map/filter/reduce with complete with inline anonymous functions. You really think that's better than this? &gt; users.map(user =&gt; user.user);
&gt; You really think that's better than this? &gt;&gt; users.map(user =&gt; user.user); Yes, because that doesn't compose. Retrieving an array of user properties is probably not the only thing you're going to do, right? You might filter after that, or transform the data. Those transformations might be specific to the data type, but more often than not they are pretty generic. By leveraging partial application and function composition, you can build up a collection of reusable "actions". One really cool application of these "actions" is within promises. Instead of: getUsers() .then(users =&gt; users.map(user =&gt; user.name)) .then(names =&gt; names.filter(name =&gt; isAwesome(name))) It would look like: getUsers() .then(getUserNames) .then(getAwesomeNames) where `getUserNames` is const getUserNames = _.map('name') Or you can just write them in-line: getUsers() .then(_.map('name')) .then(_.filter(isAwesome)) Because lodash/fp functions are curried by default, and (more importantly) take the collection *last*, you can do all sorts of cool stuff like this. edit: updated examples to show lodash shorthand for 'pluck'ing
Why not just use ES2015? It is a great language and feels way more mature than ES5. Babel and Webpack have more benefits than just bundling and transpiling - 1. you're getting a complete buildsystem, 2. together they allow you to use mostly anything on npm, which is invaluable.
Now we need another 5 billion comments like yours to make up for the insane a unit of swearing from I.E. 
Thanks for the insight! I believe that for the scale of this project I'll be fine, but I'll be keeping that efficiency issue in the front of my mind when I start working on it. Gonna read through that article now, thanks again
I also just found https://github.com/santoshrajan/lispyscript
Line 242 in target.js Uncaught TypeError: Cannot read property 'el' of undefined Demo doesn't make much sense either, even after reading the description: &gt; Target.js doesn't do much. But what it does, it does well. It is a simple UI library that adds functionality to your DOM elements using data-attributes. It lets you: &gt; * Show elements &gt; * Hide elements &gt; * Toggle elements &gt; * Click away from elements to close them &gt; * Create responsive scrollboxes &gt; * Increment/decrement quantity boxes So I get that the cart button shows off some of these declarations but the whole mess of responsive image tiles is just confusing... and modals seem to pop up randomly.
I have a very simple solutions for this problem... you could build the navbar as a separate html file and use iframe to show the navbar! http://www.w3schools.com/html/html_iframe.asp Alternatively, you could load the navbar to each page using ajax, which is a lot less complex than it actually sounds! I would gladly give an example, and answer any questions if you're interested :)
Exactly this. But I bet money that OP won't share his idea to the community because he probably thinks his idea is so good that it will get merge into the language and he'll get credit for it. LOL
There's some pretty damn tedious boilerplate in JavaScript. It's hard to write beautiful code. Though I'm likely just spoiled by Python. I bet it's far worse in many other languages. I think the thing that bothers me the most is not being able to use keyword arguments that self document so beautifully. Instead of this: `manager.cancelRequest(request, true);` Imagine this: `manager.cancelRequest(request, silent=true);`
Linters should catch superfluous spacing like require alignment, object literal spacing, and other pointless feel-good nonsense.
An eye roll would be cool :-)
That's one way of getting at the data, but I'd use a custom dimension instead. 
You might like this http://exploringjs.com/es6/ch_parameter-handling.html
Don't propose it. Just write your own library that mutates prototypes until it works, and then declare it the "last library you'll ever need."
Holding out for the millions of ECMABucks.
LiveScript or Coffeescript are my favorites for JS+ languages. No braces!
Thanks for reminding me just how much I want the pipe operator in JS. Can we get pattern matching as well? (Half kidding)
Wow.... what a silly mistake, thank you so much!
I can't keep track of all these news cryptocurrencies nowadays.
because it probably happened to him and he got all pissy and use the article as an outlet.
With ES7's `Object.values`, the native syntax is a lot closer to ideal.
Doesnt seem to play nicely with my face :( Works on someone sitting next to me (obviously not both trying to use it at the same time). Probably has something to do with my beard.
Pull and format your way, push and format back to their way. Why even bother bickering or talking about it. I'd rather focus on performance and logic than quibble about style.
&gt; Honestly, the author probably wanted to cover any questions they could think of, avoiding another bikeshed. As pointed out in the comments that is one of the main reasons. I didn't wanted to be superficial, and still I feel I missed a lot of good examples that transcend JS and node.
There is no such limitation actually, it is more about trying to get the point through, because it is very hard to take someone out of the "theoretical beauty" arguments.
It is not about typing, it is about the consequences of doing it. In programming typing doesn't have any relevant difference because one spends more time editing existing code or links between them than creating new one, thinking is much more important.
Honestly the difference was instantly noticeable for me, all future projects at work are now going to be React Native-based :)
He's on a Javascript-focused subreddit, saying that JS is bullshit, in a snarky non-answer to the OPs question. That's probably why he's getting downvoted.
I don't know of many developers that still work with SharePoint. This feels like a blast from the past. 
I may end starting my next project with gulp+rollup instead of webpack. Gulp 4 seems like a decent improvement to the API, hopefully it will be stable soon.
your mira is pretty cool!
Makes sense, thanks for the post
this is helping me in my journey thanks
It's not a non answer. Scalia can be compiled to JS
Yeah, but it is not just about the diff (although one of the main points), there is atomicity, code conflicts, potential of cognitive complexity for code review and eventual inconsistency by having one more thing to care about (this is a minor point though).
Don't tell /r/golang ;]
lightgallery - A modern, electron and nodejs based image viewer for Mac, Windows and Linux. http://sachinchoolur.github.io/lightgallery-desktop/. This is basically the desktop version of lightgallery (a javascript lightbox gallery i developed earlier. http://sachinchoolur.github.io/lightGallery/)
Although nothing like the web applications we have today, MS had [HTML Applications](https://en.wikipedia.org/wiki/HTML_Application) 17 years ago. Also not much like the web components which are _still_ a WIP, MS had [HTML Components](https://msdn.microsoft.com/en-us/library/ms531018\(v=vs.85\).aspx) at around the same time. I'm far from a MS fanboy, but some of their ideas truly were way ahead of their time.
No problems limiting clean here. Linting 24/7. 
Agreed.
Whenever you click store a reference to that item and on next click if the reference is not empty unset the color then overwrite the reference with the current item.
A better question is, "why manage Lambda?" The argument here isn't going to be a technical one, it's going to be asking why, as developers, we should have to think about infrastructure. :)
&gt; if they would look for groups of lines that look like they could have columnar alignment, and stretch the spaces out so that they line up. Wow! That is an incredible good idea! If your editor does it there is no need to commit to source control and it probably fixes most of the problems stated in the article! It would be awesome if someone came up with a plugin for Atom or something like that! Not sure if there are technical limitations though, but definitely something to try! That's why I love reddit, thumbs up with pleasure!
Wrong subreddit. /r/java is thataway.
I tried to get this to work with a simple three.js cube... It did not go well. Also, I suck at JavaScript.
Yeah, i dont really get that part, however, the rest of the article is pretty good.
It's an anti-pattern. Seeing that makes me feel like the person who wrote that article doesn't understand how React's state and props work.
Something something elastic tabstops
On any click, turn all boxes blue, then turn your selected box orange. Something like this in your click handler (I didn't look at your code): $('#box').style('background-color', 'blue') $(e.target).style('background-color', 'orange') My jquery is a bit rusty and yon should use hex colors, but you should be able to infer the intent of the code. 
Yepp, it's only pseudo-code, I should have made that clear in hindsight. @BeastModeUnlocked: a screenshot might actually help, you can embed one in your post with say, [imgur](http://imgur.com/). What variant of the game do you envision - do you only rotate tiles in place or are they movable to other places within the grid, I've seen variants with hexagons as tiles? I was under the impression that you're familiar with the programming language you're using (JavaScript, I'd wager?), sorry for that - been in this too long I guess :-). 
So TL;DR: typical Medium wankiness. 
How is your mustache sir, do you possibly have some sweet handlebars?
Brilliant! Now this just needs to make its way into V8/node! 
English 
I'm a bit more bearish. I see many downsides to getting tail call behavior when you don't expect it. Can you explain why you'd like to have PTC?
FUCK. YES. So happy I don't have manually unroll my elegant recursive functions anymore when optimizing my code.
Sadly I am in the same situation =(. Maybe I get some time to try this out someday, but if you or somebody else start something, please let me know :)
Will this be available online?
Hey there, I created [a gist of the easiest solution I can think of](https://gist.github.com/anonymous/cf0992e6ebc2bc849702af5340353207) in ES5. This assumes that you know the solutions to your levels beforehand. If you need your levels to be dynamic you have to generate a solvable level and solve it in code to get it's solution. Good luck!
I am not 100% sure but I will try to put it online Zach
Seconded, great idea. But instead of an editor/IDE plugin look into the [git smudge/clean filters](https://git-scm.com/book/uz/v2/Customizing-Git-Git-Attributes) and instead of a general pattern recognition prepare a set of regexes for each file type. I could do it, but I'm afraid I will be afk for about a week. :O Any way keep me posted if you come up with anything. 
&gt; bearish I'm a bit confused since there's a German proverb called “Bärendienst” (bear service), meaning an attempt at help that makes things worse. It fits perfectly here so I wonder if you mean that or just that you're grumpy and dismissive towards the idea like a bear.
haha! I really should have thought of that!
**[Market trend](https://en.wikipedia.org/wiki/Market_trend)** --- &gt;A market trend is a perceived tendency of financial markets to move in a particular direction over time. These trends are classified as secular for long time frames, primary for medium time frames, and secondary for short time frames. Traders identify market trends using technical analysis, a framework which characterizes market trends as predictable price tendencies within the market when price reaches support and resistance levels, varying over time. A trend can only be determined in hindsight, since at any time prices in the future are not known. The terms "bull market" and "bear market" describe upward and downward market trends, respectively, and can be used to describe either the market as a whole or specific sectors and securities. The names perhaps correspond to the fact that a bull attacks by lifting its horns upward, while a bear strikes with its claws in a downward motion. --- ^I ^am ^a ^bot. ^Please ^contact ^[/u/GregMartinez](https://www.reddit.com/user/GregMartinez) ^with ^any ^questions ^or ^feedback.
Is there any particular video you want feedback on? I can't see any link.
These braces were for destructuring, another ES6 feature for inline extracting info from an object let object = { name: 'xyz', age: 100, points: [1,2,3] }; let { name, age, points: [first, , third] } = object; console.log(name, age, first, third); Default parameters are just what you asked for cancelRequest(request="", silent=true, somethingElse=otherFunction()) Though you can even mix it which is way cool function cancelRequest({ url }) { ... } let socket = { endpoint: 1, id: 2, url: 'localhost' }; cancelRequest(socket); // extracts 'url' from socket
&gt;[**JavaScript for Beginners - Arrays [4:02]**](http://youtu.be/26005T-6g14) &gt;&gt;Hi, my name is Rob Merrill and I am a recent Advanced Full Stack JavaScript graduate at Code Fellows in Seattle. Welcome to my series on JavaScript for beginners. &gt; [*^Rob ^Merrill*](https://www.youtube.com/channel/UCW_bCOnBazeOcVkvBIQGVsQ) ^in ^Science ^&amp; ^Technology &gt;*^7 ^views ^since ^May ^2016* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
It looks quite nice. It might be better to illustrate what you're saying with examples instead of the whiteboard typing out exactly what you're saying (you could use captions for that). Also, reducing the volume of the background music (or eliminating it) when you explain stuff could make it a bit more clear. Just out of curiosity, how do you make whiteboard videos?
Ironically bear markets sometimes can be foolish attempts at trying to help a crisis, only to make it worse.
Thanks for the feedback! VideoScribe is the service for the whiteboard. I then just edit in iMovie to sync up the audio script.
Yes, it's an anti-pattern. Nowhere did I say you should do it, I said you can if you need to for whatever reason. I realize it wasn't clear so I removed it. Sometimes there are legitimate reasons for keeping state in the component (e.g. not using Flux).
Follow up from the previous investigation (https://www.reddit.com/r/javascript/comments/4ksz5x/comparing_react_to_vue_for_dynamic_tabular_data/)
A big one is that we're based around our open source software, [Nodal](https://github.com/keithwhor/nodal). We're not really based around the concept of microservice architecture --- we want to provide most of the benefits that microservices provide while still enabling developers to think in terms of traditional MVC. :)
 I am using ShieldUI (www.shieldui.com) for all my development needs. It has data viz components, as well as grid, editor and input components, as well as a datasource. It might give you a swift start on a solid track.
I think you should have an Album component that contains AlbumHeading and AlbumBody, it's weird to me that heading contains body. Then have an App component where you generate the Album components like you're doing for Albumh. When you add components dynamically you need to set a unique key for each one https://facebook.github.io/react/docs/multiple-components.html. Also I noticed you need to use .bind(this) for that onClick handler. EDIT: A simple way of showing/hiding the body would be to have a toggleBody function on Album that gets passed into your heading as a prop. Function should use setState() so it gets re rendered. Then in your AlbumHeading's onClick handler you can do this.props.toggleBody();
ha I'd go nuts seeing that. but can't really beat this :p - https://jsfiddle.net/hmhu2k10/
I would definitely go with Angular 2 and Angular Universal - it gives us the ability to build a SEO friendly single page app, something that a couple of years was only doable for very advanced development teams, now anyone can do.
prototypes are your friend var sumObj = [[1,1],[1,2],[2,1]].reduce(function(p,c) { p[c[0]] = (p[c[0]] || 0) + c[1]; return p; } ,{}); var sumArr = Object.keys(sumObj).map(function(k){ return [k, sumObj[k]]; }); edit: typos... https://jsfiddle.net/8q9eLqt6/1/
so? you set up codeship and that's it, can do all that and deployment in one run 
Teamwork! :)
That is great! If I coded like that all the time, just imagine the job security I would have. 'Don't get rid of him, he's the only one that know how the system works!!!'
This is really great stuff
Totally fair - that's a reasonable conclusion for many use cases. In our case, we've found a performance ceiling with one of our products built with React and can definitely see some benefits to using Vue instead. Obviously YMMV depending on the specific problem.
React. Or if I can cheat and not use Js, Reagent (Clojurescript interface to React). Edit: oh, you wanted to know why. Mainly I haven't seen anything better. Vue and Mithril are all the hype rn. Vue - I'm not really into the two-way data binding thing. Mithril - client-side MVC, ok, interesting I guess, but damn defining all those views with `m("div"...` looks clunky as hell IMO. To be fair I haven't tried either of them. I keep seeing people say that Vue is more suited to people that are newer to programming or Javascript... maybe that's fair, idk. I don't think I've grokked what they're going for with Vue tbh, because when I look at the examples, it looks like it's not buying me much over just using vanilla JS. I like React because I can think like a programmer and simply operate on data structures. There's not too much magic: once you get what's going on in a general sense, it's very easy to reason about what's happening with bugs and such. I've been maintaining a pretty complex screen for about a year now and it's been a breeze. Whenever they need a change or a new feature, it's been some of the easiest code I've ever written to maintain. I think the functional/declarative/immutable approach mixed with writing bite-sized components and composing them is what makes that the case.
Not a framework answer, but something that I feel strongly about on the backend side is that I will never ever use Mongodb again.
Thanks for this. Will give it a try in 2h when I'm back at the office... No, I need all entries to be there with their unified values (if it makes sense). {[a; 2],[a;3],[d;4]} =&gt; {[a;5],[d,4]}
Hi, thank you this, will give it a try when I get into my desk again.
Sounds about right - it highlights quite well why the TC39 is a broken institution
If you enjoy doing that, don't let me stop you. We're not a lambda analog. We offer open source software that compiles to the cloud. Enjoy configuring API Gateway and managing all of your other services. :)
React does not use web components. ES6 and modules has nothing to do with React.
If anything it goes against them
Ember is the only framework I know that actually includes ES6 and standard modules by default.
Agreed. Seriously, that sounded like buzzword bingo right there.
Bummed about the pipeline operator. Would be a real boon for a lot of devs.
Fun! Only duplicate metrics: http://codepen.io/anon/pen/JKPBNR?editors=0010 *All metrics: http://codepen.io/anon/pen/pbzZxz?editors=0010
lamdba is a service on a large platform - now what if my API needs a db? where is it hosted?
Depends on how big project. I think I'd start new project with immutable, redux, react with webpack as main build tool 
Polybit provides you scalable databases in the cloud as part of the platform. I suppose I should clarify that. :) Thanks for bringing it up!
It's by far the most widely used framework that is designed to work with them. It takes very little effort to use react with the current holy grail setup compared to the others widely used in production. Also React is literally designed as a series of components, not quite sure where you got that from. I didn't mean the highly experimental W3C spec that probably won't see the light of day, I meant the convention. 
It will depend on the project. If the project is small to medium size, then I will use VueJs. If the project is quite big, I will choose between Aurelia and ember depending on performance and feature requirements
I guess it would be overkill but http://www.jsfuck.com/ is always an option. alert("Hello world") turns into to 10721 chars. [HERE](https://www.reddit.com/r/javascript/comments/3vd5f6/jsfuck_write_any_javascript_with_6_characters/cxn7ir7) you can get an idea of how it makes the letters 'a' and 'z'
The [Wat talk](https://www.destroyallsoftware.com/talks/wat) he referred to at the beginning. It's awesome/funny if you haven't seen it before. Edit: the JS part of the talk starts at about 1:20
Mithril's `m("div"...` is a lot less clunky than React's `React.createElement("div"...`
I learned how to code, not solve software problems. I never really learned all those academic parts of software engineering! So I would much rather stitch together 100 libraries than methodically design and implement an application.
Interesting. I've used Ractive for several projects, which has a similar design philosophy to Vue I believe. I really like it, but I am worried it's not getting updated much anymore.
Aurelia. No need to explain :)
Yes, I can use google and have read that page. Do you have anything to actually add to the discussion?
[qooxdoo](http://qooxdoo.org/demos). It doesn't feel like I am writing Javascript anymore. It doesn't need advanced CSS. It can do web apps looking like native applications, classic html webpages, and mobile. It boosted my project by miles. Second best, [Dojo](http://demos.dojotoolkit.org/demos/). Maybe I was too noob when I first tried it so I didn't understand it that well. Still I think is a real pain to theme but very helpful in programming. Both have the downside of not having much dead tree literature for the recent versions.
Sometimes I think people purposely try to find ways to confuse other people about javascript. Some of these examples are not real code, and are designed to confuse people about type coercion. 1 &lt; 2 &lt; 3 = true; 3 &gt; 2 &gt; 1 = false; This is classic type coercion, doing exactly what it should do (and also not an example of real code). 1 &lt; 2 = true. true &lt; 3 = true, because true is not a number it must be coerced to 1 and 1 &lt; 3 = true. 3 &gt; 2 = true. true &gt; 1 = false, because true is not a number so it must be coerced to 1, and 1 &gt; 1 = false. It's really quite simple. It's not a "quirk", it's a very well thought-out feature called "type coercion". While some people seem to think this is a problem, it's really not. It's only a problem when you try to trick people into think it's a problem. 
Can I ask why? and what you'd use now?
Meh, while I agree with this in general, I also believe in not re-inventing the wheel sometimes. Coding is often time also about communication with other people ( and sometimes our future selves!). The conventions frameworks give for sharing code with others can really expediate things.
memcache?
/u/Mackinstyle tried to use sarcasm on the Internet. It's sad that people don't get his intentions because it is a hilarious comment. 
Hmm, yeah. Two issues I see there. First, the article gets something (I feel is) incorrect about the Tabs VS Spaces war... but maybe it's best not to get into that. Second using tabs for non-indentation purposes on non-equal-length line segments will show as an ugly mess for anyone who has a significantly different tab width - and this makes tab widths so variable that it'll be a mess for any editor or other display that doesn't have this plugin. That said, this looks great if you can guarantee everyone who will look at your code will have elastic tab stops, and really, a plugin that resizes spaces to user preference should probably include something elastic tabstops functionality (at least as an option).
Hmm, yeah. Two issues I see there. First, the article gets something (I feel is) incorrect about the Tabs VS Spaces war... but maybe it's best not to get into that. Second using tabs for non-indentation purposes on non-equal-length line segments will show as an ugly mess for anyone who has a significantly different tab width - and this makes tab widths so variable that it'll be a mess for any editor or other display that doesn't have this plugin. That said, this looks great if you can guarantee everyone who will look at your code will have elastic tab stops, and really, a plugin that resizes spaces to user preference should probably include something elastic tabstops functionality (at least as an option).
I forgot to open and close with sarcasm tags. Rendered anyway. Curse this non-SGML!
I'm aware of the sarcasm. Implying that developers who create software built on the libraries of others are somehow inferior or possess less of an ability to "methodically design and implement an application", is idiotic.
I wouldn't call it "very well thought out", but at least it's a fairly well known feature. Overall I was expecting more wtfs but the effect of breaking in a finally really surprised me. 
&gt; I see many downsides to getting tail call behavior when you don't expect it. Such as?
I'm up voting this strictly based on name and emoji use 
[Here's an article explaining Wat is happening in the examples too](https://medium.com/@mikehall314/wat-s-happening-a-closer-look-at-wat-b7f689d33945#.ema8l8h3b) tl;dr: type coercion and overloaded operators.
how the hell would you call it anything other than well thought out? one comparison at a time. the first goes first and resolved to a truey. everything after that is the bad programmer doing bad things.
http://jsbin.com/biluvimado/edit?html,js,output
I'd love to give redux-elm + horizon a go. 
I use my own. For publicly available stuff, I'd be inclined to go with Redux on either Inferno or DomVM. If I needed to do it with a team, I'd consider React, Ember, or Polymer.
I'm hoping to give Rob Eisenberg's Aurelia a go on a project soon. I like what I'm seeing of it, so far. However, I'm finding that almost any of the popular frameworks really start bogging down as soon as your project becomes even moderately complex or "heavy". I typically work with forms that may have hundreds of text fields active all at once, with "single-click/save-all" functionality. This really doesn't work well with two-way data binding in any of the frameworks that I've tried. Anyone suggest something? 
Hmm, that's another good way to do it. That said, there's a case for making both an option: * A plugin works on code as it's written, before it's committed to a git repository. * A plugin works on code that didn't come from a repository at all. * A plugin can have its settings tweaked moment-to-moment. * A plugin can be turned off if a 'raw' view is needed for a moment. Of course, smudge/clean filters work for whenever a plugin isn't available or desirable, and as they're a different part of the toolchain, will be a better option for some workflows. This brings up a new choice - should the clean filters clean to "no alignment or other extra whitespace", or should they clean to a specific type of auto-alignment? While a project can do either, I think there's a strong case for "no alignment" - if nothing else, it avoids extraneous changes in the repo due to alignment changes in lines that were otherwise untouched. Additionally, it's an easier starting point for individually-tailored smudge filters and plugins to work from. Plus, I'd say that automated alignment is more likely to get things wrong in an edge case, and changing how the alignment works in the repo is going to be more of a pain if someone wants to fix an edge case or just update the project's standards.
I would call it a dangerous and unnecessary feature that should not exist.
If you like this, Kyle has a workshop in London next month on ES6 and async: https://ti.to/cooperpress/kyle-simpson-workshop/
What, type coercion? It should exist within the context of what JS used to be used for. Not for complex programs. But complex JS programs have only started being a thing recently. 
&gt; Python does this, and has no trouble. Once again, Javascript is not Python - and thank god for that. Sorry that Javascript is not more like *your* preferred language, but that doesn't mean the way javascript does things is bad or wrong, it's just different and I quite like how it works and so do many others who actually understand how and why javascript works. &gt;I would expect a programming language to return boolean "true" for 3 &gt; 2 &gt; 1 Javascript is a programming language. It doesn't do what you want it to do, so maybe it's your ideas that are misaligned with how it works. It does make perfect sense in the context of type coercion, and saying it doesn't make sense isn't really making you look cool, or right, or smart.
Again, the example presented *is not real code*. If you are coding something that coerces in this way then you are probably doing it wrong to begin with and have a whole other world of problems you need to deal with other than type coercion - and using Python won't save you, nothing will except making mistakes and learning from them. Noobs shouldn't be writing code to launch rockets, do bank transactions, or anything important, and this would be a really noob mistake to make. People typically learn these things before they get into a position of writing code of any importance. There's a million ways to write shitty code in any language, and singling javascript out as bad or wrong for the way it treats type coercion is just trolling. 
&gt; Unless someone somehow learns about the deeper-level inner workings of JavaScript before learning basic statement syntax, they are likely going to be confused by this (seemingly) inconsistent behavior. It's not unintuitive at all, not in the least, not if you've bothered to read anything about javascript and how it uses type coercion. Can you read?? This isn't some mysterious thing deep inside javascript. This **IS** Javascript. It's *extremely* well known and if you haven't learned how type coercion works in javascript yet, then I suggest you go out and READ ABOUT IT. It isn't like javascript came out yesterday and you get to ridicule it because it's doing it wrong - Javascript was around for 20 years, so if you can't be bothered to learn it then I suggest you don't use it. &gt;this behavior could easily be corrected and type coercion could still be a feature of the language if JS evaluated comparison statements right-to-left and/or evaluated comparison chain components independent of each other This is nonsense. If javascript changed to doing this it would break most of the web. Not a good idea.
&gt;Such hostility. Ease up. You do realize you're posting on the public internet, right? I'm under no obligation to please you. If you don't like what I'm saying or how I'm saying it, then you can simply avoid writing comments back to me. 
Sure, and people do that all the time by creating bootstrap projects that have all the dependencies and setup done for you. The problem is that they're making decisions for you about what you'll use, such as React, Webpack, PostCSS, etc etc. One of the exciting things about Javascript is how fast things change, and all the new options you have for doing old things. You can do that same tutorial with normal CSS and ignore the PostCSS stuff, if you want. React was the point of the tutorial, but that could be replaced if you want. If you have a better build tool than Webpack, or a better transpiler than Babel, you could use those, too, instead of what they say there. What you're asking for is fewer options, but if we stuck to that philosophy we wouldn't even have React in the first place, making the whole discussion moot. I get it. It's incredibly frustrating to get started with Javascript web development right now, and the server side of things is even crazier! But start simple, get the basics down, and then add on the advanced stuff like React and PostCSS later. You'll get there, and you'll understand why things are like they are.
&gt;We will send you an update as soon as the first tutorial is available. Seriously? Why bother posting here if there's nothing to *see* yet? There are far too many didn't-finish tutorials out there already. I dn't need to put in my email to subscribe to another of them.
BackboneJS, because it doesn't shove it's hand up your ass and force you to do things you don't want to do. *looking at you angular*
I think this is probably the 10th time I've said it: 2-way data binding on input elements is just syntax sugar for a one-way value binding + an input listener that updates the value. That is different from, say, two-way binding between components (which is possible but not the default in Vue). People rejecting a whole library/framework due to the sheer appearance of the term are either looking for an excuse for their laziness or simply do not understand what 2-way data binding really is.
The package is a shared dependency between vue-loader and vueify, which are the respective transforms for webpack and browserify. Still, with vue-cli you could've tried Vue HMR first hand in 5 minutes but you just assumed it didn't count. /shrug As for the others... - JSX is not even something that counts because Vue doesn't need it. And you can use JSX with Vue 2.0 if you want. - ReactNative is a big win for sure, but if you are not building mobile apps then it is irrelevant. There is also a project that renders to native using Vue's component syntax, which is being actively developed by Alibaba, the largest e-commerce enterprise in China. - Not sure if you just ignored the awesome-vue link mentioned above, but "ever growing number of reusable open source components" applies perfectly well for Vue too. The absolute number may be smaller, simply because React's ecosystem started the growth earlier. And I'd argue the marginal return for the number of 3rd party components decreases when most of the important pieces have consolidated. I'm not even trying to convince you to switch to Vue, but most of the reasons you listed can be completely irrelevant for a large percentage of users.
&gt; Why the name Closure then? This is because the function inspects it's environment and *closes over* the variables I fully accept this is the answer, but it still strikes me as weird and unintuitive terminology.
Yes, this is a known bug with autofill that google has ignored for years. I solved this for ui i was working on last year, ill come back and edit this post when i find my old source code.
That's *incredibly* good news. I would love to commit my company to using Ractive for our ongoing development, but the lack of any visible activity on, say, ractivejs.org is a real hindrance to me selling it. The last blog post, for example, was May 2014
This dude is the embodiment of jumping-in-the-latest-trend-bandwagon dev. Not that I have anything against all the things you've stated. I'm actually a big fan of React and modern JS but you didn't really provide an explanation or reasons behind why you believe in the things you've stated. 2 of which are not even related to the discussion and web components != React. 
*Some* programming languages *cough*Python*cough* do the intuitive thing with expressions such as `1 &lt;= x &lt; 25`. You have to admit that's way cooler than type coercion, especially since type coercion is—generally speaking—awful and a misfeature, much like automatic semicolon insertion. Sure, an "experienced developer" should know about it, but that's like saying "an experienced PHP developer should be able to write a secure program". Just because it's true doesn't mean the design of the language isn't making things harder than they need to be.
I weep for your codebase if you think anything else might be the future of frontend engineering.
LOL. Where in my comment did it even indicate I thought of anything else? Maybe I just hit a nerve on the bandwagon thing because its true. I even stated I am a big fan of React and modern JS which encapsulates ES6 and modules. Good comeback though. Attacking things that don't exist because you can't respond properly to criticism on your original comment. Classic fanboy reaction. Parroting other people's ideas and thoughts because you can't form them on your own. Kinda makes sense why you replied the way you did. I weep for people who have to work with you.
What's weird about it though is that in my case I auto-focus the username field on page load, and attach a handler on it to where if the user hits "enter" it tries to log them in. You would think that hitting "enter" would be a user interaction right? Wrong. Even after hitting "enter" JavaScript still can't read the value of the password field. However, if the user hits "enter" again, suddenly JavaScript can read the value. If chrome wants to implement this security measure, that's fine, but hitting "enter" should count as a user interaction, and I should be allowed to read the password value after that.
 Use a text editor? "Analyzing source code" is vague. Do you mean static analysis for complexity or test coverage, with something like [plato](https://github.com/es-analysis/plato)? Why does it have to be small - is this something you want to run on a page? LOC wouldn't matter in that case if it'll be minified.
Any function with inside parentheses will self execute. e.x. function AnObject() { var aMethod = (function(){ // Some stuff })(); } When you assign an init a AnObject, aMethod will execute var an_object = new AnObject(); // Some stuff happens This, of course works in general, so when the browser loads a piece of code written like that it will execute the function. You can even pass it arguments like so: (function(arg){ // Some stuff with args })(foo); So if you write your script like that myFunc will run on assignment var myFunc = (function(){ alert('Hello'); })(); [More here](http://markdalgleish.com/2011/03/self-executing-anonymous-functions/)
 var myFunc = function() { }; myFunc.prototype.init = function() { console.log('look it worked'); return this; } var someUniqueClone = new myFunc().init(); console.log(someUniqueClone); edit: Ah, I like these other responses better than mine :). 
Is there any difference during a submit event handler and using form serialize?
that fixed it, thanks
You're welcome :)
Who will stop you. 
Knockout is a terrible framework, and anyone who starts a new project in it should be shot. *At best* it allows you to quickly create unmaintainable prototypes. Source: Just left a company that created a gigantic mess in Knockout.
We use Sequelize and love it. Currently with MySQL.
just gonna drop this here ;) https://github.com/leeoniya/domvm
Putting everything inside a form and listening to the submit event actually worked. Thanks!
You'll have to forgive me for not taking your (bitter) opinion to heart. You can create a mess if you aren't careful in any framework. To me, your problems sound more like planning and/or implementation-based.
Updated question
You don't need to use Vue router. Just use the component :is trick from the large scale app section of the docs, or a variation on that with cookies to store the equivalent of the route. 
If you want a solution that doesn't trigger a page reload on submit you can try this. Use a hidden iFrame as your form target ` &lt;iframe name="my-form-target" style="display:none" src="about:blank"&gt;&lt;/iframe&gt; &lt;form target="my-form-target" action="about:blank"&gt; &lt;input name="user"&gt; &lt;input name="password" type="password"&gt; &lt;input value="Submit" type="submit"&gt; &lt;/form&gt; ` Attach a `submit` event handler to your form ` form.addEventListener('submit', function (event) { // do something }); ` The form `submit` event is what stores the values in browser auto-complete. Using the iFrame as a proxy target for your submission event allows you to trick the browser into store the autocomplete values without reloading the page. 
[removed]
If anyone has questions, it seems like a few guys of Riot Games are over at /r/programming answering questions: https://www.reddit.com/r/programming/comments/4l6pho/the_architecture_of_the_league_of_legends_client/d3kvuzl
[Mithril](http://mithril.js.org/) is a very robust micro-framework. It shares a lot of concepts with React and is very approachable imo.
Agreed, mithril's source is very approachable.
Well doesn't make much sense to call it a "Promise" if you can renege on it. I think promises are fine how they stand. If you want an async primitive that can be cancelled, then get behind rxjs/Objservable being standardized. (Observables can be sync as well...) 
and where is it all hosted?
He just comes across as bitter and an annoying person to work with. Switch statements with fall through can be useful.
Why they didnt just use Electron instead?
The only one of these that really bothers me is the super keyword binding for classes in ES6. 95% of what he said is confusing, sure, but I would guess I could go my entire career and not run into any of these (except maybe trying to coerce Symbol, people are definitely going to be bothered by that). But as someone who loves mixins in python, not being able to `.apply()` on a function that calls `super` is going to really mess some things up. Like, really badly. To the point that a lot of libraries will definitely not use classes, and probably won't work for anyone who does. I love the new class syntax (I think I'm rare though) because it's easier to read and easier to write, but that's pretty bad in my opinion.
I love this guy! He has some great courses on pluralsight, and a really solid book series.
I agree, its one of those opaque names that does not say anything about the concept. Like Monads or Functors, etc. 
I have a Vue app that it's an iFrame, and I just Vue router without problems. The iFrame manage its own browser history. 
This will be unpopular in these parts, but... ExtJS. I'm not aware of a more powerful and logical (once you get past the learning curve) JS framework. This of course assumes we're talking a robust webapp project... I might give a different answer for a plain Web site. But given I build Web APPS, ExtJS is second to none IMO. If only the cost structure wasn't so exorbitant. 
Your update doesn't change anything. You're still assigning a function to a variable. The update now simply does it by referencing the function through an object. Outside of using a getter/setter, your function(s) won't execute unless you use parens `()`. If you're trying to do assignment and call in one line, you could also do that, just not within the declaration. var callFunc; (callFunc = someFunc.myFunc)();
"brief" :) Someone learning js nowadays is in for a good time. Good read though.
hire people
I, personally, am not a fan of "closes over"; it doesn't really do it for me. That sounds more like blocking or shutting out. I prefer "enclosing" as in encompassing, or capturing within. There's less of an implication of adverse effects.
Strict typing in JS? Come on, JS is weak typed. It's the feature, not bug. Use TS if you need strong typing. Or use completely different language like Java. Anyway: wrong post to comment, this one is about JS. BTW, this dude is weirdo. A guy who writes books about JS talks about his personal WTFs? It's all wrong, like he doesn't really know what he is talking about. I wouldn't read those books. They could be confusing. For me "finally" behavior is perfectly normal. If you place 2 returns in your function - from you expect both to be executed - why should you get value from the first one not the second one? This is WTF for me. Why write such a weird code? Language exploit? For what (TF)?! If you know how switch structure works, geez, even its syntax alone - you won't put default on top, and if you for one weird reason do, you WILL as hell remember to put a break at the end of the case. Why this weird weird dude insist default case should be inconsistent with all other cases? Damn, people like this must have designed PHP ;) I bloody HATE inconsistency. Handling all the cases the same is perfect. I have my language preferences. I wrote quite a lot of code in many different languages. Very different languages. There is no one perfect and correct language. It's as obvious as there's no one tool for all jobs. Week typing is useful sometimes. As any language feature, except inconsistency. In strong typed languages as C# we can even fake weak typing with boxing. In JS we can fake strong typing with typeof and conditions. Sometimes we want our function or method operate on ducks, sometimes on integers only. Interpreted languages are good for many things, compliled ones for other things. And we have even mix of those two. If you say WTF - then, well, learn. People say WTF if they don't understand. It's fine, but it's not about broken or even weird language features. It's about they haven't learned. Let's say you very experienced with using a hammer. Then you got screwdriver and say WTF is this? How the hell do I use it on nails? It's ridiculous. Oh, BTW, if you use return in generators - you should see it coming. If the language accepted (even more) obvious bugs and tried to guess what to do it would be barely usable. BTW, whitespace instead of number treated as zero has nothing to do with bugs. It's a feature which spares you from writing extra code of assigning zero in case user hasn't entered number in a field. You won't assign strings containing whitespace in code as numbers... Unless you're this weird guy ;) Well, in JS I sometimes must check the types. In C# I sometimes must check for null. Oh, and not all types are nullable. WTF? Not really. Minus zero is confusing? MIN_VALUE? How about reading the friendly manual? ;) MIN_VALUE defined as in JS would not have sense for integers, but JS Number type is not integer. Nor it's like decimal, float or double. It's something else. Geez, you have to be extra careful choosing books about JS these days ;)
"How can a beginner mechanic learn to rebuild an engine and install a turbo charger? I've changed my oil, brake pads, etc, and in 3 weeks I'll need to rebuild the engine myself. What's the best way to learn how to do that?" Programming isn't easy. There aren't a lot of shortcuts beyond "learn more, build something with it, repeat". If you could learn it in a few months it wouldn't be such a highly paid profession. Ideas are often the easiest part by far. It's incredibly rewarding tho, don't give up. Good luck!
React with redux, immutablejs, redux-thunk and reselect
~~This isn't quite right. Browserify actually predates requirejs/AMD.~~ (This is wrong!)
Wow, did not expect so much saltiness in this thread. 
A bunch of us should pool our money and tell him together.
I didn't get that impression at all.
I would suggest using something like three.js to render onto the canvas, and then set it to render wireframe. That would get you pretty close. Alternatively, you could simulate that with a 2d line drawing api, but the complexity of that would depend if you're rendering with perspective foreshortening or not.
What's the ugly side of promises? I like async/await a lot, but it's just syntactic sugar to me.
I fail to understand the angst around the idea "it can take an entire evening or day to set up a react project!" You are going to be spending a lot longer than that on the project anyway (hopefully). Half a day or a day is a vanishingly small amount of time when creating a product. 
I found that Browserify started at 2011 and RequireJS and NodeJS was 2009. Do you have any reference where I can dig it further? Thank you.
I'm a beginner too, and I've been using Meteor. Database is built in and a lot of the devops can be taken care of using Meteor's command line interface (cli). 
You're right! I just looked at the commit histories for both repos, and it seems that requirejs predates browserify by about a year and a half.
I thought it was there to prevent a page from hijacking your auto complete. 
Did you watch the video, though? Kyle Simpson is not a JavaScript hater. Quite the opposite. 
They're all kind of similar. They each define some kind of grouping. `(callFunc = someFunc.myFunc)();` is more similar to `var i = (5 + 3) - 1;` in that it enforces an order of operarations. `(callFunc = someFunc.myFunc)` groups the assignment from myFunc to callFunc so that it occurs first. The result of that assignment is the newly defined value of callFunc. What you get then is equivalent to `(callFunc)();` which is the same as `callFunc();` and that calls the function. With `(5 + 3) - 1` the parens group `5 + 3` to be evaluated first followed by the `- 1`. The IIFE (`(function(){ ... })();`) doesn't represent order so much as it defines a one-time use scope allowing you to define variables that don't pollute the global namespace. If you don't declare any variables in an IIFE like this, its mostly pointless. var someFunc = (function(){ return { myFunc: function() {alert('hello');} } })(); This, for example, does not benefit from being within an IIFE. It could have just as well been defined as: var someFunc = { myFunc: function() {alert('hello');} }; It would be more appropriate if it was defined something like: var someFunc = (function(){ var message = 'hello'; return { myFunc: function() {alert(message);} } })(); Here, the `message` variable is being defined in the IIFE. If an IIFE was not used, this variable would be defined in global where anyone could access it and it could potentially interfere with other variables. Being in the IIFE its local to that function and not available anywhere else except the other definitions also within the IIFE.
The coffeescript source code is a fantastic easy to understand compiler. I read it over a couple months until I understood all of it and could implement the concepts and learned a huge amount. Very well written, by the guy who did underscore and backbone. As a bonus, you will *really* understand coffeescript afterwards. 
Backbone is a great place to start, basically the original framework and it has [annotated sourcecode](http://backbonejs.org/docs/backbone.html)
I'm a beginner, 2 months into my first programming job (and also a fan of Kyle Simpson) but if I caught myself writing code that toad-fuckingly retarded, I would probably take that as a sign to go home.
Extreme emphasis on YMMV, like absolutely massive.
you don't have to know what it does, just that when it does it, it does it right.
I can't see why would i use this over [vanilla-js](http://vanilla-js.com/). that one is way more unobtrusive and is 0 bytes uncompressed. 
I like this approach a lot. It doesn't change the current promise implementations, the new syntax is more minimal, and the new syntax isn't promise specific.
&gt; using Python won't save you &gt;&gt;&gt; 3 &gt; 2 &gt; 1 True &gt;&gt;&gt; 1 &lt; 2 &lt; 3 True &gt; the example presented is not real code I believe this is perfectly reasonable code for checking range bounds or another type of ordering. And yet it is not real code in realm of Javascript. I do understand that different languages have different trade-offs, but you should admit that some trade-offs may be much more helpful and reasonable than alternatives.
Ended up using this one. Had to made some changes but it worked very well at the end! Thank you!
Thanks so much for this. I've had some issues with this implementation and ended up using ForScale's solution.
Thanks so much for this. I've had some issues with this implementation and ended up using ForScale's solution.
Learning fall through is learning how a switch-case works though. If you didn't know about fall through I'd argue you never learned programming control structures properly.
you know riot promised a new stable client back in closed beta?
brwoserify a couple of times ;) Nice summary :)
Is testing new browser versions that bad? Just use the chrome beta for your daily browsing and you'll be forewarned when something is about to break. 
A framework is a library or a set of libraries that come with a prescription for application architecture, such as Angular. Another approach is to make a decision on application architecture, and then find the libraries that would help you build that, like people do with React. Either way, if you have an app architecture in mind, then you're either going to use somebody's library or write it yourself. The writing of a library may require domain-specific knowledge that is irrelevant to the rest of your app, and the writing of a library that's better than the field is very difficult. Knowing when to choose a custom solution over an existing solution is not just a technical decision (unless you're working by yourself for yourself), but it is also a *project or business decision*, and all software decisions, even ones not related to business, necessarily have business-like constraints, such as the finiteness of resources and the timeline to deliverables, and they almost always involve the coordination of human effort. Software engineers benefit from thinking like an *executive*, whose domain is to contemplate the balancing of factors in service of organizational goals. So before you manufacture your own digital display technology, you might want to consider what set of goals you wish to service, their factors, and what resources you have to attack the problem. Maybe you didn't want to dedicate all your talent to compete in the digital display industry. Maybe you wanted to create a Tesla with a digital display, and that's your big focus. So when you decide on custom solutions, make sure that it's a good *executive* decision. Rewriting React or RxJS may have been myopic judgment.
SVGs are just markup, you literally just write what appears in an SVG. Auto-generated markup has always been quirky and is generally best avoided. If you want to be good at front-end then writing proper markup is a skill you need to master. If that means manually writing your SVGs or at least going over and correcting auto-generated markup, then that's what you need to do. Also SVGs aren't really anything to do with Javascript.
Regardless of the intent of the speaker, it's also realistic thinking. Most people cannot write a better-than-the-field RxJS or React. Knowing yourself, including your incompetencies and pace of personal growth is important. You can't just throw guidance and effort into a training model and expect top quality to come out.
I actually like the wheel analogy. There absolutely is no need to re-invent the wheel. A regular wheel works for almost any car. But now imagine a high-end special vehicle. Would you use a regular wheel or would you use a carbon fiber supported aluminium ultra lightweight wheel having the optimum wide and diameter? If there is such a wheel available: Buy it. If there isn't: develop one. 
You can make cubes in regular old CSS. The 3D abilities are pretty amazing. https://davidwalsh.name/css-cube Three js would be ideal for anything more complex
what use case? obviously for the post authors’ case, the difference didn’t matter after all.
I don't know much about this issue but I suspect that if it is a webview issue, you could get around it by using [Crosswalk webview](https://crosswalk-project.org/)
I took a quick look and it seems to generate the APK for you, we'd like to add some native functionality like push notifications as well so I don't think that's suitable. Thanks for the suggestion though :)
Check out Meteor
This is certainly not AMP. AMP does not permit any custom JavaScript on the page. They demo'd it as an example of a Progressive Web App.
It's not unnecessary though. Fall through is useful and a major reason to use a switch instead of an if else if else if chain Goto is stupid because it allows a jump around a large code base meaning it's not possible to see all the code. Switch doesn't do that. And regarding explicit fall through, I disagree. Break is the explicit bit.
Amazing article. The time spent into that tutorial is insane. Even testing is included. Wow. The comments in HN for this article is a shitshow lol. https://news.ycombinator.com/item?id=11778663 Some people suggests to learn 1 by 1. That didn't work for me -- that's way too much shit at once. I personally learn better by example, so I prefer the boilerplate route. I see boilerplates just like I see Angular -- a batteries included framework (because a framework is really just a collection of libraries). I clone a boilerplate, starts coding.. got questions? check the docs.. then I expand out and learn the stack 1 by 1.. At least, I got something to test with. If you never heard of Babel, Webpack, React, Redux and you're trying to learn them all, you're going to have a bad time. If this tutorial scares you, but you want to learn all of these and more.. do these steps: - Find a simple idea of a mini project to do. If you can't find one, why not a Yelp clone! - `git clone` this: https://github.com/erikras/react-redux-universal-hot-example - `npm install` - `npm run dev` - Start hacking and reading the source. 
Totally right. Let's get rid of for loops and do-while statements too.
I love using React with MobX, which actually internally works on the same principles as Knockout. MobX has all the benefits of observables, but you can render with react, which is a superb library for rendering DOM compared to raw knockout.
Mithril is definately fast nad light, for small pieces of functionality on the web it seems like perfect tool. I have to be inclined to choose React though for bigger projects. Especially those, which might need a mobile app sometime in the future-react-native has me covered there. 
No love for [Cycle](http://cycle.js.org/) here? Admittedly it takes a bit of time to wrap your head around it but once it clicks it just completely makes sense. Unfortunately there are a number of side projects going on at the moment, Cycle, Motorcycle and Cycle Diversity, I do hope they'll converge in the end.
Why not just put the actual function references in the array instead of putting their names as strings? Example: function foo () { ... } function bar () { ... } const funcs = [foo, bar] funcs.forEach(func =&gt; { func() }) It looks like you're using ES6 in your code which is why I'm using it in the example.
Don't be pedantic.
what? OP asks for js framework. while nodejs does not even qualify for js framework. albeit it can be "considered" as we consider vanilla-js, but you are not exactly advocating nodejs over express or hapi, right? 
 function fn (evt) { [].slice.apply(document.querySelectorAll('.btn')).forEach((ele) =&gt; {ele.style.backgroundColor = '#0000ff'}); evt.target.style.backgroundColor = '#ff9900'; } [].slice.apply(document.querySelectorAll('.btn')).forEach((ele) =&gt;{ ele.addEventListener('click', fn) });
Yes, this is the way to go. There may be cases where you need to look up a function with a string, but 99% of the time it means you are Doing It Wrong. To actually do it, you can: function foo(){console.log("foo")}; this["foo"](); But don't do this..
Quick search shows that Spider is no longer developed.
I'm not very experienced so I didn't think of function references. I don't want to forEach because I want to break if a function returns false. Thanks for post
There are two ways to use it - the first is with cordova (which isn't suitable for your needs). You can also use it as a replacement for the native webview while keeping the rest of your app as it is - https://crosswalk-project.org/documentation/android/embedding_crosswalk.html
Good stuff! Thanks man.
I think one of my takeaways with this benchmark is that Virtual DOM is not a guarantee of better performance. I'm still very curious to see how the results change when Vue2 hits, if Virtual DOM makes an impact or if it's a relatively minor gain. My guess is it probably varies by browser. Chrome might have a very fast DOM compared to the others?
Same here I'm working on [Crafter.js](https://github.com/SaulDoesCode/Crafter.js) and building some demos. I always try to find gaps so I can add to it..
There are alternatives which I think should have be used instead. I don't think fall through should be the default behavior. Rather, it should be the special case that requires extra syntax. Fall through isn't what you want most of the time. For example. Look at how pattern matching is done in rust.
Anytime!
Thank you! code makes perfect sense, but I am having a small problem, I dont know how to implement it in my code., do I replace the clickHighlight or some sort? hehe Updated code: https://jsfiddle.net/kne4chds/6/ *I removed the clickHighlight function since I thought that the for loop replaces it
I think the one this got right is TypeScript but that's about it :) - TypeScript - Elm - PureScript - ClojureScript OK, I might be biased towards functional, but honestly CoffeeScript's good features are in ES6, and at least I'm not aware of any other actually good ones besides TypeScript.
[removed]
There are multiple "benchmarks" that pretty much show the same thing over and over. React is better than most frameworks of old, but isn't faster nor lighter than many of the new. There's the variety of dbmonster, http://vdom-benchmark.github.io/vdom-benchmark/, https://localvoid.github.io/uibench/, and the older https://rabbots.github.io/todomvc-perf/
According to the numbers posted, he's boasting some serious gains in both size and performance. Even if performance remained the same and the size was halved the argument only becomes stronger. Fast enough only exists if people basically see no load as every 100ms is felt by your users and for places like Amazon that translates into money lost.
Thank you, I updated the code but it dosent seem to function, I think I implemented it incorrectly updated code: https://jsfiddle.net/kne4chds/5/ *I removed the clickHighlight function since I thought that the for-in loop replaces it
Good point!
Almost everyone does it. Yes I agree. That doesn't make it a particularly good design decision. If you are looking for languages that don't fall through. Perl, Pascal, Fortran, Basic. C# has limited fall through. You can only fall through in C# if the statement is otherwise empty. Either way, my point is that fall through is rarely desired, so it shouldn't be default behavior. Its the whole "falling into the pit of success" thing.
&gt; larger React ecosystem To add to your point: …a larger anything is not necessarily a good thing. In PHP/JavaScript, they have a low barrier of entry to write *functional* code, but to write well-tested, well-performing code? I'll take smaller over "here's fifteen plugins that do the same thing, now spend hours figuring out which one is actually good."
I read this article yesterday and found it to be very thorough and *generally* well written... I'm very confused by this though: get content() { return ( &lt;Router history={this.props.history} /&gt; ) } render() { return ( &lt;div style=\{\{ height: '100%' \}\}&gt; {this.content} &lt;/div&gt; ) } ~~1) why is the `style` prop written with escapes like that??~~ 2) Why is `router` inside a div, and not wrapping an app like "normal" 3) What is the advantage of having a class function that returns a router component? All of these things seem like strange indirection to me. EDIT: looks like the escapes were mediums fault https://github.com/fullstackio/yelp-clone/blob/master/src/containers/App/App.js#L24
This is just the simplified version of what I'm actually working on. Thank you very much! You really helped me out in understanding this!!
It's not just "use production mode". It's also learning about `shouldComponentUpdate`, immutable.js, how they come together and why, to begin with. Before that, there's also the JSX setup (because the in-browser JSX transformer is good for tutorials but not meant for production). By comparison, in Vue, you can just put down a `&lt;script src="vue.js"&gt; and be pretty much done w/ a performant, production-quality setup.
Hi we're actually serving the web app over the network so that isn't the issue. I think you may be right about local storage, it might need to be enabled or something, I came across that whilst searching.
Ah, indeed! http://stackoverflow.com/questions/5899087/android-webview-localstorage
&gt; compared to raw Knockout But that's what I love about KO. You can literally make it do whatever you want. It even plays pretty nicely with Javascript/jQuery plugins via custom bindings. Admittedly, I've never used React, so I'll have to give that a go sometime soon.
You're never going to use hard-coded numbers in a comparison like this. (x &gt; y) &amp;&amp; (y &gt; z) (z &lt; x) &amp;&amp; (x &lt; y) This would be a far better way to write something like this. It's easy to reason about. It isn't purposely trying to confuse anyone. 
Hi /u/dr_jerry, does iPath have a project home page? I see there is a github repo, but it looks like the repo for a website and not the project itself.
We've finally released angular 2 version of our beloved Blur Admin. We hope you'll like it and we would be happy to discuss anything about the template :)
You're apparently not freed from Javascript if you want to access the DOM. At the moment, you apparently need a layer as a bridge between the worlds. There's talk of that *maybe* changing, but it seems very tentative.
http://exploringjs.com/es6/ or anything else written by Axel, as he's basically _the_ authority for the new features. http://www.2ality.com/
There have been several times where I've refreshed my browser over and over and over again trying to test some code or CSS I just wrote only to realize that I'm on a deployed test environment or even on a production version of the app and not my localhost.
Style is a props, and it gets evaluated for the DOM diffing algorithm. If it were text, you would have to parse the text, transform to CSS, then do a diff to see what changed. An object is easier to compare and update. It also gives you the possibility to merge in-line styles and do some JS transformation on it. What I suggest though, is to put them in a variable instead of inlining it like that. I find it easier to read. 
Seeimg how angular 2 also advocates immutables, i guess Angular 2 fans will say the same when it's benchmarks will release (after 2.0 obviously). In react world, it seems devs are moving to mobx which is kinda like vue's reactive system but view layer agnostic.
this.
maybe not dumbest thing I've ever done, the other day I had react components with check boxes, and watch attaching my prop to "value" and not "checked" The UI would update and so would the state but refreshes got weird. took me like 40 mins to figure out. 
Thanks for the mention! * ES6 (ES2015): http://exploringjs.com/es6/ch_overviews.html * ES2016: https://leanpub.com/exploring-es2016-es2017/read * ES2017: http://www.2ality.com/2016/02/ecmascript-2017.html
three js and datgui are what you are going to want. I had a working starting point demo project, but it is quite out of date. I just tried building it and all my dependancies are fucked. I can link you the source if you want to take a look, but Im sure some googling will find you some good resources.
~2 hours debugging a JS file not working. I had turned off JS via Chrome Dev Tools.
Not too sure if troll or not.. img[src="tupac.png"]:hover { cursor:pointer; } This CSS Rule causes your mouse-pointer to become a cursor. 
Things: 1. this has doesn't really have anything to do with javascript 2. your formatting is fucked up 3. your description of the problem is vague at best That aside, the relevant line appears to be this one: img[src="tupac.png"]:hover { cursor:pointer; } I'm guessing that you want all images to be affected, so you need to remove the `[src="tupac.png"]` part. Final result: img:hover { cursor:pointer; } if that's doesn't fix it, or if you don't want all images to change the cursor, adding a class to the elements would be better. HTML: &lt;img src="tupac.png" class="clickable" width="600" height="420" alt="" onclick="playSong()"/&gt; CSS: .clickable:hover { cursor: pointer; }
Umm, howabout adding a class to img you want the hover effect on? just call it something like img-hover. Then on your css call .img-hover:hover {cursor: pointer;} Also this isn't even remotely related to javascript... I don't really even understand what you wanted, is the cursor not changing or the song not playing? Maybe post something like a jsfiddle?
I know what it is, but there's no point in making it a prop in *that* situation, since it's never going to change. Putting it in real html instead would be just as easy to read and less taxing on the CPU when rendering the element.
It isn't a problem with reading documentation. It is easy to accidentally forget to add a "break;" to a switch statement. Further, nothing tells you that you have done something wrong. It will compile well, run well, and may even be nearly unnoticeable depending on what it falls through to. What I'm arguing for is making programming languages that make doing the right thing easy and the wrong thing hard. It should be easy to not fall through, because that is generally what you want. It should be harder to fall through because you generally don't want that. The language should be designed such that the right thing to do is the easiest thing to do. It shouldn't be designed with "Well, idiot, you should have just read the documentation!" in mind.
&gt; You would never gitignore the dist folder. Er, wait, what? Why would you want to check in the compiled build artifacts?
It looks like the elements do not exists.
So what do I do?
use `some` instead then.
Couldnt they just make native bindings instead of making whole C++ code? It seems like a waste of time by developing a wheel
&gt; WebAssembly is sufficiently low-level compared to JavaScript, we could really call it compilation. &gt; *And the best part—it’s not being designed in 10 days!* So javascript was designed in 10 days eh &gt; For one, it’s memory safe, which means you can’t crash your computer just by going to some website with an allocation bug. Wtf!! That has never happened to me... I think if start messing with garbage collection it would probably
Nothing wrong with angular for bootstrapping an app fast. 
I once changed my local dev app to use the minified production scripts to test if everything was working before deploying. Came back to it later spent a good 15min randomly editing things and restarting the server and could not understand why my changes were not visible. Forgot to switch back to the non minified ones, I my head I was convinced Apache or something was seriously messed up. 
I can push stylish through the google apps admin console, but I don't think I can apply settings to it. That's why I want to have it all in one addin. Also that's sort of what I'm doing already: var elements = document.getElementsByClassName("docs-reference-pane-container"); elements = elements.length ? elements : [elements]; for (var index = 0; index &lt; elements.length; index++) { elements[index].style.display = 'none'; }
You could create a style node in js that is injected into the page. var head = document.querySelector("head"); var node = document.creatElement("style"); node.innerText = ".picker {display: none}"; head.appendChild(node);
I once spent a little over half the workday debugging about 30 fairly straightforward lines of JS that were blowing up IE8... only to finally spot the trailing comma in an object declaration. Not my finest hour :/
I'm pretty sure there's no way to do that in templates alone with Mustache. However, if you're in control of where the template is rendered, or at least to the data supplied to the render call, you can add a callback to the data which can get you what you want. Then, instead of mustache rendering a value, it will call your function with a context equivalent to `{{.}}`. Then you can have that function return the value in your pseudo expression up there. Hode up, I'll throw a fiddle together... https://jsfiddle.net/5hnfxgge/
It's the 750e. I also have an indoor camera but both models use the same protocol. I'll read into the doc more. I got so far as to get the discovery info last week but was stuck there. The document you linked extends that info. Thanks!
Depends on the team/project within Microsoft you are interviewing. Each team handles interviews differently and the workload might be different. Some teams might expect you to know more computer science concepts, some not. Sorry for not really answering your question but I am not sure this is a question that can be answered.
What I do is have a `dist` or `production` folder (or something similar) and then replace the the `&lt;script&gt;` and `&lt;link&gt;` tags automatically on build. If you are using Gulp there are a number of packages that help you with that. Or you can do an old node string replace. Another thing I do, is whenever I build for production, I don't name the files `build.js` or `build.css`. Instead I use a timestamp to be sure everyone will load the latest version. Eg: `1457498671178.js`
Sure, but how long does your `npm install` take on a fresh clone? That's more likely to be the bottleneck on a deploy.
its obfuscated code that has ben transfomed in order to be inreadable. jsbeautifier would be a useful tool to make it at least readable http://jsbeautifier.org/ the arguments themselfs then are thenselves altering itself/ and also contain code. but it looks like there is some code missing, becuase its not valid. the arguemnt that is meant to call the ananomys function does not terminate. it does not close the single quote nor the paranthese. the function with the arguments named packed takes up to 6 params, but not even once is declared properly. Thats why its not possible to reverse the code correctly. I assume you c&amp;p not everything. In case you have the remaining piece transform it step by step back, that means remove the inner function of packed that would then unpack the code for the next step. from my current position i cannot judge how deep this is gonna be, but after you feel comfortable enough xou still can execute it in an encapsulated environment. 
I'd suggest something like this: dogbook/ build/ yugebundle.js yugebundle.css app/ img/ ... areas/ home/ home.logic.js home.view.html components/ dogbone/ dogbone.logic.js dogbone.view.html dogbone.spec.js dogbone.styles.css services/ search.logic.js search.spec.js `src` and `dist` are common names, but I also see `app` and some others around a lot. This structure is pretty agnostic to framework of your choosing, and has worked well with me since the knockout days all the way up now to html-less react/mithril. The thing about using webpack is you can fold pretty much everything into your bundles - js, css, html, even json or really whatever you need. This would leave your index file to be pretty anemic. I would say you should usually gitignore your build artifacts.
I think I get what you mean. JQuery was a glue that was used to keep apps together. And now React is a glue that can be used to keep apps together. And as a framework for building apps, which is its intent, it's great at it.
Thank you! one last question, what is the purpose of the [i] in var child = this.childNodes[ i ];? wouldnt only this.childNodes grab all the child names? I might be mixing it up with somehting
&gt; So javascript was designed in 10 days eh [A Short History of JavaScript \(w3.org\)](https://www.w3.org/community/webed/wiki/A_Short_History_of_JavaScript) Actually designed / developed in 10 days, but yes.
wow good job man! Thanks thats exactly what I was looking for, I knew his ID would have had to been in there somewhere! 
Thank you so much!
Most deployment servers cache packages they already have, but yes it might take a while.
`weasel = "E";` Classic 
No worries, glad that helped! You might wanna check those other scripts on Github to see if there's any other IDs, then ban them/report to Steam/etc.
Maybe my project will help you https://github.com/rofrol/css-accordion
kind of confused, why is 'answer' an array containing an array of individual elements? why not just an array of elements? I feel like what you're trying to do is this: Given an array of integers i.e. [1,1,1,2,2,3,4,5] , find out if this array contains a sequence of elements that match the following array [3,4,5]. In this cause it would return true. Is this what you are trying to answer?
Looks more like a desktop environment / window manager to me.
&gt; users can experience the Progressive Web App when reading a Post AMP article and clicking through to the PWA link when it appears in the menu. The URL linked from this post is a Progressive Web App. The Post is indeed using AMP as well. For example, here is a link to an AMP page: https://www.washingtonpost.com/amphtml/politics/while-the-culture-wars-rage-trump-largely-stays-out-of-the-fight/2016/05/27/6e89a62a-238b-11e6-9e7f-57890b612299_story.html As the article you linked to suggests, there is a hamburger menu on the top left. If you click that, there is a link to "Progressive Web App". That loads a new page. AMP pages are very simple, and are architecturally incompatible with implementing a PWA. Apologies it I came off like a jerk. These are two very different things though: * https://www.ampproject.org/ * https://developers.google.com/web/progressive-web-apps/ And run by different teams at Google with different end goals. The Post just happens to use both.
I didn't downvote you. What peaked your interest in doing something like this?
This is a jQuery accordion I wrote that is very basic. If you know JavaScript it is easy to implement. It toggles classes. Animation styles are CSS3. http://codepen.io/JBreit/pen/uLilg/
I'm relatively new to task runners/pipelines, so sorry in advance for the noob question: What advantages does webpack have over Gulp? Seems like it's less feature-full and requires a more verbose config setup to me.
I use flask and usually have a "static" folder for all the html, but otherwise exactly as you've done.
I saw an algorithms and data structures with JavaScript orielly book on safari. May be worth a read?
Could please show the html?
&gt; However, only the most novice of software engineers or super fanboys of his will pay for that. It's businesses, generally. Consider an engineer in NYC, SF, LA or wherever is probably $10-20K per month all-in cost - even if their training budget is a tiny portion of that, it still adds up. This is why there are tons of high priced conferences doing okay as well. It's partly true in London though at a much lesser scale because British developers are grossly underpaid. (Though doing a workshop with Uncle Bob in London, say, is still about £2K.)
you've probably figured it out by now, but the error tells exactly what is happening and where an element with an id of BitcoinSec does not exist. if you want the code above to work, it needs to exist. you either need to add that id to some element, check your spelling, or create an element that id
No, angular 1.x is the most popular. If Angular 2 was improvement upon angular 1, then you would be correct. but angular 2 is so different, it is not far fetched to believe that angular 1 devs will move to react or aurelia instead of angular 2. &gt;the fact that their are so many libraries and so many frameworks is not good for developers why their are 20 libraries and frameworks that all make the same apps but take weeks to understand individually is beyond me. Because the One True Path has yet to become mainstream. angular 1 could have become OTP but angular 2 destroyed devs faith 
It is like a virus... with a white hat xD
This use case is pretty viable for scripting language though.
&gt; For one, it’s memory safe, which means you can’t crash your computer just by going to some website with an allocation bug. That stuff does happen. It won't happen on basic websites, but complex stuff (3d games) or benchmarks can crash browser.
&gt; Can anyone tell me why I'm not able to get the items to display according the javascript that I've included in this code pen link?? A couple of reasons: 1. You're referring to a variable called `snack`, but you're never defining it. Check console for errors such as `"Uncaught ReferenceError: snack is not defined"`. I'm going to assume that you want to bind the listener to all elements with the classname `"snack"`, in which case the code should look like this: var snackElms = document.getElementsByClassName("snack"); for (var i = 0; i &lt; snackElms.length; ++i) { snackElms[i].addEventListener("click", function(){ // ... } } Or if you're allowed to use jQuery: $(".snack").on("click", function(){ // ... }); 2. Inside the listener, you're referring to a variable called `content`, but you're never defining it. Check console for errors such as `"Uncaught ReferenceError: content is not defined"`. I'm going to assume that you want to target the element that is the next sibling to the clicked `.snack`, in which case you should use [`.nextElementSibling`](https://developer.mozilla.org/en-US/docs/Web/API/NonDocumentTypeChildNode/nextElementSibling): var content = this.nextElementSibling; 3. Your CSS includes .content { ... display: none; } This hides the content, even when you set `content.style.display = ''` from your JS, since `.style` only changes the `style` attribute in your HTML/DOM. Change it to `content.style.display = 'initial'` so that it sets a value, overriding the one set in the CSS. 4. The initial click will still hide the content, even though it's already hidden by the CSS. This is because `.style` doesn't care about CSS, but only refers to the `style` attribute in your HTML/DOM. Instead, use [`window.getComputedStyle()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle) or add `style="display: none"` to your HTML instead of the CSS from 3. [All together now.](http://codepen.io/birjolaxew/pen/ZOEBGv) So to summarize: `.style` doesn't actually read/write all the styling that's applied to an element, but only the ones that are set through the `style=" "` attribute in your HTML/DOM - and you need to define variables before you use them.
Really good framework. You can be very productive with it, but it definitely has a learning curve. The grid and tree panel are arguably the best JavaScript components I've seen. Pros: * Very rich set of good looking and highly customizable components * Robust event and class subsystems * Strong data package, * Good documentation and tech support, * Lots of examples. Cons: * There's definitely a learning curve, * Licensing could have been more flexible.
Just wanted to share my portfolio which has gone live today. Any feedback is welcomed. http://danieldelcore.com/
I know... but he says it can crash your computer... maybe he meant just the browser
`run(..)` is a known quantity. It's already been solved many times by many popular libraries. It's exactly the same as you don't worry about the implementation details of a virtual DOM when using React. You just use a `run(..)` provided by any favorite lib (Q calls it `spawn(..)`, etc). Of course, if you want to understand how it works, you can inspect a fully commented version of it, which is why I linked to the version in that chapter. If you looked at a comment-free version, it's only about a dozen lines of code.
Sure, that sounds fine, too. The tax is not really the call-site including `run(..)`, but the fact that you have to include a lib with that dozen lines of code in it. You can tell from the post that my feeling on the tax is that it's not much.
You've made a large assumption about "extremely rare". If I felt it was going to be "extremely rare", or if that had been my experience, I wouldn't have written the post. YMMV.
I don't see **any** readability difference between gen-run (generators+promises) and async functions. The point of the post is that they're virtually identical. I'm not going to address arrow functions here. My ill feelings on them are well documented in my other writings.
Totally disagree this is "common sense". I think putting a free variable in an outer scope is a bad anti-pattern. It violates the important FP principle of pure functions to use a side-effect from inside a promise chain to share context across multiple inner functions.
We just converted our whole front end stack from requirejs, bower, and AMD, to webpack, npm, and es6. Loving it so far. One thing that bothered me was that I could load sass files with my modules but there wasnt a way to easily define variables for the sass modules which I could "overwrite" for skinning purposes with my project specific variables (let's say we want to have some base styles so we can have a nice looking UI without a specific skin, but also don't feel like overriding dozens of selectors with one sass file towards the end) So I wrote a preloader that will "inject" an import to our app specific vars, right after the var declarations at the top of the sass file for the module. The preload determines the relative path to the global sass var file based on the loader context and injects the import statement in the right place And it works, the thing I find is nice about it is, that the module still works just fine stand alone since it relies on its own vars for its own style. The "override" only happens at bundle time, so it's totally optional for the project to specify one or not! Does anyone else think this idea is neat? Let me know
I still could not understand what `run` is doing, what problem it solves, and why it is needed. Not necessarily the implementation details, but rather a well-documented api description. Including the benefits it offers over other solutions. If it is well-known and included in many libraries, links would be appreciated. It is not meant as complaint, just a suggestion what can be improved to make it in par with the preceding part that I really loved. 
You don't need the data layer. Scrape the data with GTM and send it to a custom dimension in Analytics. 
* It's low barrier to entry - most people on the web are exactly one key-press away from a JS REPL, so if they want to start learning, where's the easiest place to start? "Download and install Python or Ruby and find a tutorial", or "press F12"? * It's accessible - weak, dynamic typing makes it easy to get started, and a flexible object system, first-class functions and support for procedural, OOP and functional programming styles makes it easy to keep using no matter what flavour of more advanced software development you tend to favour. Hell, with Typescript "JS" is even starting to stretch out to the static-typing crowd. * It's the scripting language of the web - the web is the most popular computing platform in the history of computing. If you want to develop for the web you more or less have to learn JS. Therefore everyone knows JS, so everyone *uses* JS, so JS slowly gets everywhere because it's the safest/lowest-common-denominator option. It's like the modern PHP or VB6 in that regard. * Availability of high-quality embeddable open-source JS runtimes like V8, Rhino, Spidermonkey and the like make it really, really easy (both technically and from a legality/IP perspective) to embed JS into applications and systems.
IIRC, The maximal part of maximally flat means that on conflicts, the least popular version will go into the node_modules directory of the package(s) requiring it. Unless I misunderstood what you meant by sub-dependency conflicts? 
&gt; I have no idea what this lib does Does mouse detecting to IE6/8 done right - at all, nothing so magical. And sends you few events. One when mouse is over given `element`, second when mouse is on this element, third when mouse is out of this area before `delay` ends; fourth `complete` event when mouse is on `element` for `delay` time. You can use it to create "kudos" like you can see in Svbtle (https://dcurt.is/unkudo see the end of the article for example). There's few others in the wild - https://github.com/masukomi/kudos, but it is shit, outdated and do too much. `tunnckoCore/kudos` let everything to you for free (okey, 3kb). I think the name and the few examples in the readme are enough to understand what is what, or okey, for that human that know what is kudo.
I just didn't knew what you meant by "kudos".
Links with javascript in their href attribute just can't be opened in a new tab, because they don't start a new page - they run on the current page.
I would love to hear more answers to this, also if people are using peer dependencies to ensure flattened frontend packages and what the rules are for that. It's unclear when to use dep vs peer dep. My scenario: my app uses React 14. I also use another library Foo which just released a new version that requires React 15. How do i prevent dupe Reacts? Ideally at the package management level? It would be pretty easy to scaffold a tool to manage version updates like this but really this should be a package manager feature like bower has. What i want is: I update Foo It asks me if i should also update React to 15 If yes: it updates that too If no: it asks if i want dupe reacts in my dependencies. If yes: business as usual If no: it prevents the package from being updated and tells me to contact the Foo author to release a version that works with 14. Or it identifies the last version of Foo that supports React 14 and gives me that as an option. This basic idea applies in pretty much all front end scenarios. We really dont want more than one copy of something referenced. There are edge case where it is ok, and npm can support than which is a strength, but those edge cases should be explicity allowed rather than implicitly. 
Fair enough, but I couldn't figure out roughly when Jscript was released, but I knew it let you interact with com objects. Plus I had no idea how much market share it had. I don't think jscript really had cross platform as an option either, given it was based on .net, which is one thing node.js can do. Also I had no idea Adobe made their own second life clone.
Hi /u/d3vc47, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Given a garbage collector that considers an object collectable only when that object is not referred to by any other, circular/cyclical references are problematic: function createCycle() { var parent = {}; var child = {}; parent.child = child; child.parent = parent; } createCycle(); After this function has returned, we have two objects that are no longer accessible (due to scope), yet neither can be garbage collected because each is referred to by the other -- Since child is referred to by parent, child cannot be collected; since parent is referred to by child, parent cannot be collected. There is no longer a way to reduce either's reference count to zero. Granted, that example is also contrived, but perhaps the general utility of a parent-child relationship makes it a little easier to see why such references might be created. As has been mentioned already, this scenario is not generally an issue for modern JavaScript GC.
&gt; Having a simple, readable and idiomatic way to write it almost all of the time is a huge win. Most of the time, you're going to write exactly the same kind of code in a gen-runner driven generator as in an async function. I showed several side-by-side comparisons of virtually identical code. The `async..await` syntax is limited to those, and the gen-runner pattern has more flexibility for the places you need it. Using syntactically/semantically limited tools just so you can constrain programming practice to a narrow subset is a common approach. But it's one I find suboptimal. I'd rather learn and use the smarter tool, and use it responsibly in all places. Your implication is that this will make code harder to debug, but that's a strawman argument. The code that doesn't need the extra power will look **identical** to the code using the simpler `async..await` tool (except `yield` vs `await`). No difference there at all in debugging. The code that needs more sophistication -- I assume this is a requirement because it has been for me, and I reject any "well, I just wouldn't do that" reductionism -- will be more complicated in **both** cases. There's no evidence presented that suggests that some promise+`async..await` approach to the types of use-cases I outlined would be any better than the `yield *` and smarter gen-runner utility. I accept you may not have need for these capabilities in your code, fine. But there *do* exist reasons for it. I'd rather use a better tool that lets me tackle those when they come up rather than go looking for another ad hoc solution if the situation arises.
regenerator is an entirely different story, since it's transformed code. And yes, I agree, that code *is* harder to debug. But the **exact same** code, and thus the same weird debugging, comes if you have to transpile `async..await` currently. The context of discussion here is when both generators and `async..await` are natively implemented, and thus you're not using any of that regenerator transpiled code. The debugging experience of a generator is going to be at least as good, if not better (because generators came several years earlier) than `async..await`.
Sorry, I didn't mean regenerator, I just meant async/await with generators, not the crazy state machine that regenerator does.
Oh I see. What many packages are doing is listing react as a peer dependency to get around this situation, and npm3 no longer installs peerDependencies (but will warn about uninstalled deps), leaving decisions like this to application authors.
Glad I could help :)
This link is a question I submitted to the OSI's mailing list. I wanted to repost it here because it's really mostly a question about Javascript minifiers. The question is: Do software licenses that require attribution when distributing source code apply to minified Javascript? And how can I be sure?
[Here's](https://repl.it/CWSE/2) a (hastily made) solution that runs through arr iteratively instead of randomly. Is there a reason this has to find them randomly? Also, regardless of whether or not randomness has to be preserved, I dont think this can be achieved with a single loop Edit: nvm about the single loop part, didn't realize you were making a recursive call on find()
Played around with mobx (in combination with React) today and *really* liked. I'll think of a little demo app tomorrow.
This video was really informative. I kind of wish your post had gotten more comments, I'd love to read a discussion on all of this; it's fascinating!!
You suggested implementing throttling inside your `run()` utility, if I understood correctly. &gt; What if, for the purposes of throttling resource usage, you needed to make sure that no more than one HTTP request/response was handled for each database request? Then I posed that if I wanted to throttle HTTP requests, I would also most likely have other asynchronous methods I would *not* want to throttle. Those un-throttled methods would need to go through a separate `run()` utility, or the original `run()` would need to accept parameters on creation / handle different yielded items and run differently based on those contexts (ie - disable or enable throttling). There's no strawman here. That is an entirely reasonable use case derived from your suggestions, and that's already too complicated, in my opinion. &gt; I've never seen a single example of anyone doing literally just await somePromise; just to pause while it finishes. How about CSP implemented with promises for flow control? await ch.put(3); Or deleting a record from a database? await db.delete('table', tableId); Saving a file to the filesystem? await fs.writeFile('filename', data); Asynchronous methods that utilize a callback which will only receive an error as an argument are common in node. The equivalent of those is a promise which does not resolve into a value.
It was going to be made a mobile game, so I never bothered adding them.
Released my first javascript plugin. Open to any feedback and suggestions on how I can improve :) 
yeah, something like phaser or three.js would be better.
yeah i figured as much, but it would be really simple. it made the game really difficult to play with a touch pad mouse. 
As a way to learn react and redux and node I built a platform to help resell sports tickets. Its basically craigslist for sports tickets, and using reddit as an auth. The idea being that you would be more likely to trust someone and buy their tickets if you know them from your favorite team's sub reddit. I've worked on it for 6 weeks so far, so please check it out. http://ticktra.de There aren't any actual listings, so feel free to try add tickets that you don't have so you can try it out, I will wipe my db before I officially "launch" I used this boilerplate as a starting point. https://github.com/choonkending/react-webpack-node It was everything I was looking for, and saved me having to wire it together. Saved me a lot of time, so I recommend it for anyone looking to build a serious application with react. I'd happy to answer any questions anyone may have. cheers. 
Haven't had the opportunity to fully play around with it yet. I think React Native "stole" quite a bit of NativeScript's potential for gaining developer interest, and it was left a bit in the shadow of RN's hype. But I'm mostly here to say: I'm interested in knowing more about this as well.
loved the things in the labs. I starred the first one. I am working on a three js project right now, and I will definitely be taking a look at that source this week. 
I had a horrendous experience with it back when it was first released. Basically none of the tooling actually worked (random JS errors), so that turned me away immediately. I actually prefer the idea of NativeScript over React Native, since you're using each platform's native APIs directly, but the tools need to actually work first if you want anyone to adopt them. I'm sure it's a much better experience now, but really I'm not happy with any of the cross-platform JS offerings at the moment. I still believe writing mobile apps with the native toolset is going to win out over any cross-platform tools, and I haven't been proven wrong yet.
I totally forgot about that! Appreciate it!
no screenshot :( 
Is there a way to make it like… not do that? If I'm picking the license myself.
Disclaimer, I might have some of this wrong... Gulp is a task runner. Many of these tasks could be ran with a npm script, things like minifying, concatenating files, running tests, and deploying, basically running different tasks. It doesn't support modules out of the box, but with Browserify it brings Node modules to the browser, allowing you to require/import things. Webpack does all that and more, it doesn't need Browserify to bundle modules. It also supports hot module reloading with webpack-dev-server. It has many loaders available that allow for a bunch of cool features to be chained. You can use a CSS preprocessor, minify, and then concatenate files just like Gulp, but then you can use other loaders to import the CSS file into your JS file and have it create a scoped CSS module (you can still make a global stylesheet) and write a script tag into your HTML file for you. You can even do crazy things like import a picture into your JS file and use it as a variable for a source. Webpack also supports multiple modules, so you can separate things in a larger app. Webpack can require a more verbose set up, but is pretty powerful once it is set up.
I've never understood the implication that if your build process doesn't involve transpiling code through at least 2 different languages you're somehow behind the times.
Thanks! I'm glad they're useful to you! 
To be valuable, it needs to work in reverse - storing state in an HTML attribute lets us select HTML elements by their state: $(element[attr='val']). Moving state into a plugin and associated objects removes that option.... what do you have in mind to replace it?
It doesn't, it is an ES6 feature. I have created some [string replace](https://github.com/FagnerMartinsBrack/str-replace) code sometime ago that can help in replacing stuff in ES5, but if your use case can be solved using Template Strings, then do it, it's worth.
You can gitignore specific directories, like: dist/js dist/css You can also whitelist on an ignore with `!`: dist/ !dist/index.html Don't base your folder structure on gitignore, ~everything is possible I mainly use the `src` and `dst` pattern, ignoring dst and only keeping source files in my version control. Anything generated file shouldn't be in your version control, unless you have a specific need for it.
Seems to be just fine, Vue looks a lot like how I write my Routing using the [Vanilla Framework](http://vanilla-js.com). But one thing you could do to make the Templates more readable is to either use [Template Literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) or enclose the strings via '' on the outside and "" around classes: Template literal which uses ` instead of normal '' or "": var dailyDeal = { what: "a thing", picture: "https://somethin.com", price: "$84", itemUdid: "hexHash" } const DealTag = Vue.extend({ template: `&lt;div class="daily-deal-box"&gt; &lt;div class="heading"&gt; &lt;h3 class="in-line"&gt;${dailyDeal.what}&lt;/h3&gt; &lt;span&gt;${dailyDeal.price}&lt;/span&gt; &lt;img src="${dailyDeal.picture}"&gt; &lt;div class="foot"&gt; &lt;button&gt;Check It Out!&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;`; }); You see that way you can write indented HTML like it's in HTML, so if you want to add an element you know what scope it's in. 
Send your questions to the guy in the video. Very high chance he'll reply to you.
I didn't know about template literals. That definitely looks more readable. Thanks! 
**Whoops!** I forgot template literals are ES5 feature. Anyways you could do the same either with '' and + or in an array like: const DealTag = Vue.extend({ template: [ '&lt;div class="daily-deal-box"&gt;', '&lt;div class="heading"&gt;', '&lt;h3 class="in-line"&gt;',dailyDeal.what,'&lt;/h3&gt;', '&lt;span&gt;',dailyDeal.price,'&lt;/span&gt;', '&lt;img src="',dailyDeal.picture,'"&gt;', '&lt;div class="foot"&gt;', '&lt;button&gt;Check It Out!&lt;/button&gt;', '&lt;/div&gt;' '&lt;/div&gt;' ].join(''); });
wait make sure you see my reply because I forgot it's an ES6 feature. And to do the same in ES5 would require string replacement.
The theory is you access the object's property using the getter/setter and not the actual property but when dealing with an object literal like this, both the property and the getter/setter functions are available to the calling code and you've named them the same so when you're referencing person.name you are referencing both the internal value and the getter/setters.
The key insight is that what matters is that you can't have a data property and an accessor property with the same name, but I should mention that the underscore character does have a use in certain nonstandard parts of certain JS engines. --- The nonstandard object prototype methods `__defineGetter__`, `__defineSetter__`, `__lookupGetter__`, and `__lookupSetter__` are used in most non-IE browsers from before ES5 to define and retrieve getters and setters; they were created by Mozilla, and then Opera and Safari implemented them for compatibility, and then Chrome has had them from the start, and IE started supporting them in version 11. It's possible to use these non-standard methods in part of a robust polyfill for `Object.defineProperty` and for `Object.getOwnPropertyDescriptor`. --- Other dunder-delimited engine-internal things include `__proto__` for accessing an object's `[[Prototype]]` property (which is widely implemented, now described in an annex to ES6, and usable in part of a robust polyfill for `Object.create`) and the object prototype method `__noSuchMethod__`, which was only ever implemented in Firefox and was removed in Firefox 43 (it specified a function to run in case an attempt is made to call a method that a particular object doesn't have, and now this can be done in ES6 by wrapping the object in a `Proxy`); I believe the double-underscore convention came from its use in C and C++, and not from its use in Python.
Presumably, your app updates the *real* DOM at some point. So you can use Selenium to test that.
Yeah that's pretty much where I was going with that one. Most of the current tools aim for the write once, run anywhere approach, which doesn't really work in the long run. Really, if there was some kind of project to share business logic between apps, but keep all the UI code native, then that would be ideal. I kinda figured NativeScript would be exactly that, but it looks like they're mainly pushing their cross-platform UI kit as the primary way to build NS apps, kinda like Xamarin and their XAML-based UI kit, which unfortunately leads to a lowest common denominator UI. 
I've been keeping an eye on MobX for a couple point releases now, but haven't had a chance to try it out on a real app yet. I've been working on a large app with some state management issues, and I really think something like MobX will help a great deal. These new features are making me want to get on that even more.
The URL needs to be shareable which is why the ID needs to be part of the location. The reason I'm trying to do it this way is to avoid someone bookmarking the URL and getting the same ID forever. I'll try to figure something out with your suggestions, thanks. I also could just have a shareable link that's not the same as the URL like normal people but I like to do things the hard way.
Even if you agree/disagree, I think it's a worthwhile read to consider this perspective. Yes, you can have more control with a custom `runner()`, but that also incurs its own technical debt if you are working in a team. `async/await` just works. 
[which-cam](https://github.com/hemanth/which-cam) was used to click this pic?
Try using `history.pushState({}, '', '#foo');`?
It makes sense, thanks for explaining.
I wonder how that would be if one compares to the 90's
That's correct. I want to learn how to code javascript, and I like to do it with concrete examples. That way it's easier for me to see, what everything does. So I would like to make a bot, that would do certain things for me in the game [TrainStation](https://portal.pixelfederation.com/da/trainstation/#) by Pixel Federation. Things like dispatching trains, setting up flags etc. But I'm not sure how to find the source code where all the key elements are named, how to write the code (that's probably easy to find a tutorial on) and how to execute it in the browser.
Perhaps a link would help for those who have no idea what `co` is: https://github.com/tj/co
It is good. That means you are making individual progress and not dragged by the comfort zone. Not rewriting everything means that you making progress in understading and a
I created a program that can be used to procedurally generate rocks in WebGL: https://github.com/Erkaman/gl-rock
[Jasmine](https://jasmine.github.io/2.4/introduction.html) is great for verifying that the functions you write do what they're supposed to. You can also use it to imitate user interactions; you just have to assume that you've set up event handlers and the like on buttons, form elements, etc. correctly. In order to test that the actual interface elements do what you want, you can use a tool like [PhantomJS](http://phantomjs.org/) to simulate a user interacting with the site (hence the "headless"). This would open a browser and perform whatever actions you specify, and you could [use it in conjunction with a testing framework](http://phantomjs.org/headless-testing.html) like Jasmine to run your actual unit tests.
Oh its this fucking guy again.
Typically, it's event handlers which don't get removed and reference your Dom node so they dont get GC'ed.
wow. Thank you so much.
Like how? Do you have a quick example? 
&gt; To be valuable, it needs to work in reverse - storing state in an HTML attribute lets us select HTML elements by their state: $(element[attr='val']). &gt; Moving state into a plugin and associated objects removes that option.... what do you have in mind to replace it? https://github.com/meowsus/jquery-state/issues/1#issuecomment-222364634
The other answer uses syntax I've never seen before. (It makes sense, I've just never seen anyone do it that way.) I think this is a lot more normal, and you can do more than one without overwriting what's already there. newTextUser.style.color = data.color;
I totally forgot that selenium was the web driver I used with PhantomJS. Thanks for making that clarification.
Is this the same as making a example.js file with the script: const PI = 3.141593; console.log(PI&gt;3); and running 'node example.js' in the terminal?