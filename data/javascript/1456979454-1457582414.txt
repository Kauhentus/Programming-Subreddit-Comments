Question: Where are there tests?
5.7 definitely has arrow functions. Try adding `--harmony-destructuring`. I think destructuring and default parameters are landing in the next update (V8 v49).
One big, important advantage is testability. The more testable your code is, generally speaking, the better. Automated testing, obviously facilitated by highly testable code and well-written tests, helps ensure that you're developing quality code and can significantly improve maintainability.
Yea that's the thing with knockout I find -- granted I'm not the best with it, but I find whenever I work with it I need to wrestle to get it to work the way I want and read through their... verbose... documentation. I mean, I had to idea `ko.isObservable`existed.... there is no page on their site that describes all of these things. so, I was working on this legacy project using knockout and tearing my hair out with weird questions like these, "what is observable here?" what isn't? why is it so difficult to have a form that adds items to a table and get all the data for a post to the server later?" I switched it to angular, which I'm far more familiar with, and it took me maybe 15 minutes to get the thing working like I expected... Anyway, that's my two cents worth -- back to your particular problem: &gt;I thought about that but the text input correctly updates the observable when I originally had it as just a text input. I'm not sure why this is... I have a hard time thinking what would happen if you used data-bind with a regular properly -- maybe it just updates the property 1-way? But if you set the observable yourself I don't imagine the value of the input element would change. &gt; how would I set the properties from the API call? You can assign each property manually, or use the knockout mapping plugin, I think, to do this. (you may want to look this up, I'm a bit rusty on it ... this may or may not work): function PickViewModel () { self.newPick = ko.mapping.fromJS({MatchTime: null}); self.pick = ko.mapping.fromJS({MatchTime: null}); self.setPick = function () { var data = ko.mapping.toJS(self.newPick); ko.mapping.fromJS(data, self.pick); } } Check out : http://knockoutjs.com/documentation/plugins-mapping.html for more details on that. Again, knockout seems like a bit of black magic for me -- I find angular to be far more intuitive and I realize it might not be completely appropriate to say 'just pick another tech' if it was my project I'd do it in a heartbeat.
What /u/rabidbunnygopoop said is true, but please, don't waste your time building a DI framework. Just use one.
This is true, but DI is just one way to create unit-testable code. 
With the framework-happy nature of JavaScript these days, I dare say that they're better off *reading* code than writing code in this space. But, yes, learning opportunities abound when you write it yourself.
Have you got a good tutorial for getting started with Relay/GraphQL? Should I learn Relay and GraphQL over Redux if I'm just starting out and don't know either? I've heard people say Relay/GraphQL is the future and is needed at scale, but might be overkill for the tiny project that I'll be working on.
There are so many existing options already. Instead of asking if you should, you should ask what you'll do better. If you can't come up with reasons for it to begin with, it's probably not the right subject for a serious project. Now, for learning, it sounds like a great project. There should be sufficient blog posts and such on both sides of the DI fence. My personal top reason though is the testability it adds. Unit testing is not the same without it.
see for example: https://esdiscuss.org/topic/having-a-non-enumerable-array-prototype-contains-may-not-be-web-compatible
I would separate your files from 3rd party libraries by putting 3rd party resources into /vendor instead of /js. Makes it easy to tell what is yours versus theirs.
Are you familiar with basic web apps (express), javascript compilers (webpack), and task managers (gulp)? If your project is serious, iterating with the tools you know and gradually adding complexity tends to be a more pleasant and productive experience. If you mostly want to learn Relay/GraphQL or Flux (Redux), Relay/GraphQL is a very clear winner by my experience. Flux's concepts are easier to grasp which I think is why it gets more attention. Relay/GraphQL takes some mental chewing, but is more expressive, performant, modular, and extendable. It's a fantastic way to colocate components with the data they use. With Relay, user-interactions that cause data mutations are amazingly patterned, encapsulated, and complete. The optimistic response API let's the browser update instantly and magically resolves syncing with backend response. I'd say take a look at the Relay/GraphQL examples: [webpack-express](https://github.com/christianalfoni/webpack-express-boilerplate) [relay examples](https://github.com/facebook/relay/tree/master/examples) [relay-skeleton](https://github.com/fortruce/relay-skeleton) [relay docs](https://facebook.github.io/relay/) [graphql docs](http://graphql.org/) 
Express is "dying" but honestly, it's working fine and is depended on by a lot of major projects. It'll continue on with or without Doug Wilson. Koa is a great alternative but it can be annoying having to pull in a bunch of plugins when I sometimes wish it just worked out of the box. I still can't get koa-router to work consistently across different projects.
Or for that matter, [lazy.js](http://danieltao.com/lazy.js/) for a (usually) more performant solution.
Tease...
Thanks for the heads up, I used to sub but I might have to come back and check it out.
How long had code school been paid for? Thought it was free
You are acting slighly unreasonable here. You may be right, or you may be wrong. I'm kind of surprised you use gossip and speculation to defend react - it starts to be emotional here. I'd like to discuss the facts, not "what if", facts are that there was a very bad relatiation clause, and now its better - but it doesn't mean it doesnt have risks. And ofcourse I can't point to a patent - it might or might not exist at all (I think if you deliberately look for patent it might get you into trouble, US patent system is weird). But it doesn't mean there isn't any risk, and the fact that someone told you they are unaware of problems doesn't mean the issue is clear. Ideally the best option would be for an actual lawyer to comment on that and explan the possible ramifications. As for Google, I have no idea what is the current state of things, but I don't think I saw a project using react. 
Right, but does it have the same big ecosystem around it? I think there is plenty of options nowdays.
afaik all the time, but they have few free courses(like Angular.js)
&gt; Don't use lodash and underscore on the same website. This isn't always your choice. As a library developer, if we modified prototypes in the same way you're suggesting, and another library does the same, you run the risk that we install different versions with different API contracts, and different behaviours. This *IS* the problem we've had in the past with different libraries adding things like `String.prototype.trim`and people expecting it to be the one they added, and work like the one they added. Then eventually it gets added to the standards and they may choose to implement it differently. Then you either overwrite it, and people using your library get messed up because they're expecting the standard trim function. Or you notice it's defined, and don't overwrite it, but then your library was written to work with a different implementation. Also, you're not adding much by putting them on the Object namespace.
Man, you really don't want these same people building stuff in something like React. If they write bad Angular applications, imagine when they get their hands on something a little less opinionated. I used to love Backbone in the day for it's freedom of choice, and flexibility. Until I started seeing custom everything. I'm starting to see the same in the React world. Then again, bad software is being written by bad engineers in many projects regardless of language, framework, library choice, etc.
10 in binary is 2 in base 10 01 in binary is 1 in base 10 not sure what you mean.
Heavyweight? I think you might be misinformed. https://twitter.com/rob_dodson/status/695706320452726784 Btw. I was looking into riot, I wonder why it can be so lightweight compared to react. Something must be omitted to archieve that? " riotjs is actually the reason I sent out these tweets. They say on their site we're 183kb, that's just wrong." ;-) I think polymer and react are similar in size.
Yes, only briefly but from what I've seen it is very promising. A Next Gen JS framework that just makes sense. It is what Angular 2 was supposed to be. No crazy syntax, everything just makes sense. It is a framework worth investing time in.
It's like Browserify, but on steroids. You have loaders that automatically process files for you without having to explicitly import the necessary models (webpack does this for you). In addition, it offers hot module replacement (HMR), which makes development easier. If you change css, for example, it automatically updates the document. No refresh needed (though changes to things like the script will automatically trigger a reload).
First check out what is closures http://shamansir.github.io/JavaScript-Garden/en/#function.closures Then change your code to var list2 = document.querySelectorAll('.list2 li'), clickHandler = function () { console.log('My index:', this.index)}; Array.from(list2).forEach(function(elem, index){ elem.addEventListener('click', {handleEvent: clickHandler, index: index}, false); }); Hope this help
&gt; I'm kind of surprised you use gossip and speculation to defend react - it starts to be emotional here. You're the one who citing rumours; I'm the one asking you for any references. &gt; I'd like to discuss the facts, not "what if", facts are that there was a very bad relatiation clause, and now its better - but it doesn't mean it doesnt have risks. It also doesn't mean it *does* have risks, compared to not having the grant at all. Let's focus on facts, not gossip and speculation. Why do you believe that React exposes you to a greater patent risk that Polymer? &gt; I think if you deliberately look for patent it might get you into trouble Kind of, yes. If you know of a patent that covers your code, you face greater penalties if you continue to infringe. In a very few cases it might make sense to purposefully stay ignorant of any patents as long as possible to delay the moment you need to start paying license fees or rewrite your code. &gt; Ideally the best option would be for an actual lawyer to comment on that and explan the possible ramifications. This is not complex, and a lawyer will not help you. If you use React and manage to get your license to Facebook's patents revoked, you're in the same position you would be with Polymer or Angular. *This is not a drawback to React; worst case all three projects are on an even footing.*
So you only have the weekend to complete any courses you want to complete? Or can you add them during the weekend to come back to it later? If the former, how much can be covered in a weekend? 
The idea is to offer a small free appetizer so that guests order the full meal, not to give away ones assets for free.
You're probably thinking of codeacademy
Gulp has better documentation lol. But really as a build tool gulp isn't completely necessary, a lot of what you can do you can do without the hoard of plugins that you have for gulp. Here's a great article on just reducing the dependecy (addiction) on gulp [Why I left Gulp and Grunt for NPM scripts](https://medium.freecodecamp.com/why-i-left-gulp-and-grunt-for-npm-scripts-3d6853dd22b8#.w6urdnr0i)
http://eloquentjavascript.net/ https://github.com/getify/You-Dont-Know-JS Here are two free online books (both can also be purchased in printed form) that are very well written and accurate. I would also highly encourage you to work with other people. Go to meetups or grab a friend from your class, and bounce your questions off each other. Getting started is really hard to do all by yourself. You probably know more than you think and just need to glue your bits of knowledge together.
The frontpage of their website says: &gt; We’ve reached 2 million students now learning at Code School, so to celebrate, we’re making all our content free this weekend! The pricing page on their website says: &gt; $ 29 Per Month/$ 290 Per Year If they really do have 2m paying students, they are turning over $58,000,000 (~£41,205,620) per month. In reality they may have fewer students than they claim: it is possible that they have bulk user deals for educational institutions. Nevertheless, this makes sense of Pluralsight's acquisition of codeschool for $36m last year. In fact, it seems like a no-brainer. It also goes some way to understanding how Pluralsight pay their top authors [millions of dollars a year](https://www.pluralsight.com/content/dam/pluralsight/pdfs/pressreleases/InterimLogo_Releases/Pluralsight%20Computer%20Programming%20Instructor%20Becomes%20Online%20Education's%20First%20Millionaire%20Teacher%20.pdf) (pdf press release). Teaching, it seems, is big business.
Is MIT considered libre? 
The sites real value comes in the online tests they provide between videos which to my knowledge are not downloadable. 
I just don't think anyone would do that. There are obviously no braces on if (true) act(); and I cannot think of a mindset where someone would think pressing enter and adding new statements without adding curlies is the way to go here. Would you? Honestly? This, on the other hand: if (true) act(); is more likely to cause errors and should never be allowed.
Yeesh, blocking all javascript that doesn't meet your ideological standards? 
Thanks for extensive answer. I am using a string as object key id (a hash) and the lookup is indeed fast, this is the most common lookup. But when I want to fetch all items by companyId a search through all is very slow.. like 50ms. How can I "index" by companyId at the same time as the item "id" hash?
 let k = 'hello'; ^^^ SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode at exports.runInThisContext (vm.js:53:16) at Module._compile (module.js:374:25) at Object.Module._extensions..js (module.js:417:10) at Module.load (module.js:344:32) at Function.Module._load (module.js:301:12) at Function.Module.runMain (module.js:442:10) at startup (node.js:136:18) at node.js:966:3 node 4.3.0
You are right real value is with the exercises and they are not downloadable. But the best to have without paying is to download just videos only :( 
In my experience, it's **far** more common to get bitten by things like missing commas than tag name typos. In Mithril, in particular, it's even less common to get tag name typos because in the most common case `m("div.someclass")` the tag name can be omitted altogether `m(".someclass")`. Speaking of Mithril, it also has no dependencies, and it gives you a pretty minimalistic set of tools (a virtual dom, ajax+promises, router and that's about it), and it can be used from a cdn without the need for webpack and friends, so maybe it's worth checking out.
1.5 can strongly delay the need for upgrading to 2 for a good while. Some of the new syntax is actually *less* verbose than ng2, and you can even approximate [stateless functional components](https://toddmotto.com/stateless-angular-components/) in 1.5.
Basically when you have an index in a SQL database, what the database does is create auxiliary data structures (similar to how I explained above), and it then maintains these data structures in sync. The trade-off of adding an index is that it takes more disk space (in the DB case) or memory (in your case), and added CPU costs on writes (because now you're writing to a table plus synchronizing the data structure for the index) So to have a fast companyId lookup, you'd create a second data structure that is keyed by companyId (in addition to the data structure keyed by id). You then need to ensure that both index data structures are in sync if you write back to the database. The cost profile of doing this is that the creation of this second index is going to be the slowest operation, running at O(n) one time upfront, and writes will have a little bit of extra overhead, but then lookups by companyId will be done in sub-linear time when you use the second data structure, since you already did the work of indexing by companyId upfront there. To conserve memory, the second data structure doesn't need to have a copy of the entire database row; it could just point to the id values, and then you could use the first data structure to do lookups by id
That's a really good point; I hadn't considered it.
404
I would argue that import is a form of DI. You're asking to use an interface without explicitly specifying it's implementation. Jest takes advantage of this and treats import like DI. Webpack seems to be a quintessential DI framework, as you can explicitely configure at fine and course grained levels where dependencies are provided from with loaders and plugins. You can change your depenency graph and behavior with configuration changes and no source code change, and you can quite easily provide different dependencies for test, dev, prod, etc.
Underscore and Backbone. Jeremy Ashkenas writes beautiful source code.
Have a look at https://clipboardjs.com/ 
I would like to add that modern browsers can usually only read 6 script/link tags at a time. Imagine your HTML having over 6 tags to be included, the browser will only take more time to read these files; whereas Webpack mitigates this problem by bundling them. 
&gt; Array.prototype.from Array.prototype.from(array) gives me: 'Uncaught TypeError: Array.prototype.from is not a function' Array.from(array) works fine.
We're both making Pinocchio references. :)
&gt; We're both making Pinocchio references. :) Oh, damnit! Duh. Cheers :)
Considering that in many cases advertising associated script code is malicious and anti-privacy I am not sure I understand your perspective. I am not saying people should be denied from making money writing code, but I wouldn't use advertising a valid example of that either. If advertising code weren't trying to stalk me and beacon away all my data without my permission then I am sure I wouldn't have such a problem with it. It would also help if it such shoddy garbage. In the mean time I should feel free to block absolutely any code from running on my machine that I wish. If you want all my privacy data then at the very least you could buy it from me.
This was our eye opener: [unpacking webpack](http://blog.tighten.co/unpacking-webpack) We came from from Grunt, then Gulp for a large 3D/CAD library with countless of files that needed to be in specific order. Gulp would concatente it (in said specific order), minimize it, then go through sub-projects (minification, autoprefixing, image compression, etc.). Grunt and Gulp only perform atomic tasks and do not consider your project at all, they offload the asset management on your shoulders. Because of that it was pretty hard to keep everything in check - the slightest change meant checking hard-coded dependency trees, digging through sub-projects to copy/paste a salad of includes, check mark-up so the replacement of HTML include-chunks would still work, etc. In Webpack there's no specific load-time order, the project consists of clean modules that do specific things and invoke other modules if needed. Webpack bundles them into a few assets, minifies, compresses, transpiles to ES6, worries about web-workers, etc. --- all through a concept called 'loaders'. So basically it does the same as Gulp, but allows you to keep a neat and lean environment. Webpack also includes a powerful dev server that doesn't just refresh the page on change but hot reloads the module you're editing while keeping the page as it is. In essence, with Webpack we don't miss Gulp, just like we didn't miss Grunt when we went Gulp.
I don't know how I feel about this. It feels like there is a lot of ways to fail. Having to declare all the directives you use in your template seems a bit verbose. 
We're talking about blocking *all* javascript that doesn't meet a certain standard, not just advertising code. 
Especially for large projects you should give Webpack a second look, it doesn't just bundle and that's cool. It transforms your project into an orderly thing while still allowing you to pipe in transforms. We have just switched and it makes maintenance very easy. The config block in the beginning was harder to set up than Gulp but the project has never been as clean before. It finally consists of clean modules. There is a single bundle in the HTML entrypoint. Minification, compression, autoprexifing, Es6 transpiling, etc. is handled by the loaders. Looking back i think Gulp and Grunt handle projects in a not-so-good way. The tools are amazing, but that i once thought that *concatenting files in specific order (or else ....)* and *parsing HTML files to replace a salad of file entries* was any good seems very strange to me now. Especially for bigger projects. These are good reads: http://blog.tighten.co/unpacking-webpack http://jamesknelson.com/using-es6-in-the-browser-with-babel-6-and-webpack/
I'm not sure what browsers don't support those pseudoclasses but browser compatibility could be a concern if you need to support IE. I also found that you can't highlight/select the text added from CSS.
No need for a DI framework when you can just use pure JavaScript and factory functions
how can this be even considered a dsl? well I don't really care. I just hope this trend of defining html in js ends soon. btw, if you hate typing html tags then use zen coding.
If it's a one-time thing, I completely agree. But I found myself doing that +10 times so this CSS was amazing to me. I would hope that other devs would look at how things are being done in other templates before they add to the project, but they can still use that check in your example without hurting anything.
Coming from a react background, I would opt for a component, `&lt;FormattedCell percentage&gt;{someModel.text}&lt;/FormattedCell&gt;` or `&lt;FormattedCell type={TYPE.PECENTAGE} &gt;{someModel.text}&lt;/FormattedCell&gt;` and handle the formatting in there. If your working on a small project though, totally no problem is doing what your doing, and it is a neat trick!
In case you've been following angular 2, here's the new information I got from this video: * Components can "interact" (mutate) their host: 14:42 * The useless `@input` and `@output` boilerplate is so you have a "well-defined" API: 12:09 * Components have an "intuitive" lifecycle of ***8*** steps: 13:40 * DI still requires boilerplate in the form of `providers`: 20:30 * You can make a module for your modules so that the DI for your component's providers is more clean: 21:59 The rest of it was on RxJs and typescript. Overall, I'm still severely disappointed from the amount of boilerplate you have to do with angular2, especially after the 1.5 release and react. It feels like they're trying to make angular even *more* complicated, when that was one of the largest criticisms of angular 1.
&gt; Jeremy Ashkenas writes beautiful source code, when Jeremy Ashkenas writes code. FTFT
FWIW I think [this is why that happens](https://github.com/desandro/arpeggiator/issues/1#issuecomment-191886451).
Spec or no, if you have trailing white space, then use `:after` with `content`, that space has shown up for me (at least sometimes, on some browsers).
The code and bug tracking is on Savannah: https://savannah.gnu.org/projects/librejs/ More resources on this: * https://www.fsf.org/blogs/licensing/rel-jslicense * https://www.gnu.org/philosophy/javascript-trap.html
So I am right in saying that the reason the `&gt;&gt;&gt;` is used is to account for humongous arrays?
because angular
Can you explain?
This makes me nervous.
&gt; Javascript modules, through AMD, Common JS, or ES6, give you this - you just import "something" and of you go. Accept if you need to inject that something or have something injected into another class... &gt; Javascript's "classes" also have no privacy about them. You could just assign onto it to overwrite the dependency with a stub/mock. I feel like thats not best practice and would lead too all kinds of complications down the road. I think DI has its place when you need to inject functionality from one spot into another, now we might not have name arguments like PHP, but we can still tell a class, through DI, that it depends on an instance of another class and have DI fetch and inject it ... no?
I think you forgot the word: Learning.
So it's essentially just an IEFE without a return statement? 
MDN may have this wrong: &gt; JSON is a syntax for serializing objects, arrays, numbers, strings, booleans, and null. It is based upon JavaScript syntax but is distinct from it: some JavaScript is not JSON, and some **JSON is not JavaScript**. What JSON is not JavaScript?
``` function isNumeric (num) { return !isNaN(parseFloat(num)) &amp;&amp; !isNaN(Number(num)); } ```
The simplest way I can think of: function isNumeric (value) { return parseFloat(value) == value; } It works because: * NaN != NaN * Numbers compared with == can be implicitly cast to string * == handles all cases where the value contains a number and is not actually numeric I'm not completely sure this is a bulletproof solution, but it will probably do the trick.
This is pretty much the exact use case for filters
This is ultimately just HTML and CSS. I used Angular's templating language as an example use case but it would work just as well with any templating language.
Yeah that's a good idea. I still think there is something to be said about a framework-agnostic solution like this but a separate directive would probably be the safer choice.
Wow that's really nice and clearly indicates an excellent knowledge of the language, well done!
thanks moratnz, you are great! tell me is recursion in this form "fac(8-1)" mathematical stuff or some rules from javascript?
I'm pretty sure that you do not need to create your arrays using new Array (); 
I actually messed up a bit. When comparing a number to a string the number is not converted to a string but the other way around. That conversion can be forced using the *Number* constructor so my code can be rewritten to use strict equality. function isNumeric (value) { return parseFloat(value) === Number(value); } Here the cast to number is explicit and might help avoid warnings when linting. In all honesty it took me a while to remember this. If it was the other way around the tests would fail when given an exponential number as a string.
Recursion is a general 'thing', used in mathematical proofs and in many programming languages (though different languages have different optimisations for recursion, so how powerful it is varies across languages). It's the general idea of a function calling itself from within its code. 
This fails for `"0x1"` (hex string) :(
You must be thinking of splice, because slice does not modify the array it's called on.
While that looked a little bit weird at first, it's passing all the tests, including the hex values, well done :)
True. Never though of that, while Number can convert it only parseInt can handle different bases. Knowing that NaN is *falsy* this should work: function isNumeric (value) { // return (parseFloat(value) || parseInt(value)) === Number(value); return (parseFloat(value) || parseInt(value)) == value; }
jQuery and JSON2
Would this actually be more performant than using just JS? Isn't JS faster than the dom? Still nice in anycase,
Is that a consistent 780 seconds?
Indeed, the array initializers below are sufficient, so the new arrays you allocated above are wasted.
I think your main problem is that when you refresh the page, you get the original state of the page: Refreshing only works when you have some means of retaining state, whether newfangled stuff like `localStorage` or oldskool stuff like dynamic server-side pages with a server-side database. You actually can change the displayed HTML on a page with methods like assigning to the `innerHTML` property of an element; it's much better to do that than to stick in a script block and use `document.write` where you want the text to appear.
You're not wrong, but it is a valid constructor. Usually programmers opt to just declare the arrays when they have values for their elements, however sometimes using `new Array()` is necessary, such as in complex apps or working with (async) data. But OP should also not be re-declaring the array variables (or any variable for that matter) using `var`; as previously stated, it's best practice to declare an array explicitly, and best practice to never declare a variable with `var` more than once. Example: bad: `var arr = new Array();` `var arr = ['x','y','z'];` good: `var arr = ['x','y','z'];` OP a few more points: * onclick/onchange/on[whatever] HTML properties are considered bad practice; I understand you're new to JS so that's fine, but consider learning [`EventTarget.addEventListener()`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) * `document.write` is also considered bad practice, especially when using it to write in HTML into your document; instead, learn about [`document.createElement`](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) and [`Node.appendChild`](https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild) for creating elements in JS. * Use [`document.querySelector`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector) to find your output element, and use `.innerText` to return `avg` to the output element's text node. One of the breaking points for your code is that you're trying to call undeclared variables outside of your main JS, partially because you're trying to write out the `return` value inside HTML; try using the `addEventListener` method I posted above to listen for a button click, then `querySelector` to output the value to an element. Make sure this is all where you declared your variables too!
&gt; This doesn't seem right, AFAIK BSD licenses carry implied patent grant , so a dispute with creator of the software will not take it away from you. A couple of lawyers have suggested this *could* be true. It has never been tested in court, most IP lawyers disagree, and even if it is one day created by a court, nobody knows how it would work, what it's scope would be, etc. Nor do we know whether an explicit grant would overide it, and we certainly don't know what would cause it to terminate; both are questions a court would have to answer when (or if) they decide it exists in the first place. Doubt and uncertainty like that isn't good for users; as a result most modern open source licenses include an explicit grant. If you think that BSD licenses do contain an implicit grant (and more to the point, if you think you could overcome Google's lawyers and convince a court of this, when the plain language of the license seems not to do any such thing), and if you further think that the implicit grant would be broader or harder to revoke than Facebook's explicit grant, and if you further think that an explicit patent grant would preclude the implicit grant you believe exists, then sure, that does make the Polymer license better than the React license. But if that's your logic, you should probably be clear about it. As for the links, I think they confirm the points I have been making. For example the one regarding Calypso contains a note from a project leader that they evaluated the patent issue and are happy with the current grant and then closing the ticket.
this shouldn't be as expensive as a filter if the table is very big? 
I think you're getting confused here. First, the more correct way to apply styles/formatting in this kind of situations would be using a CSS class rather than an invented HTML attribute. Second, nobody thnks the code you posted was Angular-specific. Rather, u/David_Crockett asked *why* you'd use an attribute instead of a CSS class, and u/bronkula blamed the *mistake* on your experience of AngularJS (because Angular has a history of needlessly encouraging/permitting developers to use and invent invalid HTML attributes, instead of using proper, valid `data-*` attributes).
javascript is not java and if you try it like other language you gonna have a very bad time. there is so much things to talk about in your code. first you dont need to declare variables like that you can create a new array literal like this. var array = [1,2,3]; no need to initilize it. and unlike const when use of var all variables are hoisted and is a good practice define all vars at the top of the scope. other good practice when use &lt;script&gt; tags is define it at the bottom of body. i would refactor your code like this: https://gist.github.com/anonymous/bdc30089071f9235b2bc http://output.jsbin.com/dekogepivu
These are fantastic resources about the jQuery source. I especially love the annotated source on Genius so you can get an idea behind the early development and the mind of Resig. http://genius.it/ejohn.org/files/jquery-original.html http://www.paulirish.com/2010/10-things-i-learned-from-the-jquery-source/
&gt; So Should I not Build a simple DI framework and OS it and be like "look ma at what I did" Do whatever the fuck you want.
&gt; While this is a solution, it's not that apparent/obvious, which can lead to maintenance problems. If you're a front-end developer (rather than, say, "just" a javascript developer) it's not that confusing at all - if you need to debug it you look in the DOM, see there's no "%" in the text content of the element, and go straight to the CSS to look for a `content` attribute. It's also a perfectly reasonable use of CSS - to transform/style the content at the point it's displayed to the user.
You can use one-time binding if you know that the data won't change. Also :empty is kinda picky, for example if you had a single whitespace inside the element, it won't be matched by the selector.
&gt; why bother with CSS If anything CSS should be the faster, lighter-weight and probably smaller solution. There's nothing *wrong* with doing this kind of stuff in JS if you're already using it anyway, but - in general, for output styling/transformation - CSS is arguably the better way from an architectural standpoint wherever possible.
&gt; the leading cause of brain-damage like this among otherwise-healthy developers. That's a strong reaction to an otherwise small detail... &gt; First, the more correct way to apply styles/formatting in this kind of situations would be using a CSS class rather than an invented HTML attribute. I can't think of any pitfalls of applying it as an HTML attribute. Browser compatibility isn't a concern because an unsupported browser would also not supported the selectors' pseudoclasses. UI frameworks such as Bootstrap tend to already bloat the class attribute so I liked the clarity of a standalone explicit attribute for what is really a unique scenario to apply CSS. &gt; Rather, u/David_Crockett asked why you'd use an attribute instead of a CSS class, and u/bronkula blamed the mistake on your experience of AngularJS Twas not a mistake. Rather an architectural design decision you disagree with. If custom attributes elicit such strong feelings from certain devs, then I imagine custom elements defined by React or Angular are probably a nightmare.
This is the perfect counter to that stupid meme that says you only need the first and last letters of a word.
Thank you. These are my feelings exactly. Isolating something away in a CSS file rather than add to the JS codebase is always my preference. 
That's the issue! It's only for inline elements. It should have been obvious to me, but I ended up doing something else to fix it (that code, I believe, is no longer in use anyway).
It kind of supports that, though. 
Sure it does. It's the same as saying window.myFunc = (function() { function myFunc(){ ... } ... return myFunc; }); That will work with Babel, and browsers should implement it with functions so it should follow the same rules. Can you post a fiddle or something?
Quite a few: https://codepen.io https://plnkr.co https://jsfiddle.net https://jsbin.com Just to name some of the more popular ones. I personally like jsfiddle as it supports babel at the click of a button.
&gt; chg our lng to use 3 ltr or lss per wrd and yer gld-n
This seems like a bad idea. Do screen readers read whats in the content property?
No, we are talking about expressions. That's why you replied to the only post in the thread that suggested using an expression
Could you give an example of when using new Array() is necessary? I know that best practices call for using the simple array initializer but what circumstances would require new Array()? 
Im sorry, a bit unsure of what you are referring to.
Thanks! I did find this resource but was having some difficulty implementing it but that was at 4am so will give this another try.
Nicely refactored.
And that's how you get Japanese/Chinese.
Nevermind, looks like React is what I need.
When I said `new Array()`, you can also use `[]` or an undefined variable to achieve the same effect. ### Loop example --- var data = { 0:'a',1:'b',2:'c' }; // or some other data var arr = new Array(); // or [] for ( i in data ) { arr.push(data[i]); } console.log(arr) //=&gt; ['a','b','c'] The array declaration outside the loop allows the array to push new values to itself for each property in `data`. ### Function Example --- var arr = []; // or new Array() function getData(source) { ajax.get(source).success(function(data) { return arr.push(data); }); } getData('https://data.google.com/example.json'); getData('https://dev.facebook.com/users.csv'); This declaration again allows the script to push any passed objects/variables when desired, no matter how nested/deep in the code. (so long as data is being pushed after `arr` is declared)
Lovely.
Ractive had virtual diffs before it was cool
//https://jsfiddle.net/Lwdapgb6/ function isNumeric (arg) { if (isNaN(arg)){ return false; } if(isNaN(parseInt(arg,10))){ return false; } return true; }
Ractive looks nice as well, will look into that.
Yes, yes it is.
It would be interesting if you could work with dyslexics to see what they were seeing and use javascript to try to fix it for them based on their individual needs. I wonder if that would be possible. So maybe every third letter is out of place or backwards so you fix it automatically then the next person it's every 2nd letter.
Reading this really wasn't that hard, partially because the first letter, last letter, and general word shape remained similar or the same. It was a bit distracting and longer words were harder to distinguish, but overall I read it at probably 70% of my normal speed. 
Funny. I could read without a problem 
It's not about seeing...
No framework is required, otherwise we would all use it. However the more complex your application becomes, the more moving parts you need to control. This is where most developers move to one of the frameworks, since they solve many of the problems that you would need to solve yourself otherwise. The question becomes which to use? That depends on what you are building, how large it is likely to grow, whether you are working by yourself or in a team etc. For a small website where Javascript is simply used to aid the display, then vanilla Javascript or Jquery will be all you need. For more complex website you might want to look at React which makes the view layer easier. If you are doing a lot of data crunching then React with Flux or Redux might be the solution, or you could go to Angular, Ember, Backbone ..... to help with the data crunching. If you are looking for complete solutions which are production ready, then Ruby on Rails, Django, Laravel become an option, but these are very powerful frameworks and require learning more than just the language of the browser. If you don't see the need for controllers and views etc then don't use them, which means you probably don't need any framework at present to build the applications you want to build.
At what point to Babel stop transpiling to es5 and instead use native es6 features? I mean, native will be faster and people have different browsers they have to support
I respect what you're saying as a by-the-book developer, but we're at an age in frontend web dev that warrants things like custom attributes and custom components that aren't yet part of the web standards. Perhaps you can build a large web application while still abiding by all of those specifications, but I would not want to be in charge of maintaining that code base. All of the major frameworks - Ember, Polymer, React, Angular, etc. - are aware of this and willfully break them in return for clarity and maintainability. I would rather have that than being able to pat myself on the back for following all of the rules.
And then perhaps someone will finally come up with an alternative to the abomination we call JavaScripy
I would probably just use /vendor and /js. If I had 3rd party CSS or HTML as well, you can nest it like /vendor/js e.t.c. If you try a framework based project, it will likely be more opinionated in terms of your file structure.
[here's a link to the javascript code](http://codepen.io/teachtyler/pen/xVwbrM) I hope this isn't in bad taste to OP Awesome work btw
Hi /u/cbrady350, First off, this is not a job board or a place to post classifieds. Secondly, we will not do your homework for you. &gt; [Mods] I am sorry if this is the wrong forum for this topic. If there is a correct place to where I can post this subject please direct me. There is no correct place to ask for help with academic dishonesty. Cheating is bad and you should feel terrible for not doing your own work.
Well then this little program is useless.
But there aren't any spaces, so you'd really end up with one giant word. Running this on one giant word would probably be really tough to read, since you'd be chasing around the fragments you started reading.
I have it moderate to severe, but I learned tricks to read as well as most people in my classes. Its not too bad if you are lucky and get good support, or just stubborn and work it out yourself 
i forgot my damn pwd, bleh, since i have a brilliant mind at hand can i use ghost? or wordpress? with a listener for a port to make a ticker? i have digital ocean cloud and ubuntu 14.04 and am against the rope if i should deploy nginx or express edit: ill look at react js ive been torn over extjs, this is why im reaching out i hated it
tbh i cant argue with you. This isnt my passion and Ive missed so much school being away for events it would be too hard to make up.
Why do you expect code that asks is a value is numeric to return true when it's a string? I mean, if I saw this for real, I would be expecting other code around it, not this function. :-/
Understood - Thank you!
Wierdly enough this happens to me in reading and writing. I've not been diagnosed with dyslexia but I read painfully slowly. However I've never let it hold me back and I'm currently half way through a masters degree. A lot of my time gets taken up with the readings though. 
Brackets
Even the very long words?
Interesting idea. A tad bit impractical and a weird misdirection of code. I'd think for the sake of code maintenance a simple function that could also function as a data normalizer in the case of value transforms is superior.
Hmm do chinese/japanese get dyslexia?
Elm ftw! Still compiles to js, but hey, I dont look at machine code either
This is more interesting than the title would have you believe. Especially the last section about the Function constructor and the switch statements. Interesting read.
Letters jumping around don't help though
What the hell is up with the annotation abuse? Whatever happened to, you know, normal code? It's like Angular 2 has deferred behavior from actual code, to configuration. "We may not want to make all of our class's properties and events, publicly available for user bindings and subscriptions" (12:15). I mean.... normal code does that. People have been doing that without these pseudo-configurations in many programming languages, for many years. You can do that with protected and private keywords in classic OO languages. You can do that with appropriately applied scope, closure and return objects/functions in JS. "I want to protect my privates" is a solved problem that shouldn't require annotation configuration to implement. It's like they're deliberately making Angular 2 almost impossible to apply pre-existing programming experience to. I can figure out basic principles like "I want to protect my privates" in just about any language, because there are pretty standard ways of doing that: appropriate scope usage, or explicit keywords. It's programming 101. What I *cant* intuitively figure out, is some seemingly proprietary pseudo-configuration approach. It's *almost* like a DSL, but not quite. Honestly, at this point, I think Angular has lost the thread. The big elephant in the room is how to update the DOM to reflect changes in application state, in a clean, maintainable way. That's it. That's the big problem. Angular 2 feels like it's gone off the deep end.
At the cost of having thousands of “letters”.
I don't think that's how dyslexia actually works. This is just a visual metaphor.
And the coffeescript source code. I learned an incredible amount about programming from that code. It's by far the most readable and understandable programming language source code I've ever seen, it's perfect for understanding the basics. 
[Lion eating poet in the stone den](https://youtu.be/vExjnn_3ep4) 
There is also the "closed form" or "golden ratio" method, which is O(1) constant time on computers with FPU (any modern non-embedded computer). const root5 = Math.sqrt(5); const phi = (1 + root5) / 2; const psi = (1 - root5) / 2; function fib(n) { return (Math.pow(phi, n) - Math.pow(psi, n)) / root5; }
HTML suffers from two primary problems: 1. (minor) HTML is verbose. Extremely. 2. (major) HTML is neither expressive nor composable. JavaScript functions are.
Isn't it on github? There's a link at https://github.com/geon/geon.github.com/blob/master/_posts/2016-03-03-dsxyliea.md, and I guess you can hunt down the Javascript on the same project. 
MDN refers to it as a callback: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach &gt;**callback** Function to execute for each element [lodash](https://lodash.com/docs) meanwhile seems to refer to the same function as the `predicate`.
&gt; we're at an age in frontend web dev that warrants things like custom attributes There's already a mechanism in HTML to do that. You just prefix them with "data-" and you're all good. Honestly I'm slightly appalled that front-end web devs would need that explained, but that's kind of my point about brain-damage. ;-) This isn't a case of frameworks like angular bravely forging ahead and web standards lagging behind. As I said, it's a case of angular and it's community *completely unnecessarily* permitting/encouraging invalid code when there are *already* perfectly valid mechanisms in HTML to do exactly the same thing.
Golf version: isNumeric=e=&gt;!!+e; Doesn't work for 0 or '0' though :) Slightly longer: isNumeric=e=&gt;e==+e; 
I think they got some ultimatum from higher management saying they can't support Angular anymore do something so fucked up that people stop using then we will disband the team. 
Haha nice, you're getting creative! :P
[handsontable](https://handsontable.com/)
Why is that stage going in reverse order, i can't get it :)
Interesting. Freaking complexity, though
Hi you need to Add jQuery to your page adding the script tag like you did should make it work, check to see you're loading the file correctly. Regarding changing the image tag, you can get use $('#IMAGE_ELEMENT_ID').attr("src", src); this will change the image element to the variable 'src' Here is a little updated fiddle https://jsfiddle.net/bgaj790e/
Ok, first of all, $ undefined means you forgot to include jquery in your project. Normally in web applications you would load it using *&lt;script src="http://code.jquery.com/jquery-1.11.1.min.js"&gt;&lt;/script&gt;*. To do it in JSFiddle press button with the cog on the javascript window and select jQuery framework. After you do this - your on-click event will work. &gt;When the page loads, Dice.getURL is called twice to get the URL for the 1-dot die, and the jQuery.attr() function is used to display the images when the page loads To do this, first of all, you will need the way to reference your images. Add id tag to html elements and call them something like "dice1" and "dice2". Now, on document.ready tell jquery to set "src" attribute of "dice1" and "dice2" elements to Dice.getURL function result. $('#dice1').attr('src', Dice.getURL(1)); $('#dice2').attr('src', Dice.getURL(1)); Hope that helps and you will understand how to continue with your project :) Feel free to ask me if you still need anything to clarify. 
Good for you! Its never easy to over come a learning difficultly like that. Especially with the lack of understanding there is, people can be right gits :( 
&gt; rapid **nmnaig**? wat?
According to /u/achen2345 [they do](https://www.reddit.com/r/javascript/comments/48t893/dsxyliea/d0mfwrc). &gt; What does orthographic processing mean? It is the part of the brain that composes sound hints to a collection that becomes sound instructions, such as letters (which represent certain sound fragments) into syllables (which represent certain sound formations) and finally into words (which have a distinct meaning often unrelated to the sound). In short it is the visual decomposition of a written symbol into a more complex auditory symbol that is really not auditory at all. **Languages that are not phonetic tend to have increased probability of dyslexia, like Chinese. Languages that are syllabaries tend to have a far decreased probability of dyslexia, like Cherokee and Swahili (half syllabary).**
I apologize I've always been bad at explaining. So google sheets allows you to create java script functions and I want the function to basically say "if this date has passed, then add this number to the sum." I'm making a spreadsheet for an invoice for work that I do.
I gave a slightly better explanation of what I'm trying to accomplish in my comment to the other person. 
Supercool, appreciate the help. I will try it out after work today. Does webpack handle the autoprefixing and other css/sass thingies aswell?
you probably need to detect the browser and suggest the user uses chrome or something, safari is pretty low footprint and not great on standards compliance, generally not worth the effort. Try installing chrome and see if it helps for starters of course.
They already have something like this in place: in Babel 6 you need to specify which transformers you want to use. Usually you would take a preset, e.g. one that transforms all of es2015 to ES5. If you want to target later browsers you can simply omit the transformers that are no longer needed (or use a preset that does so for you)
While this table shows you handy information about browser support and whatever, it's also handy to just get a rundown of where various features are in the process of becoming part of the official spec. The closer to the top of that list, the closer it is to being officially part of the ECMAScript spec. At the top is ES2016, which is now ratified and you can safely use with Babel without fear that anything in the spec will change. Before that happens though specs go through five stages before being included in ECMAScript. I think it basically works like this: Stage 4 specs will be included in the next ES version; Stage 0 specs were recently introduced and could change substantially before they become implemented, if that ever actually happens. 
Got a link to your game?
Before I dive in, I'll need to see an 'adonis-passport' module. Having a good OAuth module built for this would make it more attractive.
I probably should have just posted it here, but, you know, Friday. Basically it's a game built for devs, and I had an absolute blast finishing the game. Do not open if you have lots of work to do today; pretty much my entire office is playing this game right now.
LINK. THE. GAME.
Some of the problem comes from the people who ask questions like "How do add 3 numbers together with JQuery" or "How do I loop through an array in Angular 2" A lot of the "Vanilla JS" proponents are targeting people who develop tools, frameworks and components. Does your open source library REALLY need JQuery to be a hard dependency? ect.
http://www.macobserver.com/tmo/article/ios-8-how-to-enable-safari-extensions don't act like an idiot. 
short summary: ES2015 doesn't have unicode-aware `\w` and `\b` which is critical for my usecases
I agree with your statements.
http://radar.apple.com/
Sure, but at the bottom of it all that "thing built on a lot of other things," is just JavaScript. Sure at that point it's a DSL or what ever, but It can't not be JavaScript. It's not like jQuery, ect.. is it's own language. It's not like Rails or Django is it's own language. They are what they are written in, they can't not be. The frameworks are a result of programming in JavaScript. I'm not trying to say it doesn't make things hard, convoluted, create division, but you can't argue the basic point that, it doesn't really matter, because it's JavaScript all the way down.
What's CMV? And why are you so angry as to be throwing around insults?
yea post the code/link, we're just playing guess who right now.
People who claim to know JS because they use jQ in their apps/pages; people who can't style a page without Bootstrap, yet claim to know CSS.
That's really bizarre. Like, incredibly bizarre. Something must be breaking with font rendering, but it has to be to the extent of corrupting the font data in presumably the RAM. The game is perhaps using so much memory that it overflows a stack or screws up restricted system RAM. A temporary fix is to encourage iOS users to exit the game correctly or detect a blur and clean up some stuff. It's definitely a bug that should be reported to Apple.
I actually completely agree with you, this was mostly done for fun. It wouldn't be hard to break something like this anyways since you can access the underlying array or map or set and add values of the wrong directly to them (hence the "ghetto-ness"). But thanks for taking the time to comment and provide feedback! :)
I just realized you're agreeing with the overall point of the post, just not the way it's being applied as an attribute. Fair enough. I will concede that you are *technically* right but referring to that decision as "brain damage" is a gross overreaction.
It looks great, and it's a great idea - but I think from a game-design perspective the difficulty ramps up way too quickly to get many people hooked. It's the internet, we have a ludicrously short attention span. The first couple of puzzles should be real gimme-s with just a hint of the depth/challenge to come. Then the player has invested enough time to consider not closing the page. Of course you'll get people (like me) who will battle through - but I think it's such a cool concept that you should consider the "normals" a bit at the beginning, to reach a wider audience and get people hooked. Otherwise you'll be doomed to 99% insta-tab-close... the demon of web-based game dev! Anyway, gotta get back to the puzzles... 
That makes sense. All we need to get a decent job. What about their Fortran course?
&gt; people who can't style a page without Bootstrap, yet claim to know CSS. Wait, you can style pages without Bootstrap? Since when.
"press any key to start" *presses enter* -&gt; nothing happens *clicks on make sure page has focus, presses enter* -&gt; nothing happens *presses escape* -&gt; nothing happens chrome Version 48.0.2564.116 m i guess i should get back to work :(
http://stackoverflow.com/a/9337047/1616437
you might have had another variable named `str` somewhere
To be more specific, because of function hoisting, the following three lines of code will log `'string'` to the console: var str = 'rofl'; function str() { return 'lol'; } console.log(typeof str); The function declarations are parsed first, then the variable declarations, and a statement like `var str = 'rofl';` is turned into a `var str` at the top of its scope, followed by the assignment `str = 'rofl';` left where the original variable declaration was; that is, the code block above is parsed as if it were function str() { return 'lol'; } var str; str = 'rofl'; console.log(typeof str); (If a variable is redeclared, or has the same name as a function declaration, then the second declaration does nothing; it's the reassignment that does something.)
The name "callback" comes from the notion that it's something that is called back. An important distinction from callbacks and general function-valued parameters is that callbacks are actually called during execution of the function they're passed into: For example, functions that build functions based on other functions, like the `bind` and `curry` utility functions of many libraries, do not execute the functions they work on, so their function-valued parameters are not known as callbacks. (The ES5 method on functions known as `bind` is similar, except that the function it works on is `this` instead of an explicit parameter; still, it does not execute that function and instead returns *another* function that, when executed, uses a specific value of `this` and of the first few parameters, as in partial application. Additionally, the "bound function" returned from the native `bind` cannot be re-bound in any way, even to partially apply more of the parameters.)
I can't stare at that for longer than a few seconds
Thanks! You've been a huge help. I'm still in my infancy for JS and JQ, so your last paragraph was a little greek to me, but that's okay. Everything else helped me a lot!
lol
Fuck-yeah-guy!
The majority of the React community uses it. Some use hyperscript &amp; hyperscript helpers. Some don't use either.
you could also use an array of cached values and read from that. function fib(n){ var numbers = [1,1,2,3,5...etc]; return numbers[n+1]; } this solution represents the best case for big0 complexity (note that javascript numbers become unpredictable once you get outside of 31 bit space.) 
Threads like this come up many times on this sub. It appears that most people, based on my reading, feel similarly when encountering JSX but after using it they come to appreciate it. It's not a lot to learn. Give it a try and then see if you still can't stomach it.
This does not appear in the latest spec - http://www.ecma-international.org/ecma-262/6.0/index.html#sec-literals-regular-expression-literals According to MDN \w is equivalent to basic Latin alpha characters plus numbers plus underscore: `[A-Za-z0-9_]`, https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FRegExp It appears there is some internationalization support that came with ES6 for string literals, but nothing for regular expressions.
I'll echo this sentiment. I was (professionally) brought up with "separation of concerns" mantra, so the idea of React / JSX seemed heretical at first. But upon using it... well, it's javascript. With a tiny bit of syntactical sugar on top. Basically, they added shorthand way of calling a single, specific function. Nothing more. JSX is orders of magnitude simpler than CoffeeScript. But then again, I've never understood the hate towards CoffeeScript, as I found it absolutely godsent at the time it appeared.
Haha maybe "can't stomach it" was a bit too strong a phrase. But I just hate alternative syntaxes. I'll give it a try though, I guess!
This is exactly it. That's why I'm not super happy with frameworks like Angular, in which you have to learn "angular" to use it. I don't mind learning languages, not a huge fan of learning fad frameworks. 
I might have a better one. My app is written in Swift, but mainly it launches web views. I execute web services in swift and then hand the html to the web view. Anyway, I have one particular web view, that when loading the right html (via javascript), will crash IOS completely. Goes like this: 1. Load Web View 2. Load HTML 3. Screen locks up for aprox 5 minutes. At this stage, nothing can be done. The home button doesn't work, power button is useless. 4. Screen goes black, I see the Apple logo. In a few minutes the reboot is complete. I can reproduce this on an IPad 2, IPhone 6s, and IPod, all running latest IOS. Fun times.
It's a relatively new syntax and is only getting more popular, so yes and yes to your questions. That said, you don't **have** to use it with React.
I will definitely give that a read. Babel is a little different because its aim is to allow us to use ES6 syntax, which is in fact Javascript itself.
user: b password: b 
I was like you once. Then i realized that when my brain sees jsx it instantly knows what it does. It not bad. This from someone who hated its concept.
I used to be big on flow and anti TS, but I tried it out a bit and came to prefer it. You don't have to write everything as a class, and you can do FP just fine. The big get is that there are typescript definitions files for tons and tons of libraries out there. It's just a massive productivity bump if you don't have to hack together something on your own for external libraries.
It's probably the graphic display memory corruption. I sometime got it on Windows when playing some intense 3D game. The screen got scrambled even after I've exited the game. A reboot is needed to clear the screen. 
I wrote an open source tutorial with it once and it worked like a breeze. Can always be better but I'm quite blown away by all the things it's capable of already. There is a new v3.0 version currently in the pre-release stage. It'll introduce proper support for custom themes, which has me very excited, as I might finally get to use GitBook for a documentation site. The very book-centric styling of the default theme has made this a bit awkward in the past.
I've found JSX to be fantastic. I've done a lot of web-apps and in the past had tons of html in strings. This is much easier to maintain, and much more dynamic. Just think of it as a beefed up templating system, which is essentially what it is. 
I view JSX as a non-spec JavaScript operator. React with out JSX looks like this function Foo(props) { return React.createElement('div', { className: 'my-class' }, React.createElement('span', null, 'hello world') ); } More tersely: const h = React.createElement; function Foo(props) { return h('div', { className: 'my-class' }, h('span', null, 'hello world') ); } I view JSX as an shorthand operator for `React.createElement` that allows people who “only” know HTML to make meaningful contributions to a React codebase with out having to “know” javascript function Foo(props) { return ( &lt;div className="my-class"&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;/div&gt; ); } In fact, JSX can target things other than React, which people do/have done, which IMO lends credence to the idea that JSX is a non-spec javascript operator. This is a somewhat relevant article I recommend https://medium.com/@dan_abramov/react-components-elements-and-instances-90800811f8ca#.pm3v00am0
There is nothing about TS that encourages classical inheritance patterns any more than ES6 does. All it does is add types, which are pretty useful for functional coding style.
I don't agree with many of his coding beliefs, and in the past he has said a lot of things about how we should be grateful we're employed, etc. Basically aspects of his "professional manifesto" are somewhat right-wing. This was a long time ago, and I haven't paid attention to him since. *shrug*
The author makes the disclaimer that the article consists of personal opinion based on 3 weeks of using TypeScript. Viewed in that light, his points can be understood. But in terms of a convincing argument against TypeScript, there's nothing here of much value to those genuinely considering whether they should use it. Most of the arguments range from weak to incorrect. (In my opinion, as someone who has been using typescript for well over a year now.)
Yep.
JSX only really replaces templates. The rest is JavaScript. I would say you're hamstringing yourself by not using it, bot to each their own. 
Took me about a day of development and I was fluent. It's a tiny piece of react and its beautiful. 
&gt; Many people state that jQuery is dead and it doesn’t have a place in modern web development anymore. it still does the "write less, do more" thing pretty well
It was like reading a different language for me at first, but after a short while it just made sense. I now much prefer it to building templates with a restricted DSL like mustache.
I read this for about 10 minutes, and then realized that today I had my coffee in my jQuery mug... What a coincidence. 
So [don't do that](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.enatcgxbc).
Sorry but I don't click on links that contain lists of reasons, tips or mistakes. Or links that may amaze, shock or terrify me.
JQuery taught me where JavaScript lacked. Surely you could admit the majority of its issues have been addressed in ES5 / 6. Yeah? 
Try looking though some of the projects on http://up-for-grabs.net/#/tags/javascript The site is built to make it easy for new contributors to find projects that have issues/tasks that they can work on without a lot of preexisting knowledge about the project or about OSS.
The only limit is yourself.
You can do anything AT [ZOMBOCOM](http://zombo.com/)
Now do it for a different locale. Sure, it probably works for your current locale, but French (and likely others) use a dollar signs after the value -- other locales have the percentage before the number... many use different commas vs. periods for groups and decimals. Of course, you could apply those styles differently based on other more specific styles that target lang attribute -- but this wouldn't work for group separates. The "preferred" way to do this is with filters. Check out the [currency filter](https://github.com/angular/angular.js/blob/v1.5.x/src/ng/filter/filters.js#L59-L77) in the angular source. If you do need to support other locales, you can pop in the angular-locale file for the proper locale and the rest is taken care of it for you. The way it works, there is a provider for `$locale` that is defined in each of the files, e.g.: [tr](https://github.com/angular/angular.js/blob/v1.5.x/src/ngLocale/angular-locale_tr.js) -- I mention this one as it uses percentage before. Now, the rub here is that there is no percentage format filter in angular, for whatever reason. I believe these locale files are all generated based on some closure files (e.g., [TR](https://github.com/angular/angular.js/blob/v1.5.x/i18n/closure/numberSymbols.js#L3275-L3291)) --this *does* have percentage and percentage format so I'm not sure why they never implemented percentage. You could potentially write a decorator that overrides keys in $locale to include the appropriate value for the given locale and write a similar filter for percentage as well (which, if copied from currency, would do the group and decimal separation as well).
Sure, and I will continue to advocate jQuery as a markedly simpler DOM API (especially for Javascript beginners), but if the practical reasons for using jQuery are cross-browser support and AJAX... then yes, it is becoming obsolete. Which is a good thing for Javascript, and the web as a whole. I think there are some questions one should ask before installing jQuery: Do I need to support old IE? Do the benefits of the API justify the 86KB file size (i.e. can I get the functionality I need between native methods and smaller libraries)? If I'm using a framework of some kind do I even need jQuery (i.e. should I be directly manipulating the DOM)? The answer might be yes, in which case jQuery would be handy for sure.
&gt; JQuery taught me where JavaScript lacked. Well it's more where browsers were lacking and clashing, not JS itself as such.
try vuejs, not as popular as React but it's start getting traction more and more
It's less true than it used to be back when IE was at its worst, but there are still a lot of weird bugs and edge cases that jQuery handles, in part just because it's huge and very experienced with all the quirks. You think something is going to be simple... but then, well, just look at the jQuery 3 source code and look at all the things it has to handle here and there. Granted, for specific bits of functionality (dom transversal, ajax, callbacks) there are probably individual libraries that ALSO hopefully cover those weird edge cases and differences. But jQuery is probably a lot more reliable on those things than a random npm module of dubious matienence.
I think he misunderstands what Promise.all is for. Promise all is just sugar for merging a bunch of promises into a master promise. It's not a controller for when promises happen or what their individual dependencies are. If you want to serially do something, and then when it's done, do something else, you just chain your Promise-returning functions serially in the perfectly normal base-case way of using .then and returning a new promise. exports.up = function(knex) { return knex.schema.renameTable('tomatoes', 'potatoes').then( _ =&gt; knex.schema.table('potatoes', (table) =&gt; table.string('name')) ); }; Or you could build a pipeP construct to make it more readable, or use Reader, Task, etc. to externalize the knex, and so on. Promise.all was never even relevant here. If the output of both calls was important (which is what Promise.all is actually good for) then ES(8?)s async makes that nice and easy to express: exports.up = async function(knex){ const op1 = await knex.schema.renameTable('tomatoes', 'potatoes'), const op2 = await op1.then(_ =&gt; knex.schema.table('potatoes', (table) =&gt; table.string('name'))); return [op1,op2]; } in ES6: exports.up = function(knex) { return knex.schema.renameTable('tomatoes', 'potatoes').then( op1 =&gt; knex.schema.table('potatoes', (table) =&gt; table.string('name')).then(op2=&gt; [op1,op2]) ); }; 
Yes.
Jquery is the last bastion of web dev without a compilation step. It makes sense for content-centric web**sites** more than it does for data-based web apps, but it has its place there too. It has backwards compatibility tons of major users and is easy as heck for beginners. You don't have to worry about whether your nodeJS dependencies are going to work on days ending in 'y'. The jQuery team is awesome and they should feel awesome. ~~My only criticism is [A+ Promises](https://promisesaplus.com/) vs [jQuery promises](https://api.jquery.com/jquery.deferred/), but [it won't be long](http://caniuse.com/#feat=promises) before we don't have to use them.~~ Aaaaand I finally RTFA. They're fixing this in 3.0.
What's the value of "Immutable.js inside"? I feel like people just throw trendy libraries in their projects without any sort of understanding of actual use cases in which they make sense simply for cool points.
Yes.
Great comment. 
&gt; But upon using it... well, it's javascript It's obviously not javascript. Remember when people were saying "coffeescript is just javascript" ?
It's not new, it's basically E4X under new clothes.
&gt; Many people state that jQuery is dead and it doesn’t have a place in modern web development anymore. However, its development continues and statistics of its adoption (78.5% in the top million) contradict these claims.
DOM traversal (`add()`, `find()`, `siblings()`) and chaining is still very convenient in jquery vs standard js, as are non-standard sizzle selectors like `:contains`, `:first`, `:last`, `:gt`, `:lt`, `:eq`. yes es6 helps but jquery is so much more concise than the standard DOM API. at this point there's so little overhead, so much support and so much familiarity that it's radical to do any frameworkless thing without including jquery.
Because anything is possible
I'm curious to see if they've learnt anything from Velocity. If the framework could replace jQuery's animation stack (force-feeding, caching, sequences and rAF) that would be amazing.
While the referer method /u/lewisje mentioned works, I'd argue the better solution is to simply post a different URL on Ebay to your site that includes a unique name for the site you posted the link to in the query params of the URL. Affiliate programs (like the kind you'll see some YouTubers use when being sponsored by a website, e.g. `audible.com/PewDiePie` or `audible.com/SmarterEveryDay`) do this all the time because they need to know where their customers are coming from (a PewDiePie video or a SmarterEveryDay video?). The advantage to this method is that it still works if users copy-paste the link into the URL bar, or send it to a friend or something that doesn't involve directly clicking on the link. For instance, if your site is `mysite.com`, rather than posting a link to `mysite.com` on Ebay, you should post `mysite.com?src=ebay`. Then, in JS on your site you can simply get the source from the URL with `/[?&amp;]src=([^&amp;]*)/.exec(window.location.search)[1]`. So you could post several links like `mysite.com?src=ebay` and `mysite.com?src=reddit` to several places and do something like: &lt;script&gt; var source = /[?&amp;]src=([^&amp;]*)/.exec(window.location.search)[1]; switch (source) { case: 'ebay': alert('My ebay message'); break; case: 'reddit': alert('My reddit message'); break; } &lt;/script&gt; That way, it all still works with copy-pasted URLs, and you can easily do it for multiple sites. Also this method means you don't have to handle whether the user came from `ebay.com` or `www.ebay.com` or `ebay.co.uk` or `ebay.co.jp` or the hundred other possible referers. It just works!
Perhaps, but consider that in some applications (e.g. a spreadsheet), this may actually be desired. Very good to point out though.
This was about trying to imagine what that quote could mean in practice: &gt; With Angular 2, we’re really attacking it from a ‘platform of capabilities’ standpoint... Our plan is to have versions that will work with many server-side technologies, from Java to Python I believe server side Angular will play even a bigger role in this scenario where its being ported to server side platforms
Doug Wilson is Jose http://imgur.com/gallery/iB0VQJT
There's actually a much simpler approach. You don't really care about what numbers are in the middle--just how many there are in the middle and what the min/max numbers are. Assuming you don't have duplicate values (which are easy to remove anyway): function Consecutive(arr) { arr.sort((a, b) =&gt; a - b); return arr[arr.length - 1] - arr[0] - arr.length + 1; } Consecutive([5, 10, 15]); How does this work? Well, notice that you can get the numbers between any two numbers `x` and `y` by just subtracting the smaller from the larger and subtracting one (since we don't want to count both `x` and `y`). For `x = 15` and `y = 10` we get `15 - 10 - 1 = 4` since there are 4 numbers between 15 and 10. So to get the number of numbers missing, just subtract the min from the max, subtract 1, then also subtract the number of other numbers in the list (`arr.length - 2`). The -1 and --2 (i.e. +2) then become +1.
http://poop.bike/
https://github.com/jakepusateri/auto-babel
Thanks everyone!!
&gt; `for i, _ := range 1000000{` That's not valid Go syntax.
We don't use jsx but use coffeescript at work. Mine looks like: HelloMessage = React.createClass render: -&gt; React.DOM.div 'className': 'whatever' , @props['name'] I actually quite like it like this. Nesting is not really an issue as long as you send properly nested and sometimes a bit repetitive props from the model so you do not have to touch them in the views to pass them to children. You should also create a class for nearly everything instead of component methods that return pieces of DOM in far too big frankencomponents.
If you embed jquery3 script on your site and then embed the query 3 migration script right below that, your console will fill up with lots of info about deprecated functions you are using so you can quickly fix your code. Once the console messages are gone you just remove the migration script and you are done.
Thanks for the reply, I do like your implementation because I think adding artificial tags to existing promises by hand is lame. One minor difference between my implementation and yours is the alts promise rejects only if all promises have failed.
Well, do-while loops actually fits here perfectly. I do not want to explain whole difference between all types of loops, but do-while logically fits here. What it does is runs same block of code while some expression is true. Here is your mistake number 0: Your do-while loop will keep rolling dies while their sum is equal to needed number. You actually want it to run while their sum is NOT equal to needed number. [How to do this](/s "replace == with !=") Here we got to mistake number 1: die1 = Dice.rollDie($('#dice1')); This peace of code doesn't makes sense in your context. Your Dice.rollDie function does not return anything, so you are not really assigning any value to die1. What you want to do is make Dice.rollDie function to return rolled value. And that's pretty much it. https://jsfiddle.net/gn79yrs6/ Here is a working version in case you need any reference. About that jQuery - make sure you include jquery higher in the page than your code. JavaScript evaluates from top to bottom, so jQuery needs to come first. :)
Also using some sort of local storage has proved to be to slow. These requests and responses need to happen at about 40FPS to keep up with the lighting data.
Thank you for taking the time to go into detail :)
No doubt he is very entertaining. I just don't think he's particularly correct about a lot of what he advocates. 
You can run a simple HTTP server locally. Accessing the page via http://localhost:8080 (or whatever) should help get help get around most of the issues of accessing it via file:///path/to/file Once that's all set up, you'll need to return a CORS header (`Access-Control-Allow-Origin`) from your server.
Thanks! I've been having an issue with trying to set the header though. I'll pop back in later with some code snippets. 
maybe. take a look how howler.js is put together https://github.com/goldfire/howler.js "pos: Get/set the position of playback. position: Number (optional) The position to move current playback to (in seconds). id: Number (optional) The play instance ID."
Now, if I run a local web server to serve the page, will it still have a valid origin when I try to access the lighting data server? The data server must be its own application. The Rendering page is huge and it's hit on the lighting data read process is significant, so I really can't afford for the lighting data process to serve the page should one of the connected pages refresh mid show. That would be disastrous. 
This is not the intended use of JSDoc, think of JSDoc as a replacement for your confluence docs, not a supplement. JSDoc runs on your JavaScript source files and aggregates a broad view of your codebase. The JSDoc script returns a whole bunch of metadata about each function, class, namespace, etc... it all depends on what data you're looking for exactly.
[removed]
If you want true separation of concerns and want to treat JSX like a template, just use a module export that exports ONLY the JSX "template", and then import/require it in a component's render method. Then your JS and "markup" will feel more separated. That said, doing this will likely start to feel burdensome and over-separated as most JSX is focused and inherently coupled to its data model whether the JSX lives next to that model or not.
I found http://js.cytoscape.org Have never worked with data visualization before but have found it easy to pick up for a threat association project.
From personal experience/opinion: ES5 - jshint ES6/JSX - eslint
Yes, but my understanding is that different ports are considered to be different domains for CORS purposes. So let's say you have your lighting server running on localhost on port 8000, and you run your static file server to serve up the site running on localhost port 8080. You would need to set a header on lighting responses like `Access-Control-Allow-Origin: http://localhost:8080`. Or, alternatively, you can set it to star, but that means there will basically be no CORS protections, so just be aware of that. Node should be something like: http.createServer(function(req, resp){ // ... resp.setHeader('Access-Control-Allow-Origin', 'http://localhost:8080'); // .. }).listen(8000); If you're using a framework, though, you'll need to consult the documentation for setting headers.
Eslint all the way . I like enabling standard/semi standard and having it enforce a style guide too. One or two like config and it warns me about a ton of bad practices. I love being able to toggle some things as required and some things as warnings. Totally my choice. All the built in envs and presets are pretty nice. There's also the eslint-cli package so eslint can be installed per project but still have a global binary.
Yeah you can allocate an array with 1000000 ints and range over that: var ints [1000000]int for i := range ints {} But that's not really idiomatic at all nor what `range` is really for.
/u/mseyne I'm here again! =)
JSX is nothing like Coffeescript (which tries to bring another language style/syntax, Ruby, to JS). JSX just lets you write HTML tags inside of a single function within a React component. If you've ever written HTML, JSX won't be an issue and no different than Pure JS besides what goes inside the render function (the only required function within a react component) of a component. Don't over think it. Look at the React docs.
Thanks very much! This whole setup is not online, and for a one off purpose, so no security concerns. 
Airbnb is where it's at
You need to be aware of 3 things in order to accomplish this. 1 is that there are 26 letters in the alphabet. 2 is knowing whether you are working with uppercase or lowercase letters (different character codes). and 3 is being aware of what the "max" character code is for the respective lowercase and uppercase alphabets. see the following code: function cipher(str, num) { var cipher = ""; var shift = num + (26 * Math.floor(num / 26)); console.log("the shift is ", shift); for (var i = 0; i &lt; str.length; i++) { if (str[i].match(/[a-z]/i)) { var currentLetterCode = str.charCodeAt(i); var lowercase = str[i].toLowerCase() === str[i] ? true : false; var max = lowercase ? 122 : 90; var cipherCodePreMath = currentLetterCode + shift; console.log(`The current letter is ${str[i]} and the code is ${currentLetterCode}`); console.log(`After a shift the new code is ${cipherCodePreMath}`) console.log(`This is ${cipherCodePreMath &lt; max ? "below" : "above"} our ${lowercase ? "lowercase" : "uppercase"} max of ${max}`) var cipherCodePostMath = cipherCodePreMath - (26 * Math.floor(cipherCodePreMath / max)); console.log(`The cipher code is ${cipherCodePostMath}`); cipher += String.fromCharCode(cipherCodePostMath); } else { cipher += str[i]; } } return cipher; } cipher("coderBYTE!", 3); // "frghuEBWH!" you can run this in a javascript console to see the console.log outputs. we determine the shift by removing as many multiples of 26 (letters in the alphabet) as we can. this is so if someone passes say 53 as the number we don't actually need to shift 53 times, instead we only need to shift 1. we then iterate through our string one letter at a time. for each letter we first ask "are you a letter?", which you obviously were already doing. if it is a letter we must next ask "are you lowercase or uppercase?" because this will determine what the "max" (or "z"/"Z") character code is. Lastly we apply our shift, and if we have gone above our max character code we subtract 26, otherwise we just use our newly determined character code. hope this makes sense.
I really like every rule from standard except for the space before the function parameters like here: function foo (a, b, c) { } Is there any way to use everything from standard but change the rule to enforce this style instead? function foo(a, b, c) { }
I am not sure why you would not want to use JSX ... 
Possibly. I need to keep the lag time to a minimum, as these are time sensitive operations. I may just try to contact the media server manufacturer about modifying the chrome instance to run without security
I think you need to improve the "why" section of your Readme. I'm struggling to come up with a use case for this... 
Yeah, that's been stuck there since the initial commit. Should probably find a use case for it.
[removed]
WhatsApp just ditched support for Android 2.x
IE does implement JS. What's your point?
&gt; Vanilla (+jQuery) Wash your mouth out
If I remember correctly, there will be a compatibility version, with support for older IE.
That may be true, but he's at least provided explanations for his beliefs, whereas "Most of the arguments range from weak to incorrect" is just a bare assertion. Care to clarify what specifically you feel he got wrong?
[removed]
Really interesting indeed. I hope it will work, that could be nice ! 
Same here - extend it and put your own tweaks on top. Example .eslintrc: https://github.com/insin/eslint-config-jonnybuchanan/blob/master/.eslintrc
Can typescript also enforce coding style? (eg. propper indentation, spaces around brackets and so on) 
:) I'm happy I helped you. It took me a while to figure out myself when I was tooling around with React 0.14 in November. It's bizarre why arrow notation in functional expressions is kosher es6, but using class syntactic sugar doesn't allow it. 
I use Velocity.js for animations. It has a similar API to jQuery animations, but is way faster.
[standard.js](https://github.com/feross/standard)
[Tslint](https://github.com/palantir/tslint) is what you're looking for.
Could you clarify exactly what the inputs and expected outputs of this are? It's not readily clear from the demo page or source what constraints you're trying to maintain in your infinite grid. Some tiles are wide, some tiles are thin, some rows are tall, others short, some rows have 1 tile, others many--what is the intended behavior?
&gt; I need to keep the lag time to a minimum Using websockets might help in that regard.
Usually you'd use something like hyperscript or mithril if you're going to go without JSX. Here's what that would look like: const HelloMesage = ({ name }) =&gt; m('div', `Hello ${name}`); Or with hyperscript helpers: const HelloMessage = ({ name }) =&gt; div(`Hello ${name}`)
Can someone explain me please what is this sudden urge to have immutable variables in JS ? 
Google for "watching paint dry".
[Image](http://imgs.xkcd.com/comics/standards.png) [Mobile](http://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2604 times, representing 2.5483% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d0oxyg1)
It's counterintuitive, but functional programming works really well when you have to deal with a ton of side effects
Is there a lightweight library similar to his 'h' library that provides a nicer jquery-like api to working with the dom?
It's honestly never something I've cared about so I don't know.
What don't you like about promises?
I wasn't aware I could use web sockets in browser. How does that work?
I'd take a look at popcorn.js
I will check those out and try to improve upon the animations. Thanks for taking the time to look through it. 
Probably best to read up on MDN, but generally, on the client-side, it would be like: var sock = new WebSocket("ws://domain/path/etc"); sock.onopen = function(m) { // Connection opened }; sock.onmessage = function(m) { // Received message }; sock.onerror = function(e) { // Error }; sock.onclose = function(m) { // Connection closed }; sock.send("Send message to server") 
They gain a lot by open-sourcing it. * People can contribute changes back to the project, such as bug fixes and improvements * Motivation to completely modularise the project if it's not already * Feel-good factor from advancing the state of web development
No, as I mentioned elsewhere, this answer was deliberately flippant and is still incorrect. You want tslint to warn, or I prefer clang-format to enforce and then I never care again about fixing it myself.
I just don't get the jquery hate. It is easy to see how many ORM libraries run very inefficient queries. Can anyone show me how jquery is so inefficient vs home-rolled code? I've read the jquery code. It is NICE. Lots of subtle optimizations. Is the beef just that the file is big?
In my experience, one issue is that it allows less-experienced developers to take shortcuts that are VERY time-consuming to refactor. It also encourages bad behavior, like animating in JS and silently failing when calling a method on an undefined nodelist (two examples I've seen in the past week). And yes, sometimes that 30-40k can be crucial, that's about the size of a web font.
I think it's just the "idea" of not knowing what's going on under the hood that puts a lot of people off these days, or conversely, understanding what's going on, and not being happy with the overhead. Plus, lots of developers have abused jQuery terribly and that's created a certain reputation around it that it doesn't necessarily deserve. There is a quite considerable overhead in each of its methods however to allow it to be as flexible as it is. For example, allowing methods to take arguments in any order, allowing chaining,.. or allowing it to fail gracefully when you forget something important. All this stuff makes it awesome and makes the barrier to entry as low as possible, but by taking this sort of stuff out when you don't need it, you can certainly gain a lot of performance benefit.
Obviously it's great to see people writing code and solving problems, the way the JS ecosystem moves forward is by incremental improvements, I look forward to the release of the library with interest, and I hope the author does not take any negative feedback personally, etc., etc. But... ...right now the linked gist could be summarized as: &gt; I have no idea that there are a dozen different libraries using Object.freeze to enable immutable data structures that works with the normal JS array and object access notation, so I'm going to write my own. That doesn't seem likely to go anywhere useful quickly.
Ah gotcha. I guess I can see that now. Personally I've always thought about the cross compatibility stuff moreso in the DOM apis vs native object methods, but jQuery still contains things like `map`, and I guess `fetch` is considered ES6 as well.. and syntax.. well that's just delicious sugar.
You might want to look at Zepto, which is lighter and provides a similar API.
If there's anything ES6 will "save" us from, it's Underscore/LoDash. Maybe.
Hi /u/MrCurryLove, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Hi /u/braaaiins, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Personally, I've had a lot of trouble with jQuery event handlers being unpredictable and interfering with native event handlers, causing odd race conditions and weird mobile behavior. I'm much better at plain JS, so I find the easiest way to avoid these issues is to nix jQuery. 
&gt; it detects handlers directly attached to elements and alters them to be jQuery handlers instead This. Thank you for sharing this. I never understood exactly how jQuery messed with event handlers, but this makes a lot of sense.
That's the first explanation that I can respect. It doesn't sway me personally, but I can understand that POV.
i get what you're saying, but if you attach hundreds of handlers and you don't realize (i.e. you don't notice cause there's no slowdown) who cares?
What are you trying to accomplish? I've thought about using Sizzle.js for easy selection (it's also what jquery uses) and just writing a few of the more useful bits from jQuery (on, hide, html, what have you). For &lt;100kb, I'm just too lazy to justify it. I have other things to work on, and if it isn't broken...
`Object.observe` or `$scope.$watch()` or whatever other library you are using to watch changes on objects. A lot of MV* frameworks work this way now, watching data for changes and redrawing the view. So, "Immutable" is a contract that means the object must remain unchanged. Any future *changes* can only be represented by a `new` object reference (which could be a copy of the original). The benefit can be for security or thread safety, but for JS, it's mostly for performance. As an example, Angular 1.X has two watch type functions, `$watch` and `$watchCollection` (there may also be a third now, but it's irrelevant to my point). If a new item is added to a list that is being `$watch`ed, nothing happens because `$watch` only checks for changes on the list reference and not the items in the list. `$watchCollection` on the other hand, does watch the list for size/element changes, but it is inherently slow, as checking every item within a list for changes on digests is pretty awful for performance. So, with libraries like Immutable, when you add an item to an Immutable list, [it returns you a completely new list reference](https://facebook.github.io/immutable-js/docs/#/List/insert). This way, you get the benefit of just `$watch`ing the list reference for changes, because any changes always create a new reference. Thus, `$watchCollection` is unnecessary and it's better for performance.
But 97+(str.charCodeAt(i)+num % 26) for Lower Case letters won't make y to an a for example so that can't be right
Yep, and for anyone being forced to support old versions of IE, it's a godsend.
X-Post referenced from /r/coolgithubprojects by /u/bitjson [WIP &amp; naenae: CLI utilities to easily manage Work In Progress with Git](https://www.reddit.com/r/coolgithubprojects/comments/4958j0/wip_naenae_cli_utilities_to_easily_manage_work_in/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Sorry, it should be: 97+((str.charCodeAt(i)+num-97) % 26) for Lower Case letters that way were only modding from the value of a up. So now we're taking 121, subtracting 97 to get 24, plus 2 is 26, but with modular arithmetic, that resets back to 0. Add 97, the value of a and you get an a back.
 'name' IN ('%doe%', '%smith%'); 'name' IN LIKE ('%doe%', '%smith%'); these aren't valid sql... well, the first one is but it doesn't do what you would hope. You would need to do the or query. A quick look at [the docs](http://docs.sequelizejs.com/en/latest/docs/querying/#combinations) reveals you can do that with something like this: Users.findAll({ $or: [ {name: {$like: '%doe%'}}, {name: {$like: '%smith%'}} ] })
Right I know they aren't valid queries but I was just throwing some ideas out there! I did see that, and while that works, but this array im working with is created on the fly and can have any number of elements in it
I mean, you never really know what it is going on "under the hood," depending on how deep that means. You don't control the browser your user runs or on what system. At least you can step into jQuery if you want.
The `babel-plugin-transform-class-properties` Babel plugin converts `class` into `className` for you.
My main concern about using Promises is the way they swallow errors like a black hole, my main concern about RxJS is adding a lot of KB to a currently very small library.
This one is very good: https://vimeo.com/105955605 Coding Space Invaders from scratch without any libraries. 
[**@OweR_ReLoaDeD**](https://twitter.com/OweR_ReLoaDeD): &gt;[2016-03-06 02:45:42 UTC](https://twitter.com/OweR_ReLoaDeD/status/706309754562420737) &gt;I'm writing some async APIs for a [#JavaScript](https://twitter.com/search?q=%23JavaScript) library with currently 0 dependencies, what should I use? [#nodejs](https://twitter.com/search?q=%23nodejs) ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/495iir%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/joealcorn/TweetPoster) [^[Issues]](https://github.com/joealcorn/TweetPoster/issues) 
I'd say it has more to do with the popularity of react and its ecosystem than clojurescript (or any other JS compile-to). We've had functional compile-tos for quite some time now, but more recently, react and especially redux have been getting more popular. 
I created a baby who reacts to your voice frequency: https://please-dont-cry.appspot.com/ ------- How it works: https://www.youtube.com/watch?v=eN8E5eD9_d4 &amp;nbsp; PCs: Chrome/Firefox: you gotta allow the use of your microphone Non Chrome/Firefox: move your mouse over the screen &amp;nbsp; Mobile: Face the screen up and down 
I'm so sorry, I'm gonna post over there now...
&gt; it detects handlers directly attached to elements and alters them to be jQuery handlers instead Although you shouldn't be using `onclick` attributes if you're taking advantage of CSP, and you should be. Plus, `onclick` [doesn't behave the same](https://github.com/jquery/jquery/issues/2918) as an `addEventListener` handler either, much less jQuery. &gt; it "fast paths" event resolution by delegating to any handlers attached via jQuery before releasing the event for it's normal lifecycle, moving the bubble phase artificially in front of the capture phase (and only when you use trigger). To clarify this, if you use jQuery's `.trigger()`, and *only* for that case, it does a bunch of messing with event order at times. That was needed for IE8 in all cases and is *still* needed today for some non-native events, but it sure does screw up the capture-bubble cycle when you're working with a mix of jQuery and native. It's better to fire native events rather than using jQuery's `.trigger()` at this point if you're past IE8. 
Promises do not swallow errors, they are propagated as failures: Promise.resolve(2) .then(x =&gt; { throw new Error('Oh no!'); }) .then( x =&gt; console.log('Error was swallowed'), err =&gt; console.error(err) ); // console will write the 'Oh no' error
You can always do a [custom build](https://github.com/jquery/jquery#custom-build-examples) and only include the parts of jQuery you use. Of course if you use a lot of plugins they may expect the full jQuery.
Personally, I feel the same way. If you read the article I posted, it gives a lot of other examples but they all fall into the categories of: A. You're doing something without realizing the performance impact. Don't do that. &gt; [Not to mention it makes it incredibly easy to attach hundreds of handlers without even realizing it.](https://www.reddit.com/r/javascript/comments/494d66/a_year_without_jquery_patrick_kunka_discribes_how/d0p2gmp) .. or .. B. You're hiring people, you can't trust. Don't do that. &gt; [In my experience, one issue is that it allows less-experienced developers to take shortcuts that are VERY time-consuming to refactor.](https://www.reddit.com/r/javascript/comments/494d66/a_year_without_jquery_patrick_kunka_discribes_how/d0p0x8z)
Since you mentioned debugging, the #1 thing you need to learn to use is the debugger in your browser. If you are familiar with debugging in other IDE's, this should come naturally. Learn your DOM inspector too if you are doing DOM scripting.
**TL;DR: Ha! No. Google mostly doesn't do "frameworks". Google mostly doesn't do third-party code. Google mostly does server-side rendering. Angular and Polymer are growing though...** Nope. No one. I doubt many have heard of it at work either--Google is pretty insular when it comes to tech. There's kind of a tacit stigma associated with using third-party code. Angular and other client-side-heavy frameworks are basically unheard of among the large consumer-facing products (although Angular is used more commonly for small sites or internal tools). Google Closure dominates, and is often used on its own, although that's less of a framework and more a compiler and set of libraries. In general though, Google doesn't really do "frameworks". I've been at Google for the past 4.5 years or so and worked on 4 different teams ranging from massive BE big data projects all the way to complex rich media FEs, so I've worked with most of the main technologies we use. The vast majority of Google FEs are server-side-heavy, with various internal C++/Java server-side templating DSLs dominating, although there are tides of change with increasing internal adoption of Polymer and Angular. The AdWords FE, for example, is currently being rewritten from GWT (truly awful) into Dart Angular. I'm a Tech Lead for a rich media ad format and we use Closure + LESS (most of Google uses GSS, but since I started the project, we use LESS :D ), with literally no other libraries. Web Search uses jslayout (an internal framework for hybrid server-side/client-side rendering), which I love, but only really hits it stride at very complex huge-scale sites IMHO. A lot of older systems use Soy templates, GXP, GTL, or the like.
They (depending on the implementation) swallow errors if you don't explicitly catch the error and then do something with it. Unlike code that doesn't use Promises. Compare: new Promise(function (resolve, reject) { throw new Error('foo'); }); vs throw new Error('foo'); Chrome does now throw an error in the first case, although it used to not. Firefox still doesn't. Don't have other browsers handy to test.
The error is not swallowed, though. Swallowed means it's ignored and the program resumes as normal. The promise is failed if an exception is thrown, and any dependent actions are not executed. In the context of a promise, it doesn't even make sense to throw the error. Execution has already left the block by the time the error is thrown. Async/await only does it because generators are pretty awesome and defer execution. 
Well, think of it like this way: var test = function() { doSomething(); throw new Error('wee'); doSomethingElse(); }; Now, promise-ified: Promise.resolve() .then(doSomething) .then(() =&gt; { throw new Error('wee'); }) .then(doSomethingElse); They will behave exactly the same, where `doSomethingElse` is unreachable. The only difference is where the exception bubbles up to. This is not just semantics, and you don't have to explicitly handle the error. That's actually one of the advantages of promises - the error-handling is *built in* instead of being repeated all over your code. Also, Chrome doesn't throw the error, it writes it the console. You can check for yourself: try { new Promise(function (resolve, reject) { throw new Error('foo'); }); } catch (err) { console.log('swallow'); } // exception is still written to console This is because, as I said, the execution has already left the block, and there's nothing to catch by the time it is thrown. This is, again, not just semantics, but a pretty important distinction.
Good clarification. Do you know what non-native events that it need to be attached in this way? It's been a while since I read the code to see the exact edge cases (Jquery's in-code commenting by the way, are great, I encourage everyone to read it to see how commenting can illuminate the why and not the how).
I don't recall seeing null safe checks on object properties in ES6. Without that I don't see Lodash going away. 
I think it's much easier to keep separate interfaces. Otherwise you never know if you're dealing with an immutable or not and it's harder to keep mutable objects out of places they shouldn't be, leading to difficult to debug runtime errors.
I guess I take my concepts more from PHP where they have a concept of a "set up" and then you jump into the application. The old Days of Ember where they have a general "global" (note the quotes) App object. I am not a fan of seeing 20 imports at the top of a file, this remind me of PHP's old days with 20 require statements before they got things like DI and composer for auto loading. I can understand your down votes, hatred and severe dislike of my idea and concept, which is largely taken from Symfony's container system, but I thought I would try something that I thought was interesting and share what I have so far with people. weather you prefer the 20+ imports at the top as "a much better way to do it" or a "real" DI container, doesn't matter. I just wanted to throw one more idea on the fire and see what kind of smoke it gave off as it burned. :)
I'm not downvoting you. I certainly don't agree with you, but you're not contributing irrelevant noise, so it's not deserving of a downvote. Just keep in mind that this is not PHP, javascript's import is lightyears apart from PHP's include, and having 20 dependencies is a code smell no matter how they're injected. 
Well, I'm not going to, because I share your view.
But doing what Angular does without Angular would take way more work. That's the appeal.
But then of course if you find yourself doing the same thing many times, you should probably extract it to a function. And hey, maybe you could group some related functions together. And you know what, you need these same functions in a bunch of projects, why not bundle them into a library you can easily include? And now you've created a clone of the off-the-shelf library.
If your site's simple, then it wouldn't be a problem to drop jquery and use a lighter library. But when you require advanced widgets like calendars, popups, grids, etc., it's pointless to try to reinvent the wheel when we have a plethora of available ones that use jquery. As usual, it depends on your site's needs.
I like what you're saying but Douglas Crockford's obsession with banning features he doesn't like kind of bothers me. I mean, I imagine the man himself is not so rigid when he writes his code but he has legions of fans who are.
Regardless of the noise I am contributing I thought it was a good idea and I thought I would share it. The fact that you have to import the actual library might set some off. As this goes on and I develop it out more and get peoples ideas and feedback, assuming any have any other then "stop wasting time only use import, GTFO." Then Ill be glad to see if the noise I make becomes a little more interesting for people to at least listen in on and see whats going on .... No?
Read what I said again, I said you're *not* contributing irrelevant noise. :)
As far as I know, you are using some sort of proxy. For example, if you want to use the twitter oauth api, they provide a php script, which then contains the api key. Your frontend would then use this php file to get the twitter data. 
I mean 4 years ago those browsers still had some incompatibility issues. I bet you anything the last 4 years of your life would've been a lot nicer had you been able to use jQuery.
When render is called the second time, how is the vdom rendered to main again? Does patch do that?
&gt; I think it's just the idea of not knowing what's going on under the hood https://github.com/jquery/jquery The nice thing about open source is that you can know what's going on under the hood. 
nice solution... dynamic programming languages for the win!
As nobody else has mentioned it yet, I'm gonna say JSLint. I realise the single mindedness and strictness of the rule set will put many off and that making your code pass JSLint can be a chore. But I really do think my code comes out looking great after passing JSLint. 
You take pride in the code you write? I feel like I just kissed my sister everytime write code in a way i know to be subpar.
Think about it this way. If you are building a dog house you won't probably even need a blueprint. If you are building a skyscraper where hundreds (if not thousands) of persons are involved not only you need tons of blueprints, but you also need tons of people managing other people and lots of planning to find the best way to overcome the problems. Without that the project will never end, and if it does it will consume far too much time and money. As a project grows in complexity the success depends on organisation. That's what frameworks are all about. So do you need Angular/Backbone/Vue? It depends on what you are building. Don't take my word for it, try to build a large project for a few months without a framework (not even your own) and see if you don't end up with a huge pile of dog shit.
Jquery threads are always great. 
Vue.js
I don't think that's what he's saying at all - every application needs helpers when things become repetitive. As there are a few cases where no native API still exists, he's created a few very lightweight functions that are very specific, and learned something from doing so. Surely 1KB of homespun code that you understand is better than a ~250KB library?
It just takes items with width and height in properties and then scales them in proportion to fill display width and to the same height. And in the output will be updated width and height. Sometimes algorithm can't place item in the row then it will be popped into the next. 
It enables additional parameter from the context object in the lifecycle methods of the component [see here](https://facebook.github.io/react/docs/context.html#referencing-context-in-lifecycle-methods). 
Why not populate the context object by default? I'm sure they have their reason, I'd like to know the reason though.
My comment is not disagreement - your choice is perfectly valid - I just want to give the reason why I personally *do* like that rule: It visually separates function definitions *(i.e. both fn. declarations and fn. expressions)* from function invocations. Of course, that's quite subjective and depends on what you are used to and the effect is unlikely to be significant either way (which makes it a perfect issue to argue about ad infinitum - [bike-shedding](https://en.wikipedia.org/wiki/Law_of_triviality)).
&gt; If you're writing ES6 already the only difference with TS is what you're using to transpile Your view is too browser-centric. I'm doing node.js work and current node.js has almost everything of ES6 available, most of it enabled by default, some of it - really just some - behind flags (but I have yet to encounter a problem - not that I'm actively looking or trying to stretch the envelope). That's because I really don't want to compile, it's not worth it for me and my kind of projects. I get type-checks during editing by JSDoc-ing everything and using WebStorm, which also allows Google Closure compiler type annotations in addition to pure JSDoc. It's not perfect, I'd say it's 60-80% there depending on how you use it, but WebStorm gets better at this with each version. My biggest gripe right now is that when I add JSDoc type info for things WS already auto-detected it won't warn me if it sees a conflict between what it detected (which, when it does, usually is correct) and my JSDoc type comment, but instead letting my annotation override what it found. Kind of defeats (much of) the purpose of type-checking in the IDE in the first place. 
Well its just kind of surprising. It'd be kind of like a doctor saying he's been practicing for 12 years but hasn't heard of these things called "antibiotics". You end up wondering what he's actually been doing for the last 12 years.
It's a bloody miracle you've never _heard_ of jQuery.
Why are frameworks like MV* worth the added technical debt they bring?
the problem is when you don't want to catch the exception in .catch() http://stackoverflow.com/questions/30715367/why-can-i-not-throw-inside-a-promise-catch-handler 
&gt; To put it more generally, there is no way to provide both a lock and a key, but prevent them from being used in the wrong way :) Isn't `https` such a secure way that provides lock and a key? I haven't come across such a requirement mentioned by OP, of course, but I think if `https` can allow secure client information (like passwords) to be transmitted to the server, then why not the other way round? Why can't secure server information (like API key mentioned by OP) be transmitted to the client? 
If you were using webpack I imagine there are plugins to help you with that sort of thing, that maybe could build locale specific asset packs.
But you know what your code is doing. You have that control at least.
Thanks for tip
Yes. It's called [W3C Web standards](https://www.w3.org/standards/webdesign/script). All browsers implement it natively.
I read the article and didn't see any jQuery hate. Are you claiming that anybody advising any alternative must hate jQuery?
I've been programming for the web for 12 years and I've never used it. Never will. Partial lie. Used it once at one screwed up company two years ago. Step one was to remove all jQuery code. Step two, receive bonus check for making site run faster, smaller code size, more understandable, played well with outside sources, and more.
in your about page you would simply add at the top `import about from 'aboutObj';`
The client shouldn't know what the secret key is at all.
(I'm a newbie in Js) The way I do it (with vue and webpack) is like you, I do a require statement in my router, then inside my viewmodel I use es6 imports. '/patients':{ component: function (resolve) { require([__dirname + "/views/files/patients/patients.js"], resolve) } }, and then in my patients.js I use es6 modules import Vue from 'vue' import template from './patients.html' ... rest of my view code So I don't have one huge file, but an "entry point" (that's what's called in webpack) and views that are loaded on request I don't know if the same rules apply to require.js, I tried to do a project with require.js + knockout.js but when I got to r.js optimization I decided to switch to webpack. Edit: sorry for the edits 
I call bullshit.
This is a great summary of the problem. I ran into this myself recently on a project that relies heavily on JQuery. A library I wanted to incorporate into it turns out to trigger problems when $.ajax() runs, and since the project is JQuery-based, I had to abandon efforts to incorporate the other library. It puts me off of using JQuery for anything else.
Maybe he lives in one of those country where western movements don't reach.
Seems like not so good of a question unless you let someone see it in a code editor something. Generally when people debug things they don't look at a function on a white board. A better question might be that the developer suspects there may be a bug in a function and ask them the process they would go to debug the issue. That should give you a clear insight into how they think about a problem.
Please check this blog post too, which is in direct reply to the article at hand: https://medium.com/@vivainio/not-a-typescript-fan-68f088b58b6e#.ffi7dhlas 
Prior to CSS transitions, JS was the only way to animate a webpage without requiring a plugin. And given browser requirements, you cannot rely on transitions existing. I disagree with animating in JS being a bad behavior. 
Okay let's hear it, what's the problem with lodash?
That's what I was kind of figuring. There isn't an environment provided for debugging, and the bugs are mostly trivial (the `=` instead of `===` example). The functions purpose is clearly outlined at the start
Only initially, angular makes up for it twofold when you need to do something that angular doesn't support automatically. 
Well maybe, just Gulp is much more comfortable for me then Webpack and in future you can do much more stuff using gulp then webpack, what do you think ? 
What happens when you intentionally want multiple listeners that have been declared in different locations? Blindly putting the unbind call would cause problems. Wouldn't it be better to isolate your event declarations in an initialization routine and use a semaphore to control its invocation?
When you put it that way, it does sound a bit silly XD
Thank you for taking the time to answer. Is this the Google closure you are talking about: https://developers.google.com/closure/ Also. If you don't mind me asking. Even though most of what you guys do is back end heavy how much is it influenced by Matias Duarte and the overall design motto of "Focus on the user and all else will follow"
Can you give some examples of things you'd want to do with gulp that cannot be done with webpack?
Well, the answers to that are two: 1. If you're familiar with Angular you're familiar with how to coerce it to do whatever you want 2. Many applications can use nothing but built in Angular features for the vast majority of their functionality, so the extra cost in a small portion of it is more than paid by the saving it provides.
[That's not really an issue anymore.](http://caniuse.com/#search=css%20transition) Given the CPU hit on older devices that would be running these obsolete platforms that don't support it, I still think it's a bad idea. Why do you need an animation that probably runs at 10-20FPS anyway?
/u/eric-douglas :p
Where would you store it? For example, if the Stripe private key was sent down to the client, it is assumed you would want to use it. The tendency would be to put it in a cookie or local storage, but then it is exposed. Even if it came across via JSON, the end user could grab it once it is on the machine, or malware on the machine could watch what comes into the browser. While HTTPS prevents some forms of snooping, and is generally a great idea to have, it is not a panacea. The best option is to rely on the server, so the end user would make an authenticated call to the web server, which would then use the secret key to make the call to the service provider. That way, the client never gets the secret.
What you are referring to are javascript libraries. Once you are familiar with the ins and outs of javascript, you can then start learning about the libraries that were written in javascript by other developers to abstract and make many things simpler to do. 
And to add on, I would definitely recommend taking a look at Anthony Alicea's course, 'Javascript: Understanding the weird parts.' He has the first 3 hours on YouTube and it will give you good insight on how frameworks and libraries work. 
Ahem... There are no problems with it. Quite the opposite, it's a very useful library. After some parts of its functionality has been standardized, though (think Array.prototype.forEach), its usefulness is starting to diminish. This is what I was alluding to by saying "save" (in quotes!).
 $( document ).ready( // Slider initialization code here. ); For example: $( document ).ready( // Slider initialization $(‘#foo’).slideme({ arrows: true, pagination: “numbers”, resizable: { width: 990, height: 450, } }); ); Make sure your slider CSS and jQuery files are linked correctly.
~~As a note for those who claim Flow as a better alternative to Typescript, I invite you to check the languages used on the immutablejs project - https://github.com/facebook/immutable-js (by facebook, the creators of flow). Almost 25% of the code base is in Typescript.~~ That's not to say there's no value in Flow. Just that there's definite value in Typescript. edit: it appears that the TS files are actually definition files (see /u/samg's comments below ) &amp; tests and not source files which makes my original statement somewhat misleading. 
I think an undefined callback and single = used should be detectable, a loop that ends one early doesn't sound very useful.. I mean, if they look at the result, sure. Personally I think asking questions about their knowledge and trying to get a discussion going is more valuable. 
Thanks for the info.
Glad to learn this now, thanks.
&gt; I invite you to check the languages used on the immutablejs project - https://github.com/facebook/immutable-js (by facebook, the creators of flow). Almost 25% of the code base is in Typescript. I'm not sure what you're trying to say here; The only meaningful conclusion you can gather from this is that Facebook doesn't dictate that their programmers must use flow. &gt; Just that there's definite value in Typescript. IMO, this statement is meaningless too. The project wouldn't exist if there was no value in it.
Yeah. I don't think tests will help you hire the right people. You need to practice getting good at interviews, getting caught up in tests won't really help you do that. Your primary objective should be getting people to come out of their protective shell and talk about what they know and enjoy. Any typical approach is going to give you typical results. People practice for these things and are coached. TLDR: If you don't get good at interviewing, you are only going to hire people who are good at being interviewed. 
I was asked what techniques do you use for debug an application, which I found pretty dumb. I just said `console.log` and `console.dir` and Google Chrome Developer Tools. I don't know exactly what they were looking for, but they made me an offer, so I guess I passed. Probably the best interview question I had was where they told me to actually code something in front of them using hackerrank.com. I think this probably gave the best representation of what I could actually do with code, although I didn't get a second interview. This too has its flaws though, because given more time I could probably have come up with a better solution. I think one of the best ways to evaluate someone is to look at their actual work.
This was only one portion of the tech questions that they have setup for interviews. Working on refining it to be more useful. They are meant to be simply bugs to find (from what I can tell). So it seems like it's more to determine the persons ability to walk through code and figure it out. The other portions do include other stereotypical questions. But I'm looking to change it away from things that appear in the first 5 results of a google of 'Front End Developer Interview Questions'. Just looking at ways to improve their process.
Exactly.
|Any typical approach is going to give you typical results. People practice for these things and are coached. That's what I'm trying to get away from. The director and another developer handle the personality portion of the interview (as they've done it long). I'm brought in with another one for the technical part of the interview. I know from previous experience that I've been asked basically the questions that appear in the first results of a google search. So I'm trying to redesign some of the tech portion to be more useful. Make somewhat of a more unique question. 
I'm largely a "no": * Angular 2 introduced a python 2/3 problem; all of the angular code is in angular 1, and has little incentive right now to upgrade, since all of the code is in angular 1 * Angular 1.5 release was pretty good, and gave native support for component slots and streamlined components, as well as better one-way and single-time binding * Angular 2 is an exercise in needless complexity were it needn't be * I've found angular 2 to be a lot more boilerplate than I'd expect a fully rewritten framework in this day and age to be * Compares very poorly in developer quality of life to Vue, React, etc., or even angular 1 * Horror stories, like having to write their own HTML parser since angular templates no longer valid HTML * Monstrous combination of home-grown DI and ES6 modules * Classes for every little thing, including single-function things like filters * The most egregious abuse of decorators I've ever seen outside of enterprise java code Angular 1 is going to be around for a long time yet due to just how much code is written in it. Angular 2 can't simply rely on being "angular 1 better-er"; it has to impress in the day and age of react and its contemporaries, and I just don't see it doing that from what I've seen of it.
"Angular 2 is an exercise in needless complexity were it needn't be" Hmm could you expand this? I found it more easy to learn the concepts of Angular 2 instead of Angular 1 as it has less things to worry about. I am by no means expert and i haven't seen the whole picture of Angular 2 yet but thats my initial impression so far. Also classes and the likes make it more easy for object-oriented code, isn't that what Java, C do? I agree on the boilerplate part. It needs a lot of boilerplate to get it going and i had to make my own just to understand what are the dependencies needed for just starting Angular 2. Hope this gets better with time though.
Fair enough! Instead of a question that has them basically act as a code parser, maybe offer something that helps you see them problem solve. You could offer an OOP pseudo code example that could be better optimized. Maybe a couple methods could be doing basically the same things, have some patterns available that the original example is not leveraging, etc...
And you only do that once. You have the control. You know what it does. You can modify it at will. &gt; Can you guarantee more sales or improved customer satisfaction with your shiny new library? Can you guarantee more sales by using jQuery? No you can't.
I checked the order and it should be fine. [But here check it for yourself.](http://imgur.com/a/Obvf6) Thanks for trying to help :D
&gt; The best option is to rely on the server, so the end user would make an authenticated call to the web server, which would then use the secret key to make the call to the service provider. That way, the client never gets the secret. 
I think this is one of the reasons why typescript is a good idea, though. Typescript's typing isn't *nominal*, it's *structural*, and *progressive*. This means that your like-you-do everday code works just fine: function doSomething(value) { console.log(value); } doSomething('hi there'); // valid doSomething(2); // yup doSomething({ name: 'foobar' }); // still good But when you want to add a little bit more "safety", you can: function doSomething(name: string) { console.log(name); } doSomething('hi there'); // valid doSomething(2); // nope doSomething({ name: 'foobar' }); // nope And, as I said, it's not nominal, so anything can meet it: function doSomething(arg: { name: string }) { console.log(arg.name); // good console.log(arg.names); // oops, we typo'd } var Thing = class { constructor(public name: string) {} } doSomething('hi there'); // nope doSomething({ name: 'foobar' }); // yup doSomething(new Thing('foobar')); // yup So you can type normal javascript when it's convenient, then solidify your API later with types for other people working on your team, or consumers of your library.
&gt; I think it's great especially for people without a thorough understanding of ES5 TS is a superset of ES5, so you are going to have a very hard time with Typescript if you don't know ES5.
I've been using Angular for the past 2.5 years. I work on a large Angular app right now and I doubt we will migrate to Angular 2 just because of the size of the app. If I were starting a new project today, I would most definitely be looking into Angular 2 and ES6. 
Typescript may be getting nullability checks as well: https://github.com/Microsoft/TypeScript/pull/7140
Just to illustrate, Vue components all look something like this. You just pass a straightforward config object with intuitively named members that do exactly what they sound like they should do. Most of these are optional, and this is only a few of the most-used ones. Vue.component('my-component', { props: ['thinga', 'thingb'], // HTML tag properties we know about ready() { // code to execute when the component is ready // Ajax calls, for example }, methods() { // component logic sendStuffToParent() { this.$dispatch('stuff', this.something); // see events below }, clickHandler() { this.sendStuffToParent(); this.something = 'bcd'; }, }, data() { // component state return { something: 'abc', }; }, computed() { // component state computed from data, props, etc happening() { return this.something + " is happening"; } }, events() { // events received from other components eventname(data) { console.log("we just received ", data, " via eventname"); } }, watch() { // do stuff when our data changes something(new, old) { console.log("hey, something just changed to ", new, " from ", old); } }, // HTML that gets rendered whenever we're used in an HTML file or other // component template with // &lt;my-component thinga="foo" thingb="bar"&gt;&lt;/my-component&gt; template: ` &lt;div&gt; &lt;h1&gt; Stuff &lt;/h1&gt; &lt;other-component :propa="something" @click="clickHandler()"&gt;&lt;/other-component&gt; &lt;/div&gt; `, }); If there's another framework that's easier to understand than that, I'd like to hear about it. :-) 
Oh, neat. Glad to see proper bottom values. It'd be unfortunate if we get "null exception" before "null soak", though: let s = e!.name; // Assert that e is non-null and access name Null soaking can be useful in a lot of places: let zip = person?.address?.zip let result = doSomething?() But unfortunately this appears to be ["out of scope"](https://github.com/Microsoft/TypeScript/issues/16) for typescript. 
Happy to help. Order looks ok. I'll try to set it up on my end and see if I can get it to work. ID and class name seem to match. Is your images folder named "Imagess" or "Images"?
Try putting a function wrapper inside the document.ready like this: $(document).ready( function() { $('#foo').slideme({ arrows: true, pagination: "numbers", resizable: { width: 990, height: 450, } })} )
Appreciate it! I'll be coming out with more videos soon!
Other comments have addressed the library aspect, but increasingly there *are* different "JavaScripts" floating around. Most of what's written in tutorials and executed by browsers is ES5 (or &lt;5) which is the fifth version of the JS language specification. However, it is set to be replaced by ES6, which adds new syntax and language features. ES6 is already very popular for server-side code, but browsers are still not done implementing it. However, "transpilation" tools like Babel are becoming very popular. They let you write ES6 that is converted to ES5 so browsers can understand it. In addition to ES6 you'll often see snippets of JSX, which is used with React and is basically JavaScript with inline HTML. This is not supported by browsers, but is transpiled just like ES6. You may also see TypeScript, CoffeeScript, etc. around as well. The buzzword soup is not to scare you, but up let you know that there are a ton of assumptions people make about your familiarity with these different flavors of JS when writing on the internet. There is a frightening amount of context required to understand a lot of modern JavaScript tutorials, so getting ahead of the buzzwords and assumptions sooner will help you make more informed tool choices sooner!
yeah i named it "Imagess" on purpose... it was just for fun :/
Wow! this actually works! (but it's not perfect) Thanks... but the only problem now is that it broke my navbar XD Well I'm going to see if I can fix it.
I tried to use it with /r/DestinyItemManager on our v4 ionic app, and ended up removing it. It was more trouble than it's worth. I'm writing a library/api for interacting with a restful endpoints. I wanted to make sure that the code we wrote would be useful and to give them confidence, I wanted to use typescript with its benefits. My issues with it is when pushing the syntax with async/await, that there was a drag while we wait for features to catch up with TS. I had to do more work when adding functions to existing objects like rootScope. There was impedance from the tooling as I had to explicitly define the .ts files in my config to keep the auto-compile step light. I still think that defining types, interfaces, etc are good ideas, but I wasn't happy with it in practice using TS and took TS out of my project.
Regarding types landing in ES, if WASM is going to be a thing, I could see typed features being added that way rather than trying to bend JS into a different sort of language.
they said that they will greatly reduce the size when its finally out of beta.
Does it render on the server side though? If it doesn't, in 2016, that's a non-starter for me.
Not in official Vue, as far as I know. There may be some community stuff on Github to that end, but I don't have any need to muck with server side Javascript, so I can't speak to any of it.
An ad for ionic which as far as I could tell has no Linux client and is angular only.
The only reason I need to not use TypeScript is that if I do, anyone else who wants to work on the same code needs to learn it as well. If I'm incorrect and am somehow misunderstanding something fundamental about TypeScript, please correct me.
I didn't find anything that I didn't have to tinker with out of the box, if just to get the appearance and positioning right. I ended up using [carouFredSel](https://github.com/gilbitron/carouFredSel) which was the easiest for me to work with that did what we wanted.
I recommend using Appcelerator Titanium. Basically the same as Xamarin (actually native apps) but then with Javascript.
Has anyone really been far even as decided to use even go want to do look more like?
Oh yeah I remember seeing that one... don't you need to pay for it? Well it doesn't quite matter any more, as I have managed to figure out most of my problems with the current one I'm using. Thanks for all your help!
&gt; I chose Javascript after a cursory search of "what is the future of programming" lol. Expect to see this on /r/programmingcirclejerk. That aside, I'm happy for you. Programming is a very interesting job and not every gets to realize that.
Sure! You can do the same thing in angular 1 to entirely circumvent its DI as well. However, angular is a very opinionated framework, and part of that opinion is using its DI. If you look at all of their documentation, it all uses the DI. So if you do things the "angular way", you do it with verbose DI containers.
Well, of course, but you're comparing 2 code snippets that are not the same thing.. I think that DI is a very strong feature, and part of why I love ng1. If you want to compare NG2 and mithril, you should use the same benchmark, bind a controller to a view. If you want to throw DI to the mix, do it for both.
Not
It's kind of my point that the angular example written idiomatically has a lot of other stuff that the mithril one doesn't, and that the mithril one achieves the same thing without doing all of that stuff, in many lines less. :) Of course, if you added provider factory services and redundant DI, the mithril example would get bloated! Especially if you added in more observables, and then some kind of messaging bus... but all of that is unnecessary, and not encouraged by the framework. Meanwhile, all of that definitely IS encouraged by angular. As for DI, my mithril example was using ES6 modules, which achieve the same thing. If you wanted to be able to mock it in a unit testing scenario, you'd just have to add a very minor tweak: import {MessageService} from './message.service'; export view(_, {messageService = MessageService}) { const messages = messageService.getMessages(); // or w/e return m('div.chat-display.thumbnail', messages.map(message =&gt; m('div', [ m('b', message.username), m.trust(message.content) ]) ); } Now in my test I could do: import * as chatDisplay from './chatDisplay'; const messageService = { getMessages() { return someDummyData; } }; const result = chatDisplay.view(null, { messageService }); expect(result.tag).to.equal('div'); // etc
I suppose I'm not being clear in what I'm arguing. I mean to say that IMO the spread of using a specific implementation of an immutable bit-mapped trie that has structural sharing baked in (as exists in the clojure/script languages) originated in the ClojureScript community and has spread to the larger JavaScript community (via ImmutableJS) because it has proven useful when paired with React. I make no claims to the wider functional programming community, and do not wish to. Edit:grammar 
We are using ts at work, and I love it. Although working with external libraries can be quite annoying, when everything is working, it's a huge productivity boost. Just for the semantic autocompletion... And the good thing is that not everything has to be typed. I still do some vanilla js from time to time with ternjs, but this is miles away.
i think many time about this problem and finally i think who dont want music normally have the audio off or veru low.. no?
That was quick! Also just noticed when you pick a matching item, it says 'IT'S PAIR'. If you wanted to keep that phrase it should be 'IT'S A PAIR', although it's an odd phrase. Having just 'TIE' or 'DRAW' might be more straightforward. Hope I don't sound too critical, just trying to help!
Slowly but surely catching up on old versions of Python. EDIT: I mean am I wrong?
Yes. Client side has restrictions like CORS. You can make a simple proxy server for yourself and use that.
Babel just generates a tmp swap: var _ref = [b, a]; a = _ref[0]; b = _ref[1];
Stuff like this is cool, but I never seem to actually have a use for it. Edit: I'm talking about swapping variables, not destructuring.
Yep, that's it. As to the influence of Matias Duarte, well... let's just say I'm one of the FE implementation experts at the Google LA campus and I've never even heard of him. Maybe he's more well known up in Mountain View or in the Android org? I'm also more about ideas than people, so I rarely remember names. To be honest, for all the things Google does very well, a solid culture of design is not one of them. At this point I'm moving a little bit away from statistical fact to personal opinion, but I think the Google hiring process (unintentionally) ends up filtering out a lot of good FE engineers because they often don't have the raw algorithmic chops, and there is a tacit but palpable sense across eng that FE engineering is "less complex" than BE engineering. Having done both at Google, I actually feel that it's quite the opposite--most BE engineering is just copying a [proto](https://developers.google.com/protocol-buffers/) from this bigtable to that bigtable--but both factors lead to there being a well-known deficit of good FE engineers at Google. As a result, the design component is often left entirely to UX teams (which are also spread thin), and there are a lot of BE engineers creating BE code for FEs (which works about as well as you'd imagine). Don't get me wrong--my coworkers are damn smart, many much smarter than I--but being an expert cabinet maker does not really qualify you to be an expert wood carver. There's a lot of shared knowledge, but if you approach one as if it's the other, it's not going to turn out well. That said, I still love Google. It really is an incredible company.
Yes you're possibly right, that was only a proof of concept when I was doing the React tutorial to see if it was possible to separate them. Perhaps the rawMarkup bit in components is more presentational logic than anything else in that file, I didn't really go into that much detail when I was separating them out. I think generally though that the logic for fetching the data, validating the data and so on is completely different to rendering it and so shouldn't be in the same file. I've worked on sites before where different sub-brands of the site which otherwise behaved exactly the same way would differ only in the HTML output and I couldn't see a way of supporting that ability with React without separating out the JSX from the rest of the logic.
Thanks for the thorough, cogent post. I'm less sure than the author that an *optional* type system is not in ES's future ([ES7 typed objects](http://wiki.ecmascript.org/doku.php?id=harmony:typed_objects) are a clear step in that direction), but he makes some great points backed by data.
That misses the point. If I'm not using them, then it's pointless to use. If I am using them, then I've made my code less readable to anyone unfamiliar with them.
I think that's my underlying frustration with JavaScript. It's so incomplete so people integrate tools. There's a thousand different tools every month so none of us are speaking the same dialect of JavaScript. To the point that this is perceived as normal.
I have no idea what you're talking about. Can anyone show an example?
I think another important issue is that this approach (and others like it, e.g. deep-freeze, icedam) only implements a facade of what makes immutability actually valuable in JS--being able to efficiently signal deep changes to an object with a simple reference change at the top. Immutable data is useless if you can't easily and efficiently create modified copies of an immutable object. Recreating the entire object again from scratch (as this approach seems to imply) is just not viable. Could this approach be modified to do that? With some relaxation of the requirements, yes, but cloning entire immutable objects for each mutation (like `.merge` in seamless-immutable) will absolutely destroy performance unless implemented with shared [persistent data structures](https://en.wikipedia.org/wiki/Persistent_data_structure) (or what Immutable.js calls "immutable data trees", a.k.a. [hash tries](http://stackoverflow.com/questions/9054561/what-kind-of-data-structure-is-used-for-immutable-maps)). This is the hard part of creating an immutable library. The ability to recursively freeze an object is not very useful unless paired with an efficient means of cloning that frozen object with modifications.
 var a = 1; var b = 2; To swap the values (a=2, b=1), normally you'd go: var tmp = a; a = b; b = tmp; Or like /u/skitch920 suggests But now you can just go: [a,b] = [b,a]
Those are old examples (before Node.js had built-in Promises). Look for ES6 examples, those should run without problems.
Right but my point is you can become familiar writing web apps with "vanilla"ish JS, such as backbone and you don't need to know angular at all. Then you don't need to coerce it to do something that shouldn't need to be coerced in the first place. :-D
He could have just learned all he ever used in JS when he started out 12 years ago, before jQuery existed; then the unbelievable part is that he's still employed in front-end web dev.
Thanks for checking it out! I actually forgot to test the font rendering in multiple browsers. Each `.symbol` element's width is hard-coded in the code, so I'll have to increase the width for those characters that overlap.
Immutable started before Flow existed, and isn't actually written in TypeScript. It ships with a .d.ts file (awesome!) and the tests are written in TypeScript (external contribution). The actual data structures are written in plain JavaScript. It's true that Facebook engineers can use whatever they want, but I'm not aware of anyone using TypeScript internally. Many teams do choose to use Flow and we have a Flow declaration file typing Immutable. I agree that TypeScript is a super valuable tool. I'm sure Lee would as well.
Are we looking at the same framework[?](https://media.giphy.com/media/smQQvjcAtwtvW/giphy.gif) I guess I'm not sure what you mean by linux client. Are you wanting to develop apps for ubuntu phones or something? &gt; You can develop Ionic apps on any operating system you prefer. In fact, Ionic has been developed at various times on Mac OS X, Linux, and Windows.
This is what you're looking for: `b = [a, a = b][0];`
I started using NativeScript and so far it has been easy to use. I have run up a couple of test apps and so far so good.
It's definitely creative, but honestly I don't know if *any* performance improvement is worth writing code that horrible.
I've always heard meteor being called a "full stack" framework. Angularjs or Aurelia being front end mvc frameworks. React being a View only front end framework. Could you elaborate on if my understanding is correct?
Ugh, why would you want to do that? How did a and b get bound incorrectly in the first place? [edit: I added something, then removed it.]
~This is for the next version of Javascript, ES6. OP omitted the digit.~ Edit: My bad, /u/bitterschweet is referring to ccricers's trick, not OP's.
They didn't. There are indeed operations out there that require swapping variables. Sorting, state machines, etc.
Thank you. Sincerely. For your time. For this post and all previous posts on Reddit. Not many people take the time here who are knowledgeable.
It works now. I think originally he had a=... He changed it to b=... and it works fine.
I wish it were pattern matching. If it were, Javascript would be golden.
&gt; TypeScript has an unsafe cast operator, Flow doesn't. While Flow doesn't, it is actually possible to force a type, you can cast to `any` and then force flow to believe it to be any type you want: function assertNumber(num: number) {} let a: number = ("hello": any); assertNumber(a); // No error 
I think your characterization of typescript's typing is more-or-less accurate, but there's some important qualifiers. Typescript emphasizes, really more than anything, typing when it is convenient. As an example of this, how generics are handled aren't strictly bivariant. They're ... *compatible*-variant. Structural-variant? Observe: class A {} class Aprime extends A {} class B {} class Bprime extends B { public name: string } class Box&lt;TValue&gt; { constructor(public value?: TValue) {} } // duh var a1: Box&lt;A&gt; = new Box&lt;A&gt;(); var a2: Box&lt;Aprime&gt; = new Box&lt;Aprime&gt;(); var b1: Box&lt;B&gt; = new Box&lt;B&gt;(); var b2: Box&lt;Bprime&gt; = new Box&lt;Bprime&gt;(); // works var a3: Box&lt;A&gt; = new Box&lt;Aprime&gt;(); var b3: Box&lt;B&gt; = new Box&lt;Bprime&gt;(); // this also works - looks bivariant var a4: Box&lt;Aprime&gt; = new Box&lt;A&gt;(); // this doesn't, types are incompatible var b4: Box&lt;Bprime&gt; = new Box&lt;B&gt;(); // this DOES work, types are compatible var huh: Box&lt;A&gt; = new Box&lt;B&gt;(); I think you can see the same idea in `noImplicitAny` being off by default, being able to do casts that will *always* work, and so strongly emphasizing progressive typing. I actually think this is related to why typescript doesn't have much type inference too - it would be less clear when you want to progressively type versus when you want it inferred. However, I certainly wouldn't be upset over more type inference in typescript, and I'm happy that there's some healthy competition going on. 
That is correct. But even with something like meteor you can choose to use a different front end and not use their built in system.
How else would it do it?
thank god for `_.get`, eh?
Magic.
You should be able to use promises natively in node 4 and on. I also recommend looking into async / await if you're using babel and don't mind using ES7/stage-0 stuff. If you have something like this: function doSomething () { return new Promise(fulfill, reject) { fulfill("this is a value") } } You can call it using async / await like this, which makes it look synchronous. It's also super easy to read compared to going through the full promise flow: async function test () { let value = null try { value = await doSomething() } catch (e) { // this is when the promise is rejected } console.log(value) }
Thanks for that info. I should probably have gone through the source code before making that claim of 25%!
If an architecture already has Spring and Tomcat providing RESTServices for a Java application, could you see any reason to utilize another full stack such as Meteor or Angular/React/Aurelia + Express + Nodejs vs Angular/React/Aurelia within the Tomcat/Spring container to provide a WebUI front end for the Spring application? 
Most of the time, React components are just about displaying data, with couple one-liner event handlers that pass the information to your data processing layer (flux or the like). I see declaring data dependencies (`propTypes`) and lifecycle hooks as more related to displaying of data, and therefore belonging together with the 'templates'. I tend to use a data layer (currently mostly Reflux, looking to move to Redux in future) with immutable data structures in my React projects, and when you take an overview, most of the code in those projects deals with displaying data. The clear, unidirectional flow of data means that the usual web of event handlers, notification callbacks and information flow helpers just isn't there. A request for modification comes in, you fetch the current data state, apply modifications to it, output new state. Business logic ends. Rest is just how I want to present that new state to the user. That might be what's throwing your senses off, making you look for more code to separate. That, or your projects vastly differ from mine :)
A lot of great info here: https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/
Not unless it will be solving a problem with your existing solution.
I ran into this problem recently. My confusion was with the term "native promises". "Native" means check the MDN docs for Promises. You won't find it in the Node docs because it's part of JavaScript.
Nah, `t=a;a=b;b=t` is a character shorter.
Again, I don't know where I'd ever need this..
Then you haven't done much programming. Or too much programming without thinking. Or only extremely simple code. Or you like needlessly verbose code - and I mean "needlessly", because I sure don't mind verbosity itself when it helps readability and maintainability.
OPs statement creates a new array too, by the way. If I wasn't so goddamn lazy I'd write a tiny performance test comparing the use-temp-array method(s) with a simple temp-variable swap.
http://jsperf.com/swap-array-vs-variable/35 `variable` is an order of magnitude faster (sometimes Infinitely so, I'd guess because of some behind-the-scenes memoization), `destructuring` (OP's approach) is an order of magnitude *slower*.
[node.green](http://node.green/) has es6 features listed for different node versions, Promises have been in for quite some time. v8 4.9 has been merged recently in node.js nightly, so together with Chrome 49 we can now use most of ES6 without transpiler, only rollup.js is still needed !
I've only used Javascript for 6 months as a student and never used JQuery and I would like to try it, but I heard about VelocityJS, isn't it pretty much the same thing ? Should I only learn about JQuery or try to use VelocityJS instead ?
Yep. It's just results[JSON.stringify(arguments)].
Something I made to to verify data to &amp; from server during development. In our app, missing properties cause several bugs and it is hard to hunt them down. Suggestions are welcome!
An example is a function with multiple return values.
I've made it a point to always have a side project in something entirely different. I'm actually rather surprised by how much game development in a strong static language has impacted how I think about problems in JavaScript. It's a whole slew of different kinds of problems and restrictions than you see in JS development. One minor example from this week was when I finally bit the bullet and implemented a less than clever method for spawning enemies not too close to my ship. The JS dev in me was insistent that this would just kill my machine, doing so much trig *every frame*. But my PC yawned at it.
Same as this if I'm correct: let a = 'blah'; let b; // undefined a = a; // blah b = a; // blah
I'm pretty sure b would be a copy of a rather than a reference; I'm basing that on what Babel does though (creating temp variables), so I could be completely wrong.
You can also drink soup with a shovel, doesn't mean you should.
Yeah, JavaScript has first class functions. Just consider this: rather than mutating the variable you pass into a function, you simply return a new object that looks the same except with changes. In this way there are no side effects, no altered variables, but the state machine can still progress and the lists can be sorted. Here is some info on FSM and functional programming (not JS specific) https://www.quora.com/Is-it-possible-to-write-software-with-a-state-machine-using-Functional-Programming Here is some info on functional programming in JS https://www.smashingmagazine.com/2014/07/dont-be-scared-of-functional-programming/ And a functionally programmed router that I made as an example of some functional JS code, which i wrote as an excercise to try out functional programming in es6. I was quite skeptical at first, but after writing this I am pretty much sold https://github.com/whtevn/one-track/blob/master/index.js
You can't drink soup with a shovel, but in reality FSMs are actually perfect candidates for functional code because the state is easily considered in a single object. Passing that object into a function with information about the state you are moving to is natural, the only change in a functional algorithm would be that you would avoid altering the original, but instead mutate a copy. Really not that big of a deal. Sorting a list is the same thing. Same algorithm but instead of altering the list you return an updated copy. Functional programming is not that big of a deal. I don't understand why people cry about it so much. I assume most have never tried it but read some poorly written code one time and assumed it couldn't ever be good? I can't guess because it doesn't make sense to me. Typically a response is preferred to a downvote, btw. Like no one has ever seen messy imperative code...
Definitely not, all arguments in favor of angular 2 generally boils down to "angular 2 is better than angular 1". What about other frameworks, people? you know, I wonder about lack of react, vue, ember and aurelia in all those articles which praise angular 2. After comparing angular 2 and vue, I just can't choose angular 2 over vue. And if i actually need a full fledged js framework, I would go with emberJs(I don't know much about emberJs but it has good reputation) Anyway Until angular 2 actually gets mass adoption(hype and ads can't win my heart), I won't even consider it. 
you can post the 800th example of a fibonacci sequence function and then forget about using it ever again
Is that guaranteed to work in ECMAScript? In C, this would be undefined behavior I think, because it's not defined in what order the array elements are evaluated.
In our project where we are using this grid there is no restriction for row's height, but there is for minimal item width because we display some additional information about images
But mostly that last aspect ;)
&gt; Suggestions are welcome Hi, I wrote a library with a similar rationale (and API) https://github.com/gcanti/tcomb-validation, if you scan the issues you can get an idea of what people may want from such a library
 let {first,last} = {first: "John", last: "Doe"} ⇒ const _obj = {first: "John",last: "Doe"} let first = _obj.first let last = _obj.last you can also do: let {key: rename} = obj ⇒ let rename = obj.key
So in the first example, you're creating 2 variables (are they still referred to as that?), `first` and `last`? or is it some sort of array? The second example is confusing the hell out of my wary 11pm brain so I'll have to wait til morning before I can parse that in my pre-ES6 mind :)
You should not access the child's state from the parent. Instead, pass in props to the child from the parent that allow the child to communicate with the parent. For example, you could pass a function into the child that resides in the parent to assemble your query, and the child can call this function and pass through the arguments needed.
Yes, in the first example variables `first` and `last` are instantiated with the values of the of the corresponding property of the object on the right.
You couldn't be further from the truth. You haven't seen my code so don't make assumptions. I just couldn't see a need for it. A lot of the business problems I've solved haven't needed me to swap variables like that. But as someone else pointed out, multiple return values seems a good fit, but again, I don't really code in a way that I would need multiple return values, and when I do, I'd use objects anyway and just return the object.
When developing using Ember-CLI, this comes in very handy. You can import Ember and then set its internals as scoped variables. import Ember; const {Component, computed, inject} = Ember; export default Component.extend({...});
Cleaner code. Example: This: { props} = this.properties props.a /* do something */ props.b /* do something */ props.c /* do something */ Instead of this: this.properties.props.a /* do something */ this.properties.props.b /* do something */ this.properties.props.c /* do something */
yeah, destructuring can be a bit confusing, as it’s totally the inverse of object creation. it’s basically “extract several paths from an object and bind them to variables”: const obj = {a: {b: 1}} // store “1” as obj.a.b const {a: {b: val}} = obj // retrieve obj.a.b and store as val in the above case i stored and extracted one path, but multiple are possible. also there’s shorthand syntax involved, making it more confusing: const {short} = obj // ⇒ const short = obj.short something similar can be used for object creation: const obj = {short} // ⇒ const obj = {short: short}
yup: const {things, i, need, ...props} = this.props const stuff = compute_with(things) return ( &lt;container {...props} other={i}&gt; &lt;button onClick={need} /&gt; {stuff} &lt;/container&gt; )
won't `props` just equal `this.properties.props` in your example? Besides, you can just do `props = this.properties` to get what you're trying to do.
Yes. Angular 2 has hoped on the component band-wagon alongside React so all of the component-based application pro's apply to it and migration to native components when they land should be easy. It should be faster than Angular 1 and we'll have to wait and see how fast. The syntax is new but at least for the mark-up part is close enough to Angular 1 so that learning it will be no great obstacle. It will be available in either Typescript or ES6 and honestly the Typescript just makes building components very fast via it's decorators. React might look smaller but to be honest I can't think of a professional use case in which I don't need to something Redux like so if we're comparing we need to compare React+Redux+other things you probably need, so Angular seems to be a more complete package where you can see upfront what you really need. 
&gt; Meteor so where does redux fit into all of this? If I were to make a javascript app, would it be correct to say that I can replace MEAN with react+redux in place of angular, meteor instead of express, and any sql/nosql database in place of mongo? 
Okay I'll bite... this was the question you responded to: &gt; Python still not native in any browser, when will it catch up to JavaScript? a) "native" (webassembly != native python) b) "when" (something potentially/theoretically doable - if somebody actually does it!- at some point in the future: two uncertainties in response to "when"?)
While swapping variables is the basis of this thread, I don't see many doing it. It's like those weird lol gotchas of JavaScript that everyone complains about, but nobody uses. This time instead of complaining it's "look at this cool thing we COULD do."
There is just *one* temporary array ([yes that's slow](https://www.reddit.com/r/javascript/comments/499o7b/til_you_can_swap_values_in_es_like_this_a_b_b_a/d0qkud5?context=3)). The left side is *destructuring* (that's slow too - but that will hopefully change when JS engines optimize the ES6 feature set).
Based on my -10 score I'd take a guess that the JS community REALLY LIKES this particular gotcha. I think I offended someone by my lack of use case for this.
It's okay, sometimes /r/javascript is full of salty people and bandwagoners. Either they downvote you for not having the same opinions as them, or they downvote you because everyone else is. In one thread I got downvoted to hell for saying I understand ASI and don't use semicolons and use a linter on my code. Then I got upvoted to the top of the sub by submitting a link to a module making fun of users who are so obsessed with semicolons. Don't sweat it, it's just internet points that don't matter.
I swear it's the same few people flooding programming subreddits with blog spam and horrible attempts to monetize shitty content. Go away. 
Actually *any* side project is your most important asset. Language doesn't matter the least.
oh right, sorry. as for `props = this.properties`; The real beuty comes here: `{props, stuff, otherStuff} = this.properties`
You could try [Meteor](https://www.meteor.com/).
I don't think the author of the article was being sarcastic, no. He appears to know nothing but javascript, but anyone who is interested in computing in their spare time as well as on the job is demonstrating an attitude that employers will pick up on. It doesn't need to be javascript. If you aren't doing javascript by day then it might be a good choice, but having a breadth of domain experiences is a big selling point too, so you don't have all your eggs in one basket. If you are fulltime javascript and don't know anything else, you should really consider adding java or python or whatever to your skill set in your spare time. Even much of the tooling around JS uses other languages (i.e. C++ or python). I suppose JavaScript lost a lot of focus when it tried to "javascript all the things", when there are much more maintainable and performant things on the other side of the wire. It, as a community, had the opportunity to dig deep in the browser experience, but swerved wide, so monoglots wouldn't have to learn existing tooling or something.
In general the `g` flag is super evil for reusable code and should only be used with the `exec` method, where it returns all the matches at once. For methods like `test` that only return one result at at time, it has internal state of `lastIndex` that is changed each time you call it. As a result your first example `laterOn` is not a *pure function* that produces a result that is only based on its inputs. The regexp state acts as a history that can affect subsequent calls. Good luck debugging that! This StackOverflow post does a good job of fully explaining the behavior of the flag: http://stackoverflow.com/questions/1520800/why-regexp-with-global-flag-in-javascript-give-wrong-results
/r/jailbreak will be quite happy with this
there's a lot more awesomeness in es6. [es6katas](http://es6katas.org/) is a playground with all the major features... 
[Mithril.js](http://mithril.js.org) is pretty simple (about 30 methods, including ajax and a router), and it's used in production by Guild Wars 2, lichess.org, and a bunch of others. The community in the [gitter channel](https://gitter.im/lhorie/mithril.js) is active and friendly, and you can also message me if you need help. Mithril is smaller than Vue.js and and Riot, performs well, and you don't need supplementary libraries to do the basic task of getting data from the server onto screen. It is fully documented (i.e. has prose, examples and signature docs for entire API, guides from getting started to component architecturing, and documentation is versioned) and has a reasonably large ecosystem, ranging anywhere from [JSX plugin](https://github.com/insin/msx) to [material design](http://polythene.js.org/#/polythene) to [components](https://github.com/lhorie/mithril.js/wiki/Components#collections) to [integrations](https://github.com/catarse/mithril.postgrest) We use it exclusively at our company it and people have been able to pick it up fairly quick (some are fresh out of school). 
Something like this: function Parent() { function handleData(data) { // Do something with `data` } return ( &lt;div&gt; &lt;Child onTrigger={handleData} /&gt; &lt;/div&gt; ); } function Child(props) { function handleClick() { props.onTrigger(/* Send `data` to parent */); } return &lt;div onClick={handleClick}&gt;&lt;/div&gt;; }
This is really handy for extracting multiple variables from JSON responses shorthand, I use it frequently! E.g. let {fooData, barData, blahData} = JSONRESPONSE;
It looks confusing, not clean. It looks like array = array. :(
Oof, that syntax for observables is a bit verbose: var name = observable(); name.set('hi'); name.get(); // hi I remember way back when knockout was still popular and people were complaining that it was so much extra work to type this: vm.name(); instead of: vm.name; I can't imagine what those people would say about this: vm.name.get(); --- Anyway, if you're tired of transpiling JSX and don't feel its necessary to go full redux on one of your applications (or you desire something like databinding), I recommend mithril: var name = m.prop(''); const view = () =&gt; [ m('h1', name()), m('input', { value: name(), onchange: e =&gt; name(e.target.value) }) ]; m.mount(document.getElementById('container'), { view }); 
TLDR: we're a company not hiring any JS devs, please be kind and do that dev for us, for free.
You could use something like Flux / Reflux / Redux to manage your application's state. Think of these as just a way to manage an entire app's state as well as sanely update the state from a child component. If you need a one off solution for a single component, the answer from /u/MrSauceman works just fine. If you're going to need to do this for several components throughout your app it's probably a good idea to use one of the libraries mentioned above.
Hi /u/fahimulhaq, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `educative.io`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [educative.io](/search?q=%28and+site%3A%27educative.io%27+author%3A%27fahimulhaq%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|4|100%
You can also use with default params: const auth = ({ user, password, http = myHttpService }) =&gt; http.get('isvalid', { user, password }); Which lets you do interesting things, like export code that can have its dependencies mocked for unit testing.
That is literally the only thing JavaScript has going for it. As a language it is pretty piss poorly designed.
might want to start that sentence with 'well actually' next time
No.
remember to set your proptypes still though, you can set propTypes and defaultProps as properties on that function, like: ``` greeting.propTypes = { name: PropTypes.string, title:PropTypes.string, }; ```
You *can* drink soup with a shovel, though.
I'm just saying a shovel is more a replacement for a bowl than a spoon, is all. the code to deal with FSM functionally vs imperatively is barely the difference in a spoon and another spoon. it's the same code, slightly rearranged 
I can certainly imagine many places where a developer would put themselves in a position that would appear to require swapping variables, but as far as I can imagine almost all of them would end up looking like the code needed to be refactored for readability 
I don't actually have a life or friends so I disagree with this heavily.
To each their own. Some people put in a ton of hours, create great side projects, and are rewarded for their efforts. Some put in less hours but have more free time and enjoy themselves that way. Everyone has different things that they value and everyone has a different capacity for what results in things like burnout. This is coming from someone who works on a game in their spare time ~10 hours/week for the past 2 years. I have to be more choosy with my free time as a result but that works for me and I haven't burned out yet (knock on wood).
Can you use Joi with Express?
Most developers I have spoken with (including those who have side OSS projects) can't seem to figure out the productivity vs balance issue. I am thinking this is due to a lack of diversity. Corporate leaders don't seem to have this problem, neither do entrepreneurs, nor many people in completely unrelated professions. I maintain a side project that has been growing in popularity lately (almost a million NPM downloads just in January) and I have two unrelated careers. In my part time job I am transitioning from a leadership position to a technical principle (Army) and in my primary job I am a senior developer for a major travel company. I have this crazy school coming up soon for the Army job so I have to be in incredible shape. I walk 4.25 miles 2-3x a week with 5 pound dumbbells and a 40 pound backpack. This takes a lot of time and leaves me drained for much of the day. This isn't uncommon though. Alot of people who have physically demanding jobs or really stressful jobs have to frequently work out. You just have to make time for it. You have to figure it out. In addition to that I also have kids that have things like track events and choir concerts and other things to attend. Also throw in a solid 2-5 hours per week of really dedicated personal time playing games, exercising, talking, reading together, or other things. This takes additional time, but you figure it out. I also have the primary full time job that also takes time plus the commute. People love to whine about *work-life balance*, *burnout*, or *not enough time*. I know there are special cases out there where its not whining, but really for most people it really is just bitching. There is 24 hours in a day (that is a huge fuck load of time) and most of us only work 5 days a week (that is two full days to spend on productivity outside of the office every week). Because I have two jobs I get all my weekends off and I still make it work out.
It would be great to see things like this standardize on http://json-schema.org/
You didn't negate anything that he said. Also, ~10 hours/week is not that much, tbh. Side projects usually take up way more time than that for most of us.
Nice post, but I'm surprised you're using an unregistered copy of sublime. I've always thoughthought I'd buy a license if I started making vids cause the 'UNREGISTERED' is so glaring haha
Though I'd recommend not using the msx plugin. Mithril code looks just fine without it.
JQuery is probably the single most-used Javascript library in existence. Whether or not it's outlived its usefulness is debatable, but just based on sheer popularity I think you should learn it.
**b** is a copy of **a**; both are references to **something**.
&gt; most of us What is this "us"? Everybody is different, there is no us.
Actually, trkl's API is the same as Knockout's. I used the .get/.set syntax merely to make things easier to read - I'm not certain how familiar most people are with Knockout/Mobservable's API. I may just use Trkl's syntax through and through to avoid any confusion.
good idea about the defaultProps upfront, though sometimes the props you're taking in can get a bit long. &gt; And I would caution against using prop types unless your component needs that exact thing. Your mind immediately went to a string, but that's not necessarily the only way it could be used: &gt; Guess PropTypes.node covers that if you ~~intend your prop to be able to handle anything renderable~~ want to indicate your prop can handle anything renderable. PropTypes is self documenting and helps you communicate your intentions to other people using your components. It also provides free exception logging in the console if you pass the wrong type. Annoying though it might be.
&gt; The average JS developer spends 7 hours a week coding on the side Really? Dang, I must be lazy. That's almost a full working day.
Why JavaScript in particular, as opposed to any other language? Shouldn't you use whatever fits your needs?
I'm not sure either, I always feel a bit old bringing up things like knockout in this sub. IE6 support, wowiezowie. 
No trig required! Just additions and multiplications. You can even ditch the sqrt like I did here. myShipLoc = {x:100, y:200, z:20}; foeLoc = {x:40, y:-30, z:15}; MINDIST = 15; MINDIST2 = MINDIST*MINDIST; if (dist3d(myShipLoc.x, myShipLoc.y, myShipLoc.z, foeLoc.x, foeLoc.y, foeLoc.z) &lt; MINDIST2) { // Recalc foeLoc } function dist3d(x1, y1, Z1, x2, y2, z2) { delta_x = x1 - x2; delta_y = y1 - y2; delta_z = z1 - z2; dist = delta_x*delta_x + delta_y*delta_y + delta_z*delta_x; return dist }
If you look at code you wrote 2 years ago and are not ashamed then you aren't growing fast enough. 
&lt;sarcasm&gt; Come now. If you're not writing code in Javascript, you might as well not be a developer. &lt;/sarcasm&gt;
Apart from codeacademy, I've never touched JS. And apart from a couple of django and flask tutorials, I've never made a website either. I do develop code for what I need in my daily life (most recently an automatic résumé/cover letter generator), and for robots and things that interest me. And I think that that is good. edit: Missed the sarcasm tag.
Well, Riot has a bit of history of underdelivering. It originally was announced as a 1kb library with a "viva la revolution" tone against big frameworks, but it turned out to be a super thin wrapper around jQuery's `.on`, a simplistic wrapper around history.pushState, and a XSS-vulnerable version of underscore.template (they did fix the escaping issues after they were pointed out though). Version 2.0 was a completely different framework from v1, and the feel I got with that release was that if you were a v1 user and wanted to upgrade, well you're on your own and how hard can it be anyways. The v2 docs are clearly worded to leech off of React's popularity, but among virtual dom implementors, Riot is not taken seriously at all because its "virtual dom" implementation isn't really one. For starters, it has no keys algorithm, which is a hallmark indication of a poor quality implementation. Anyways, I wasn't the one who downvoted and I'm definitely not trying to shit on it, I'm just giving my point of view as someone who has followed Riot on and off. Riot was actually one of the inspirations for Mithril.js
The same reason other languages took decades or never gained a feature: Either the nature of the language's environment or current corporate ownership dictated a certain speed of update cycles (browser compatibility concerns being the major driving force in the development new js features. Until recently C++ took almost a decade for new language versions to be released). Or, the language's design philosophy dictates that a feature shouldn't exist or at least shouldn't exist the way it does in other languages (such as Go's lack of classical inheritance, or python's insistence on using exception handling system for non-exceptional occurrences). 
I didn't know much of the history of riot, but I always saw mithril and riot as being similar in philosophy, if not the details. Alt-react vdom libraries with a bit more opinion on how to structure and use your app, and enough "batteries included" to get up and going quickly. 
&gt; My main issue is that the web application will probably be maintained by other people in the future and I don't want to use something that will pose a big learning curve before they can do so. From the OP's post. Using a library or framework will make it easier for others to comprehend it and contribute. 
If you're looking to enumerate them via client-side code, the best you can do is look for DOM0 event-handler methods like this: function enumListenerMethods(node) { 'use strict'; if (node == null || typeof node !== 'object' || (typeof EventTarget !== 'undefined' &amp;&amp; !(node instanceof EventTarget))) { throw new TypeError('unable to have event listeners'); } var listeners = {}, matcher = enumListenerMethods.matcher, hasProp = Object.prototype.hasOwnProperty; for (var name in node) { if (matcher.test(name) &amp;&amp; hasProp.call(node, name) &amp;&amp; typeof node[name] === 'function') { listeners[name.slice(2)] = node[name]; } } return listeners; } // below was originally in the function, but pulled out to keep it under the V8 inlining limit // (600 characters including whitespace and comments) if (!(enumListenerMethods.matcher instanceof RegExp)) { (function (Object, undefined) { var temp = /^on[a-z][a-z]*$/; try { // exists in IE8 but throws unless called on DOM nodes Object.defineProperty(enumListenerMethods, 'matcher', {value: temp}); } catch (_) { enumListenerMethods.matcher = temp; } }(Object)); // try/catch confined to inner function, so outer function may still be optimized } // thus the regex is compiled only once There is no way for client-side code to enumerate oldIE attached events or DOM2+ event listeners, but many libraries (like jQuery) keep track of the listeners internally, allowing easy enumeration of handlers attached via the library. The other answers, about how to use the browser's developer tools to enumerate all event listeners, are much more robust.
This is pretty handy: https://chrome.google.com/webstore/detail/visual-event/pbmmieigblcbldgdokdjpioljjninaim It's a Chrome extension that will find event listeners for you and let you see what they are. If you don't want to use an extension, there's a bookmarklet you can use from here: http://www.sprymedia.co.uk/article/visual+event+2
&gt; Now that I'm looking for a new job (currently in contract) I realize I have to completely redo my site. If it works and it looks okay then it *doesn't matter* what the code looks like.
I'm the other way around! I find that game development in a dynamically typed language helps me iterate faster and just getting stuff done. In my day job I work with AAA game engines that can take up to half an hour to compile. On my hobby project, I type `grunt --deploy` to upload a new version to the web in a matter of seconds.
Well, in short it's all about Maintainability, Scalability and Testability -&gt; which all result into cheaper (faster) development (as a side effect more fun too). jquery/vanilla js gets out of hand fast if you're doing anything more complicated than a todo list (even then...) - and you can pretty much throw tests out the window and good luck handling state. Web devs are catching up to idioms used by app/game developers decades ago. Which makes sense since web sites are turning into web apps and the apps are getting more sophisticated and complicated. I'd recommend react with redux (sometimes called react-redux) mainly since I find the combination the most sane, simplest and most testable. But it's pretty 'bare bones' so keep that in mind.
I think that is based on people who answered the SO survey. I'm guessing those numbers are a bit skewed toward the high side. At my last job, I was one of few people who actually programmed outside of work.
Meh, a lot of interviewers will analyze the shit out of your code and dismiss you out of hand based on it. That being said, you might not want to work there if that is the case...
I would say that the vast majority of people performing interviews have never heard of you, let alone read your resume, until the first 5min of the interview.
In Firefox it's built-in (it's one of the few things that are better in Firefox dev tools than Chrome, in my opinion). You just right-click | Inspect Element and then in the DOM view events will be annotated (just like ::before and ::after) and you just look for the little grey boxes saying "EV".
Probably true. I generally apply/work for smaller companies where people usually actually prepare for interviews and you'll sometimes even get questions about your publicly available code.
Yeah, I was thinking that was a bold statement considering they say "the average programmer" and assume that every programmer responds to a SO survey (and truthfully to boot). 
Interesting! I do find it fascinating that you dismiss candidates out-of-hand if you find their publicly available code to be poor. Seems like an overly critical filtering system, do you have really large applicant pools? For myself, almost all of my code is held in private repos. Even my open source work is hidden away, most of it is infrastructure stuff and the repos contain 'secrets'. This, coupled with fairly conservative privacy settings make my Github profile appear inactive, which could totally confuse employers looking for an easy way to screen applicants.
Coming from a 20-year javascript background, it looks confusing, and it's a silly way to write code.
You could build a server side wrapper script: the js calls your server via Ajax, authentication by a session. Your server calls the API and forwards the result as the Ajax response.
coffeescript is a dead-end.
A) Make a server-side wrapper. B) Leave it as-is. They ask you for a domain at the registration so i assume that they block requests that doesn't come from your domain (this will block people that try to use your api key on their sites). 
An average of 10 hours a week is quite a lot.
Ill have to look into a server side wrapper. I haven't any experience whatsoever! Did think the same for B codestation, but I've checked and it doesn't matter what domain is put on the validation service's registration page. The key can effectively be used anywhere if known.
If you're worried that a future team are going to have to maintain it, go with something that is very popular to ensure there is a solid body of stackOverflow questions and blog posts covering all the pain points they're going to encounter. Don't pick something obscure but beautiful. The most elegant framework will not make a complex application simple, while a simple application is simple. Also, take a look [at todoMVC](http://todomvc.com/) as well, which has the same simple app implemented in dozens of frameworks. 
I've looked at code I wrote 10 years ago, and I'm actually pretty happy with it, for what it was and what it does it's not that bad.
Sometimes, lack of understanding how to evaluate a programmer in a language or framework agnostic way is probably why a lot of companies find more value in the latest fad language or framework. You'd find more language-agnostic technical interviews in the bigger companies, who have bigger wallets so they are able to mold talent regardless of their technical background. Other companies either don't have the resources to acclimate those people to their stack, or simply want exact talent they're looking for completely spoon-fed right to them.
&gt; You're also currently in a position where you just have to trust the clients word that they've authenticated their phone number How do you mean? Functionally its fine, security wise its awful. &gt; Thankfully it appears to be a pretty small job. I know, but I just thought the freelancer could guided me on a better integration solution!
I hadn't. I thought it was /r/programming.
I use Riot 2.0 for my own projects and find it pretty easy to get used to from React. Its way of using mixins for example makes a lot of things convenient. But I don't see it gaining a lot of steam. For lightweight view based frameworks Vue.js seems to be getting more popular, especially now since the Laravel team seems to have endorsed it.
Heh... it matters to me. :P 
Have you looked at contexts? https://facebook.github.io/react/docs/context.html
It's only confusing until you understand it, then it makes things a lot cleaner and easier. I think you're being a little prematurely dismissive here.
I specifically wake up at 6am (work doesn't start until 9 and I work from home), just so I can get in those 3 hours of programming. Then I often work on my own projects while taking a break from work (like right now). Then I sometimes work a couple hours after work Saturday and Sunday, I usually wake up a few hours before my girlfriend wakes up just so I can work on my current project. I wouldn't be surprised if I do 25-35 hours a week on personal projects.
two point validation, client side validation during form fill out. If that checks out, allow submit. Server side validation on processing, if that checks out.. do the operation.. otherwise bomb out and send back the errors. Client side public API Keys are fine, like google maps, stripe, paypal all have them.. its no big deal as usually the domain/ip is whitelisted on the api providers side and there is an associated private key thats used for more sensitive things like actually submitting data to the service. e.g. charging a cc. However, for the phone validation service that really should be wrapped with a server side endpoint script like others have said. I'd suggest doing basic formatting validation on client-side. You could also do an onBlur of the field to call the server side wrapped validation service but that is a lot more api calls for no reason. It looks like there is a rate limit of some sort with that service which you pay for so I'd suggest doing what I said with two levels of validation and a wrapper around their API. Simplest approach is ... 1. client-side validation while form is being filled out, just check formatting and required fields 2. on submit do the more in-depth validation like whether a record is unique or a phone # is valid using the service you provided then perform the action of whatever.
It was a valiant attempt. It's tough to get clearer than that in a programming related subreddit. 
It's worse than that. Starting a project in Coffeescript today is literally starting with technical debt. You have no upgrade path and no developer community behind you. Anyone still writing the stuff is misguided
Thanks Jafit, appreciate it.
&gt; its no big deal as usually the domain/ip is whitelisted on the api providers side To be honest I'm quite surprised it isn't! &gt;You could also do an onBlur of the field to call the server side wrapped validation service but that is a lot more api calls for no reason. Tried this when messing around before. It ended up sending double the api calls (as you say it will) so I just do both rule and api validation on submit. If one returns valid (either phone or email as valid but the other invalid), the api is not called again. Thanks for your help, appreciate it!! 
yeah for instance, Stripe's API has a public/private keypair. You use the public key with their js library which does basic CC validations like the right CC # to type, exp checking, cvv checking etc, Stripe returns a "token" if the validation passes Then on the backend you use their server-side lib and the private key to pass the "token" you got from the client along with price, currency, relevant customer info to their service. Which then does the charge stuff. The tokens are good for one API call only.
Sounds like a terrible interview...
Can't thank you enough! 
Glad I did a search on this in Reddit. I just saw an online course for CoffeeScript. After watching the first lesson I was going to ask the same question OP did. I found a video on Code School about Babel 6 and how it Transpiles from ES2015 (ES6) to ES5. And wow, it looks like it did a lot. I guess I should write in ES2015, use Babel to transpile, and eventually I'll be able to switch away from Babel for pure ES2015 front end?
I suspect that there are much more idiomatic ways to do the same thing in JS. This code does the same thing, but is much closer to what I think a JS dev is likely to actually implement. 'use strict'; var makeStore = data =&gt; {//encapsulate in factory data = Array.isArray(data) ? data : []; var fieldMap = { //field map knows type and can convert them too id: {index: 0, type: 'str', toType: val =&gt; val}, part: {index: 1, type: 'str', toType: val =&gt; val}, qty: {index: 2, type: 'int', toType: val =&gt; parseInt(val)}, date: {index: 3, type: 'date', toType: val =&gt; parseFloat(val)}, shipped: {index: 4, type: 'bool', toType: val =&gt; (val === 'true') ? true : false}, }; var get = (rec, fieldName, defaultVal) =&gt; { if (fieldMap[fieldName]) {//ensure field exists var val = rec[fieldMap[fieldName].index];//get value val = (val === '' &amp;&amp; defaultVal) ? defaultVal : val;//set default if exists return fieldMap[fieldName].toType(val);//convert to appropriate type } else { console.error(`No field name of type "${fieldName}"`); } }; var loadData = () =&gt; { this.data.push(["001", "A312C19", "88", "Mar 1, 2016", "true"]); this.data.push(["002", "B120X50", "", "Jan 22, 2016", ""]); }; var logRecords = () =&gt; {//When logging, use template strings over substitution if you can't use table. console.table(data.map((rec, i) =&gt; ({ recNo: i, id: get(rec, "id"), part: get(rec, "part"), qty: get(rec, "qty", "0"), date: get(rec, "date"), shipped: get(rec, "shipped", "false"), })));//Lispers should be proud of this.... }; //get must be spelled out because it is a keyword in ES5.1+ objects return {data, fieldMap, get: get, loadData, logRecords}; }; var store = makeStore(); store.loadData(); store.logRecords(); 
I have, and this is basically what react-redux does. I was wondering if it exposed additional ways to attach things, or perhaps if there was a better pattern.
I think either one is ok.
[removed]
I'm using cheerio for scraping html. I don't know if it's the fastest but it seems pretty fast. https://www.npmjs.com/package/cheerio. Also if anyone have a better alternative please enlighten.
Bills being voted for in the United States often have something called a rider attached. This is where a congressperson adds an addendum to the bottom of a bill that's sure to pass. Even if the rider is generally undesirable to everyone else, nobody will say much because the original bill is too important to keep postponing. MS is pushing very hard to make JavaScript into C-SharpScript. It makes a lot of business sense for them and they stand to gain quite a bit from pulling developers their direction. When you use typescript because "I don't much care for the class syntax, but the static typing is great", then you've put your weight behind not only the stuff you like, but the stuff you don't. This travels upstream ultimately and adds more force for things you may not like pressuring other companies to pass the good with the less desirable. Look at Babel. Want the new double-colon bind syntax, add it. Want to use flow's type system, add it. Want to try the class enhancement proposal, add it. If you change your mind, then change your code and remove it. Now look at Typescript. Want the double-colon syntax? Out of luck. Want a different type system (shoutout to [infernu](https://github.com/sinelaw/infernu) because types should be for the programmer instead of the machine -- unlike the TS types)? Out of luck because TS doesn't play nicely with anything but TS. Don't want those class changes? You're SOL there too because you can't remove them. When there's only one language to choose from, I believe that slow, organic growth is the only solution. I use JS all day every day. I want the best language possible.
A promising development is the [Salsa](https://github.com/Microsoft/TypeScript/issues/4789) JavaScript service. It basically means that some of the smart features of TypeScript, like type inference, can be used for regular JavaScript code and make for better tooling. VS Code is shaping up to be a very strong JavaScript editor. The plugin ecosystem isn't there yet, but if you're focused on JS/TS then you don't really need any plugins. And it's a refreshing performance boost if you're coming from Atom.
Thank you for your help and your comprehension :)
PhantomJS (http://phantomjs.org/) is decent for this type of thing. There's an abstraction on top of it called CasperJS which offers better bindings into phantomJS but I've not used either in over a year so not sure how they've progresses or stagnated since then. 
You're apparently unaware that the ECMAScript design committee has repeatedly cited Python as a primary influence for newly added features. I agree that saying JS is "catching up" is snide and wrong, but no less snide and wrong than (a) stating as fact that JS and Python are not becoming more similar (they are, if only superficially), (b) stating as fact that Python is not the inspiration for this new feature (it most certainly is, they told us it is), and (c) claiming we're talking about swapping values, rather than the application of destructuring assignment to swapping values, in order to facetiously call the new technique "common and simple". I feel like there's some sort of tribalism going on here, and that's the wrong mindset. Every language - even and especially the great ones - stands on the shoulders of what came before. A borrowed feature is something to be proud of - it's a heritage, not inauthenticity.
C'mon man, you get some gains from coffeescript. It's generally less code than writing ES3/5, and you get things like switch *expressions*, list comprehensions, chained comparisons, safe-navigation operator, and so on. Also, compared to a lot of the other compile-tos, it's still pretty similar to javascript, which you can't really say for ClojureScript, elm, etc. or even parts of Babel (looking at you, decorators). There's a reason it called itself "just javascript". I don't think you should start new projects with it in 2016, but we don't have to pretend everyone just became suddenly insane by using coffeescript when it was popular. It still has a lot of stuff javascript doesn't.
Coffeescript was never a good choice. Significant whitespace makes the code more difficult to read, coffeesript has plenty of ambiguities, it's never been as good as you claim it is. Transpiled languages should only be used for side-projects or research, not for production code. 
Javascript isn't going anywhere, but it's been evolving at a pretty constant clip now for the past few years. At the very least, we're going to see transpilation for the future edge features to compatible code for a while yet. I'm not sure how long things like JSX will last, but I doubt they're going away tomorrow. And the coffeescript argument still stands. Javascript still doesn't have a lot of the best parts of coffee, like comprehensions. It doesn't take a rocket scientist to see the impact it had on ES6, either.
Significant white space does not make code harder to read
X-Post referenced from /r/reactjs by /u/avindra [React.js v15.0 RC1 is out](https://www.reddit.com/r/reactjs/comments/49fxrp/reactjs_v150_rc1_is_out/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
I *think* I've run into a similar problem in the past (had a module that I wanted to make available that was constructed with some user specific state). I ultimately stuck it in the store due to the fact that, even though it didn't necessarily fit the model of the rest of my store (not a pure data structure, included some methods), it was in fact "state" and it was computationally inefficient to reconstruct as needed.
Yes the session can be manipulated. That's why the session is usually cryptographically signed on the server to ensure its authenticity. An alternative to that is to store the user's session in the db and then give the user a key (unguessable) that corresponds to the session in the db. 
Thanks Nitrodist. &gt; Yes the session can be manipulated. Whilst it can, it may be more suitable for my needs. I'm currently trying something out. Results after 6-8 weeks will lead me to either abandon or invest further. So I think the method using session authentication may suffice for now. &gt; An alternative to that is to store the user's session in the db and then give the user a key (unguessable) that corresponds to the session in the db. Would I be correct is saying the principles of the authentication are effectively the same as [ndboost's suggestion](https://www.reddit.com/r/javascript/comments/49elfu/securing_api_key/d0ra8aq)??
&gt; "NPM packaging is a killer-feature : simple and fast, light-years ahead pip+virtualenv." Highly Subjective
Follow their advice. My advice is not as pertinent. 
Doesn't TypeScript's `class` syntax match ES6 syntax? It seemed to me that, other than the type system, every other feature follows ES6 syntax. It may not have implemented everything that Babel has (e.g. double colon as you mention) but, as far as I know, the features it does implement, other than types/interfaces, would be compatible if you wanted to switch to Babel.
I code for an hour or two outside of work each day. It's nice to have a project that is all your own where you can make any creative or architectural decision on your own. Occasionally I feel the need to scale it back and relax in the evenings and mornings but for the most part programming is just as much a hobby as it is an occupation, which is why I feel so fortunate to have ended up here.
Meteor has honestly been my best experience with JS so far. But this JS ecosystem has so many random tools that it is honestly hard for me to wrap my head around in understanding which niche each of the tools actually solve. Meteor one stop solution. Want to roll your own? For front end MVC, AngularJS, Aurelia, Ember, Backbone? then throw React in there somewhere? Maybe use it with the others? then you got the CSS frameworks (stupid.css, framework7, semantic-ui, boostrap), then you got the backend, expressjs, hapi, Koa...that is if you want to use node...but if you want to put it in Nginx...tomcat...jboss? Hell I don't know any more.
Mine still shows no update available at 10.8
If you want to write Javascript then go ahead. If you write coffeescript, typescript, or whatever the fuck is the current buzzword transpiler, then go right ahead but you won't be writing javascript and you won't be contributing anything to the javascript community. Your code will be passed over by javascript developers, and eventually your project will become a dead-end just like coffeescript. Good luck with that. People looking for the new and shiny use Babel because they can't seem to concentrate on getting work done - they have to be 'current' or bleeding-edge, for no good reason other than to satisfy their own curiosity, not because it's a best practice. Transpiling comes with plenty of complications, none that make getting work done any easier. When can-i-use says all modern browsers support a feature, then I'll start thinking about using it, until then it's just not even important to getting work done.
I don't believe it is a step two. Just a secondary option. 
That's not what I asked though. Do you like bundlers and minifiers? 
Nope. Python is super easy to read. Write some JavaScript with no indentation, not easier to read than Python.
You don't edit minified code. I think you're trying to make a point that amounts to misdirection, because minification and transpiling are not the same thing at all. We're talking about SOURCE CODE here, not minified code, not bundled code. If you write your source code in a language that isn't javascript, then you aren't writing *javascript*. Period. End of story. Minfiers have nothing to do with this conversation.
&gt; You don't edit minified code. You don't edit transpiled code either. (Also, why so angry? Your tone is vastly more aggressive than anyone else in this thread.)
Yeah, that part I didn't agree with. Pip's new use of [wheels](https://wheel.readthedocs.org/en/latest/) are much better than the old egg format. Build once against the architecture *if necessary* and cache accordingly (and use the cache properly). CI builds still kill me with npm and fresh checkouts...
[removed]
I'm just asking you some questions, since I don't really run into anyone with a perspective as pointed and extreme as yours anymore. But hey, I totally understand why you wouldn't like coffeescript if you're not cool with babel or typescript. Also, I don't think it benefits you at all to communicate your opinions in such a negative way. Do you think you're going to convince anyone in here that one kind of code transformation is OK but the other isn't by calling me stupid? 
Good formatting. If you want to improve your code this is what I would do: * avoid global variables * make the canvas and score elements be parameters for the initialization function * make the initialization function create an object that contains all data needed for the game session (canvas element, score element, game state) * separate draw logic from game logic * decouple game logic from the rendering, changing the size of the viewport(canvas) shouldn't change the game play. * avoid using alert * don't reload the page if it can be avoided
It's a good thing I did not state any of those things then. You may feel that tribalism is going on, but I know for certain that you read things into what other people say.
Why are you using the angular injector manually like that, first off? Second off, if you want to use the injector with ng modules, you need to specify ng with it: angular.injector(['ng', 'mvpass.services'])
If all you know is javascript, it's natural to feel threatened by not-javascript
No, it has literals and things like a public and private keywords. Some of these are under consideration for ES8+, but that's a long way off.
Sure you can use a shovel as a spoon. Try it out or picture it.
I already presented my case as to why I thought they were similar a few comments ago. In response, you called me stupid and completely ignored the point. If anyone here is trolling, it's not me. :)
A bit unrelated but I'm interested in that Survive JS book the author mentioned. Is there a good alternative that covers Redux yet?
I need to set up some kind of blog.
Oh thank god they finally got code folding added. Will be giving this a shot again. Still feel it doesn't have anything that atom + my plugins cannot do but I do feel it's a bit more feature rich out of the box. 
You did say those things, but I guess you meant to say something else. If you'd like us to know what you meant to say I suggest you elaborate.
Now we just need indent guides.
Those are some good suggestions! Thank you! Some follow-up questions: * why avoid global variables? * can you elaborate on decoupling the game logic from the rendering? * why avoid using alert? * why avoid reloading the page? Sorry, I'm new to JS, and I just want to understand these practices and conventions. Thanks!
How about moving focus to the Play button after the user has lost a game so they can hit Enter and immediately start another? =)
You're completely wrong about saying transpiling has any resemblance to minifying - they are completely different domains, there is nothing similar about either process. How could you claim otherwise? One is compiling, one is compressing - these are not at all similar concepts. You're really trying to force an argument here, and you're doing a poor job with critical thinking. 
Thanks everyone for the suggestions, I'm going to be implementing a simple example in each of the suggested frameworks and decide on which one I want to proceed with, I'll make sure to update you! I guess I should've mentioned the biggest issue, the maintainers are technical support people and they work with different systems, so should a problem happen they won't bother learning whatever framework I use (Yea I know that sucks), they'll probably just immediately dig into the code and try to fix the issue, so something that is easily understandable by just reading the code will go a long way.
even better import Ember, {Component, computed, inject} from 'ember'
Avoid global variables to be able to protect the code you're working on and make it possible to name stuff. Your main.js file is 89 lines long and you name a little over 20 global variables. Most big JS apps are at least 10k lines, some are many many more. If a 10k line app was written in the same style, it would have around 2k variables that could all be accessed from anywhere in the program. Coming up with 2k unique and easily differentiable names is impossible. You'd have to remember if x, or y, or score are being used somewhere else, and you have to trust that whoever uses those variables in the future will understand what they do and won't mess anything up (people are really good at messing stuff up). On top of maintaining your own code, you're often including libraries that other people have written. Imagine writing an app when all of the code that you haven't personally crafted is globally scoped. Is x my x? Or is it the x that this cool plotting library I just installed is using? Better name everything mySuperCoolAppX, to make sure it doesn't conflict - and now we have some homegrown janky namespacing when we could use local variables instead. Decouple logic from rendering so you have reusable pieces. What if tomorrow you want to use SVG or WebGL instead of canvas? What if you want a variation of the game where players can control the % speed instead of automatically speeding up? Both of these things require an almost complete rewrite of your app as it is. Separating allows you to write new front ends for the same logic. Code sharing is a massive productivity boost. Avoid using alert and reloading the page because these are both terrible experiences for the user. Alert provides a OS level UI for interacting with a website, which is super sketchy and a scam trigger for most people. We can provide much better branded and beautiful UIs for conversing with a user. Refreshes remove all state that you once had. The people visiting your site lose their place, it wastes time and data to refetch the page and uncached resources, and it's a pretty jolting experience when the page flashes to white.
Here's a more compacted way to assign keys in native JS: document.addEventListener('keydown', inputDown, false); document.addEventListener('keyup', inputUp, false); function inputDown(event){ keyCodes[event.which] = true; } function inputUp(){ delete keyCodes[event.which]; } With this you can essentially then build a single function that handles key events as opposed to multiple functions separately for each key as you currently have. Keep in mind this is just a snippet of a code from a larger class that follows OOP. Also, this will register keys live, you should still determine how you want to write your delay into your input/etc.
&gt; 1 million objects = quite a bit of constant memory usage depending on what's in those objects. If the code was running on a mobile phone, the phone's memory could be depleted quickly. I think this is not the best example. Allocating a 1 million object array each time you call a function is not a good idea (unless you actually need to have a new array each time) for performance reasons.
You might want to use if/else if a little more. It will help avoid bugs like what happens when you score 15, and save you from having to type out redundant conditions.
Not to mention 90% of what you need is in the standard library already. 
Why is it a non-starter? BTW, it's quite funny for me how server side rendering is both 2016 and 2006 :-) Thin client-thick client is a neverending story :-)
Code folding?!? Please oh please
&gt; You're completely wrong about saying transpiling has any resemblance to minifying I can see several ways in which transpiling and minification are similar. The tools are written in similar ways (eg, parsing the raw code into an AST, applying transforms, etc.), they are used at the same point in the deployment process, they are used to work around the fact that web browsers are a mediocre application runtime, and they share many of the same drawbacks. For example: They make debugging more difficult, they can introduce bugs, and they introduce additional dependencies. It's rather absurd to say there are *no* resemblances and *nothing* similar about the processes. You seem to be trying to make an interesting argument (not a lot of hate for style sheet languages these days), but if all you're going to do is shout that you're obviously right, nobody at all is going to listen, because you're not even saying anything to listen *to*. I've read every comment you've made in this thread, and all I've learned is you think everyone else is stupid and/or arguing in bad faith.
&gt; Most people do not know how to manipulate the canvas off the bat. I've never learned canvas... Should i?
most of them are pretty useless, but there are couple of gems like: SequenceMap, Rating, Embed
Not really unless you want to make games or do some fancy graphic work.
[removed]
It's a shame the Rails crowd jumped on it too early, which means it will linger longer than it should have done in numerous Rails legacy apps.
Ah alrighty. Thank you!
&gt; Significant whitespace makes the code more difficult to read Python developers would disagree there.
Still not sure. Angular 2 seems overly complex from a distance, even for someone like me who is coming from Angular 1. But at the same time the current React 'ecosystem' is a nightmare of dependencies and configurations. One thing worth noting in favour of Angular 2 is Typescript. It is truly amazing and a real game-changer for (large) projects, especially when combined with Visual Studio Code. It may look daunting at first, but once you get used to working with types there really is no going back. It has a huge impact on the general developer experience and the confidence with which you write code. 
Skate to where the puck is going, not to where it has been :). Which is a fancy way for saying: coffeescript is dead, use Typescript or ES6/Babel. 
for some reason I cant make it work, i still get "any" type, I just got 10.10, am I doing something wrong? http://imgur.com/xdFSFMk *the string there is just for testing, didn't work as well.
The plugin ecosystem will never be there because it is a Microsoft product. Look at Windows Phone.
https://addyosmani.com/resources/essentialjsdesignpatterns/book/
Yes. This can be done in JavaScript. jQuery is a JavaScript framework, so you may be able to use it in some creative way. However, it's probably better to learn how to do it with JavaScript alone. I would recommend using a testing framework - like Jasmine - to test drive your development. 
I can't speak for the above, but it ran quite slowly on Safari on iOS, iPhone 5C. Quite cool though 
Maybe that explains why I was able to get the types to appear in the issue I reported. You still didn't get the "Adds stuff" description to appear in yours, so it's not quite working right either.
&gt; I'm sure if you used a Python-to-JS compiler, you would get Python in the browser more easily than with using ES6 with Babel and Webpack or whatever. You speak as if it's so hard to get babel working... The amount of time it would take to find a Python-to-JS compiler and learn how to use it, is 10x as long as it'd take to npm install babel-core, babel-plugin-es2015, and create a .babelrc file.
No, it cannot be done. http://codepen.io/anon/pen/vGGBKO
Definitive ... Anyway, got a small chuckle out of me.
I have this book. I haven't re-read it recently, but I remember the editing being a little rough and some parts of it being really more aimed at intermediate or advanced JS folks. /u/segmentationfaulter, are you looking for something more at the speed of beginners or intermediate?
Is this meant to show off cocycles? If so, you might be better off writing a quick blog post than just linking to a search result page without any context.
`print thing` is also no longer a thing, `print` is no longer a statement since python 3.
Just sharing a perspective - I had been a js fan all my lifetime. When I tried coffeescript a few years ago, I did not like it much and lack of braces made it harder for me to separate out functions and sometimes an unintended tab would cause compilation issues. But, after I wrote an application on RoR, I started liking the family of Coffeescript, Jade and Stylus (without braces) and have ever been coding in these 3 techs for all my projects. At the end of the day, everything gets compiled or transpiled to js and gets minified and bundled. It does not matter what the world likes, but if you and rest of the engineering team likes it, then go for it. Any library/framework out there is not going to satisfy all your needs and there is never going to be a library/framework that will last as the best one forever. This space is so evolving that anything new is easily getting outdated within years. Since most of them are open source, you can extend or adapt the components to your way as an when you need them. Keeping your codebase clean and structured is the most important part :)
Okay, sanity check: 1. This library vendors in *minified, unauditable* code. This is extremely dangerous. 2. It doesn't clearly explain the algorithms used, or why, or how, or even where the implementations come from. 3. Uses RSA, which is notoriously difficult to implement correctly, even when just writing a 'wrapper library'. 4. No security proofs whatsoever. Sorry, but this is almost a textbook example of "rolling your own cryptography", which is a *very bad idea* ([more](https://security.stackexchange.com/questions/18197/why-shouldnt-we-roll-our-own/18198#18198), [example](https://kivikakk.ee/cryptography/2016/02/20/breaking-homegrown-crypto.html)). Don't use this, and to the author: please do not publish it, or at the very least put a __"DO NOT USE"__ warning in big, bold text into the README. Seriously, please just use an existing implementation of libsodium/NaCL (for example, [this one](https://github.com/wilhelmmatilainen/natrium-browser)), which are designed for precisely this same purpose, by an experienced cryptographer, and in a way that makes it hard to use them wrong.
Thank you!
the return description here only shows before entering the () when writing the function name
Why you say It cannot be done? O.o
Yeah, I see your viewpoint. Wouldn't probably use this pattern myself for properties though (you should usually 'know' what kind of data is in them), and utility functions that take a date either as Date or string should clearly mark that in the declaration. 
 Sure: function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } var poolA = getRandomInt.bind(null, 1, 5); var poolB = getRandomInt.bind(null, 5, 10); var poolC = function() { return 0; }; function getSelection(pullFromPoolC) { var toReturn = { a: poolA(), b: poolB() }; if (pullFromPoolC) toReturn.c = poolC(); return toReturn; }; Now you can append the call from `getSelection()` to the document and style it appropriately. e: typo
Is this a Node alternative for Linux?
Just to be silly.
Sorry, but you too are narrowing down a lot the definition of code quality. Once again, depending on the context, code quality could mean: highly readable and robust (what you and I prefer), like team-built business applications. Or as fast as possible (but not readable; perhaps sprinkled with lots of comments), like brute-force decryptors, signal processing or competitions. Or a small as possible, like highly constrained embedded systems.
Not condescending at all, I completely understand what you're getting at and sometimes I do need to take a break from programming for a while. That mostly happens when I run out of ideas or I'm preoccupied with something else though. I have a lot of side projects I like to hack on and I try to keep learning; I like to be hire-able. (note: my work ethic is not tied to whether or not I'm burnt out with programming, I work hard everyday regardless because that's what you do when you have a job)
Looking for feedback on this. I extracted it from a project and I'm not sure if it's useful for other people. It could also just serve as an example of using GSAP with ReactTransitionGroup. I couldn't find a ton of information on it when I started this project. Basically, it's a light wrapper around ReactTransitionGroup and TweenMax. It lets you extend your components from this class and just supply some TweenMax properties for the Enter and Leave events. Any time the item appears/disappears from the ReactTransitionGroup it will tween itself and let the parent component know when it's done. You can also specify index/total properties for staggering. Doing so will only notify the parent component only when the last item has finished it's tween.
Can you please link this to JSFiddle for me? I'm currently out and wanna give this a quick check and Implement when I'm back home! Thanks for the code though! ;D
Lol Thanks! :D 
Can confirm. The longer we use Sequelize, the less I like it. Looking at my old projects using raw SQL, they look a lot better. Also, imho it is easier to generate performant queries when writing them themselves than when using an ORM (especially Joins are pretty ugly in Sequelize in my opinion). Next project I will probably go the middle ground and use something like a query builder. Flexible like raw queries but hopefully not that error prone.
Anytime!
You might want to try [Bookshelf](http://bookshelfjs.org/) (or just straight [Knex](http://knexjs.org/)). I didn't look too closely but, given the similarity in syntax, I wouldn't be surprised at all if Nodal is using Knex under the hood -- although probably not, or they would already have support for things beyond Postgres.
the script is obfuscated to make it harder for antiviruses to detect it and people to analyze it it downloads an executable file, saves it as `%TEMP%/augmentWidthOrHeight.scr` and runs it here's the virustotal report for the file it downloads: https://www.virustotal.com/en/file/ddf646e2527f4f1a8cd8904e85ca92a569a1f4d8cbdfb318746c50426df8540b/analysis/
Thank you!
I will say this: there are no tasks that can be accomplished by swapping variables that could not be accomplished by other means. or, stated another way, swapping variables is never required except potentially as a memory-saving measure, but that would need to be demonstrated before I would believe it. in terms of applications that are normally accomplished with javascript, either in node/io or the browser, there is no good reason to swap variables. It is not necessary and makes code difficult to reason about.
there is a difference. I asked you what it was. you made this about drinking out of shovels, not me
Thanks! I tried this -&gt; for(var i=0;i&lt;4;i++) { var currentSelection = getSelection(true /* false to not generate 'c' */); append(currentSelection.a, 'red'); append(currentSelection.b, 'blue'); if (currentSelection.c != null) { append(currentSelection.c, 'green'); } } This generates a zero every time where as I want either only one zero or none! Any fix?
Since we're still not backing up claims, then I will say this: there are tasks that can be accomplished by means other than swapping variables, but that won't necessarily make it more readable. In terms of javascript applications there are indeed plenty of reasons to swap variables. 
But this thread _is_ about drinking soup with a shovel. How is it not relevant anymore?
The variable you pass to `getSelection` will determine whether or not you get the `c` pool to be generated. Try calling `getRandomInt` if you want to make it random.
what reasons would those be
Is architecture/framework dependent. We can't guess at how your application is built without examination of the code.
It's obfuscated, but nothing a good old rename for the silly variables and REPL for the safe mathematical stuff (which in most cases is a long line boiling down to something like `0` or `false`) won't fix. Anyway, enjoy [the fruits of my labour](http://pastebin.com/veQqV3VF). Hope it helps. As a small point of interest, Windows Defender started raising a ruckus the instant I finished. +| ha, all that work and /u/-epicgirl1998- beat me to it with a saner approach. Oh well, I had fun :) +| Small but important correction: last line should have `path._return_this_()`, not just `path._return_this_`.
Soon (in v2.0.0-alpha.3) examples will become more real and both Katana and Shuriken will implement IWeapon instead of using single-implementation interfaces.
 for(var i=0;i&lt;7;i++) { var currentSelection = getSelection(false); if(i==0) { var currentSelection = getSelection(true); } append(currentSelection.a, 'pool-a'); append(currentSelection.b, 'pool-c'); if (currentSelection.c != null) { append(currentSelection.c, 'pool-b'); } } This Works! Thanks!!
I totally hear you on the jsrsasign tampering thing. I think setting up a build process to create cryptoidentity.js the same way I do manually could help alleviate concerns. Asside from that, it really depends on how jsrsasign is trusted or not. 
Jest might be easy to set up, but it's literally 10x slower than other testing frameworks, and just wait until you want to debug a test. Step thru debugger beats print statements every time for getting shit done. You can run other frameworks on the command line, of course, but you have the *option* to run them in the browser and use Chrome's debugging tools. Not so with jest. If you have 10 tests, it's probably fine, but we had hundreds, soon to be thousands and it was a huge pain point. Luckily we almost have it entirely removed from our setup (at work). Good luck with the framework though!
Hi /u/murkin, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `blog.500tech.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.500tech.com](/search?q=%28and+site%3A%27blog.500tech.com%27+author%3A%27murkin%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|4|57%
Hi /u/kuzzmi, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `kuzzmi.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [kuzzmi.com](/search?q=%28and+site%3A%27kuzzmi.com%27+author%3A%27kuzzmi%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|7|70%
From the release notes: &gt; ## Source Code Folding &gt; The editor now contains a first implementation of code folding. You can turn the feature on and off with the editor.folding configuration setting (File &gt; Preferences &gt; User Settings or Workspace Settings). Once enabled, you can collapse and expand code regions using the folding icons next to the line numbers. Regions that can be folded are shown with a - icon, regions that are already folded with the + icon. The - icon only shows when the mouse is over the gutter.
It's bare JS runtime for microcontrollers with low flash and RAM.
Yay the internet of shit
The answer to the riddle? Let's see um, I guess the difference is that heaven and hell are the same? 
Agree with your post, definitely not a misunderstanding of Javascript but a misunderstanding of promise collections and how they are processed. I spent a few hours this weekend buffing up on why my solution didn't work, and I've provided a new working solution that addresses your concerns. Thanks for the feedback.
As the matter of fact, you may be right. In Javascript, it seems like the most relevant case to swap variables is during sorting. Meh, I know I've done it in the past for games and stuff, but I should probably check that ancient code and either marvel at my cleverness, or throw up at my naivety. Edit: typos.
what should it do more than React-Native already does?
I like submitting microlibraries that are topics of conversation and potential investigation. 
fieldMap is defined the same as it was in 1999, we just have arrows now :)
&gt; the gaining of features at a later date that are known to exist in some other language does not, BY ITSELF, imply that either language was copying (or trying to copy) the other language I see that and I agree with it. What I was objecting to was that it determines the relationship here, which is implied by your bringing it up here. &gt; swapping of values in a computer program, no matter how it happens, is a common and simple operation Agreed, but I think that simple problems can have conceptually complex or refined solutions, even when not over-engineered. Destructuring isn't something that occurred to me before I was taught it. That doesn't mean it didn't independently occur to these groups, but it's my reason for doubting it did. &gt; it is incorrect to assert that A must have copied B due SOLELY to the existence of a structure in A that are similar to B's structure, yet B contained that structure earlier than A. I agree. &gt; That is why I made my comment, because the logical flaw implied is a bad idea. I see your point, and I agree that it's important to see the flaw in that line of thought. I think you see my point too - that in this case, the feature was copied, though we know it for a different reason.
Ive been using this: https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow. They look cool together.
Another good step forward in making Atwood's Law happen: "Any application that can be written in JavaScript, will eventually be written in JavaScript."
I'm a huge fan of CoffeeScript and still use it for a personal project, but I agree that ES6/7 will mostly replace it in the long term as they took a lot of ideas from CoffeeScript. I disagree that it's completely dead, there are still some big projects/companies that use it, for example GitHub.
My gosh, that site looks like it's from 1998. Edit: OMG, It IS from 1998! http://imgur.com/uF5tvvZ
&gt; since it's a char rather than a boolean that must mean there are several options with a varying degree of permissions. That's a pretty big assumption to make, 0 and 1 are commonly used as booleans. There might be some underlying legacy reason they use 1 and 0 for that value even though a 'real' boolean is available.
Indeed. one and zero are much faster to process than "Take a string, normalize it's case then convert to a bool"
hmm not really haha why is it: "for loop will always start with i = 1 (unless num &lt;= 0, then it won't start at all)"? the Fibonacci sequence is 0, 1, 1, 2, 3, 5 etc. in this case i=1 and num is 54, so the loop starts with 1 and goes up to 54. If num would be smaller than 0, how would that work? Why is On first pass, first if condition is (1 !== 1) ? if (0+1!==i) adds 0 and 1 and looks if its not 1 (then its not the Fibonacci sequence and returns no. If it is 1, then it goes on to if (i+ (i+1)!==i+2), then to if (i+ (i+1)!==i+2) and so on up to num and if at any point it would not match the Fibonacci sequence., it returns no 
Yes I too feel the issue with desktop site, Its take some time to load up the segments. My bets are on the top cat advert loader which blocks / defer the main image loading most of the time.
Your logic is all wrong here. I'm not sure what you were going for but you aren't going to arrive at a solution this way. I would first work on figuring out how to generate the fibonacci sequence in general. Once you get that, try to work out how you'd efficiently determine if the supplied number is in that sequence. I'm not going to spoon feed you a solution and I'd highly recommend you ignore the other people that are doing that. You won't learn anything by just copying someone else.
Don't guess, read the relevant standards: [Tracking Preference Expression](https://www.w3.org/TR/tracking-dnt/), [Pointer Events](https://www.w3.org/TR/pointerevents/), [client identification](https://html.spec.whatwg.org/multipage/webappapis.html#client-identification). In the case of the latter, `appName` is always "Netscape" by definition. These date back to prehistoric times and are totally deprecated. All browsers report what Netscape Navigator reported in 1995 because they have to for compatibility. 
It'd probably be better without that stupid fucking cat arm interrupting me.
Complete with Jerry-rigged security?
Well, back then all I had was a Casio PB-300 with 1K memory, I think. So cleverness was a requirement.
I can think about three good reasons: ### 1. Real decoupling: Some JavaScript IoC containers out there declare the dependencies to be injected as the following: import Katana from "./entitites/katana"; import Shuriken from "./entitites/shuriken"; @inject(Katana, Shuriken) class Ninja { // ... The nice thing about this approach is that there are no string literals. The bad thing about it is that our goal was to achieve decoupling and we just added a **hard coded a reference to Katana and Shuriken** to the file in which Ninja is declared and this is not real decoupling. InversifyJS offers you real decoupling. The ninja.js file will never point to the katana or shuriken files. However, it will point to the interfaces (at design-time) or string literals (at run-time) which is admissible because these are abstractions and [**depending upon abstractions**](https://en.wikipedia.org/wiki/Dependency_inversion_principle) is what DI is all about. The price to pay is the string literals but this price can be mitigated if you declare all your string literals in a file which contains constants ([like actions in Redux](https://github.com/reactjs/redux/blob/master/examples/todomvc/constants/ActionTypes.js)). The good news is that in the future the string literals [could end up being generated by the TS compiler](https://github.com/Microsoft/TypeScript/issues/2577), but that is in the hands of the TC39 committee for the moment. ### 2. All the features that you may need As far as I know it is the only IoC container for JavaScript that features complex dependency resolution (e.g. contextual bindings), multiple scopes (transient, singleton) and many other features. On top of that there is room for growth with with features like interception or web worker scope. We also have plans for the development of dev-tools like browser extensions and middleware (logging, caching...). ### 3. Type safety The library has been developed using TypeScript so type safety comes out of the box if you work with TypeScript but it is nice to mention that if you try to inject a Katana into a class that expects an implementation of IShuriken you will get a compilation error.
That's kinda how I feel about classes in ES6.
An iterative method is probably what is asked for, but this property of Fibonacci numbers is slick: https://en.wikipedia.org/wiki/Fibonacci_number#Recognizing_Fibonacci_numbers (Also, I think your function should be expecting a number, not a string that represents a number.)
This looked very familiar at first and then I realized you are the same person [who has this](https://tofuness.com/projects) in his list of projects. Cool to see that you expanded on it.
Ah I recognised samccone's little hat face from the picture. Big contributor on Marionette, in case anyone is curious. (And works at Google, which is probably a bigger deal...)
one of my favorites. suitably, was adapted from this https://en.wikipedia.org/wiki/Allegory_of_the_long_spoons
I see that it's an expansion of your sine wave dots project, but then I realized you used a 3D transform on the canvas now, which is probably why this runs slowly in comparison to the sine wave dots.
I don't tend to worry about diving into any particular technology unless there's a specific problem to solve. I'm usually subjected to a steady dribble of problems, so it's only a matter of time before the right opportunity to learn a particular something new arrives. This also keeps me learning things relevant to my job, I don't pick things up unless I need to (or unless they're interesting!). This is the aforementioned "Learn something, build something" territory, there's just no better way to dig into something than to solve real problems with it. Any time I pick something up away from real projects, it tends to go in one ear and out of the other. However, the layer above this is what I think you're referring to. For me, it's just a bunch of mental notes of names and top line ideas of what things might be useful for. For this, I like developer conferences (so much good content to be found, year after year), podcasts, and TBH just general browsing around (it's why I'm here now) to see what people are talking about. Even just stowing away a single line "A JavaScript library for building user interfaces" will give you an insight into what React could do for you when confronted by a particular problem to solve. I do keep a paid sub or two rolling, but this is usually due to something I've had to mug up on (and afterward making the most of a month by tapping a sub for everything that takes my fancy), or just down to personal interest (because I love this shit). I hope at least a bit of that was useful. I tend to delete more posts than I write but I thought I'd let this one fly.
I do know what the fibonacci sequence is and i am asking questions SO I understand it.
So you understand the fibonacci sequence but you don't understand why this if statement will never be true? `if (1 + i!==i+1) {` 
No lmao Panda is a real thing, pretty nice actually!
Also I keep getting m.imgur.com pages on desktop because people link to them, which I find really fucking annoying. In fact, I hate the m.* mobile subdomain convention. And I hate imgur. So all in all, not a great blend.
Very helpful and insightful! Thanks a lot! Just curious what paid subs?
I remember imgur clocking in at over 1.2gb of RAM on Chrome on my 16gb MBP once. It's probably not at those heights any more, but it used to utterly cane my resources.
Will this work if the phone is locked and in a users pocket? My guess is not, which would pretty much rule this out for making a pedometer.
As someone who regularly browse Reddit on a phone and tablet, I despise the gifv trend. I'm probably listening to either music or a podcast. An HTML &lt;video&gt; element, when played, will pause whatever is already paying, which is frankly terrible. Chrome on my tablet also just cannot play imgur's gifv for whatever reason, meaning I have to manually edit the URL and change .gifv to .gif. Of course, that doesn't give me a nice gif, it just redirects to the image's main page, where if my tablet is in landscape mode, the gif is probably a bit taller than my screen. If it had just given me a fucking gif file, my browser would have scaled it perfectly automatically.
&gt; The user could keep their phone unlocked when it's in their pocket. Realistically, that's not going to happen :) 
It's more of a REALLY good wrapper for react native. It handles running emulators, publishing projects, and handles some ota updates depending on what's changed. Siphon looks really nice to develop with.
Super cool! There's some really interesting stuff here: https://github.com/tofuness/eex
No, it's because GET'ing is one the best ways to traverse any network, it will almost always go through, will work in any reasonable browser. So it still works, is time and battle tested and requires no workarounds. Seems like a pretty good solution to me. What do you see being improved by using POST?
Large enterprise SaaS product. Hundreds of modules. Less than a second sounds nice. :)
Thank you very much for the comment, that's exactly what I am looking for and it's nice to see that you're not finding any glaring issues with the code as it already is (I hope). I was wondering what your thoughts were on the `commitFiles` function, is there any way it could be improved?
&gt; What do you see being improved by using POST? Nothing improved really, just making it easier to post a complex JSON object than to flatten it out in url variables We are implementing our own and I had never really thought about this until today
That's perfect feedback, thank you very much. return Promise .all([getRefSHA, postBlobs(files)]) .then(([refSHA, blobs]) =&gt; repo.postTreeAsync(blobs.map(getBlobData), refSHA) .then(treeSHA =&gt; repo.commitAsync(refSHA, treeSHA, message)) .then(commitSHA =&gt; repo.updateHeadAsync(branch, commitSHA)) .then(commit =&gt; commit.object.sha) ); ^ That is just beautiful.
I think you might be able to remove a level of nesting as well (but you'd have to determine with what is closing over what): return Promise .all([getRefSHA, postBlobs(files)]) .then(([refSHA, blobs]) =&gt; repo.postTreeAsync(blobs.map(getBlobData), refSHA) .then(treeSHA =&gt; repo.commitAsync(refSHA, treeSHA, message))) .then(commitSHA =&gt; repo.updateHeadAsync(branch, commitSHA)) .then(commit =&gt; commit.object.sha);
I always thought it was an integer 1 and 0 that are used as booleans. But then again a "number" can vary in byte length such a long that happens to equal 1. But anyways, I am assuming that if doNotTrack:"0" must mean I can use GeoLocation right? 
It doesn't just defeat the purpose, it's decidedly not responsive design. Responsive design rose in popularity as a result of the inadequacies of practices such as mobile sub-domains.
Thank you. And assuming what you said was true about the expressly stated desire to copy this feature, then python would in fact be the source.
To me it sounds like either you have too many dependencies that jest has to rely on and thus you split up your front end JS into smaller testable modules or maybe this isn't the right tool for you.
It says it only works with es6 modules and not require() statements. Does that mean using require() is just fine as it is?
I don't see why not...
I didn't know there was an idiomatic JavaScript
This is an Android problem not a gifv problem ( which should just be webms what the fuck imgur ). This is coming from someone who uses Android and browses reddit outside of Google's shit mobile browser so doesn't have these problems. 
Hrm, I think this is a mobile thing no? I could have sworn apple's interrupt audio too when playing a gifv. I'll have to test that later. =/
Since you are writing in a functional style you should be able to write a good battery of unit tests. That would be the next step for me.
Which is what I said. Defeats the point (not purpose)
OK, but *why*? If you wanted a level of indirection, why not just have another module? We already have dependency resolution through modules. They also let you write pretty unit-testable code. Typescript also has the ability to import types from modules, especially if they were also written in typescript. What concrete problem javascript developers face is being solved by DI? 
I just wanted to know how it is managed usually or the best practice.
Remember that a 'return' does exactly that. It returns something to the caller of the function. If all possible avenues in your loop have a return in them, then you'll never actually reach the bottom of the loop and actually repeat. This is the big misunderstanding here. How you think your loop is working, and how it's actually working. Try putting print statements in your loop that show you the values of count, i, etc to help you see what it's actually doing. I would recommend taking another approach: write a function that generates Fibonacci numbers. Have it take a number as input and generate Fibonacci numbers until it hits the input number. (Use prints to make sure it's working) Once this works, you're 90% there. Now just modify it to check the generated numbers against the input. If the number is less than your input, keep looping. There is still potential for a match. If the number equals your input, return "yes" because you have a match. If the number is greater than your input, then you've exhausted all possibilities and should return "no". 
Thanks! The project is under development at the moment so if you spot a missing feature, play around and find some bug, etc please contact the development team using the GitHub issues. All kinds of feedback is highly appreciated :)
I have updated my SO post with how I ended up fixing it
If you don't understand what it means, you should learn about it, just understanding what the sequence is, it's algorithm and why you use it will help you out here. This isn't so much of a programming problem as it is a "research your algorithm" problem 
Sounds like observables to me. Here's some [trkl](https://github.com/jbreckmckye/trkl): const first = trkl('jane'); const last = trkl('doe'); const full = trkl.computed(() =&gt; `${first()} ${last()}`); console.log(full()); // 'jane doe' first('james'); console.log(full()); // 'james doe' I honestly don't like the term 'reactive' at all. 
If you don't mind wrapping all of that in an object, getters and setters might be enough to achieve what you need: var props = { x: 1, get y () { return this.x * 3; }, get a () { return [this.x, this.y]; } }; props.x = 10; props.y; // 30 props.a; // [10, 30]
Check out: https://github.com/cujojs/most
That's not impossible in JS at all... [use functors](https://youtu.be/YLIH8TKbAh4?list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84). Either that or im not understanding something.
Cool. Looks like building a variation of pipeP/reduce is what you went with? But since the promises aren't composed, but instead are meant to be merged, something like this would also work: Promise.series = (promiseArr) =&gt; { return Promise.all(promiseArr.map(fn=&gt;fn())); }; //Promise.series([thunk1,thunk2]) Or, if you have ES6 and want to more easily cut out the extra [] when specifying the arguments (though that would make it less like the Promise.all syntax) Promise.series = (...promiseArr) =&gt; { return Promise.all(promiseArr.map(fn=&gt;fn())); }; //Promise.series(thunk1,thunk2)
Hey that is pretty nifty.. would like to see Babel support?
first two answers are synonymous. third, is just a left over. Normal JS is working fine.. I've reach out to the library dev to see how this behavior can possibly be.
I think each person learns differently, but it seems that to really cement that knowledge, you need to build something. I personally prefer to combine the efforts. Then you also can usually reevaluate at the end and get a valuable refactoring step which teaches you even more.
Sorry, its just a slop of an example. Real world javascript is fine with no typos But i was trying to do this in a krpano plugin where inexplicably getting the object name from the argument doesnt work. May have something to do with strings,values,types etc.
&gt; look more like Arduino Not sure if trolling.
It's satire. &gt; By Rick Astley, POS News Service San Francisco Bureau
ES6 will eventually become standardized and you won't have to use Babel or whatever.
I can't understand why they don't fix emmet. It is the only thing holding me back. There are a ton of emmet features missing so I would not call the VS Code implementation a proper implementation of Emmet. They just included the expand tab feature and not anything else.
Thanks! 🙏🏼
Just a few weeks ago I read the blog post of someone who had fervently argued for using currying in JS for years - and in that blog post he said "I was wrong". Can't find it any more. The gist was [along those lines](http://stackoverflow.com/a/114030/544779). Haskell and currying = great (important core concept), currying and JS = mostly useless. Partial application *sometimes* may be useful. Seeing JS examples always feels like people are desperately trying to do something considered "cool" just for the sake of it. EDIT: Found it! https://hughfdjackson.com/javascript/does-curry-help/?utm_source=ESnextNews.com&amp;utm_medium=Weekly%20Newsletter&amp;utm_campaign=Week%206 &gt; But as time has passed, the world has changed, and so have I. Is it still a good idea to lean on this technique to squeeze more expressivity out of your code? &gt; &gt; I’m not so convinced. ... &gt; When I originally presented currying as a possible addition to our toolbox at work, my colleague William (not his real name) adamantly insisted: &gt; &gt; &gt; This isn’t Haskell! &gt; &gt; Equally stubbornly, I argued that we should pilfer good techniques wherever we find them, no matter how obscure the source is. **It took me a while to realise how right he was.**
Had no clue there, I just put the blurb in a site specific directory/file off to the side and include it. The file is empty in test environments. 
That's cool
i typed out a reply and realized that you basically said everything I wanted to say. Also, it doesn't really get any more "ultra-super-large scale" than facebook. 
You're not reseting the skills back to 0 if they are over. So once they are over they are always going to be over 
Paid subs? I've used Egghead.io for things, Treehouse, Pluralsite, Laracasts, O'Reilly and I'm sure plenty of others that I've forgotten about. Each varies slightly in tone, which unfortunately is easiest to grasp by diving in and trying a few bits and pieces, but if something at Egghead.io (which is has a lot to offer, IMO) has caught your interest then why not sign up and see what you make of it? The cost is the same as a movie ticket or two and the content is just as interesting. :) Don't neglect conference content though. Generally I find them to be very watchable soundbytes on a wide range of subjects, everything from new technologies to best practices, and you'll soon get a handle on namesof speakers to look out for. They're just a great resource for a broad overview of the developer landscape at any given moment. They also make household chores easier to deal with! Dig in, I would. It's just TV with added value. :)
What browser on what mobile OS are you using
another thing i notice now i have more time to look into it, is you're calling your function recursively when the check for totalskills is over 10. So even when you create a correct character load out (334) it just continues from where the function was called. does this make sense?
What about [MobX](mobxjs.github.io/) 
What would you use it for?
Ah I see, thanks for explaining.
If you're trying to create a class with '`Array`-like' functionality, you could extend off the native `Array` i.e. class Child extends Array {} const _ = new Child; for (let i of [1,2,3,4,5]) _.push(i) console.log(_) // [1,2,3,4,5] That's one alternative, but of course there are many more depending on what you're trying to achieve with `Child` :p
It that case it depends entirely upon the needs of the given project. The term SPA is pretty generic. A SPA can, in practice, be many completely different things that work in completely different ways for various reasons. Most people just drop in a MVC framework and simply ignore even raising these questions to begin with. (that is a bad idea)
Somehow I didn't see your code before.. I understand it now and did it like you said-I created that sequence and then just checked if num is present in the sequence array: function isFib(num) { var fibSeq = [0,1]; for (var i=0; i&lt;1475; i++ ) { fibSeq.push(fibSeq[i]+fibSeq[i+1]); } if (fibSeq.indexOf(num)!=-1) { return "yes"; } else { return "no"; } } console.log(isFib(34));
lulz why are you doing it that way? Can i suggest you take a look at the prototype methods attached to the array object? https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array 
I wrote this after trying to find something to keep state in check for React applications and noticing a **lot** of over engineering and a lot of misunderstandings about FP even from libs that claimed to do those. I hope this isn't too stupid for this sub, but I really think we should write less code and think a little bit about the problems we are actually trying to solve.
Congrats! Hopefully things make more sense now. Loops and returns and general flow can be really confusing at first. 
&gt;lulz why are you doing it that way super helpful post. the link to the docs with no explanation or context or suggestions on where to start makes you seem really knowledgeable, like someone who knows what they're talking about.
Cool! Do you feel like you have a good understanding of it now? Do you feel like you could code it from scratch at this point?
Thank you!
Oh im sorry did you expect me to just hand out an answer on a silver platter when i recognize the objective of codewars is ranking via your OWN skills? Little bit of effort is required but the answer is still there.
It was in the plans, but now that most ES6 features are already supported by browsers it's not a high priority. What needs to be implemented though, are imports. The IDE currently supports unconventional import syntax where :someModule imports module named 'someModule'. This has some benefits over ES6 syntax, but standard syntax naturally needs to be supported as well. PS. vanilla JS works already. There's also support for LESS, HTML, etc: http://jussir.net/#/edit/languages
We're open to any programming topic but talks need to be advanced and last only 30 min. Submit your talk here: https://eventil.com/events/polyconf-16
That does help, but essentially after the player has entered the values correctly, it should move onto the next chapter/function in the game. Will the function not reset completely (e.g. reset skillPoints to 0, along with all the skills) when I call calcSkillPoints()?
Uhh... what? JavaScript is pretty much taking over the world at the moment. People are using JavaScript EVERYWHERE - including places they really probably shouldn't - because it is so popular at the moment, and growing more popular every day. I have no idea what the people you are talking to are talking about. Maybe if they're confused, and think you are asking about Java instead of JavaScript, but even that wouldn't make a whole lot of sense because Java isn't becoming irrelevant either, it's just becoming less popular as compared to JavaScript.
You can also compile most any language to it, so at what point does it become the web version of ASM, and thus, unused except in critical sections where a higher language just doesn't do quite what you want?
you have to understand that once you're function has completed, javascript continues on from where it was before For example. You hit this function it sets the stats to 0. and asks what your strength level is. You think yourself really clever and put in 9001 ^(vegeta would be so proud). Your program is clever and see's this is too many points and [HERE IS WHERE YOUR PROGRAM GETS COMPLICATED] it calls the function again from line 29. This pauses the current function stores the line number (its like: "ok i am on line 29 but its asking to run a function let me remember i was called from line 29) (the technical term for this is it stores this on the stack). it then starts your function and your less cocky this time and put in 3str, 3agi and 4chr. your function is happy and completes. now remember that stack i mentioned earlier? well Javascript does and it thinks to itself "Oh yeah before i ran this function i was on line 29" and it CONTINUES FROM WHERE IT LEFT OFF ie after line 29 it goes to line 34. Does this make sense? i know thats probably alot to ingest. and i'm not the best teacher online, im much better in person
One idea is to introduce a state object of some kind that represents what you're creating in Three.js. Then instead of directly calling methods, you fire events that change the state. I'm not familiar with Three.js, but its job could/should simply be drawing whatever the state is to the canvas. Event -&gt; Change State -&gt; Render The big change would be rewriting all the Three code to render the state instead of making direct changes.
Your function has too many responsibilities, this makes it a lot harder to reason about the output of the function based on arbitrary input. I'd suggest you split it up into multiple functions: * one that creates a new character * one to check if a character is valid * one to get player input You should probably avoid declaring global variables for this. Also parseInt takes two parameters, the second parameter is the radix, ie. what base the number is in, most implementations default to 10 but some don't, best specify it to avoid weird behavior in some environments.
This seems solid to me. It certainly reduces boilerplate to a minimum for the purposes of declaring dependencies between values. Of course you could use streams/observables for this kind of thing as well but you really can't get more lightweight than this. If your project isn't big enough to need 100k+ of libraries to handle heavy-duty stream action, this seems like a dead-simple alternative that does most of what you need.
Neat! This seems very similar to the [flyd]( https://github.com/paldepind/flyd) event stream library.
I wouldn't, but I *would* like to read about the project in the free time I have in the morning, away from a computer.
This is fantastic! This would have saved me about two hours last week.
I wrote a more complete explanation of how to grab the id from the URL in another post, if you care to see it at all it's [here.](https://www.reddit.com/r/learnjavascript/comments/48x0zk/search_implementation_in_a_website/d0na7hw) In short, you can access the URL with window.location.href and then pass it to a function to parse for your id parameter, starting with "?" symbol. I'm not exactly sure what you need to do with the radio button, but if you can clarify a bit I'll try to help you out.
I would be useful for you to learn to use Javascript, regardless of what happens with any growth in popularity of compiling other languages into javascript. it's a good foundation even if you end up on a project that uses Typescript, Dart, or whatever else and compiles it (and uses source maps for debugging so you rarely ever see the actual runtime JS code.) Javascript itself is also evolving, and you can also use a compile-phase today to start using some of these new features now. Take a look at BabelJs for example. Some of these newer Javascript features may reduce the popularity of compiling other languages to JS for browser development, who knows. But I'd say it would be a big mistake to focus one of these other languages on the assumption that underlying JS will become irrelevant. 
I think i just don't understand some basics. How do you deploy a bundle, so it can be used by a customer? Otherwise i would have to ship all files seperately and force users to write webpack configs with resolves, plugins, etc.? Basically what i want is: 1. bundle modules into a package 2. deploy to npm 3. make it possible somehow for others to use it in a modular way Maybe i got webpack totally wrong and this is only useful for single purpose frontend tooling, not for distribution, but then i don't get the library-output options which it has.
Oh! That makes sense. I didn't know the program would continue, despite being called. I figured it would just break. Thank you very much for your help. +1 to you sir :)
Thanks for the advice! I'm probably going to follow your suggestion once I've done some tweaking to it.
This is good news for ag-Grid and for anyone who needs a top-quality javascript grid for a commercial application. At my office, we're in the process of switching over from jqxGrid, and I'm sure we can convince the bean-counters that ag-Grid-Enterprise is a good investment. But I have a couple of concerns about the specific licensing model. For this kind of software one would generally expect to pay yearly for support and updates, but for a perpetual license to those updates. That is, if at some point we stopped using ag-Grid-Enterprise for new work, the old stuff has to keep working. We just couldn't put ourselves in a position where our flagship software would stop working unless we purchased a new license every year. Second, there doesn't seem to be any option for a site license. £250/developer/year is reasonable for a few developers, but one expects a bulk discount. We have around twenty developers, any of whom *might* work with ag-Grid. Trying to figure out which developers should be authorized to use the software would be impractical, with developer turnover and shifting teams and projects, but simply buying an individual license for each developer would be excessively costly. For comparison, jqxWidgets charges $899/year (~£632) for an enterprise license that covers any number of developers. Kendo UI charges $999/year/developer (~£702) for individual licenses, but offers substantial group discounts for 2&amp;ndash;10 licenses and (unspecified) enterprise licensing for 11 or more. These are perpetual licenses that come with one year of updates and dedicated professional support. (In addition, these are extensive widget libraries, although ag-Grid is doubtless worth all of jqxWidgets and then some.) If ag-Grid-Enterprise were available under reasonable enterprise licensing terms and with a perpetual license, then I have little doubt that we'd jump on it. But the lack of site licensing would give the bean-counters pause, and the lack of perpetual licensing is a showstopper. I can't speak for anyone else, but I expect that other midsize companies would have similar concerns. (Disclaimer: any opinions expressed in this comment are my own. I cannot speak officially on behalf of my employer.)
I don't mean to say that it offers more than anything else. If anything it probably offers less. But that's not really at issue. The point here is a minimal implementation. I'd never run into trkl, and you're right, it looks awfully similar in concept. I'll have to explore some more observable libraries to get a sense for the lighter-weight options. I'm mostly familiar with heavier observable libraries like RxJS.
One request is actually quite a lot for some of Google's use cases. For example when user opens the page and closes it right away, there is pretty high chance of not be able to capture even if you only have 1 ping. 
&gt; however the "experts" I talk to claim that JavaScript is becoming more and more irrelevant Says who ? says you ? what expert ? you just made that up, for what purpose? 
Using `for ... in` with arrays ಠ_ಠ Also why does the code for removing a word go to all the trouble of first checking to see if the word is in the data structure? It basically has to do the search twice.
Do you mean its because I started another else if instead of if? I fixed that and it didnt work.
This problem is not about arrays, it's a math problem. The first thing you need to notice is that there's a periodicity, i.e. there are `n` people followed by `n * 2` people, followed by `n * 3` people and so on. In other words, `n * (1 + 2 + 3 + ...)`. You can see the pattern is a progression of consecutive integers starting from 1. There's a [famous story about a mathematician called Gauss](http://www.americanscientist.org/issues/pub/gausss-day-of-reckoning/) which tells us that the formula to calculate that sum is `x * (x + 1) / 2`, where `x` is the last number in the progression. Given that `n` is the number of people in the array and `r` is the index we're interested in, we know that `r == n + (n * 2) + (n * 3) + ... + offset` where `offset = r % n`. In plain english, to reach the index we want the solution for, you start with a line of `n` people, then add `n * 2` people, then `n * 3` people and so on, while the size of the line is smaller than `r`. If adding `n * x` people makes the line become bigger than `r`, we instead add only enough people to reach the number `r`. That leftover amount is `offset`. We just saw that `n + (n * 2) + (n * 3) + ...` can be expresed as `x * (x + 1) / 2`, therefore `r == n * (x * (x + 1) / 2) + offset`. From there, we can solve for x. First can we reformulate that into these two equations: y = r - offset / n 0.5x² + 0.5x - y = 0 Then we can apply [Bhaskara's formula](http://www.entaovamos.com.br/wp-content/uploads/2015/04/f%C3%B3rmula-delta-e-bhaskara.jpg) to find `x` Quadratic equations always give two results, and in our case, we're only interested in the positive answer. From there, we can calculate the index at which the last period starts: `s = x * (x + 1) / 2`. In plain english, `s` is the last time the first Sheldom grabs a pop. Since we know the index at which the first Sheldon last grabbed a pop, and the number of people in the original list, we can then figure out who is at index `r` Complexity: O(1) [Solution](https://jsfiddle.net/63j8wd4a/3/) 
The problem with your examples (and this is more of a problem with JavaScript) are that there are no guarantees about car1 or car2's signature. DI can, at least, do some of the legwork here to guarantee that what you're asking for is, in fact, what you're asking for.
So you wrote a data flow engine
It also looks like a great fit for online job interviews with code exercises. Great job on the UI! The workflow this app is built around is excellent. I've adopted it myself for a bit over a year and the real value is cognitive. The abstractions and patterns of UI development available with this toolset are very sensible and consistent.
Typically, as an application grows, and state is introduced through the application to remember different things, it gets harder and harder to understand what is changing that state and when that's happening. It becomes less and less common to be able to look at a function and know exactly what result it will give you. This idea that state is a functional programming concept. In functional style you tend to avoid actually writing values out into variables that are used as state. Typically your programs are written as a chain of function calls that flow between results that you need to use for things, and when you do output values, that is a fairly strictly controlled event, because of the potential for errors to arise. By writing software in terms of how one value becomes another, there's less wiggle room to get lost in the complex interrelationships that can lead to a variable being set to an unexpected value because that value's result is literally encoded into its existence, rather than being a result of possible several different entities acting on it arbitrarily over time. So dealing with state has become a subject of some controversy as functional styles are popularized in JS. It's hard to imagine how to go without state, right? Obviously some things in programs require a memory of their state. You couldn't even have a toggle switch if you didn't hold a bool in memory somewhere. But the issues surrounding state have more to do with how to prevent state from becoming a source of complexity and error than anything else. Libraries like PureState.js are attempting to find clean and minimal syntax for declaring dependencies of one value on another values -- to declare the chain of functions to transform one value into another explicitly -- and allow the program to reactively update anything that depends on a value as soon as it changes. It's just another way to establish that kind of functional style that makes it easier to make sure a variable's current value is well-understood and explicitly outlined by the code.
A 1 is truthy. So it would be "Do not track".
compared to ExtJS, what are the big things you miss which I can consider for ag-Grid? thanks for all the other feedback.
Totally agree, the licensing model is simplistic to the point of being unworkable. It needs to incorporate perpetual use of the version for which you are licensed and it needs to include site licenses. I've read half the license agreement too. Crap like this &gt; A Designated User can be replaced with a new Designated User only after being a Designated User for a minimum of six (6) months. Doesn't fill me with joy. This is essentially enforcing named licenses instead of floating licenses. Just to be clear, I'd love this to be a commercial success, the grid is great, but this is not the way forward. I'm guessing he's landed at least one significant contract for licenses, possibly with his former employer which has given him a warped sense of perspective. Total guess, it's just how it feels. 
One other thing you can do is just iterate through all of the Array methods and then just bind them to your class's prototype, using `this._childs` as your `this` value. And then you can just add a `get` for the length. For example: const arrayProps = Object.getOwnPropertyNames(Array.prototype) const arrayMethods = arrayProps.filter(prop =&gt; typeof Array.prototype[prop] === 'function') class MyArray { constructor(){ this._array = [] arrayMethods.forEach(method =&gt; { MyArray.prototype[method] = Array.prototype[method].bind(this._array) }) } get length() { return this._array.length } } And then you could do: const arr = new MyArray() for (let i of [1, 2, 3, 4, 5]) { arr.push(i) } console.log(arr) // [ 1, 2, 3, 4, 5 ] console.log(arr.length) // 5 console.log(arr.reduce((a, b) =&gt; a + b)) // 15 You can even override any of the `Array.prototype` methods. [Here is an example](http://www.es6fiddle.net/ill5ari9/) of a way you can override the `push` method to only push the value if it is a string.
&gt; In computer science and automata theory, the state of a digital logic circuit or computer program is a technical term for all the stored information, at a given instant in time, to which the circuit or program has access.[1] The output of a digital circuit or computer program at any time is completely determined by its current inputs and its state. &gt; https://en.wikipedia.org/wiki/State_(computer_science) Imagine a web page with a two tabs. When Tab 1 is selected, InfoPanel 1 is displayed, and when Tab 2 is selected, InfoPanel 2 is displayed and InfoPanel 1 is hidden. You could imagine the state of the page when Tab 1 is selected to be something like state1 = { tab1selected: true, tab2selected: false, infoPanel1: "visible", infoPanel2: "hidden" } and when Tab 2 is selected state2 = { tab1selected: false, tab2selected: true, infoPanel1: "hidden", infoPanel2: "visible" } At any given moment, the "state" of the page should only ever be one or the other but never both (just because we say so, we've designed the system to behave that way for this example). It would be invalid for both infoPanel1 and infoPanel2 to be "visible". &gt;In computer programming, a function may be considered a pure function if both of the following statements about the function hold: &gt;1. The function always evaluates the same result value given the same argument value(s). The function result value cannot depend on any hidden information or state that may change while program execution proceeds or between different executions of the program, nor can it depend on any external input from I/O devices (usually—see below). 2. Evaluation of the result does not cause any semantically observable side effect or output, such as mutation of mutable objects or output to I/O devices (usually—see below). &gt; https://en.wikipedia.org/wiki/Pure_function JavaScript is largely a "functional" programming language. In functional languages, a "pure function" is the ideal. Given state1 from above, if the user clicks Tab 2, the state of the page becomes state2. A given state and a given input always produce the same output. Notice that state1 and state2 are totally different variables/objects. state1 wasn't modified (by saying state1.tab1selected = false, etc), a completely new object is created and returned. So why do we care other than to please anal retentive academics who are overly strict about programming paradigms like "functional programming"? Because: &gt;In computing, a stateless protocol is a communications protocol that treats each request as an independent transaction that is unrelated to any previous request so that the communication consists of independent pairs of request and response. A stateless protocol does not require the server to retain session information or status about each communications partner for the duration of multiple requests. In contrast, a protocol which requires keeping of the internal state on the server is known as a stateful protocol. &gt; https://en.wikipedia.org/wiki/Stateless_protocol HTTP is a stateless protocol, and JavaScript is more or less cosmically bound to the web. Given any state, your application should be able to display/function correctly, and always behave the same way given the same input (user interaction, server events, etc).
You're on the right track. State is both the data you're working on and the data you need to use to work on it with. If you're making a text editor, the data you're working on is the text, but you need data about the editor too. Both of these together would be the editor state. Generally in UI work, the data you're working on is much smaller than the data for the UI. It seems that you don't have a good feel for how much state even a simple project can have. Let's imagine that you have a game of solitaire you are making. What data (state) do you need in order to keep up with everything? You need 52 cards where each has its suite, value, a link to it's image, etc For the setup, you need info about the 7 rows at the bottom, the cards they contain, which cards are face-up or face-down. You need the remaining deck, the cards it has, and if it's draw-one or draw-three, how many cards have been dealt and which cards are visible(between 1 and 3). You need four placeholders which track the card type they hold and which cards. Now that we have the basic stuff, we still need to be able to move it around. Each card needs data for position (x, y and z), because users can drag around stacks of cards, each card needs to know the cards below it. We also need data about if a card is selected or hovered over. We want cards to automatically go to the top if they can, but not if a user has specifically pulled them back down, so we need state to track that too. Players also want win/loss statistics, timers, hints, and so on. Since it's an online game, we need to keep a bunch more state to sync with the server and we may want local storage too. There's probably other stuff I didn't think of that you'll need, but I think you get the idea. When we start moving stuff and adding a bunch of interactivity, it can quickly become impossible to reason about all the things that are changing. When you move into a state you didn't predict, unpredictable (and usually bad) things happen. Keeping this state manageable is one of the hardest problems in computing (to be more specific, it's a combination of both the caching and naming problems). Pure state is one approach to the problem (it's finally growing in popularity). A great way to think about it is a [flip book](https://en.wikipedia.org/wiki/Flip_book). Each time something changes, you draw another page that looks the same except for the parts that moved. If you need to go back to a previous state (eg. undo a change), then you just flip to the previous page and remove the newest page. If you don't need the old pages, then you can still remove them as you go. There's a cost to redrawing the image, but libraries like immutableJS use some very interesting programming tricks so they don't actually redraw the whole thing. tl;dr State (all the application's data) is a real thing and a huge problem. Pure state is one (good) way of trying to make that problem easier to handle.
Pattern matching would be something like this: [1, 2, 3 | tail ] = my_list The above will only match a list that begins with 1,2,3, such as [1,2,3,4] or [1,2,3,10,20]. Then it will assign tail to whatever values are left after 1,2,3. You can use pattern matching to build complex objects too. {'user': id, 'status': status, 'username': username } = _user; But that's not possible with assignment like this.
It is a bit smaller (25% gzipped) but yes, it is awfully similar to trkl. I just found trkl a little more verbose than it needed to be and wrote PureState, but I'd gladly say the same things in favor of trkl. Note that, while I see no reason to not use PureState (and I will), this is more about the rant than the lib itself - I'd like to hear what people think about this approach, what potential flaws it could have and if they agree with my sentiment about over engineering.
&gt; If you change a stateful vriable, all variables that depend on it are updated. This sounds a lot like MobX, except that MobX says its approach is essenitally mutable state, while this makes the claim that observer-indirection makes the state 'pure'. I've never actually heard a value being 'pure' (functions...yes... values ... no) so I'm not sure from just reading through the documentation what the difference in the approaches are.
Does it support complex objects? Like f = state({'hello': 1}} Can I write f.hello = 2? Or will I have to write f({'hello':2})
I didn't realize you were the author of ag-Grid. Sincerely, you've done a great job. I've actually made a number of (what I think) are basic/useful improvements -- although I've accomplished them by creating my own interface to call ag-Grid internally. Is there a way you prefer to receive feedback? &gt; compared to ExtJS, what are the big things you miss Not exhaustive by any means but here's a few off the top of my head; (also, upon inspection, some of these have been addressed in the ver 4 update) * Nested grids (or a general "rowbody") to play with. Not tree data, but a way to expand a row and embed a sub-grid, raw html or maybe a template. * Row methods/events (many of these look to be addressed in the v4 update) * More advanced column editing. The combobox is a big one, although not entirely fair since ExtJS has its own. I understand you allow a "custom" editor, but the syntax is verbose. More of a "you can do what you want to" rather than a helper. * Context menu (added in v4!) -- however, one default should be column selection in the context menu, not just a way to enable the tool panel. Create a sub-menu with all the available columns and put a checkbox next to each one. * Better/Advanced grid filtering. I have to admit I find your filterModel a little weird when it comes to sending the query to the server for different data types. If it's a number, "2" is less-than? For a string, "4" is ends-with? A dataset type sends a function? * Built in debounce/delay on filters (customizable) * Maybe one thing is the documentation in general. A good comparison would be something like the column models [ExtJS](http://docs.sencha.com/extjs/3.4.0/#!/api/Ext.grid.ColumnModel) vs. [ag-Grid](https://www.ag-grid.com/angular-grid-column-definitions/index.php).
I had a look IP filtering but for someone who works in several offices, this wasn't a viable solution.
I think redux is good for describing state transformations in some scenarios. I think it's pretty noisy in other scenarios - CRUD forms come to mind. I think observables is good for describing state transformations in some scenarios. I think it can make it harder to understand data flow in some other situations, like when they get passed down to tons of components. I would disagree with your characterization of redux as being less functional. Functional programming *does not avoid state*, it simply minimizes it to specific areas (usually functors or monads) which functions are then applied to. You cannot entirely avoid state - without state, your application cannot do anything useful. Redux's reducers have the advantage of being easy to reason about - given a state, and a reducer, you'll get the same transformed state back in response. Observables do not enjoy this - I have to be aware of *every single consumer* that it has, since any of them could change it at any time, for any reason. The "time traveling debugger", while a neat marketing pitch, is ultimately not even a consideration for me when I use redux. I use it in scenarios where I absolutely need to have confidence about combining my application's logic, something that writable observables simply cannot promise. However, I don't think there's any one silver bullet to managing state. I will note that we've already gone from flux to redux and I doubt it's going to be the final iteration on the concept, but how observables work has largely been the same since I became aware of knockout (well before angular was a thing). I've always been a fan of knockout-style observables, but I recognize the context of my affection came at a time when angular was hotter than lava, and it relied on tons of ugly dirty checking.
Maybe I'm missing something, but the OPs implementation doesn't require manually requesting a refresh either. It happens on state variable update.
I've been working on a state lib myself for smaller projects, called [cubbie](https://github.com/samueleaton/cubbie). I think all of the reducers and actions in redux are too much boilerplate for a simpler use cases. I was proud of how I implemented state modification and state rollbacks.
Hey, awesome tool! Tried it, but it seems it doesn't output sourcemaps yet?
feedback received. thank you. re column selection in the context menu, that's already in the column menu, will be easy for me to add to the general context menu also. the only item you mention that is going to me an issue for me is nested grids. grids inside grids is a challenge when you are doing row virtualisation. does ExtJS do row virtualisation when this feature is enabled?
That's the impression I got from most of the popular functional programming resources (Eric Elliot, Addy Osmani and mpj come to mind).
The rowbody (and any content therein) doesn't exist until the row is expanded. If a row is expanded and then scrolled out of the buffer there are a few possibilities; * move the DOM node somewhere else and save a reference to it, so you can replace it when the row comes back into view (keep a "rowExpanded" flag on the row). * destroy the node but keep the flag, re-expand the row when it comes back to view. This is problematic in the event the user has a form in the rowbody, or something that would be lost. I don't think one need worth about expanding rows and pagination. You could apply the same logic as above, but I think most users would understand that row expansion is lost when going to the next/previous page. 
Not planned it for now. I would suggest just using hangouts or something in the background though. Any implementation would fall short of that :) Though great idea!
I am planning for the mobile version to work on LIVE bins. So that the preview window will automatically slide in/out when "teacher" changes focus/saves etc. Just an idea for now. Though generally be able to toggle code/preview is a good idea to use it on mobile. Load up boilerplates. Not a focus currently, but should be there. Thanks for the feedback!
The cool thing is that the package you downloaded will never be downloaded or bundled up again. It will stay in a "special minfied webpack bundle" that will be shared with anyone else also using it :) It will stay in-memory for 24 hours making it insanely fast, when it times out it will be deleted from memory and grabbed from database the next time someone needs it, and put into memory again... which is also insanely fast. Though it will not be downloaded and bundled again. That is already taken care of :) Unless you download a different version of course
Mobile support will be a focus when some other stuff is in place and the project has stabilized :) 
That is a good idea. Please create an issue on it :)
It does have sourcemaps, though it uses a simple version. That said, it is good enough to debug. The error message in the "Log" does not show filename and linenumber though because you can not extract that information from a thrown error. Only Chrome console has this info. But this might improve later, need some help from Webpack author. Anyways, just giving the error message now should generally be enough I think. Not that many files created :)
I strongly recommend [learn you a haskell](http://learnyouahaskell.com/). It may take you a few reads to fully soak in, but it's going to teach you functional concepts much better than something like an eric elliot rant would.
Well, I built Cerebral as well :) Though together with fantastic contributors the last months. Cerebral is just really great to handle these complex UI apps and the LIVE code sharing was done in a couple of nights because of the way Cerebral works. It is very easy to do. Cerebral will be released in 1.0 later this year. It has been hurt by a lot of changes, but things are stabilizing now and a lot of great things are produced in the Cerebral community... webpackbin being one of them :-)
Insightful. I think your considerations are very good. But I thought a little about it and had an insight: Redux is just a combination of observables + lists. var actions = state([]) var initial_state = .... var view = state(() =&gt; foldr(my_reducer, initial_state, actions())) // The same you would do with Redux function my_reducer(action, state){ return ... } ... document.body.innerHTML = view() ... // To rollback the history, just do something like this instead: var historic_view = (time) =&gt; state(() =&gt; foldr( my_reducer, initial_state, actions().filter(before_time(time)))) // This view allows you to roll back your app state to any point in time. // Sounds neat, I should write a demo... This patterns gives you exactly the same things you like about Redux. Redux is structured, easy to reason about and allows historical debugging because you are formalizing your actions; making them explicit. But you can do that naturally with observables - all you need is the usual implementation of lists and their folds. Let your only state be the list of actions and make the other states derive from it. Make your view a stateful fold of that list of actions. That will be isomorphic to what Redux does. What do you think about that?
Separate git repos. Ownership is spread out among many teams. My team (~15 people) owns a dozen or so public git repos with 3 or 4 of them publishing npm modules, some of which have dependencies on each other.
For us it's one guy repo per module but we don't publish to private npm. We use an oauth token plus git url in npm deps
State is anything that changes during runtime. The issue is that, the more things change during runtime, the harder an application is to scale. Think about Wikipedia: it is a huge database of text. You can change any single page without worrying about breaking another page. Anyone can edit anything. Now, think about a code base with 1000 files, and 10000 global variables. If you edit any of those global variables, the can break the behavior of any line of code in any of those files. It is impossible for a human to keep track of that. So, the brilliant idea is to make most of your code pure and only have state for things that are actually stateful. Pure code is just code that doesn't affect anything outside of its own lines of code. It doesn't "set" anything, it doesn't do any action. It just describes things, like text describe things. That is why I can edit a very complex Haskell function on a giant codebase without fear; but dare I touch a single variable in a huge PHP-spaghetti database. So, a simple example. Suppose your site displays the value of a stock in 4 different currencies. You could have 4 states - one for each currency - that you set when the value of the stock changes. Or you could have a single state (the value of the stock) and use functions that convert that value to 4 different currencies. 
I think modules aren't meant to be bundled by the distributor - at least this is what i got from hours of reading through the internet. I can deploy Babelified and uglified modules via npm, and the end-user can use them either way, Browserify, webpack or otherwise. I am fine with it, but i still don't get why they have a library option at all in webpack when the resulting bundle is a total blackbox that cannot be gotten into from outside - that one makes me scratch my head...
Could you explain one more detail --- what to do with the resulting libraries once they're bundled? Both Browserify and Webpack chain a bunch of modules but don't seem to export anything. From the end user perspective it's clear, i have my modules and the code that uses them, all gets bundled up and included - works. But when i distribute modules and bundle them together, how will the end user import the modules now?
transform names into pairs (name, cnt) . initially cnt=1.
Sure: // this syntax imports whatever we exported as "default" and // puts it into the variable "Db" import Db from "databasething"; // our exported function accepts one argument - an object // however, it was destructured and had defaults assigned to it, // so we can do simply just this: var db = Db(); // if we had a previous connection or database, we can also pass them in var db = Db({ con: someConnection }); // we can also do this. the 'new' has no impact and is harmless when your factory returns an object literal var db = new Db(); // because we exported an object, we can dot into it, just like any other object db.add({ id: 2 }); // it even looks like a class with state associated with it, since now we can do this: db.remove(2); However, in a unit testing scenario, things can be a bit different: // this syntax pulls out exported 'add' and 'remove' import {add, remove} from "databasething"; // we can stub out the dependencies var connection = { ... }; var database = { entities: [], save() {} }; // now we can test these two pieces in isolation add(connection, database, { id: 2 }); expect(database.entities.length).to.equal(1); remove(connection, database, 2); expect(database.entities.length).to.equal(0);
Its an iPad Mini... I would guess the latest one? It just hangs on the "Loading" screen
http://stackoverflow.com/questions/12070631/how-to-use-json-file-in-html-code
Remove the first closing bracket '}' after the part that says 'else if( choice1 ==="rock" )'. Also from the code you pasted you need a '}' at the very end. Pasting your code in something like http://jsbeautifier.org/ makes it easier to spot syntax errors.
More objects like what? I see no arrays in your code. If you have an array, with 16 objects in it, and you want to add some values from those objects to your html, then you can do something like var arr = [/*16 objects in here*/]; for (var i = 0; i &lt; arr.length; i++) { document.body.innerHTML += arr[i].propertyOfTheObject; }
&gt; The this in functions is inherently stateful. This seems to be the premise of your whole reply, but I wholeheartedly disagree with it. I think this... add.call(null, con, db, entity); ...isn't at all inherently different than this... add.call({con, db}, entity); You need to think of "this" as if it's just another parameter, to which we can pass any arbitrary argument... because ultimately that's really what it is. &gt; Functional programming and its techniques are not all or nothing. I thought that was *my* point. :-) The presence of "this" doesn't automatically make it anti-functional. Likewise, the *absence* of "this" doesn't automatically make it functional. It's perfectly okay to use "this" and still be immutable.
I'm having a hard time seeing the conceptual difference between this and mobx. Marketed differently maybe. Mobx uses getters and setters, which i like. Why pretend you're not changing a variable? 
My data is external JSON array of objects like this: { "elements": [ { "title": "value", "date": "value", "lead": "value", "image": value, "url": "value", "type": "value" }, { "title": "value", "date": "value", "lead": "value", "image": value, "url": "value", "type": "value" }, and so on x16. And from this JSON array I need insert data to html. :) 
And I'm not offering a job. It's a volunteer open source project, dude. Everybody voted the post down BECAUSE I didn't offer a job. Forget it /r/javascript! Cryptos are for real coders.
You might want to look at a templating library like handlebars https://jsfiddle.net/uzmvcm50/1/ http://handlebarsjs.com/ 
I've just noticed an issue with my approach. You get O(N^(2)) updates! I.e., you have to re-fold the whole list every single time you append an action. FRP libs deal with that. Some kind of auto memoization would fix the asymptotics, though. Let me know if this makes sense.
I'll gladly do! (I find marketing really hard). Do you have points which in particular made the case more clear then MobX did?
Just released an improved introduction / tutorial. Would this make the point more clear? https://mobxjs.github.io/mobx/getting-started.html
Well it's what get passed around on talks, social media, hacker news and the like. And it's kinda appealing to newbies such as myself.
Wow, thanks! Looks cool.
Taking a different approach in explaining sate -&gt; state is *all* the *minimum* information required to *render* your application(or game) at any given time. As web applications are becoming more complex they've started to search for solutions to maintain this complexity. The answers, unsurprisingly, lie in the same principles used for many decades developing large desktop applications and games. Which all boils down to minimizing state, using pure functions, determinism etc. As an example the 'Redux' library has taken a bare bones deterministic approach similar to how games such as Starcraft2, Age of Empires, Clash Royale and Clash of Clans work. These applications/games are built to be deterministic and do not leak state or have state hidden somewhere. This is why the 15 minutes replays of these games are only a few kb large since all they need to do is store the actions/inputs and they can play/rewind the state out of those action/input events. Also watch this: https://www.youtube.com/watch?v=avwDj3KRuLc
I watched the video where MobX was introduced, and I've been using MobX for a while. I didn't need convincing because I already thought flux, and the siren song of immutability was a poor fit for my application, but for others I think starting off with: &gt; Conceptually MobX treats your application like a spreadsheet. ... might be a bit of a turn-off. Partly because people hate spreadsheets due of flashbacks of VB programming in Excel, and partly because its a bit of an abstraction from the start. I think this starting paragraph is great: &gt; State is the heart of each application and there is no quicker way to create buggy, unmanageable applications then by producing inconsistent state. Or state that is inconsistent with local variables that linger around. Hence many state management solutions try to restrict the ways in which you can modify state, for example by making state immutable. But this introduces new problems; data needs to be normalized, referential integrity can no longer be guaranteed and it becomes next to impossible to use powerful concepts like prototypes. That said, right after it... you should launch into a discussion of observers, what they are, and how they make things better. The getting started link, and [this link](https://mobxjs.github.io/mobx/) both take too long to get into the concept of observers which is pretty much the heart of MobX. Perhaps you could try something along the lines of: MobX-React provides transparent observers and ensures that no matter where a state change happens within your React application all components that use that state will be re-rendered. MobX-React takes this one step further with an internal dependency graph to ensure that *only* the necessary components will be re-rendered. This means in practice, you will rarely have to write your own WillComponentUpdate() calls in order to achieve performant rendering in an application with a large number of components. ----- Another thing I'd add is... although MobX is a standalone library, in application, most people are using it with React --- As a side note. - Can you fork documentation [like this](https://mobxjs.github.io/mobx/getting-started.html)? - And if not, how can I write something similar---do you use a template? I'd love to contribute my own take on things, annotating one of the demo apps that I made when I was investigating MobX and React. 
AH, I somehow the bundled version of main.js when I clicked an error in Chrome's dev tools. Will try again later. Even without that though, I went back to try jsfiddle again, but it feels lacking. The code editor feels better, installing npm modules is awesome. What I did miss from locally running webpack, was altering it's config manually, so that I would be able to add support for whatwg-fetch for example. I'm really looking forward to using the live feature as well. Would it be possible to have 2 people changing the code simultaneously? I used to have a user script for etherpad that added a autorefreshing iframe with the contents of the pad as HTML. WebpackBin would do this much much more fluently.
You can't use getters here because these are variables, not properties of an object.
1. You never give the form a name. You call `document.orderForm` to access it, but if you haven't given it a name, how's the browser supposed to know what that is? Change the `&lt;form&gt;` to `&lt;form name="orderForm"&gt;`. 2. You're making a typo, 'stuentgrade' instead of 'studentgrade'. 
Nice work so far. I apologize if my comments came off snarky or dickish. I certainly understand getting something out there so there is a presence, then circling back for all the niceities later on. Will probably end up using this a bit :D
I'll see the next time :)
After LYAH, I actually didn't take too much from the book. It was all very neat to me, but it had little practical value in my mind. I then eventually stumbled upon [F# for fun and profit](https://fsharpforfunandprofit.com/) as I do a lot of work as a .NET developer. F# is a "functional-first" practical multi paradigm language, and something I could actually plausibly sink my teeth into in practical areas, since it has very strong interop with C#. In particular, the talk on ["railway orientated programming"](https://fsharpforfunandprofit.com/rop/) is one of the things that really convinced me of the value here. I then saw [Look, No Mocks!](http://www.infoq.com/presentations/mock-fsharp-tdd) by seemann and it was like a breath of fresh air. Easy unit testing! No single-implementation interfaces. Etc. With all of that context, I re-read LYAH a second time, and found much more of it stuck to me. Moreover, I began to connect what I already knew from things like javascript's promises to haskell's monads, and f#'s computation expressions to javascript's generators. I don't know any of this will help you, but it's why I said it might take a few tries to really appreciate LYAH. It took a few tries for me, then I *really* appreciated the book. :)
Thanks for the reply, and for creating such an excellent piece of software. I'm just a code monkey, so I can't really say anything on behalf of my employer. But I know how to read a license agreement, and I can make a pretty good guess as to what parts they won't like: - No perpetual license. This, unfortunately, is an absolute must-have for any software we might integrate into our own. Updates and support are more than enough incentive for us to maintain a yearly subscription as long as we develop using the software. - No listed plans for site licensing. Not every similar product spells out the terms online, so there must be some business reason to be coy. But from my perspective, it's a lot easier for an enthusiastic developer to sell a product to management if they can tell them how much it will cost. - Sub-point: designated users. This might work for a very small team, but past a dozen or so it would be a bookkeeping hassle and a compliance hazard. We used to have a tool with limited transferrable seats, and it just proved so inconvenient that we rarely used it and ended up ending our subscription. Presumably, a site license would not come with such arduous restrictions. - Prohibited uses are a bit vague. I am nearly certain that the kind of customizable reports my company produces are not intended to fall into that category. I am less certain that I could convince a manager that they could not possibly be *construed* to do so. - Auditing. This is a very surprising thing to find in this sort of license agreement, and realistically, I'm not sure it's of much use for software at this price point, while it tremendously increases the risk. If I recommend the software to management and later they get an email that a vendor is planning to audit us and the license permits it, it's my ass on the line even if we're fully in compliance. It's one thing for a six-figures-annually Oracle installation, but I have never seen it in a license for a product like this one. - Publicity. This is another odd thing to see. I know that some javascript libraries offer a discount in exchange for publicity (such as a case study or testimonial), but it's a bit odd to see this mandated. You, of course, have the right to tell our competitors about the wonderful product you have, but it is our right *not* to tell them about it. Hopefully, the aforementioned bean-counters will be in contact in an official capacity in the next few weeks. Until then, please take these points under advisement while you continue to flesh out the licensing regime. 
Maybe I should go back and give LYAH another try soon. I didn't find it hugely *practical* at the time I read it so much as it helped me see functional programming using syntax that was understandable to me (a.k.a. not Lisp) and felt really appropriate for the strengths functional brings to bear. I originally read it when I was just barely starting to get functional concepts (I had already been learning off-and-on for a couple of months) but I'm not sure I was entirely prepared for it yet. Thanks for these other resources, though. I'm starting to dig into some more serious material but I'm still a little bit confused about the level of mathematical terminology that gets thrown around once you try to learn about functors and monads. For example, I've been reading [Professor Frisbee's MostlyAdequate Guide to Functional Programming](https://drboolean.gitbooks.io/mostly-adequate-guide/content/index.html) lately, and everything was sinking in just great but as soon as I hit chapter 8, which discusses containers/functors, I completely tripped up and felt like I hit a wall. Don't get me wrong; that book has been a great experience and taught me a ton so far, but functors just knocked me for a loop and showed me I still have a ways to go. Other than that, I'm in the middle of going through this [Elm Tutorial](https://www.gitbook.com/book/sporto/elm-tutorial/details) which has been hugely instructive in a really practical way. Elm seems like a fantastic set of training wheels to get a grip of Haskell-like syntax and application structure before trying to work with Haskell itself. I feel like Elm is a fantastic expression of the redux philosophy, and that it is so much more concise at expressing the relationships between parts of the application, and that's helped a lot to make those parallels. Anyway, thanks again for your advice. I figured I would post some of the most helpful resources I've been looking at recently as well in the hopes that someone else can make use of them.
If it helps at all, I actually wrote a comment here on this subreddit a little while ago trying to [build some good intuition for functors](https://www.reddit.com/r/javascript/comments/47k3d4/array_reduce_like_you_may_have_never_seen_it/d0ekdaf?context=3). I feel like all of the math terms used around it *really* slowed my time to understanding it, so I tried to explain them without using any math-y terms at all. 
Functors are intuitively a container that implements map. The map function takes the value of of the context of the functor and passes it to the transforming function you pass to map. Functors also have some "laws" that make them "well-behaved". For the most part, every `map` implementation you come across will obey the rules (you mostly have to try to break them). But one important one that separates a functor's implementation of map from just a general mapping is that you can't leave the "context". For example, no matter what you pass to the `then` of a promise you get back a promise. No matter what you pass to `map` of an array, you get an array back. If you look closely at my `map` for numbers, it can actually break this! If I return a string from that function, then I will get a string back. Therefore, my map implementation for number is not a functor - and intuitively, you can see why. It doesn't make sense for numbers to "contain" anything. But yes, that's basically all there is to them. It's a thing that has a map which you can check in but you can never leave. This is again why I find all of the math terms so frustrating - *people already know* what a functor is! Yes, there are other words for common interfaces. For example, Monads are basically the interface for the `bind` function. Monoids are the interface for the `append` function. Foldable is the interface for the `foldr` function. Ord is the interface for comparisons. In haskell, these common interfaces are called *type classes*. Type classes are pretty similar to interfaces. However, they differ in some important ways: * The implementation is with the *type class*, not the object. The `Maybe` type in Haskell *does not* have a `map` function, but the `Functor Maybe` type class *does*. (This is why you see things like `(Functor f) =&gt; f -&gt; f`, instead of maybe saying something like `Functor -&gt; Functor`) * Type classes can have default implementations. Very often you can just implement more "basic" type classes like functor and monoid and you'll get most of the way to monad. Type classes like `ord` and `show` often don't need any implementation on your part at all! * A data type does not need to explicitly implement a type class during its definition. A type class can be added to any type at any time. * Instead of being used for polymorphism when passed around, the compiler uses it to find the correct implementation to call. This is how in haskell you can write such a totally generic function that still somehow seems to just *work* for everything.
I actually learned about Panda from Echo JS, which I found back when DailyJS announced it would stop updating.
I find it ironic that this started when someone linked me MobX yesterday. I liked the concept, but then I kept reading, saw a lot of OOPy things, got a little confused with the documentation, asked myself if I really needed all that and started looking for a less complex alternative that did less things. Well, I'm glad this helped you somehow. Thanks for the great work and inspiration :)
I couldn't disagree more. I know this is coming from my nearly 2 decades experience using JS, but I find the new syntax to be very unreadable. Especially the arrow functions. I can't seem to stop myself from reading them as equal to or greater than. I really wish they had not taken this construct from other languages, but rather used a keyword instead of arbitrary symbols. Now get off my lawn. 
Maybe [namespace css loader](https://github.com/jeffling/namespace-css-loader)? It's a bit of a weird request, imo. Bootstrap, foundation, and others are meant to be global. 
But don't you have to have variables that change state somewhere? If I pass a first name and last name into a concatenateName() function, wouldn't I want to put the result into a variable so I can retrieve it later or do something else with it? Presumably that function was called from within another function, so now I have one function in which variables change state and another where they don't change state. Is that correct or am I missing something? Do you split your code up so that all the non-state changing functions are in one place and the state changing functions are elsewhere?
I must be the only one that likes the arrow functions. that and the spread operator, are my favorite
I think it's very important to note that `function () {}` and `=&gt;` are _not_ the same thing. `=&gt;` doesn't reset `this`.
I can't for the life of me figure out why class methods don't autobind. Why do I have to do this: export default class YourMom { weighs = () =&gt; { return -2,147,483,647; }; }; Why isn't `this` bound on all instance methods on a class? Am I missing a strong argument in favor of not autobinding classes? But my god, string interpolation with \` (how do you show backticks in `code`)? is just glorious. console.log(`lol jared, your mum weighs ${jaredsMum.weighs()}`);
You are certainly not the only one! They're fantastic.
While using the fat arrow is somewhat unusual, using an arrow is pretty standard in just about any language with lambdas that I can think of. Javascript was the odd one out to have the incredibly verbose `function(formal paramaters) { return expression; }` syntax for lambdas.
Also, as of Chrome 49 basically all of it works in the browser! https://www.chromestatus.com/features
Should be fine to create a [gist](https://gist.github.com/) out of them.. just name the file "warning don't run".
It's only available in Typescript if you care about the source code. Npm package will have ES5 and ES6