I think I'm more confused now that I've seen the pic.
No I don't think it is.
let is 20% slower than var when used in for loops depending on which version of nodejs your using, not an issue for transpiled code but be careful if you are using it natively. https://bugs.chromium.org/p/v8/issues/detail?id=4762
It all makes sense. OP's post isn't an informative gif. It's a meme based on caffeinated beverages
There's some overlap to call by reference and call by sharing, and the latter is not widely used. Call by reference is simple to understand as long as you're willing to listen to the fact that call by reference is not the same thing as passing a reference value.
What do you mean only the var statement will work. Just declare the variables that need hoisting at the top of the file.
Well safety is the first thing you learn about as a construction worker or a mechanic but an amateur that self-taught wouldn't know that. All these self-taught programmers only know bits and pieces of how things work and often miss the big picture and they limit themselves by doing that. Most of them have never read a programming book in their lives and instead resorted to online coding camps and challenges. In the process, they learn quick hacks on how to make things work and very little in the way of how that "hack" actually works. I'm sure many would consider this example as some sort of crazy hack as well, simultaneously questioning its purpose like most 1st year CS students do. There are plenty of mechanics that have these conversations with DIY'ers. Just because you read an online tutorial doesn't mean you have any proficiency in the field. I am of the opinion that if you read the books then you're definitely intelligent and a much more capable self-taught programmer. 
TS doesn't have a char type either. It has no additional primitive types compared to JS.
`null`, `undefined`, and `symbol`.
Now you're projecting. I have, and am still developing, a very deep understanding of programming, programming languages, and the math that is involved all the way down to the hardware. If you're self-taught, that's great. I was too at one point. I only had to get to my second semester of uni to realize I didn't really know shit. I'm sorry if you don't know pass-by-reference but you're gunna want to learn it. You don't need to learn assembly and the internal workings of the cpu like I have, but when I say this is one of the first things you learn when programming I mean it. It was my first class in uni that we learned about pass-by reference and it was about the 3rd or 4th week out of 16. There is a very big difference between a "coding technician" and a "CS major". 
Whoah I used C++ for years and never realised that references were... _actually references_. I only ever really thought of them as 'pointers without NULL'. Thanks!
I left very disappointed with the javascript community today. Not only did I realize most of them have no idea what they're talking about, they're also going to downvote you when you tell them that being self-taught results in massive gaps in knowledge such as this.
My blood stream is bent up on stims^stims^stims so fucking hardcore^core^core
&gt; I personally can't kick the var habit, so far. &gt; I feel the only way I'll get used to let is if browsers deprecate var, to give me bit of a kick in the rear. If you want, you can deprecate it for your project and give yourself that kick yourself in the rear by using ESLint and enabling the [no-var](http://eslint.org/docs/rules/no-var) and [prefer-const](http://eslint.org/docs/rules/prefer-const) rules (as well as using the eslint:recommended preset) This way your editor or build process will automatically remind you to use the appropriate alternative. `const` whenever the variable refers to a single thing and `let` whenever the reference changes at some point. I think the opinionated rules in ESLint are great way to shake some old habits. I can define what kind of code style I *want* to have and a hundred squiggly red lines later, I'm doing that style by default. Not that `var` is suddenly terrible or anything, but as you said, there's no reason to use it. Even if you never run into any scoping issues with `var`, the `let` and `const` keywords are more explicit. Makes code easier to follow when you need to make less assumptions.
As long as the transformation from data to canvas coordinates is reasonably fast (and it should be), there's no reason you couldn't plot millions of points in under a minute. Bars should also be pretty straightforward to compute on the fly - both layouts are several orders of magnitude less complex than circle packing which is a really weighty process. Here is half a million particles smoothly animating, for a three.js based starting spot: https://threejs.org/examples/webgl_buffergeometry_points.html
Ha, that's a nice detail. So it is the value of the reference. Will remember this for my next job interview. Thanks for the lecture.
Yeah, this wouldn't really make any sense if I didn't already know what it was trying to illustrate.
&gt;You wouldn't know because you don't need to know. I think that's a big exaggeration. You could go on not knowing how to use a switch statement and get by with if statements or not know how to use a for loop and get by with while loops. Doesn't mean it isn't something you need to know. I can think of plenty of scenarios in JS where you would need to pass an instance of a class or even a simple sorting function that would require knowledge of pass-by-reference. 
I guess I associated JS with Node and maybe some more complex front-end configs that use angular or react where you would at least need to know how classes work.
You don't really need to know about pass by reference vs value. You just need to know that in some cases your original object will be mutated, but you don't have to know why.
I guess you're right. Still seems to me that there's gotta be situations where not understanding the difference would result in failure of the code to do its job. I mean somebody made this post in the first place so there's gotta be plenty of scenarios that require this understanding. 
You are welcome. I think JS is not more or less difficult than other languages. It has its flaws and difficulties like probably almost all other languages. It your case it was hard to know, how browsers actually render the HTML, so JS has a tricky context, too. I have much respect for someone, who codes data analytic and machine learning stuff. Kudos!
That's the way C# works.
You're trying to be sarcastic but you're just ignorant.
I consider there to be a set of about 20, which I can say I'm familiar with. I *can* say that, because the example I gave is just an example: The pointer is still a separate type, else it's not a "pointer" https://en.m.wikipedia.org/wiki/Pointer_(computer_programming)#Support_in_various_programming_languages. My point was restricted to C-like pointers, so I won't dispute your later point about pointer initialization. I though we both agreed that they are semantically identical? Of course, in C++, pointers and references do the same thing when used correctly. One uses a reference for safety and cleaner code, not because the do a different job. This is of course restricted to function parameters (one can't malloc and get a reference). To be nitpicky, modern CPUs use general purpose registers which are then sometimes (e.g. in amd64/x86-64) given names. You didn't show an example of pass-by-reference, because you passed some thing by pointer (with the pointer being passed by value). "Hacking" != "Fixing/Finding simple memory safety bugs"
Non-Mobile link: https://en.wikipedia.org/wiki/Pointer_(computer_programming)#Support_in_various_programming_languages. *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^81633
Does "pass by reference" mean anything else in any programming language? You always pass a value, which happens to be a value.
Yeah, but this pointer here is still a value, isn't it? It's just explicit that it's a pointer value.
I didn't make up the idea. The behavior is distinct enough to have been given a name. https://en.m.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing Note: You sound very condescending when you say that I should read through this thread when if you had done so you would have already read this same discussion that I had with someone else. My point remains that JavaScript is not simply call by value. You need more information such as that objects are references in order to put together the behavior. Given this distinct behavior, then distinct terminology is appropriate to encapsulate the idea. And to be clear. When I say distinct, I mean the behavior is distinct from call by value or by reference. Not that only JavaScript does it. 
Non-Mobile link: https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^81641
&gt; So, first. Passing by reference means, in simple words, that... func doThatThing(n) { n = 8; } // ... somewhere else ... var x = 7; doThatThing(x); // x is now 8. &gt; ..."works" and in the end x is actually 8. ---- Here's something I added in that other thread, admittedly lost amongst the hundreds of other replies. &gt; Eh... it's messy terminology. The problem is Java uses the word "reference" differently than how C/C++ uses the word "reference". The [Java language spec](http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html) explicitly says references are pointers. What you're describing, on the other hand, is a [C/C++ reference](http://en.cppreference.com/w/cpp/language/reference), which describes a reference as an alias. &gt; That means the phrase "pass by reference" is also messy terminology. In C/C++, it means a parameter is an alias for something; in Java, it means a parameter is a pointer to something. &gt; JavaScript seems to have adopted Java's terminology in this case. So in JavaScript, whenever you hear "reference", think "pointer". ---- So be careful when you start declaring what a reference is or isn't. Its meaning changes depending on the language. Your description is what C/C++ calls a reference, but not what JavaScript calls a reference.
Yeah Object.values just got added to V8 so makes sense it's in chrome. I would guess it should be in Firefox shortly
There is a tiny difference: it just passes the value of the reference what allowes you to change the referenced object, but this does not allow to assign a different object to the reference, what is possible with "real" pass by reference.
So I really like Webpackbin. What does CodeSandbox provide that Webpackbin doesn't?
The pinkish background is too strong to be able to read from a distance. Consider a much lighter shade of background colour. 
Totally agree. At the time they backed off from auto-mocking enabled by default it started to evolve into amazing tool. It should be only better in the future given that the number of contributors is only growing.
- You pass apple, you change color of apple -&gt; color will be changed both places - You pass copy of the apple, you change color of that copy of apple -&gt; the copied apple's color will be changed Bonus: - You pass apple/copy of the apple, you reassign that inside the function e.g. `function fn(apple) { apple = {}; }` -&gt; original apple won't be changed.
Sorry, I haven't seen you discussing this already. I will read through it again to find your replies. 
I'm literally done with people calling jquery a language!!!. I would immediately cancel an interview if someone told me that.
There are no pointers involved in this example. `a` is not a pointer. As far as the programmer is concerned, you're passing *the variable itself*. In pass by value, you pass the *contents* of a variable. There might be a pointer involved under the hood, but that is an implementation detail.
That's how Python is as well.
If you can't assign to the parameter, calling it pass-by-reference seems meaningless and confusing.
Yes and no. If you take this to be C++/C code, then yes, it's pass-by-value of course. But OP meant that if you can write some function swap, call it, and then have the variables swapped on the caller side without assigning to them, then you *do* have pass-by-reference. You're right in that for C++, you'd have to have `int&amp; a, int&amp; b`. In C, you couldn't write such a function, hence C does not do pass-by-reference.
What happens if you do `a = b;`? There are no function calls involved here. The same happens when you do a call in a function that's call-by-value (everything in JavaScript) function foo(x) { console.log(x); } For the call `foo(localVariable)`, JavaScript will, behind the scenes, essentially do `x = localVariable;` It follows regular assignment rules, no magic involved, no special "pass-by-object-sharing" or anything, because that's not what you were thinking about when I asked you what `a = b;` did. It's just an assignment. After this assignment, `x` and `localVariable` refer to the same variables, as you would expect. But you have *two* variables. If you assign to either of them, it won't magically affect the other variable. If, however you have a language with pass-by-reference, there is no assignment `x = localVariable` happening behind the scenes. Instead, you pass "the variable itself". That means, that within that function call, `x` will *be* the varible `localVariable`. So we're passing objects or values, we're passing the variables themselves as parameters. Hence, if you assign to `x` inside the function, you're assigning to `localVariable`, because `x` *is* `localVariable`. JavaScript does **not** do this, ever.
&gt; That means the phrase "pass by reference" is also messy terminology. In C/C++, it means a parameter is an alias for something; in Java, it means a parameter is a pointer to something. &gt; This confusion goes away if you think about it with two separate ideas. * On one hand, we have pass-by-reference vs pass-by-value * on the other, we have reference types and value types Yes, it's a cluster fuck that "reference" and "by reference" mean different things, because, maybe, Java thought reusing C++ terminology in a different way was a great idea to attract C++ programmers. Anyway, no "true" authority on Java will tell you that it does "pass-*by-reference*". Yes, we do say that we pass references, which is unfortunate and very confusing. But, we're not saying we do pass-by-reference.
I didn't call it a language, you're obviously still writing JavaScript. There are plenty of people though that can make something work with jQuery that don't really have any idea how and of it works, or don't know how to do anything in JavaScript without jQuery. Thus, they know "jQuery" but have a really poor fundamental understanding of JavaScript. Thankfully this is way less true today than it was a few years ago.
It’s named because of the coffee beans from Java, Indonesia.
Duplicate all the efforts! Why the shit do people keep making more and more of these schema validation library things? There are a billion of these om npm already, some of them quite established, standardized and/or hardened.
I primarily deal with Safari/WebKit and have found various posts on the [WebKit blog](https://webkit.org/blog/) to be informative. There's also an (outdated) [wiki entry for JavaScriptCore](https://trac.webkit.org/wiki/JavaScriptCore). My "JS Innards" bookmarks folder has these links: [SquirrelFish](https://webkit.org/blog/189/announcing-squirrelfish/), [SquirrelFish Extreme](https://webkit.org/blog/214/introducing-squirrelfish-extreme/), [LLInt](http://wingolog.org/archives/2012/06/27/inside-javascriptcores-low-level-interpreter), [FTL JIT](https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/), [Type and Code Coverage](https://webkit.org/blog/3846/type-profiling-and-code-coverage-profiling-for-javascript/), [B3 JIT](https://webkit.org/blog/5852/introducing-the-b3-jit-compiler/), [Riptide Garbage Collector](https://webkit.org/blog/7122/introducing-riptide-webkits-retreating-wavefront-concurrent-garbage-collector/).
This is an interesting case! Let's observe what are you trying to do here. You are declaring a variable that is *implicitly* meant to be used only in test environment and only for test purposes. Your app is meant to work 100% without it. So, to be more explicit, and avoid that this var could be misunderstood and be used for any other reason than tests, I'd rather use a dedicated object for that. A thing you could do is attach that var to "process.env" object: process.env.fontNameCopy = fontName
duh! it breaks on the last example, use this regexp instead: /(\$)([a-z(]+)([^$])/gi 
Because of Javascript's hoising and function scoping, could you move var fontNameCopy to a let at the top of the function and get the same results? 
**Colorblind here** Unable to read
You may be confused because in C, it *would* be fussy to make a huge deal out of the difference between pass by reference in C++ vs "c-style" pass by reference, which is basically passing a pointer to your objects rather than the object itself. These two techniques have the same behavior. Java and Javascript support no such behavior. Objects are not passed by reference in Java or Javascript. Again, as is mentioned all over the thread, in pass by reference, you can alter the object being passed in by overwriting it with an entirely new object, and this change persists outside the scope of the function. So the counterexample in JS would be: function alterObject(obj) { obj = { a: 4, b: 5, c: 6 }; } var myCoolObj = { a: 1, b: 2, c: 3 }; console.log(myCoolObj.a); // 1 alterObject(myCoolObj); console.log(myCoolObj.a); // still 1 
&gt; Namely, you can implement a swap function, call it with swap(a, b); and the variables will have switched values. You can't do this in JavaScript. &gt; So I wonder, why call JavaScript call-by-reference? Holy mother of bike-shedding, people really like to argue about this stuff, huh? :-) Take a step back and think of a language which is *exclusively* pass-by-reference and never pass-by-value would be able to implement the swap() function above. Answer is you wouldn't be, because every assignment will be assigning a new reference to the variable, instead of assigning a value to the previous reference. What makes `swap(a, b)` possible, isn't merely the presence of pass-by-reference semantics, but the *simultaneous support of both types of semantics*. Of course, intuitively when people say "pass-by-reference" they expect the situation found in C++, Pascal and so on. So sure, it's not intuitive to call JavaScript "pass-by-reference". But it's also not intuitive to call it "pass-by-value", because **the only thing you can pass by value is references**. Again if we'll appeal to intuition, when we say "pass-by-value" we expect we have various values which we can pass-by-value, instead of just references. References to numbers, references to strings, references to functions, references to objects... References, references, references. JavaScript never gives you a value to work with, you always only have access to the reference to pass around. So strictly speaking, JavaScript is a "exclusively-pass-references-by-value-only" language. Kind of a mouthful ain't it? But it's accurate, so enjoy saying this every time. 
Any comments on why Angular 2+ and not React?
Works as a charm. It was a bit of logic for Sublime Text snippet generator that I built. Thanks again https://pawelgrzybek.com/snippet-generator/
Not colourblind. Still don't find it at all pleasant to read.
Yep sorry, here is why : Angular 2 is a platform. It is big, but it is good at creating front application (full aplication). Typescript is god sent in term of maintainability, you have a router, component and everything you need out of the box. Also, since you start from scratch integrating the framework will be simple. On the other hand, React (the way I see it) is good to create small component / UI. It also fit well on existing projects. But big project with maintainability concerns? It's doable, but you won't like it. 
It's missing a case. The `new` operator supercedes `bind()`. function a() { console.log(this); } b = a.bind({}); new a(); // this is the new instance new b(); // this is the new instance, not the object from bind().
Also, if there are any other metrics which you think would be useful to track about the stream, I would happy to implement them!
It's the little things.
Thanks I will check it
You're getting a lot of good feedback for diving deep into the implementation details, so here's something from a much higher level: [How Browsers Work: Behind the scenes of modern web browsers](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/) It's a little aged by now, but I think most of it still applies.
As everyone is saying, I have finally updated my post with let/const :)
Thanks! :)
I think something like this will work: `var [user, data] = await Promise.all([userPromise, dataPromise]);`. The two promises will run in parallel.
You're partly right, but it is an implementation detail for extern functions only. Most of the time, the compiler can avoid passing a real pointer. It's only required if you're building a shared-library or something of the sort. What matters are the semantics: you're passing a reference to the storage itself. Same deal with fortran. In fact moreso since it has nested procedures that are never extern. 
Thanks! I'm pretty sure I understand what affects what now, but maybe a diagram could help people learning this. It's pretty confusing to learn what can change and what can't. I guess in layman's terms you can think of it as: You can't change the entire thing, but you can change a part of the entire thing.
Most languages now are call-by-value. The arguments to the function are duplicated and a fresh copy is passed into the function. Some older languages let you skip the copy, and pass the variable itself into the function to be manipulated freely. Typically they did this for performance reasons (no duplication before calling). Fortran, Pascal, and C++ have modes like this. Under the covers, you're just creating a new name for the existing variable, so no copying needed; but you end up mutating the original directly. Languages that still are still developing (Fortran, C++) have fully integrated references, so in addition to the above, you can make `extern` functions with references. To implement these, the compiler must stash a real pointer value into the call signature. This leads to confusion because programmers used to the modern pass-by-value world think that references are *always* implemented with pointers under the covers. Not true though, it's only an extension of the `by-ref` language feature into places where it makes no sense, but users still want it to work, so it gets emulated. I can tell you that a lot of languages implement by-value semantics on top of a pure by-ref calling convention, and it looks like this: void call_by_ref(int&amp; x) {x = 12 + x;} // mutate the by-ref int a = 5; { int __param_copy_a = a; // explicitly duplicate. call_by_ref(__param_copy_a); } assert(a == 5); Compilers often do something like this internally so that optimizing inline functions is easier (you can use normal register pressure tricks to elide parameters)
What if I told you immutability is not a necessary condition of functional programming. Functional programming means functions are first class, and I JavaScript it is 
&gt; A reference is a pointer and a pointer is a reference No, this is false. References are not always pointers. Their original purpose is as an 'alias'. There is no real parameter on the stack, just a compiler trick to let you talk about a variable inside of a procedure. Both names designate the same memory with *no pointer*. The only time a reference becomes *real* is when it's part of an extern function that needs to be linked. Some languages let you do this, and the way they do it is to make a fake reference that looks and acts like one, but is actually a pointer under the covers. Not all call-by-ref languages offer that feature though.
Why are you using var with async/await. T_T
Not bad, but I'm not sure I see any benefit to using this over redux with redux-thunk.
I think people coming to JS are too used to `print()`-like functions so it naturally comes more natural as an approach when you're just starting out.
Imo this would be a great reply with some good info if it wasn't written by an Gaye. 
People coming from other languages knows better than that. They do read up stuff before using it
&gt; the only thing you can pass by value is references. ... References to numbers, references to strings, references to functions, references to objects... References, references, references. The question /u/tutorial_police asked, and that I've also asked you a couple times is: **Where do you source that claim?** It's traditionally understood that primitives pass by value and objects pass by reference-value. So what did you read or hear that led you to believe that even primitives pass by reference-value?
I don't think FP is an antipattern in JS as much as importing a standard library is. We currently have two problems with JS and FP: 1. Insufficient native filter/map/reduce 2. No immutable maps and arrays Using libraries for things that should be stdlib is the antipattern, even if what we're starting with isn't great. Things like lodash and ramda solved one problem but created another. Same with Immutable.JS.
Nice! Please never use `eval` in real code, though.
Definitely. I've seen Angular2 and React apps, where they show how you can use document.write to create stuff, and then gives 100LoC for same stuff without any proper explanation.
Well block-scoped variables don't actually work in this case, so what would be your alternative?
Oof
You're making the assumption that OP and commenters are self-taught, but you don't know this. How do you know they didn't sleep walk through CS school, or are just overly eager freshmen? I'm guessing you're still in school? You would be surprised how many brilliant and informed, self-taught programmers there are out there. You wouldn't know because they're busy writing good software, not reddit comments. While your statements are a correlation I can sympathize with, they're a clumsy over-generalization that may have rubbed some of us autodidacts the wrong way :)
I'm new to JS, why should you never use eval?
now that webpack is dead, what are we using next?
this is real code
I wouldn't stress on that too much. The Wikipedia definition of functional programming is wrong. The next sentence reads: &gt; It is a declarative programming paradigm, which means programming is done with expressions[1] or declarations[2] instead of statements. Functional programming is neither declarative or imperative, but certainly is not procedural. It may be either declarative, imperative, or neither. This has been demonstrated with number examples and by various different languages. The Red language, for example, is functional imperative. Furthermore, if functional programming as a paradigm truly accounts for lambda calculus then side effects and mutability are absolutely available. In this regard reassigning the value of a reference in a child scope, a closure, is certainly a side effect to other unrelated child functions dependent upon that reference. In that regard the data is mutable and state is variant, and yet this is absolutely a fundamental function programming concept. With all the silly bullshit aside functional programming is quite simply programming with functions as the structure by which the code is organized (architecture) opposed to organization by delegation or inheritance. How that code is executed, instructions are passed, or if values are returned all have no bearing if the code represents functional programming as a paradigm. Food for thought: https://en.wikipedia.org/wiki/Organizational_structure#Functional_structure
I swapped propTypes for flow at work and found hundreds of redundant props!
[There's a bug with an outdated/missing uglify dependency that causes webpack's minification to fail.](https://github.com/webpack/webpack/issues/5092) Installing uglify v2 yourself fixes the issue, e.g. `npm i -D uglify-js@2` EDIT: [It's fixed.](https://github.com/webpack-contrib/uglifyjs-webpack-plugin/pull/45)
That works. I don't know how to map that object and return one though. Or how to deeply set it without mutating.
lol
haha :)
God I really hope Webpack doesn't go out of style, while I really enjoy learning new libraries/frameworks/languages I don't enjoy learning tools. I learned browserify then webpack and dreaded every second of it, it's like buying a new TV and setting up the tint and contrast settings using an unfamiliar remote control. I don't want my brain filled up with useless knowledge on how to configure out of style tools, I want that time for learning new development techniques or design patterns. 
I wonder if Rails still auto generates `.coffee` files these days, it wouldn't surprise me if it did since everything feels dated with the framework. 
I was really not looking forward to re-writing my webpack config for the new release, until I checked the release notes and realized the changes were super minimal. I figured "why the hell not" and installed the new version, and didn't have to change a thing. And it did seem a bit faster, so that's cool. Thanks webpack dudes!
Is the `eval` even needed? Does the following not fulfill the calculation needs without exposing the risks involved with eval? ``` let f = new Function(...keys, `return Number(${val.substr(1)})`) ```
The Coding Train on Youtube has some great tutorials.
Everything seemed to be going well, then I noticed that my hot reloading is no longer so hot. I see `[HMR] connected` but ain't nuthin updating. SAD.
That has the exact same issues as eval. You're still dynamically evaluating user input as code.
Makes sense. You could also use something like Selenium to ensure the execution was sandboxed.
`webpack-dev-middleware` doesn't work for me with `webpack@3`. Also it and `webpack-dev-server` have `webpack@2` defined as dependencies.
Oh of course. I knew that. My brain must not be working today. Thanks.
.... for many companies, it is? Not sure what you're trying to get at here
It's a reference to a video, Google his comment
totally agree
Surprised to find that [ydkjs](https://github.com/getify/You-Dont-Know-JS) isn't listed. Not much info on how a browser/v8 implements javascript but does go into great detail on how JavaScript itself works under the hood, which can be a great step before jumping into how different vendors/engines go about implementing those details.
This is one of the reasons I prefer typescript over babel and/or flow. There's very little configuration and the defaults are sane so I spend almost 0 time getting typescript set up.
`will-change: transform` is cool. This looks like a good use-case for it. However, I'm going to be that guy and point out that there are no silver bullets in software engineering. Everything has its trade-offs. [Be aware when using will-change](https://greensock.com/will-change). `will-change` can make your animations look like hot garbage, check out the Chromium bug link from the article https://bugs.chromium.org/p/chromium/issues/detail?id=596382. Opened a year ago, still looks terrible today.
I wanted to play with this and couldn't figure out how to manipulate the code, then see the result. What am I missing?
Okay, yeah I will. I just rolled back to 2.6.1 and it magically started working again.
Summary: Functional programming in JS is an anti-pattern for when using the author's definitions of "functional programming" (pure functional, no exceptions or spectrums) and "JavaScript" (a set of opinionated JS libraries the author doesn't think are simple enough). The solution: learn an entire new language that the author thinks is simpler. My alternative: stop using ImmutableJS. Use seamless-immutable instead, which has no cross-mode cost. Store all state in one immutable variable (store for your react/redux). All other temp variables: const. When coding, assume all variables are const, most are, and there is no harm in treating mutables as immutable. Now you have pure immutability, you didn't have to rewrite your codebase, you don't have a disconnect between the language you write vs the one you run, and you don't have to spend brainpower wondering what mode you are in.
Right now it's in alpha stage, however I'm actively expanding it every night, right now the basic components are there (basic DOM manipulation), the main purpose is mostly a simple manipulation, debugging framework. As I explained over in r/webdev that the biggest feature will be the debugging server provide advanced understanding of errors, bugs, issues in rendering on different browsers/OSes, etc. and allow you to be able to understand why an error occurred and see the steps the end user took before the error occurred and recreate the problem on your end and do live updates to apply a hotfix patch. A lot of the basic stuff can be done with jQuery, but one goal of Oayo is no dependencies except vanilla JS, I am planning to actively maintain, develop, and support this long term, as an entirely free and open source project, and support all browsers to the best I can. A real problem we face at my employer is: 1. We have a dev server, production server - same data and code base 2. Some stuff works on dev perfectly and breaks on production 3. It takes hours to understand why and fix Solution: Oayo Debugger - understand what broke, what steps happened before it broke, what calls, requests, etc. and then apply a fix via hotfix updater; this gives a visual representation of what happened, exact details, etc. and if a problem is specific to a user only? Filter by id, unique hash... etc. and repeat process Also, thanks for that, slight oversight on my part, will add in tomorrow when I work on it more! Cheers and thanks :) 
&gt; I don't think for ... in is map or a function though. map returns a collection. for ... in doesn't. I can't compose for ... in with other functions. Object.keys(obj).map(identity) maps the keys of the object but not the values. You are very correct! Which is why I said: &gt; you could use to make your own specific function that does what you are asking. I am not trying to say that JavaScript comes with what you need but to say it's more confusing than it has to be because it doesn't have a stdlib that you want is a weak argument.
&gt; // Not allowed: &gt; ()&lt;&gt;@,;:\".[] "()&lt;&gt;[]:,;@\\\"!#$%&amp;'-/=?\^_\`{}| ~.a"@example.org is valid. https://en.wikipedia.org/wiki/Email_address#Examples
A single function call, huh? I didn't realize Clojurescript was so small.
The constraint of this codebase is to save every byte possible, without compromising runtime code quality. Obviously, I could spend a few (or hundreds) of bytes to make my code more readable/maintainable, but there are already libraries for that. My selling point is: "as small and fast as possible." Including test code in production code is a no-go.
Report the issue you turd.
Agree, which is why I use Vue CLI so I only do minimal changes on project config. Surely your framework of choice has some sort of scaffolding tools.
That WOULD work, if you had one and only one test on a page. But my test page has dozens of tests. Each time this function ran for each test, the global-scoped process.env.fontNameCopy would be overwritten, resulting in non-deterministic tests (because the tests are all asynchronously finished).
What does it mean "it's traditionally understood"? You want a source, but your source is what is "traditionally understood"? You can go open the V8 source and you'll see for ex. string data refers to the same piece of data on the heap when it's assigned from one variable to the next. It's not copied. Even then it's silly to say "JS is pass-by-something" because **V8 has no less than half a dozen unique string implementations**, and they all behave differently in terms of internal characteristics when passed, are combined, split etc. Why are engines handling primitives in such a heterogenous way? Because when primitives are immutable, **there's no visible way to the user, that determines if they are passed by value or by reference**. If you want to get technical, internally JS engines pass strings by reference (most of the time), while numbers, booleans and null are passed by value, simply depending on what's faster, and not due to semantics at all. The ECMAScript specification doesn't officially label JS as being "pass by whatever", since due to details like I just mentioned, slapping a lazy label like this over the entire language is utterly unhelpful. Engine details aside, when explaining the semantics to a JS user, not to a JS engine writer, the distinction is quite meaningless, because, again, primitives are immutable. So why say "this is passed one way, and that is passed another way", when a simpler explanation is also valid? You know how JS works from a user perspective, try to come up with a single example that demonstrates that "primitives are passed by value". You can't. Which is why engines do whatever is faster in every specific scenario, and this whole conversation is stupid.
From the examples on the main page it seems you are using callbacks. You should probably switch to a promise based API so that your library can be used with `then()`, async/await, or even RX. I skimmed over your code and it also seems you are using ES5 with self pattern, etc. Why not use ES6?
Fine, just use it if it works for you. Nobody's stopping you.
Use Number.isNaN() instead. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
Hrmm, so what exactly are you saying I should do?
&gt; What does it mean "it's traditionally understood"? You want a source, but your source is what is "traditionally understood"? For example, https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions &gt; Primitive parameters (such as a number) are passed to functions by value Another observable difference comes with equality tests. let numberValue1 = 7; let numberValue2 = 7; numberValue1 === numberValue2; // true let numberReferenceValue1 = new Number(7); let numberReferenceValue2 = new Number(7); numberReferenceValue1 === numberReferenceValue2; // false Now, it's certainly possible that MDN is misleading here. It's happened before. And like I said in an earlier post, I was genuinely trying to discern from the spec how primitives and objects are handled. But the spec is surprisingly non-specific on that subject. Right now, I couldn't even cite the spec to you to justify saying that objects are held and passed as reference-values, even though we all know they are. &gt; Because when primitives are immutable, there's no visible way to the user, that determines if they are passed by value or by reference. That's a genuinely thought provoking statement, and I can't find any fault with it. But saying we can't tell the difference is very different than positively asserting that everything, even primitives, are passed as reference-values. Maybe it will turn out you're right. But even if you are, you didn't divine that knowledge. You got it from somewhere. And so far that's all we've asked of you: What's your source?
I don't want that var there either. It's just that I can't find a way to remove it without breaking other constraints. I welcome suggestions.
Wow! Very cute code. 
Yeah, like I said in the post: &gt; will-change: transform creates a separate layer for an element. Notice you shouldn't use it with too many items and it doesn't necessarily make things faster! I also posted the link, where there's a lot of good info: https://developer.mozilla.org/en-US/docs/Web/CSS/will-change
Yes I have read those. They are what motivated me to learn more about the internals :)
Found this project https://github.com/diegohaz/rest Although it's not exactly what I was looking for, it says it can generate REST API using best practices.
Had the same, issue [here](https://github.com/webpack/webpack-dev-server/issues/949)
Tabs vs spaces, Brace placement These are explains of, " I don't like this because I'm not used to it"
You are an amazing example on "how not to be updated"
You get used to it pretty fast. And I think also beginners should understand them. I also didn't start with Python 2.7 to understand Python 3. It's just a matter of time. I hope you don't get confused by the following, which does actually the same: `value =&gt; value`
It was confusing at start for me as well, but after a couple days it became second nature. It's much more concise to type and read, despite the syntax being really strange at first. 
why not? since most codebases will have them it's good to get to know what they do. You don't even need to spend much time getting used to them. 1 week max.
Someday I'll get off my ass and switch from webpack 1. Webpack 1's still working great tho!
&gt; But saying we can't tell the difference is very different than positively asserting that everything, even primitives, are passed as reference-values. Maybe it will turn out you're right. But even if you are, you didn't divine that knowledge. You got it from somewhere. And so far that's all we've asked of you: What's your source? As I said you can read about string handling in V8 and you'll see string values are a reference type in the engine. It goes even deeper: when you concatenate two strings into a third string in V8, like this: var three = one + two; Now `three` doesn't contain an actual string, but only two references: to `one` and `two`. This kind of optimization is possible precisely because you can't tell, as a JS user, if an immutable type is passed by value or by reference.
Wow they decaffeinated coffeescript transpiler code? :DDD LOL
It depends. If you can push the work client-side then you could save yourself significant server resources and potentially make the application appear more responsive. *But* do make sure you test on mobile platforms if they are part of your target as they have considerable less power so pushing work that way may backfire. Beyond those considerations it comes down to what it is easier for your to maintain. If you have *all* the data available server-side but need some extra requests to get it client-side there is extra complexity and potential points of failure.
I suggest you use KoaJs instead. Although fundamentally not that different to Express, it makes working with Async/Await a lot easier.
True, the only difference being that strings are passed as reference by default.
I like it because of "less logic" approach – it's great for making an output, not for putting some logic into a template. And the syntax is pretty clear, while it take some time to understand partials/blocks at the first time.
So, solution is using library+more code+uglier code. okay.
You're absolutely right in that. Even angular 1 was originally released in 2010. But it took a while until people started embracing JS instead of avoiding it, or using outdated methods to manipulate the DOM theirselves.
&gt; I see it as some weird kind of expression Well, they are expressions. There are no arrow function declarations or methods in JavaScript. (Dart supports those, for example.) &gt; I still find them intensely confusing. You'll get used to it, don't worry.
I think it's the = sign that gets me. Like in this example for instance: const doSomething = (foo) =&gt; ({ bar }); That looks like assigning doSomething to the value of foo to the value of.... oh wait it's an arrow function.
&gt; The confusion might come because it looks like an operator rather than a statement Yes I think so! It definitely looks like an operator. const squares = [1,2,3,4].map(function(x) x**2) What is that function even doing? Can you even have functions without curly braces?? It looks awful. If that's a legal way to write single-line functions I never want to do it. I would *always* do this: const squares = [1,2,3,4].map(function(x) { x**2; }); ...which is infinitely easier to read (or perhaps comprehend is a better fit) than what it was. Maybe it's just because I came from C++ originally and while I've been programming in JS for more than a year I still find I need very strict syntax to enjoy JS. I do love being able to shove properties into whatever object I like though :P
HTML Webpack Plugin [doesn't work](https://github.com/jantimon/html-webpack-plugin/issues/705) atm. Throws a null (undefined) pointer.
There really isn't any utility here. A project with no issues shows as green, but it may not have been touched in years.
This article is a great example of overcomplicating something simple.
Keep in mind the two have different specific use-cases, so replacing Rollup with Webpack may not be a benefit to you - definitely worth comparing if you have the time and right project ;)
I love them. Super useful.
Should probably just link to udemy? It's $10 btw, they claim it's a sale but I have a feeling it isn't.
This is part II of my [previous 'await' article](https://www.reddit.com/r/javascript/comments/6ide7e/es2017s_asyncawait_is_the_best_thing_to_ever/), with a lot more technical details on moving to async/await, including: - eslint config - node config - getting proper tracebacks and using util.promisify - testing - implementing common promise patterns with 'await' - how to handle await refactoring for larger codebases Give me a shout if you need anything!
I love them. I was on a project that used mongo and there was no way I was using callbacks to manage the logic around the queries. I found async via a node flag and haven't looked back. In his example, would the call to `getPhotosAndSaveThem` require `await` in front of it? It would in python 
Great concept – thanks for putting this out there! Unfortunately, it conflicts with [octolinker](https://octolinker.github.io/)'s functionality. Maybe if it displayed the summary in comments automatically (without clicking) or as a `title` prop/popover? Also, some screenshots on the chrome store and/or repo might help convey the functionality better and overcome security FUD.
Why do you need a template language? What is that you expect from one? When you choose any library, the "what" and "why" questions should always be asked. Since you are asking for input, can you answer those so you can get some meaningful feedback instead of everyone's personal preference? 
Promises in general are some of my favorite new features in JS. This looks great!
I just don't understand what's wrong with `{user.name &amp;&amp; &lt;Hello name={user.name} /&gt;}`. The component should focus on the display, and the container on the logic. That way, the decision of whether or not display the component is left to the container. Sounds perfectly reasonable to me; simple to use, and readable.
I don't see anything on this site for proposing content. Is there a process for doing so? Is there a charge for listing something? 
Oh, I see, didn't know that. Does anyone?
Exactly. People are just lazy and they want to use lib for anything.
I use https://recordnotfound.com/ as it gives more info regarding popularity and activity as such... 
NaN is very strange, look at this: (NaN === NaN) is false
[removed]
Thanks for sharing this - I have a pretty big production coffeescript codebase, and I found it very helpful when I was designing our company's development strategy five years ago. But I totally understand this sentiment: &gt;JavaScript is the future, in part thanks to CoffeeScript. Now that it has served its purpose, it's time to move on. Convert your CoffeeScript source to modern JavaScript with decaffeinate. This could be very helpful for us moving forward.
I don't think I'd say `async/await` is the best thing to ever happen to JS, I'm somewhat torn between Node, Babel, and arrow functions. Node was a huge explosion in popularity for JS and is, IMO, the point when people really started taking JS seriously as a language, and not just as a client-side toy. Babel, and the general idea of compiling modern JS down to browser-supported JS has been huge for making JS development more palatable. It doesn't matter how cool arrow functions or `async/await` are if you can't use them for the years it takes for everyone to move off of unsupported platforms. And arrow functions just make JS code a lot nicer to read and write, it makes the functional style a lot more appealing, and it eliminates a fair bit of the hassle with dealing with `this`.
Yes, you are on the only one. No, they are not going away. So you better learn to live with them.
da hell is wrong with you dude?
browserify for life
Try/catch everything.
I have just taken a course through this site and it really is $10👍
&gt; The way I see it is that async / await kinda evolved from clever hacks like co that use generator functions Async/await was borrowed from other languages. C# had it since 2012. Generators were introduced with ES2015 (ES6).
Same way as other Errors - just catch them! That said if you don't expect errors, you're not actually forced to handle them - much like Python Ruby etc 
Idea is that you can add it to your own account, and then adjust to your needs. Or you can just take a look at the sources and use it somewhere else if that's your preference :)
I'd steer you towards working with tech that you're already familiar with for serious projects. You're probably going to have to re-write everything multiple times anyway before you get a release that you're comfortable with, so you might as well get version 1.0 out as soon as possible.
I think the tricky part may be this: document.getElementById('file').onchange = function(){ I dont care about an onchange event
If the file is stored on the internet you will need to make a network request to GET it. To do this you could either use fetch or xhr, once you have your file you will then do all the other stuff. This will replace selecting the file from an element, as instead of getting it from the DOM you're getting it via network request. On phone so formatting will be bad, but you want to do something like this: Const getFile = async ({ address }) =&gt; { Const file = await fetch(address, { // ...options }) // do something with your file }
Show me atleast one real-world example where React components are wrapped in function(Which you have to write yourself too) to perform simple `{condition &amp;&amp; &lt;custom-element /&gt;}`.
You can still use classic XHR requests with callbacks instead of the fancy ES6 features though. See https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest and https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
I like to hear that. I thought everyone agreed on this in JS community. What was my astonishment when I encountered a colleague who preferred to work with raw promises instead of async/await. He said the indentation made it more obvious that function is async. What a dumb argument.
&gt; not actually forced to handle them - much like Python Ruby etc I understand that you don't need a try/catch block necessarily but how would I know this, depending on my situation? I should at least always try/catch HTTP requests, right? Any high-level explanation for how this is approached in Python &amp; Ruby is also appreciated.
Node &amp; Babel sure, but arrow functions? It's just syntactical sugar that in some cases (with several chained) can be a PITA to read.
A good example is some async stuff which only fails when your server is disconnected from the network. Eg, I connect to a database that's on my local network, and if this fails, I'm quite happy to have node crash, because chances are that server has somehow become disconnected from my private network, or the DB server itself is down. Catching the Error wouldn't provide any more value, or help me work around or diagnose the problem more. `Uncaught rejection: couldn't connect to DB` is fine. 
To be honest, I don't really see the point of that method. If you want an array's iterator (e.g. for the sake of conforming to some interface), just use Symbol.iterator like you'd use in any other case. &gt; [][Symbol.iterator] ƒ values() { [native code] }
Looks like Coffeescript redux.
Lodash has mapValues and mapKeys
I somewhat disagree with Nodejs being what made js taken seriously. It was a boost for sure, but JS was and still is the only thing that runs on browsers. This fact alone would be enough to make JS crucial to the whole tech industry
Author here. The amount of time I've been programming with JS is cleverly hidden in the first sentence of the article. 😂 And yes, you're right. I get, if that's the point you're making, that jQuery providing consistency on top of the DOM API was massive. However I think of the DOM API as one level above JavaScript the language. 
You are the master of intriguing post titles.
Haha, I'm not saying they have no value, just disagreeing with their place on the list of the best things to happen to JS recently :D But it's just personal preference. I find them them nearly the same to read and I never actually type `function(){ }` anyway, I just type `fn→`, `fnm→`, etc for various flavors, bindings, ... I still almost never use them (or any anonymous function) for one reason: I like function names in stack traces :) Uglify strips them for prod.
Meanwhile, the linter we use at work is quite old and doesn't allow let and const. I really should push to get it updated.
Doesn't seem like the link is working :/ If you were wondering how, I found this post through BeeHyve that has a sample implementation! http://www.beehyve.io/data-structures/post/1497986129319-binary-search-tree-implementation-javascript 
😂. That's also how I roll...
Funny you say that, [this is how I roll...](https://www.youtube.com/watch?v=dQw4w9WgXcQ)
Thanks Mike, for putting into words my frustrations with every person who has tried advocating for Promises... The argument is always the same... no more callback pyramids...! Except I haven't written a pyramid in years. It's an anti-pattern that tells me it's time for an async.waterfall. I'm sure there are other compelling arguments, but none seemed to convince me.
The transformation is actually quite complicated. Check TSC's or Babel's output.
You can put an IP6 address there or even just a TLD. Email addresses are fucking weird.
How's the JSX experience over in vim land? 
I think this is cool
Actually no, that's wrong, mine is right. `this[Symbol.iterator]` is a function that returns an iterator when invoked. Here's a quick test that proves it. Note that you'll have to run this in a browser that implements `Array.prototype.values` https://jsfiddle.net/86owc4w8/1/ // polyfill [].values() by a different name so we can compare against the native implementation Array.prototype.values2 = [][Symbol.iterator]; var a = [1, 2, 3]; for(let v of a.values()) { alert(v); } for(let v of a.values2()) { alert(v); }
I forgot the invocation parens. But you're right. It doesn't need to be this array's array iterator.
 Array.prototype.bananas = function() { return this[Symbol.iterator](); }; for (let v of [1, 2, 3].bananas()) { console.log(v); } Logs: 1, 2, 3
Lol. Didn't know about those. Map keys seems to be the map I expect in this case (return an object if given an object and allow iteration over keys and values of the object). Thanks for pointing them out! I still think it's easier to have just one map function (called `map`) that works on arrays and objects and is part of the language.
Use a different one for each template you create, and once you run out, make new ones! That way you can learn more of them in one go, and it'll look great for your resume. ^/s
What’s the problem with Promises? I’ve just started using them with angular
Sorry about that. Right now, the site is migrating to another server at the moment. **Update**: The site is back up and running. Thank you for letting me know :)
 // Where 'obj' has props you want to swap function swap(obj, key1, key2){ var tmp = obj[key1]; obj[key1] = obj[key2]; obj[key2] = tmp; } 
The problem with conditional rendering is that React will unmount such component (to hide) and mount again (to show). So if you want to avoid recreating components (e.g. to keep state) it would be probably better to set `display: none`(AFAIK, maybe there is another solution? I know Vue has `keep-alive` component for that: https://vuejs.org/v2/api/#keep-alive ) 
Because React is too simple to have fun. Programmers like to have intellectual chalenges.
not the most legible code I've ever seen but definitely interesting + concise! love the ol' xp style
I also use Namecheap for domains. For static hosting I have used [NearlyFreeSpeech.net](https://www.nearlyfreespeech.net) where you pay only for what you use. They support some dynamic web frameworks too.
I really hate that there isn't a more elegant or at least a less ugly way to do it
Nothing, promises are great
Domain from Namecheap and hosting from RamNode. 
i'd imagine it's for api consistency with e.g. map &amp; set
You could create a function that calls async functions in a try/catch for you and when done it calls a "I'm done"-function that you can pass to it. ...wait a minute
const a = b =&gt; console.log(b) a.name = 'log' a(1)
Lol, that's not better
In some situations where `this` is important it might be. My point is that it's possible though.
it is kind of ugly, but it is much less ugly than having one way of handling async errors and a different way of handling sync errors.
What advantage offers vim against for example vs code? I mean, I've always heard that vim is fast as hell and improves productivity but i find it kinda strange, ugly and uncomfortable to work with (i find all those char combos like mortal kombat fatalities). I think it's about to get used to it but does it really improve that much?
Maybe in lambda calculus, but in Javascript it's called an arrow function. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions
Oh, well I didn't know how map worked, I was just going on what was written. I googled map to see what it did; seems pretty simple, it just runs the provided function on every element of the array. Not sure why it's called "map" though; jQuery's "each" does a similar thing and that name makes much more sense. Doesn't bother me, just seems a bit of an odd name to choose. How would the arrow function syntax look with a return? Like this? const squares = [1,2,3,4].map(x =&gt; { return x**2; }); Thinking about it some more, I think it's confusing because there's no name associated with the function. Every other part of the language uses actual names for things. Variables are named, and they contain things. Functions are named, and they do things. Anonymous functions aren't named, but they behave like an object where doing `function(){}` returns what can be thought of as a "function object" (even if it's just a function, not an object). There's just no way to make sense of what the arrow is doing. I have to say it looks distinctly more readable with the curly braces in there though, and the semicolon. Cannot stand not having them. I can never tell where a line has actually finished when there's no semicolon.
Could you please explain what you mean by this distinction?
I think that /u/mailto_devnull was suggesting that the use of 'await' in conjunction with promises can entail more readable code compared with the use of 'then' in conjunction with promises. It's not so much a matter of promises being 'bad' as how best to interact with them in common scenarios. I'd generally agree on this point, as callbacks can look a bit 'heavy' in comparison to 'awaits'. 
pasition v1.0 released ! Path Transition with little JS code, render to anywhere. Lots of optimizations and adjustments.
Wholeheartedly agree. 
This is because people misuse Promise rejections. A Promise is not an if / then. It is a "give me a value" / **"OMG FAIL"** . If `await` had been introduced with promises it would have been a lot more obvious that rejecting is not the right way to handle these kind of conditions. Think about it this way, do you use a lot of synchronous libraries that use `throw` to pass back return status? Probably not, because you'd really hate having to wrap all their API calls in a try/catch. The `await` is intended to give a sync-like control flow to Promises and inappropriate rejections are screwing things up.
I would highly recommend HostMonster. I got all of my domains and hosting from them. Great service, speed, etc
Do promises support multiple return values? resolve(error, data)?
what was the fix? was it changing to `function` from `arrow functions` i guess, that should not make any difference here.. const start = async function(){ try { await getPhotosAndSaveThem(); } catch (error) { log(`Oh no, something went wrong!`, error); } }
I've been using this in all my new projects lately and contributing where I can - been loving it so far. Happy to answer any questions here or you can also check out the gitter chat if you want to join in. Pretty active. [gitter link](https://gitter.im/lightscript/Lobby)
Openly admitting to not care about clean looking code on a programming sub? Pug isn't HTML, but ES6/7 _is_ JS.
What operating system are you running on? 
How does canceling a generator differ from doing something like: let cancel; async function loadWhatever() { const response = await fetch('whatever'); if (cancel) throw 'Processing canceled'; // Do something with response } loadWhatever(); // When user wants to navigate to a new view: cancel = true; Of course with `fetch` you can't (yet) cancel the actual request after it has been invoked, but generators change nothing there.
Yosemite
It's just incorrect English it's nothing to do with the content or what he's saying. "JS now has with a syntax" isn't right.
sorry i didn't realise i was being condescending. could you point out where?
Is there a difference between: promise.then((res) =&gt; {console.log(res) }) and await promise console.log(promise) 
The "with" shouldn't be there. He probably left it in after an edit. 
Are you using the CLI to run the flow server, or are you using it as part of an editor or IDE? (Since you said "every time I save", it's ambiguous)
What's your point? There are many ways to skin a cat in any programming language. If you don't like that JS gives you multiple options for the same thing, then don't use it?
Thanks for the explanations! I'm starting to realise that a lot of (especially newer) JS is based on traditional mathematics, an area I'm incredibly weak in. I always seriously struggled in school (well, at home; I was homeschooled... but I digress) with maths. Now that I've been programming for many years I find simple algebra to be very easy and fun since it can be directly related back to programming in my mind, but if it starts to use maths-specific symbols and techniques I get lost almost immediately. I wish there was a way to use arrow functions without the awkward syntax... maybe I'll have to make a simple compiler that takes source files with some custom keyword for arrow functions ("arrowFunction()"?) and converts instances of that keyword to proper arrow function syntax :P Thanks again. I'm very slowly starting to see "(x) =&gt; {}" as a whole unit instead of a left side then some weird operator and a right side.
You posted this exact link a month ago: https://www.reddit.com/r/javascript/comments/6a0rjb/cookiedb_stroring_structured_data_with_clientside/ Nothing has changed in the repository since then. Why post this again? --- Also: https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB
I like them too, like ALOT. But I'm confused about 1 thing, maybe someone can enlighten me. I hear more and more that I should be using Observables for HTTP calls, I don't like them and don't see the point of them 90% of the time, plus you can't use async on them. What's the deal there?
Yikes
I don't like decorators in any language. I first encountered them in python. They reduce readability.
See, this just made my day. I'm happy to help. Fun fact: if you're interested in compilers and syntax transformations (and not intimidated by it, as many programmers are) you are, by definition, perfectly capable of at least one branch of higher mathematics: formal languages are a well-defined mathematical topic. So don't think too poorly of yourself. ;) (For what it's worth, I completely hit a wall in college when I was trying to learn engineering math. I was trying to mess around with calculus the other day, and realized I don't remember a damn thing, other than a general kind of intuition.) If you're interested in writing a syntax transformation, maybe take a look at the Babel project. It packages syntax transformations individually, and there might be some interesting ideas there that you could adapt for your own project. After all, good artists borrow, great artists steal. :)
It gives so little fucks that you have to transpile your precious `async awaits`
Ooooooh [: Thanks! That's pretty dope. Appreciate it. [: 
Yeah that was all I was saying. Figured maybe OP would want to edit that out.
I don't think so, because once ie dies, modern evergreen browsers are firmly established and language features are more granular then we will be in an enviroment where transpilation may nit be strictly neccessary.
Thanks! I'll definitely look into both, just from the comments Namecheap seems like a pretty good option. If there's any particular reason why you picked RamNode though, let me know. [: Cheers!
I've always wanted to move to the AU! Thanks for the options, really appreciate it. [: 
&gt; subjectively leaning towards whatever the majority uses Answered in OP :) I want to know what the most popular is, which branches off to most supported and ease of finding answers to Q+A, if I were to Google issues
This may be a grand idea! I almost just used Pug again, because I know it. However, esp. since it's slower, I should definitely lean towards what is popular outside of Pug
Nice! This is what I've been leaning towards, and is what I'll most likely do.
Languages always evolve; that's the nature of them. If you're concerned about the future of this language, then get involved with the process: https://github.com/tc39/proposals.
You're probably using Angular, which uses Observables as the default primitive for HTTP responses. In that case, it makes sense to use them, rather than converting to Promises for the sake of it. Other than that, they mostly make sense for some use cases that probably don't apply to you (e.g. wanting to combine the responses of multiple dependent requests, cancelling requests, etc.).
It doesn't make your code behave like synchronous code; execution of the rest of the block is halted until the values come in.
Read, dude. https://bugs.chromium.org/p/chromium/issues/detail?id=615873 https://bugzilla.mozilla.org/show_bug.cgi?id=1299593
&gt; I feel like this thread is getting ahead of itself and complaining that something What else am I to do with my free time?
Does that 20% speed reduction causes any noticeable degradation in performance to the end user. I'm going to guess it doesn't. Even a 100% performance reduction may still be blazingly fast.
Depends what you mean by "in production". Our source code relies on that heavily (async/await, generator functions, destructuring, classes) but the browser code is compiled back to IE 11-compatible JS through Babel. Our Node code uses new features as soon as we upgrade our Node version, though. In terms of frameworks, we use Ember and love it. Highly recommend checking it out. 
I would suggest writing a benchmark that uses the native implementation of async/await in Node v7.6+. This comparison uses that [asyncawait library](https://github.com/yortus/asyncawait) last committed to "a year ago"
express-handlebars is your friend!
Those are supposed to be used in-dev only, not for production.
Yep, definitely. It's not an issue for end users, but for developers. For them, it doesn't matter if you use the cert in dev only: the issue is that developers need to trust the CA certificate during dev, and that then immediately exposes those developers to unavoidable trivial MitM from anybody anywhere in future.
why not? if it reduces development and maintenance efforts, 20% of performance reduction is a constant value, while development maintenance cost will grow with the size of the project, and at some point, it will be much bigger than the cost of the cloud time for performance
Kind of want to see what some of the talks are on before purchasing a ticket. 
Yeah my async unit tests now look exactly like my sync unit tests - no more 'done' callback.
Parent function needed the 'async' keyword.
Uncaught errors still end up in logs. The load balancer notices the server not responding and return a 503, disabling the server.
This is actually a very important clarification. I would have agreed with /u/power-lift but yeah if it's server side the 20% can matter a lot. Can't you just transpile the async await into promises for now with babel or whatever until they are better optimized by node?
*If* the core of most requests is CPU-bound and there is little or no concurrency, which is very rarely the case. In most applications there is a lot more time spent waiting for IO of some sort (particularly database access). They appear to have accounted for that with the "largest" sample function, but the write up doesn't suggest concurrent requests were made - I suspect that IO load and/or IO contention will become more significant as request concurrency increases meaning that the per-request performance difference between the methods will fall significantly. The obvious exception would be if you were performing a definitely CPU-bound operation, some number crunching or some sort of data content/structure transformation perhaps, but in that case you probably want to pass that work to a separate worker thread and let it be done sequentially for optimal performance only calling back on completion/error (and perhaps occasionally for progress updates if it is a really long process).
JSX does not break standards. E4X was a fixed standard baked into mozillas engine back then, Angulars custom props break web standards in half. But `createElement(el, props, ...children)` which JSX yields is merely an interface that describes an element prototype, be it a dom node, a three-js object, or a native view. That is why it transcends platform standards. &gt; if you don't know HTML, you code is going to be shitty in browsers, Not at all. You need to know CSS, and a few basic tags. It's pretty much the other way round, if you don't know JSX, your app is going to be shitty. Making a complex application in HTML, a blob of div soups, id hooks, dom queries, that would be like going back to the dark ages. I agree otherwise, but my perspective seems to be different. It is insane what we have to do today to make sure an app behaves more or less the same in different browsers. And that is HTML's fault, and CSS's of course. Two old, broken technologies made for docs and spreadsheets, not for applications. A renderer can abstract it. The majority of Reacts-dom's production size for instance is about normalizing crazy HTML behaviour.
This is good but it's not a golden bullet but it's a big improvement. It still requires discipline. Async functions return a promise and you can quickly get into a promise chain hell. 
Which is how synchronous code behaves.
LB doesn't reboot the server, just disables it. Rebooting doesn't generally fix network connectivity problems (or problems in general). The error is handled properly - user is given a 503. Adding code to handle every possible error does not take 'no time at all'.
Ah sorry, I had to emphasise: the values might come in asynchronously, which is not the case with synchronous code (or at least, the time scales are vastly different). Hence, it's actually likely that other code will run in between.
Ideal syntactic sugar for composition would look like this: const add2Mul3 = add(2) |&gt; mul(3) This can be useful when supplying parameters to .map or .forEach **inline**. Correct me if I'm wrong, but it seems that decorators are intended only for methods/constructors. For the same behaviour I'd have to do something like this, and adapt add() and mul() to work with methods: class A { @adapt(add(2)) @adapt(mul(3)) add2Mul3(id) { return id } // could this be omitted? } So do decorators have any use in functional JS? Could adapt() be omitted? Could result forwarding be omitted? Do they have any use apart from logging method inputs/outputs?
If you are paid by the hour for debugging, it could become a gold mine!
Well for the kind of CS professor I was trying to reference, this is a meme. Maybe I should add more context to jokes next thyme.
ES7 is finished and shipped without decorators. Decorators currently sit at stage 2 so no thank you. I'd rather not use draft features, knowing that they could very well change in the future and my implementation would then only be compatible through an older version of a transpiler. Stage 2 is interesting for experimenting and feedbacking proposed features, but there's no way I'd ever use anything in stage 2 in production code. Look at what happened to Object.observe. 
Depends on your needs. I wanted a VPS so I would have full control e.g. root shell access, and ability to install and configure the OS as I pleased. I use Ramnode for my personal website which is primarily static and gets low traffic. I pay about $13 per year which is pretty cheap. You can find reviews and deals on VPSs on lowendbox.com I've used nearlyfreespeech in the past as well, worked okay. Github pages seems like a good option if your site is static.
So I read half way through the article but dont really understand what decorators do. Can someone explain to me the Problem theyre trying to solve? 
"I will be using Typescript for the examples in this article." Can you please xpost this over to /r/typescript op?
Sounds like DOM events to me.
Have you ever had an actual discussion on reddit? That's the intention but it's sure not how it works. This sub in particular is very strange where unless you are of a certain mindset you get downvoted. Of course my comment had a point. It was an opinion but so were lots of other comments but it still had a point. For those that did not get the point or who disagree did they ask for clarification? No they just downvoted which is not what the feature is for. So don't give me, the whole "we respect all points of view let's have a peaceful discussion" line. If post a comment contrary to the general opinion it will get downvoted. Even though I love Javascript and have been using it for over a decade my opinion is not welcome here. That's kind of bullshit if you ask me. Especially since any opinion on Javascript short if "it sucks" should be welcome. But you all go ahead and downvote if you want. 
No, thats not how this sub works. You literally stated the way you FEEL without any reason as to WHY you feel that way. In what way do you think, according to the way reddit was supposed to be used, does your comment qualify for upvotes?? I bet you good money that if you had written your ideas out and have brought up some points in a well rounded text, no one would straight away go for the downvote. What youre talking about of course is also true, that the general oppinion will be upvoted more than any one elses but thats absolutely normal. The difference here is that if really the only reason for your downvotes was your oppinion then you'd only have 0 or -1 karma. The real reason for all your downvotes however is the not so well thought out one-liner without even trying to back yourself out. That shit just won't fly. EDIT: and also, you're the only one reading this. I know it was YOU who downvoted me... :D EDIT2: Also, why should I ask for clarification if on reddit, youre supposed to provide your explaination right away. 
Async has a higher overhead, so you can't just pack async into a normal function and allow await everywhere, while still allowing for optimization. 
No, definitely not, but async functions are a side effect and you will need to interface with them at some point in your program. The only current way I can see to do this is using the returned promise from the async function.
I always feel like these are missing an example between callbacks → promises of the async helper libraries people use to manage the callbacks and do error checking once at the end, e.g. with run-auto and run-parallel: getBalances(cb) { auto({ accounts: (cb) =&gt; web.eth.accounts(cb), balances: ['accounts', ({accounts}, cb) =&gt; parallel( accounts.map(account =&gt; cb =&gt; web3.eth.getBalance(account, cb)), cb )] }, (err, {accounts, balances}) =&gt; { if (err) return cb(err) cb(null, Ramda.zipObject(accounts, balances)) }) }
Look, there is no reason for me to try and deny the reddit hive mind and how it works. I guess I am just saying that especially if you already know how reddit works and how to spark actual discussion instead of hatred and downvotes you should either do that or not comment at all. You're right that the majority oppinion is what gets upvotes but that does not mean that its impossible to generate good discussion by questioning the given view in a constructive manner. (Which was the exact opposite of your original comment)
ES8 is nearly out too. I don't understand why people keep calling new featured ES7. And the current stage 2 decorators don't even match the interface defined in this blog post. Adopting features like this so early just adds to the confusion. They are experimental for a reason, people!
Started using lodash heavily lately. Sometimes I wonder why I did not start using it earlier. Have many, many things that I was writing by hand everytime. Saves a LOT of time (people, don't recommend rambda please, if someone willing to do so, I hate "pure only library" approach, where library does not provide sample, shuffle functions just because of that paradigm)
Agreed, though the renderer will normalize buggy implementations across vendors. That's what react does for styles, html and events. You start to worry less about the implementation target (dom &amp; html), so you can focus on the app itself. In the two examples, at least vue is based on the same principles internally (createElement). I believe the majority of todays frameworks use it. 
&gt; that does not mean that its impossible to generate good discussion That is why I am so confused. If this were /r/politics I wouldn't even bother. Any non-mainstream opinion can and will be destroyed there but this is a really niche sub and it is especially confusing.
Hmm. Okay. I'm mostly surprised to find 5.5k downloads for this? I respect the developer for contributing to the community but this is less than one line of code to create. In addition this doesn't look as compatible as the built in tools. Frankly. Although this is great, It's **exactly** https://github.com/kevva/is-negative? Lets see the difference: **Positive.js:** 0a731f0 on Jan 11, 2016 function (n) { return toString.call(n) === '[object Number]' &amp;&amp; n &gt; 0; }; **negative.js** function (n) { return toString.call(n) === '[object Number]' &amp;&amp; n &lt; 0; }; Or maybe I could just write "Math.abs(n) &gt; 0" and save a bunch of imports... --- *Edit: Fair cop - Math.abs() is silly thing to reply with. This should be "n &gt; 0". 
I agree... fuck `ie` man. &gt; People who actually use ie is because it came with the os and it serves them. Doesn't windows 10 come with edge instead of ie?
Ok check this out. I didn't start really learning JS until 2011. Prior to that I had done back end development for 15 years. I went through the exact same pain you are describing. As others have said, you just have to build real projects. It will come together and make sense.
For those interested in **(classical) Object Oriented programming**, CrxOop's implementation supports the following features: * **Classes.** * **Class public constructors.** * **Class public and private variables.** Public variables are supported on roughly IE9 era browsers and later. * **Class public, protected and private functions.** * **Class public virtual, protected virtual, and private virtual functions**, including support for "finals" and pure virtual functions. Pure virtual functions can not be finals. * **Casting.** * **Data Typing.** See also Class Typing. * **Class public and private static variables.** Private static variables are supported on roughly IE9 era browsers and later. * **Class public and private constants.** Private constants are supported on roughly IE9 era browsers and later. * **Class public and private static functions.** These are supported in roughly IE9 era browsers and later. More precisely, from the IE family, IE8 and earlier will not work, and from the Safari family, only Safari running on very recent MAC OS versions will work. Further more, these only work in the Non Strict JS version of the library. * **Abstract Classes.** * **Anonymous Classes.** * **Interfaces** (a Class with only public pure virtual methods).
Nice try, DiscoverSDK.
I do just want static pages. That sounds not bad at all. Thanks and thanks for shared numbers, it helps give me a bit of perspective. Cheers!
Thanks for elaborating! [: Really appreciate it. Thank you! 
Even though it is not that widely used (anymore), this really sounds like a project for which SproutCore is very suitable. In case you didn't hear about it yet: it is the framework used by Apple to build iWork.com, the original versions of MobileMe and iCloud. It is a Cocoa-like framework for the web. Feel free to come and have a chat at https://gitter.im/sproutcore/sproutcore
Maybe because it's early in the morning. But, I kind of don't follow. Sorry. So what do you use, exactly? Thanks. 
What are the challenges in writing such a system? Is this a matter of keeping track of forces that work on e.g. a triangular basis element, and doing hit-testing so the triangles cannot move through objects or other triangles?
Just one example is declaratively associating runtime metadata with a class. For example, if you write a class that should deserialize from JSON in a specific way, you can declare that info with decorators: class BlogPost { title: string; body: string; // After receiving JSON from the server, invoke new Date(jsonString) rather than blindly assigning the value @ParseDate publicationDate: Date; } In this example, the decorator merely attaches or registers metadata *somewhere.* (that detail is up to our implementation) It doesn't actually affect the class's functionality. But our REST library picks up that metadata and uses it to parse the JSON we receive from the server. (because JSON cannot transmit JSON date objects) This can certainly be done without decorators, but decorators offer a declarative syntax that is less verbose than the alternatives.
Do you have examples of things that were standardized with a slow implementation and then got faster?
You aren't alone, it will pass eventually. As long as you keep banging your head against the wall. If you have questions feel free to ask me. I'm no expert but if I'm able to answer your question it also helps me further cement my learning.
Decorators are literally just syntactic sugar for function composition (which, if you're not familiar, is a pretty staple pattern in functional programming). My apologies if that doesn't particularly help, I'm sure someone more familiar with functional programming can explain it better than I can.
I'm similarly really disappointed that decorators can't be applied outside of a class context, since I use function composition a *lot* for higher-order components in React (like in your example), but typically the components I'm passing in are stateless functional components (unless there's a good reason for it to be stateful/instance-backed) -- which means I can't use the decorator syntax sugar. And the code ends up less neat/readable, IMO. To use your example, my code ends up looking like: const MyComponent = ({ /* various props */ }) =&gt; ( ... ); export default translate()( connect( state =&gt; ({ ... }), dispatch =&gt; ({ ... }), )( fetchData(props =&gt; ... )( MyComponent ) ) ); Or alternatively, something like: const MyComponent = ({ /* various props */ }) =&gt; ( ... ); const withTranslation = translate(); const withState = connect( state =&gt; ({ ... }), dispatch =&gt; ({ ... }), ); const withData = fetchData(props =&gt; ... ); export default withTranslation(withState(withData(MyComponent))); 
&gt;[...] Finally, async/await is here and, combined &gt;with Promises [...] Async functions **ARE** promises. If you have this snippet async function foo(){ cons data = await getSomeAsyncData(); return data; } Then you can chain the async function call as classic JavaScript promise, because as I said, an async function is a Promise. foo() .then(transformData) .then(otherThingWithData) .then(finalStepWithData) .catch(handleError) 
In my experience new features are in modern browsers for months (sometimes years) before the new features become standard. That is plenty of time to test things in production and iron out all the performance considerations. This said I cannot think of any example where some feature got faster by simply becoming a standard.
Thanks. I just wanted to make it clear that they don't "replace" promises. Maybe I expressed myself poorly? If you have a better way to say it feel free to fork the post!
So do you have an example of where a new feature got slower after standardization?
I think it is kind of a moot point to bring up generators because they were still only introduced shortly before async and await. And they can't really be used in browsers because lack of cross-compatibility (thanks IE, still). Both are great solutions but I always saw generators as an inbetween of promises and a true async/await implementation.
&gt; Besides, some things don't transpile very well, e.g. let. `let` (or Dart's block-scoped `var`) transpiles just fine. In the output you simply use `var` and rename variables to avoid collisions. let foo = 1; { let foo = 2; } Can be compiled into something like: var foo = 1; var foo2; { foo2 = 2; }
Someone's envious about popularity of another. Why not another article? (it's a joke, op's article is actually good)
By lambda calculus, you mean every other modern programming language ever? http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html C# https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions C++ http://en.cppreference.com/w/cpp/language/lambda Swift https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html Kotlin https://kotlinlang.org/docs/reference/lambdas.html D http://dlang.org/spec/expression.html#Lambda And I'm sure many many others that I didn't bother looking up, I guess "lambda" is too scary of a word for Javascript.
Angular 1 switched to Angular 2, BUT there are a lot of companies that use angular 1. And any framework will make some changes that will require transfer at some point... There never will be framework that does it all, its just impossible(its javascript after all), you pick and add what your project needs. Even though you have a very long question it is still hard to understand what those projects will need, vague question will lead to vague answers like Angular, Ember or jQuery. So. Will some of you apps be SPA? Does UI components need to be in the framework itself or they could be other modules? Does this framework needs to be complete or still some features developing? If you want something crazy robust with a lot of support and modules then just go with jQuery, Angular or Ember. Also i know you said you don't want to spend time building projects but React with any UI framework will be so easy to maintain and develop. (Material, Semantic, Bootstrap, Foundation). Also it has CRA to bootstrap all those things. In React sense people usually spend time building and bundling projects, so their development is very smooth. My choice this past 2-4 month's was Mithril.js. It does't have UI, BUT. I like it because its complete, in the sense that it has features that doesn't need to change or update, people actively work on it and maintain it, but it has everything front-end framework needs to have: components, life cycles, http client, router, es6 classes support and jsx support (ALL IN 2000 LINES OF CODE). I choose Mithril because you can code how you like, components as objects, components as classes or jsx. And i can slap any UI framework on top and it will work great. Also there is Kendo UI (the most featurefull framework there is on the planet)
VueJS is a wonderfully simple framework that would fit your needs perfectly. It has an official CLI, router, and state management package. I use it in nearly all of my side projects due to speed of development &amp; light footprint. It's nice because it's incredibly flexible &amp; easy to understand. If you're decently familiar with JS then the VueJS intro &amp; docs are about all you'll need to get productive. React is probably the standard answer here though. It's infinitely more popular on the American job market, and the dev community seems to be significantly larger. It can be bootstrapped fairly quickly with the create-react-app cli tool. For React I really enjoyed and learned a lot from the free basics course at https://reacttraining.com/online. I'd also throw a note in for Ember. It's not as popular as React or even VueJS, but it has a steady and vibrant community. It follows the Rails Convention over Configuration mindset and the CLI is amazing. You'll find plenty of ready-made components that you can just install and drop in. For maintaining an app over the long-term, I find Ember to be great since it enforces certain standards and conventions.
`isPositive(Math.sign(n))`? the point, i'm guessing, is to abstract how you get the boolean once you've settled on a number.
well, it would be pretty interesting to have magic strings that get turned into the jpeg data at build time. Would actually help loading in some situations, reducing http requests. Why would you suggest this, if you weren't certain it's another bad idea the react community will adopt?
You'd just write `Math.sign(n) === 1` to figure out if `n` is positive. Or you could just write `n &gt; 0` as you'd usually do.
Decorators are great in python, they increase readability
one memorable example: https://bugzilla.mozilla.org/show_bug.cgi?id=626021
I recommend Heroku if your just looking for a free small site
My group went through the same evaluation and we landed on: * React * Redux * ES6 /w Babel * Bootstrap + additional packages for more complex UI components * Webpack * Eslint /w the Airbnb configuration for style consistency We're building and maintaining 3 (going on 4) decent-sized web applications. The front end projects all share the same project layout and webpack build configuration, so once we got the first one how we liked it, getting the other 2 up and running was a snap. We came from Angular 1. React has great support and is going strong. Redux was part of a natural progression towards more complex state management. Getting the webpack build setup the first time was a bit of a challenge, but once you understand what the parts and pieces are doing it makes sense, and compared to Gulp it's actually a heck of lot easier to maintain in an ongoing project.
This package is great example of reinventing the wheel, actually. Instead of just writing one line of code and forget, somebody wrapped this one line of code in library with 15 commits, built test case for this, wrote documentation and pushed for npm four times. And using this package is more complicated than writing this by hand because: - you have to npm install it - you have to require/import it - you still have to write one line of code to check if number is positive. No magic here. One thing this library makes more is checking if variable is really a number, before comparing with zero 
Was going to say I'm comfortable in my vim setup, with autocomplete etc. But that's only after about 5 years of tinkering soooooo... I see your point. 
React + GraphQL
no argument here.
So the follow up for Mithril: [This code](http://i.imgur.com/Np1AEs5.png) generates [this chart](http://i.imgur.com/rx9Kq82.png) and it took me about 1 minute to do so. No bundlers, no components and very fast render (of course you can bundle and component mithril as much as you want)
Be wary of Object.prototype.toString. {[Symbol.toStringTag]: 'Number', valueOf() {return Math.random()-0.5}} Is an interesting example of making this module return different things per invocation.
Right, it works only in the situation where the array instance hasn't been assigned a custom Symbol.iterator property. However, in cases where a custom Symbol.iterator property *has* been assigned, `Array.prototype.values()` is supposed to ignore it. This means you can't use `this[Symbol.iterator]`; you have to use `Array.prototype[Symbol.iterator]`.
We definitely need some sort of cancellation token. 
You need to actually build something on your own with javascript. When you don't know how to do something google it, but be weary of posts on forums without an upvote/downvote mechanism. You can trust stack overflow. Also, this was a significant thing for me to learn (even though it sounds incredibly simple to me now) and I recently taught it to my cousin: You can think of functions as variables. You can pass them around like variables. The difference is that you can call the function code by adding () to the end of it. var a = function() {console.log('test');} a = a variable that is a function. a() = call the function that the variable a is pointing to. This is an over simplification when you get into the details, but it really helped me understand that there isn't anything special going on with functions, you just have to call them with (). I don't know why it was like a light bulb going off for me, maybe it will be for you too.
Thanks, didn't consider this option. Only other option I've seen actually created closures. As far as I can tell, this won't work with lambdas trying to capture the let vars during a loop. Any workaround for that?
This is really close to the React setup I've gotten together for our current framework evaluation to update / refactor an Angular 1 project. I've been digging it, but I'm still wrapping my head around Redux and hoping I can get over my affinity for Angular's 2 way binding. We're also considering Angular 4 which is looking to get in a settled position. I got one project started on the ng2 release candidates and really liked the direction it was going in but dreaded every new changelog entry. I'm still skeptical on it, but it's looking a lot more stable the last couple months on the breaking changes.
More than roots: it was orginally developed as SproutCore 2.0. The main difference between Ember and SproutCore is that Ember is more like webpage tooling where SproutCore is more like Qt or GTK for the web.
I think the correlation has to do with moving to better editors. Better editors use spaces by default even if you press tab (Jetbrains products, VSCode, Atom). While an editor like Notepad, or Notepad++ will keep the tabs there if you press them. 
This. Thanks for clarifying. 
This. Initial setup is a little bit rough, but if you spend the time to build a basic boilerplate that you can quickly use to get a new project up and running (or learn someone else's), it's amazing. &gt; Bootstrap + additional packages for more complex UI components [Reactstrap](https://reactstrap.github.io/) is pretty fantastic and no jQuery dep. 
Exactly! [recompose](https://github.com/acdlite/recompose) has bunch of useful helpers for functional component composition, I can't imagine living without them any more.
The correlation is more about OSS participation compared to developers who do not participate. The unstated assumption there is that OSS contributing developers are more likely to be aware of tools (or write them) to solve for these stupid holy wars. http://evelinag.com/blog/2017/06-20-stackoverflow-tabs-spaces-and-salary/index.html#.WUq1a4qQzuM
I would have assumed it's read-only. Well, one shouldn't mess with built-ins anyways.
Yeah the transition to Redux was a bit of a curve, but now I can't really see getting anything "serious" done without it.
https://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-proble%E2%85%BF :)
Okay, that's actually pretty hilarious. This makes me think it is a joke.
It's amazing that a library can completely go under your radar (and I was just looking for nice react bootstrap bindings.) Thanks for the link!
&gt; What exactly is so bad about \[CoffeeScript\] nowadays? Nothing necessarily. It's just preference and/or managerial insistence on one thing over another. For those interested in staying on the bleeding edge, or just to present a technocratic view that technology advancements are inevitable, CoffeeScript is 7 years old now, and it served as a superset language that helped influence its direction, but will be surpassed as ECMAScript refines its functionality, expands its scope in use for OOP, and becomes less idiosyncratic. Compiling-to-JS, as a concept, isn't going anywhere anytime soon, so dig into CoffeeScript if you like. At worst it will sharpen your understanding of JavaScript and what influenced the current standard. https://en.wikipedia.org/wiki/CoffeeScript
&gt; We're also considering Angular 4 which is looking to get in a settled position. I got one project started on the ng2 release candidates and really liked the direction it was going in but dreaded every new changelog entry. Luckily for you Angular is out of RC and is more-or-less stable. I haven't feared an update since last summer. 
Looks like a thriving framework! I'd go as far as to say that it will be even better supported in 5 years!
We actually have "magic strings that turned into data", they're called data URIs. But usually it's the other way around: we provide the build system with a file to embed and it does the heavy lifting for us, converting the file into the "magic string".
If you didn't like the article and downvoted I would love some feedback to improve for future articles. Many thanks.
&gt; Or maybe I could just write "Math.abs(n) &gt; 0" and save a bunch of imports... Umm, isn't `Math.abs()` guaranteed to produce a positive number for all numeric inputs other than 0 (disregarding `NaN`, etc)?
Hi /u/hackingbeauty, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Most likely a joke on how anything can make it onto NPM
ok.. maybe I'm lame, but what is the colorscheme in your editor there?
Another hour, another "discussion" on /r/javascript about how functional programming is suppose to be our saviour. Can we just get over this hyped nonsense already? Being able to run cleaner tests doesn't make it better code. As programmers we're suppose to be able to anticipate bugs and handle them appropriately, not limit ourselves by strapping on training wheels.
Promise.race doesn't somehow abort the function that "loses", it just ignores the result
I agree it could be something like that. The code looks machine generated and is very hard to read w/ "view source." Make sure it isn't doing something like calculating tax twice which might account for the 318 kr difference.
Your example of impure function, var tax = 17.5; function calculateTax(productPrice) { return (productPrice * (tax/100)) + productPrice; } might not be the best one, because relying on values outside of a function doesn't necessarily disqualify function from being pure. For example if `var` is switched with `const`: const tax = 17.5; function calculateTax(productPrice) { return (productPrice * (tax/100)) + productPrice; } this function is provably pure since `tax` cannot be reassigned to any other value and we can't change `17.5` from being `17.5`. But even without `const`, `calculateTax` can use external values and be pure: function constructCalculateTax() { var tax = 17.5; return function calculateTax(productPrice) { return (productPrice * (tax/100)) + productPrice; } } var calculateTax = constructCalculateTax(); calculateTax(10); //=&gt; 11.75 (no side effects) // ... after some time and computations ... calculateTax(10); //=&gt; 11.75 (no side effects) In fact, using values from function's closure is the basis for currying. &amp;nbsp; In my experience, a better example might be something that uses time: /** Impure */ function secondsSince(date) { return Math.floor((Data.now() - date.getTime()) / 1000); } secondSince(new Date("2017-01-01")); //=&gt; 14845000 // ... after 1 second ... secondSince(new Date("2017-01-01")); //=&gt; 14845001 /** Pure */ function secondsBetween(dateA, dateB) { return Math.floor((dateA.getTime() - dateB.getTime()) / 1000); } secondsBetween(new Date("2017-07-21"), new Date("2017-01-01")); //=&gt; 17366400 // ... after 1 second ... secondsBetween(new Date("2017-07-21"), new Date("2017-01-01")); //=&gt; 17366400 
ah, that returns `0` as positive. here, i fixed it and made it Web Scale: const numberForm = number =&gt; Number.parseInt(number, 10); const isInteger = submittedNumberForm =&gt; (Number.isInteger != null || !!require('core-js/library/fn/number/is-integer')) &amp;&amp; Number.isInteger(submittedNumberForm); const isNumber = potentialNumber =&gt; (potentialNumber === potentialNumber || !Number.isNaN(potentialNumber)) &amp;&amp; isInteger(numberForm(potentialNumber)); const isPositive = number =&gt; isNumber(number) &amp;&amp; Math.sign(numberForm(number)) === 1; console.table([NaN, undefined, null, false, true, {}, [], '', ' ', 0, 1, -1, '0', '1', -0, +0, Infinity].map((o) =&gt; { return [o, isPositive(o)] })); 
&gt; less than one line of code to create Welcome to the insane world of "micro-modules" where we all hate ourselves and everyone who touches our code.
None of them. That you came to reddit and asked that question with those requirements shows you shouldn't attempt this. It's way over your head. You don't know yet what you're doing.
If you like Observables, you might also like AsyncIterators: https://github.com/tc39/proposal-async-iteration/blob/master/README.md
OMG.. THAT IS SO COOL. But, I don't think it's for me? Seems out of my league. But, I'd totally give it a go if I ever get to App design or the dynamic side of things vs. static. Thanks. Yeah, that is a pretty cool site.. 
Your code isn't just for you. Other people have to maintain it, and their job becomes a lot easier if you use pure functions and immutable state.
Thanks! [: 
I mean on the array instance, not the prototype. So it's not messing with any built-ins because it's not mutating the prototype. Hope that clears up any confusion.
Yeah, I imagine your 15 years of backend dev work didn't prepare you for the logic nor syntax of javascript... shit's hard man :/
I assume you're tryna use php yea? 
&gt; Also, you can't use React effectively without using pure functions see here. Well if I can't use React... /s Pure function are limiting in that they are "strict". I'm sure you've looked at a function and said something along the lines of "how do I make this pure?".
&gt; but I'm still wrapping my head around Redux make sure to try out MobX as well before you build something big in Redux.
MongoDB just released Stitch if you wanna check that out: https://www.mongodb.com/cloud/stitch
I've actually JUST switched to atom from sublime, so its the default [dark theme](https://github.com/atom/one-dark-ui)
i think this is a joke, or at least i really hope it is. I don't know how NPM gets the download number, but at least with RubyGems.org, it is not a reliable way to gauge usage, since it's mainly bots mirroring the site. 
Well then. I've never even seen that syntax outside ES6. That seems like a pretty big gap in my learning.
I think the tooling you use depends on which parts of WowHead you want to emulate. Here's a few notes from a prototype web site I was making for WoW's pet battles... links are in the TL;DR along with some new points! **Language** I personally am relatively anti-PHP due to performance cost and it's development history. That said, any language that can expose a RESTful interface and query a DBMS (not necessarily an RDBMS) is good here. **Why RESTful?** I mention a RESTful interface because an easy enhancement over WowHead - and one that would save you processing time and bandwidth - is to make your data available in a RESTful API. That is, instead of http://www.wowhead.com/item=120978/ashbringer, which brings the content about the item in the main page html, simply make that URL bring down a generic 'item' page that then calls for item data via the RESTful API (a la 'http://www.myfancygamedb.com/api/item/120978/'). I'd recommend [Swagger](http://swagger.io/) for defining your API and writing boilerplate code - they have generators for most languages! **Data Storage** For a DBMS - or really a data store - there are a lot of ways you could go. In this case, your generic item page could either [directly reference S3](http://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html) - something like 'http://s3-us-east-1.amazonaws.com/myfancygamedb-data/items/120978'. You could also have your RESTful API simply respond with that URL. Note that this really only works with static contents - things with updates, like comments, drop counts, etc. aren't a good fit here. You could also use MongoDB - and store those JSON per-item documents in there. Your retrieval time goes up, but you also get integrated querying. **Search** A better option than MongoDB or your RDBMS, depending on your update lifecycle, might be to use [Solr](http://lucene.apache.org/solr/) for querying the items. This has downsides - you need to create and maintain a Solr index - but the upside is that it's very strong for searching. You could also do a hybrid technique. Look at how WowHead works today; if there is an exact match in name, it uses it. If there are multiple exact matches, you get a disambiguation list page powered by their DB. If there are not exact matches, they have a 'Did You Mean?' box that is really just a Google domain-based query. While this relies on good SEO, it's less resources they have to have. **TL;DR Version** * Language: Any is probably fine. PHP probably isn't a great fit here. Javascript/Node.js is a little better - middleware like [Express](http://expressjs.com/) can help make sure it's clean and , but if you are really concerned about performance, use a compiled language like Java. * Access Method: Use a RESTful API - it will serve you well here. (I'd recommend [Swagger](http://swagger.io/) for defining your API and writing boilerplate code - they have generators for most languages!) * Object Storage: You can use pretty much anything, but if you want to save some money, put as much content as you can as static and [feed it from S3](http://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html). * Search: Look at your object storage options (S3 doesn't help here, but any RDBMS (like MySQL), NoSQL DB (like MongoDB) or other tool probably can); [Solr](http://lucene.apache.org/solr/) and Google-as-a-fallback are also good options. 
Thank you! Really appreciate the help. I finished as a design major but pretty interdisciplinary with interiors/graphics/web/etc.. It'll be a site to showcase my works and such. But, yeah.. I want to make my site from scratch. No cookie cutter stuff. (: I don't think I'll be getting much traffic. Cheers!
Does avoiding global variables qualify as 'training wheels'? Does 'use strict' qualify as training wheels? I don't think I agree that limiting ourselves is always bad.
Thanks for small demo, I always like to see some examples :)
No worries, do you have any ui/ux knowledge? Just curious. Also if you want to feel free to pm me and we can share emails if you ever need any help or anything. I'm a full stack webber, but my design has lots to be desired so I could probably use help too
&gt; An observable side effect is any interaction with the outside world from within a function. That could be [...] calling another method from within a function. Calling an *impure* method from within a function makes it impure. Calling another *pure* function doesn't.
I also use this setup for apps at work, but with [react-bootstrap](https://github.com/react-bootstrap/react-bootstrap) if it's using Bootstrap 3 and an ESLint setup based on [standard](https://standardjs.com/) with some tweaks on top. [react-widgets](https://jquense.github.io/react-widgets/docs/) also fits in nicely with Bootstrap's style if you need a datepicker or other custom components it provides. All the development, build and test tooling is handled by [nwb](https://github.com/insin/nwb) and the [ESLint config is also handled by a single package](https://github.com/insin/eslint-config-jonnybuchanan), so all those devDependencies and configs don't need to be individually managed across projects and we can upgrade them when we're ready by bumping a pair of version numbers instead - most recently we upgraded from Babel 5 + Webpack 1 to Babel 6 + Webpack 2 in one go by bumping a version number and making a few changes in how certain modules were importing/exporting. [Bootstrap is used from its Less or Sass source](https://medium.com/@jbscript/using-bootstrap-4-from-source-with-react-and-nwb-f26caf395952) depending on the version so we can easily customise it and omit pieces we don't use, and nwb's development Webpack build can be [integrated as Express middleware](https://github.com/insin/nwb/blob/master/docs/Middleware.md#middleware) if the project needs its own Node.js server.
Doesn't the current ES proposal only allow decorators for classes, not functions? Is TypeScript just implementing their own version of decorators? Or am I wrong about that?
Well TypeScript doesn't allow decorators on functions; only classes, methods, and class properties. I don't know if there are differences between TS decorators and the current proposal.
Got my domain name from namecheap and do my hosting with Digital Ocean. If a static site is all you need, you can use GitHub pages for free!
You might want to consider something like tagging. https://bootstrap-tagsinput.github.io/bootstrap-tagsinput/examples/ It is possible to restrict the inputs to predefined list (regardless of what library you use, or if you write it yourself).
you nailed it
I'm a fan of [vanilla-js](vanilla-js.com). It has everything you listed except components. 
async / await is much more conceptually simple than both promises and generators
I've been using Angular 4 with the [angular-cli](https://github.com/angular/angular-cli) toolset, which provides mostly preconfigured typescript compilation, webpack bundling with all the desirable features, and unit and integration test harnesses. We are also using [ngrx-store](https://github.com/ngrx/store) as an Angular-friendly Redux implementation. I've been pretty happy with the framework and would recommend it. Typescript is great also, providing nearly all ES2015 features as well as type annotations. We are taking a very component-focused design approach and Angular makes it pretty easy to do. We checked out React+Redux and Vue as well when we were in the early prototyping phase, but for what is essentially a glorified CRUD app Angular fits the bill really well and provides a lot out of the box. I like both React and Vue and in some ways they are better than Angular, but the React ecosystem feels very piecemeal and fragile/rapidly changing and Vue just doesn't have the popularity to give confidence that it will still be around in 5 years. The whole Angular 1 vs 2 schism is a bit of a bummer, but it needed to happen. Angular 2+ is a completely different (and far better) animal, and honestly Google should have just given it a new name rather than cause confusion. But the core framework and architectural patterns feel very solid now, and there have been very few breaking changes since 2.0's official stable release.
&gt; this = uninitialized; What's the significance of this piece?
I've been doing this far longer than you've been alive little boy. And that goes for 80% of the redditors giving you that advice. As I said, mostly unemployed amateurs and 15 year olds kids using their mom's computer. So if you think these opinions and advice from reddit is the best you can do, then this work is, as I said, way over your head.
Could you summarize the use cases? I would love to only use one bundling tool. Rollup has tree shaking, webpack now does too. If there is a link you know of that outlines why we should consider rollup (especially now that webpack has the hoisting stuff) I'd really appreciate it.
Pet peeves: 1. When people use `let` when `const` is obviously the right choice 2. When people use anonymous arrow functions and assign them to variables instead of just using `function` The image on this post triggered me.
SproutCore has never been officially supported by Apple. It has always been a project without a company officially supporting it, or where a single company is the lead developer. The one time it had a company taking the lead, it didn't last as they essentially developed Ember instead. The Github repo gets updated when necessary: lots of changes can also mean unstable. A lot of energy has been put in the npm module as it originally used Ruby based buildtools. The npm module says node 4.x and up, so also supports node 6.x and 7.x. 
We can follow jMeter's example where they generate the certificate on the fly, so each dummy certificate only valid for that particular machine, which avoid the possible MitM attack method using the shared certificate.
Any particular things with the Vim extension that throw you off? - One of the maintainers of VSCodeVim
Just a note: Simply switching `var` for `const` to enforce purity only works for scalar types. `const tax = {rate: 17.5};` for example doesn't protect `tax.rate` from reassignment. The rest of your arugment: spot on. 
I'm using let, arrow functions, for of, spread operators, map, filter, class and more quite a lot. Usually I'm waiting until a feature is supported by at least chrome and firefox. I'm not using a transpiler because browsers that do not support ES6 properly also tend to have poor WebGL support, which I require. At this time, the new features are essential to me. They make life so much easier, it doesn't make any sense to go back.
A [hierarchical timer wheel](https://www.confluent.io/blog/apache-kafka-purgatory-hierarchical-timing-wheels/) provides an amortized O(1) solution. This uses a more coarse firing than if based on a min-heap, which is an O(lg n) algorithm. Sometimes a heap is used for millisecond resolution and a timer wheel at larger ones, but in most cases fine precision is not necessary. In the linked article, the populated buckets are scheduled using a heap timer. This way instead of O(lg n) timers only O(lg m) are needed, where n &gt;&gt; m. In my Java [implementation](https://github.com/ben-manes/caffeine/blob/master/caffeine/src/main/java/com/github/benmanes/caffeine/cache/TimerWheel.java) the evaluation is deferred, but it gives an idea of the magnitude of the difference. It uses 165 buckets for an unlimited number of timers, meaning there would be an upper bound cost of 8 comparisons if scheduled into a heap. A recently JavaScript [port](https://github.com/aholstenson/transitory/blob/master/utils/timer-wheel.js) of my implementation might offer a starting point if you find this topic interesting.
I'd give [HyperApp](https://github.com/hyperapp/hyperapp) a go. I think it shines in 1 and 2. It follows the Elm architecture, so the API is considered done. So, I think 4 would not be a issue. TBH there aren't a lot of components in the wild, so 3 would be an issue. But the API allows you to wrap existing 3rd party libraries, e.g., CodeMirror. Resouces: - https://www.reddit.com/r/HyperApp/ - https://github.com/hyperapp/hyperapp/tree/master/docs - https://hyperapp.glitch.me You said you don't care about, performance, but [it is actually great](https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html). Oh, and it's 1 KB. 
Why does the second point bother you?
I tried angular 2 a while ago, and was disappointed by how huge the built was and how long it took to load a simple hello world. But recently picked up ang 4, and what a delight. To someone coming from a template mentality, React is just too weird, and I had many attempts. 
Probably nothing that could be reasonably fixed. For example, I rely heavily on Vim Surround -- any emulation without that additional functionaly is going to lose me. It's more of an "it's not you, it's me" type scenario. To be honest though, I haven't spent a ton of time trying to make VSCode my daily driver. I've been crafting my ideal Vim experience for years now and I'm not sure what it would take to attract me elsewhere. I tried to stick with VSCode for a week a few months back but ultimately came back to Vim. 
I guess, but the same was true for promises; it just _looks_ somewhat like synchronous code now.
Https://You-party.co is the base website where one may build playlists with their friends. Https://You-party.co/v1 is our beta version which includes suggestions. Https://You-party.co/hard is where you can sign up for the platform which will build upon the core functionality
So a couple things. You're 'selecting' the entire form with this code. document.getElementById("demo").innerHTML = "Hello World"; Thus gets the "**demo**" element. You want the text box element. You can easily grab that element in a number of ways but since you're already using getElementByID you can just give the text box an ID like so: &lt;input id="textBox" name="keywords" size="12" type="text" value=""&gt; After you've given it an ID, you don't want to change the innerHTML, that would completely change the input box itself. Rather you want to set the value of the box. This can be accessed with the "value" property: document.getElementById("textBox").value = "Hello World"; [Here](https://www.w3schools.com/code/tryit.asp?filename=FGTX3FASRWMA) it is all together. Finally, I think you might be putting the cart before the horse here. You should consider taking some free HTML/CSS courses such as www.codecademy.com. Best of luck!
I'll have to check it out again and let you know how it goes! Now, using VSCode as a frontend for Neovim would *definitely* interest me; I'll keep and eye on that PR. I've been dying to be able to use either VSCode or Atom as a GUI with Neovim behind it. Having the VSCode debugging experience with true Neovim under the hood would be my ideal scenario. 
That's only the case if that function is always located in the same scope as `const tax`. However, you should be able to move a pure function elsewhere and have it work the same for the same input, so if you can place it in a scope where `tax` suddenly has a different value, and the return value then suddenly changes for the same parameters, the function is not pure. tl;dr Yes, relying on values outside the function disqualifies it from being pure (for the common understanding of pure).
Yep, that's the one
Oh -- this site looks pretty neat -- are you in the community?
Yeah! :) You need to be a student to sign up but it's a great place to get questions answered - lotta really helpful people on there. Would recommend checking out!
Ahh yes, awesome! Super thorough explanation!
You can use Object.freeze() for that. Remember to enable strict mode in that case.
My first idea was, that you should initially have display none on all elements and remove it for the elements which will not be deleted, but then I realized that you are not talking about your own page? An idea would be, to inject a white overlay over the page, which will be removed when the page has finished loading and you have removed all elements. 
&gt; When people use let when const is obviously the right choice I feel so triggered when people do that. http://eslint.org/docs/rules/prefer-const &gt; When people use anonymous arrow functions and assign them to variables instead of just using function Hoisting, context 
Agreed 100%. Tests should be written at the interface of your method, which means not mocking private functions, or utility libraries like lodash (which are kind of like private, helper functions that somebody else has written for you). I consider some dependencies to be part of the interface, though. Anything that involves communication to the outside world like HttpClients -- or to other parts of the application, even another class inside the same application, if that was a dependency. These should almost always be mocked in a unit test.
&gt;which music is playing at our office A bit off topic, but do companies often do that?
Yea and you can put something like `http://google.com` and watch people wonder why there's no syntax error.
[removed]
The bottom line with a problem like this is that you need a way to run some code before the initial render which means you need to be able to inject JS synchronously above the first elements in the body (in the HEAD element is best so the browser can try some optimizations on downloading the JS in parallel with other sync head JS). As the other commenter said, once you can run code before render you have a few clever options around hiding the whole page or just the parts of the page you're interested in. If you can't inject code at the top of the page (or a stylesheet), maybe try doing a document.write (as long as DOM parsed hasn't fired yet) as soon as you can. The doc.write is sync, so it will stop rendering at that point and you can check if you were in time or not (did my element already render?). If you can't inject code before rendering begins, then it's all about making the problem hurt as little as possible. Consider just trying a smooth transition (fade in/out or a carousel). You can try things like checking if the element you want to modify is visible and doing a transition effect if it is or swapping it if it isn't. Beyond that, you're hosed AFAIK. 
I think that's exactly what they've now done, but you'll have to upgrade to the new releases and remove these certs locally asap if you've installed them (check here: http://badcert.mike.works/). Notably Preact-CLI uses DevCert for this: https://www.npmjs.com/package/devcert. Handles all the generation for you, looks super easy.
1. It creates a brand new object. 2. Sets its prototype link. 3. Bind this to the new object. 4. Returns the new object. You can find read about this in https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md#new-binding
I simply disagree. If the server can't connect to the DB once, my experience is that the entire connection is indeed dead. Obviously your experience is different. That's fine. Could we respectfully end the thread? Thanks in advance.
Yeah, network/database/file system access, these are valid cases for mocking.
Sounds like you want a giant chain of promises. What's wrong with that?
[Image](https://imgs.xkcd.com/comics/goto.png) [Mobile](https://m.xkcd.com/292/) **Title:** goto **Title-text:** Neal Stephenson thinks it's cute to name his labels 'dengo' [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/292#Explanation) **Stats:** This comic has been referenced 147 times, representing 0.0912% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dj8p0ch)
Did remove one of these from our production codebase once. Surprised a few people that it worked.
Being able to chain promises is one of the coolest aspects of promises. Why would you try to reinvent the wheel?
 let res = null res = await fetch('/api/user') console.log(res) res = await fetch('/api/posts') console.log(res) res = await fetch('/api/tits') console.log(res)
Say I have a list of 1800 movie titles, and I want to issue a request to IMDb's public API to get each movie's information. Hand-writing 1800 chained promises is obviously ridiculous for a variety of reasons. What I want instead is to have an array of titles, pop the first one off, get its info, and once that's done, pop the next one off. But I'm totally new to imperative async programming and finding it difficult to find simple ways to accomplish this. I have a few solutions but they all involve either over-elaborate uses of `await` or recursion levels mainstream JS interpreters do not support. I thought I had something for a minute with generators, but recursive solutions blow the stack and loop iterations can't be paused.
I think I communicated my problem poorly. I am performing the same action thousands of times while iterating over a collection. Chaining thousands of identical promises on each other by hand is not a sane solution to that, obviously. My ideal solution would be a `for` loop that only begins the next iteration once you explicitly call `next()`, so that I could write something like: let shows = ["Seinfeld", "The Simpsons", "The X-Files"]; for (let name of shows) { IMDbAPI.fetchEpisodes(name) .then(episodes =&gt; database.commit(episodes)) .then(() =&gt; next()); } I don't to write a solution that goes `fetch("Seinfeld").then(() =&gt; fetch("The Simpsons")).then(() =&gt; fetch("The X-Files"))` because that isn't a sane way to work with a database containing many collections.
I've seen something similar in the [AngularJS code](https://github.com/angular/angular.js/blob/c2b8fab0a480204374d561d6b9b3d47347ac5570/src/ng/rootScope.js#L808) loop: while(true) { // work goes here // until: if (/*some condition*/) { break loop; } My blind guess was and is, that they work like fields in object literals. }
[removed]
Where does the list of titles originate? Maybe I'm missing something, but my initial approach would look something like this (excuse mistakes, I'm on my phone): ``` const movies = []; // Whatever data you have return movies.reduce((acc, movie) =&gt; { return acc.then(() =&gt; doSomethingToFetchMovie(movie)) }, Promise.resolve()) ``` Assuming you have a function that fetches movies that returns a promise. You can make a big ol' chain of promises, using your collection of movies. 
it can be avoided by extracting scanning code to separate function and using `return` instead of `break`. Cleaner and code and reusability for free.
Potentially less performant because of the extra function call, and it assumes that you only want to return a single value, whereas scanning might compute multiple values, which would be more annoying to return from a function. For example, it may be important to keep both indices in addition to the matched value. It's also not really cleaner. A return is like a labelled break except the "label" that your eye scans for is the top of the function. Not conceptually different; you're still jumping out of multiple loops at once.
So let's say you need functionality like your impure example. What are you supposed to do?
Ahh, it can come handy during a JS golfing competition.
&gt; advice Living with arrogance it is then. Regards!
The one disregarding experience is you old man, I am here exactly to listen to experiences while you are talking like if you were Elon Musk but you are just a sad guy complaining. Best regards!
So can anyone enlighten me what's the difference between pure functions and the known static functions? 
You just solved the mystery of some Microsoft code I was reverse engineering. Of course they'd use something like labels. 
Golfing competition?
Code golf, doing something with as few characters as possible. See JS1k for an example.
You're like my personal reddit comment linter! Thanks for the correction :)
It's really reassuring to hear how aligned we are with other shops. That was what we were trying to do, not just for the sake of consistency in our projects but for the sake of our developers (and their cv's.)
Angular had a turbulent development period as I'm sure everyone is aware. Arguments can be made all day about whether a lot of change during beta / rc is a good thing or not. But regardless of how you feel about the development cycle it went through, angular's interface has barely changed since actual release. If I had to guess I'd say I've spent a total of 2 hours total when upgrading my medium sized app from 2.0 through the different versions to 4.0. It's been a complete non-issue for me. The change logs are sometimes big and scary but if you bother to read them a lot of the bullet points are just mentioning improvements they've made under the hood that have 0 impact on the code you've already written.
You can wrap the returning object in parenthesis to avoid this issue :-)
A static function can be called without instantiating a new object. There is no requirement for a static function to be pure. Static functions can still contain side effects such as calls to non pure functions, network requests, I/O stuff etc. They can also query/modify application state, the DOM etc. 
If you need functionality where you compare some time to the current time, you're going to have impurity somewhere in your application no matter what. There's no getting around that. It's really just a question of where you want to make the impure call (i.e. where you decide to get the current time). `secondsSince(date1);` is the same as `secondsBetween(new Date(), date1);`. `secondsBetween` is pure while `secondsSince` is not. For both of these functions, though, the calling function is impure in these examples, so it's up to you to decide whether or not you want to pass the current time in to the calling function as a comparison date or if you want to call `new Date()` within the calling function. function someCallingFunction(objectWithDate) { /* ... */ const delta = secondsBetween(new Date(), objectWithDate.date); /* ... */ } versus function someCallingFunction(currentDate, objectWithDate) { /* ... */ const delta = secondsBetween(currentDate, objectWithDate.date); /* ... */ } By passing in `currentDate`, you're making the `someCallingFunction` pure, and you can continue to pass `currentDate` as far down the stack as you like. You may not want to do this, though, if that means you're having to pass the `currentDate` through 12 different functions just to use it in this one place. But if you're rendering in a template, I probably wouldn't do `{{ secondsBetween(new Date(), date) }}`. I'd refactor `secondsSince` to //Impure function function secondsSince(date){ //Pure calculation function return secondsBetween(new Date(), date); } and just do `{{ secondsSince(date) }}` in the template. This way your calculating logic is a pure function and only your display function is impure. Do what makes sense for your scenario and where you need some impure functionality. There's no hard-and-fast rule on this.
If someone is worried about having to pass props down a large hierarchy, why wouldn't they just use context? I thought the whole purpose of context was making data available to any subcomponent in the hierarchy.
And you continue to prove my point.
In my experience, labels are most useful/used for control flow when managing nested loops. The reason you don't see them often is because they are somewhat of a historical artifact of JS's imperative past. As new features in the language, libraries and common use patterns have pushed authors toward functional programming paradigms, the main use case for labels has gone away. Nested loops are now seen as a code smell by most -- with lodash methods, Array.forEach (and now iterators) preferred instead. This in turn has lead to labels not even being taught anymore so newer JS programmers don't know about them and older ones have mainly turned away from them. 
Array.forEach has little sense in functional paradigm, it's still imperative concept, it's just syntax sugar over for-loop. map and reduce can be useful in functional programming, though. 
iOS Safari has 100% ES6 coverage
Nope. But we're releasing something better soon. - https://github.com/hyperapp/hyperapp/issues/238 
Welp, this explains the error I was trying to debug at 3am this morning... Thankfully it was a side-project and nothing major.
Angular app boot time has been reduced to almost nothing with aot compilation which is done automatically by the cli now. Bundle size is still a bit bigger than I would like but it gets smaller with every release and once the framework matures a little more I'm sure it will be down to a very reasonable size. You can already do a lot to minimize the vendor bundle size but it takes some effort right now. Eventually the methods will be rolled into the cli though I'm sure.
&gt; premature optimization is bad. I'm talking about non-premature optimization. The kind that you do when it's important. &gt; probably ES6 generators could address this issue. A cleaner, faster implementation than using generators would be to use a labelled break. Did you know that JavaScript has had labels since ES3?!? The possibilities are endless! &gt; It's different because return yields value. Of course, but there's no need to yield a value when your local function scope isn't being thrown away. You can have values in several variables.
Use reduce. Make an array of promises then reduce through the array adding a then in each iteration. const myPromiseList = myPromises.reduce((acc, promise) =&gt; { return acc.then(promise); }, Promise.resolve({})); 
That's a good point, and you can definitely [rewrite `calculateTax` function][1] to eliminate the `tax` free variable and be able to move it around without it changing its output, however, since basis for functional programming is [lambda calculus][2], we _really_ want this to work reliably: function add(a, b) { return a + b; } // const add = (a, b) =&gt; a + b function addCurried(a) { return function(b) { return a + b; } } // const addCurried = a =&gt; b =&gt; a + b add(2, 3) === addCurried(2)(3) const add2 = addCurried(2) //=&gt; function add(2, 3) === add2(3) Since `addCurried` returns a function that depends on value outside of itself, you could argue that `add2` is impure — if we were somehow place it in an environment where `a` was `3`, we'd get wrong result. The trick is that we can't do that (unless value we depend on isn't immutable, e.g. prop of a JS Object), because language treats free variables as if they were part of the function, i.e. [closure][3]. In other words, environment is just another function parameter — given the same environment and the same arguments, pure function will produce the same output, you just have to move function around _with_ its environment :) A more pedantic (IMO) explanation can be found in this [SE question](https://softwareengineering.stackexchange.com/q/235175). [1]: https://en.wikipedia.org/wiki/Lambda_lifting [2]: https://en.wikipedia.org/wiki/Lambda_calculus#Motivation [3]: https://en.wikipedia.org/wiki/Closure_(computer_programming)
I woked at an agency that did this, it was a horrible idea. Every day a different person could choose the music/set up a playlist. They did have a pet policy, though, which was great.
Because you lose hoisting and it's harder to read, in my opinion. It's not the world's most rational bother, but it is a pet peeve. But I guess for me one of the issues is, if you do this, then there's no reason to ever use `function`, and I just think it's an important feature of JS. Maybe it's nostalgia? But hoisting and readability are big concerns for me. I think it even takes more characters? Let's see. function hello() { } const hello = () =&gt; { } let hello = () =&gt; { } Yeah, it's always more characters. I just don't really get the point.
Freeze only does a shallow case though right ?
Freeze only does a shallow case though right ?
BTW ESLint has `$ARBITRARY_RULE` rule.
it's a label followed by a comment
http://replygif.net/i/150.gif
Didn't fully answer everything, sorry! We use [winston](https://github.com/winstonjs/winston) for all of our logging. These then go into [Splunk](https://www.splunk.com/) but that might be a bit pricier. Not used New Relic but heard good things. For monitoring we use [DataDog](https://www.datadoghq.com/). Has great integrations with all of the apps you might use and has great tools for drilling down into problems if you have them.
[Guy's got issues](http://i.imgur.com/OWkL8Y1.png)
Not resolving here, just me?
Wrote this as a reply deeper in the thread, but since I just saw that you did ask for recommendations of learning resources: I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics.
[That's not how .find works, though.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find) For that, you're better off [flattening](https://lodash.com/docs/4.17.4#flatten) it first. `flatten(someArray).find(v =&gt; v.isWhatIWant)`
&gt;Congratulations. You just trained your first Linear Regression Model in JavaScript. trained it to do what, exactly? edit: I found [a very well written introduction to Linear Regression here](https://medium.com/@chetcorcos/introduction-to-parsers-644d1b5d7f3d). Not light reading but tons of links/resources included throughout. if you know regex you're halfway there. 
There's nothing wrong with labels. They are actually quite useful for people that know the language.
You're completely right :)
I usually agree with you Shaper_pmp, been following you around reddit for about 10 years and always enjoy your comments. I have to disagree with you in this case. I like labels. They can be a useful way to solve specific problems.
Yeah, but you also haven't demonstrated that you've even attempted the problem. Your post comes across as, "I need to do this thing, please hold my hand and show me how from the beginning". If that's truly what you need, then perhaps /r/LearnJavascript would be a more appropriate place to post. So as not to be a complete waste of time, I'll recommend that you read this over: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest And more specifically: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader And there are a ton of results on Google and StackOverflow if you search for "XMLHttpRequest Authorization: bearer", so once again, it comes across that you didn't really attempt to solve the problem...
did you read the article lol it says right above the quote you mentioned
Cheers
Who gets to decide what's outdated? You? 
You're absolutely right, but getting downvoted by offended noobs, most of which probably have "senior javascript developer" job titles. Ugh.
It predicts a certain value according to your input value based on the database you have given it. Is this exciting? No that's why data science is more than training models. You need to learn how to interpret things.
&gt;regressionModel = new SLR(X, y); interpret how? I have no idea what SLR stands for. 
Out of curiosity, does your single-file version actually include all the web worker files that are normally separate as well? If so, how does that work?
Then read the documentation of the library they are using...
When used in an assignment the right hand side is expected to be an expression of some sort so it gets evaluated so that a primitive or object type can be assigned to the left hand side. I.e. Let x = { Foo: 'bar' } When it's by its self it's not evaluated as an expression. And so is interpreted as a label in a block. {Foo: 'bar'} But wrapping this in parenthesis tells the engine to treat it as an expression and so will get evaluated to an object. ({Foo: 'bar'}) // ==&gt; object I'm having a stab here. Could someone validate this? 
JavaScript is an absolute mismatch of different languages and paradigms. It's very hard to know all the syntax and features of it. It's perfectly fine to google as and when you need it. 
I'm really new to React so I might have misunderstood, sorry if I did, but at the point where you have component trees deep enough to give problems wouldn't you be better off using Redux?
Marko is awesome. Hopefully the ecosystem will keep on growing.
Redux has nothing to do with component trees, only state. Even if all of your state is in Redux you might need to layer the components themselves deeply.
Is there a conventional way for initializing a file in Node?
&gt; map and reduce can be useful in functional programming, though. const forEach = (arr, callback) =&gt; arr.map((item) =&gt; callback(item)).reduce(() =&gt; {}) :p
&gt; reeeeeeeeeeeeeeeee
X-Post referenced from [/r/node](http://np.reddit.com/r/node) by /u/brentschooley [How to Use Twilio Speech Recognition](http://np.reddit.com/r/node/comments/6iv0xg/how_to_use_twilio_speech_recognition/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
 const requests = [/* array of requests */]; for (const request of requests) { await fetch(request); }
TIL you'll never find coffee which relies on crazy cast rules
I agree with you. This is an article more properly titled "reading a file, and passing it to a function". I was expecting a study on the implementation of a ML algorithm. This is all we get in this article: const SLR = ml.SLR; // Simple Linear Regression We will have to see what Part 2 brings. 
I appreciate the brevity of the post and the concrete examples, but without an explanation of *what* we're doing this article is a no-brainer for people who already know this field and does nothing to educate amateurs. 
``` const details = titles.map(async title =&gt; [title, await fetchMovieDetails(title)]) ```
This tool is released too early. Everything I've tried is failing with various errors with no explanation. First the axe dependency missing. Then "Couldn't find any valid configuration". Then hanging on "Traversing finished".
This has brought me great satisfaction. Thank you.
1You say that as if JS labels are more common than code relying on automatic type coercion. I wish I could agree.
Jesus imagine doing dev work today if all your JS errors came in the form of dialog boxes??
Well what you're describing as a solution with context is exactly what react-redux is doing.. putting global stuff on context.
...right. I know. React-Redux uses context. &gt;Passing the Store &gt;All container components need access to the Redux store so they can subscribe to it. One option would be to pass it as a prop to every container component. However it gets tedious, as you have to wire store even through presentational components just because they happen to render a container deep in the component tree. &gt;The option we recommend is to use a special React Redux component called &lt;Provider&gt; to magically make the store available to all container components in the application without passing it explicitly. You only need to use it once when you render the root component: Provider uses context, no? That's the "magic" it's talking about. What I'm stating is that Redux does not solve nested components. e.g. SomeComponent contains OtherComponents, each of which contains MoreComponents, each of which contain FinalConponents. Redux doesn't influence Component hierarchy.
I'd need to know your skill level and what area you want to grow in.
That's actually quite accurate. 
I could be very wrong, but I was under the impression that the majority of JS developers didn't use trailing commas. Also, I believe the default style in ESLint is to [not allow trailing commas](http://eslint.org/docs/rules/comma-dangle). Also, the main idea behind opinionated projects like `prettier` or `standard` is to the stop arguing about trivial stylistic rules. Just choose a style to be used and be done with it. While I'm not a huge fan of Golang, I do really like the idea of `gofmt` which means everyone's Go code looks the same. At the end of the day, there is always going to be people who disagree with some of the style choices, I don't think it's possible to please everyone.
NOTE: In Javascript in a web browser, if you define a variable inside a file that isn't inside a scope (isn't inside a function), or if you define a variable without 'var', 'let' or 'const' keywords, it gets defined globally. The file "snake.js" defines a function called "integrate", and at the end of the file it calls "init()" and then "integrate()". "init()" is not defined in either of the files you provided, so I assume it's in "render.js" or the html file for the web page. "integrate" is the function that is run as what is tradationally called a "game loop". However in Javascript, you cannot write a "game loop" as a loop because the code runs as a single-threaded operation, and will block any user events (like kepresses) until after the loop is finished executing - which would be never in this case. Instead, this code uses the Javascript function "setTimeout", which calls a function after a specified number of milliseconds. In this case, at the end of the "integrate" function, it calls "setTimeout(integrate, GAME_SPEED);", which tells Javascript to run the "integrate" function after GAME_SPEED milliseconds - which is not defined in the files you specified either, so it must be somewhere else. This means, every time the "integrate" function is run, it will tell Javascript to run itself again after an ostensibly short delay, which simulates a loop. The file "controller.js" sets a callback function for when a key is pressed. This means: when a key is pressed, perform the assigned function. In this case, the assigned function is anonymous, and it ultimately sets the global object "speed", which represents a 2d vector of x,y with values of -1, 1, or 0 based on which arrow key was pressed. Since the "speed" object is global, the "integrate" function uses the "speed" object to determine where the snake moves on every tick of the "game loop".
Why the fuck would they name it that. God damnit Microsoft.
it's not a stretch to expect someone reading a machine learning article (even if introductory) to know what linear regression is.
you should go complain about introductory Node articles not explaining what 'HTTP' stands for.
Just use machine learning to reword this article, stupid.
Have fun with your trolling.
[-__-](http://lmgtfy.com/?q=slr)
Yeah I definitely recognize that as a feature, but in that case I would only do that if I was actually using `this`. My `functions` are actually more likely to be pure. I don't think I've written an impure `function` in a very long time. Hell, I can't think of the last time I used `this` outside of a class declaration. Not even sure why you'd want to. Actually, the only time I can think of using `this` outside a class is for mocha, which binds `this` with utility functions affecting the tests, so arrows would actually break that. But yeah... If for whatever reason you're writing a function that needs to capture `this` and assign it to a local variable... By all means go for the arrow function. By the way, you can write codeblocks by surrounding phrases with backticks. `like so`
if you haven't seen someone use the word 'prerequisite' outside of school... (e.g learning basic CSS is a prerequisite to learning SASS / post-css / styled components, i.e, a shorthand for saying 'it's good to learn ___ before ____) then i don't know what to tell you
Depends which iOS Safari we are talking about. 10+ sure, but the amount users out there on older iOS versions is frightening(at least for e-commerce). It's also not evergreen since it's tied to the operating system, which was kind of my point. 
&gt;every ML term I shutter to think what your code documentation must looks like. 
Sure, then what point were you trying to make in your original post?
I misunderstood the OPs questions to be "Once your Component hierarchy he's complicated enough, you should use Redux" to mean that Redux somehow flattened the tree. They probably just meant to control the state for the Component hierarchy. 
Yes, but i don't frequently use it 
... 18 years on console maintains its unshakable lead as debugger of choice.
Thank you for letting me know. Suppose i commented one out I still get: (unknown) WebSocket connection to 'ws://localhost:3000/tweets' failed: Invalid frame header in chrome
(prettier author here) I would encourage you to set the few flags that prettier has to match what your existing codebase uses and to run it through your codebase, do git diff and see how it behaves. If it's not outputting code that's too crazy in your opinion, then don't use it :)
Just like the App Store :)
Thank you for the prompt answer! A few questions if you don't mind :) I don't have the leisure to slowly build up due to time constraints from my company, however I have hosted the website on S3 and it's working fine. We can make accounts and login using cognito. I now need to fully integrate cognito, as well as dynamodb, which is where my confusion lies. 1) I think I'm misunderstanding the definitions of static vs dynamic websites. I assume if an `img` changes to users based on their geolocation, that would be dynamic, but a user's panel that displays their name, phone number, etc is static. Why is the latter static if the content is "changing" based on who the user is? 2) Our backend (cognito + dynamodb) has to be accessible by not only the website, but later by mobile apps. In order to prepare for this, shouldn't I have a few instances with API's that allow fetching data from dynamodb, and user account creation/login from cognito, versus coding it twice on both platforms? Thank you so much again, I just want to do this right with proper scaling, versus wing it and build from an improper setup :D
I'm not familiar with Cognito and have never used DynamoDB. Static: same content for every user Dynamic: content dependent on user Some components can be made dynamic client-side while maintaining server-side rendering (e.g. Username in nav bar). I won't be able to answer all of your questions. What you need is essentially an entire deployment architecture. I will say that this is something you should invest time in. 
Hmmm, see the difference between dynamic/static make sense to me. Googling tells me S3 does not allow dynamic websites, only static, However if you look at www.serverless-stack.com, they implement a note taking app with user login/signup/note adding under specific accounts and it is on S3 &gt;_&gt;
You should learn actual programming and not a library or framework first. If you want to do this as a profession the best advice I can give you is to learn something like Java or Python, even CPP. JavaScript won't teach you core fundamentals that you will have to know if you ever want to be semi competent outside of building a shitty web app.
Oh thanks, I'll give it a looksee! [: Cheers. 
I agree with you about learning the fundamentals but JavaScript is a really good language for a beginner. It's nice and forgiving.
It's really not a good language for a beginner. It's not forgiving. It's not expressive. It gives terrible debugging practice, and it's type checking is undefined or Nan. Other languages teach much better habits and have less garbage you have to go through. If they ever want to learn about something outside of JavaScript they will have to learn CS all over again. Where as going into JavaScript with a background in any other OOP non scripting language will give much better domain knowledge.
Because I'm a software engineer that uses JavaScript and isn't a part of the giant circle jerk that is web2dev and doesn't have the balls to admit that JavaScript isn't the end all be all of programming languages. If the person above wants to ever be a competent dev and not a part of stupid threads trying to explain pass by value and reference incorrectly they will take my advice and learn something before JavaScript.
When it comes to opinions, fuck CSS in JS. Unless it's simply dynamically bundling or inlining CSS, but this whole writing CSS as objects in JS is ridiculous and I say that as someone who is well aware of CSS scoping issues and limitations. 
I am a webdev by trade as well. However, I cut my teeth with Head First Java, and I learned my fundamentals well. JS is my daily gribd, and I'll be the first one to say I don't recommend it for beginners.
thanks captain obvious. the whole issue is a mistake, not ignorance: &gt; e.g. by forgetting parentheses 
&gt; premature optimization is bad. this is not premature optimization. it's wise to think about performance when choosing a solution to a problem, even though the pithy quote says premature optimization is evil. i'd argue anyone who doesn't think about the performance of their solution is the real evil. the issue with this is that's it's a ridiculous performance concern. if you're to the point where the overhead of an extra function call matters but you're not worried about scanning a 2d array, you're probably focused on the wrong things.
I use this method right now: https://cesiumjs.org/2016/01/26/Cesium-and-Webpack/ how does this differ from that?
How is JS forgiving? That's not snark - it's a real question. Unless they have heavy UI experience with JS, all of our new hires are not proficient in JS. They can come up with solutions that work, but they are always the clunkiest abominations I've ever seen. Again, that's not to be snarky. The problem is that JS can be terribly tough to debug, all of the frameworks and libraries are highly opinionated (rather than discussing actual trade-offs for real use-cases), and states in web applications are tough to grasp without instruction. The most common mistake a new hire (who inevitably says the know JS) will make with us is making a controller for some service, writing validations with jQuery, and calling it a day. They *never* use a persistent session object (a few ways to handle this in our project) to hold those values and validate against them server side. This leads to bunk validations that can be spoofed by using good data then manipulating those same values in the console before submitting. System languages like C, Java, C#, etc. are divorced from a DOM. They have their own quirks and pitfalls, but the model for learning these languages, in my opinion, is much more palliative. Don't get me wrong - you can learn a good bit of JS without touching a DOM. But JS is the language of the web. It's weird to learn JS without applying it to the web. 
Pick another name, MS. This one is taken. Don't be another Elm. 
I do exactly this. Prettier most of the time works in my case but sometimes the `JSX` indentation seems to clash with some eslint rules so I do the formatting at the end of my commits and diff it with the previous ones. It really isn't that nightmarish as you're fearing, OP. Also, just doing `prettier &lt;enter&gt;` should give you all the flags that you can use.
I just started using styled-components today for the first time and I'm liking it so far. Check it out. It's not inlined styles. It creates classes for you and puts style tags in the head. No inlining. I was vary wary of using it because i didn't like how other libs did it (like radium, CSS in js, etc)
It can be a syntax error: http://google.com { console.log('here'); } Need to ensure the brackets are on the next line: http://google.com { console.log('here'); } Edit: Really wish Reddit didn't flatten triple back tick code blocks &gt;_&gt;
&gt; know Hey, /u/tbranyen. Knowledge is great, so let's see how much you know about yourself! One day long ago you said: &gt;" Same here. My grandparents had a ____________ that looked identical to that in Kissimmee.". Which of the following words fills in the blank (respond with **JUST** the correct **word or letter**)? A. conspiracy B. domicile C. human D. house --- ^I ^am ^a ^bot ^| ^Summon ^me ^with ^"/u/KnowUrselfBot ^!quizme" ^| ^Reply ^with ^"STOP" ^to ^opt ^out ^permanently ^| ^\/r\/KnowYourselfBot 
Look at Free Code Camp's full stack projects. 
I don't get it either. Is this only about performance? CSS &amp; HTML is a very good ui framework and there is really no need to step back to inline styles.
I love the library! Many frameworks have an overwhelming complexity for such simple task. This one makes easy composing any type of validation sequence with plain functions
It's less about performance and more about keeping CSS scoped to specific components. Another benefit is you can load only what you need for the page but you lose caching of styles unless everything is happening server side. While I get that scoping is difficult when working with a lot of developers and a complex website, most of my projects are smaller in scale and I manage scoping with a simple BEM class naming scheme. Also while I can read and write basic JS, I'm much more fluent in SASS for doing straightforward CSS stuff. 
I'll check it out, thanks. 
Hmm I actually find arrow notation functions more readable but to each their own I guess. Also I dislike hoisting and it ends up causing more problems than it solves for me so arrow notation actually helps in this case. Just my preference preference I guess
CSS Modules all the way. Best of both worlds. Your CSS is still CSS, your JS is still JS, and they overlap concerns in precisely the right areas.
It seems to me that Javascript is perfectly suitable to receive and deal with styles, why wouldn't it be? If you could express styles functionally it would be as useful as it is for user interfaces. The churn you have to go through to get css more or less behave across browsers and play along in the component era is a little crazy compared with how you deal with styles on native platforms. And this isn't just about resets, prefixing and bleeding descriptors, css hasn't been made with components in mind and the crutches it gets now don't really fix the nagging issues we face when making applications. And while the new band aids (shadow scopes, variables, etc) are propagating slowly it only increases the complexity that makes it volatile already. None of this is actually needed if styles were functional. Styles as object-properties could and will be done at the component level with a myriad of benefits. In the future css will likely be an implementation detail, just like html is nowadays. React-native already proves that it is viable. It did things in 3 years that css won't be able to do in 30 to come.
Nice article 
* Koa: 9640 req/sec * Fastify: 21287 req/sec
koa with async/await. hard to beat. Who is behind fastify?
un-be-lievable
A shame, but, as I am not a good designer, I never learned how to use those softwares. So, as a frontend dev, I work with html file directly, juste raw mockup without any logic, and I customise thing with the devtool and css in place. After that, when I am ready to go, I keep this file in a tab, and the new animated (meant with logics) one is written according to this.
You are not going to Google things you don't know you don't know. This year MacDonald's was caught saving passwords in plain text, for example. If you are truly responsible you need to know the theory behind it and know what is going on. If you keep this try and error approach you will never have quality in the things you develop.
**Edit**: Used even the host option, result is still the same. I did what you said, in my config: proxy: 'http://0.0.0.0/d8' And this is how netstat looks like: root@sw-web-drupal [~] netstat -tulpn | grep 300[01] tcp6 0 0 :::3000 :::* LISTEN 3658/gulp tcp6 0 0 :::3001 :::* LISTEN 3658/gulp I am using CentOS 7. Could it be gulp related? I am using browsersync with gulp like this: var gulp = require('gulp'); var browserSync = require('browser-sync').create(); var browserify = require('gulp-browserify'); var uglify = require('gulp-uglify'); // process JS files and return the stream. gulp.task('js', function () { return gulp.src('src/js/*js') .pipe(browserify()) .pipe(uglify()) .pipe(gulp.dest('dist/js')); }); // create a task that ensures the `js` task is complete before // reloading browsers gulp.task('js-watch', ['js'], function (done) { browserSync.reload(); done(); }); // use default task to launch Browsersync and watch JS files gulp.task('default', ['js'], function () { // Serve files from the root of this project browserSync.init({ proxy: "http://0.0.0.0/d8", open: false }); // add browserSync.reload to the tasks array to make // all browsers reload after tasks are complete. gulp.watch("src/js/*.js", ['js-watch']); }); 
You're not wrong, you're just an asshole :) 
This loads all assets in one go, viewer and all. There are no other dependencies, build steps, or files to copy / host. Just var Cesium = require('webpack-cesium'); If you just want to add Cesium to the global / window object, add a script tag and host one of the files.
Try utfstring = unescape(encodeURIComponent(originalstring)); 
I know Elm the language, and elm the tree... is there another one?
Friend don't lash out because someone implied that you're a jerk with the social skills of a damp smelly sponge in a polite yet firm way. I know it's hard for people like you because of the extreme lack of personality some asshole only developers have. 
* could you put up an example on jsbin? * it's not clear from your example what/where #addon1|2 or .frmctl are * I'm not sure why you're finding the parent, then finding the buttons again and adding/removing the same class? * you might find it easier if all your buttons observe a common object and manipulate/derive their selected states from that instead
Or one could learn how things work and learn how to program and avoid most of that. Your life will be far easier, stable and you'd know much more than anyone else in the field who won't be doing this five years from now.
It's the latest gimmicky thing made for headlines and not real life. Redditors will eat it up.
This is reddit. They won't get it. They're has to be a button on this thing for that thing. No one gets up off the couch to change the channel anymore. Too much assumed effort.
&gt; It does everything css can do as far as I'm aware. I'll stick with CSS cause I am positive it does everything CSS can do.
Since picking up Ember I've found my mental load when it comes to building web apps has been greatly reduced. I literally never have to worry about project scaffolding, or routing, or hooking up styles to components, or building my assets, or anything like that. I can just focus on building the meat of my app, which is awesome.
* [jsbin](https://jsbin.com/dibosatepe/1/edit?html,js,output) * Sorry mistake, updated digaram, frmctl == btn. The file structure is illustrated on the right. Both addons include the global.js * So I can clear previous selected items (radio button behaviour) * Can you expand on this please. I want to keep general behaviour in global.js, but the issue is just detecting the changes state at the addon file.
Look for the method(s) in whatever addon host you are using, that allows you to communicate between addon scripts. Use that for synchronization.
Is this to be celebrated? At least 90% of these things are presumably duplicates, or variants on the same idea - I cannot imagine there are 500,000 _problems to solve_. When the repository expands so quickly, the question is - why aren't developers adding patches and fixes to existing projects, rather than forking their own?
Very good guide, thanks!
SECTION | CONTENT :--|:-- Title | You're not wrong, Walter. Description | You're just an asshole. Length | 0:01:00 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
He's the founder of Deco IDE so I guess that's something. Now owned by airbnb. (I just looked at his github profile)
I'm more of a back-end dev but do build some JS modules as needed. I thought I'd try to incorporate some React into the front-end of a project the other day. Ended up spending like 4 hours getting the tooling setup and something somewhat working. So then I start looking at docs and trying to figure out some issues and each one used different tooling. Serious question, how do front-end devs that use react or flavor of the month stay productive?
So my thought behind hoisting is that it's pretty common to see "helper" functions at the top of a file in an effort to appease the linter with the whole "using a function before it's declared". Thing is, if you see a giant helper function first, you're already going to be disoriented. You don't know where the main point of execution is, and right off the bat you have to find it. I'd rather do the "main" stuff (or the main exports) of the file at the top, and if you see a function call and you don't know what it does, you can reference it as it comes up later. I'd rather see a function that I'm looking for than one that I'm not. And you can't do that without hoisting. =) 
Writing BEM classes is hardly bending over backwards. I don't have to rely on all my devs knowing both JS and CSS (a lot of React devs really don't know CSS well, and a lot of designers know CSS really well but not JS). I don't have to manually pass a theming object just to get simple brand colors. I can easily restructure my CSS and markdown and relink styles with little effort. I'm not saying I don't see some advantages to CSS-in-JS, but for the majority of projects I see it's overkill and comes with disadvantages. 
I have not yet been convinced that decorator syntax is adding clarity rather than inhibiting it. It's just one more means to call a function - under odd and specific circumstances? One of the joys of Clojure is the amount of time you *don't* need to spend parsing syntax... 
Could you help me a little bit more please. There is a tiny little problem with your regex. The logic works really well but it removes some white space from the end. Example: `$test = "test";` becomes `\$test= "test";` Should be: `\$test = "test";` space before `=` is missing
Build a React Native app using Redux aligned with your deepest interest outside of coding that you would use. Even better: do that but keep a way to make money in mind so you can quit your job and work for yourself. Only you can find and determine what your deepest passions are and what you want to allocate the few years you have on this planet toward. It's a question to always be asking yourself and refining its answer. If you need to be practical, it's ok to think of what you are building as a stepping stone to something you build in the future when your skills are better and you know what you want to do more. And that's basically how I take your question. So build an app for your fellow firemen. This solves one key problem most people don't think about: getting feedback and motivation. It's like working out and eating right--if u tell ur buddies, they hold u accountable and u feel u have to do it. We humans aren't perfect. Support systems help, if even just in our head. Your partners will be asking you when the app is coming out and it will force you to finish and make it the best. Make something you can tell your friends and associates about, not just Internet folks u can flake on because they don't care. But definitely react native using React Navigation and Redux. Animated performant apps ur friends can use on their phone and permanently install is what they will be most impressed by and take the most seriously and likely revisit/reopen. Websites they have to punch in less so. If u can get ur friends receiving push notifications ur guaranteed to at least have a few users continually checking ur app.
&gt; But function expressions are given as examples on the Functions page. ...where?
oh shucks seems like everyone is bandwagoning on Go lately ( late 2016 - early 2017) 
Debian is around for a long time, and 70.000 compared to npms 500.000 in just a couple of years isn't that much. Pretty sure lots of junk in there, too. &gt; So - you'd say the issue is that too many projects are unreceptive to pull requests? Again, it is what it is. That doesn't diminish npm reaching the size it did. All package managers fight with the same problems. npm came out of no where and is now bigger then most if not all of them put together, because it unites the biggest dev community on planet earth. They're celebrating it, what's so bad about it?
https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/encode 
For what it's worth, I recommend to use leading underscores to mark things as private until actual privacy lands in the language¹. The WeakMap workaround is just way too annoying to use. Alternatively, use TypeScript. It has access modifiers. &gt; **@ ljharb** &gt; Private means inaccessible. That's not quite right. Instances of the same class can still access each other's private fields. And if you got something like library-privacy, anything within that library is free to access anything inside it. [¹ https://github.com/tc39/proposal-class-fields]
[mp4 link](https://i.giphy.com/JIX9t2j0ZTN9S.mp4) --- This mp4 version is 99.33% smaller than the gif (50.82 KB vs 7.36 MB). --- *Beep, I'm a bot.* [FAQ](https://np.reddit.com/r/anti_gif_bot/wiki/index) | [author](https://np.reddit.com/message/compose?to=MrWasdennnoch) | [source](https://github.com/wasdennnoch/reddit-anti-gif-bot) | v1.1.2
How do you go about running Rocha or Focha with ES6 code? The article mentions --harmony, but I can't see how to use it. 
You must not use strongly typed languages often. JavaScript is so vague you only know a value because of your console log. The 'compiler' does nothing to help you. Callbacks are awful. No interfaces exist natively. Debugging is next to impossible if you follow a traditional method due to interference of frameworks or libraries in the browser. It's not expressive.
AAAaargh, scroll not working. Works for the first slide and after it's dead forever. RIP mouse scroll wheel.
Angular is a expansive framework that has runtime dependencies. It will not produce a standalone webcomponent.
I am taking the JavaScript full stack course on TreeHouse. It's hands down the most amazing and curated learning resource I have touched. 
Hi /u/st3dy, release announcements are fine, but please link to the project page or some other meaningful resource (this post was removed). Thanks.
The most important question is "how it's achieved". Many _fast_ frameworks achieve their speed by cutting features and comparing themselves to bigger (and slower) well established frameworks.
Then why are you inflicting JSX upon ourselves?
The prototypers at my company are using Framer and Illustrator and Sketch
https://nodejs.org/dist/latest-v6.x/docs/api/fs.html
I edited my original coment before you answered. Never mind, I got it working. I had to disable ipv6 protocol on said machine. That helped.
Are you using any tool for generating the scaffold JS code from mockups or from Frame?
I think it is capable, but the component would have angular as dependency. So it would be quite big. I'd look into polymer or skatejs/svelte if you want web components.
The tooling is usually the same for every framework you touch or every project you begin: git, node, npm, babel and webpack. Knowing these makes setting up projects trivial. Frameworks give you cli's that make it faster like create-react-app, though doing it manually doesn't take more than a minute. It sounds more like all of this is new to you, in that case you should learn it plain and simple. Nothing you will encounter is doing without. The few places that still have you include script tags are fading out. Just curious, have you had the pleasure to deal with C++ linker settings, makefiles, python toolchains or Java settings? The web specific tools people like to complain about are pretty easy compared to what we've had to learn previously.
React has been around for four years now. Hardly "of the month".
I agree with most of your other points, but I think weak typing is a weak (pun not intended) point. Strong typing allows errors to be raised when incompatible types are used. I feel that this brings about a stronger mental model. You can't preform subtraction on an int and a string, but you can subtract an int and a string that can be successfully casted to an int. Strongly typed language usually make this an explicit action. In JS, `1 - "2"` has implicit casting, and instead of NaN (like `1 - "test"` would give) , you get -1 of type `number`. I concede that my mental models may just be different. I feel if I started with a weakly typed language, I would have fallen prey to implicit casts since I didnt quite understand what went on under the hood. 
The best practice is to write as much HTML as possible in HTML and only have JavaScript generate new HTML if there is a very good reason. The reason for this is maintenance. It is very easy to see all the baggage and bad code when it is confined to a similar format and a similar location. There are also performance implications. HTML is downloaded before JavaScript so if your HTML is absolutely massive then you might want to slim down the page and bring additional content in latter and dynamically. This way the user is looking at some amount of branding and messaging instead of an empty white page waiting for the first resource to come in. Otherwise, put as much HTML into HTML as possible. Also, jQuery is stupid slow. The standard DOM methods are 2800x faster (average cross browser) than the standard querySelectors, and jQuery is even slower than that. That performance difference is based upon a single access comparison (up to three steps walking the DOM executed simultaneously versus a single equivalent querySelector that is up to three steps of complexity). When multiple accesses are considered the performance gaps widens significantly so while an artificial microexperiment will indicate a performance difference of 2800x a practical real world comparison might show a performance gap many times larger than that. Of course any method of generating HTML from JavaScript will always be slower than if the HTML is present in an HTML file so that it doesn't require any JavaScript generation. If you do choose to generate large amount of HTML in JavaScript how are you validating accessibility without manually testing the page in a screen reader?
Yeah this is a fair point. Generally when I taught absolute beginners, it was difficult introducing types to them before variables, loops, arrays, objects etc. Not having to deal with learning how to typecast etc or what public and private functions were helped a lot in letting them learn quicker and grasp bread and butter programming concepts easier. But yes, static types do make for a stronger mental model. 
How big is your project? Angular 1.6 has issues because people have used it in production heavily and realised that there were shortcomings. Why did you like Angular 1.6 over Angular 2 or Vue? Also Laravel has built in support for Vue, how is it better for it than Vue? Here is a decent article on the problems with it https://larseidnes.com/2014/11/05/angularjs-the-bad-parts/
Leading underscores offer the best of both worlds: they let a method simultaneously be private and public, getting the benefits of both ... IF your team is not made up of idiots. All of the arguments against leading underscores boil down to "but people might be stupid" and use an underscored-method outside of a class. Then, someone else "might be stupid" and think the underscore means the method is truly private, change/delete it, and then get a bug because it was really public. And that's 100% true: if your team does that you absolutely can get bugs. But most of us programmers went to college for four years, and those of us who didn't were smart enough to learn programming on our own. We're not idiots. We are capable of understanding that underscored-methods are not truly private, yet at the same time are intended to be private. This concept is no harder to grasp than `map` or `reduce`. If your team is made up of adults and you use underscored methods, not only will you not get bugs, you will write better code. As long as everyone understands that you're not supposed to use underscored-methods outside of classes, they won't get used outside of classes. And as long as everyone understands they aren't truly private, and checks before refactoring them even though they're underscored, then even if someone *does* use an underscored method outside of the class it *still* won't create bugs. But what you will get is the benefits of both. When you go to refactor, there is a benefit to knowing that a method is/isn't supposed to be used outside of a class. And when you go test those methods, there's a huge benefit to being able to do so directly (because they are in fact public). Or, when you need to debug code, you can still call those "private" methods to get debugging info (which you couldn't do with true private methods). In other words you can very easily get the best of both worlds ... but only if your team isn't made up of morons.
What makes Symfony or Laravel so much more convenient when working with Angularjs? It's all just rest anyways, or should be. I'm doing some work with angularjs and while it's not bad per-say I much prefer Angular2+. Things like Angular Language Service, component based architecture by default and integration with Observables are worth the "effort" imo.
I love the `help` flair.
&gt; The real beauty of prettier is that you can have your own prettier config that differs from your companies standard. Thanks, I think this point really helps to sell me on Prettier (and helps me understand that it's not trying to force bad formatting standards on me, but in fact is trying to do the opposite).
does it improve if you use this ? str.replace(regexpMagic, `\\$1$2$3`);
Yeah but you said "I don't understand the hate for Angular". It's completely fine for school projects and personal projects etc.
Thanks, that was very insightful.
&gt;But scoping CSS to components just undermines the whole concept of keeping structure and style separated. Not sure how this is a problem. Before we were writing CSS in JS, there were all kinds of solutions to CSS being global instead of modular, and none of them were as good as, y'know, actually making CSS modular. Putting the styles next to the component they style works just fine.
Checkout `create-react-app`, it takes care of all the setup you need to get started. (Also react has been around for several years.)
&gt; It really isn't that nightmarish as you're fearing, OP. Good to hear. My big concern was that there would be "opinionated decisions" made that *wouldn't* have flags I could use if I disagreed with those decisions. However, it's really starting to sound like I don't need to care about that at all, if my main use of Prettier is to format code before committing. If that's the case, then all I need is for either A) Prettier to get at least close enough to my idea of "good standards" for me to live with, or B) if it can't, for me to use any other formatter tool to format the code for my use (and then use Prettier, with it's line-length handling and such, for formatting on check-in).
Thanks, that was really helpful. If Prettier really has "made those (style disagreements) configurable" then I have nothing to worry about. And I definitely do see the value of it being able to format based on line length (something I haven't seen any other tool do).
vie-material seems to be quite heavy-weight for inputs only
100% agree with this. 
&gt; It is entirely accurate. https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html Do you see that 'Y' there in the "class" column? &gt; Classes do not have private fields... yet. Yes, I already mentioned that. &gt; If you [...] don't understand scope I do understand how scope works in JS. Thanks for asking. **Edit:** Here is a Dart example: https://dartpad.dartlang.org/03990898d0007e08cc10d09a18cc58f9 As you can see, that other instance's private fields are not inaccessible.
*Per se :)
It's not really. To instantiate the components you need the angular run time to be running. And you can't easily just include a few random angular components scattered throughout an otherwise non angular site. Angular is designed pretty explicitly for spa's. Maybe something will change in the future but angular isn't currently set up for non spa use case at all.
thanks, I wondered how to spell it when I was typing and did't want to put effort into googling it.
If you are going to do this, use Objects, not Arrays. While the syntax you show in your example works, it does not do what you think it does. Use this instead: var piece = {}, block = {} piece.height = 50 block.height = 50 Your original `piece["height"]` syntax still works too, but it's exactly equivalent to `piece.height`. Once you switch to objects, you can also do things like this: var piece = { height: 50 } This declares the variable and sets up `piece.height = 50` in a single statement. Code like this is very common in large, professional projects.
thanks!
You are right. It's unpopular.
The big idea is to use something which can be easily swapped out for the real thing in the future. While capturing a WeakMap instance can be used to emulate the behavior accurately, it requires some boilerplate code and is annoying to use. (**Edit:** Example: https://jsfiddle.net/cex8urmr/) The leading underscore convention works just as well if you are a bit careful.
&gt; Console.log is additionally super helpful for seeing what your variables do etc. So is using the actual debugger that comes with the web browser.
&gt; The most common mistake a new hire (who inevitably says the know JS) will make with us is making a controller for some service, writing validations with jQuery, and calling it a day. I think beginner in this thread means someone that started programming two weeks ago, ie not your typical new hire. 
yeah scrollwheel only works once in Chrome
literally just this: .mat-input-container, .mat-select { width: 100%; } i'd imagine if you used more input types you'd have to include more classes.
So I've worked with and mentor a lot of developers straight out of school. One of the most consistent things fresh grads are missing is the understanding of the time scale of real projects. You're lucky if you find someone who worked on the same code for a whole semester but real code based have to worry about growth and development on the time scale of years if not decades. To be clear I am not knocking you, you should absolutely pick the tools that you are most comfortable with to get your school work done. However, I hope you can come to realize that frameworks that are easy to work with for a few days or months don't necessarily mean they will continue to be that easy or comfortable to work with when you have a dozen developers banging in the code for years. 
If you think unit tests, despite their obvious shortcomings, won't help you deliver a good product, you are fooling yourself. Don't let perfect be the enemy of good.
Can't agree with this after spending a year on React projects. So much about Angular I miss.
You can do components with Angular 1, too. 
Hi /u/willw10, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
The big idea is to circumvent the scope conventions of the language, that already account for privacy, so that classes can creep one step closer to a Java-like convention.
or Typescript
True but I'm on mobile and couldn't at the time. Also it's the first result if you just google "babel".
I hesitate to say "most" without data, but it feels like most people...particularly those using arrow functions...dont' write code for browsers, they write code for Babel or Typescript.
Have you tried Vue? Laravel officially recommends Vue as a complimenting front end library.
I read all the doc and do little prototypes but not big project yet. It is great though
Just wondering, what do you miss? 
Yea, or like C#, C++, Swift, Rust, Dart, Kotlin, and so on and so forth. Privacy is a very common feature. And as the leading underscore naming convention clearly demonstrated, there is a huge demand for it. Being a unique snowflake has no value by itself. Being different for the sake of being different improves nothing. You are working with computers. Things will always change.
If I were phishing for people to help me list reasons I can use to get my company to migrate to angular 2 this is the exact language I would use in a post.
[removed]
Looks very interesting! 
Re: name collisions, I just always add the component's name as a class to the root element of each component, e.g. add a MyWidget class to the MyWidget component. Then just scope all styles in your component's CSS to .MyWidget, which is super easy with sass or less.
Cool! I use Vue in production and it's awesome. Though I have no qualms with using angular 1 if that's what your comfortable with and it meets the needs of the project. As someone doing web development there is some wisdom in staying in touch with the newest technologies.... Even though it's hard and sometimes annoying to keep up with. Our industry is ripe with innovation, and that's a great thing!
I use NG 1.6 too and not touching NG 2 for now.
&gt; I don't understand the hate for Angular Spotted your problem. Need to understand that first, then you can evaluate your decision in the light of day.
I don't care what you name properties or methods. I care that they are _consistent_. This is _their_ style guide/rules, people are free to change it to confirm to their own style. I don't understand the big fuss.
&gt; Especially the old $scope / $rootScope based approach You like that mess? This for me is a sign of just how ill conceived Angular was.
i'll bite. i'm developing apps in 1.6.4 right now (with experience all the way back to 1.2), using all the Cool Tools like typescript, webpack and yarn. i think i have a decent enough perspective to share. you're right that angular.js is still a very convenient tool. in fact, i'd go further and say that if you need to support older browsers there might not be a better single option on the market, as angular.js handily bakes in e.g. a promise polyfill, a promise-based http service, and a slew of other convenience features like is(Function|Object|etc) or copy (deep copy!!). on top of that, the type definitions make it painless to, say, `import { copy } from 'angular'` and use it like that. but those conveniences are really liabilities these days; we have promises and a promise-based http service baked into the browser, along with high-quality polyfills for them gushing from every corner of the ecosystem. using angular.js is productive and convenient, but it locks you into whatever architectural &amp; performance plateau it would have (already?) reached when google moved on. and speaking of performance: if there's one reason why people are moving on from angular.js (and why google decided to make angular), it's because two-way data binding - the ultimate convenience feature - is a total dead-end for basing a framework around. the strategies required for making two-way binding work (dirty checking) are horribly inefficient, even after all the time and energy spent on optimizing them, and can easily (i mean _super easily_) lead to situations where your app spins itself in circles trying to get its state right. anyway, all faults aside, it's still more than usable, even with the massive changes in the ecosystem around it. i find that extremely impressive engineering and design. however, be prepared to jump through hoops to make it all work (there's a reason `ng-import` exists). hell, i recently wrote a ~500-loc library myself just to make it more palatable for The New Shiny. that being said, i look forward to retiring it as a technology not because i hate it (on the contrary, i cut my teeth with angular.js; it'll have a special place for that alone) but because the world has so thoroughly advanced past the things that used to make it special. and really, that's the point: the world doesn't hate angular.js, it just doesn't have a place for it anymore. may we all be so successful. (also, minor quibble: react was heavily inspired by a) PHP, and b) lessons learned by the team behind MooTools; and vue.js takes a lot of ideas from angular.js, but also from react, ember and other libs) 
Yeup...In fact, React way more closely resembles Ember than it does Angular. Angular 1 is a full fledge MVC framework, where React only handles templating. I would argue comparing Angular 1 with React itself is kind of moot (Without Flux/Redux). Edit: Whoops. Totally confused Ember with Handlebars. It's been a while haha 
ok. thanks for sharing.
Have you ever used ng2 or react?
Yeah i do ng2 at work, and i'm starting a react native project
idk, a proper template, jsx system, virtual dom etc system is pretty important to me. With this it seems like I might as well just write the html and javascript myself.
[removed]
[removed]
I had this exact same problem. I was experimenting with this: https://github.com/kriasoft/nodejs-api-starter but it's too complex for learning graphql. https://github.com/postgraphql/postgraphql is awesome, but still really complicated. The best one I found so far is https://github.com/apollographql/GitHunt-API 
For React Native, have a look at a CLI generator like Ignite, or a starter app of some kind. Much easier to start with something that has made a few of the technology choices for you. Make sure you keep your data layer, business logic, and your views separated so that parts of the app are easy to swap out. Also I hope you know some objective C and Java, you are going to need that knowledge. You don't need to know all the native APIs like the back of your hand but I hope you have built native or hybrid apps before. Overall I think you'll really enjoy working in it. I like how it gets out of my way and gives me enough tooling to be effective while also being flexible enough to handle some pretty complex functionality.
I don't know, I don't work there anymore lol!
Cuz you gotta get 'closer to the metal' bro!
'Closer to the metal' has really gotten ridiculous. 
Your homework is not the same as a 200k LOC production app maintained by 10 Developers creating merge conflicts on a daily basis. That's all. 
Ember is also a full MVC framework though... Angular and Ember are more similar than React and Ember. 
Really comprehensive. Couldn't agree with you more. 
Take for example this component: class Flipper extends React.Component { render() { let Q = Object.keys(this.props.data) let A = this.props.data[Q] return ( &lt;div className="flip-container"&gt; &lt;div className="flipper"&gt; &lt;div className="front"&gt; &lt;p&gt;{Q}&lt;/p&gt; &lt;/div&gt; &lt;div className="back"&gt; &lt;p&gt;{A}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) } } It could be turned into this: const Flipper = (props) =&gt; { let Q = Object.keys(props.data); let A = props.data[Q]; return ( &lt;div className="flip-container"&gt; &lt;div className="flipper"&gt; &lt;div className="front"&gt; &lt;p&gt;{Q}&lt;/p&gt; &lt;/div&gt; &lt;div className="back"&gt; &lt;p&gt;{A}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ) ) } It's called a functional component because your component is now just a simple function that accepts props as its only argument. Also called a "stateless functional component" (SFC). This helps clean up your code a bit in cases where your component is not managing its own state. 
RDBMS arent a good fit for modelling graphs because the intrinsic meaning of a relationship/join between any two tables exists only in the data model. As the db is expanded to model additional relationships, it quickly becomes brittle and hard to manage. This is where graphing db's excel because they turn RDBMS on its head and focus on the relationship/join. At the other end of the scale, RDBMS solutions are overkill for simple key/value storage. In short: RDBMS when storing form-like data; NOSQL when focussing on inter-relationships. 
The only think missing from this is async data services. I have yet to come across a single "intro" react guide that includes where to put data requests, with or without redux. 
Haven't touched $scope, except for event listeners, in years. Also stopped using 2-way binding, replace:true, and lots of other bits. I see those old things as neat relics. A hint at how far it's evolved. Angular 2 was a natural evolution, as lots of other great frameworks are surfacing without the same tech debt treasure trove of terrible things necessary for backward compatibility.
It's important to note while it's better to do "stateless components" when they call for it; performance wise it currently makes no difference even in the latest version of react. There is still some work to be done to make these types of components function in a light-weight manner (e.g. react 16+). For now, even when you create a component this way, it will still go through all of the life cycle events, even when you are just clearly just calculating some render values + the render function. see http://moduscreate.com/react_component_rendering_performance/
https://jsfiddle.net/cex8urmr/ As I said, you can emulate the desired behavior via WeakMaps, but it's needlessly cumbersome. Of course it's also slower than private fields would be.
Angular is great. I've been using Angular 2 and it solves only a small bit of "problems" from Angular 1. If you are not bothered/experiencing these problems, you're free to stick with it.
Spot on with what I've been experiencing. I've been using Angular 2 and it doesn't really have anything that it solves that Angular 1 doesn't. That said, the $digest cycles in Angular 1, even though they got many improvements, could become a liability perfomance wise. In Angular 2 they are using ZoneJS hooks to deal with it properly, that was definitively an upgrade. As far as typescript goes, it's quite handy to use the new syntax features (async/await, the spread operator and arrow functions are the only ones that really I care tbh), but it isn't by any means solving anything new, with the right build tools you could use it in Angular 1 as well. With the perfomance advantages there are also still things that make me 'eww'. I dislike having to import my services AND declaring it in the component's provider list (and of course you have to reference it in the constructor). Same for having to sometimes double declare things in entryComponents / declarations.
There is no way to auto remove the test vars using a plugin (that I know of) for the non-minified code, aside from something dirty like a hard string replacement. However, I think I might be able to remove it via a wrapping closure. I will investigate.
That's with Chrome 55. Chrome 59 (current stable) got a new execution pipeline (Ignition + TurboFan). Startup is much faster now and memory consumption on low-memory devices is also better. Furthermore, you can't really tell what they were actually benchmarking there.
So are most of the big companies out there, who have invested significant amounts of resources into building large-scale projects with Angular 1.x. Despite its quirks and performance issues, Angular 1.x is still the perfect choice for many things, including starting a project from scratch. For starting bigger things that would require years of support, I'd probably think twice before choosing the latest Angular, and perhaps look at React instead.
Some good things about ng1: * Angular 1 had only decent module system through DI back then, just include your script tags in any order or concat them together and things are wired up in the correct order. * First major framework to be fully on board with Promises (via $q), when direct DOM mutations in jQuery success callback were the norm * One of the first frameworks with a view layer that frees developers from manual DOM mutations and the burden of keeping data and DOM in sync * UI router was very powerful and integrates extremely well with angular core components; compared to the awkwardness of react-router... * Built-in form directives are very hassle free and versatile The bad parts: * Two-way data binding, a limitation of its time. Uni-directional data flow wasn't known/popular in js land back then * On top of that, the mechanism for data binding is poorly thought out, hard to understand and gets in your way all the time (child/parent/isolated scopes, broadcast emits, watch, watchGroup, watchCollection, eval, evalAsync) * Reinventing js language constructs in its own bastardized way (the $scope is nothing like javascript scope or scope in any programming languages and is full of nasty surprises, its templating language having its own syntax you have to learn. I remember reading angular source code the gigantic regex to parse ng-option directive was such a monstrosity) * Directives are too hard: to learn, to write, to maintain and to reuse * Performance.. good luck tracking down the hotspot in your 10000 watches scatter all over the place 
Yeah. But which from both. Which first ?
After learning one, do I need the other ?
You don't, strictly speaking, need either to begin with.
yeah the rationale for that is supposed to be testability, but i don't buy it. strikes me much more as a vendor lock-in strategy, especially since the new angular insists on smearing its code over every possible inch of your application. 
Looks pretty cool! Can you show only the dollar values initially, let me click to choose one, and then accept my input as the answer? Of course this would turn it into an actual game especially if it records my balance.
For what? They're different things for similar roles. Some jobs will want one, or the other, or both, or neither. 
Yep. The reason we we're supposed to move away from JQuery spaghetti was due to the complexity once the app started getting big. But a huge SPA app in AngularJS is even worse than the JQuery, especially when you've got layers of scopes and async calls coming from everywhere. I'm hesitant to believe that React or Angular 4, along with the layers of constantly changing tooling, is going to make thing better, despite the promises. They're great for quick prototypes, as was AngularJS, but I feel the reason we're constantly rewriting the same apps in the latest front-end framework every two years is simply because Javascript is not the solution we need. 
I wish more people realized how similar Angular 1.5 and 1.6 can be to Angular 2+ (I even recently helped write a [book](https://www.ng-book.com/modern-ng1/) that goes through how you can use Angular 1 with Webpack, Redux, component architecture and so forth). I've used 1.6, Angular 2, React and React Native at work and I still enjoy working on a decently scaled and architected Angular 1 code base. There are countless companies with massive Angular 1 code bases and although switching to a different framework is something that might eventually need to happen, I just wish more people realized how much they can do with the one their team is currently using (to the point that they might not even need to switch frameworks for quite some time).
Oh okay. I see
&gt; I don't understand the hate for Angular Then with respect, you should read up on criticisms of Angular 1.x before you aspire to hold any opinions about it. You don't have to *agree*, but if you don't even *understand* why people might criticise a (any!) framework then you don't don't know enough about the subject concerned.
You are most likely going to need to use a library like jQuery to help you manipulate your list. There are more advanced frameworks (like Angular and React), but I think for what you need, and based on your skill level, jQuery should work fine. Though it begs the question, you may be better served just using an FTP view and putting security at the forefront (password protection).
&gt; I do not like that convention The main thing it has going for it (and the main reason why I recommend to use it for the time being) is that's easy to spot. You can grep it or you can use a linting rule. This will make it much easier to update the affected areas in the future. An IDE might even provide a "quick fix" and do most of the work for you. Personally, I think that funky leading characters are kinda ugly and somewhat *Hungarian notation lite*™, but I don't really mind using them.
Kind of bizarre that a phone takes the second place. 
React's main differences are its lifecycle controls, proptypes, and high-order functions (because everything in React is just Javascript). Personally, these factors along with styled-components have made my speed to completion somewhat longer. [Also, I think Vue's official comparison on this is better than anything that I could provide.](https://vuejs.org/v2/guide/comparison.html)
Possibly
It's the Node community's love affair with NoSQL more than anything. If you want a really painless experience developing a GraphQL API with postgres, for example, look no further than elixir, Phoenix, and absinthe. 
I respect your decision to stick with npm. Recently I discovered that it is possible to avoid these type of bugs with npm as well, using the global-style config. https://docs.npmjs.com/misc/config#global-style I'll update the article with this info
I made a timer for official curling matches that syncs on multiple devices with web sockets. Still a few kinks to work out, particularly with the UI, but working pretty well otherwise! App: https://timetocurl.azurewebsites.net/ Source: https://github.com/trianglecurling/timetocurl
I just took a look at it, looks really clean and cool. Impressive, good job man :)!
A small recommendation: explain what it does in the README. Is it an audio-based CAPTCHA that says, "Hi, are you human?" Or does it ask three riddles like in Monty Python's Holy Grail and hang up if they get it wrong? In other words, I want to know _how_ it's filtering robocalls, not just how to set it up. (I know I could look at the source for this, but...)
It is sad that we might need this in the future. Surprised at how nice the twilio API is. 
Agreed! 6 months ago, I inherited of a crazy AngularJS 1.x codebase that runs in production and where the client wants me to debug stuff, add features and rebuild the UI. Coming from React and AngularJS projects before that, I felt like everything was so convoluted with so many services/controllers inheriting behavior from crazy abstract classes, clumsy dependency injection stuff, use of 'ng-controller' all over the place, modals are bound to url states, directives (more like magic html attributes that you can paste on any dom element) that could have been basic components, direct dom manipulation where it was not needed, $rootScope etc. The guys before me tried to build reusable directives to display charts and they almost created their own callback lifecycle. The app works well btw, the performance is great so far but debugging and iterating on this app is a nightmare. This experience makes me realize that AngularJS is really powerful, you can do so many things with it, but the consequence is that sometimes people overengineer stuff. They need clear boundaries to keep things sane. Since I've seen that Angular 1.6 has .component(), every single new feature that I build is only using components. No more directives/controllers/non-isolated scope shit. By enforcing this set of constraints, they help developers to write cleaner and more maintainable AngularJS code, instead of crazy MVC/MVVM stuff. Onboarding developers even become easier. I don't really like to compare JS frameworks because they all have their advantages and tradeoffs, but imho these constraints are definitely why React is better than AngularJS (I can't speak about the others, these are the two I've spent the most time with) And if we migrate the whole codebase to components progressively, one day it might be possible to get rid of AngularJS 1 and use something more perfomant/saner if needed. 
I was in Chrome :)
good eye. That stops the site from being broken but the ajax request isn't doing its task.
[An Electron app for copy/pasting copypasta.](https://github.com/kingdaro/donger-bin) I'm working on improving the UI and making it more general purpose (for more than just 'dongers', lel)
What I meant from breaking the code is that the javascript had a major syntax error in it stopping further javascript from running. Getting rid of that extra curly bracket stopped that happening and after running the new code, the javascript showed no major syntax errors, but the ajax request is still not working properly. No specific error, but I knew further down javascript stuff wasn't working so I was able to pinpoint it to the ajax request I had just put in. I'll check out to see if any network requests have taken place. EDIT: No network traffic in relation to the ajax taking place
Compared to standard programming tools...of the month. In five years, React will join the pile of frameworks no one uses anymore along with the React users who thought it would last forever.
I haven't worked much work Vue. Our company chose Angular over Vue/other options for an internal app we released earlier this year mostly because of the bigger/more active community. We were able to use a bunch of plugin-like modules (e.g. ng-bootstrap, a busy-spinner module). It wasn't without some pain but I would use it again for similar projects (if only because now I've experienced building an Angular app from scratch). With that said, that project made me realize I prefer libraries to full frameworks in most cases. You might have some luck finding a job offer looking specifically for someone who knows Angular, but I recommend making sure you also know the basics (JavaScript) as others have mentioned. Edit: words 
we use join-monster-- it solved the problem of complex data relations rather eloquently 
Yes that sounds about right. People don't realize how much faster phones have gotten in the last few years. Javascript used to destroy mobile browsers.
Oh I know the differences since I've been using both for about 2 years now. I'm just curious why you'd pick React over Vue for long term projects since obviously you believe you are more productive with Vue.
Here you are https://github.com/MaxGraey/webpack-butternut-plugin. This package without babel dependancy. Has benchmark and some speed advantages for multientries.
C++ was one of the first languages i learned and the language i've spent most of my career with (began as a system/lowlevel programmer), it is a tough language to configure and optimize but if you think it isn't, let's just just leave it there. I then moved on (Java, C#), still hard to configure. As for the the tools i've mentioned, it does not matter what "frameworks use" and how they're built, *you* can use babel and webpack and pull in whatever framework or module you like. Vue, React, Redux, Vuex, Mobx, whatever, it isn't more than an "npm install" and an "import" statement away. A webpack config that allows that to happens is trivial: module.exports = { entry: './index.js', output: { filename: 'bundle.js', path: './dist' }, module: { loaders: [{ test: /\.(js|jsx)$/, loader: 'babel-loader', query: { presets: ['env'] } }] } }
Nice work!
Really? ?
Well written but fatally flawed. No mention of Vue, and FAR too much importance given to Ember and Polymer, particularly the former. At least it doesn't bang on about Aurelia. Mid 2017 the choices seem clear: React or Angular, with Vue a good up and coming alternative. If you are on the bleeding edge there are other choices like Cycle, but you probably know what they are anyway. Polymer not quite ready for prime time just yet.
What's wrong with Ember? I've never understood why it isn't talked about. 
&gt; which is often considered to be the next step in the evolution of frontend frameworks It's not really the next step, in fact with the introduction of React Fiber, Vue's going to be lagging behind. Just because there's hype around a framework it doesn't make it great in itself. React has 10x more daily downloads and has a far bigger community pushing it forward. Vue is nice and neat, but it's not a big player like React and Angular.
Big and steep learning curve. Plus these things follow trends, like anything else. If you use React you'll find devs no probs. Ember? Not so much. So it becomes a self fulfilling prophecy.
You are asking about truths values in JavaScript. Here is a link to the MDN article: https://developer.mozilla.org/en-US/docs/Glossary/Truthy basically, anything that is not undefined, null, false, 0, or NaN will return as true when evaluated in an if statement. Doing test === true will also do a type check and will return false unless test is actually a Boolean true value. Here is a quick codepen I put together to show a bunch of examples: https://codepen.io/christoferpeterson/pen/GEMRNo
It's probably used in more places than Vue is. It's especially useful for large applications. Companies like LinkedIn use it and contribute to it and it's current engine rewrite, Glimmer, is faster and smaller in size than both Vue and React. A lot of companies still use Ember. I do love react though. 
I've heard this mentioned before but at least in Seattle it seems to be about equally as popular as React if not more. Just my experience at SeattleJS meetups. I think it might be a regional thing.
&gt; Edit: but surely your original statement is still wrong; the documentation shows that function statements are supported That's why my comment emphasized function "expression", in contrast with with function declarations.
The compiler won't do this automatically, but its certainly possible. Conceptually, you'd treat it like NgUpgrade - it creates a "wrapper" that bridges the Angular component to an AngularJS 1.x component - the same thing is possible with Custom Elements. Events, Properties and Attributes would need to be "relayed" from the wrapper (the CE) and the Angular instance. See https://github.com/angular/angular/blob/master/packages/upgrade/src/common/downgrade_component.ts for how that's done in Upgrade. It's certainly something I'd like to see us do at some point in the future, but its not at the top of the priority list at the moment. 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [angular/angular/.../**downgrade_component.ts** (master → 263c1a1)](https://github.com/angular/angular/blob/263c1a1d7eccb69577759867ba80df5cab088233/packages/upgrade/src/common/downgrade_component.ts) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply djcmr7e.)^.
As /u/our_best_friend said, part of it was the learning curve. Ember's docs used to be lacking, but they've done a lot to fix that. If anyone tried Ember a few years ago and was turned off, I'd suggest giving it another go (and maybe, if you're still turned off, consider reaching out to the official Learning team about what made your experience less than great). Part of the learning curve issue is that Ember does much more than, for example, React. If you were to ask "which is more complicated, Ember or React?" then the answer, rightfully, would be Ember. However, it's not fair to compare Ember and React, since they're not doing the same thing. Comparing apples to apples would be React vs. _just_ the Component concept in Ember, which is very powerful all on its own (see the new Glimmer tooling that they've extracted out of Ember). To compare against Ember as a whole, you really need to measure against React _plus_ a routing tool like React Router, _and_ a data tool like Redux, _and_ a build tool like Webpack, because Ember rolls all of that together. I would argue that learning all of those tools together, vs learning Ember, are roughly equivalent. Another thing that I think plays into the popularity is the corporate backing of the different tools. React has Facebook, Angular has Google, Ember has.... Who? It depends how far back you want to trace the history, but the short version is that it didn't come out of any one company, and who is behind it matters to some people when making technical decisions. LinkedIn has since adopted it really heavily, and hired a lot of the core developers to make it fit their needs (to great benefit of the larger community). I've been doing Ember development almost exclusively for the last 4 years or so and love it.
The if-statement coerces whatever expression you give it to boolean, and then checks whether the result is true. That's always the case, it's not a special case when using a variable that's already a boolean. For example, if you wrote `if(foo == false)`, what you're doing there is evaluating the `==` operator. If `foo` is false, then the `==` operator will evaluate to `true`, which is then passed as the condition to the if-statement. The if-statement has no idea that you used the `==` operator. Its behavior is no different than your examples, except that in your examples the expression is just a variable name, so there's nothing to evaluate. And your variables are already bools, so the coerce-to-boolean step is also a no-op. 
That's some valuable information. I'll look into it tonight or tomorrow. Meanwhile I've found a simplistic example which used an angular component inside a react application. https://github.com/alebedev/angula2-in-react/blob/master/app/js/mainApp.jsx Your proposal seems to be even more complete. Thanks 😄
To put some context into my question. We use at our organization angular mainly. So we publish angular components and produce angular apps and a lot of our devs know and use angular 1.6.x &amp; 2+. We are very few to know and use multiple frameworks and very few to use javascript for things other that frontend development. So we're trying to see to which extent those angular components/modules we created (and will create) can be repackaged as "webcomponents" to be used in, say, a polymer or react apps.
It must be, in trying to learn it in earnest, but I think only one company in my area uses it.
How do you know daily downloads? Vue was the fastest growing github repo of 2016 so it has huge momentum. https://www.reddit.com/r/javascript/comments/5loq79/vue_is_the_top_javascript_framework_of_2016_by/ From what I see angular is dead and should not be in the conversation, and it's a fact that React Fiber is not out yet and there are still many blockers, it's hard to make a case for React based on it.
I am sure it will, but it doesn't seem there just yet - outside the Google bubble, that is. I mean they use Dart a lot, and used GWT in the past...
Ember is extremely complicated with little to offer for state management. In my year of ember experience, I've also found it nearly impossible to debug and refactor, with poor documentation and low quality stack traces. The 'best practices' often lead you to write highly coupled code. Glimmer2 seems nice though. Typescript support might go a long way to reduce Ember's incomprehensibility.
Github stars mean absolutely nothing, look at npm if you want to know if a package grows in popularity or not: http://npmcharts.com/compare/react,vue I think he is right. Vue is not really new, it is a mixture of Angular on the outside and React in the inside. It doesn't focus on modern patterns like React does and in fact inherits lots of bulk, complexity and restriction from the template era. He is also right in stating that Fiber is already chipping away at the next frontier which is bringing native methods like culling, chunking &amp; prioritizing into the web. Someone on the Telerik site addressed this recently, where they also skipped over Vue due to its similarity to Angular: &gt; Another big influence you miss here is static typing. Angular 2 being written in TypeScript is a big positive. But here React has achieved quite a coup: TypeScript has built-in support for JSX. This means that UI templates are also statically typed. It actually means that TypeScript provides more explicit support for React (and its many clones) than for any other pattern. I suspect this will become a sticking point for Vue. It is frankly a blast from the past - similar in feel to Knockout.JS and Angular 1. The view is defined in HTML extended with its own vocabulary of directives. So I suspect it is attracting Angular 1 refugees. It seems unlikely to pursade many React users however, because of the huge advantage React derives from its "everything is JavaScript" approach. No need for HTML directives for looping/logic. And templating integrates with modern JavaScript's modular name spacing and TypeScript's static checking and intelligence. React's approach creates a virtuous circle of mutually supportive elements.
Have you read up on CORS?
And worked awfully slow, if I understood correctly
No, [it's Polymer](https://youtube.googleblog.com/2017/05/a-sneak-peek-at-youtubes-new-look-and.html).
&gt; To compare against Ember as a whole, you really need to measure against React plus a routing tool like React Router, and a data tool like Redux, and a build tool like Webpack, because Ember rolls all of that together True, but Webpack is a standard FE tool these days. I used it before I started with React, and I can also use it with angular. It's the Ember team's choice to stick to their own - therefore it's entirely fair to include that in the Ember learning curve but not to include Webpacl in React / Angular
`element` is not defined in your second function. Is it supposed to be `data`? Try this: function passToArray(object) { // Get or initialize new rotation const rotation = JSON.parse(sessionStorage.getItem('rotation')) || []; rotation.push(object); sessionStorage.setItem('rotation', JSON.stringify(rotation)); }; function addElement(type, data, _color) { // Clone the input so you don't modify it const element = Object.assign({}, data); element.type = type; passToArray(element); }; addElement('buzz', { foo: 'bar' }); addElement('bang', { bar: 'foo' }); console.log(JSON.parse(sessionStorage.getItem('rotation'))); This `element` in `addElement` is based off of the `data` input. It's bad practice to modify an object given to a function, you should try to work off of copies. In `passToArray`, you can cut out that `if` statement entirely to save a little cognitive overhead. The `if` statement suggested that there was something different about the two branches when the only difference was really how `rotation` was initialized, so you can keep the user from even wondering what the difference is by limiting it to the one line.
This works fine: https://jsbin.com/xuyecixive/edit?js,console
We do tend to have an affinity for bucking the trend 🙃
I actually forgot to add the initialization in the snap I posted, but ”element” is defined there, right after the definition of the array. I solved the bug by removing "var" from: //Initialize the array var rotation = []; and // Get elements from sessionStorage var rotation = JSON.parse(sessionStorage .getItem('rotation')); Thank you for your interest! Have a nice day! :)
Thank you, have a nice day! :) 
It is. Just not for enterprise projects more so.
Um, that's weird, because in the full app it didn't work neither in Firefox nor in Chrome until I removed those ”var” . Thank you for your help and have a nice day! :) 
Only in Seattle...
Thanks for the alternative version. I'd like to read some things on the techniques that you used, so if you could recommend a book or something like that that covers those and other interesting stuff for beginners I'd love to see it! This is my first JS app and I knew absolutely nothing about this language (I learn only C++ in high school) when I started working on it, so my code is far from the best practices now. If you're wondering why I haven't said all of these in my first reply is because I responded from my inbox and I didn't see your edit.'
Thank you for the time you took to write this! You are correct - that's the scope of that array. I have 3 more that contain different proprieties of the elements that are used to generate a chart via ChartJS. Originally, I didn't plan to use that array in this way, but I have problems with an array that contained times that the user inputs - null elements were appearing out of nowhere. I didn't manage to find out what caused this and then I thought of using ”rotation” as an array of objects from which I could extract the time values directly. Can you give me some hints on how would you handle this differently? I'm really curious, but I can't think of any alternative at the moment. 
&gt; GraphQL isn't great for mapping to SQL. Nonsense. Whats the argument?
Oh my bad. Thought I read an article a while ago saying they built it in Angular. 
https://www.youtube.com/watch?v=8NUzNtqu3zQ
Does it whitelist the number you are calling from once you've solved it once ? Because I wouldn't call that person anymore if I had to do that every time. EDIT: Code doesn't seem to whitelist, but it'd be pretty easy to add that feature, if you don't want to infuriate your loved ones.
It is in beta stage. I don't know if that answers your question.
To be honest, this reply spreads false truths. This guy from Telerik probably only (mis)read the docs for 5 minutes and then went on spreading this nonsense. - Vue is much more like React, and much less like Angular - Vue supports render functions and JSX as well (so much for the "sticking point") - JSX is far from "native" JavaScript, so that argument doesn't go to well either Also curious to what kind of modern patterns you are talking about. I would prefer it people arguing for or against Vue/React would actually try to use both before making a case.
I have professional experience with both React and AngularJS. I tried Vue for a little while, and it seemed much more like AngularJS to me than React. It uses attributes for logic, directives, and string evaluation. It also does not (in any way as far as I can tell) leverage functional programming concepts such as pure functions, immutability, or composability. Could you please offer your reasoning behind suggesting that Vue is much more like React than AngularJS? Unless you're suggesting that it's more like React than Angular (as in, Angular 2), in which case I'm not sure I can agree or disagree, but I've always seen Angular (2) as a version of React that decided dynamic string evaluation was the way to do things for some reason.
Use C# instead. Unity's "JavaScript" (aka UnityScript) is some weird bastard language. http://wiki.unity3d.com/index.php/UnityScript_versus_JavaScript
Ember came from Sproutcore, an Apple project. It wouldn't be right to call Ember Apple backed project, but it's part of its history.
Absolutely! SpoutCore influenced the initial version of Ember, and Apple continues to use Ember today. Unfortunately, their corporate policy prevents their developers from open-sourcing any interesting work they might be doing that the rest of the community might benefit from, unlike LinkedIn which has largely driven the advances in server side rendering ([Fastboot](https://github.com/ember-fastboot/ember-cli-fastboot)) over the last few years. 
I don't see npm downloads being a better metric than github stars, quite the opposite actually. According to the chart reactjs is seeing 200k downloads per day, do you really think there are 200k new react projects being started every day? It's much more likely that react simply has much more downloads for other reasons, like an oddity in how builds and updates work. Look at angular for example in comparison, and we know for a fact that angular is still much more popular than react yet its numbers are much closer to vue's.
twitch.tv uses Ember I believe
Yup ended up using maps with a custom priority queue implimentation
As someone getting comfortable writing vanilla JS and understanding fundamentals for programming, should I even start looking at frameworks?
Great point. I did rush the readme and didn't even consider that it would need a bit more explanation. Classic case of being too close to your own product!
Tldr - react
[Test it.](https://www.youtube.com/new)
It has both iirc. Or at least my Enterprise copy does. Also tbh edge isnt that bad. Sure i would rather use chrome or Firefox, but it's could be worse(IE)
Static type checking us the biggest liability and exactly why vue seems more interesting; it doesn't force it.
This was discussed recently: https://www.reddit.com/r/javascript/comments/6bxw6h/simd_was_apparently_dropped_by_tc39/
I switched jobs and stacks from Coldfusion/Ext.js to Rails/Ember about 6 months back. I actually miss Ext.data. Think it was easier to understand, easier to customize, and easier to debug than ember-data. But other than that, yeah, I sympathize. Did they ever get their router working usably? In the 5.0 days I couldn't do anything non-trivial with the Ext router.
Whitelisting is on the list of features to add :) If this was spun out to be a proper service, there'd be a number of cool things that could be added; whitelisting, android/ios app for configuring everything, changing the messages, viewing logs/reporting, etc.
Pseudo-code expressing that you can only access `this` after you call `super()`.
Ember data is, "race conditions as a service." It is not a state management framework, it is a two way binding framework, which is parlance for "mess."
React is JavaScript at its finest. 
Out of curiosity how does Google sheet use eval safely? I can't find any related article so far...
Got it working. Although, I haven't yet figured out how to get socket.io to use the default path on both the client and the server. But anyway... I guess the docs are out of date. Proxying is working for me. I was able to leave HMR as is, so that's really nice. The proxying also allows my BE server and FE server to be nicely independent. I run the server using `forever` and it auto-connects with the client after every restart. Here's the settings I used to get proxy working: let config = Object.assign({}, baseConfig, { entry: [ 'webpack-dev-server/client?http://127.0.0.1:' + defaultSettings.port, 'webpack/hot/only-dev-server', './src/index' ], cache: true, devtool: 'source-map', plugins: [ new webpack.HotModuleReplacementPlugin(), new webpack.NoErrorsPlugin(), new BowerWebpackPlugin({ searchResolveModulesDirectories: false }) ], module: defaultSettings.getDefaultModules(), // devServer, this is the part we care about. devServer: Object.assign(baseConfig.devServer, { proxy: { '/api': { target: `http://localhost:${myServerPort}/api`, secure: false } } }) }); Server code: const server = require('http').createServer() const io = require('socket.io', {transports: ["websocket"]})(server) ... io.on('connection', socket =&gt; { socket.on('/api', listenerFunction) }) server.listen(port) Client code: const socket = require('socket.io-client')('http://localhost:9090') socket.on('connect', () =&gt; { console.log(`Connected. ID: ${socket.id}`) const data = {stuff:'whatever'} const receiver = resp =&gt; { console.log('Server response:') console.log(resp) } socket.emit('/api', data, receiver) }) Hopefully this helps someone else if they have the same problem. If I get the chance, I'll make a generator with this included, and some other personal touches. 
They're both only vaguely similar to Javascript, so it won't matter too much. C++ will teach you more about manual memory management, which isn't used in JavaScript, but I feel it's worth learning in general to help with writing performant code.
This is how npm works and they all play under the same rules. React distributes script tags and npm modules just like vue does. The truth is that vue never really did grow the way people wanted to believe it did and it is plainly evident in the statistics i showed you. Angular &gt; 1, the one that's being deployed on npm under the @angular scope, is also not even close in popularity and widespread use. http://npmcharts.com/compare/react,@angular/core,vue
We use both. The "v = f(d)" paradigm only applies to it in passing, because it inherited createElement as of 2.0. On the outside it still adheres to the older mvc model. The user facing lifecycle is not functional and/or declarative, it is *imperative*, just like Angular is. As an example, the following is functional/declarative in that UI is a function of state (properties), and declaring a function yields a readily re-usable component: const A = () =&gt; &lt;span&gt;im a component&lt;/span&gt; const B = ({ color }) =&gt; &lt;div style={{ color }}&gt;i can use that component: &lt;A /&gt;&lt;/div&gt; &lt;B color="red" /&gt; &gt; Vue + Vuex is equally powerful as React + Redux Vuex doesn't have access to the tools and middlewares that make redux flexible. Redux is framework independent with bindings that reach everywhere. We have the same code for instance running in Angular, Vue, React and React-native, because all logic is contained there. You could use Redux in Vue, though.
What? No Vue?
I'm still using the Polymer version. Works fine though I am using a gaming PC :/
&gt; Systems language doesn't make any sense. wat? 
Cool, thanks. 
Plenty of jobs in the UK for Vue. 
Can't wait fir the next article:"Choosing a front-end framework in 2018"
Wow, thank you so much for this detailed reply! You made some great points that made me realize I can optimize my code. I'm definitely going to revamp some parts after I add some features that are still on my roadmap. 
By "the PHP world" did you mean "me and the other 5 people in the vue chatroom?". I would be surprised if more than 5% of the PHP world has even heard of Vue.js. 
You misunderstood him. He said that React naturally *inherits* types, in both TS and Flow and all tools to come. It doesn't comply to or enforce anything. If a tool validates or transpiles javascript, be it for types, specs, drafts or anything really, it will work with React because React is javascript. Vues structures are neither html nor javascript, it cannot inherit anything and support has to be explicitly built. 
Is there a point to agree/disagree with the person which claims that C++ compiles to bytecode?
You're so far from reality, I'm not sure how you got there. &gt; The term low level language typically refers to machine code like COBOL or Fortran. Java and C++​ are languages that require compilation into byte code. There's a difference. Here's the definition of a low-level language, [from Wikipedia](https://en.wikipedia.org/wiki/Low-level_programming_language): &gt; In computer science, a low-level programming language is a programming language that provides little or no abstraction from a computer's instruction set architecture—commands or functions in the language map closely to processor instructions. Generally this refers to either machine code or assembly language. COBOL was designed for business, not even systems programming. So it is in no way a low-level language, or even close. You can do low-level programming in Fortran, but also in C++. In fact, C++ is probably the most common language after C for this. Java is compiled to byte code, C++ is not. C++ is compiled to machine language. &gt; Java can run on any environment thanks to the JVM. Thats a big deal esp. if you compare it with something like C#. C++ runs on any environment, you just have to target that environment when compiling. *C# is also compiled to byte code, and can be run wherever the interpreter has been compiled, like Java*. &gt; Systems language doesn't make any sense Maybe not to you. [From wikipedia](https://en.wikipedia.org/wiki/System_programming_language), again: &gt; A system programming language usually refers to a programming language used for system programming; such languages are designed for writing system software, which usually requires different development approaches when compared with application software. Have you ever heard of C? C++? Rust? All of them are described as systems languages. Rust's [home page](https://www.rust-lang.org/en-US/) even says, in the first sentence, "Rust is a systems programming language".
Interesting concept and clever hack. I'd love to extend the idea to an Android/iPhone app that does the same in my mobile without extra costs. Also - call centers are annoying even though they are not robots and I think most of their calls would be intercepted by something like that
It didn't feel any slower to me but the Chromecast support is much worse than in the old version. That alone made me opt out.
Edgy
I think it's a little strong to argue Vue adhered to the "old MVC model" for something which is just a templating engine (which translates to a render function anyways, as I pointed out before). You're right that React is more functional than Vue, but I don't think we should rank frameworks based on how functional they are. You're also right that Redux is framework independent, but I wasn't making a case for or against Redux. I was simply stating that the combination React + Redux or Vue + Vuex solve similar problems in a similar way. Ofcourse you can mix things up if you want to.
So,like ember then? Lol
Apple open sources Swift so how do you figure that one?
[This](http://i.imgur.com/sIQc7xI.png) is what it looks like in FF 54 for Windows.
For me, the biggest advantage is the clarity of the documentation and the ease-of-use for getting started (either drop it in a regular web page or use the excellent vue-cli to get a great starter kit). There is so much fragmentation in the React ecosystem, which makes it difficult to get started. I don't care so much for the templating engine or JSX (I'm fine with both).
As a backend developer, I find it difficult to understand why the frontend community seems to have a lot of trouble finding "the right way" to develop frontend applications. I myself am a PHP developer, for which we have two major frameworks (and a few older ones): Symfony and Laravel. Both build upon the MVC concept, with a slightly different approach. Still, MVC is the major cornerstone on which those frameworks are built. Ruby has Rails, Python has Django, Node has Express, Java has a bunch of web frameworks, .NET and C# can be used for web development. In my personal opinion, one language is better to do the job than others, but they are all built on that one cornerstone: MVC. (I'm no expert in all languages, so feel free to correct me if I'm wrong in any of the languages and frameworks listed above). With the frontend community, I have the feeling we're all starting from scratch again. As if the 10, 20, 30 years of web experience of those other languages don't matter anymore. I feel the JavaScript community is trying to solve issues that have already been solved many many years ago. And I don't understand why? Is it because JavaScript is the only language available in browsers? Is it because of performance issues in the browsers? Because of different platforms to build for? Still I can't seem to figure out why the past years have been such a difficult time. Routing is a key part of any web application, views need data, probably from controllers (some call it "state"), you'll need a secure way to fetch and store data from a data source, you'll need a place to write your business logic. So why is the frontend community struggling so hard in finding the right solution? PS: this is a genuine question and not meant to offend anyone. I've really been wondering about this issue for a while now.
I don't agree. React is also suited to entry level devs, you don't have to be experienced. Designers like it.
Ha. Good catch. Upvoted!!!
I actually used the sharing functionality provided by the library to post this link here. Suggestions are well accepted.
Thanks for the heads-up, I didn't know about that. Let's see if that will create a problem.
Something like [this](https://github.com/kern/filepizza) might help.
Yes, I did make a backwards selection. I'd fix it by making the pop over appear below the selected text, if that's possible.
Yeah, it seems a lot of projects use flex funding when they know their idea is luke warm but still want to get free money. It definitely makes me nope out of the project almost immediately. 
Looks like it behaves the same as [this code](http://www.typescriptlang.org/play/index.html#src=let%20t%20%3D%20setInterval\(Timer%2C%205000\)%0D%0Alet%20timercount%20%3D%201%3B%0D%0A%0D%0Aconst%20el%20%3D%20document.createElement\(%22div%22\)%3B%0D%0Ael.id%20%3D%20%22timer%22%3B%0D%0Ael.innerText%20%3D%20%22Please%20Wait%22%3B%0D%0Adocument.body.appendChild\(el\)%3B%0D%0A%0D%0Afunction%20Timer\(\)%20%7B%0D%0A%20%20let%20timerdisplay%20%3D%20timercount%20%2B%201%3B%0D%0A%20%20el.innerHTML%20%3D%20%22Count%3A%20%22%20%2B%20timerdisplay%3B%0D%0A%20%20clearInterval\(t\)%3B%0D%0A%7D) But what you've posted is kind of stupid, don't declare variables and functions using the same name.
I have. I still don't know how to implement a solution for that via wordpress, especially when both servers (the one for wordpress and the express app) are running on localhost, just with different ports. Like, how can I make it so that anyone can post to a route in the api from the express app's frontend?
Lot's of errors there. Not all JS - this will give you something to play with &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script&gt; var Timer = setInterval(Timer, 1000) var timercount = 0; document.getElementById("timer").innerHTML = "Please Wait"; function Timer(){ timercount += 1; document.getElementById("timer").innerHTML = "Count: " + timercount; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id="timer"&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;
Pretty cool. I like the concept of animating routes, but this seems like it would not scale well. Thats a lot of code for these transitions. Also made the routes kinda messy. I wish I remembered the tooling, but I did this in Angular 1.x back when it was the hot commodity and I remember it being a line or two of code. Still, Ill give this a go to feel it out! Thanks for posting.
Aye, looks good! 
It was a genuine LEADING question, with a lot of patronising and misconceptions throw in. The are no answers, because the question is idiotic and based on wrong assumptions, which is what you should have got from reading my answer instead of going butthurt.
That's true, and a relatively new change for Apple. I know a number of people that work there though, and they have said that they're not allowed to do OSS work. Swift is an exception as a project controlled by Apple, but if someone on a front-end team had come up with some really useful Ember addon, for example, they're not allowed to release it to the community. It's a shame IMO, because with all the impressive engineers that work there, I'm sure they've developed tools that other people could benefit from too. 
Yea I used this as a template really I'll usually just use synonyms when I want to do something like this.
This is something I threw down while bored, I know how dumb it looks with a head tag below body. Trust me, I could do better. What happened was I noticed the script tried the access the &lt;P&gt; before it was loading and I didn't feel like copy pasting another &lt;script&gt; below the &lt;P&gt; to make it start properly
No problem, you tried to help I realize the flaws were major in my code. It's not your fault. I tried fixing [it](https://jsfiddle.net/zrozkn41/) but made something else not load properly, but that's just how programming works.
From what I've seen from this code, It freezes and there is a thin line between NaN &amp; that returning variable, but after a quick look at the code I've edited locally on my computer it is working properly. Thanks for you trying to help although.
Wow that text to speech is so creepy.
the `clearInterval` stops the interval, I think that was a misunderstanding on my part. Then you have an issue here: let timerdisplay = timercount + 1; let timercount = timerdisplay; Since you already declared `timercount` outside of the function, I think the browser is getting confused seeing timercount being used and re-declared inside the Timer function Basically what you needed was to have the timercount from outside the Timer function be updated (so either `timercount += 1` or `timercount++`)
Thank you. The other suggestion here (slick) is really what I need. Appreciate the suggestion though.
Misko showed me the code in Sept 2014. They'd been working on it for 2 - 3 months. The problem for AngularJS inside Google (in my opinion) was that GWT was the high profile tech for UI creation at the time inside Google. Well **definitely** at the time of AngularJS's creation earlier in 2009, and up to Misko's [first blog posting on it](http://misko.hevery.com/2009/09/28/hello-world-angular-is-here/). AngularJS was more low key that year, and 2010 (despite the huge promise). Backbone and others got the community buzzing. By the time the the backwards incompatible v2 break was mooted, Polymer was buzzing inside Google, and Angular needed to match the features (as well as react to React, etc). See if you can redo https://paulhammant.com/2013/01/18/client-side-mvc-roundup/ for the current timeframe, Taras. Might be harder now as the CLI era means we find it harder to easily count the actual app's LOC count.
Does it look like [this](http://i.imgur.com/v8OuNWp.png)? Then it's already on polymer and shipped.
Hi /u/colorfulpilgrim, please keep it civil.
Best experience I've ever had with a Web framework
Yeah they dropped SIMD because they think a better place for it is in WASM.
This is actually one of my most detested features - I'm a user that selects text as I read it, and it's incredibly distracting to have these things popping up everywhere. I actually go out of my way to create Stylish sheets that purposely target those elements and make them display:none because they are so obnoxious to me. I'm sure some people may find it useful, but I just honestly cannot stand them :-(
Yes, but what specific code would I use to rotate the object toward the mouse?
Thanks for the fix, merged!
Strange, never had any issue. We're using socketio, i've had dozens of sockets run concurrently. Backend is local for testing, online in production. Webpack-dev-server for testing. There's nothing special i've ever had to do: module.exports = env =&gt; { return { entry: [ 'react-hot-loader/patch', 'webpack-dev-server/client?http://localhost:8080', 'webpack/hot/only-dev-server', 'index.js', ], output: { filename: 'dist/bundle.js', path: path.resolve('./'), }, module: { rules: [ { test: /\.jsx?$/, use: { loader: 'babel-loader', options: { presets: ['env', 'react'], plugins: ['react-hot-loader/babel'], }, }, }, ], }, plugins: [new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin()], devServer: { hot: true, contentBase: path.resolve('./'), stats: 'errors-only', historyApiFallback: true }, } } You mentioned HMR, i've left in the pieces that enable it, this is with react-hot-loader 3.0.0-beta.7 import { AppContainer } from 'react-hot-loader' import App from './views/App' const load = () =&gt; render(&lt;AppContainer&gt;&lt;App/&gt;&lt;AppContainer&gt;, target) load() module.hot &amp;&amp; module.hot.accept('./views/App', () =&gt; load())
Truly the villain of the book.
The Tower of Babel isn't pronounced "babble" though
Nope. Somehow I visit youtube.com/new but I'm redirected to the old version. No idea.
Snowcrash for me
It's not?
It's ironic that people are arguing over how to pronounce Babel.
This is super cool! * Snazzy transitions * Loading screen animation * Single URL for all pages * Heavy weight library Still needs a custom scroll bar... I think these sites could be sped up considerably if we could compile them into a binary and use a plugin to run them. 
You can use: import get from 'lodah/get' And that won't include the entire core, only the bits to allow the imported method to function. Rambda is nice enough, but I feel like Lodash' interface is far more user friendly - for example, lodash collection methods always pass through the item, index and collection to work with. Purely opinion though. Regarding the map to filter example, you can always use the sequencing lodash functions like chain. For now, I will continue to use lodash where it makes sense, it's powerful, quick and the team understands it. 
Yep. 
In your ES6 example, you should remove the () from your arrow functions since you don’t need them. Simply just use .map(team =&gt; { ...team, ...etc. }) Moving onto your other comment, you can import just import lodash functionality separately and just reassign to an underscore instead of importing _ from lodash.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [tc39/proposals/.../**README.md** (master → ae5a458)](https://github.com/tc39/proposals/blob/ae5a458fe3da311a55b905febafb151e0756bd86/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dje973x.)^.
Yes they do, because we changed the spelling.
It's your lucky day: http://eslint.org/blog/2017/06/eslint-v4.1.0-released
Yes it does. There is http://ramdajs.com/docs/#path, which is almost identical.
Thank you guys for all the comments. I've update the article with your suggestions and retracted my statement about the bloat.
I never considered pronouncing it differently. I was expecting to learn that I'm also wrong.
You clearly don't understand anything about it, people wanted to do bad things, God confused them to avoid a tyranny reign from Nemrod, who was a violent and evil king. 
Do you have a source on 1? If so I'm going to use it alongside the fact that it was called soccer before football
Hope you get to explore some more options. They also have lenses, which are a really interesting way to work with deeply nested objects. They allow you to update and get nested values in a clean way.
UK, religious upbringing here, we know it as the tower of "bayble". I've never heard anyone call it the tower of babble.
I feel your pain, man. That's why I did everything I could to make it customizable, so developers can make it as little annoying as possible. As a matter of fact, I think I'l provide alternative style sheets and scripts to to show could be done in a more acceptable way.
You are very welcome. Keep us updated with whatever you choose, any modern library or framework is a solid choice. It's a great time to be a front-end developer.
Idk, maybe he could have gotten rid of him instead? 
I think it's perfectly fair to reject a name if the author's grasp of how letters work can be questioned. Not saying that's the case here, I'll leave the pronunciation arguments to the people already doing it, but if an author decides "fewujbwef" is pronounced "bob", fuck that author. Obviously that's an exaggerated example, but the point is that I disagree with an author's preference having any overriding authority.
Lodash provides lazy evaluation. _(largeArray).map(/* some iteratee */).filter(/* other iteratee */).value() is way faster than the native .map().filter() because the chains are composed. You only iterate the array once instead of multiple times like the native chaining does. You also misspelled improve twice. You wrote imporove.
Ctrl-F "exampel"
PouchDB might cut it. Though you'll need to advertise the "host" IP somehow. 
It does when his pronunciation is perfectly valid :) Again, this is a name. If someone said their name was Anthony, pronounced it ant-ohnee, and you started adding the h in because it's what you're comfortable with that would be wrong. He could say Babel is pronounced "squid" and it would be correct. It would be idiotic, but correct.
This isn't like GIF (which the creator says it's pronounced like jiff, but people argue that his opinion doesn't count because they think it should be a hard G like Gift.) The difference is that babel isn't an acronym or abbreviation or any made up word. Babel is an actual word that has been around for thousands of years and has had multiple pronunciations based on which culture you come from. Some will pronounce it Bay-bel, some Bah-bel, and some Baw-bel (bauble) and still other baw-Bel. I personally pronounce it bay-bel like label and Abel, that's just me. Interestingly I may switch pronunciations based on who I'm talking with and the context (i.e. talking to a friend about babel fish (bay-bel) versus talking to someone about the Tower of Babel (babble)). American English is a screwed up mishmash of everyone else's languages and rules combined with a certain amount of laziness, go figure. Frankly, with an already well-established word, it seems nonsensical to argue pronunciation. Pick the norm for you and most people know what you're talking about. Otherwise, you're like that pretentious girl in high school who had been Laura (Lor-uh) up until 9th grade and suddenly wanted every to start pronouncing her name Lar-ruh. If BabelJS's creator gets butt-hurt over the pronunciation and wants a certain pronunciation he can always use a different spelling to make it clear (Babble). 
&gt; He could say Babel is pronounced "squid" And we'd be free to ignore it. I don't pronounce PNG "ping" either. It's silly.
For the same reason a lot of people still pronounce Linux as "line-ex", "line-ucks", or variations of "lean-ex/ucks/icks" even though Linus Torvalds said years ago that it's "Lynn-icks". The debate is still very much ongoing regardless.
I just recently learned that Avocado doesn't have an L in it. Luckily, pronouncing "Alvocado" doesn't sound much different than "Avocado" so no one ever noticed.
**Google Apps Script** Google Apps Script is a scripting language for light-weight application development in the Google Apps platform. It is based on JavaScript 1.6 with some portions of 1.7 and 1.8 and provides subset of ECMAScript 5 API, however instead of running on the client, it gets executed in the Google Cloud. According to Google, Google Apps Script "provides easy ways to automate tasks across Google products and third party services." Apps Script is also the tool that powers the add-ons for Google Docs, Sheets &amp; Forms. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/javascript/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.23
Why _should_ he remove them? Some people like to keep them for consistency, the same way you keep braces for if blocks even if they are only one line
I call it Ubuntu it Centos.
Baggle
Because "babel" is a biblical/HGTTG word, and "jif" is dumb. 
After all, it's always worked well for modern dictatorships ...wait
One of your colonies on the other side of the world here, I usually hear it as "babble".
Emerging anything's (technologies, economies etc) have higher growth rates than established anythings.
socket.io has various fallbacks if WebSockets aren't working. In your case it might be doing this in dev and then not in production.
Which means you get it. :) 
Looks pretty slick. Kind of amazed that someone would spend the time to recreate all these components and animations...! Anyway nice work.
It's written out in the picture
That's really interesting. Thanks. I'll look at webAssembly.
Wow dude, great work! Great code!
It was named after the babel fish. It was pronounced rhyming with table in the [1981 TV series](https://www.youtube.com/watch?v=fmpP73-SHPQ), [the 2005 film](https://www.youtube.com/watch?v=YWqHkYtREAE) and in the original BBC radio series. It makes no sense to pronounce it as "babble". Edit: Fixed link to the film version.
Thanks for the constructive reply! Very helpful!
great article 👍🏽
Like this, which is what it was named after https://www.youtube.com/watch?v=fmpP73-SHPQ
Video linked by /u/tempfolder: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Community Season 1 Clip - "Bagel"](https://youtu.be/NEZGYpd7cPg)|SonyPicturesDVD|2010-09-14|0:01:05|466+ (98%)|158,513 &gt; Look for Community Season 1 on DVD September 21st. Smooth... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/tempfolder ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=djemb3m\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
Video linked by /u/lachlanhunt: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Hitchhiker's Guide (Original) Babel Fish](https://youtube.com/watch?v=fmpP73-SHPQ)|Excelsior10000|2011-03-11|0:01:57|221+ (96%)|37,856 --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/lachlanhunt ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=djemb65\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
But some people pronounce the biblical reference differently. http://www.dictionary.com/browse/babel?r=75&amp;src=ref&amp;ch=dic For instance, Dictionary.com says "bey-buhl" is the most common pronunciation of Babel^2 which is the Biblical reference. It's also pronounced that way in HHGG, which is probably what the name is also a reference to: https://www.youtube.com/watch?v=fmpP73-SHPQ
It is estimated that using Angular means writing 80%-90% less code than if you use native Javascript or jQuery. That's why all non-trivial apps use a framework.
&gt; Nowadays making applications in vanilla js is comparable to programming native applications in assembly. Nonsense. Plain JavaScript is plenty high level enough. It is a bit nicer and less verbose with a library for querying though e.g. jQuery. Plenty of sites have been made and function perfectly fine without a framework.
This is hilarious, and ironic. Also, it happens any time anyone uses the word. http://onlineathens.com/stories/022307/living_20070223028.shtml
0.19 % of UK IT job ads mention "Vue". AngularJS is mentioned in 8.36%; React 3.48%. Knockout, Backbone and Ember are all more needed skills than Vue. https://www.itjobswatch.co.uk/default.aspx?page=2&amp;sortby=0&amp;orderby=0&amp;q=&amp;id=1300&amp;lid=2618 
I've heard both many times (and the except North America bit is completely wrong)
German here and I'm very convinced, that it's pronounced either babbel or babbel with a long "A". Babbeln is actually a German regional predicate, see here http://www.duden.de/rechtschreibung/babbeln It has like most South-German regional words French influence.
Jesus, my quad core mobile slows to a crawl and turns into a handwarmer trying to render this website.
Minnesotans say "bag-el"
Same, my phone cannot handle this site. 
That's a nice idea and will make for an interesting effect. The only problem is that bluring an image is very expensive in terms of performance. Every time a scroll event fires, the whole image has to be blurred again. You won't end up with a smooth animation, even on devices with high specs. Now, there are a few ways to get around this issue. First, you probably want to use requestAnimationFrame for that. This is basically a way to let the browser decide when to draw a new frame on the screen. If you were to do all calculations everytime a scroll event fires, you would blur the image constantly, even if the browser is still blurring the image from the previous event. With requestAnimationFrame, the browser will finish the blurring and just then do the next one. This ensures that you get the best possible frame rate, without making the page unusable. Secondly, instead of changing the radius of the blur during scroll, you could have two images on top of each other: One blurred with the maximum radius and one not blurred at all, with an opacity of 0. Now instead of animating the blur radius, you animate the opacity from 0 to 1 of the "normal" image. Of course this will result in a different effect, but you can achieve smooth scrolling performance with it because opacity is quite easier on the GPU. Another way would be to completely outsource all blurring to the GPU with the help of a 3D canvas and a GLSL shader – but that's rather complicated. Alright, if you still want to go with the CSS blur filter and animate the blur radius when scrolling, here's how you do it. I am on mobile and have to do it OTOH, so see the code more like pseudocode. :) var SCROLL_DISTANCE = 300; var MAX_BLUR = 30; function blurValue(scrollTop) { if (scrollTop &lt;= SCROLL_DISTANCE) { var offset = SCROLL_DISTANCE - scrollTop; var blur = (offset / SCROLL_DISTANCE) * MAX_BLUR; return blur; } } This function will return the blur radius you need relative to the scroll position. This of yourse only works if you start blurring right away at scrollTop 0. Now you only need to feed this value to the element you want to blur. To get the "backwards" value you can just subtract the returned value from the above function from MAX_BLUR. You probably _really_ want to put this in requestAnimationFrame ;) See here for a nice example: https://gist.github.com/Warry/4254579
I cannot say with 100% certainty, but I would bet that it was not named after the Babel fish, but the Tower of Babel.
&gt; uses it in map(), a ternary, etc. Same applies to Vue, only that due to your template being a string it doesn't know javascript so it's emulated, either by markup code or a ternary look-a-like. &lt;div v-bind:class="[isActive ? activeClass : '', errorClass]"&gt; &lt;li v-for="todo in todos" v-if="!todo.isComplete &amp;&amp; condition1 || condition2"&gt; The terminology has shifted over the years. JQuery and dom calls were imperative in the past and Angular was considered declarative. Nowadays the component you functionally declare *exists*, while in a template it does not exist, only in an abstract space and as a key that has to be *imperatively wired in*. No place you go to will tell you react is imperative. The rest is semantics, i am using the terms as most contemporary sources use them. The difference is more mvc vs fp anyway. More about it, [here](http://blog.wolksoftware.com/the-rise-of-functional-programming-and-the-death-of-angularjs).
Who in the fuck pronounces it with am "l"?
Seems too complicated to be honest. Just like that [other post](https://www.reddit.com/r/javascript/comments/6icr7w/hideable_react_component_using_hoc/) where they used whole library with ugly user-code to hide elements. Plain old simple bit flags are way easier and cleaner for me: // flags.js export const SHOULD_RENDER_TITLE = 0b1 export const SHOULD_RENDER_SUB_TITLE = 0b10 export const SHOULD_RENDER_BODY = 0b100 // main.js import * from 'flags' const FLAG = SHOULD_RENDER_TITLE | SHOULD_RENDER_BODY; // 0b101 const card = ( &lt;container&gt; {FLAG &amp; SHOULD_RENDER_BODY ? &lt;h1&gt;Lorem ipsum&lt;/h1&gt; : null} {FLAG &amp; SHOULD_RENDER_SUB_TITLE ? &lt;h2&gt;sit dot amet&lt;/h2? : null} {FLAG &amp; SHOULD_RENDER_BODY ? &lt;p&gt;Hello world, I ♥ bacon.&lt;/p&gt; : null} &lt;/container&gt; ); /* &lt;container&gt; &lt;h1&gt;Lorem ipsum&lt;/h1&gt; &lt;p&gt;Hello world, I ♥ bacon.&lt;/p&gt; &lt;/container&gt; */ 
 var pixs = window.innerHeight-$(document).scrollTop()
I've made a small sandbox to test `animated`, you might wanna play around: https://www.webpackbin.com/bins/-KfKys3S2mgEH9UsE8GL While this example would be trivial in css, animated is pretty powerful, it makes things possible that aren't easily done in css. And it's cross platform of course. If you have ever worked with animations in react-native, it's quite something.
Or &amp;&amp;, saves the tail &lt;container&gt; {FLAG &amp; SHOULD_RENDER_BODY &amp;&amp; &lt;h1&gt;Lorem ipsum&lt;/h1&gt;} {FLAG &amp; SHOULD_RENDER_SUB_TITLE &amp;&amp; &lt;h2&gt;sit dot amet&lt;/h2&gt;} {FLAG &amp; SHOULD_RENDER_BODY &amp;&amp; &lt;p&gt;Hello world, I ♥ bacon.&lt;/p&gt;} &lt;/container&gt;
Baybell?
Do you have a link?
It wasn't my code to begin with, but, I'll go with that: was struggling to avoid `.innerText` more than anything else at a quick glance.
UK Jewish upbringing here - you'd refer to it as bayble in English but bah-bel (like babble) in Hebrew
If JavaScript is so expressive, then what does this snippet do: `['10', '10', '10'].map(parseInt)` 
dude i'm tired but so happy... i'm trying this tomorrow... you guys are all so fucking amazing... i mean it sounds confusing but ill figure it out tomorrow... thank you so much..... You're so kind too!!!
Use wasm
http://onlineathens.com/stories/022307/living_20070223028.shtml
Oh no
Many developers just directly use the drivers (refer [this comment](https://www.reddit.com/r/javascript/comments/6jk1do/how_are_nodejs_enterprise_applications_connecting/djet448/)). And many ones *do* use sequelize or knex too. Depending on the project I may choose to use knex or directly the pg or mysql driver. You **don't** need to use another non-node service, calling a db from node is very easy and reasonably efficient, and now that we have async/await it's also convenient and clear. 
Slow? It is a Microsoft's UWP feature
NodeJS Enterprisey applications? They are just NodeJS apps or they are different in term of requirements for database connections?
Three guesses where the verb "babbel" comes from... the city in the Old Testament.
["Teh-Ah-Tim-Eh"](https://wiki.lspace.org/mediawiki/Jonathan_Teatime) Also: [Mrs Bouquet](https://en.wikipedia.org/wiki/Keeping_Up_Appearances)
I just assumed that was the British accent.
Yes, but it was never called just "football" for ages. It was association football, then soccer, then football
This is kin to saying that instead of React Router we should just use &lt;div&gt; {location.pathname.match('/r/javascript') !== null ? &lt;div&gt;JavaScript Page&lt;/div&gt; : null} {location.pathname.match('/r/ruby') !== null ? &lt;div&gt;Ruby Page&lt;/div&gt; : null} &lt;/div&gt; Obviously the example in the documentation is trivial, but the story changes when you're dealing a tree of hundreds of components.
&gt; "How can Java take over itself? Isn't Node.js written in Java?" no, silly, it lets you write sever-side Java
Here's an example of how to clean up the route codes a bit; https://gist.github.com/mhaagens/93d62b9fa812e7c898e55a2a5f8a3569
Exactly
Yeah, just look at FedEx. They aren't re-factoring that shit anytime soon.
While Java is rather verbose, it does offer great tooling and it works well for large projects written by large teams. The same isn't true for JavaScript. That's why there are languages like TypeScript which try to fix that. It's true that you can write almost anything in JS these days, but that doesn't mean you should.
I will be messaging you on [**2018-06-26 12:43:04 UTC**](http://www.wolframalpha.com/input/?i=2018-06-26 12:43:04 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/javascript/comments/6jjtgx/mikeal_rogers_nodejs_will_overtake_java_within_a/djexybr) [**2 OTHERS CLICKED THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/javascript/comments/6jjtgx/mikeal_rogers_nodejs_will_overtake_java_within_a/djexybr]%0A%0ARemindMe! One Year ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! djexynu) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
And conditional rendering is just true/false render.
You want to know the secret? Go slow to go fast. Make the smallest change that gets you a little bit closer, then test it. TDD helps here. If it works, commit it. If the change doesn't work, you know exactly where the problem is. The result? Tiny bugs that are trivial to fix and perpetually improving code.
https://www.javapoly.com/
&gt;I don't think within a year but java is slowly entering the cemetery. In fact today most java devs are maintaining old code (new projects very rarely start with java) so it's a powerful sign that it's happening. Sorry, but I have to call BS on that one. I work in a medium-to-large dev company, and we never run out of new developments in Java. Java 6 IS dying, as everyone is rushing to upgrade to 8. There's REST webservices, message queues, large systems which access Oracle databases with over 50 tables, and you think we're leaving all that reliability over a fad? Dream on.
&gt; My experience with enterprise java projects with 100+ professional developers is do not go here. And you think this would be any better with JavaScript where there is no compiler which checks if things do at least theoretically fit together?
/s was supposed to imply sarcasm.
Where do these numbers come from?
ehem, Kotlin...
**Here's a sneak peek of [/r/shittyprogramming](https://np.reddit.com/r/shittyprogramming) using the [top posts](https://np.reddit.com/r/shittyprogramming/top/?sort=top&amp;t=year) of the year!** \#1: [Pokemon Go just lost 10 million users. Should I switch to Pokemon Rust or Pokemon Node?](https://np.reddit.com/r/shittyprogramming/comments/4z8lls/pokemon_go_just_lost_10_million_users_should_i/) \#2: [If JavaScript is garbage collected ,why does it still exist?](https://np.reddit.com/r/shittyprogramming/comments/5q3nhk/if_javascript_is_garbage_collected_why_does_it/) \#3: [Best way to branch conditionally](https://i.reddituploads.com/0d7e47e054e543cfb5fe93d8c49d1db7?fit=max&amp;h=1536&amp;w=1536&amp;s=21b77374eafd613e929d6b80c295cc8d) | [25 comments](https://np.reddit.com/r/shittyprogramming/comments/5ucc4z/best_way_to_branch_conditionally/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
KEK
Returns an array of numbers, and because the radix wasn't specified it's not entirely certain that the values will be 10. And then the array is garbage collected. But, I don't understand why you seem to think I'm arguing that js is "so expressive". I don't think I said or implied that.
Aguacate
TL;DR - use `babel-preset-env` - `yarn add regenerator` or `npm install regenerator` - add **node_modules/regenerator-runtime/runtime.js** (10.7kb minified) into your bundle
Authorial intent vs [reader response](https://en.wikipedia.org/wiki/Reader-response_criticism)?
&gt; They never use a persistent session object (a few ways to handle this in our project) to hold those values and validate against them server side. This leads to bunk validations that can be spoofed by using good data then manipulating those same values in the console before submitting. This is also a symptom of the fact that security is not a required subject. If you don't know what can happen when you don't validate your input correctly, you can't know why it's bad to do what you described. I see this so often. I go to an intern that is happy that he finished something, I give some bad data and poof! blue screen (I'm talking here about kernel development, but the mindset for a CS grad is rarely different when it comes to security - they don't even know that security or defensive coding is a thing). 
&gt; no compiling means almost instant feedback on what your code does. Oh, give it a break. It's 2017, if you're a beginner your code will compile in under a second, you're not compiling the entire Linux kernel, you're compiling some console application. &gt; Console.log is additionally super helpful for seeing what your variables do etc. So is printf. 
Can anyone help to explain those two lines code?I have a trouble understanding them.Thanks. let f = new Function(...keys, `return eval("${val.substr(1)}")`) return f(...keys.map(key =&gt; ({valueOf: _ =&gt; valueOf(key)}))).valueOf() 
I pronounced it "Bahbelh" (Basically in German) because the word exists in my mother tongue as well. It's a bit weird for me now, because now I'm torn between saying the correct thing and how I pronounced it for years and I hate that.
Yuck
Fun fact: Async/await is already natively supported by Firefox, Chrome, and Edge.
Go home Mikeal, you're drunk.