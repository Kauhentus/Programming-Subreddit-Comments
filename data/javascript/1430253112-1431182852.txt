These are pretty much the exact conclusions I came to going through my first flux implementation too. I also found it weird that one of the most complicated customizations in the Todo app -- the handleViewAction in the dispatcher -- is also the least necessary. Personally I'd much rather see an implementation that uses more store events than simply their `StoreConstants.CHANGE` for everything; maybe a `StoreConstants.SAVE` to indicate that it's persisted the state of your store to its backends. I really don't know as I've never used more than just CHANGE and have never seen an example that does things differently. Apart from shimming Object.assign instead of using object-assign from npm (as it's finalized in the es6 now), and building my constants like `ActionTypes: (function() { keys = {}; ['FOO', 'BAR'].forEach(function(key) { keys[key] = key; }); return keys; })()` instead of using `keyMirror`, mainly because I have many actions and writing out `: null` so many times felt silly, I ended up doing things the same way as in the article.
It's the only templating system I can stand. I fully expected to hate it and grew to love it. Suddenly html is easy to read and almost fun to compose. 
visualizations definitely coming :) What do you mean by "interlink build steps"?
Jeez, people... I might be able to do it for you, OP. PM me the requirements and I'll let you know if I can pull it off.
Sounds great! I'd love it to support other task runners. Like, npm scripts. =)
You seem very confident that an Angular 1.x application will be straightforward to map directly into something that functions identically under an Angular 2.x runtime; perhaps we can trust you to write that bridge?
Great! &gt; What do you mean by "interlink build steps"? I'd like to be able to use compile-to-js languages other than babel too. That normally means that I'll have a gulp or grunt build process run after my code changes, then node runs the output of the build process. I figure since you've got babel already working this might not be a difficult change. Are there any features planned which will make async suit this environment better? The babel async (es7) support might be one option. Making sure it works with something fibers based (like synchronize.js) might be another option.
yall hatin
And [This](https://codefights.com/home) so you can practice a bit ^ ^ 
Backbone's "extend()" function is a decent simulation of your more typical OO-like classes. This particular chunk of code appears to be two functions from a View class definition. "onClickToggle" is presumably a handler for a jQuery DOM click event, and "render" is the standard function that should be overridden and called to create and/or update the view's HTML. This particular render function is actually mostly just a couple of jQuery calls. Really, Backbone itself is just a few fairly small conventions and abstractions. Events maps strings to callback functions, Model stores values and triggers events when a value is different, Collection stores multiple model instances, and View adds some declarative ways to organize DOM event handlers and create chunks of HTML. Can you give some more details on specific concepts or pieces of code you're having trouble with?
WTF? God damn moron. This checks if a # is 2 or odd (except for 3!)...
FYI browser consoles define $ and $$ for you as shortcuts for document.querySelector and document.querySelectorAll respectively.
Thanks man! I will definitely consider it. 
Start by writing a function that you can call directly from the console to perform the update. After that works, you can write the event handler(s) that perform the change, and also know that the "core logic" works without being tied to the event handler. Are you working with plain JavaScript, or a library like jQuery? Also, you are misusing the `type` attribute on the buttons. Type is `submit`, `reset`, or `button`. [MDN Reference](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button) Would you be better served by a series of radio buttons and a single "submit" button? 
Thanks, I was looking for something like this 
Libraries like flummox (https://github.com/acdlite/flummox/) have done a great job of building the correct amount of abstraction to support a flux architecture. I'm still pretty surprised to see people blindly cranking out ridiculous looking 200 line switch statements and files full of constants when those are really details that should be abstracted over by a well thought out library.
No offense but this is braindead simple. You're going to have to get off your ass and try learning javascript. No one's going to spoon feed you. You Ruby developers don't want to leave the confines of your language, hence stupid shit like Volt.
Maybe I am wrong but I think the word you are looking for is scheme
Don't rely on setTimeout. Browsers will not respect timers running in an inactive tab. Make sure you only queue a slide change after a slide has transitioned. If you blindly queue every 3 seconds your code will fail.
This is exactly what you want, python and flask. Enjoy friend. https://github.com/DavidAwad/Simple-Flask-App
With the growing avarage bandwidth of users, the library byte size is getting less important with the day.
One suggestion for templating is something like [handlebars](http://handlebarsjs.com/). It fits your header/footer case and you already know Javascript. But Jekyll is really the best option for your case, if you still want to serve static pages (it reads your Markdown and builds the HTML for you - then you serve this HTML as if you had written it by hand). By "static pages" I mean pages that don't change unless you upload the HTML/JS/CSS again, the opposite being dynamic pages. Anyway, if you need to serve dynamic content (specially content that the user can change), you need a database. Otherwise you don't need it. Or PHP for that matter (PHP is sometimes used for static pages, but this isn't really typical). (a side note: I'm not sure that learning PHP and using it in a new project is the best idea, well not in 2015, since we have better options now)
Not to mention, iirc the runtime performance of Zepto is worse.
does your server respond with a proper Content-Size?
assuming you are not gzipping your data: If you are sending a file: header("Content-Length: " . filesize($path_to_file)); or if you are returning JSON or other text, you can just put your output into a variable and then do: header("Content-Length: " . strlen($output)); echo $output; note that the content-length header is in bytes, so depending on the encoding you may have to apply some mathemagic.
What is your use case? 
Yeah, well I have a gulp watch running constantly but I guess it can be too much on large projects. Forcing tests before commits is a great idea. :) &gt;ps. your username gave me a lolz I'm quite a gentleman. :D
Yes - it's an internal system so we never really bothered. I'm just wondering why people are *still* going against ng-repeat when most use cases will be like 10-30 items at a time. And very likely paginated if larger. I mean, if you're building a system with thousands of visible, interactive table rows, you'll probably already be testing the performance of potential frameworks anyway. It's not a normal use case for most people.
1 tip to get better Angular performance 1. Stop using Angular.
How would an automatic redeploy tool like nodemon work in this setup?
It isn't, but there are far fewer edge-cases handled by Zepto browser-compatibility wise
I did because the java I had was only disabling one selection at time, I found something much simpler that can disable multiple, but it apparently only works after they are selected so now I just need to figure out how to get them disabled on load if they are already selected in another row. I'll definitely look into your suggestion if I'm not able to get this going in the near future.
Make sure to have a local fallback, even the big CDNs sometimes fail &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt;window.jQuery || document.write('&lt;script src="js/vendor/jquery-1.11.2.min.js"&gt;&lt;\/script&gt;')&lt;/script&gt;
I've been trying to learn how to do everything that I use jQuery for in pure JavaScript. It's nice understanding how jQuery actually works, and has given me a far better platform to start learning node.js. 
document.write completely blocks the browser engine from further parsing the page. Don't do it unless there's no alternative.
As it turns out I found: https://github.com/azproduction/autopolyfiller Which does almost exactly what I envisioned. Including letting you specify what browsers to shim via grunt/gulp/cli/etc.
You don't need to use a database with php, but it supports most database engines if you do want to use one. I only suggest it because its probably the shortest and easiest to learn path from writing flat html to doing some simple interactive pages and to give your project modularity by including headers and footers and other things. That being said, in 2015 you get down votes for suggesting php because its not cool and for someone who is learning it may encourage bad patterns. However I think its good to learn a server rendered way of making web pages before learning a full stack framework or a client side framework. Personally these days for web apps I use [React](https://facebook.github.io/react/) &amp; flux to write my client side code and [sailsjs](http://sailsjs.org) to write a restful json api for storing data on the server. I am huge fan of this stack, but there are a lot of concepts to understand and tools to learn (MVC, ORM,grunt, browserify, express etc) to have it be effective.
`var div = document.createElement("div");` `document.body.appendChild(div);` This might not be exactly what you're looking for; as there are a couple ways of doing this. But there's hundreds of answers on SO to answer this!
Thanks, I was able to get this to work before; however, I didn't put in additional detail: how can I have the div appear where the &lt;script&gt; is being called (instead of appending it at the end of the body)?
I don't know if you can appendChild to the script tag; but you can select any element by id and append the div to that. Might be able to point you a little further if I can see a snippt of what you're trying to accomplish 
If you replace coffeescript with es6/7 in the title then I'm all for it.
edit: please see /u/Magnusson 's replies for some clarifications. I recommend Javascript The Good Parts. And also just working on a better understanding of programming, particularly at the theory level. I think you will be fine once you hit the point where you kind of just "get it". I've found that you often need to do a lot of experimentation with javascript. Open chrome and the chrome developer tools. Playing around with the console in the developer tools will allow you to test things and really get a feel for what to expect. "this" in backbone is the same as "this" in any javascript. The other things in your tutorial seem to assuming an understanding of jquery and the dom. In backbone, a view can have an "el" which is the view's element. The view's element is basically a representation of what the view is, but it is not the actual rendered dom element. Say you had a backbone view that was just a "div". That would be the most basic backbone view. In a backbone view you can provide a value for the view's "tagname". You provide this as you are instantiating the view, and/or your view's definition. The tagname is always defaulted to "div". That means that when you instantiate your basic view, it will essentially be able to create this: &lt;div&gt;&lt;/div&gt; You can use other tagnames and your backbone view with come out accordingly. If you refer to your view's "el" aka "element", then you are referring to the non-rendered view. A element can basically come in two forms. el: is the non-rendered element. It's like the idea, or plan, for the view. It doesn't actually exist in the page. You can add things to it, do things with it, etc. But it isn't the same as... $el: This is the rendered view. So when you refer to this.$el then you are referring to the actual dom element in your page that was made by your view. Say I had a backbone view. First you would have had to define it, typically. Defining a view is done by extending backbone's view. myThing = Backbone.View.extend({ ... Then you instantiate your view. var hello = new myThing(); Now you have a view instantiated. Now you could use jquery to append your view into the page somewhere. $('#someDiv').append(hello.$el); Once your view is added to the page, then the changes that happen to that page element are based usually on the code of your view. The main thing with backbone views is that they are usually tied to updating whenever models/collections are updated. Typically your goal is to have models that are being updated based on certain things: some function, user input/manipulation to a control, or a call is made to your server to fetch newer model data. Backbone's strength largely comes from its listeners. You bind a listener of a view to hear changes made on a model or collection of models. You can tell a backbone view to render (or call any function) whenever a listener event is fired. One typical use. You load a backbone view and tell it to listen to changes on a collection. That collection contains models of different types of cats (name, size, color). Your backbone view represents a "ul" or un-ordered list. You basically want your backbone view to render an html un-ordered list that contains a row for each cat. So in this example, you would have your view listen to changes on your cat collection. It might start as an empty collection. So you use backbones collection.fetch functionality to fetch from your server that contains a restful endpoint to /cats . So your backbone collection has a url of "yoursite.com/cats" and you ask that backbone collection to fetch. catCollection.fetch(); Now your collection makes a get request to the cats URL and in return it is loaded with all the cat models from your cat database. Your backbone view is listening to the collection and notices that it just changed. i.e. the collection went from empty, to containing 5 cat models. Your backbone view was cleverly designed, by you, to reference that collection. For each model in the collection, it renders an "li" or list item and adds it your "ul". Your view's render function should essentially contain this "code". empty the list (just in case it already has stuff in it) add a list item for every cat model in the collection Now you can see that based on that simple routine, your view will always stay in sync with the collection that it listens to. I hope this helps explain one of the main ideas behind backbone. The rest is going to come from understanding javascript, jquery, server requests, restful backends, the dom, etc. 
If you are having trouble with understanding `this`, then use `console.log(this)` statements to see what this `this` is of a particular function. In javascript, the caller of a function can specify what the `this` is of any function.
http://youmightnotneedjquery.com/. This really isn't good advice anymore. For web apps it's not a big deal, but jquery is a performance killer for apps like those mimicking phone apps. It's major reason for being used, browser incompatibility is now a soon to be defunct issue -- the performance hit of including it is soon to no longer be justified.
ES6 support in Tern is being funded on Bountysource as well: https://www.bountysource.com/issues/1141202-support-es6-features ;)
I'm a bit lost on what isn't good advice anymore. That people should learn the DOM before using jQuery? Or that jQuery is a great library? I didn't mean to imply that people should, in all cases, use jQuery after learning VanillaJS. I meant that if a person wants to use jQuery, they should learn the VanillaJS way first. As for why someone would want to use jQuery, they has dropped support for older browsers and cleaned up their code base quite a bit. It's extremely handy for custom selectors, event handling, and Ajax which is why I think people would want to use it.
I'll have to see if Tern has any plans for supporting the ace editor: https://github.com/ajaxorg/ace
If you're going to learn Marionette, look at Backbone.Marionette.js: A Gentle Introduction by David Sulc. It's the best tutorial book I've ever read for any JS framework. 
By adding a Script tag
This is great to show up the validation rules to the user, but there should be definitely a real data validation on the Backend!
If you host jQuery from google there is a pretty good chance your user already has the file cached. That certainly outweighs the 30k difference.
Thanks - I had this before; however, I wanted to include the div creation in external JS file. Since our JS requires jQuery for other logic, it works for us.
Yep - using reddit_of_borg's comment above, I was able to get the location of where the script is being called in the DOM and do before() to insert our div.
Thanks, but same as incredibadass comment, I can't append to body - I was able to use reddit_of_borg's comment and get the exact location of where the script is called and create the div before it.
How do I know if my script is inline or not?
TIL: StackOverflow's just a subreddit.
In the line above, the script is included in a blocking manner. Using document.write as a fallback doesn't hurt one bit. It doesn't add a single msec to the page's loading time. This kind of code is meant to go just before the closing &lt;/body&gt;. Dynamically adding a script tag does not work, because the scripts which follow were written under the assumption that jQuery is already loaded. They will fail if this isn't the case.
Will do, I'm brand new to Reddit! :) Thanks!
Wouldn't it be nice if all of these code snippets were collected together, and wrapped up in functions, in some kind of library?
But Ramda would be nice to use in combination with Flyd in case you need some more functions? Ramda promises to never modify you input, making it kind of immutable in practice which I guess is nice for something like this. And you can keep the same style?
Disregarding the fact that object construction performance will have neglidgable performance implications on the vast majority of use cases, I have heard that modern jit compiled engines in browsers makes the assertion about memory and speed advantages of prototype-based construction no long true. I would love to see actual, modern data on this subject, rather than the handwavy "it's faster and more memory efficient, trust me."
Ah, okay, I was apparently thinking about Zurb's article comparing jQuery 2 and Zepto. http://zurb.com/article/1293/why-we-dropped-zepto
This is the best tl;dr I could make, [original](http://techcrunch.com/2015/04/29/microsoft-shocks-the-world-with-visual-studio-code-a-free-code-editor-for-os-x-linux-and-windows/#.dq11wt:wqmf) reduced by 74%. (I'm a bot) ***** &gt; At its Build developer conference, Microsoft today announced the launch of Visual Studio Code, a lightweight cross-platform code editor for writing modern web and cloud applications that will run on OS X, Linux and Windows. &gt; Visual Studio Code offers developers built-in support for multiple languages and as Microsoft noted in today&amp;#039;s Build keynote, the editor will feature rich code assistance and navigation for all of these languages. &gt; As Somasegar told me, the new editor is partly based on Microsoft&amp;#039;s experience with writing the online Monaco editor for Visual Studio Online, but the company also worked on bringing some of Visual Studio&amp;#039;s language features to Visual Studio Code. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/34apjh/microsoft_annouces_visual_studio_code/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.5, ~13191 tl;drs so far.") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PMs and comment replies are read by the bot admin, constructive feedback is welcome.") | *Top* *five* *keywords*: **editor**^#1 **Visual**^#2 **Studio**^#3 **Code**^#4 **Microsoft**^#5 Post found in [/r/programming](/r/programming/comments/34aglr/microsoft_annouces_visual_studio_code/), [/r/microsoft](/r/microsoft/comments/34agmg/microsoft_launches_visual_studio_code_a_free/), [/r/technology](/r/technology/comments/34aj5j/microsoft_launches_visual_studio_code_a_free/), [/r/webdev](/r/webdev/comments/34ai2m/microsoft_launches_visual_studio_code_a_free/), [/r/csharp](/r/csharp/comments/34ah8v/microsoft_launches_visual_studio_code_a_free/), [/r/javascript](/r/javascript/comments/34ala9/microsoft_launches_visual_studio_code_a_free/), [/r/Ubuntu](/r/Ubuntu/comments/34ai9l/microsoft_launches_visual_studio_code_a_free/), [/r/programming_jp](/r/programming_jp/comments/34akp0/visual_studio_code_が発表されるフリーのコードエディタでwindowsmac/), [/r/hackernews](/r/hackernews/comments/34ajwg/microsoft_launches_visual_studio_code_a_free/) and [/r/realtech](/r/realtech/comments/34ajiq/microsoft_launches_visual_studio_code_a_free/).
JS always blocks because it can change the DOM and force a redraw. This will load the script in the document.write before any js below it runs. I didn't actually test this, but this is my understanding of how js works in the browser.
Does anyone actually have data on cache hit/miss with google CDN for jquery?
There are still large performance implications. http://jsperf.com/prototypal-performance/208 The nuts and bolts of this are that traditional prototypes and constructors are converted into C++ classes while objects created via the module pattern are not. A secondary concern is inlining. Inlining is the first step for many optimizations, but isn't done when closures exist (more specifically, it isn't done when variables exist on the heap). The module pattern works because it creates a closure around the data and functions, but in the process of creating the closure, it disallows a lot of possible optimizations.
&gt; JS always blocks because it can change the DOM and force a redraw. See "async" and "defer". https://developer.mozilla.org/en/docs/Web/HTML/Element/script
Well ofcourse it wont block if you async it....
I love atom, but the code completion is certainly not in the regular product. If MSFT throws their completion in I'd be so stoked. 
It could be that they added a few extensions to it… I couldn't get very deep, because it wasn't even able to read my Visual Studio solution. I also saw that they have some kind of debugging in it, which is also not in plain Atom. I'm not sure about the third party extensions already available, though.
I am trying, but your sense of superiority certainly does not help.
Anyone able to figure out how to configure launch.json to execute Grunt/Gulp. I get how to run node against a js file but I'm running into problems with using other build tools.
Magnusson Im convinced I need to get a better grasp of javascript before tackling backbone properly. If you dont mind can I PM you some questions in the future if I run into any issues? You must understand that coming from a language with Classes and OOD makes JS a bit disorienting, granted I dont have a great grasp on the DOM or jquery because it has been years.
Sure, no problem.
I just tried it and it seems a lot snappier than Atom. Also, I was happy to see that it supports syntax highlighting for R out of the box.
Det er det dælme også, kære landsfælde og JavaScript kollega.
I noticed a lot of the sessions just end up having me go to codecademy and working there. So I ended up just using codecademy and not going back to freecodecamp. What's a good reason for me to go to freecodecamp anymore?
Oh god no! Broken links?! One step at a time.
I'll go ahead and say its a trap. Heres how itll probably go: - https will be eradicated - https:// will load TLS - consumers will think its secure when they see https:// and the logo - one site will possibley be hacked and then http will be so thoroughly slandered everyone will demand tls - getting the public to switch back to https will be impossible The benefit of this is, if it is breakable or backdoored, not only will they get the new tls traffic but all the old https traffic also--- and now the openssh traffic too. Why not offer https:// and tls://? Every mandatory https movement or group was completely crushed for the last 10 years The way it was added to openssh... They merged it like 1 day after openssl 1.0 was released, and insta released a 1.01 with basically only TLS. and the whole thing crumbled within a day. the patch was submitted and then code reviewed by the same guy. **TLS implementation has already had 2 serious show-stopping bugs if i remember. and heartbleed on top of that.** admittedly theres not much proof anywhere ... but well wait and see. I was off the internet in 2012 but from what i remember the story is this: - I dont really remember anyone saying we need tls - I do remember ppl saying we need all sites to use https and maybe https 3 -- but all the projects were met with mysterious hurdles and people refusing to cooperate - I dont really remember any outcry of happyness tls was coming along - I dont know who made it or what their background is and why they are legit - etc Arguably the w3c knows what its doing to HTML, but should we follow? HTML is still a piece of crap after 20 years. (Google "How to Center text CSS", 27,100,000 results) Before we do this we should understand how ****ing hard it is gonna be to setup a MeshNet... Already posted this on HN and got down-voted into oblivion. tbh i would rather just enc the html files with pgeep and call it done. cheers.
Because they'd like to remain relevant to developers, even if it's by rebadging something else.
Hi /u/bevacqua, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Very nice, great job!
Really cool, great tool for building whatever sort of ui you want.
Until this supports plugins I can't see myself using it. I need some VIM emulation.
I like that it has syntax highlighting *at all* out of the box. Although it doesn't convince me to switch from Atom because of the lack of packages/plugins
Anyone else having issue unzipping the Linux package on an Ubuntu PC?
The script currently being executed contract s referenced at document.currentscript. You could use that as the basis of you injection by appending your div as a child node of its parent element either before or after your script tag.
Yes, had to use "unzip" in terminal to extract it. 
Wasn't trying to be a dick, but your comment would've been confusing to me if I were just learning backbone. `el` vs. `$el` is not rendered vs. non-rendered. The `el` is always the HTML element and the `$el` is always the jQuery object. Both exist as soon as the view is instantiated but neither is in the DOM until the view is rendered.
That's a feature that's still super broken in Atom, too.
How can you hide files? 
lmao wut a troll
A lot of classes do that. It organizes and give you a curriculum. Codecademy is great for what it is but won't get you very far
 // The command is grunt. "command": "grunt", Is that comment strictly necessary? 
Does anyone know if the debugging on VS Code works with AEM and CQ?
When I say "inline" I mean there is no load handler inside the script, i.e.: window.addEventListener('load', function(){ // this is executed after the page has finished loading }); or, with jQuery, passing a function to `$` will make it run after the page has the dom has loaded: $(function () { // this is executed after the page has finished loading }); When running "inline" the script only has access to any DOM nodes up to that point in the document, so grabbing the last `script` element will always be your own.
Douglas Crockford has released some videos regarding the history of javascript. Here's a start (warning, there is a LOT to watch split across lots of videos, but you did ask for abundant information): https://www.youtube.com/watch?v=JxAXlJEmNMg 
Try searching for ecmascript instead for a full history.
Thank you!
I mean, what's the worst they could do? It's a simple code editor with above average quality code completion. Unless the thing is god's gift to programmers I doubt they'll be extinguishing anything. I have to imagine there are quite a few shops that don't use VS because it isn't cross-platform so this might be their attempt to attract that market.
Unfortunately, I'm not trying to hide it completely, just mostly move it off screen. (Only its icon shows). I can use jQueryUI to get the effect I'm looking for by using an "addclass" and "removeclass" function, but I'm trying not to add the overhead of jQueryUI if I can help it.
When talking about colors you don't usually call HSL, RGB, CMYK different colour schemes, The correct term for the difference between how colours are mathematically represented is called a color space. RGB, CMYK, Lab, HSL, HSB are all different color spaces. So in this context the library converts between different color spaces not between different color schemes. In this case "schemes" is a word programmers are more likely to know and use ~ but when talking about colors the correct term is color space.
Wow. Way easier. What browsers do ":hover" and "transition" work in?
Oof. Looks like it's not supported in IE9. :( Unfortunately, I have to have IE9 support.
Yes.
In the test you linked, in my browser, prototypal is not the fastest. :/ Also, the comparison functions/klass uses new and this, even in the module pattern. I'll have to make my own test it seems. Are you certain no browser implements similar object detection at runtime? I'm pretty sure chrome devs have stated they do. This optimization would not be detectable by initialization tests such as these because the object would have to live long enough to be observed as similar.
In sublime it's the folder/file exclusion properties in the main settings that let you hide files and folders from both the sidebar as cmd+p
The discussion is continued [over on github](https://github.com/astoilkov/jsblocks/commit/147376acc3030d7192edf5dc83f4e397c3b5f29a#commitcomment-10956598). lodash has optimizations for large arrays and lazy evaluation.
Right now it's a glorified text editor with a dark theme. You have to download at least 5 other third-party tools to get it set up to do .Net development.
In the worst case scenario that this won't be supported, I've still got a good markdown editor with live preview now!
&gt; Java /r/javascript This isn't the subreddit you're looking for *jedi*
I think the best way is to use something like this http://www.codecademy.com/tracks/javascript and give advices/help whenever needed. Or explain using the flow presented here. Additionally, I think is better to start with JS as a standalone language and then add the DOM tree and etc. 
its the no1 requested feature and will be integrated next. 
and then there were 0 funny comments about the marijuana sub that OP is subbed to. Reddit, I am disappoint.
I understand. I guess I always tend to think the way I mentioned above. I guess it might be because you often wait for the view to be rendered into the DOM before you start messing around with the $el? Thanks for the clarifications. 
Hah, no. They actually have a few examples in the default launch.json, I just modified one of them.
I like that all the Mac screenshots are using Monaco as the fixed-width font (instead of the default Menlo). Is that Microsoft's choice or the author of the article? If Microsoft, it concerns me that they are not respecting user settings. If it was the authors choice, I say, good taste!
Once the other two choices disappear, do you want a new content to re-write over everything with a new situation? Have you tried instead of disappearing, displaying a new page with new HTML content based on your previous choice?
Next stop...DirectX on Mac...then the ability to buy MacOS for any PC, then I'll never need Windows again!
I would rather teach him console.log('hello world') :)
Doesn't beat Webstorm, but could be a contender. Syntax highlighting could be better.
Why does techcrunch have three articles with different titles?
Yep~~, and with zero ES6 support I'll be waiting even though it looks decent.~~ Edit: ES6 support is available with Typescript-Syntax. Thanks, /u/te7ris
If you want to add more layers like nesting, you could copy the js and add like a .subpanel, or maybe a data-* attriblute, since I am hiding all $(".panel"), which would include the one you are clicking. So it might get a little complicated and I am sure there is a cleaner way to do it. The way I write code is get it working, then go over the working code and fine tune it. I mean there are a hundred ways, you could add a data-panel="sub" or something then use js to ask html: &lt;div class="panel" data-panel="sub-panel"&gt;&lt;/div&gt; js: var panelType = $(".panel").attr("data-panel"); $(".button").on("click",function(){ $("."+panelType").hide(); $(this).children().show(); }); Hope it helps, tinker around with it and see what works, that's the best way to learn IMO!
Nice! Now, is there a way to support a custom linter like eslint? If so, I could make the switch from (crash prone) sublime.
Unfortunately, that's the way the web was designed. The browser only understands caching requests per requested resource. There are a few ways though to influence browser caching behavior though. 1. AppCache ([Don't!](http://alistapart.com/article/application-cache-is-a-douchebag)) 2. [Service Worker](http://www.html5rocks.com/en/tutorials/service-worker/introduction/) (Still under development) As for `http://localhost/api/resources/:id1::lastModified,:id2::lastModified,:etc` The only way this would be possible is, based on the lastmodified logic, the server concatenates the resources on the fly and serves them. **BUT** When you implement this caching logic on your own, you are essentially forgoing whatever caching behavior the browser provides you, according to the standards. There are also significant technical challenges to this approach. 1. Static resources will have to be tailored for every user. Will increase request processing time. 2. You lose out on CDNs which serve your static files. They probably won't do this logic for you.
wah! &gt; main.js:131 Uncaught TypeError: Cannot read property 'multiply' of null
I'll start with my best score of 318,000. Who's next?
I think I got you beat http://imgur.com/9bgsrBe
I was surprised the score was so high when more points and a larger radius was supposed to be better. I guess that ratio could use some adjustment ;)
I feel like I've heard someone talk about this recently. I usually use Treehouse to learn coding, but this looks pretty sweet while I just started diving into JavaScript. Thanks for sharing!
I was able to get 11.7 million once, but I couldn't repeat it. It seems to be biased towards larger circles, so you should aim to draw the largest circle that will fit in a maximized browser window. Even pretty crappy ones score in the millions if they're large enough. 
I really don't think there's the remotest possibility that Microsoft (or anyone) will gain a monopoly on the lightweight code editor market.
Woah, very nice!
ok clearly something is wrong with the scoring. :-)
If he has no prior experience programming then you need to teach him **basic programming** before you start getting cute and trying to teach him about the DOM or OOP. It's easy to forget how hard programming is for someone who hasn't trained their mind for years to handle it, so go as slow as you think appropriate, *then two or three times slower than that*. Take him from the absolute beginning: "this is a variable, it's like a pocket you can put a value in", then move on to more advanced variables (objects/arrays/strings), operators, conditionals, loops, functions (and variable scopes!), etc. If you're doing it properly and letting him really assimilate the materials (as opposed to racing him through it and only checking he's mouthing the words along with you with no real comprehension) I'd be amazed if you even get past conditionals in your first session (say a couple of hours, to avoid burning him out and overloading him with information) - maybe up to loops if he's really bright and interested in the material *and* isn't just nodding and smiling while you lecture him. Then in the second session take him back again and *review the previous material again*. Don't move on to later lessons until you're absolutely certain he has all the previous stuff nailed, or you'll hit a wall eventually as his lack of understanding of basic concepts prevents him even mouthing the words properly when you start to tackle more advanced stuff. Set him some homework between sessions if you can, and don't carry on until he's written at least 10-20 little programs that use each concept. If you're trying to go from "never programmed before in his life" to the DOM API and OOP theory in a single session then you're insane, frankly. You're teaching him brain surgery before you've taught him to hold a scalpel, and all you're going to do is alienate him and convince him that programming is exactly as impossible to learn as he thinks he is.
[almost 32 million](http://imgur.com/qKcQPFJ)
Check out this [98 million point masterpiece](http://imgur.com/Jsi1ALb)
not yet; but the plugin-system is the most requested feature and it comes soon~.
I'm not going to post my score, all of mine look like old potatoes.
You are right, the score is calculated as (NumOfPoints^1.8 * Radius^2) / (ErrorPerPoint * Disbalance) could definitely use some tweaking, that was just my first attempt 
I am going to read js: the good parts, and Javascript and Jquery: the missing manual, and then maybe ask some questions about backbone after I have a firmer grasp on JS. For those who were polite to me, thank you. It's not always easy switching languages especially since js opperates a lot differently than the OO langauges Im familiar with (primarily java and ruby) :/
okay, now I definitely need to tweak the scoring methodology
You can accomplish the same thing using jQuery's animate. The transition is just telling the browser what property to animate essentially. 
[I win!](http://i.imgur.com/iiiogAd.png)
Sigh....
http://i.imgur.com/OepNaHg.png 8 million, 3rd attempt
Related MSDN blog article: [Why we made vorlon.js and how to use it to debug your JavaScript remotely](http://blogs.msdn.com/b/eternalcoding/archive/2015/04/30/why-we-made-vorlon-js-and-how-to-use-it-to-debug-your-javascript-remotely.aspx).
Hey, please don't apologize. It's all good! I was just being sensitive. 
You can get actual private properties with WeakMaps: var Person = (function() { var privateData = new WeakMap(); function Person(name) { privateData.set(this, { name: name }); } Object.defineProperty(Person.prototype, 'name', { get: function(){ return privateData.get(this).name } }); return Person; }());
Of all the currying examples I've seen, I have yet to see a reason to use one in the real world.
I've only just learned about it with this post, but I am also sitting here trying to figure out when I would ever need it.
When developing, you should be using [watchify](https://github.com/substack/watchify) for incremental builds rather than rebuilding everything on changes.
I agree, it didn't seem like a particularly big release.
/u/razh is correct. Watchify is the only answer. Luckily the grunt plugin for browserify has watchify support built in. Just add `watch: true` to the browserify options object: browserify: { options: { watch: true } }
No body cares. I just here to say that BTHW :)
Mental note to self: name next project nacho.js
https://github.com/Gregoor/nacho.js
I wonder when they are going to start saying its 'ok' to use this for production projects. Starting a new long-term Angular project now. Tempted to just jump in (but not going to just yet).
Definitely a fan of ES6, glad they are showing their examples using it.
Probably not before the end of the year. However, if you use TypeScript (1.5+) or Dart, breaking changes will be a lot more manageable. If the tooling can identify issues, fixing them becomes a lot easier.
wait, does Angular 2 not support javascript? I'm beginner/intermediate developer and have no experience using ES. 
&gt; there is always the possibility that the HTML will load but not the JS This is an extreme fringe case outside of those that intentionally disable JS. Optimizing for this would violate the Pareto principle in that you'd be much better off optimizing other parts of your system before this.
Damn, Microsoft is on a roll. 
ES is EcmaScript is JavaScript
Mental note to self: name next project NachosBellGrande.js
*As far as a ship date, Green mentioned that the first production Angular 2.0 app at Google will ship in May 2015. While Green gave no release date, it provides a glimpse at the timeline.* [At bottom of page](http://www.infoq.com/news/2015/03/angular-2-concerns-addressed).
&gt; Ember decided to completely change their rendering engine because of react. Except it's a big performance improvement that usually requires no changes to the app's code to upgrade to. What's your point, that Javascript frameworks should never make progress?
Not saving the the state of your React components -- persisting the updated data in the store to your backends (DB, instagram album, google doc, etc.) I wouldn't necessarily want that happening indiscriminately on every CHANGE.
They said its both good and bad that they're moving forward. Did you even read the post, or just start your teen angst rant at the first line you disagreed with?
`R` is the standard shorthand for the library [Ramda](http://ramdajs.com/). It's a pretty awesome functional library, though there are many others as well (lodash has a functional version I believe). There's nothing *wrong* with example 3, but it's very imperative and there's more complexity/moving parts involved. Granted it's a fairly trivial example, but it's just for demonstration purposes. `R.prop` is a function that takes a property as its first argument, and an object as the second. It would look something like this: R.prop = function (prop, obj) { return obj[prop]; }; The benefit to this is that Ramda automatically curries all its methods, which is one of the main reasons that arguments are ordered the way they are (normally with the actual data being the last argument). So if you call `R.prop` with just one argument, you get back a curried function that will return that property of any given object. Essentially you could define your `getFirstName` function as: const getFirstName = R.prop('firstName'); So you're right that it would be smart to refactor that getFirstNames into its own function, but what happens when you have the same functionality for a variety of properties. It's much easier to use something like this inline than to introduce a new named function for a one-off use case. Again, nothing at all technically wrong with #3, but it's not *functional* which is where currying shines.
Code school first angular course is free. I believe the second one is subscription only. 
$$$
Thanks! I'll look into it.
A quick example with events: const eventHandler = message =&gt; event =&gt; { alert(message, event.target.id); } &lt;button id="button1" onClick="eventHandler('hello from')"&gt;click&lt;/button&gt;
It's hard to tell why you think your comment was relevant. Can you explain why it deserves upvotes?
The one thing with lodash is that its arguments normally aren't ordered in a way that's conducive to currying, and it also doesn't perform automatic currying. So, iirc, you have to manually call `_.partial` or `_.curry`, whichever of those two exist. That said, it's far more popular than Ramda (and its scope is much bigger), so you should still check it out!
Edited, but it's already buried.
At ng-conf, they stated that clearly that their strategy was to watch the traffic patterns for Angular.io (v2.0) and Angularjs.org (v1.x), and as the traffic shifted, it would determine when they start promoting 2.0 over 1.x. Those same analytics would also influence where resources get allocated, and how long v1.x is supported. That fits with the idea that Google is very driven by analytics.
Had exactly the same problem at work recently. I tried everything, and I think the only way I can find to do it is run a deferred script (using setTimeout) after the element has already been displayed on the page. Which is a shitty method. Would love to know if there's a proper way to do this as well.
Check your font-face settings in your CSS. I've seen this happen between browsers when you have a typo or something similar between the various formats. If you're using TypeKit, Google Fonts, etc. see if you've got the asynchronous "flash" handled correctly. TypeKit has some good documentation on how to handle that.
Are you asking specifically about how Angular 2 compares to Mithril? Why not Angular 1? or React? or Meteor? Or Ember? Or Backbone? Or Knockout? Or (continues until eternity)
I was on board with this article until the NoSQL part. Is the author trying to say that NoSQL is harder to understand than SQL?
True. JS is ES, they even just say JS in their mettings, I listened to some lecture by some guy at ES, where he stated that they call it JS between them, but in official communications they call it ES. TL.DR; JS === ES 
Because I am attempting to create a project using Mithril at the moment. Curious if anyone else is maybe in the same boat that has worked with Angular 2.
Maybe it's just me or I'm just bad at navigating but I've yet to see Angular 2.0 samples without TypeScript. 
Thanks for pointing out. I will update the changes
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 7. [**Trademark**](https://en.wikipedia.org/wiki/JavaScript#Trademark) of article [**JavaScript**](https://en.wikipedia.org/wiki/JavaScript): [](#sfw) --- &gt; &gt;"JavaScript" is a [trademark](https://en.wikipedia.org/wiki/Trademark) of [Oracle Corporation](https://en.wikipedia.org/wiki/Oracle_Corporation). It is used under license for technology invented and implemented by Netscape Communications and current entities such as the [Mozilla Foundation](https://en.wikipedia.org/wiki/Mozilla_Foundation). &gt; --- ^Interesting: [^JavaScript ^library](https://en.wikipedia.org/wiki/JavaScript_library) ^| [^List ^of ^JavaScript ^libraries](https://en.wikipedia.org/wiki/List_of_JavaScript_libraries) ^| [^KJS ^\(software)](https://en.wikipedia.org/wiki/KJS_\(software\)) ^| [^Prototype ^JavaScript ^Framework](https://en.wikipedia.org/wiki/Prototype_JavaScript_Framework) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqus26n) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqus26n)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
[here you go](http://lmgtfy.com/?q=javascript+trademark)
Using CSS? Ugh, why not use SVG? https://www.youtube.com/watch?v=SeLOt_BRAqc&amp;start=1470
I think a lot of the reaction depends on your company and how much freedom/time you have to keep current or maintain existing code. I can understand being in some stressful place that tracks every billable hour for each client or pounding out 70 hour weeks to get an app ready... the frequency of updates would be too painful. The rule I have been following has always been to have a goal of 5 years for maintianable code. Luckily, my current contract gives me time to keep up with all the new developments and do that, so I look forward to it. But I'm personally quite conservative and only want to use a new tool once it has been worked out sufficiently. I still haven't switched from Grunt to Gulp for example, since I want to do the least amount of work possible when migrating to something new. I'm not a pioneer by any means. I do have some affinity for the Angular team. For one, everyone there is smarter than me (I know, I've personally talked to several of them). I have also got the buy-in of my entire team and they understand the benefits (mainly optimization) for us to refactor, etc. But I've worked for other clients where we don't want to be constantly updating our frameworks. Still, this is web development, not embedded systems, so I think of it as just the price of doing business this high on the stack.
I haven't touch angular 1.? for more than a simple crud app. So my question is: should I put my limited time toward angular today, or keep up with 2 and be ready to rock when it's officially 'ready'? Don't know much about either version so I don't know if there is significant unlearning and relearning between the two.
I am using blogspot, and I wanted to exactly achieve this kind of floating navigation bar: http://apairandasparediy.com/ As you can see, when you scroll, the floating navigation bar shows as it slides down. I'm only new to jQuery and I still have no idea how to implement this. Your help is much appreciated.
I'm on my phone so can't give links. But you should probably use browserify instead of requireJS.
JS got its name from Brendan Eich. Nothing to do with Oracle (or Sun, who owned Java).
Well, they're using ES 6 modules, which is nice :) And template strings, but other than that I haven't seen that exotic use of it indeed.
Thanks, i didn't know stackoverflow has this feature. 
I use the exact approach you're asking about. [Here's a sample gulpfile.js](https://github.com/insin/isomorphic-lab/blob/payload/gulpfile.js). If you have [a list of the 3rd party modules you depend on](https://github.com/insin/isomorphic-lab/blob/ac58c4df3f707ba438022930e6312aa49eefe1f3/gulpfile.js#L15-22), you just need to add [`bundle.external()` calls](https://github.com/insin/isomorphic-lab/blob/ac58c4df3f707ba438022930e6312aa49eefe1f3/gulpfile.js#L46) for them when bundling your own source and [`bundle.require()` calls in a separate task](https://github.com/insin/isomorphic-lab/blob/ac58c4df3f707ba438022930e6312aa49eefe1f3/gulpfile.js#L59-75) which creates the dependency bundle.
Also, all you have to change is your routes. Angular 1 and 2 can co-exist. Change the routes and any new code is written in Angular 2. All all code happily runs with Angular 1. And the routes aren't that different.
Yes, I know about the info tab, but that still doesn't mean anything in regards to the statement.
+1 from a high rep user myself. &gt;please lets try to not draw destructive and completely clueless users to the site. About 80% of all redditors.
No not at all. Basically I'm working with a NoSQL system right now that's largely based on XQuery. That part of the article was largely influenced by my frustration trying to figure out how to navigate the data with XQuery the same way I would with SQL. If it was something like Mongo it wouldn't be an issue.
This comment wasn't meant to be my perspective. I was just making a generalization of most people's sentiment to contrast with the other side of the argument. It's easy to complain about the front end with its high churn rate. It's also easy to forget that this churn rate means that we as front end developers get to have a plenty of choices for the technologies and tools we have to select from. 
Seems like their new router is part of their migration path between Angular 1 and Angular 2, and they are looking at trying to have ways of letting Angular 2 apps live within Angular 1 apps (or the other way around?) so you can migrate portions at a time. I haven't given it a try yet - I'm a big fan of ui-router. But, it looks like if you want to minimize migration pains. * Use their new router * Use controllerAs syntax * Use ES6 or TypeScript - both can bring benefits to an Angular 1.x application anyways * Keep controllers thin, most of your logic in services * Minimize how much you rely on $scope and $rootScope I doubt it will be a pain-free upgrade, but should help reduce the pain.
x2. Nice tip
OP is not talking about questions, but about *tags*. Every tag has a wiki (although they might be empty): click the tag, then click the Info tab. So yeah, the title was correct. (Except maybe that not _every_ tag's wiki contains useful resources.)
Adapting to change is the price of progress. I'll take too many people trying to make things easier for me, over having to write my own libraries for every stupid thing, any day of the week. Some people like to tout vanilla JS, or bash something like JQuery or Ember for being too big, and it's always because they're too ignorant to realize the scope of browser and platform BS that these libraries and frameworks smooth over for them. I started doing web dev back around IE 5.x, and the browser wars, and it was a fucking nightmare. Kids don't know how good they have it. Harrumph.
You need at least 1500 reputation to create a new tag, but only users with 5000 reputation can approve changes to or create tag wiki pages. You may need more reputation to unlock the privilege you're looking for. http://stackoverflow.com/help/privileges
Ha, I'm from the complete other end of the spectrum of viewpoints on this. I mean, I agree that StackOverflow is great, and that occasionally there's crap content, but depending on what you mean by "clueless" I *absolutely* want clueless (e.g. "OMG my boss just handed me a PHP book and told me to start coding my website") users. Why? Well, if they ask really crappy questions, they can just get deleted, and if they ask *good* questions, then *they learn*. I'd much rather risk the occasional bad content than make someone feel unwelcome just because they're new to programming, bad at English, don't know the right term to use, or have the temerity to ask about something someone else has already asked about. I actually get fairly bummed when interesting but "off topic" questions get deleted too. I'd much rather they just get hidden from the search engines but still archived somewhere. People seem pretty trigger happen to delete questions there, too. I nearly had one of mine deleted because it sounded too "I need to figure out how to choose/use a programming tool" and not enough "I need to figure out how to code this tool". In order to prevent deletion I actually had to rewrite the question to be less generally helpful for other users looking to solve the problem I was trying to solve. Frustrating.
&gt; please lets try to not draw destructive and completely clueless users to the site You do realize SO is a *question and answer site* right? It always is going to attract those are less knowledgeable, being snooty about less experienced users isn't helping anyone.
Very cool. Never heard of Tessel.
My initial suspicion is that `cancelLoginTimer` is defined within a function which would make it local and not accessible to the onclick. Where is that code placed?
You're welcome. Can we see the final project!?
Authentication is nothing more than verifying someone's identity. Authorization is the second step, where you are saying "Now that I know who you are, should I give you access to this application?" Authentication is generally independent of context, while authorization is in the context of your application or use case. When you own both of those systems, a lot of identity management platforms also offer application authorization. I've not seen similar in the federated authentication scenarios I've implemented. Generally when you are using a third party for authentication, e.g. google, you would use your own application for authorization. You can definitely request and receive various metadata about users from google, by scope, but the available information doesn't include groups. It does include organizations (see https://developers.google.com/+/api/latest/people/get#response). I've managed authorization in the past by adding and managing roles per user from within my application.
You were right it was inside another function - I've moved it out and now it works! Thank you so much!
Yep, you were spot on, I moved it outside the function and it now doesn't give the same error. Thank you so much!
Not knowledgeable users aren't a problem. Lazy users asking half a question without searching and without first trying to find where exactly is their difficulty **are** a problem.
Thanks. It's refreshing to see a post about SO on reddit which isn't from some disgruntled user complaining that their duplicate half question got closed or that nobody liked their joke... 
you're downvoted because you've misunderstood the post completely. it's talking about TAGS and you're talking about QUESTIONS. You post questions, and assign tags to the question to give the question more targeted visibility.
Hmmm so what youre saying is that although i cant restrict which users get to sign up for my intranet via Google....however i can restrict the type of info that gets pushed out to certain users? I'm making an intranet type of web app that only want people who works in my project to be able to access, but i would like for them to be able to sign in via their google account. What would you say would be the best way to go about restricting just...the general public from signing up and seeing internal content?
I currently use atom as my main editor. Besides startup speed (which I almost never reboot my pc so is fairly irrelevant). I have not noticed any speed problems with atom anytime recently.
I always thought it was cache invalidation and naming things.
You have a terrible, elitist attitude.
That dungeon sample is VERY nice. Looks good all over actually.
&gt; My goal: Lets say we have 10 animated gifs. At start, I want to play the 1st one. Once that one finishes, I want to play the 2nd one on the place of the 1st one. In other words, make 1 single non-stop movie out of 10 gifs. Without coverting the 10 gifs into 1 file, ofcourse. I can achieve this... without too much code... It'd be really helpful if you could tell me the duration of the gifs. If I have that, shouldn't be hard to create.
Sounds easy enough. Let me see your code and I'll try to figure out the dropdown part... shouldn't be too tough.
Don't forget: name next project NachosBellGrande.js
This is really exciting. Working with REST has never felt quite right. Nice to see an organization like Facebook lead the charge to replace it.
How does this compare to OData?
Just out of interest, what is the purpose of making this a react component (rather than just plain ol' code)? Is it "normal" to have a JSX tag for something that doesn't end up as a page element?
maybe /r/learnprogramming?
Hi /u/GoblinSmasher, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
"Forbidden"
I can't speak to this project, but I suppose react-router does that.
Since you're using [libgif-js](https://github.com/buzzfeed/libgif-js), this should be pretty simple to do. All you really want to do is use the `on_end` option of the constructor to add a callback for when the GIF ends, then display the next one once that option is called. Something like this (note: completely untested, only based on a quick readthrough of the `readme.md`): HTML &lt;img src="/1.gif" /&gt; &lt;img src="/2.gif" /&gt; ... JS: var gifElms = $$("img"), gifs = []; for (var i = 0, j = gifElms.length; i &lt; j; ++i) { (function(i){ // create the SuperGif instance for this image gifs[i] = new SuperGif({ gif: gifElms[i], loop_mode: false, // this is the callback for when the GIF ends on_end: function(){ var selfCanvas = gifs[i].get_canvas(), next = gifs[i+1] || return; // I'm not even sure how libgif handles elements // I assume they just replace the img tag with a canvas self.parentNode.insertBefore(next.get_canvas(), selfCanvas); self.parentNode.removeChild(selfCanvas); next.play(); } }); })(i); }
I believe one of the requirements is to find the gif length. that is the only challenge I see here the rest could be done using setTimeout() and using css to hide a bunch of stacked gifs. of course activating on document load.
I only just just read the readme - but it got me excited b/c it's like meta tagging resources with UI. For example - it's good practice to put script tags after the html so that the html renders first. I assume the same concept is being applied to react - only waiting for the UI to render - then grab resources - and have loading feedback while it's happening. Still need to look at source code tho It has to be done in a react lifecycle method in order to be certain it's rendered.
These are all really exciting and interesting ideas! We'll probably try to find stuff to do that's a little bit less evil, though.
Yep, that's what I was thinking. Shouldn't be too hard.
We are capable of doing math, so no, we are absolutely not thinking that ;) The feedback that we get is that most of the workarounds like this are pretty inconvenient. And, at $7/mo, they don't end up saving that much money. We think that we can make it simple enough to save at least a few minutes per month per dev if a company just goes ahead and gives each user their own account. If you're paying people typical tech salaries (especially in the Bay Area), then it's a bargain. On top of this, we can add other products and services that make it an even more obvious win for individuals and companies. I think we'll do fine. This is just a first step.
Oh funny. I saw your reply and I wasn't sure what you meant. And then I just now realized that many Europeans use commas where we use periods and periods where we use commas. Looking at the code with that fresh in my mind, the problem is obvious. Always glad to help :)
Been away from this project for a bit, but I'll be sure to check this out. Thanks!
My [slight] problem with this is that in the example, `result` would still benefit from being declared as `const`. This would lend itself more towards the "Const is the new var" title and the wrap up in the end about preferring the use of const. However it seems `let` is being used instead as a hint towards mutability of the object and not the constant nature of the variable.
[This was discussed on es-discuss a couple weeks ago](https://esdiscuss.org/topic/should-const-be-favored-over-let), and since @esdiscuss is a little slow at reporting highlights, I just read about the discussion earlier today. &gt;I agree, `let` is likely to win because of it's length. I find that I fall into using it solely or that reason. I think it also wins on readability. &gt; &gt; If we had a "do-over". I'd make `let` means what `const` now means and have something different for defining mutable lexical bindings. Maybe `let var foo=...;`. Languages have made a mess of the `const`-ness of `let` bindings. Rust has `let mut`, AS4 had `let` mean `const` bindings, JS has `let` mean block-scoped `var`, Swift has `let` mean `const` and `var` be block-scoped, OCaml and Scheme have `let` and/or `letrec` which have another take on the concept.
Hah, yeah. And dart has `final` as ES6 `const` and `const` as, uh, real `const`. In my opinion the best way would be just `let` and full immutability by default. One can dream. :-)
What is this AS4 of which you speak??
I agree. The problem with mutability is that it's "infectious" so unless it's guaranteed at language level, you can't rely on it. One of my all time favourite papers [Out of the tar pit](http://shaffner.us/cs/papers/tarpit.pdf) summed it all up nicely years ago.
http://www.reddit.com/r/web_design/comments/34frdh/lets_see_your_portfolios/cqu9353
inb4 someone complains about how hard it is to keep up with javascript.
As much as I respect Lea, she's wrong. There are *plenty* of situations and projects where jQuery is a good choice.
just another option is bind them both to the same func function abc (e) { ... } $('#button1,#button2').click(abc)
What do you mean "Where do you see that in your link"? at the bottom of the page there is a button that says "edit tag wiki". It is a wiki page.
Webpack shows there is plenty of valid competition and there are a ton more.
oh please don't. 
The most important feature a code base can have is readability because readability makes it easier to understand and maintain the code. Things like these make code difficult to read and so shouldn't be used.
If it seems too much to write !== -1 you can always create a live template(webstorm terminology) for it.
But.. but all the cool kids are using them! Seriously though, I learned them from some of the respected libraries out there. Besides, one-liners like them, once you know them they're just like a syntax, hardly un-readable.
well, no. Code should communicate the programmer's intent to other programmers for the most part, including their future self, and in second place, to the computer to make it do stuff. If you want to test a value for -1, then write something that looks like a test. || and &amp;&amp; are primarily boolean operators which have been extended for other data types. But you would do well to just keep them for use with boolean logic, anything else is more clearly expressed in other ways. 
If it's only showing or hiding data, why not just use the ng-show and ng-hide directives in your HTML? ng-hide="data === 'A'" ng-show="data === 'A'" ng-hide="data === 'B'" ...
Hi, thanks for the answer, they are not always opposite, in other functions they are both set to false. I'm not very resourceful, I'm gonna try to simplify it with your suggestions, thanks!
A generic approach to solve your problem could be writing down the [truth table](http://en.wikipedia.org/wiki/Truth_table), optionally optimizing it, and implementing it in javascript.
As written all over this is just in a early stage so far. There are plans both to include jquery based syntax, and something called Live Nodes. Updating different virtual nodes live when a action happen. Circular events are the start of this.
I guess I was meaning in the Elvis operator sense. 
Hi /u/mistymintcream, this post was removed. If you'd like help with JavaScript, you will need to attempt and write some first; you can't just post the markup and expect us to do all the work for you. If you're so new that you have no idea where to start, I'd like to point you to /r/LearnJavaScript. Thanks for your understanding.
Thanks!
Ended up doing it for OP. http://codepen.io/anon/pen/jPPQEo
If I remember correctly, Chrome will not (or can not) JIT compile code which uses `with`. 
Rx is so great, and functional reactive programming in general. Used an alternative to Rx called bacon.js to write the [sigh asset pipeline](https://github.com/sighjs/sigh) and it was a joy to work with. Brings some of the things I love about Haskell to JavaScript. Going to be giving a talk including a lot of stuff about FRP this month in London.
`with` is fine, possibly even great, for **read-only usage** of the context object such as DSL-style APIs. I used it for a function call-based template engine where the API consisted of tag-name functions and $-prefixed helpers like `$block`, `$if` and `$for`. I wouldn't do the same today as I'd rather have the benefit of strict mode making bad management of `this` an error (and because React/JSX killed template engines dead for me)
How does this compare to ESLint? 
Ha.. well that was concise. It does appear that they are planning on some mechanism to automatically fix lint errors if possible. Looks like they going to provide the AST and a separate tool can actually apply the fix. Either way, I'll definitely check out JSCS. I'll have to dig in and see if they have all the choices that eslint or if I would need to use eslint as well. 
A big distinction between JSCS and tools like eslint and JSHint are around formatting vs early bug prevention. Linting should help guide your code into more consistent operation, style checking will guide your code into more consistent visual appearance. You may find many options from eslint and JSHint migrated into JSCS. I'm not sure I'd necessarily want eslint to adjust my code beyond style changes.
In case anyone also wants to know what Aurelia is before listening to a podcast, [it's yet another client-side framework]( http://aurelia.io/). Using es7 is interesting, I'll give them that.
Hi /u/bsurela, it looks like you're new to reddit, welcome! Is there any reason you're posting the same site [you posted just 8 days ago](http://www.reddit.com/r/javascript/comments/33ocxw/log4surecom_a_client_side_logging_service_with/)? That's generally frowned upon -- please see http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more information. Thanks for your consideration!
We are all the error. That's why we write JS.
I have been using Kefir recently. It is designed to be similar to Bacon, but with better performance and fewer dependencies.
To be fair, this is a consequence, not a cause. `with` has been deprecated or hated for so long that engines never optimized its use case like they did with so many other things.
Holy crap, someone on reddit who actually reasons well. I like you man. Id say browser makers probably weighed the alternatives and decided it wasn't worth it. You can get close enough by using a function and binding your context ( only difference is having to use this, instead of calling the variable without context). I've never tested that for performance though. You would expect in either case, the closure would be the culprit. Well now I'm curious.
cant download your source
I understand. Thank you.
I crashed it with a right click. https://www.youtube.com/watch?v=LhnZbNHWx8I
I don't really like auto-formatting, unless you're using it to fix up a legacy codebase. Personally I prefer it if programmers actually oversee the process of making their code readable by making it conform to the standard outlined in the JSCS config. My setup refuses to make builds if there are JSCS style errors, so then the programmer goes in and fixes it and then (hopefully) eventually never makes those mistakes again. It's much less of a learning process if it's done automatically.
Came across this while Googling on this exact error. So I upgraded Webstorm from 9.something to 10.0.2 and problem went away.
Does anyone know what formatter cloud9 ide/ace uses? Is it already jscs? I've been using it since they introduced it, and never gave it a second thought.
On thing I have yet to encounter is the need to publish modules. I am a little confused as to why it is necessary if it's something private to your project. I understand there are private repos online but why is the link functionality not something you can use if you don't want to publish your private modules but still have them available across the project with require.
Well, you're asking multiple questions. Put simply, ES4 was skipped because it was too much of a change to the language, and ES5 happened instead. By some standards, even ES6 isn't as big a change as ES4 would have been. As for why Typescript is seen as the goto ^(*hee hee*) compile-to-JS language for using types in your code- it's a superset of JS (presumably), so it's opt-in, its types are optional, and last but definitely not least, it has excellent tooling (I'm looking at you, atom-typescript). I'm on mobile, so I can't provide links (although it would be nice if someone could), but I think that sums it up nicely.
that was unintentional, fixed
sorry about that, I realised I hit the link submission which doesn't take comments.
There is https://github.com/lodash/lodash-fp
AS2 was already ES4 based, it was however a half backed language between AS1 and AS3. Nobody wanted it, nobody liked the migration to Java pattern that ruined Flash, if you consider the amount of development is done these days, compared to the amount of AS1, basically identical to ES3, and before Flash5. The decline of developers started in those days, I hope JS won't be ruined in a similar way.
Tilde has a performance cost if you could be comparing complete strings. If have have an actual substring, it makes more sense.
&gt; Microsoft didn't really know what they wanted. They were more interested in pushing Windows oriented technology instead of the web. They were against it. I think it's more than that. Microsoft was(is?) the biggest proponent of "invented here" syndrome. If they didn't think about it, it's not good. There is a famous quote somewhere that is basically, "I don't care what standard they use, as long as it's ours."
JM2C, but I suggest that if you’re going to think about `let`, you should also think about `const` at exactly the same time. Further to that, if you *can* use `const`, you should. `let` should only be used if you know for a fact that you need to rebind a variable.
From what I've heard, the problem is that ES4 was half-baked and Adobe's proposal was a complete joke. None of the details were thought out at all. So when MS came into TC39 with a pretty much complete ES3.1 draft it was pretty hard to argue against.
Performance is horrible on Chrome for iPad. Better in Safari but the blog post can't even be read because the infinite scroll infinitely scrolls so you can never get down to the article.
Agreed. I worked a LOT with AS2 and AS3. Rosetta Stone (where I was working when AS3 was born) adopted AS3 when it was still in private beta. We built version 3 of the software with it and I feel strongly that AS3 was a major improvement over AS2- in much the same way as I feel TypeScript is a big improvement over vanilla JavaScript. Runtime types will be nice eventually but at l least having static analysis is a huge gain.
&gt; JS frameworks are so common as to almost be a joke No. It **is** a joke and the third one I heard this weekend.
Interestingly, this is not too different from what happened with the [successor to ALGOL 60 in the 1960s](http://heerdebeer.org/ALGOL/succession.html): A complicated successor was developed by a committee, ALGOL 68, but half of its members, including Wirth and Dijkstra, wanted something more simple and practical and closer to ALGOL 60, resulting in the development of ALGOL W and, later, PASCAL.
&gt; TypeScript uses a mix of nominal I don't think that is correct. Names don't mean anything in TypeScript. Only the structure is important. Unlike Java for example, you never have to say that object X has class/interface Y. If X has the same structure as class/interface Y then it is a Y. You don't have to connect the name Y to X. Names in TypeScript are just a useful way of referring to a defined structure. In TypeScript you should be able to replace any usage of a name with its corresponding structure and it should still work. (I suspect that the language grammar doesn't quite allow this though.) The closest counter example that I can think of in TypeScript is classes and the `instanceof` operator. `instanceof` compares objects to a given constructor function, not the structure. 
I think you may be tying your definition of nominal typing too closely to how it's been implemented in languages like Java. Just like some people tie their definition of OOP to what's done in Java, and claim that JavaScript isn't object-oriented (because it hasn't been class-based, historically). &gt; Names don't mean anything in TypeScript. They mean a lot to people who write TypeScript code... as evidenced by the overriding presence of named types in TypeScript programs. The type system knows how to deal with names to enforce its rules, and it needs to because programs use a lot of them. Therefore it's a mix. It might not be a balanced mix (in terms of the amount of rules that deal with names vs. structures) because it's easy for the type system to quickly do the name-&gt;structure translation, and then do all of the hard work in the domain of reasoning about structures. &gt; In TypeScript you should be able to replace any usage of a name with its corresponding structure and it should still work. You could... but it would be a complete usability disaster to the point where nobody would seriously use the language. &gt; (I suspect that the language grammar doesn't quite allow this though.) That's almost reason enough to call it mix. Like if there's some tiny little theoretical aspect that makes a type system provably unsound, you can't really call it sound with a straight face. In our case, the type system must deal with names, so it has *at least* some aspect of nominal typing.
Microsoft is the guy that when discussing and sharing music, they try forcing you to listen to their mixtape!
Interesting name lol
I'm glad you responded. I wanted to know what the experience using this language in a team.
Those are all good points.
Gulp... grunt... sigh. All non-verbal noises. Although I didn't realise it at the time, I called it sigh because I was disappointed/bored with coming up against the limitations of existing asset pipelines over and over.
Typescript is also heavily influenced by ES6 so in learning it you won't be far off in the future.
&gt; ~~Flash~~ FlashPlayer being buggy, a security hole, and not being mobile friendly killed it. On the other hand AS3 was a huge improvement.
You are a genius.
Thanks for starring sigh! :)
ES4, by 2004/2005, had a type-system. Just because something was rejected once doesn't mean it'll be rejected forever. Was the ES4 type-system perfect? Almost certainly not. Does TypeScript have its basis in lots of active PL research today? Yes. Standardising something locks it down in many ways — and it's almost certainly worthwhile seeing how more of the research around TS turns out before doing so.
coffee and emblem..NO THANKS.
Also, if you run the code you write, the line numbers in the console match the line numbers in your code. 
FlashPlayer was mobile friendly, it's the content that companies were publishing that wasn't. (and, again, their content that was buggy, not the player itself) The visual performance was WAY beyond what HTML5 was able to do at the time (see this [demo](https://vimeo.com/10553088)). Flash was also generally less of a security hole than IE, which was the most common desktop browser at the time. The real reason it was killed was because Steve Jobs decreed that it wouldn't be allowed to run on the iPhone. Considering the other limitations of what code could run (no cross-compile from un-approved languages), it seems that his stance was mostly "Not Invented Here". Adobe licenses the Flash Player source code to many large corporations (It was a popular option for rendering 2d UI on both the PS3 and Xbox 360, and Google has their own specific version that they bundle with Chrome). I know for a fact that Adobe showed Jobs FlashPlayer running on the iPhone before he made the decree, but it didn't sway him. It was a classic Steve Jobs decision. Apple won, Adobe lost. Simple as that.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Herd immunity**](https://en.wikipedia.org/wiki/Herd%20immunity): [](#sfw) --- &gt;__Herd immunity__ (also called __herd effect__, __community immunity__, __population immunity__, or __social immunity__) is a form of indirect protection from infectious disease that occurs when a large percentage of a population has become [immune](https://en.wikipedia.org/wiki/Immunity_(medical\)) to an infection, thereby providing a measure of protection for individuals who are not immune. In a population in which a large number of individuals are immune, chains of infection are likely to be disrupted, which stops or slows the spread of disease. The greater the proportion of individuals in a community who are immune, the smaller the probability that those who are not immune will come into contact with an infectious individual. &gt;==== &gt;[**Image**](https://i.imgur.com/DtSuI3M.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Community_Immunity.jpg) - *The top box shows an outbreak in a community in which a few people are infected \(shown in red\) and the rest are healthy but unimmunized \(shown in blue\); the illness spreads freely through the population. The middle box shows a population where a small number have been immunized \(shown in yellow\); those not immunized become infected while those immunized do not. In the bottom box, a large proportion of the population have been immunized; this prevents the illness from spreading significantly, including to unimmunized people.* --- ^Interesting: [^Mathematical ^modelling ^of ^infectious ^disease](https://en.wikipedia.org/wiki/Mathematical_modelling_of_infectious_disease) ^| [^Cholera ^vaccine](https://en.wikipedia.org/wiki/Cholera_vaccine) ^| [^Vaccine-naive](https://en.wikipedia.org/wiki/Vaccine-naive) ^| [^Vaccination ^policy](https://en.wikipedia.org/wiki/Vaccination_policy) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqxo169) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqxo169)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Verbing weirds language.
Very neat!
&gt; Because you probably want javascript in the first place Targeting some particular platform does not automatically mean that you want to use a particular language. E.g. don't necessarily want to use Java just because you want to target the JVM, right? &gt; Javascript is not THAT complex ES6 is actually a rather complex language. Have you looked at destructuring in parameters? That alone is a complete nightmare. &gt; But after mastering these pitfalls, you will realize that you do not need any of these tools to be good. Yes, you can of course write large applications in JavaScript. However, due to the lack of proper tooling, it's a lot harder than it needs to be. GWT, CC, Dart, and TypeScript were all created for making this easier. They all enable better tooling. Tooling is what you need to remove the kind of friction you get when multiple developers work on the same project.
This looks interesting, although I just switched from Grunt to Gulp mainly because gulp is easier to allow junior/mid-level developers to create their own tasks. Grunt was becoming too big to manage the configuration. Would this be able to fix the Karma issue, or does it provide an alternative to Karma, where you can't stop a running set of unit tests to restart them when a watcher detects a file change while the tests are running?
JavaScript was a massive letdown when I first came from AS3. Flash sucks but AS3 was awesome.
Or delete, or arguments (unless just using arguments[index] or fn.apply(ctx, arguments))
yuck... it's like they were trying to turn js into java
Bravo. I don't even know the backstory, but bravo.
It's fine to dislike specific aspects of Java. It's moronic to dislike everything about Java just because someone told you that Java isn't cool. Also, don't forget that JavaScript was meant to look kinda like Java and that it was called *Java*Script for marketing reasons. Without riding Java's popularity wave, JS probably wouldn't haven gotten anywhere.
&gt;Martin Computer King I am ded now. But what about Al C#ton and Jesse Javackson? Malcolm Xcode?
you deserve more. This post was basically the 'Twilight' of javascript.
Emberto Eco holy shit, just got that one.
The error is clear. There's no element with an id of `price3`. If you check your HTML, you'll see you have a typo: &lt;span id="price 3"&gt;14.99&lt;/span&gt; instead of: &lt;span id="price3"&gt;14.99&lt;/span&gt; 
This is a good point. To really optimize the DOM drawing, reuse a pool of existing DOM nodes and reposition them. I make this point in the article: "Reusing DOM elements instead of appending and removing them would be faster, but it would increase the complexity and I wanted to keep this focused on Bacon.js and FRP." What type of buffer would prevent dom mutations on per pixel scrolling? You *always* have to adjust the top position offset of the rows when there is a scroll. The really nice thing about the way streams are implemented here is a DOM node is only destroyed or recreated when it's index falls off screen or comes on screen. The streams made that really easy to do. Other optimizations might be to look at using 3d transforms so that repainting is limited (example: https://github.com/SimplGy/gameOfLife#paint-rectangles). However, I think with a solution like this the bottleneck has been moved into your domain/application, and optimization time is better spent there. On calculating velocity, I think that'd be especially useful when you need to request data from the server for each row/set of rows. Then you could predict where the user might land and request it ahead of time. Streams represent data as a function of time, so you can absolutely sample the most recent 3 or 5 values so you can derive a velocity and acceleration.
Yup that's it. Thanks a bunch. 
So close. Too bad it's not RxJS. Much better library for streams.
Thanks for the bug report. There's an issue in iOS with iframes that doesn't let you bound their height: http://davidwalsh.name/scroll-iframes-ios. I have fixed this. Responsiveness of scrolling *in the iframe* will still be slow because the browser is disambiguating between a touch and a click: https://github.com/ftlabs/fastclick For a correct representation of the solution, view the demo in it's own tab: http://www.simple.gy/demo/infinite-bacon/ This works correctly and fluidly on both chrome and safari.
This is excellent. Bravo!
It doesn't take into account leap years or even the fact that a month can be either 30 or 31 days. Using Date would solve the math : (Date.now() - new Date("11/25/1986 09:25")) / 1000
Actually I started using RxJs... By "much better" I assume you mean it's about 5 times faster for most operations. In many ways it isn't "much better", for example subscribing to the same streams multiple times can result in unpredictable behaviour that's awkward to work around. 1. It doesn't matter RxJs is much faster, 99.99% of the CPU time sigh uses is in compilers and other plugins. 2. It's more important the code be easy to work with and maintainable given it doesn't really matter which FRP library is used. 3. There are plans to migrate from Bacon.js to Kefir, Kefir is faster than RxJs and as simple to use as Bacon.js, offering the best of both worlds. 4. It's much easier to port code from Bacon.js to Kefir as their APIs are almost identical. Ultimately it would have been nice if I'd chosen Kefir to begin with, but I'm definitely glad I'm not using RxJs.
five.loud() // FIVE 
Knockout is great for having simple data binding set up for a small part of your application. You also don't need to go through much ceremony to get it working. I have more experience with knockout (I do enjoy working with it) than angular but I really don't think they're "competing" libraries. Angular does so, so much more.
ID's have a proper place in the DOM. It's my belief that they should serve as a focal point for major HTML and CSS nodes. ID's for JavaScript input and output are acceptable except where an event handler can do a better job using `this`.
Why do you need to sign up for a "free" download? That's not free.
RxJS is closer to the Observable proposed for the ES7 spec. It's more of a standard than Bacon, Most, Highlands or Kefir It also has schedulers. Which can be powerful tools. You could use them for coordinating between a currently running build and a newly triggered build, for example. CPU be damned, it's just better.
It's just an example...
The variable names gave it away. I'm currently learning Dutch, that's why I noticed. :) A quick tip: Try to stick to English, when programming. It makes co-operating a lot easier and you don't run in to problems with illegal characters ("é").
I'm working with a 3rd party library that doesn't use promises. I can use a callback, but they don't return a promise to me. Edit: actually it looks like you can wrap 3rd party code in a promise. Its not pretty but here it is var resolve1, resolve2 var promise1 = new Promise(function(resolve,reject){ resolve1 = resolve }), promise2 = new Promise(function(resolve,reject){ resolve2 = resolve }) asyncCallWithCallback1(function(result){ resolve1(result) }) asyncCallWithCallback2(function(result){ resolve2(result) }) Promise.all([promise1,promise2]).then(function(result1,resulte2){ .... }) 
Why not?
The download link to https://github.com/bucaran/retab/blob/master/retab.safariextz?raw=true is a 404. 
Some promise libs provide a method for "promisifying" existing callback-based functions. I know Bluebird does and I would imagine Q does as well. 
You should file an issue for that unpredictable behavior. I've never seen that.
Well, it's a backend module.
[Like that makes a difference!](https://www.npmjs.com/package/jquery)
I for one evaluated both frameworks and initially settled with Knockout because I liked KO's approach of using Observables for change tracking better than Angular's dirty-checking and additionally felt that Angular was mandating too many things for my cup of tea. When your project grows though, you realize that KO's lacks many of the bells and whistles that are built-in into Angular to support large scale development. After doing a couple projects using Knockout and exposure to [ReactiveUI](https://github.com/reactiveui/ReactiveUI) on the desktop I've decided to [roll my own framework](http://webrxjs.org) (yeah I know, another one ... *yawn*) which is probably best described as a hybrid of both frameworks mixed with a heavy dose of functional reactive programming but without Angular's *"there's our way or the highway"* attitude.
These two are not equivalent. Try [knockout + crossroads + require](http://blog.scottlogic.com/2014/07/30/spa-angular-knockout.html) vs angular. I generally prefer knockout as it's a library and I'm in control. With angular, it's a framework and with frameworks you let them do the driving. I don't like that. 
Haha, very nice, made me think of the hay-day of kuro5hin... My first thought, however, was "only *two* javascripts? We need at least 6 transpiled meta-JS languages in stories!"
`q.all` or `async` libraries. `q.all(arrayOfFunctions).then(onComplete);`
This. Also, it doens't take into account daylight saving. Besides that, a year has slightly more weeks then 52. According to google you get 52.1775 weeks per year, which seems accurate because it nets 365.2425 days per year. Besides that op is asking a few questions that can easily be found out with JavaScript's Date function. Like: "What day of the month is this?"
Don't make assumptions about why I do or don't like java. And btw saying js wouldn't have gotten anywhere wirhout java is utter tosh.
As others have mentioned, knockout is not a full framework like angular. Personally, I really like ember. The new render engine makes it as fast as react and the core team is committed to backwards compatibility and easy upgrading. 
Nice documentation and clean site!
Knockout is very lightweight where angular is much more fuller featured... Knockout is great for 2 way data binding while angular gives you that plus much more
A couple of things, one of which I mentioned in the podcast: 1. MS was about to cave and do ES4 in spring 2008 -- I learned this much later from an ex-MS employee who would know. We on the ES4 side were poor poker players, we should have kept bluffing :-P. 2. MS suffered not only an anti-web reaction due to boredom or NIH after IE achieved 95% or so market share -- they allegedly were also fearful of more antitrust and regulatory pain. So they sought the comfort and seeming safety of good old Windows-proprietary platform work. But in an inter-networked world this is no safe harbor, as they found out via heavy fines for monopoly abuses with Windows Media Player and IE in Europe. 3. ES4 had nominal and structural types, runtime spot-check "types" ("like" types, see Cormac Flanagan's formalization with the joke title "ValleyScript"), and more that TypeScript has yet to absorb, but on the other hand V8's SoundScript experiment proposes simplified forms of all of these. ES4 was ahead of its time, best case. And Facebook's Flow may dance with TypeScript and SoundScript to inform both. We'll see, but it could be that ES4 will finally serve some grave-cold revenge dishes in the next few years.
Thank you. Appreciate it!
Probably not until [Object.observe()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe) becomes main-stream. For the time being developers have to decide between observables (Knockout, WebRx, CycleJS and a couple others) or dirty-checking (Angular). Angular 2.0 appears to be headed for [Object.Observe](http://angularjs.blogspot.de/2014/03/angular-20.html).
Is this similar to [adaptive backgrounds](https://github.com/benhowdle89/Adaptive-Backgrounds)?
So, it aims to be 99.9% compatable.... Is it there now? And if not, what isn't compatible?
Well you _can_, but then if a dependency tries to require jQuery you will either get an error, or you'll end up with jQuery twice anyway.
Hi /u/mrzepinski, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `medium.com/@mrzepinski`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [medium.com/@mrzepinski](/search?q=%28and+site%3A%27medium.com%27+author%3A%27mrzepinski%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|5|100%
Hi /u/halistechnology, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `halistechnology.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [halistechnology.com](/search?q=%28and+site%3A%27halistechnology.com%27+author%3A%27halistechnology%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|7|100%
I wouldn't equate angular's module pattern with require. You should still use angular + require (or browserify)
The simplest solution is to not use jQuery or anything that require it.
because it's lightweight, and it does the same thing.
$.ajax is not compatible along with fn.on, and fn.off
Eww
Just adding my two cents to the others who have evaluated both and landed on knockout. For me, it came down to more flexible binding, less opinionated, not trying to do everything for you (ie, not a framework), and able to coexist dead-simply with everything already in my stack/project. In the latest project, we're doing knockout for data binding in a modular sort of way, tying the ko models to various templates throughout the application. it's light and flexible, and we get to create the MV* aspect of it exactly the way we want.
There's a "replay" button in the modal that is supposed to restart the game. Is it working? If not, what browser are you using? Thanks ;)
There is a better way. https://github.com/SteveSanderson/knockout-es5 just drop that in if you can stomach the browser compatibility of es5 setters/getters my friend
&gt;there are probably a thousand things that can go wrong Nothing springs to mind, but I can't claim to know KO's inner workings with any great detail. I'm not overly concerned with ES3 compatibility for the projects I'm using KO for.
I would set an activity tracker. var lastActivity = new Date().getTime(); function trackActivity() { var now = new Date().getTime(); if (now - lastActivity &gt; 60 * 60 * 1000) // one hour inactivity { window.location.reload(true); } lastActivity = now; } window.addEventListener('mousemove', trackActivity, false); window.addEventListener('keypress', trackActivity, false); The code should be straightforward, but if you need more info, just ask ;-)
Pretty neat game! There isn't much time considering the intentionally confusing nature of the questions. I get that it's supposed to be hard, but honestly the low time just made me rush and not comprehend the questions. Also, it's a bit tough to determine whether the last answer was correct or not. I get that the text changes to something, but some of them like "Haha!" I didn't know if it was good or if I'd messed up. I also got a "So, what's the result of..." as a response between questions.
I almost went a sinner: some time ago I had the idea about using a `with` statement throw to my mind during the development of a WebWorker based general purpose library. The idea was to isolate some user code execution from the global scope of the WebWorker to avoid side effects between third-party and user code, so the idea was to inject a customized global scope defined by the user, which is actually safe. I finally resolve it isolating the private library stuff in a closure and executing the user code outside of that closure, having full scope isolation and removing any kind of side effects, so no `with` statement was required, but I can understand that for particular hacking of some stuff it could be useful (but equally dangerous)
From the docs: &gt; ko.track(someModelObject, ['firstName', 'lastName', 'email']); vs. &gt; ko.track(someModelObject, { deep: true }); So we've got *opt-in* or *all*. Either way, imagine how often you'll probably forget to update the list of tracked properties for the *opt-in* case or how often it transforms something you'd rather have left alone for the other. :) 
You can also do `ko.track(someModelObject, { deep: true, fields: ['prop1', 'prop2'] });` ;) It won't particularly matter for my model, though. Everything in the chain will either be a basic type or something which initializes tracking in its constructor.
I was a big fan of Knockout when it first came out, and I'm also a big fan of Angular now. And as others have mentioned, Angular has a lot more than just templating databinding, which is all Knockout does, so it's not a fair comparison. That said, I'll focus entirely on the databinding aspect of Angular as compared to Knockout. What you need to know first and foremost is that they're both great templating/databinding frameworks. They are both fast and they both do a great job of enabling you to segregate your user interface logic and coding from your user interface layout. For the general case, they're both *very* performant, but because they take very different approaches to databinding, either framework could have serious performance consequences in certain niche situations. The differences are thus: Knockout uses an immediate-mode update model while Angular uses a dirty-checking update model. What that means is that when you make a change to your viewmodel in Knockout, Knockout immediately re-renders the template. When you make a change to your viewmodel in Angular, nothing happens until all of the code you were executing completes, at which point Angular checks for changes to your viewmodels and then updates any affected templates. That means that Knockout can slow down significantly if you have a lot of things to update at once, like, say, updating every item in a repeated list (every row in a table, for example), because the template builds that list is rendered and re-rendered after every update. Angular, on the other hand, can handle all of those updates in a single execution pass (which is normally fast if you're not constantly rendering and re-rendering templates) and only update the affected templates once, but with the consequence that the more items Angular has to track for dirty-checking, the slower the overall application becomes. Both frameworks have techniques available to mitigate these issues, but they're important to know about. **TL;DR:** They're both great, but there are niche issues with both that you'll want to watch out for and/or mitigate. 
The two do go hand-in-hand, though. 
I have not, but I'll definitely look deeper at it later. I'm currently involved in a couple large projects with Ember. I've used angular before and wasn't very happy, felt unnecessarily complex. I like ember for it's object oriented nature and good separation of concerns. 
I know. When working on WebRx, I briefly considered to implement the same approach but scrapped the idea when I realized what could and most likely would happen: - "Hey, I've changed property *xyz* but the view isn't updating! -&gt; You forget to invoke *trackChanges* - "But I've invoked it!" - But too late, pal! - "No, right before wx.applyBindings()! -&gt; Sorry, the property list argument to *trackChanges* is missing property *xyz* - "Uh, oh okay, I better let the method handle all properties!" - "Hey, I don't know what's going on, but my performance now totally sucks!" -&gt; Hmm ok, looks like you are repeatedly changing property *zyz* which was not supposed to be included in the transformation, triggering a huge amount of change notifications The original list was actually longer :)
I actually made a remarkable recovery but now I'm aware of how weak my knowledge of JavaScript logic operators is.
I just created this short perf test of dom traversal http://jsperf.com/dquery-vs-jquery-part-1
I don't know if this is what you are asking about, but this project is a template for building react/flux projects in sails. https://github.com/availabs/dashboardTemplate You may be specifically interested in this little bit of code in the project https://github.com/availabs/dashboardTemplate/blob/master/tasks/config/browserify.js which runs browserfy (and reactify) to compile all jsx files in your assets folder. This may be modified to browserfy whatever you want for you client side code in sails with a little modification. Happy to answer any other questions if you have them.
If I'm going for a straight data-binding framework, knockout works very, very well. Angular is decent for many things, but it is difficult to build solutions that deal with large amounts of data and still manage performance. That's just my experience so far.
use bluebird.all or bluebird.spread https://github.com/petkaantonov/bluebird/blob/master/API.md
I never knew about bitHound, that's a pretty cool tool.
How do I differentiate between rejections from my promise and timeouts?
Indeed! Out of all of the ones I listed, that one probably provides me the most value.
And not even a single link/attribution to the _actual_ minifier? http://github.com/kangax/html-minifier
I'm on mobile, not very friendly!
ha I love the typo in the title as related to code quality.
Why not include eight? It's an industry standard. https://github.com/jackdcrawford/five/issues/161 
Observe functions like $watch in angular (though with less overhead AFAIK), you still need to manually modify anything that's bound to model you're observing when it changes. If all you need is two way binding it probably can fill in for a framework, but if you need to worry about isolating scopes, etc. you'll probably want to go with a more robust framework (angular, knockout, etc.)
It's from Microsoft. What's to like?
Angular does more than Knockout does. Don't try and build a whole app with just Knockout. But, for just data-binding I prefer knockout's observable approach, except for the cases where you end up having to manually notify or manually tell things a mutation has occurred. That can get a little grimy. There should be a support group for people who've had to deal with parent.hasMutated = true;
As for your MVC questions have you actually used any frameworks that use the MVC pattern (like Angular or backbone)? Have you ever been introduced to the pattern before? It's a general software engineering pattern that is good to know outside of any programming language specific details. Here's a great reading resource on design patterns in general that covers some mvc design pattern details: http://addyosmani.com/resources/essentialjsdesignpatterns/book/#detailmvc Here's a way to prep for general interview questions for front end engineering. https://github.com/h5bp/Front-end-Developer-Interview-Questions If you have any questions feel free to pm me I'd love to try and help to some degree.
If you use "Java" as a bad word, you apparently dislike everything about it. Having standardized doc comments would also make it more like Java. Having classes and an import mechanism made it more like Java. Better tooling would make it more like Java. 64 bit integers will make it more like Java. Only using === and !== makes it more like Java. So, really, the phrase "turn JS into Java" is a really dumb thing to say. I'm really tired of it. By the way did you look at the other in-browser scripting language of that time? ViolaWWW's scripting existed before and so did Nombas' Cmm (C minus minus). Well, given that Cmm was based on C, it just wasn't as trendy as JavaScript which was, according to the casual observer, obviously based on Java. It must be, given that name and syntactical similarities. Cmm didn't look that bad: http://www.brent-noorda.com/nombas/bbs/share/docs/CMM_VS_C.DOC.txt http://www.brent-noorda.com/nombas/us/desk3/manual/index.htm If you would evolve that for 20 years, you should end up with something nice. It didn't do type coercion and had things like multidimensional arrays, ints, and raw strings. It also had a way to import other files.
Don't know but Angular2 uses this now... 
Thank you for the reply. That link for MVC looks solid. I will study that. That second link looks good too, I think I've seen it before. Is there an answer key to it?
Something something Big Lebowski.
It extends ES6 with things which make it more toolable. If you prioritize that kind of thing, you'll like TS better than ES6. The downside of a strict superset is that it can't omit any of the silly bits. However, now that there are some types, real-time analysis, and a compile step, your editor/IDE can at least warn you about some of the obvious mistakes. http://i.imgur.com/QZXgGGH.png (types from literals) http://i.imgur.com/MCUX2ml.png (types from annotations) Personally, I prefer Dart since it's the cleaner language with more straightforward runtime semantics. They do look and feel fairly similar though.
*[Why are some people] lol
Little advice: programmers like to take their time. No one is sitting around with a stop watch for simple problems. Make the problems harder, but give infinite time. 
I strongly recommend moving to Kefir. We just moved our codebase from Bacon to Kefir. Performance was a big deal to us, but also Bacon has a really bad bug with synchronous streams. I also prefer the Kefir author's philosophy around a minimal API surface.
Have you tried to do the Angular2 dev preview demo? I was messing with this earlier today and it seems like this guide might be hosed. Cloning the repo exactly and running has some obscure errors: https://angular.io/docs/js/latest/quickstart.html. As my first experience with Typescript, I'd have to say it was quite obscure and confusing. I'm still not entirely sure why System.js and Traceur are required when they have you npm install typescript and run the watch/compile step.
I'm in the middle of a re-write. Code coverage are now 57% btw. Benchmark will be published after the rewrite are done. My main focus have been now to create React compliant virtual DOM objects that can be used in React render() .
Good idea on throwing a specific type of error, I like co better because I find debugging in it easier. I also prefer returning a new Promise as opposed to bluebird mutating the promise
I don't really see the point of these. Can they work off line? Where is the data stored?
Sidebar: Sometimes I think hiring managers are just making up shit to do / gauntlets to run through. If you have a github account and projects on there, that should be enough.
Slick is pretty excellent. And there is a react wrapper. https://www.npmjs.com/package/react-slick
Yeah this is stupid right? 
I changed too much in an attempt to make it cleaner, but take a look at this: http://jsfiddle.net/nicmendoza/kdb1jqhd/1/
Agreed. Use an editor with syntax highlighting. It'll help you clean this up and get to a good starting point.
You're right, I still prefer bluebird for the debugging aspect
I actually looked at this one, but as far as I could tell it needed jquery?
The assignment that I'm doing for class only has us doing the Java script, I'm brand new. Something like 4 weeks into learning javascript so I'm running into a lot of problems. 
Could you by any chance recommend any editors that have syntax highlighting to me? I'm open to any tips or tricks that anyone can give to me!
Really appreciate you taking the time to look at it, does exactly what I want it to do. Is there a simpler method(such as something that I missed) that would make it output?
Start here: [Mocha](http://mochajs.org/) or [Jasmine](https://jasmine.github.io/) If you need spies/stubs/mocks, go here: [Sinon.JS](http://sinonjs.org/) Let me know if you need more info.
ES6 doesn't have type annotations. TypeScript does use that syntax.
But is this a right approach to reload page after asking server?? I mean is there any way like as soon new deployment is done, user any action will reload the page or ask user to reload.
TS 1.5 beta (the first version which supports decorators) was released 5 days ago. http://blogs.msdn.com/b/typescript/archive/2015/04/30/announcing-typescript-1-5-beta.aspx Give it a some time.
Ok. Thanks :)
Also check out /r/learnjavascript they have a good amount of material
Looks like nothing important, just a fanatical commitment to semver. The following are the only stated breaking changes: - V8 upgrade to 4.2, minor changes to C++ API - `os.tmpdir()` is now cross-platform consistent and will no longer returns a path with a trailing slash on any platform
I just tell potential employers that I'm not going to do a programming test. I have an extensive work history. I have rock solid references. I contribute to multiple open source projects. I've *released* multiple open source projects. I'm an advisor to multiple tech start-ups. Fuck code tests.
Just use Sublime Text: http://www.sublimetext.com/. You do not need a full out IDE for just JavaScript.
Man this is /r/shitpost That post about T3 is garbage.
If the timeout ends up just being thrown like any other exception, it seems to prove the point that a separate callback is unnecessary - it's just a rejection like any other, except maybe with a specific error type. What I think you're saying Dart does, if converted to promises, is this: var p = new Promise(); p.then(() =&gt; {}, () =&gt; {}, /* timeout */ () =&gt; {}) But I don't see any value in separating timeout from other errors - it's easier to just do p.then(() =&gt; {}, () =&gt; { /* handle timeout and other errors */). What justifies treating timeout specially? Why not have a separate callback for different classes of errors like syntax errors?
It gets your site into each company's app store, which is valuable. On Windows, it also gets you access to native APIs directly from the browser using JS feature detection, which enables some completely new experiences. Android has been helping surface these app/site hybrids better in the browser, but being in the Play Store is still better if you want people to think of you as an app and not just a site.
&gt; a separate callback is unnecessary It's a method like "then" or "catchError". Try porting the Dart example to ES6's promises. "f1" is a "promise" which completes in x msec. I then create another "promise" which will throw an exception in y msec if "f1" isn't completed by then. If it's done in time, it will complete with the value it got from "f1". So, as it is, the output is "ohai". If I change that "100" to "1100", I'd get "on noes".
$.ajax is a big thing, though. I don't think I've written any non-trivial jQuery script that didn't include $.ajax() in some fashion or another. Otherwise it looks great, it would be awesome to just be able to replace jQuery with a lighter alternative.
/u/CanadianSpy is totes a Ruby ninja, and I want to have his bebe's.
Dude I misunderstood completely. I see what you're saying now. Basically Dart has Promise.prototype.timeout(n) that does the wrapping this library does, but built-in. Yes, ES6 promises are missing many useful promise helpers. I suspect people who do advanced promise stuff will continue to use libraries.
Mocha and/or Jasmine is a good start. These are the most popular testing frameworks. Assert libraries that may work for you Expectjs, Shouldjs, Chai. I'm using https://github.com/krasimir/atomus as a headless browser. It also provides methods for mocking ajax calls.
Why? Did you get bum fucked by one recently?
I don't know what came over me.
yeah, but even for development, including a file multiple times may sometimes bite you. Also... file order. Shouldn't jquery be loaded _before_ bootstrap?
In case you're interested, I added a ES6 port to [my comment above](http://www.reddit.com/r/javascript/comments/34uyab/w8_give_your_promises_time_limits/cqyp1gq). It doesn't look too bad, but it's not the kind of stuff I could write from the top of my head. The Dart version, on the other hand, was something I could write down without thinking. Didn't even take me a minute.
Yup, that's what I thought. It can of course only replace the rendering part as you say. And it's not really part if the tutorial scope.
Neat game but I do agree with some of the other comments about the timer. Maybe have an option for difficulty where the timer can be removed?
I ask this because I'm learning CoffeeScript, I don't know the differences between CoffeeScript and TypeScript. [I've recently seen that Angular has switched to TypeScript](http://blogs.msdn.com/b/typescript/archive/2015/03/05/angular-2-0-built-on-typescript.aspx) and I don't know what I *should* do: leave Angular (to Ember/React) or learn TypeScript.
All you missed at the end of your BMI_form() function after you assign the calculation to the BMI variable, you then need to output it into the HTML element. Something like: var BMI=weight * 703/Math.pow(height,2); document.getElementById("BMI").value = BMI; } 
io.js follows [Semantic Versioning](http://semver.org). It's your right to disagree with that versioning scheme, but iojs is trying to follow it correctly. Specifically, the "minor changes to C++ API" mentioned in the V8 upgrade to 4.2 *is* a breaking change. Thus, as soon as they adopted V8 4.2, the major version number had to increment. Else they would no longer be following semver. "Let's bump the minor number every week" is due to them incorporating fixes that add functionality. Per semver, they are required to bump the minor number, no matter how little functionality is added. Instead of MAJOR.MINOR.PATCH, it might help to think of it as API_BREAK.NEW_FEATURES.BUG_FIX .
their versioning is based on http://semver.org/
The JS part of problem solved by customisable [grunt plugin](https://github.com/tomastrajan/grunt-ngsrc). Find and add your angular.js source files into index.html automatically.
I prefer flow. TS treats typed code as the exception and untyped code as the default, flow is the other way around (using type hints to reason about implicit types). TS is a bit more verbose. The only advantage of using TS seems to be the tooling support, but that seems limited to Visual Studio.
http://christianalfoni.github.io/javascript/2015/02/06/plant-a-baobab-tree-in-your-flux-application.html
I believe this refers to the new shorthand syntax (see http://ariya.ofilabs.com/2013/02/es6-and-object-literal-property-value-shorthand.html and https://github.com/lukehoban/es6features#enhanced-object-literals ) Edit: per [this comment](http://www.reddit.com/r/node/comments/34vktg/iojs_just_released_version_200/cqymso0), computed property syntax is still behind a flag, but shorthand syntax is in.
I have contradictory feelings about TypeScript. I like it but I also dislike it. My beef is not with TypeScript as a project. I like the project itself. My problem is that using types starts to steal from the awesomeness of interpreted scripts. Interpreted scripts are so malleable, the APIs tend to be simpler, the final contract among the systems happens at runtime only, and from edit to reload it may take just a quick refresh... About TypeScript I hear that its compiler can be a little slow, for example. Compilers have to do a lot of work to ensure that everything checks. Since running the compiler is not exactly fun, a lot of the effort to ensure that your program is about to be compiled successfully is done by IDEs instead at real-time as you're coding it. But the IDEs are huge monsters. IDEs may speak in terms of projects, not in terms of files like sometimes interpreted scripts prefer. With an IDE you may work on a single project at a time for more productivity. But with interpreted scripts you would be able to work on countless files at the same time, with no huge need to bundle files before you could see how they run... But JavaScript has been changing lately... More "transpilers", more "bundling of files", more "build time checking and packaging"... The problem is that those steps may add extra time to the development process... And then perhaps having an IDE to share the load with would make sense, so in the end TypeScript would do all of that by default for you. And that's where we are at.
Nope, not at all. But you're example doesn't necessarily have the constructor reference itself directly. It defines the `create()` method and it is that method which is the one calling the constructor. But the constructor can still reference itself. For example you may see people use the constructor in the constructor as a protection against calling the constructor but forgetting to include `new`. var A = function(name) { if (this instanceof A === false) return new A(name); ... } Here, if new isnt used, the this reference in the constructor is not an instance A so instead of allowing the rest of the code to execute, an instance of A (which is calling the constructor with new) is returned. 
Blasphemy. How dare you question a the jQuery religion.
Shouldn't you have written it in Ruby instead? It looks like Java to me. Either Ruby or if you wanted to distribute it to others in Go. :-) As an exercise I'd write it in Ruby and compare the different implementations. Ruby's glob pattern matching is rather useful for these things.
I use TypeScript extensively at work and I've come to have mixed feelings about it. The visual studio tooling is pretty decent, but that's only useful if your using visual studio to begin with. Although TypeScript is aligning to ES6, it's quite far behind transpilers such as babel and tracuer. This isn't an issue for everyone but if your looking to use ES6 features such as generators this presents a problem. One of the nice features is you can use it incrementally. Typescript is just a superset of js so all js is valid Typescript. This means to get started you can just save an existing file as a ts, make sure you have a compiler setup (through visual studio, gulp, grunt etc) and your good to go. From there you could start slowly added type declarations and the various other features. In terms to type checking, the two big players are TypeScript and flow. If you solely want type checking, flow is probably best as you don't need to the various TypeScript extras. Overall, TypeScript is by no means bad, but it's not incredible either. It's all about the use case and what your looking for. If your working in the Microsoft stack like I am with Visual Studio, it's great. If you solely want static typing, look at flow. If you looking for the best of ES6, stick to normal js and babel. One more thing to point out, as of the time of writing this the TypeScript compiler doesn't support JSX, which is worth being mindful of if you use React JS. This might change in the future as one of the top feature requests for Microsoft and Visual Studio is to provide better support for React.
Maybe they wanted to keep the changes more contextual to try to avoid conflicts, since features that are introduced globally may for example run into naming conflicts with any of the millions of JavaScript applications running on browsers today. I also prefer a more OO approach to it, but in some ways it's too late for them to add features like that. I mean, they are trying to add OO features with ES6 like being able to inherit from DOM classes and such. But it's very tricky even just that. When language implementers foresee that they may need for example a keyword in the future, they will make it reserved before that just so no one will use the name in a conflicting way. When they cannot reserve words like that, they may opt for more contextual changes instead.
Serious question, how are bug fixes *not* breaking API changes?
Same here!
yep! just uploaded the code! THANK GOD -.-
A tagged template does not always return a string. See here: https://www.npmjs.com/package/asm-tag https://www.npmjs.com/package/digraph-tag
This is brilliant! Is there any backstory? 
REPL history persistence is a nice improvement IMO. 
Besides the new features, it would be really nice to see the efforts of the two teams converge to the same path.
By 'code quality' do they mean that a linter like JSHint would be run on the code? Or is it something beyond that? 
I think the idea is that it is not supposed to look like a function invocation, but more like native syntax. Thus, opening the door to better DSL support. Also having the tag appear at the start of the string is especially useful when you have a large multiline string. The tag is important information which would otherwise be hard to see if it were buried at the end. 
That would probably depend on what conversation is had with the server. I probably wouldn't go so far as to say "If any byte changes, reload it all!", but instead something smarter like letting the developer say "This is a major enough of a change, users should update when able", or "This is client/server communication change, users must update before continuing".
This is where you should tell the potential employer you aren't interested in doing a "coding challenge." They should be able to hire you based on your interviewing and you aren't open to doing free work for them. If they don't feel comfortable hiring you without asking for free work, then they aren't somewhere you want to work.
Nice work. Love the lap graph – never seen it before.
Did you even bother reading the article? I pretty explicitly states how to use the tool.
how are they? The bugs aren't the API. Take for example, a fictitious bug in copying a file. It works fine in all platforms, except when the folder has a - in it, wasn't tested for and made it into release. if they fix this bug properly, it will simply increase the bug fix number, as the same code that would not have worked earlier on will now work properly, nothing has to change programming wise to make it work. If the developer created a work around, well that will still work too. But if another developer is using an older version, hits the bug, and realizes a simple update will fix it with out breaking other things, he updates and continues on with his task. That's the power of semver, you can blindly update bug fixes, provided you have faith in the project you're using to follow semver. So in this case, i don't care if one day it's io.js 500.2.27 for the version because i'll know for sure my code is compatible with 500.2.52. 
Oh sweet baby Jesus, I was hoping I wouldn't have to pick at one point!
As a transitioning Java developer I chuckle at the thought of people thinking nodejs release cycles are too slow and constrained 
I like that they are getting back together to move everything forward (I hope).
Hi systemUp, You're absolutely right- it does go beyond basic linting. Features include things like: Scoring and analysis by project, branch (multiple), file and commit, Dependency analysis checking for out-of-date packages and security vulnerabilities, Support for JavaScript and JSX, Insight into issues impacting the code base. Would love for you to check it out and let me know what you think! 
Ah makes sense, I think I'll hold off on 2.0 for a bit.
&gt; I'm learning CoffeeScript please don't
Rails marries everything very tightly together. They specifically want rails and the only right way would be to use a gem.
I like Atom-Typescript because it doesn't slow down my workflow. It'll compile on save pretty much instantly, and I can refresh my browser to test it, just like if I were writing plain JS. JS isn't *that* malleable; it's full of types. getElementById returns an HTMLElement type. WebGLRenderingContext.uniform1i takes a WebGLUniformLocation type and a number type and returns nothing. If you don't know what types are going in and out of your functions it's more difficult to debug. TypeScript makes it a lot easier to catch these errors as well as to understand the code and APIs you're using.
am I old fashioned for finding that "property / value have the same name" shorthand syntax to be sort of objectionable? I guess maybe I'd get used to it, but I'd rather be verbose and explicit with my definitions. Magic under the hood just for the sake of saving me a few keystrokes and/or bytes in defining an object literal seems excessive.
Command line launch arguments, like `--harmony-computed-property-names`
It's like constitutional law; amenable to interpretation on a case by case basis. Semver just helps set large-scale expectations. Ultimately you still have to work carefully to not disrupt the ecosystem.
Do you use flow with babel or just es5?
I'm with you! I prefer clarity over shorthand. 
My guess is somebody may not want babel, so they don't automatically bundle it in an effort to reduce code bloat 
I tried to run Babel like that. I used it to run the code on the fly rather than to first compile it and then run it separately. It was taking I think about 0.6s to run a sample for me. It feels like running a compiler, whereas JavaScript is interpreted and can run a sample in I don't know, 0.1s? And for larger projects it would take much longer to run Babel on them all the time. Modules pull other modules and everything is loaded from separate files which is slow to do for larger projects. The fastest compilers used to be written in C. One of the fastest compilers we had was the one that compiled Delphi. Then with Java they started creating incremental compilers that were also fast enough. Nowadays the Go programming language seems to have a fast compiler as well. I think that Babel is not necessarily as optimized as those. In Dart they have a feature that creates a static snapshot of a program so that when you run it again, it already includes everything it needs in just that one file. With a snapshot you improve startup by a lot even in an "interpreted" language like Dart. I think they may use snapshots on Android too. I don't think that Node or V8 support snapshots for JavaScript yet. But it's a great idea if they ever do. Then Babel could at least startup faster. Then its compiler could be further optimized and still enjoy performance improvements by newer versions of V8. Then who knows we would run Babel like every time! :-)
Ah okay, got it. Thanks!
Okay, that makes sense. But consider this situation: I create a module that has a `flatten()` method that takes a nested array and flattens it. That is all the documentation says. Without realizing it or testing for it, it turns out that my `flatten()` method will actually only flatten the first level of nested arrays. I release 1.0.0 and after a few months there are ten other modules that are dependent on mine. I start using my own module for a new project and run into a situation where I am passing the `flatten()` method an array of arrays of arrays. I notice straight away that my flattened array still contains the second level of nested arrays. This is a bug in my opinion since my documentation clearly stated that it should flatten the passed nested array. I make the changes to my module so that it will now recursively flatten the passed nested array and release it as 1.0.1. The next day I have a dozen GitHub notifications for issues filed against my module's repo for publishing a breaking change as a patch version. I defend my position by saying that the documented API has not changed, and that not recursively flattening the nested array was a bug from the beginning. Who is correct in this situation? What if the bug was reversed so that initially it *did* recursively flatten the nested array, but I considered that a bug and changed it to only flatten the first level of nested arrays?
if you want to be explicit then use variable names that differ. or... be explicit. it's not like the old syntax is invalid. 
Doesn't the localStorage API also include the `storage` event, which triggers on any and all windows connected to the same localStorage store, and sending lots of useful information? That seems like it would be much more useful than rolling your own implementation which doesn't have the same sort of synchronisation guarantees.
I wonder if there are any plans to get a better standard library than Node does (or maybe it already has it, since I haven't tried io.js yet). In my opinion, this is where io.js can really shine, since the Node standard library is minuscule compared to, say, Python. It would definitely get me to start using it for my next project.
This is definitely it. It's never a good idea to force something optional on developers, and the idea is that V8 will eventually support all ES6 features natively. It's also only one line of code once the package is installed, doesn't get easier. require("babel/register");
Probably but my ruby file io is non existent and it's fairly trivial to make a system call in,ruby anyway to execute the java program. Your right though I should have made it in Ruby. One less project in my repo list.
The "storage" event is not firing properly on all the browser (as far as I tested it). And it's not firing in the same window. Otherwise you are right. It is much better using it.
Here ya go! http://codepen.io/anon/pen/VLvbwY
&gt; it's not like the old syntax is invalid. of course not, but I do a fair amount of open source work, and even in my career I've rarely worked on a project alone.
Quick Google found this example [storage events](http://html5demos.com/storage-events)
Coffeescript was good for it's time, but it doesn't really do anything that can't be done with es6. Plus the different syntax is gonna throw people off. You're better doing learning the actual language spec. With babel or iojs you can do es6 today, and a few es7 things as well
It does include it, its just not compatible
Since NPM is integrated into Node.js/IO.js, *every* library can be used almost as easily as if it were a standard library.
I guess my phrasing "nothing important" was overly broad and wrong - it's "important" to people writing code for it - but from the perspective of the io.js codebase, it's just a dependency update. Even the dependency being updated didn't think it was worth a major version bump.
What do you think of this? http://codepen.io/anon/pen/doYWzG
I'll test to see if there are any issues with "same origin policy". The app that I'm working on will be placed in an iframe. So, I'm running it locally but placing it in an iframe so I can see how it behaves.
I think I was just RickRolled? 
Yes, they are breaking changes. Don't say it though, or you'll get downvoted to hell.
Yep. While studying we did a ton of Java, and I did some PHP early on at work. And now I've started doing Javascript full-time (React) and I can barely keep up with all the new releases!
Hmm... not really clear. Can you paste your code?
About the release speed of JS/Ecmascript, how do schools keep up? I know a school that teaches web development, so my guess is that JS is gonna be a core part of that education. Are the teachers supposed to really keep up with, say, React's(or any other big library/framework for that matter) release cycles? What's being taught in your first year might be completely different once you graduate. Java, C, C++, or any other "big" languages for the desktop are a bit slower than JS's libs/frameworks, right? Surely that must be easier to teach and add to a curriculum. 
 var str = '&lt;input name="desc" value="THIS IS THE STRING I WANT TO EXTRACT" size="20" maxlength="240" id="product_name" type="text"&gt;'; // 1 console.log(str.match(/value="(.*?)"/)[1]); // 2 var tmpEl = document.createElement('div'); tmpEl.innerHTML = str; console.log(tmpEl.children[0].value);
Right which is why I asked my first question: how are bug fixes *not* breaking API changes? If I fix a bug then I'm changing the previous behavior and according to you: even if it's not what I initially intended, it needs a major release to do so because even though it's technically a bug, people relied on the bugged behavior.
Most schools cannot keep up and are unaware that they should try. That's another reason most schools are obsolete. Learning should be self-paced based on physics and biology since no one can learn at anyone else's pace. Also, you don't need a school. You can use Google and online manuals and tutorials as well as other online resources like reddit or Stack Overflow.
&gt; That's another reason most schools are obsolete. While the webdev field changes very quickly, other fields within computers don't. Schools that offer a comp sci program that gets outdated within 5 years are doing it wrong, since they should be teaching computer science which is far slower changing, not software engineering.
&gt; * Your first example seems to suggest the template string has a prototype chain like Array or Number Does it not? The DSL rationale makes some sense to me but in reality the only big win here is multiline strings. 
There is a babel-node if that's what you want https://babeljs.io/docs/usage/cli/ 
Wish fulfilled! ;)
Yay so programmers gonna like the last release since I removed the timer :)
Thank you for the feedback murdocsvan! Yes, you're right. The life bar increase when you're right and decrease when you're wrong. I made some major changes to improve the gameplay. Oh and the mobile experience should be much better now :)
How do I know ahead of time if people are relying on the bugged behavior?
Hopefully you will not have to fork it, I just moved the timer to a "hardcore" mode :) Give it a try and eventually let me know how it feels now!
Funny trick! :P The good news is that you don't need a hack to remove the timer anymore :)
I doubt most people will use the property / value having the same name shorthand anyways. The function shorthand is very nice, but most people will probably writing those in classes anyways, not object literals. The dynamic property names are also very handy for defining properties inline, so you don't need to define the object and then define the property in a following statement.
Thank you very much for your suggestions viisi! I made some major changes to the gameplay, you may appreciate it :) If you want to contribute (add questions, suggest some features and so on), feel free to report it here: https://github.com/Zhouzi/logicalornot or on twitter (@zh0uzi). I'd be definitely grateful!
if you can't trust the guy who wrote the library you're using to have common sense, why use the library?
then don't use semver.
I guess maybe I did :) Kinda dislike the fact there's so little I can do without having to look up some or another module, though.
Well, it's just String.prototype, not a new class or type. `foo`.trim() &lt;-- works `foo`.parse(tag) &lt;-- String.prototype.parse is undefined
yes, i use node.js in my work. i've been seeing io.js a lot but haven't looked into it. are all node.js packages compatible with io.js?
What is "common sense" to one person may not be "common sense" to another.
Took a web programming course about a year ago. Concepts were broad strokes, e.g. HTTP basics, REST, client-server, p2p, SPA. We specifically learned Node, HTML/CSS, some basic jQuery, but it was all in the concept of general web practices. Curriculum was basically designed so you could swap in and out different technologies and it would still be relevant.
It depends on what the elements are - if they are things like text and images, you can use HTML5 Canvas to draw that stuff. Just start a data structure with the, say, image source and x/y position of the image. If you want zoom and pan within the canvas, start another variable with x,y for pan offset and z for zoom. Have one re-draw method that loops through the images, draws each image at (view.x + image.x), (view.y + image.y) and scales the image to view.z Hook up some UI where the user can change the zoom view.z, and trigger a re-draw. If you include mouse events, you could hook up pan to view.x and view.y
Which of the following do you prefer? `foo`.tag().trim() //or tag`foo`.trim()
hardly, I use libraries all day long that don't use semver, i simply don't upgrade those ones as I can't trust them to have rational versioning.
People are loving your game at my work btw :) You should add more languages, fix up the design, throw some ads on the page... boom easy income.
This was why I stopped using rails. By the time I was ready to release, the version I was using was outdated.
Awesome news. Anybody know of an online demo using Glimmer?
Ask people who use your code?
You're right of course, I just wish people could see past the large center aligned sales pitch sites with big fonts and animate on scroll graphics for what they are. I went the other way, i.e the website is the App which is the framework, ready to download, ready to deploy. It's functional but diabolical at selling itself. I know it! Even though the message box says you can see the code behind any page, it's the extra click which kills it.
Simply have a window and a container, make the `.window` a fixed size with `overflow:hidden`, and with the `.container` use a CSS transform of `scale` to adjust `.container`s size. &lt;div class="window" style="overflow:hidden"&gt; &lt;div class="container" style="transform: scale(2)"&gt; page goes here &lt;/div&gt; &lt;/div&gt; You could obviously set a `transition: transform 1s linear` to animate the zoom when you change the `scale(n)` in JavaScript. Here's one I did for an [Anzac Celebration](http://www.maoritelevision.com/tv/shows/anzac-2015/place-poppy) that also featured parallax. Unfortunately I didn't have time to hook up inertial mobile stuff to make the effects more subtle so it just tracks mouse position.
What skills? You can learn any framework or another "advanced" web "technology" in weeks, unless you don't know how to implement linked list, of course.
Yep. While the frameworks and tools are evolving at a very quick pace. The principles and concepts have changed at a much slower pace. Get a solid grounding on the concepts and you can pick up most tools and become productive pretty quickly.
Looks like their major releases are much less disrupting than rails major releases. Most of everything is in the same place, there were just a few breaking changes. Rails was insane with how fast and how much it changed from release to release. So bad that the only way you could really understand the API was by reading the source. Nobody seemed to be an expert in rails when I was using it (3x something)
Often, Bugs themselves are the breaking changes. Bug fixes are more of a return to normalcy than a breaking changes. However, bug is a wide net. Performance bug fixes may introduce no change in behavior. Logic bug fixes may fix things that never worked correctly. Security bug fixes may remove previously supported functionality. Part of the "should this be a minor/major/point version" discussion should include things like "how old is this issue, are people working around it currently, what are the ramifications of doing it the 'right' way?".
I think it's common and it makes sense—courses are taught by professors. You can't expect someone who is busy with research to look up and take the time to "keep up" with the industry. I would bet that even the Java/C++ I was taught is nothing like production Java/C++, because professors just used those languages to teach computer science concepts (poor choice, IMO). Still, though, I'll always be a bit mad about not doing Rails and instead doing super old PHP... and we were going to use Hartl's book too. The professor that changed it said that "we should learn how the web works without a framework"... but we never did anything more than accept forms and set cookies. If we had done Rails and everything had gone well, we would have learned HTTP and MVC fairly well with that book. Oh well, I read it over the summer.
position:absolute; Then you can specify for example left:20%; right:20%; Not too sure if this is what you wanted :/ Edit: You can also specify a z-index which says which element is stacked higher.
You don't need JavaScript - this is a CSS problem
http://shouldiuseacarousel.com/
Curious what you all think about this direction
From my understanding, the "minor changes to C++ API" were breaking changes, thus requiring a major version bump per semver (as mentioned in another comment, you can disagree with semver, but iojs appears to be trying to follow it correctly). 
I think this is the only one at the moment: https://dbmonster.firebaseapp.com/ Source is here: https://github.com/wycats/dbmonster
I would wager the role of designer and front end developer are completely different at google. More cs majors do front end now because the programming is getting to a level where the client app is as complex as the backend. Just about any front end developer can take a mock from a designer and recreate it in html, that is the easy part. There are some candidates with solid skills on both ends but they are rare, and it's not required by either of the respective roles (I would argue front end developers need solid understanding of ux and the theory though or its extremely difficult for them to contribute in planning, meetings, etc and they become the guy that can follow orders/spec well at best)
Something to be said for long release cycles for major versions. With rails it was literally every month or so. It moved so fast. I would write code and then have to upgrade before every deploy, which was usually a few times a month.
It's surprising I didn't find a post for this already. Either way, with the release of io.js v2.0.0, I figured more people are eager to try it out. Some are hesitant about the features, compatability. To them, why not just use both? Or rather, why not try out new versions with ease? :) You can't have 2 node's or npm's on your environment PATH. Enter nvm. nvm is a version manager for node.js/io.js. You can install multiple versions, and each has their own node_modules directory for global package installs. A new version of node or io.js came out; `nvm install io.jsv2.0.0`; done. There are two caveats with nvm and here are the workarounds: **It has to be sourced into to start up**. Sourcing nvm, alters your PATH and makes the selected node/npm available. The [directions on the site](https://github.com/creationix/nvm#manual-install), suggest adding it to your `~/.bashrc` file, so it happens when you open a terminal. nvm altering the PATH is problematic for software that looks for node/npm at start up, such as SublimeText's linter packages. If you're using zsh, you can simply move the code to `~/.zshenv`. For bash, I'd suggest adding it your login profile. I've actually altered the sourcing a bit to look for the nvm package on my Mac (which was installed with Homebrew). # NVM http://stackoverflow.com/questions/28017374/what-is-the-suggested-way-to-install-brew-node-js-io-js-nvm-npm-on-os-x export NVM_SYMLINK_CURRENT=true NVM_DIR=`brew --prefix nvm` source $NVM_DIR/nvm.sh export PATH=$PATH:$NVM_DIR/current/bin The other line here that I want to point out is `export NVM_SYMLINK_CURRENT=true`. This creates a `current` directory which points to the currently used node install. This directory exists even when nvm is not sourced. This is beneficial for software like Webstorm which wants you to specify **where** node is. What's better than always pointing to the same `current` directory? :) **Every install of node gets it's own `node_modules` directory**. This is because not every package is compatible with every version of nodejs (even though we'd like to think so). So when you install a new version, you can simply *copy* the packages from one version to another. nvm use 0.10.17 nvm copy-packages 0.10.10 Have fun trying out io.js :)
How exactly would you figure out what functionality something has without looking it up? Explain how you managed to find more of the Java internals without looking something up?
I see a typo. Should be `onclick` not `onlick`. Also `products` should be the name of your form and `selectedproduct` the name of your select input. I also recommend, at this level to start getting into jQuery.
Man, thank you so much. I think you just got me a new job. And saved my sanity.
Also, jQuery is next on my list.
[knockout](http://knockoutjs.com/) would also be an excellent choice for something like this. If you've ever done MVVM, or any sort of data-binding, knockout is very simple. It's not as heavy as angular, but still very powerful. Message me if you'd like more details.
How do you use them if you don't mind me asking?
onlick events...soon... 
Are you trying to render that form inside another form?
I don't understand the observable class, could you explain it? So it's a class but then instead of using literal functions you assign them to variables and I've never seen that syntax. class ObservableClass { subscriptions = []; on = function(handler){ this.subscriptions.push(handler) } notify = function(){ var args = arguments; for(var i = 0 ; i &lt; this.subscriptions.length; i++){ this.subscriptions[i].apply(null,args) } } }
Nice work to the Ember folks and a fantastic optimization and writeup! Just a tiny point of clarification, the text sort of makes it sound like this kind of optimization is not possible with virtual DOM (I'm assuming they are talking about React); however, Mithril supports a similar optimization via [subtree directives](http://lhorie.github.io/mithril/mithril.render.html#subtree-directives).
 class Popup: def __init__(self, containterId): # pop-up class will give us absolute position, high z-index and center the container self.$popup = $('#' + containerId).addClass('pop-up').mouseout(def(): self.hide() # unlike 'this', 'self' will reference the object itself ) self._$darkbg = $('#dark-bg') # overlays background with a dim layer to draw focus to the pop-up def show(self): self._$darkbg.show() self.$popup.show() def hide(self): self._$darkbg.hide() self.$popup.hide() You call that "... cleaner, more readable syntax."? You gotta be kidding me! 
When did Github turn into Tumblr? Those reaction gifs are annoying.
Thanks for the link. I still can't see the event fired in the same window though.
Hey, thanks for digging into the code. Indeed that may be a memory leek. I'll see how to fix it.
I used your code to test and indeed saw that on the receive tab the buffer is not cleared. But that's only in the beginning. Once the sender runs ls.removeItem(n); ls.removeItem(n + '-removeit'); the receiver also gets its buffer flushed because it goes to else if(!data) { buffer[namespace] = []; }
The point of this post was to see if there was a reliable resource that had common JS/MVC questions. Don't post a reply if it has zero useful input. You and people like you are what make the programming known for having arrogant assholes in it.
Yes you are right. The localStorage API works only if the two pages are on the same host and port.
It's related to the culture of certain projects. I find it as distasteful as you do.
looks like its just a html5 player, the new html5 video components r pretty nice :) 
Oh live a little.
Flash. You must never go there, Simba.
Ah, thanks, now I understand. I think I can handle it myself now, I have an idea of what to do. The only problem is that libgif-js library is slow, it takes ages to get the duration of a gif with it. The solution would be to upload the gif URL and duration to a mysql database. And then, make a seperate index.html, just for viewing, where it requests say, 10 URL's and their durations from the mysql table, and then plays it using the code you provided. 
I think you can already claim that :-) I'd love to hear more about your goals for the project, why you chose that particular project, and how you handle the challenges of being homeless and coding. Maybe do an AMA or blog post?
https://twitter.com/horse_js/status/595631349811261441
There are 2 &lt;video&gt; tags in their own containers placed on top of each other, when you use the hotkey (R) to "see the other side" the 1st video container will be moved out of the screen (so you will see the 2nd video).
&gt; How much has to be finished before I have a legitimate claim that **homeless people can program computers?** well you already did. You proofed that you can program a computer by programming something on a computer. I really like your spirit. Here are some questions and I'd love for you to answer if you find the time :) How do you access a computer with the necessary tools? Yes you can program with any texteditor, and there is no need for compilation with html/js/css etc., but still. How do you pay for it? Did you have had any "IT" education before you started? How did you learn what you know now?
It's also a work in progress. If he said it was complete, we would likely have raised more issues. But since the majority of his project is backend JS, frontend Dev generally gets sidelined till close to launch. Good criticism though! People need feedback to improve, and I was being selfish in asking what I wanted to know without providing feedback. 
Yeah, and the JS isn't really up to par either. I'm really impressed by the effort, and hell the fact that it works - but there isn't really excusing a switch statement that starts on line 4850 and ends on line 5919, inline. I would not like to be the person who has to maintain that. 
&gt; talk about his javascript He has an inline switch statement that goes for over 1000 lines.
&gt; I am attempting to write enough JavaScript to prove that homeless people (such as myself) are just as capable of writing software as any rich person Good luck to you, but I've never heard anyone who would seriously claim that just because someone's homeless that they therefore aren't capable of learning programming. They might assume they don't *already* know how to program, but that's a totally different assumption... and one that's perfectly reasonable even when applied to *non*-homeless people. Can I ask what's motivated this attempt, and - with respect - have you checked you aren't wrestling a straw man? &gt; How much programming do I have to actually get running before I have proven that homeless people are people too? I'm not sure you can ever do that. If someone doesn't think homeless people are "real" people then I don't think being able to write code (which, in the limit case, even a computer can do) will suddenly make them think you're a person. I can see you feel you have something to prove, but the question is incoherent - it reads a little like "how many fruit-tarts do I have to make before people agree that Radiohead are a good band?". There's just no connection between the activity and the end goal. *No* amount of making fruit tarts will realistically alter or affect Radiohead's position in the charts or degree of critical acclaim one iota. I applaud the work you've already done and your passion for doing more (and please don't let this comment dissuade you - you obviously have some skills in this area), but: 1. You've already proven homeless people can program, because you're one and you obviously can (and to quite a passable standard, if you're implementing your own interpreter). 2. If you're trying to fix the problem in society whereby people dehumanise and dismiss the homeless, I doubt *any* amount of programming will ever fix that. Even if you somehow became world-famous for your skills and contributions while still remaining homeless, they'd just mentally file you as a special edge-case and maintain their existing prejudices. If you were really going to "prove" to people that homeless people could program (and therefore - through some bizarre logic - were "real people") I'd imagine nothing short of a decent fraction of *all* programmers being homeless (or vice-versa - a decent fraction of all homeless people being programmers) would do it. You'd need enough coverage such that any time a non-homeless person interacted with a homeless person there was a decent chance that the homeless person would know how to code, in order to create a public perception that "homeless person" and "programmer" were associated concepts. If you're trying to convince society to change its attitudes to a whole subset of that society you need a society-level influence, and no one guy writing code is ever going to do that, even if he rose to national or international prominence.
It's a library and yes, there are actually 3 of them (does this make it a collection of libraries?). The utility functions expand (no pun intended) on the lodash features, adding the assertion system and missing functions. Everything you can find in lodash is also present here, and more. The extra features are just shortcuts for what we found to be redundant work while writing OOP in JavaScript. You could write your own validators, observers and so on, but every time you need to write a new class you have to start from scratch. Using the Class system we provide you already have all these features at your fingertips. We are not trying to compete with the ES6 Classes, as soon as ES6 becomes officially supported by browsers we will implement it instead of the ES5 solution we have now. --- &gt; Putting it all together makes it difficult to judge what you've built. Could you elaborate? &gt; For documentation sites, I vastly prefer single page. Makes it extremely easy to jump around and not lose context. Do you mean like [this](https://lodash.com/docs)? Having a single huge page with all those DOM nodes seems like it would wreck the performance on mobile.
&gt; No employer cares if you're homeless. In an ideal world this would be true. In the real world - sadly - they often will. If nothing else, a lot of employers/interviewers will associate homelessness with poor planning abilities and/or poor socialisation, lack of resources and stability, unreliability or lack of education, substance (or other) addiction and/or financial difficulties... none of which are appealing to employers. It might not alter the decision if the candidate is really good and there are no other candidates realistically competing with them for the same job, but you can bet your life it'll at least be factored into any hire/no-hire decision. I agree that in an ideal world a person *should* be able to walk into any job interview, have it emerge in casual conversation that they're homeless and not have it count against them (and it might be the case in a handful of really enlightened, trendy companies in a handful of industries), but for the overwhelming majority of jobs in the overwhelming majority of industries (including programming/IT) you're still going to get judged for it, and hard.
Thank you!
You might consider taking a peek at [Github](https://github.com) for hosting and sharing your code. It has a lot of tools for keeping track of changes to your code, and tracking things you need/want to do. The biggest advantage it offers is giving you free, reliable hosting of your code, and making it easy for others to use/contribute to your code. You don't necessarily need a computer with git installed to be able to take advantage of Github, but it does help to know [what git is and how it works](https://git-scm.com/book/en/v2). You can create files and edit them in your browser on Github, and there is a Github app which provides much of the same functionalities on android, if you have a smart phone. As for your code, there's some squawking about how poorly it's written. Mostly, these complaints are about how *maintainable* the code is. If this were handed off to someone who'd never seen or heard about this, and they were expected to do things with it or make changes to it, it would take a long time for them to analyze the file and understand how it works, and it's written in such a way that makes finding where things are difficult. I suggest trying to get your hands on some materials that teach programming patterns for javascript. As an example, you have a switch statement for rotating your welcome messages between different languages. You could store this in an object defined outside the updater function, like so: var i18n = { 1: { /* Afrikaans */ welcomeString: 'Welkom!!!', drawpicturesString: 'prentjies teken', learnmathString: 'verstaan wiskunde', programcomputersString: 'program rekenaars', buildgamesString: 'bou speletjies', havefunString: 'om pret te h\u00EA', /* e with circumflex  */ startString: 'begin', englishlanguageindicator: 'Afrikaans', nativelanguageindicator: 'Afrikaans', languagescript: "Roman" }, 2: { /* Albanian */ welcomeString: 'i mir\u00EBpritur!!!', /* e with umlaut ‘ */ drawpicturesString: 'barazim fotot', learnmathString: 'kuptuar matematik\u00EB', /* e with umlaut ‘ */ programcomputersString: 'kompjuter\u00EBt e programit', /* e with umlaut ‘ */ buildgamesString: 't\u00EB nd\u00EBrtuar lojra', /* e with umlaut ‘ */ havefunString: 'k\u00EBnaqeni', /* e with umlaut ‘ */ /* enjoy yourself */ startString: 'filloj', englishlanguageindicator: 'Albanian', nativelanguageindicator: 'shqiptar', languagescript: "Roman", }, /* etc. */ } and then have your function update the messages like so: $.welcomeString = i18n[$.animationlanguage].welcomeString; $.drawpicturesString = i18n[$.animationlanguage].drawpicturesString; $.learnmathString = i18n[$.animationlanguage].learnmathString; $.programcomputersString = i18n[$.animationlanguage].programcomputersString; $.buildgamesString = i18n[$.animationlanguage].buildgamesString; $.havefunString = i18n[$.animationlanguage].havefunString; $.startString = i18n[$.animationlanguage].startString; $.englishlanguageindicator = i18n[$.animationlanguage].englishlanguageindicator; $.nativelanguageindicator = i18n[$.animationlanguage].nativelanguageindicator; $.languagescript = i18n[$.animationlanguage].languagescript; There is likely an even more efficient way to do it than that, but at least this way, your program does not spend time iterating through a switch statement, instead performing a lookup during assignment exactly once every time the update function is called. A resource teaching programming patterns will hopefully help you tackle these sorts of issues in ways that make your program readable, maintainable and efficient. **edit**: /u/jkoudys wrote a reply to me with a much better method of doing it. Having never really worked with internationalization before, I could only offer advice that was a tiny step in the right direction i.e., not iterating a switch statement.
Homeless != stupid. The sentiment behind this project is flawed. Your website and code are typical of a new programmer so your background (homeless or whatever) is totally irrelevant.
I'm not sure if this is more maintainable or better architected.
I agree 100% I wonder why he doesn't pursue work in the industry and find a home. 
Well, this isn't learnprogramming, and OP hasn't asked for any help. So it would be kind of an asshole move to offer him/her unsolicited advice.
You might want to make your site look a little less like it was made by a homeless person. I've seen high school kids make better websites. No one is going to take your project seriously if it looks like a geocities page. 
Do you think it's obvious to a new javascripter whether trim() or tag() is run first?
No web designer is ever homeless - they just live behind a MacBook in their local coffee shop like all the others, but neglect to pay the rent on anywhere else. ;-p
&gt;Spent 2 months on nothing but a ~~registration~~ resignation
Thanks! That looks like what I was going for... Have some gold!
&gt; If forces you to compose your application not in terms of functions and objects, but in terms of directives and model-view-controller, and their flavor of model-view-controller. If you have to use MVC, then you can't leverage other architectures. Do you believe MVC to be the only way to organize a program with a user interface? 
No.
So, are you saying I should keep my job but sell my house and live on the street so we can all help this guy realize his dream of homeless programmers?
Don't torture yourself learn jQuery now. 
You've actually just said nothing in that entire paragraph. What is a better way? You claim MVC and OOP are overcomplicating things, but offer nothing to prove that your way or React's way is actually better beyond your personal opinion.
&gt;The Whiteout Mail generates the PGP key for you and puts it on a mail server. If you write an email, the client should look up the PGP keys for you and encrypt the message if there is a PGP kay available for the recipient. This sounds like (I hope) that you're talking about the public keys. Where is the private key stored when it is encrypted and/or at rest?
Uhm, do you? This is like economics or writing, not like mathematics or physics. It's not possible to be "right". The abstractions and paradigms we use in SW development is solely for humans being able to manage complexity. The computer is indifferent since it crunches everything down to ones and zeroes. The Design Patterns book that came in the nineties had some good ideas. Problem is it was turned into religion and widely misinterpreted. That is my opinon, not a fact or truth
https://github.com/neurosnap/neuronode/blob/master/src/routes/index.js#L27 https://github.com/neurosnap/neuronode/blob/master/public/js/src/index.js#L21 I'm using them on both the front and back end.
Right async/await will alleviate that problem. I come from python and coroutines are used in the same way ES6 uses them. 
nvm is awesome. I honestly wish it was a part of the official package. It makes upgrading and testing in different versions incredibly easy.
If you've done nothing on the server-side, the server will not automatically allow you to do this. You need some application on the server that handles your POST request and does something with the request body.
Problems like this and the inability to mixin helpers makes me wonder if the class syntax will ever catch on. Classes seem to just make React harder to write and maintain.
Right on. I've always been focused on three core issues: * Does it break? Is it unreliable? * Can we build more with it? * Can we maintain it? If, economically considered, the answer is yes to all three of those core questions (and enough of their derivative questions) who cares what the architecture is? There are some people that consistently write software that results in a 'no' response to an item in the list above. Those people are doing it wrong. 
Version 78. Fantastic.
&gt; What you youngsters call "SPA" or "frontend frameworks" are client/server of the nineties reinvented, but much better i might add since we have a client that intstalls at runtime and a webbrowser security model that allows that. I'm nowhere as experienced as you but I also have experience in other languages and kind of enjoy how web developers keep "inventing" stuff that was discovered in other languages decades ago. The next big thing in JS appears to be functional reactive programming - a paradigm invented more than 25 years ago. I do, however, love JS because it allows us to implement pretty much any pattern we want. I hope that in the future everybody will be making API backends and then we can build any kind of client on top of it. It always make me cringe now, when I see front end data like HTML in the backend. It just doesn't feel like it belongs there. At all.
I haven't looked at the code, but, since he or she is writing an interpreter it might be this pattern: http://gameprogrammingpatterns.com/bytecode.html. 
Ah I see. So it allows you to grab files, read them and edit them but not save them back? Would it easier to just store the file in DOM storage? Thanks
I do not believe a person's self worth comes from what they do as a career. I think you are setting out to prove something that cannot be proven. Of course homeless people are people; what does programming have to do with it?
"as capable of writing software as any rich person" --&gt;"Rich" people hire software developers to write it for them. Some of us get rich by writing code, but very few people start out rich first, then write code.
This is a great answer, I hope OP contacts the person who wrote this. 
You know that Chrome doesn't use WebKit any more, right?
The stigma against homeless people is that they are lazy. And the stigma against lazy people is that they are dumb. So even if you prove homeless people can do X, that won't solve the underlying stereotype which is based on another underlying stereotype. I spent a year of my early 20s homeless in Sacramento. I had a car so it wasn't total homelessness, though the vehicle did break down towards the end. It was after 9/11 and I didn't have a laptop, just a tower and an old CRT which I kept in my passenger seat turned to the driver's side. I powered the machine with a cigarette adapter while the car was running (which is why it broke down...). When I wasn't building cheap websites for ma and pa places, I was doing shitty daily-paid for maybe $50 a day. In that time, I stayed at homeless shelters, washed myself in gas station bathrooms, and ate questionable food from questionable places. I met a quite a few homeless people. From truck stop prostitutes more homeless than I—some tricked it just to get out of the cold. To dozens of the more common homeless: men. Although I ended up knowing about a dozen female homeless people. Excepting the majority of prostitutes, all but one of those other homeless people were every ounce of every stereotype you could throw at a homeless person: lazy, unmotivated, disingenuous, angry at the world for not handing things to them, and attitude for miles. (For the record, I am also lazy, unmotivated, and have attitude for miles.) This is after discounting for obvious mental defects AND lower intelligence. If you literally aren't smart enough to do or know better, I'm not going kick you when you're down. No, the worst homeless people have half a brain. Know how to craft their "excuse me" story so you can't ignore it. Know what kind of homeless "look" to apply for particular areas to get the best return for their shame investment. Clean those people up, layer them in business attire and you couldn't tell them apart from their richer counterparts. Becoming homeless is a matter of circumstance. Staying homeless is a choice. (The people who got off their ass to work at the daily-paid place weren't much better. I did a job installing trim in a Blockbuster store where the couple walked off the job because the contractor was making them redo their shitty work. I ended up doing it for double pay, so a win for me at the time.) I digress... Take your skill and \*sigh\* get a job. Start at fiver.com or peopleperhour.com if you want to hide your homelessness. Or take your life story to the nearest tech startup where chances are they'd jump at the chance to trot you out as their "well-paid" community outreach project of one. If you want to tackle homeless stereotypes, become a homeless person who stopped being homeless. That's much more important than "homeless person can program".
I guess I just don't know *why* I should care if I wasn't already looking for something. I (and lots of JS devs) are already using underscore/lodash. So for the utility functions: * why did you recreate those existing functions? Performance? Better chainability (ala Rambda)? * what more functions did you add and why? I don't have the entire lodash API in my head, so if you're expecting me to be able to pick out the diff on my own that's crazy. For the class system. What specifically is different/better and *why is that important*? Yes, there are more functions, but what power does that give me? Give me some concrete practical examples where using your class system would save me a lot of pain. The elements are much easier to understand. The way they're scattered about (and the slow loading) makes it difficult to see how they all fit together. It would be great to have a "full" interface example to see what is possible with all the widgets. Evaluating one text button at a time is very inefficient.
Great post, just a minor nitpick. Most of the time "culture fit" is used in the hiring process as a BS reason to hire/reject someone. However, sometimes people have serious difficulties working in particular work cultures (e.g. the cowboy coder in a bank's dev team), especially when people from vastly different cultures are involved (and that may, unfortunately, include the different cultures of homeless people and homeowners). 
&gt; AppML is different. You have full HTML, CSS, and JavaScript freedom. unlike all those other pesky frameworks
This looks like the coolest thing ever, I hope you're able to keep working on it and getting it off the ground. I tried writing a small program in it and it threw an error. Take a look: &gt;&gt;&gt; def ask_bros(): ... going = raw_input("are you going to the thing?") ... if going == 'yes': ... print "Good for you!" ... elif going == 'no': ... print "Aw :(" ... else: ... print "Sorry, the only accepted answers are 'yes' and 'no'." ... &gt;&gt;&gt; ask_bros() Traceback (most recent call last): File "&lt;console&gt;", line 1, in &lt;module&gt; File "&lt;console&gt;", line 2, in ask_bros EOFError With that said, I wish you the best! I'd love to see Python brought more cleanly into the web environment, and getting it to compile into Javascript seems like the best way of doing that.
From the docs: &gt; Technical details &gt; &gt; The runtime optional transformer does three things: &gt; &gt; * Automatically requires babel-runtime/regenerator when you use generators/async functions. &gt; * Automatically requires babel-runtime/core-js and maps ES6 static methods and built-ins. &gt; * Removes the inline babel helpers and uses the module babel-runtime/helpers instead. http://babeljs.io/docs/usage/runtime/
&gt; In the real world - sadly - they often will. Honestly, I would go so far as to say they *almost always* will.
There are som pretty interesting ideas here about alternate ways of creating components: https://github.com/reactjs/react-future
Thanks for the detailed reply, this is really helpful! I've never worked with internationalization in a program before, so I'm pretty new to it, myself. The best I could offer OP was advice to move away from using a switch statement. 
Unminified source here: http://www.w3schools.com/appml/2.0.2/appml.js Some interesting conventions... * at least 6 globals, most of which are inconsequential to the usage of the lib * these are 3 of the 6 concrete globals: function getAppmlApplication(appmlname) { return appml(appmlname);} function appmlObject(appmlname) { return appml(appmlname);} function appmlObj(appmlname) { return appml(appmlname);} * more globals will arise at runtime, due to code like `window[this.dataObject]`, `window[this.controller]`, `window[appsrc]`, etc. * lots of implicit globals like `queryElmnt`, `qfname`, etc. * complete disregard for prototypes, instead attaches all methods to `this` directly, e.g. `this.method = function() { ... };` * some questionable uses of `eval()`: try { this.display.value = eval("this.data." + needle[i]); } catch (er) { this.display.value = undefined } and: repeatObj = (eval("this.data." + repeat) || eval("this." + repeat)); * don't even know what to say about this _translate_ method: this.translate = function (txt) { var patt; patt = /APPML_ERR_USN_OR_PWD_REQ/g; txt = txt.replace(patt, "Username or password required"); patt = /APPML_ERR_ACTION_REQ/g; txt = txt.replace(patt, "Action required"); // 20 more assignments/replacements... return txt; }; * not a single `console.log()` and yet 7 uses of `window.alert()` * use of at least 2 identifiers that aren't defined in the source: `w3schoolsWebSQLOK`, `w3schoolsWebSQL1` * lots of missing semicolons (and then some superfluous semicolons, like following an `if () { ... };` block
Since I have a babel project I decided to play around with this. It's definitely not worth doing in my project. This project is mostly CoffeeScript and all new code is being written with ES6 and compiled with Babel. File Size ====== | | no runtime | runtime | bytes saved | |------------|------------|---------|-------------| | app.js | 2315597 | 2403346 | -87749 | | app.min.js | 1070583 | 1100272 | -29689 | Command used: `ls -l app.js app.min.js` Yes, that's exactly what it looks like. I checked a couple times to make sure. Adding the runtime increased my file sizes by a very small amount. Setup/Maintenance Cost ======== I'm currently using `bebelify`, which happens to have `babel@4.5.1`. According to the docs I need to depend on `babel-runtime` directly, but when I just installed it (`npm install babel-runtime --save`), the build crashes unable to find `babel-runtime/helpers`. I have to `npm install babel-runtime@4.5.1` to exactly match the version of babel I have. Every time `babelify` updates I'll have to dig through to find out the exact version of `babel` it is using and update my project to depend on the exact same `babel-runtime`. What's next ========= Maybe if I update `babelify` and get babel&gt;5.0 it would improve the file size, but the setup/maintenance cost wouldn't go away unless I change my build system to not depend on it.
You're right, it's not much more maintainable nor better structured. It was only a tiny step in the right direction, and was written in a way that could be immediately adapted to his code without requiring a bunch of other stuff to be re-written. It was all I had to offer, and probably wasn't the best example to illustrate my point about maintainability, but it was something people were calling out specifically and nobody was offering anything more helpful at that time.
Hi /u/halistechnology, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Please note that further off-topic posts (this is the 2nd now) may result in a ban.
Why are there are no defining words? Forth without : doesn't make much sense. I don't see any indication that there are pointers to the top of the dictionary, the return stack, etc. As it stands, you can't possibly define control structures. If you want, I can send you a JS forth implementation so you can see how it works. You seem to have overcomplicated a lot of things and unintentionally crippled your language in the process.
Why use jQuery though?
Thank you! This is very very interesting
&lt;iframe src="asdf.html"&gt;&lt;/iframe&gt;
I did end up installing it. I understand your worry, but really i find myself rarely updating dependencies like this until i need the new features. Since i'm running on the latest babel anyways, i can just grab the latest on NPM for the runtime. Here's how i set it up for others who are wondering: module.exports = function (grunt) { // Import dependencies grunt.loadNpmTasks('grunt-contrib-watch'); grunt.loadNpmTasks('grunt-browserify'); grunt.initConfig({ browserify: { dist: { files: { 'www/js/bundle.js': ['src/app.js'], }, options: { transform: [['babelify', { optional: ['runtime'] }]] } } }, watch: { scripts: { files: ['src/**/*.js'], tasks: ['browserify'], options: { spawn: false, }, }, } }); grunt.registerTask("default", ['watch']); }; And just included `babel-runtime` in the package.json
I lived in a motorhome for a couple years working remotely. Beaches are a nightmare; your motorhome (and thus, your bed) will get covered in sand. There's no way I'd take my computer outside on a beach. Not only is sunshine not conducive to viewing the code you're writing, the inside of your laptop will also be covered in sand, which is harder to clean than your motorhome. Best bet is to drive and park *near* a beach, get your work done, then walk to the beach and go enjoy your afternoon.
You're welcome! Glad you found in interesting.
&gt; Is probably on his next $600 a day contract now. What do you need to know to get those gigs? 
Once I discovered lodash, I never looked back. Lodash is very fast, even when manipulating large data sets. I have not tried Ramda though. I will have to go look at that.
One reason is that lodash is the most depended module on npm, whole the contestant is still in neverheard stage
Hi /u/PopThieves, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
This is akin to asking for the one true architecture. No such thing.
&gt; And OOP can be pretty nice too, if you let go of the horrible classes that is. Yeah, I wish they would have called classical OOP something like "Class Oriented Programming" instead. The acronym "COP" would also express my view on classical OOP very well. I often hear people talk bad about JS "because it isn't OOP." It really is kind of unfair since JS might actually be one of the most object oriented programming language out there. After getting my education I've gone back to full stack web dev lately and my main interest is UI. Async just doesn't work very well with MVC. Callbacks, promises, flow libraries... they work, but let's be honest: it's a mess. A huge one. And it could be a lot more fun. I got quite excited when I started exploring FRP stuff like [RxJS](https://github.com/Reactive-Extensions/RxJS), [cycle.js](https://github.com/staltz/cycle) and [this article by staltz](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754). The way it handles async with streams just makes a lot more sense. I can see and handle exactly where every event is going. Also quite interesting how [Netflix seems to be using it](https://www.youtube.com/watch?v=XRYN2xt11Ek), even for the backend. Currently working my way through [their tutorial](http://jhusain.github.io/learnrx/). Combine the above with [Ramda.js](http://ramdajs.com/) and you even have a certain level of immutability. I know everyone is on the react bandwagon at the moment but I really feel like this is where react will eventually bring us. I think I will do something like cycle.js with Ramda.js for my next hobby project.
I guess it depends on your definition of "good". Sure, I agree maintainability is a worthy goal, but it's not the only measure. On the other hand, one who looks at code and spends more time complaining about its shortcomings than understanding it isn't much use to anyone. 
I love how I can go to some obscure subreddit, suggest something crazy and indeed, someone has already done it. :)
Is "brogrammer" actually a term that people take seriously? I thought it was just an internet joke / meme.
Sadly, they do. Even if they don't use the term, that *culture* is very much alive.
+1 this! I took some time to realize that, I just can't perform well on live-coding interviews, with someone looking over my shoulder. It's just not like real world. Technical assignments ftw.
Setting aside merits of the libraries themselves, the biggest reason I can think of is going to be mindshare. If collaborating with others is a priority, you can pretty much guarantee that a JS developer worth their salt has used underscore or lodash (doesn't really matter which); Ramda, not so much. But is that a reason not to use Ramda? That really depends on how you feel. The JS community as a whole has generally erred on the side of new rather than established, so Ramda at least has that going for it.
Ugh. Hangouts interviews? Really? Fuck that noise. Phone or in person.
Yeah, I personally don't like it either, but they have to test your knowledge some how. I could do some very minor work on a project and include in my portfolio, and a lot of people will do that. I've interviewed a lot of people over the past 2 years as our team has expanded, and I can tell you people lie all the time on their applications. We have caught so many people who over sold themselves, it isn't even funny. And while the take-home example maybe more accurate to a real-world scenario, it also gives people the opportunity to "cheat". That said, the tests we run in-person (since we don't do virtual interviews) are meant to test basic to intermediate level knowledge. And we don't expect someone to get them 100% correct, or even solve them like we might. We are just trying to gauge how you approach a problem and where you strengths and weaknesses in terms of code and concepts are. 
There's nothing wrong with expecting a simple coding task to be done during an interview. 
For some reference, the thing I ask them to interpret and fix is: for (var i = 0; i &lt; 10; i += 1) { setTimeout(function() { console.log(i); }, 1000); } So it is a VERY basic, simple thing
"what does this evaluate to eval([[[[[[[++++----}}}}}]]]]]) .... "Go fuck yourself?"
Do you use it everytime you have work with a JS object? If so have you come across any issues? I'm using immutable for the model/store (in a react/reflux project) and convert it to a JS object to pass to props/context. Kinda thinking recently that I might as well use it throughout, but just worried that it's another thing for devs to learn as they roll onto the project.
Do you also [shrinkwrap](https://docs.npmjs.com/cli/shrinkwrap) your dependencies? `babelify` currently depends on `babel-core@^5.0.0`, so if it isn't shrinkwrapped you're going to get unexpected minor and patch updates. This might not be a problem if you're depending on `babel-runtime@^5.0.0` though. Also, shrinkwrap is terrible but sometimes necessary. IMO the package [npm-shrinkwrap](https://www.npmjs.com/package/npm-shrinkwrap) makes it usable, but you have to remember to never run the native `npm shrinkwrap` command. This might sound like I'm trying to talk you out of this, but I'm really just trying to help based on past experience.
Well, sure, if it's something stupid. That's going to be true of any interview question, though. Something like /u/SinS3i posted should be fine, though.
"re-arrange this function that i intentionally wrote very tersely and drastically alter it's output" .... "im gonna go get paid to write real code. peace" 
**TL;DR:** lodash &gt; ramda because it aligns with how JavaScript works. Why not to use Ramda in one sentence: &gt; Ramda functions are automatically curried. In a language without static typing currying is just a pretty bad idea. You can go and pretend that JS supports immutability, proper recursion, and advanced type system features. But it doesn't and pretending otherwise will make code more fragile. Nothing against selective use of immutable data structures in certain situations. But you won't get proper equality. You will still get all the GC and memory overhead. And there will be limits to *how* immutable the data will be.
That's probably fair. I still always have lodash as a dependency, but it's there for the things not in Immutables scope.
I don't think the layer of abstraction "grab files and save them" fits here. You are dealing with strings. You grab the content of the file in a string, and you throw the string back to the server. You need to catch the string somehow on the server before save it into the file. 
I don't think you're going to get many '*professionals*' willingly assist you to '*cheat*' in what is probably an online game, *for free*. Perhaps you'd be better to learn some basic Javascript yourself, and have a go at it? It'd be both educational, *and* a challenge for *you*.
ngly, the intended (not actual) output of that function is to log to the console 0 @ 1s, 1 @ 2s, 2 @ 3s, etc... The actual output because of how JS works is outputting the number 10 ten times @ 1s. So the problem is two-fold: 1) how do you actually get the timeouts to occur @ 1s, 2s, 3s, etc. 2) why is every output 10, and how do you fix that? nickbunch, this question is part of my technical interview for anyone who CLAIMS to be a JavaScript expert (as is normal for people interviewing with me, since that is what I am) If I were interviewing someone on Java, Ruby, etc... or just for a general position, this would naturally not be in my interview questions
Here are a few ways I can think of http://jsfiddle.net/fooey/685snb03/2/ Basic idea is you need to create a closure to protect your variable scope function delayLog(n) { setTimeout(console.log.bind(console, 'v1 %d', n), 1000 * n); } for (var i = 0; i &lt; 10; i += 1) { delayLog(i+1); } --- for (var i = 0; i &lt; 10; i += 1) { (function(n){ setTimeout(console.log.bind(console, 'v2 %d', n), 1000 * n); }(i+1)); } --- (Array(10).join(null).split(null)).forEach(function(val, i){ var n = i + 1; setTimeout(console.log.bind(console, 'v3 %d', n), 1000 * n); });
&gt; I have had just as many interviews where the lead engineer sends over a coding exercise to be turned in within a couple days. perfect. that is representative of what real coding is. I suspect this will become the norm over time, we actually pay $500 (cashiers check, before we even look at your solution) for it as well. Our task takes about 4 hours for someone relatively up to speed on the tech and who can reasonably understand the task. [I described our process sometime ago in another thread.](https://www.reddit.com/r/cscareerquestions/comments/2a9d74/good_programming_exercises_for_programming/cit8rcn)
I'm pretty high in the top percentage of users on stackoverflow (have it advertised on my CV), and I thought this is going to at least set some level of standard when it comes to interviews, but oh boy, was I wrong. I'm not surprised anymore about recruiters asking if I have 5 years of Angular experience, which tells me they are absolutely clueless on how the market works in the field they are supposed to find talent in. I'm not surprised if they ask if I have experience with MySQL, meaning they didn't even read past the first quarter of my CV. I'm also not surprised anymore when I have to "write me a function on this piece of paper that prints the pascal triangle to N depth". I'm just going to drop these two gems here: https://dl.dropboxusercontent.com/u/2654083/interview/Clipboard02_cut.png https://dl.dropboxusercontent.com/u/2654083/interview/Clipboard05_cut.png ಠ_ಠ deal with it.
I try to think of questions like these as gauging my line of thinking or approach to problem solving in a programming context. I don't worry about having a complete/"correct" solution, I try to focus on demonstrating/talking about my approach and what I'm thinking about as I work on it. If the purpose of the question is about coding under pressure or with an audience, then I probably would hate working there anyway.
I understand your comment. My proposition should only be applied to split an app in major components. You'd obviously use relative requires most of the time. Here is an example of the few local modules you might want in your client app: * API (basically just the mapping to your HTTP API) * models (business logic, validation) * UI components (reusable Angular directives / React components etc...) * random-helpers-used-everywhere (~ your underscore like stuff) Every module is kind of global, match a "layer" and could/should be reusable independently of the others. Another way to see it is to think about the `common` directory that a lot of components points to. This `common` folder could easily be a local module.
Yeah, I've had experiences where they ignore everything I've done and mumble through a contrived exercise while warning about the dire consequences of "cheating" by using external sources such as the ECMA 5 spec, a library source code, or (in one case) the console. At that point it feels more like trivial pursuit than any test of technical skills. People that are good at memorizing trivia and solving rubik's cubes will defend the process, people that aren't will criticize it, but the leadership of most companies want to feel like they're making hiring decisions based on objective data, even if they have no idea if the data actually indicates anything meaningful.
Ok, without given context I would have assumed that you just want to print 0...9 simultaneously 1 second later. How am I supposed to assume what you want to do with broken code? Are you truly a JS expert? Can you write your own lexer, parser, assemble an abstract syntax tree, write hand-coded asm.js, or implement a JavaScript engine? Perhaps you should assess your abilities honestly before self-proclaiming expertise, tech elitism is irritating. Just because you're on the interviewing side, doesn't mean you're that great.
Finance? O_o
The biggest problem with Underscore, compared to lodash, is pretty much everything else.
You also need to give the `setTimeout` a wait time of `i * 1000` rather than just `i` if you don't want them to log all at once.
I think you missed my point that self-proclaiming expertise is worthless. Also, I would expect an expert in a language to be able to implement the language, the demonstration of expertise is worth infinitely more than saying so.
I'm confident that the speed and accuracy which I could complete those tasks in would be in the top 15 -20 percent of developers. I am not, however, going to do so just because someone got salty over my use of the word expert in a reddit thread. 
As a dev with 30 years experience, I guess I'm biased. The idea annoys me because there isn't anything I need from another dev to solve a problem. It would just slow me down. The devs I see who are pair programming are typically somewhat inexperienced and it takes two of them to solve a problem. 
Still creating lots of function instances. IIRC you'd want to move function creation out of the loop body entirely.
K
What am I looking at, there? I try to avoid PHP as much as possible, but this looks broadly similar to most of the PHP I've come across.
Very nice. I may use this very soon!
He doesn't understand. This is why he needs a couple of days. He's just not very good which is why he isn't getting offers.
There are different ways of solving this. Personally I would use bind or underscore bind it creates the closure for you under the hood. 
You. You get an upvote. I turned down a job because I had a better offer that paid me $250 a day to work on a small project for them. I have way more respect for them than linkedin and ADP both with shitty interviews. 
There are lots of ways to solve it depending on what exactly the purpose of the loop is - the example is pretty contrived so it's hard to tell what the purpose of the code is supposed to be. Here's a super simple implementation I'd be inclined to use for the interview: var i = 0; var interval = setInterval(function(){ console.log(i); i++; if(i == 10){ window.clearInterval(interval); } }, 1000);
The majority of candidates will likely be interviewing at multiple places at once. Placing a burden of an X-hour homework assignment before coming on-board is a dealbreaker for many engineers. To make the process more like 'real coding,' the candidate can come on-site and pair with a member of the team for a few hours. We do this for candidates we really like, but only AFTER we have given them an offer.
I like to solve these and then end the interview.
What if you were paired with someone who also has 30 or more years experience? Do you ever feel like they might offer helpful feedblock when you hit a roadblock? 
because settimeout is async and the for loop completes pretty much immediately. so in the loop you need settimeout to invoke its callback at 1000ms, 2000ms, 3000ms. etc.
For what it's worth, I work with a programmer who wasn't so different from you. He's been coding for around 30 years and I am definitely not as experienced as him. We pair about 50% of the time and when we do the quality of the code is noticeably better, is more thoughtful, and has less bugs. Even though we're "getting less work done", the code that is produced ends up needing way less maintenance and troubleshooting. The way we do it, the person who is more familiar with the code "drives" so they can navigate around quickly while the second person acts as a live debugger (plus more). The second person is much better at noticing small typos and being able to see the code that is being written as a whole while the driver tends to be more focused on the individual block at hand. Additionally the second person helps by being able to pick up when the driver stalls in any particular area. We've been working this way for three years now and it works really well for us.
Serious question: why wouldn't i just write javascript?
I didn't write this, I was just passing this down to /r/javascript. You should contact the creators via github. https://github.com/rfk/pypyjs/issues
My experience: I live in Australia. Amazon would like to interview me for US job which would involve relocation to America. I agree to an interview. Amazon set interview time to 4am locally. After WTF'ing, I agree to time. Wake up at 3:30am, walk aimlessly around home drinking multiple coffees for 30 mins, this does not wake me up. Interview starts. They start with a few questions. I struggle on questions I would normally not struggle on if I were awake. They pull up a shared codepad and get me to solve multiple contrived functions. I get totally roasted on a minor js mistake, they end interview. I go back to bed. 1 week later they inform me I was not suitable. Worst interview experience ever.
I agree with you. My stance on coding challenges is pretty positive. Having interviewed a lot of front-end developers, and having given a lot of coding challenges, I have not regretted hiring a single person that has done well on those challenges. Now, my experience does not mean the candidates that did poorly and did not get hired are bad programmers, or that they would have not been just as good at the job as the people hired. It's just that this method has allowed me to consistently hire good candidates, and if that means that I am passing on a lot of good ones, then I am OK with that. I would much rather take the risk of not hiring a good developer, than hire a developer that I will not be happy with. And for people who are against javascript trivia and writing actual code during interviews, I have this to say: If a candidate cannot implement a simple debounce function in 60 minutes, with a laptop handed to her/him, and with full permission to look up any JS references sites like https://developer.mozilla.org/en-US/ for documentation, then maybe that candidate is better off not working with me. Heck, I do not even look over their shoulder. I sit away from them and work on something else. When I hire developers, I fully expect them to write much more complicated code in that span of time, so it's obviously not going to work out.
Your process is perfect in every way, but specifically it is socially superior to any strategy I've read before. I'm stealing your method.
How is an X-hour homework assignment worse than coming to an interview for X-hours? Shit man, think about what you just said. 
That's different if you walk away and give them resources. That's not the problem. You have many companies that will not give you Internet access and will watch everything you do, that's the problem interviews. 
Cheat? As in exactly what they'd do if they actually worked at your company by using external resources to solve a problem? 
Yes, that sucks. I would argue that they have bad coding challenges, and not that coding challenges are bad.
I wonder if they'll move away from arrays and more toward generators/iterators for proper lazy loading with method chains.
No Idea why you were down voted, but it's completely true. I'm not a great problem solver if you're sitting there watching me, but I can certainly solve anything if you just leave me the fuck alone and let me work. 
&gt; In a language without static typing currying is just a pretty bad idea Currying is fine, even in javascript. Automatic currying, on the other hand, not so much.
All of your points seem like a good way to hire mediocre people that are like everyone who already works there. If you judge candidates on equal metrics but you don't have any evidence that the metrics correlate to anything, you could be equally fair by never hiring anyone whose name contains the letter p, or by who can do the most pushups in a minute.
Maybe my google-fu isn't that great but if anyone finds a plugin that does similar to [this] in `lodash` then I'd switch to `lodash` in a heartbeat.
A lot of suggestions will be of dynamic loading. You can also utilize a grunt or gulp task to concatenate and deliver bundled files. I find usemin to be handy at packaging builds that I will deploy. You can also leave the scripts as standalone assets to do a quick ctrl+o and find the file in dev tools for debugging and in browser developments. https://github.com/gulpjs/gulp/tree/master/docs/recipes https://github.com/zont/gulp-usemin Writing code in modules is a best practice either way. 
I agree but .... I accepted this was a fact of live and spent a lot of time doing katas. I got really good and can probably still implement a dynamic programming solution the the backpack problem in under 30 minutes. I think the process actually brought my choos up to the next level. It still doesnt matter. I implemented an lru cache from first principles and was told i should have used reddis. I've written great specs using factory girl and was told it was a waste of time and I should have used features. People are just stupid when it comes to hiring. Shit, I just had a member of the ember core team tell me coffeescript was bad because then you couldn't hire people to dumb to learn a second language. 
I don't want to work with someone who does copy paste from StackOverflow and other sources and hacks it together but doesn't really understand the code. 
The reason I am using JQuery is simply because I prefer to use it personally. A JSFIddle link is actually a good idea. Thanks you. Edit: [JSFiddle](https://jsfiddle.net/t8eq78zb/)
As a general rule, you should not use `new Array()` as it slows down execution time and complicates other stuff. If you tried typing `typeof(product_prices)` it would return `object` instead of `array.` Instead, do `var product_prices = [];`
I give live coding exercises in interviews. They aren't timed, and I'm a lot less interested in you getting the right solution than I am in finding out how you think. It's done as a pairing exercise, with the candidate as the driver. People who get flustered when presented with something they aren't familiar with, or who can't talk through code and reason through potential solutions aren't someone I want to work with. I don't really care about how well you can use StackOverflow - I care about *how you think* and how you work with other people. One of the things I like seeing in interviews is "I don't remember this, let's look at the doc", because nobody is expected to know everything, and working with blowhards who are more interested in protecting their own egos rather than solving problems is not something I'm interested in. My coding tasks are never designed to be tricky or surprising - they're frameworks against which I can see how you come at a problem, and how you react when you get stuck. You don't get hired and then work in a bubble where you turn specs into code; you'll be working with other people, thrown into codebases you aren't familiar with, be asked to debug foreign libraries and deobfuscate vendor code, and lots of other things where you're going to be up against the unfamiliar and uncomfortable. If you can't handle those things, then you're going to be a drag on the rest of the team. An engineer who refuses a live coding exercise because they're offended that I'd ask them to prove that they can do what they say they can on paper is going to get a "no hire" recommendation from me, because I'm going to assume you're a primadonna whose ego is going to be a detriment to the team.
I like how you organized this, it is an interesting concept. A suggestion I'd give you is to create a GameEngine object, and store your variables as properties instead of global variables. It's best practice not to use global variables when you don't have to as it slows down execution time. Also, to save your status you can use the `window.localStorage` feature. You should look into that being a method of autosaving because if you aren't able to easily come back to a game after quitting it, then there's no incentive to play it again.
I guess I could rewrite the lib to take an argument and then chain it into the promise: w8 = function(value) { ... toPromise(value).then(promiseLikeObj).then(res, rej) }; but that would mean using it to start a chain like this `w8(100, getFile)().then(...)`
[W3Schools](http://www.w3schools.com/js/) is a good free tutor
Have you considered trying a streaming json parser? That way your parser wouldn't care if it had partial data in a particular frame, as it just get a buffered until read. Oboe.js looks nice but I haven't really used it. 
So when a downstream consumer of your API says "I've got a blocking bug assigned to you, we need it fixed asap, do you know what's wrong?" you'll just... not do it?
Boo.. 
The sad part is (esp. w/ Javascript) that so many shops don't unit test. You're gonna have a number of interviewers look dumbfounded when asked about unit testing. I've been asking potential employers if they unit test, and the interviewer either looks dumbfounded or shakes his head lamentably to admit that they fail to do so.
&gt; but as an engineer struggling to recruit ~10 strong engineers by the end of the year hello there 
You could probably string together a few streaming modules: - https://www.npmjs.com/package/xhr-stream - https://www.npmjs.com/package/JSONStream - https://www.npmjs.com/package/json-stream
I've been on both sides of this, and I get it; however, as others have mentioned, this is about separating the wheat from the chaff. Having that been said, I usually have the interviewee walk me through solving two or three challenging but short coding problems. And, if he/she gets stumped on something, I tell the candidate to just make certain assumptions and continue. After all, it's more important that we find out how that person thinks through a problem. Meanwhile, the problem I have is having a timed coding project where the interviewer is looking over your shoulder while you're working through it. I get you want to make sure that the candidate isn't cheating, but at the same time, it's impossible for me to write code when you're literally breathing down my neck. The worst instance of that was a couple of years ago, I interviewed for a position at an event ticket reseller, and they wanted me to write an IE8 and W3C-compatible web app in an hour that was CORS-enabled on top of the five-page requirements doc -- all while three guys were standing over my shoulder as I was writing it. Of course, since I had to look up some documentation in jQuery (I honestly don't remember all the 10,000 possible params for $.ajax), they reported back to the agency that I didn't know Javascript even though jQuery-specific knowledge has nothing to do with Javascript (yes, the agency came back to me verbatim saying, "Yeah, that position isn't going to be a fit for you since you don't know Javascript."). Sure jQuery is a Javascript framework, but jQuery isn't Javascript, and it goes to show that oftentimes the interviewer isn't as knowledgeable on the subject matter as he or she thinks. Sorry for the rant at the end, but I do know how you feel as there are interviewers that do get excessive with their interviewing process. You would think the interview process they make you go through at some of these places are looking for the next Douglas Crockford; surprisingly, they don't pay Douglas Crockford rates. 
What does the network tab in Web Inspector/Firebug say? You should see that network call for it -- does it come back as a 200? Does anything come back? This should help you isolate it to backend vs frontend.
Nowhere does he say that. #4 is: "We'd rather not hire someone good than hire someone who might be bad." which was preceded by saying that he's "struggling" to hire engineers. That suggests either his company offers salaries below market rates or that the selection process is inefficient. If it's the first there's not much he can do about it, but if it's the second...
Technically yeah, but if creating 10 (additional, not total) anonymous callbacks in javascript is what breaks the application's back, I think we have bigger problems.
I suck at timed coding challenges like that interviewzen.com shit. There's something unsettling about a clock ticking in the background. I much prefer in-person whiteboard coding or those pair-programming interviews. 
Yay, challenges! var debounce = function(fn, wait) { var timeout; return function() { clearTimeout(timeout); var args = Array.prototype.slice.call(arguments); timeout = setTimeout(fn.bind(fn, arguments), wait); }; }; var debounced = debounce(function() { console.log('complete!'); }, 500); setTimeout(debounced, 100); setTimeout(debounced, 200); setTimeout(debounced, 300); setTimeout(debounced, 400); setTimeout(debounced, 500); setTimeout(debounced, 600); setTimeout(debounced, 700); Now critique! ... Only half kidding, I feel like I'm missing something. Honestly though, if someone took away the internet while asking me to code, I'd probably have a mini panic attack -- even if I already knew how to implement what you asked, and I didn't need to use it. In addition to that, the high pressure situation creates a scenario where you feel like you have to be absolutely perfect the first time around, and that's not really what development is like. At least, not in my experience. In my experience development has always been iterative, improving as you go along. I'm glad to hear you don't take away the internet or stare over shoulders. 
Pagination sounds right to me as well. Though as it is ridiculously simple to implement, I wouldn't make that specific recommendation if they're not already using backbone in the project.
I'm a mobile dev learning JS on the side. Your logic seems to be that if its called multiple times within the timeout then it will be called wait seconds after the last call. Your implementation seems to be correct but what if I'm debouncing two different functions ? Wouldn't the timeout variable end up getting shared between the two breaking it ?
Changing the opacity alone in your interval handler is not enough, you need to clear the canvas and then redraw it after changing the opacity. Putting all the drawing code in a function and calling it from your blink method after changing opacity and clearing the canvas should work
Ruby no....lisp ABSOLUTELY! 
Actually, I just had an interview today where I was handed a computer with Eclipse and some Java method stubs and was asked to implement some function there. I thought it was actually kinda cool, given that I, you know, *don't know Java*. That was actually the point of the exercise, to see how I deal with a language I don't know. I have to give it props for creativity there.
the things that xsacre mentioned (avoiding repeats) ALSO: I am wondering why you keep repeatedly getting the canvas context for each group instead of getting it once and using it universally?
Why? If you're using it via cdn or similar, it's bound to be cached. Don't minify it into your script if you're concerned about size.
I agree with your three basic core issues, but would add the additional core issue of how well it scales. Regarding the effect of architecture -- any architecture choice limits what can be added or changed easily. Certainly any decent programmer can hack almost anything into almost any architecture, but those hacks will almost certainly cause a fail on your second two questions. Even if your only architecture is the bare machine at microcoding level, you still have actual limitations imposed by the architecture. Each level of abstraction (machine language, high level language(s), libraries used, architecture of the project you are working on) introduces additional limitations. Any limitation is not inherently right or wrong. Limitations are essential to your second two core issues. Therefore, any choice that introduces a counter-productive limitation is wrong in context (not absolutely wrong for all conditions).
Any programming will help.
I don't like microsfoft
A week or so I got "What's the method signature of [I forget] from the [some Java reflection class]?" "Uh... do you want me to look it up?" At least when I'm asked to find the number of inversions in a size n array it lends itself to a natural answer that can/should be achieved in a certain time complexity. Rather than these lame questions that anyone could answer with a 10 second Google search followed by some contrived answer that really only goes to show I can use Google and blow smoke up your ass.
I *think* I'm okay on that issue. Calling debounce on a separate function should result in a separately scoped instance of `timeout`. Try this out: var debounced = debounce(function() { console.log('finished 1!'); }, 500); var debounced2 = debounce(function() { console.log('finished 2!'); }, 500); setTimeout(debounced, 200); setTimeout(debounced, 400); setTimeout(debounced, 600); setTimeout(debounced, 800); setTimeout(debounced, 1000); setTimeout(debounced2, 200); setTimeout(debounced2, 400); setTimeout(debounced2, 600); setTimeout(debounced2, 800); setTimeout(debounced2, 1000); They should both finish at the same time, without affecting each other's timeouts.
A different timeout variable is created every time you call `debounce`.
 &gt; eval([[[[[[[++++----}}}}}]]]]]) Uncaught SyntaxError: Unexpected token }
JS doesn't support immutable data structures, but the guys behind Immutable.js pitched the idea to TC39 and it went pretty well. The proposal is here: https://github.com/sebmarkbage/ecmascript-immutable-data-structures It's obviously not something that will be added in the near future, but it's on the agenda.
Each time you call debounce, it creates a new closure with a new timeout variable and a new inner function. The real problem is that .bind() is extremely slow and breaks if fn is already bound (additional .bind() calls silently fail).
Pair programming isn't always about working with noobs of teaching them. I'm now Architect, but I still code a lot and when I was a senior dev a few years I paired almost regularly with another senior. We both knew our stuff and we followed true pair programming. IE , the person typing can provide input but the person driving the show is the one not typing. We wrote some of the best code of my career, two brains thinking about a problem. Two equally competent senior devs. We absolutely never got a case of "coder block" or slacking off. Because you can't, the other is there to lift you up. We also did metrics to see if our successes was just in our head, we shipped more code, with fewer bugs and higer code coverage than we did individually. Again, we were not juniors or beginners but senior devs and technical speakers. I went down the Architect route and he became a founding CTO of a startup. Pair programming , done correctly, with someone of similar background works amazingly. Some people take it further. Woody Zuil is a pioneer in the field of [Mob Programming](http://mobprogramming.org/). Multiple people programming together. Woody also did metrics at his last job, measuring individual developer producitivity vs the mob working together. He found that they shipped more stable code at a regular cadence, and again this was an experienced team. I'm not trying to say you should do it, but just keep an open mind that it works for some people.
Unless you work somewhere where you've never had to solve an original problem this is a moot point.
Yeah. I've read stalts exellent guide too. It really illustrates the advantages of functional vs imperative in some situations. How would you imperatively detect a double click? On mouse event, do a loop for 250ms then check if another click occurs, and oh dont forget to override the mouse click event while checking for the second, and....It gets messy. But with a stream and RP, its just, elegant 
I find it cute that you used bots to manipulate karma, and thanks for proving my point. You sound like a prima donna whose ego vastly outweighs their actual skill, just like every other beginner who thinks they're great. Dunning-Kruger much?
For real-life interview problems we leave the person alone for as long as they want, and ask em to implement a lodash function like zip. Then we ask em to explain it. Failing to implement this is not a deal-breaker for me. You might miss some edge-case or have an incorrect conditional, but I'd expect it to be a close representation of what the logic would look like. Afterwards, we just talk with em. We'll ask them a lot of hard frontend questions that don't have a "right" answer. Like: have you ever been in X scenario? If so, how did you handle Y? Typically they'll expand on the topic or discuss ideas, even if they haven't solved the problem before. I find this WAY more insightful. Major bonus points if you give me an answer I had never thought about. But the ultimate goal of these questions is to see if the person actually understands what they're talking about. Sometimes, if the person seems really good, I might ask tricky JS questions. I don't fault them for failing to get the right answer, but I definitely get excited when they get the right answer. I also make sure to keep the questions limited to things I've seen in real-world code. Finally, we'll give em the choice to either: do a project, send us an existing project, or link us to their GitHub. And review it. People that have public Github projects are my favorite. 
Hmm . Ok . If the timeout variable were global then they would be shared right ? Each function call is a new set of variables. Should have been obvious but I was just a wee bit confused :D. Each time I think I completely get closures , I run across some code that again has me confused. Right now my practical understanding is that functions are like containers for state and if the variable is declared inside the function , it can only be accessed by functions declared inside that function. So if you want some protected state you wrap it in a function and return another function that accesses that state. Array.prototype.slice.call(arguments) - The number of clever workarounds like this in javascript .. 
We tried that, but we soon noticed that if you only include 10 of the functions, the file size bypasses underscore.
Lodash has gone insane on npm- hundreds of modules - you can literally pick and choose what you want. I'm not even talking about lodash-cli where that's been possible for well over a year. Just pick what you need, there's almost 0 advantage of not doing that 
Which is probably 1/10 the size of one image on your page, 1/4 the size of bootstrap, and parsed faster than human brain waves oscillate. I made up all those stats, but size needs to be put into context with every other resource loaded on the page. 
Because it's a bad metric for identifying good programmers.
You don't know wtf you're talking about and I also completely understand where you're coming from. I've fallen victim to immutability / currying gone terribly wrong - and it was probably the worst experience I've had using JS. But I was using vanilla js, not a proper implemented functional library The reason I said you don't know wtf you're talking about is because lodash advocates curried functions, maybe even uses them by default now. Currying done proper is great. I know where your frustration lies - but these libraries lie as well. They use all sorts of black magic to mimic the behavior of curries, so it's not bad. I've seen how bad it gets, but I've also seen things impossible with vanilla js or jwuery or any pre 2011-2013 library out there (although some geniuses probably figured it out somewhere and didn't share then got fired and the code is sitting in a recycling center somewhere in Idaho)
Keep in mind, interviews are a two-way thing. A candidate is assessing whether or not they want to work for you as much as you are assessing whether you want to hire them. I know when I'm doing the job-search thing, the style of interview I get *greatly* influences my decision about whether or not to take a job.
Hm... It is true, jetbrains ides do support TypeScript and successfully provide helpers etc for it. But I cannot stop seeing TypeScript as some kind of all-in-one thing, rather than helper for developing (like flow, just helper for type checking or jsdoc so ide would help you with types, returns etc). &gt;It's a big thing to standardize optional types into JavaScript but one day it will come anyway IMHO. Personally I think it will be faster than we think, mainly because now many drafts and suggestions for es7 are forming, and such things as typescript, flow are hyping, pushing standards in their own way. If I'm not mistaken there are already suggestions for decorators for es7. What's your personal experience in choosing things like TypeScript, would you be so kind to share?
Yea, we use built-in throttles in chrome and firefox, but we don't really need to perform performance tests. Just look at the numbers. Underscore is, what, 4-8kb minified, lodash is ~60kb. Feature-wise, lodash and underscore do the same. Lodash might be internally faster and more elegant, but we need to focus on the minizing the data to the client.
I haven't yet chosed TypeScript for my own projects. TypeScript &lt; v1.5 was just so off the standards so I didn't even considered using it. But I am currently trying out Aurelia and I would like to see what it has to offer with TypeScript. Looks very promising. Currently I'm using babel with ES7 decorators (they are awesome).
One drawback is the maintenance aspect. To update or add new functions to the generated lodash, even if its in grunt. As soon as you want a new lodash-function you need to start configurating files to build a new version.
What I learned in Ruby that has helped me in JavaScript was to come up with "inspect" or "p" like features. Often we have to print the content of lists, maps, classes, strings, etc. So being able to see that without the help of a debugger is incredibly useful. When you're stepping your code with a debugger, it halts the execution of your program. But often we don't want to halt the execution like that because it delays seeing a larger amount of debugging data. Some debuggers are smarter than that and allow us to filter out the data we clearly don't want to see and only halt when we get to a point that we do want to see. But doing that filtering may already mean that we have a good clue of what the problem is. Sometimes we don't yet know where the problem lies, so printing more data is helpful. Actually developers have been printing data for debugging since their C days. It's just that with Ruby and JavaScript we may be able to print more of it because the languages have more introspection built into them. The data can describe themselves for easier printing. In other languages, it may be harder to get to the data. Mostly though we have all learned JavaScript before many other languages. I learned JavaScript before I had learned Ruby. Perhaps a good point is that learning other languages beside JavaScript shows to us that programs can be much larger than just a single file in JavaScript. It is important to learn to trust the tool and yourself to write larger programs, better libraries and abstractions!
[Damnit, missed opportunity.](http://i.giphy.com/kdpDNdzCO3HnW.gif)
 for (var i = 0; i&lt;10; i++){ setTimeout(console.log.bind(console, i), 100); } The idea is that if you have an argument to pass with the anon function in `setTimeout`, the function will be locked with the argument. If you just pass an argument-less function, you end up without any variables/arguments locked with the function. You just wind up evaluating whatever state the variables are in when you run.
The article let out something pretty relevant. Modules are good. Lego like applications are good. External dependencies are not good. The more dependencies an application has the less portable it becomes (as in the reliant upon a given package manager the application becomes to merely function) and the fewer liberties it has to change and maintain its own internal architectural decisions.
2 things here: 1. In the js file, replace ctx.globalAlpha = alpha; with: canvas.style.opacity = alpha; 2. In the css file, move the background out of canvas and into its own div, drawn below the canvas. Reminder to self: editing codepen code on the phone is hell. 
Benefits: * ES6 transpiling to ES5 * optional typing lets you choose when and where to add type information * type inference saves you from having to add types everywhere when the compiler can figure it out * Type information is very important information about how your program works. * Typing opens up a huge amount of extra tooling possibilities. i.e. compile time checking, refactoring, find references, dependency tracking etc * It makes programming in the Big possible (and practical) Why TypeScript specifically: * It's a superset, so we already know most of the language. * Easy to migrate from plain JS to TS * Integrates great with plain JS code and libraries * Compiler output is readable and debuggable even without source maps. * Tool/editor/IDE support is good and quickly becoming great. * If TypeScript disappears then Plan B is taking the compiled output and continue working on it as plain JS. * The industry appears to be gathering around TS. We've got about 30KLOC of TypeScript at work and it is much nicer to work on than the plain JS. We can understand our code now. I'm keen to get the rest of our JS code into TS. 
Sorry to break it to you but you can always learn more. You have the attitude of already knowing everything which is awful for a programmer.
Although I've not used it personally, I've looked at localForage https://github.com/mozilla/localForage 
(disclaimer: one of Ramda's author's here) This response seems scattered and confused. Currying has nothing to do with immutability, proper recursion, or typed data structures. There is a conflict between currying and type-signatures of varying lengths; Ramda has none of those, although it offers you some means to alleviate these conflicts if you want to curry your own functions. Currying is simply the ability to take a function like this: // map :: (a -&gt; b) -&gt; [a] -&gt; [b] map(square, [1, 2, 3, 4, 5]); //=&gt; [1, 4, 9, 16, 25] and create new functions by not supplying all arguments: var squareAll = map(square); so that you can later apply it to your data: squareAll([2, 3, 5, 7]); // [4, 9, 25, 49] That's all it's about.
(disclaimer: one of Ramda's author's here) That should be almost over. I expect 1.0 to be out before long.
What about using frameworks or tools like React or any other from npm in TypeScript? npm i library --save; import library from 'library' and you good to go, or...?
I understand where you are coming from but it makes me neverous when you say "we can understand our code now". So you potentially had 30k lines of code you didn't understand before?
And [awesome](https://github.com/sindresorhus/awesome) for the list of *awesome*.
I came here to post this but you already beat me to it! +1 It's extremely simple to use and gives you the option of using Promises or callbacks which is great, especially if your planning on doing any async programming with generators which allows you to yield promises. If WebSQL or IndexedDB exists it uses that, falling back to localstorage if those aren't available, all using one simple API.
Thanks for the effort of editing on your phone! I went with your method, changing the opacity of the entire canvas and moving the image out of it (updated codepen). I'm learning there's a lot more to the Canvas API than I thought! Thanks!
Thanks. I'm going to create a separate codepen and use this method of redrawing the strokes after clearing the canvas. Would I be able to store the light locations as variables and calling "context.clear(); context.stroke();" rather than manually redrawing the rectangles? I don't necessarily like the way I'm doing it now and am not sure if there's a better way.
this. Test high level architecture and abstract concepts of their app. Copy/Pasters won't be able to answer those questions.
We don't pay our engineers hourly, and it is a nonsensical comparison for a few reasons. First of all, full time employment is not a 4 hour contract. Generally speaking as a contractor, the shorter the contract the more you charge. The more stressful the contract, the more you charge. The lower the chance of follow-on work, the more you charge. I was a contractor for years, and while I never got a 4 hour contract, but I did get a 10 hour one once with no chance of follow-on work. I charged them north of $300 an hour, and that was years ago, round up for inflation. Another problem with your comparison to hourly is -- it wasn't a T&amp;M (time and materials) gig. It is a FFP (firm fixed price) contact for work. That means if it takes the developer 50 hours, he worked for $10 an hour and if it takes him a single hour, he worked for $500 an hour. Additionally, if you wanted to view it in strictly contract terms, what about the interview-prep, commute, waiting, interview, commute, code sample, review-prep, commute, waiting, code review, commute... as a contractor, I would be charging for all those things.
In my experience, engineers prefer answers to open-ended silence. You seem to be an exception, which is fine. It is worth noting that generally this call doesn't go into the persons shortcomings. Generally it is a thank you call, not a tear down of why they didn't get the job. Going through a code-review before you have a job is rough stuff.
"code understanding" is measured on a scale and isn't just a yes or no like I stated above. But I can say that moving it to TS has made it much easier to see what is being passed around in the code and what is being called, and where code is being called from. This makes it much easier to navigate the code and understand the impact of changes. I would guess that most companies with a non-trivial code base have code which is no longer understood by anyone who works there. Working on a large and old code base is a journey of discovery as you constantly have to figure out how things actually work, even if you were the one who wrote it. TS makes this task easier though. 
Thanks for the share! I hope it was entertaining and informative :-) P.S. they got my name wrong :-( it's Kent C. Dodds #theCmatters :-)
You used @Template instead of @View. That's something old, right?
This isn't an issue. Since lodash is modular you can depend on the primary lodash package and cherry-pick methods `require('lodash/array/chunk')` and bundlers like browserify/webpack will pick what you need. Or you can use of the many [modularized method packages](https://www.npmjs.com/browse/keyword/lodash-modularized). Because lodash follows semver with either option you can use the version range of `^3.0.0` and get the latest and greatest.
With 3.0 lodash is [modular](https://github.com/lodash/lodash/tree/npm) ([amd](https://github.com/lodash/lodash/tree/amd), [es6](https://github.com/lodash/lodash/tree/es), [npm packages](https://www.npmjs.com/browse/keyword/lodash-modularized)). So you can choose what you want and leave out the rest. This works great with browserify/webpack to easily create very small builds (considerable smaller than Underscore). (disclaimer: I'm a core dev on lodash)
Underscore is ~5kb gzipped and the kitchen sink lodash is ~18kb gzipped. Like most devs you're probably only using a handful of methods which is why lodash is [modular](https://github.com/lodash/lodash/tree/npm) and offers [per method packages](https://www.npmjs.com/browse/keyword/lodash-modularized). You can cherry-pick the methods you want from the lodash package, like `require('lodash/array/chunk')` and browserify/webpack will auto bundle just the methods used to generally create significantly smaller builds than Underscore. (disclaimer: I'm a core dev on lodash)
my code to this problem was: var radius = prompt ('what is the radius of the circle?') var diameter = (radius * 2) alert(diameter*Math.PI) i am still new to JS, though.
Hi @rnbwd! It's me! lodash is heavily documented and some of our biggest features, like lazy evaluation, have come from [non-core contributors](http://filimanjaro.com/blog/2014/introducing-lazy-evaluation/). lodash is also [modular](https://github.com/lodash/lodash/tree/npm) which may make it easier inspecting smaller chunks of code.
Nice! Yap, lodash has several large data optimizations for faster `difference`, `intersection`, `union`, &amp; `uniq`.
That might be something to do with the flushing; most of the time `onprogress` is for *after* `readyState == 3` as it is supposed to be between loading and done/complete/loaded
lodash has `_.curry` and related methods but it's left up to devs to pick the [style](https://www.npmjs.com/package/lodash-fp) they dig.
I know that was (looks like someone is on top of it now!) an issue with Ember.js as well. There you also have the issue of the property system being based around string value accessors so TypeScript doesn't have much leverage to provide value. That said, unless a project commits to maintaining definitions itself some slightly out of date definitions are likely better than nothing.
I would use it if they had more utility methods, such as pluck.
Yea, I know this. But, like I said before, we just added 10 functions, and the file size got bigger than underscore.
Yea, I know this. But, like I said before, we just added 10 functions, and the file size got bigger than underscore.
Based on [your previous comments](http://www.reddit.com/r/javascript/comments/3537kx/underscore_lodash_ramda/cr1gmo5) I doubt you compared the sizes correctly and I doubt the size difference would be substantial as I mentioned it's only a max difference of 12kb for the kitchen sink so narrowed down to 10 functions it'd be considerably less.
See [my comment above](http://www.reddit.com/r/javascript/comments/3537kx/underscore_lodash_ramda/cr1ihzj).
But it's a good metric for weeding out bad ones. The not -so-secret truth about programming interview questions is that they are primarily used to eliminate bad programmers, not find good ones. Unfortunately They eliminate a lot of good developers as well. From a small companies perspective, hiring a bad developer could easily cost a million dollars. Passing over 10 good ones costs you nothing if you still find the right one in the end. Sadly this often ends in companies simply setting the barrier for entry too high instead of properly interviewing candidates. 
what klug3 said is correct. We use it to screen out bad people Struggling to hire engineers now mean salaries below market rates || selection process inefficient? Every tech company I know is struggling to recruit smart engineers. 
If you set the cookie via JS, you can also delete it (even "secure" ones (https), different from "secure" cookies from server, with httpOnly flag).
I definitely mixed up the concepts of curry and laziness - now that I'm more awake it's obvious :P I also include lodash-fp in the spectrum of everything 
I'm using localForage on two side-projects quite successfully. Definitely recommended!
How about using JWTs? To kill the associated session, just kill the JWT in localstorage.
Hi Kent. Just curious, why does #theCmatter ? Branding? What do your kids, family, and friends call you? 
Can we have documentation for previous versions? I'm working on a project that uses 0.8.0 and I can't get to the docs for that, which complicates things significantly.
Here's a library that gives you TTL and a maximum size. https://github.com/compstak/rolling-storage
Ah, yep yep :)
The reason I like REST APIs is because they are agnostic. I can load it from anything, anywhere. It only needs to be able to do basic HTTP requests and I can use the API. I've only read a little about the Meteor DDP but it sounds like it could end up being just as easy to consume some day? It seems like websockets will soon be everywhere, too. I agree that API and app could have a closer relationship though. I guess this is also where Facebook is kind of heading with GraphQL where they don't make generic requests but explicitly asks for exactly what the app needs? Also, I don't want Java. I want a Node.js API directly on top of a database. So I already kind of cut out the Java guys. Sorry. :) &gt;As for HTML/CSS I think a future trend will be to encapsulate markup and style entirely in Javascript. HTML/CSS are ways of architecting static webpages. It doesn't transfer well to application development. Instead I think we will see more of direct manipulation via Javascript. Templates, HTML and CSS resources be gone entirely. YES, and it will be AWESOME. Especially the scopelessness (yeah, I made that word up) of CSS is killing modularity at the moment. Also, I can't help looking at JSX and wonder why they have built this monstrosity to move a step backwards, even by having to include a compile step. Sure, JS templates might be harder to read than HTML/CSS in the beginning but it honestly isn't exactly rocket science.
I've never understood these completely. Is this something handwritten or are you using a special compressor? Both ways it's very impressive.
&gt; List the 10 methods you Thats exactly what I wanted to avoid, as that would require me to git history that stuff. There are more fun things to do than digging through old test cases :&lt;
Choosing the right framework is never clear cut, if you want to learn a front-end framework I would not invest in angular, since soon the v2 will be a complete new beast. After that it's true what you describe would work well with the mean stack. If you want to learn es6, aurelia is nice, or react + flux is starting to take off as well. On the server side, Express is pretty much the go to lib, it's a very very small framework, so do not expect any amazing feature from it. http://sailsjs.org/ is cool too 
&gt;The reason I like REST APIs is because they are agnostic. I can load it from anything, anywhere I Agree. And REST APIs are great in that respect. An excellent and standard way to publish and fetch web resources, but... RestAPIs are simplex (one way communication). Meteors way of mirroring a part of the database in the client and automagically sync the data with the server and other clients is the future when it comes to the internal app communication. With DDP you don't do any API "plumming". You just declare what should be persistent data in the client and the framework handles the rest. It takes a while to get used to, just like functional programming, but boy is it worth it :-) I have a dream :-) that one day we'll have some kind of Javalibrary/framework that completely abstracts away everything HTML/CSS. You define style and behavior of your UI components in Javascript, and the framework figures out what and when HTML/CSS needs to be injected into the DOM to make it work. Some GUI editor to go along that generates quality readable code from a UI mockup would also be nice. Polymer is a good example. Sadly Polymer is broken in all other ways :-)
I wrote it up a year ago or so -- but I think I am going to put together an official-ish medium post on it. Thanks for the feedback. 
Unfortunately, we didn't start keeping alive old copies until 0.9.0, which are at http://ramdajs.com/0.9/docs/. However, there was a fair bit of change between 0.8 and 0.9: https://github.com/ramda/ramda/issues/753.
&gt; Also, I don't want Java. I want a Node.js API directly on top of a database. So I already kind of cut out the Java guys. Sorry. :) When the Java systems stop being a part of the applications, and just interfaced in the backend via Node, then the war is won. Because then Java is legacy, just like mainframes. The Java guys would hate that, and I would love it. I've disliked Java since day one :-)
This kind of stuff is always fun to read about, thanks for writing it up.
Holy crap that's an extensive list. Thanks.
Thank you for your answer. I could consider aurelia, it looks nice. What do you think about Meteor? I saw it is very popular, it has 24k stars on Github. Is it not worth to learn? I considered also sails, so I could look at it deeper. I wrote a small app with Angular 1.3 so maybe should I wait for v2.
 Use the Array literal. [].slice.call(arguments)
Use immutable data structures. 
The method proposed by pardoman is valid, but is playing with DOM, not the canvas API. Now, this is enough but not directly related to the canvas API you learn. You need to redraw the cleared zone (cleared with clearRect). stroke will only draw the latest undraw path. You can imagine the canvas as a sheet of paper, and the method you call on it as a pencil that you move on. So if you clear a zone through clearRect, you need to move your pen back on this area and redraw it.
Could it be that the map expects the coordinates in meters and not degrees? That would explain why they are so close to 0,0. [Edit] Judging by the numbers in the right corner that seems to be the case. See if they have some way of specifying a projection for your coordinates.
You got it! I finally got a response from their support team an hour ago and apparently that was one of the changes in this new version. Now I just have to fix everything they broke...
Ouch. Good luck!
Read the whole article. At the end he explains the process of getting it down to 1K. Generally speaking, both steps are part of the process. You start with hand-written code—with a good idea of how the compressors work and how you can help them—then run it through usually several compressors. Simple compressors that remove whitespace and unnecessary characters (simliar to UglifyJS) make it easier read your code before compression. More complex compressors will find repeating patterns and perform a sort of Zip- or RLE-like compression on the code itself, and then decompress it on the fly in the browser. But no compressor can beat having code written for size in the first place. There's all kinds of crazy tricks you can do to make the code smaller that a compressor couldn't figure out. A simple example would be replacing `if(test){a;b;c;}` with `test&amp;&amp;(a,b,c)` which shaves 2 characters in the right scenario. Or using different methods that have a performance penalty at the cost of bytes, like using `[].map(...)` instead of `[].forEach(...)`. His technique for "hashing" long property names is particularly brilliant!
Even if you had good points, any amount of logic or reasoning behind them would only get lost in your vitriol. While I find such aggressiveness most commonly used to mask fallacious or asinine arguments, you could really do yourself a favor by using less of what I would call the 'fox news approach'
The only right framework is no-framework.
Thank you. It's not often /r/javascript makes me burst out in laughter. :)
TeamTreehouse: https://teamtreehouse.com/join/first-week-free?utm_source=google&amp;cid=1027&amp;as_clid=297355d4-6045-4844-8f45-bcbd75433c5b:treehouse:e:g:1t1&amp;gclid=CP36spvIsMUCFSNk7AodIHcACQ I've used their service before just to check it out and it was decent. It's free for a week on that link (or if you just Google it and click the ad).
Hello! I'm one of the teachers for the KA JS course, which happens to have 13 year olds as its primary audience for various reasons: https://www.khanacademy.org/computing/computer-programming/programming But, as you say, in-person classes can be more supportive. I've written a blog post here for ideas in the bay area: http://cs-blog.khanacademy.org/2013/09/kids-coding-classes-in-bay-area.html
The reason for this is that with anything declared as a variable, including a class, the name of the var is not accessible in that way. This might help you: http://stackoverflow.com/questions/10314338/get-name-of-object-or-class-in-javascript
You, sir, are a genius. I will probably never be able to do something like that.
So for every strokeRect() I call, I'll need to call clearRect() to remove it then redraw it with whatever opacity / alpha value I want it to be? 
That's because it is an object, not an instance of the class. Have a look at [this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new): &gt; When the code `new foo(...)` is executed, the following things happen: &gt; 1. A new object is created, inheriting from `foo.prototype`. &gt; 2. The constructor function `foo` is called with the specified arguments and this bound to the newly created object. `new foo` is equivalent to `new foo()`, i.e. if no argument list is specified, `foo` is called without arguments. &gt; 2. The object returned by the constructor function becomes the result of the whole `new` expression. **If the constructor function doesn't explicitly return an object, the object created in step 1 is used instead. (Normally constructors don't return a value, but they can choose to do so if they want to override the normal object creation process.)** Emphasis mine. Since you're returning an object, you're basically overwriting the functionality of `new`. In your example, writing `var x = new MyClass()` is essentially the same as writing `var x = { bar: function(){ return "bar"; } }`.
setTimeout() has exactly the same problem though - see example: https://jsfiddle.net/xfLjqdt4/ You can use the for loop approach to sort-of-kind-of circumvent this, but it has strange consequences as it tends to result in processing the calls in a non-linear order: https://jsfiddle.net/xfLjqdt4/1/ In general, I think it's probably not a good idea to expect precision from timed events in single-threaded scripting languages running inside of a browser. 
I use https://github.com/marcuswestin/store.js/
We use callbacks. I think they are generally the right way of doing child-&gt;parent communication. I can see the concern that it can get verbose, especially when you're passing data more than one level up. However if you're doing that, then at every level you should catch the callback and turn it into a callback that is relevant at that level of abstraction. Kind of similar to [exception translation](http://allenlsy.com/NOTES-of-Effective-Java-8-Exceptions/#61.-throw-exceptions-appropriate-to-the-abstraction). I actually find using callbacks for child-&gt;parent communication elegant because it allows you to design your components such that props are the *only* interface to the component. So there's no other way for data to get in or out of it. That has made things a lot simpler for us.
[Javascript for kids](http://www.nostarch.com/javascriptforkids)
Bucky Roberts' goofball delivery and plain explanations have been pretty helpful for me with C/C++. His JS playlist might be worth a watch: https://www.youtube.com/playlist?list=PL46F0A159EC02DF82 For the longest time, I could never get my head around JavaScript's prototype-based object model, then this joker glosses over it in about 8 minutes in his Node.js tutorials, and *BAM*, got it.
&gt; ECMA may find itself in a position of having to adopt language features simply because everyone is already using them, not because they are necessarily any good. I don't know if I buy this. 1) ES5 had two popular module systems (AMD and CommonJS), but ECMA standardized neither of them, instead creating a new module system with its own syntax. It would have been pretty straightforward to pick one or the other, but TC39 forged their own path. 2) Its tempting to think of Babel as "future javascript" -- and it started off intending to be only that -- but it has turned into a language in its own right. It already supports a number of features (e.g. JSX) that nobody is even _suggesting_ go into the standard. Its a great testing ground for new features, since it already does everything that "regular" JS does, but it is no more destined for standardization than features in CoffeeScript were. 3) The bleeding edge of JS developers overestimate their size and influence. The community of people writing JS is probably an order of magnitude larger than any other language, and the vast majority of them are probably using a little bit of jQuery to make hamburger menus open up. I would venture that many of these people aren't even using source control, never mind automated build tools. TC39 is defining the language as much for them as they are for us. 
That technically creates a new array that never gets used for anything other than accessing a method on its prototype. If we're being picky (and I mean *really* picky), `Array.prototype.slice.call` is more efficient. If the length of the statement really bothers you, you can always use `var slice = Array.prototype.slice` at some outer scope and then use `slice.call()` whenever you need it. I agree though, javascript arguments are very weird to work with.
I do remember a while ago reading through an X11 dev's blog series on the X Windows protocol, and he had implemented a fair amount (mainly to teach himself the X protocol), using asm.js to compile only one library. So I do know that X-windows apps would be possible. I'm not sure about file access. I imagine that you could probably easily provide the correct API, but it would only access a virtual "ram-disk" like file system. Maybe you could do it with local storage, but arbitrary access to the browser's host file system would likely be out.
I assume: Callbacks -&gt; when you only change your parent's state. Action -&gt; when you change application state.
I learn a language best by doing. Get him in the developer console in Chrome and show him how he can use it to test out code. Then show him how to setup an html page with an included CSS file and JS file. Show him how he can change the CSS right in the browser and get it where he wants. Include JQuery for him, that will make it easier for him to work with the DOM. Then give him a small assignment like simon says or tic tac toe.
&gt; I don't know if I buy this. &gt; i don't
You mentioned Bootstrap. Are you using React Bootstrap, or are you just doing something custom that is similar to that? Any opinions about React Bootstrap? Also, do you have any public repos on GitHub of these concepts in-practice? Thanks. Great article.
I respectfully beg to differ with the article. Directives provide a powerful way to write well-encapsulated parts of your application. It's worth learning how to use them properly, and they play a more prominent role in Angular 2.
I happen to agree with you strongly. This type of interview is really just useful at evaluating who can solve trick problems while someone is watching within a time limit. It is not a measure of how well someone can write software.
&gt; is no more destined for standardization than features in CoffeeScript were Brendan Eich has stated that CoffeeScript did in fact influence ECMAScript 2015, for example, fat arrows.
We don't use React Bootstrap but it looks pretty cool. I would use it for future personal projects. I like that they provide you with both controlled and uncontrolled versions of the Carousel component for example. And thanks for the kind words!
Bravo mikrosystheme! Frameworks are truly awful and serve as training wheels for the masses. The biggest benefit of using a framework is getting an entire team or organization doing things in a consistent way. In this case, bialekino is doing this for himself so the benefits of a bloated and complicated framework to right out the window. I would recommend libraries over frameworks. Use jQuery to make your life easier in the DOM and doing AJAX. Use lodash to make dealing with data easier on the client or server. These two can take you a long way.
Codewars?
&gt; We’d also like to thank Mozilla, with whom we’ve been working closely since we started developing asm.js, and Unity for their support and partnership in helping bring asm.js to Chakra and Microsoft Edge. Aww, warms the cockles. Also, feels a bit surreal in contrast to the Microsoft we've known all these years.
If you're in the bay area, I'd recommend stopping by Hack Reactor. They don't teach kids as young as him but I'm willing to bet there's someone there that either knows of, or is personally running something javascript related for young teens. They are right next to the powell street station.
So the post is called "Stop writing angular directives", which is obviously a clickbait title. The post then goes on to say mostly nothing before closing with "Okay write angular directives but learn how to write them first". Great.
asm.js
Thank you. I did use a little bit jQuery, so it could be a good choice.
[AirPair](https://www.airpair.com/)
Great read, thanks for the article.
Unity has a JS variant called UnityScript, but to be honest the vast majority of Unity coders use C# and so finding UnityScript documentation is difficult. A very bad thing for anyone trying to learn Unity and the language at the same time. If you want more info on the differences though then it is available on the [Unity Wiki](http://wiki.unity3d.com/index.php/UnityScript_versus_JavaScript)
It would be great if the project had a more thorough Getting Started section.
typeof will not work. instanceof, constructor name will work if you dont return an object. function Stinky (){} // constructor a = new Stinky() // instantiating a instanceof Stinky // true a.constructor.name//"Stinky" typeof a // "object" 
Looks like React might have some competition :) I really like the direction Angular is heading, and it's definitely a much more comprehensive framework relative to React, which is considered a library. I think browser optimizations of shadow-dom and similarly recent API's are still a few years down the road (realistically for production usage without polyfills). Even if I'm wrong, the new API's will need to 'prove themselves' for a year or two in widely adopted browser versions. I see react moving towards abstractions that will increasingly distant itself from the browser, while these newer frameworks will attempt to leverage optimizations within browser itself. React already has the advantage of compiling to native, and the only way angular will achieve this is if google implements something in android's api to allow that to happen. 
Did you read the wiki?
Haha! Those shades! :-P
Whatever you do, be careful using function.name. It usually gets mangled when using Uglify and the like, and this may lead to unpredictable behaviour. Sure, you can disable function name mangling, but it's an important minification step.
Yes I know. But the code also sets it as a session cookie, so when I close chrome it's deleted. So I think it should be possible to delete the cookie somehow by ending the session without closing the browser. I just don't know how to do that.
Minecraft. [ScriptCraft](http://scriptcraftjs.org/) is a great mod for Minecraft that lets you write mods in JS. You can write js files and there's also an interface through chat.
Good stuff but I'm still partial to backbone/marionette and maybe using react for the display. The code feels more like normal js/html that's just written well and less like working in an entirely different environment. 
&gt;the only way angular will achieve this is if google implements something in android's api Nativescript already achieves this. In fact, you can read about Angular 2 running in a native mobile app using NativeScript at https://www.nativescript.org/blog/details/angular-2.0-running-in-a-native-mobile-app-using-nativescript 
With exception to JSX and lesser exception to CoffeeScript I really get the feeling other transpilers are primarily used by people who need JavaScript but cant be bothered to learn this language, and that scares me. Experience has taught me that this behavior will only serve to give me greater job security (as somebody who is comfortable writing in this language), but it comes at a pretty painful cost. This causes in a wider distribution of higher paying job opportunities for jobs I don't want and results in apathy, which is largely how we got here in the first place.
IDE support for ASM.js/Emscripten is still *really* underwhelming, though, and the usual Google-fu doesn't yield any useful information.
Exactly -- CoffeeScript was _influential_ in the direction of ES6 (arrow funcs, splats, etc.) but there are far more features that didn't make it in than those that did. I would love to see andand-style null-soaking accessors and I would hope that you would as well, but the language designers have passed on it for now. 
http://alexnisnevich.github.io/untrusted/ this is a game that you need to edit it's code (Javascript) to get to the next level...
Sure. To elaborate, I mean, there isn't much you *can't* do with JavaScript. Unreal Engine 4 was even ported to JavaScript. You will, of course, need to develop the interaction model that you want, and that could get fairly complicated, depending on what you want to do.
Up until now, I have avoided classes in JavaScript, but it's time to admit that classes are here to stay. The problem with classes is not classes. The problem with classes is inheritance. **Instead of encouraging people to not use classes, encourage them to not use inheritance.** Proponents of a classless approach usually tout the prototypal nature of JavaScript as being superior to and more powerful than classes. Yes, it is. So powerful in fact that it can be used to implement classes. It may not be perfect, and it may have a few pitfalls, but honestly it's not that bad. With the new syntax, I bet you'd run into far more problems sprinkling `Object.create` around your codebase, even if you're using inheritance.
I absolutely can't stand CoffeeScript. JavaScript is far more readable and enjoyable to code in.
There are a handful of physics libraries for JS * http://wellcaffeinated.net/PhysicsJS/ * http://brm.io/matter-js/#demo * http://schteppe.github.io/cannon.js/ * https://github.com/bebraw/jswiki/wiki/Physics-libraries If you are well-versed, you can do some really cool and complicated things with Three.js and some 3rd-party plugins for collision detection and physics.
I've found the [Babel REPL](https://babeljs.io/repl/) to be a far more enjoyable environment to play around with ES6/ES2015 features and even Stage 0 or Stage 1 ECMAScript features.
The github repo might help: https://github.com/PearlVentures/Essence It _looks_ to be like Bootstrap for React.
There's 6 points on that page though...
*COUGH, - LISP MACROS - COUGH*
It's neither really. The closest you can compare it with is React Native.
You could write a function that dynamically creates an anchor tag then calls the click event. Or do it directly in HTML with the `download` attribute: &lt;a href="movies/SexyPorn.zip" download&gt;Download!&lt;/a&gt; Otherwise, you'll need to download it over AJAX.
Try a less physically painful color scheme. I couldn't even look long enough at it to read the headings.
changing the index wouldn't change how many items were in the array, it would just change how you refer to each item.
or &lt;a href="C:\Windows\SecretFolder\GayPorn\Movies.exe"&gt;Download!&lt;/a&gt;
Yeah this is definitely the optimized solution. OP, I think this is what you're looking for
Once you download it over AJAX, how do you save it?
Well, you kinda answered your own question, but the one thing you missed is that lack of mutations and side effects helps immensely when many teams are working on the same product. You can perform whatever data transformations you need for your part of the product without having to worry about breaking some other part of the product.
[Babel](https://babeljs.io/) has some rudimentary TCO compilation. There is another transpiler called [Brushtail](https://github.com/puffnfresh/brushtail). Otherwise, if you really want to express your code with recursion without blowing the stack, and don't want to use transpilers, then a trampoline is still an option.
because it has a steering wheel?
For performance, browsers and node will probably optimize the tail call when JITed, but it'll almost certainly throw a stack-overflow error if you try to rely on it. My advice is to start writing point-free (is that the correct term?) but don't do flow control via TCO yet. While on the subject, TCO is a functional programming tool, so I'm going to recommend you use Ramda.js to fill up your toolbox with other important FP tools.
Create a datablob of the file, create a uri for the datablob, create an href to the uri Or window.location = uri
I'm not a fan of Object.create... But just because es6 introduces classes doesn't mean they are worth using. Most of the time closures and functions are cleaner and less error prone. 
Surprise! io.js 2.0 introduced ES6 "numbers are indeterminate" mode.
You're welcome :)
Not sure the intended effect. It's a bit odd on mobile. Tried dragging through it but it didn't really work. Tapping it spins stuff. 
I only ever truly worked on Angular 1.3 on one project. It feels so non-JS but its disgusting how easy you do things with it compared to native libraries. I have no idea what I just read in this 2.0 article but I guess I have to get even more open minded. Were they inspired by some other language?
This is search engine for developers and programmers, it enables you to search across websites as well as cloud apps. I'm looking for feedback. Thanks
Well, guys, I hope I am wrong. These are excellent points. If you are really right, then JavaScript becomes little more to the browser than assembler is in the operating system. It would be clear that it is not ECMA's job to define a language that most people code in, but rather a kind or compilation target. An interesting possibility, for certain.
That is a limitation of the library used for compilation. 
There is absolutely nothing wrong with classes as they are. My problem is with people mistaking them for classes in other languages. JS uses prototypes, yet we lots of people not aware of that. I wish we could have a discussion seeing this from all sides.
Actually it just got updated to throw a compilation error.
I assume it's written by the same guy who wrote the `Date` class.
Can you be a bit more specific? There doesn't appear to be anything complicated here. It looks like a fine beginner project.
You raise very, very good points and I thank you. Tell me how refactoring Angular code would go. The syntax seems so scary/cumbersome/
XSS should be addressed. Also, everything is gzipped.
You link is asking me to sign in to something and not taking me to the code....
You're technically right, in that TCO is an optimization that compilers (AOT and JIT) perform, and the functional programming tool I meant is Tail-Call Elimination, or Tail Recursion, or just simply Tail Call, and has to be specified by the language, not an implementation detail of the compiler. But in practice, Tail-whatever usually means rewriting this boring recursive function: function fact(n) { if (n==0) return 1; return n* fact(n-1); } into this TCO or TCE or Tail-Recusive form: ~~function fact(n, acc) { if (n==0) return 1; if (typeof acc == "undefined") acc = 1; return fact(n-1, acc*n); }~~ Edit: Holy crap my second example is wrong, this is why you shouldn't reddit at 1am. function fact(n, acc) { if (acc == null) acc = 1; if (n==0) return acc; return fact(n-1, acc*n); } 
I've done both, and for some projects I do frameworks and for some I don't. I think it comes down to the scope of the project for me; if I'm doing a huge project, I like the structure that a framework provides. I like how it ties stuff together in the way that everyone will expect it to be tied together. But mainly I do data visualizations and mapping stuff, and a framework can sometimes be overkill/more trouble than it's worth. Especially for stuff like Leaflet and D3; at that point I'm more of a Leaflet or D3 programmer rather than a Javascript programmer, and I've found that frameworks can get in the way of that since they're not really necessary for that code most of the time.
I reformatted the code so it's valid javascript but didn't actually change anything: var autoVisitMatches = function(){ jQuery('#spotlight .thumbs .match').each(function(){ var match = jQuery(this), url = match.attr('href'), popup = window.open(url); match.remove(); popup.addEventListener('load', function(){ popup.close(); }); }); }; setInterval(autoVisitMatches, 1000); I'd need to know exactly what you're trying to accomplish functionality wise to edit the code. 
Thanks! I'll try the console.log thing and try to cut down on the globals. Tmp is supposed to return with a number location for a place on the board like '13' which would be row 1 and column 3. The "rc"+tmp id should link to the table cell of the corresponding row and column of the number. I guess I need to figure out a better way to send that "tmp" variable around. I'm fairly new to JavaScript so I'm still trying to learn good practices.
Download "RFSim99" - a disaster waiting to happen.
See my other reply for a semi-solution.
Ooooh, that makes so much sense! I can't believe I forgot to set active_player! I'll try fixing that now. Thank you!
&gt; If you don't follow good practices, I'm sure you'll end up with a pile of shit. A "framework" is a set of libraries plus a set of (enforced) best practices. Frameworks will almost always provide more than what you need. You can eschew them and write everything on your own, à la carte, and it might be easy to keep it all in your head. But if the scope of the site grows, or more people start contributing, you'll find yourself writing systems to manage your individually-simple components, and using best practices to avoid stepping on toes. What you end up with is either a mess (the most common situation), or, a half-baked framework of your own. Why not save yourself the effort and use a framework from the start? Tom Dale and Yehuda Katz (primary authors of Ember.js) gave [a great 20-minute keynote about this topic recently.](https://www.youtube.com/watch?v=jScLjUlLTLI)
So I went through and looked and as far as I can tell, within the minimax_recurse function it does look like active_player is working properly and I haven't seen it undefined yet. It does look like the minimax_recurse function is getting caught up on the subalpha = minimax_recurse(board2, other_player, depth + 1); line though and it doesn't seem to go back to continue after that line but I could be mistaken. I changed a few things and created a tmp_moves array which stores the tmp move values so they aren't lost but I'm a bit stuck now on how to get the correct one out of the array. I seem to be losing values after the minimax_recurse iterations and I can't figure out how to get the "best_move" value that I need. Any ideas?
I go there and nothing happens. I don't see anything.
My advice would be to leverage existing libraries as much as possible; that way you can spend time on the things specific to your game. You could look into [Phaser](https://phaser.io/) for all the features you listed (it's easy to get started and they have a wealth of examples), or [Pixi](http://www.pixijs.com/) if you need something lighter and at a lower level of abstraction (say, for performance on low-end devices). Secondly, you might want to consider more mainstream languages to target. The languages you listed are nice in their own way, but they don't have the appeal that would attract beginners to give your game a try, the community that would keep them learning on their own, etc. Why not use JS? There's tons of support for beginners, plus a lot of existing code (parsers, interpreters, AST-manipulation tools) you can leverage. You can embed [Tailspin](http://wthimbleby.github.io/tailspin/) or something in your game to run user code.
Added the link.
As soon as 500 lines of jQuery spaghetti aren't good enough anymore, you'll need some architecture. You'll need a way to organize your code and you'll need some abstractions to avoid repetition and to make things more readable. You just created a framework. Now, the problem with this framework is that it lacks maturity, you probably didn't write any tests, and you also probably haven't written any documentation. Naturally, there also aren't any 3rd party resources and developers who are already familiar with this framework do not exist. Since it's the very first iteration of the framework, it most likely sucks. There are most likely some bugs, some poor design choices, performance issues, scalability issues, and it also might make things hard to test. Don't get me wrong, it's still an excellent exercise, but it probably isn't something you should use in production. Certainly not for something big. If small and simple is the most important thing to you, go with Backbone. Compressed, it's about 6.5 KB.
No, you are not crazy, but you will be redoing a lot of work that framework authors have already done for you. An important "feature" of not using a framework is that nothing breaks unless it's your own fault. Framework authors try to decide what's best for their users and sometimes that means changing their minds, so you get breaking changes every once in a while. This isn't so bad if you're actively maintaining it, but try to imagine upgrading from version 0.x to version 3, you might as well rewrite it. You get features (a.k.a. bloat) that you don't need, that others have requested to put in the framework. This is the "modularity shaming" in the JS community recently. For example, a basic TodoMVC app with Ember will cost ~300KB gzipped (Ember, Ember Data, HTMLbars, jQuery), which is overkill for small apps or even medium to large apps. Using only what you need will allow you to keep the codebase minimal and build web apps that work on shitty mobile connections.
Do you have any open source projects that I can look at so I can see how you organize a not so small-ish app? I'm just curious because a framework actually helps me structure my app and I've never actually built one without a framework. I'm kinda new to this business too, so I'm looking to learn as much as possible. Thanks!
I simply google for a keyword or two, and the world "npm". On the first result page there's usually 5 or more npm modules, and the most popular ones usually on top.
First thing I noticed is that it's a dart program, which compiles to javascript but is not written directly in javascript. This makes it harder to read the source code. Seems pretty simple though in concept. You click a link which calls a javascript function that probably uses setTimeout to increment the percentage until it gets to 100%, then updates the equipment list. Here's a simplified version I made for you in jsfiddle, to demonstrate how this could work using just javascript and jquery: https://jsfiddle.net/tmzmj31d/
There are two things here and is important not to mix them up. Firstly how do you organize the code when you write it. And secondly, how does your browser see it from your deployment site. I would suggest that for readability sake, you should properly organize your code in different files and folders and refer to all of them in your html. When you are ready to go live, you should use something like gulp or jslint to combine, and minify the js code and serve it out as a file.
Use ES6 modules (and classes). http://www.2ality.com/2014/09/es6-modules-final.html Since you'll have to use a compile step either way, you might as well just go with TypeScript (1.5+). Surprisingly, it's the least amount of hassle. Just get Atom + TS plugin or Microsoft's recently released VS Code. Well, if it's just a few hundred lines, you can of course just stick everything into a single file. However, if you want to get most out of this learning experience, you might want to go a step further and structure your project in a way which would also work for something bigger. While YAGNI (you ain't gonna need it) is something you should always keep in mind, it's okay to go a bit overboard while learning. The more experience you can gain, the better.
Thanks for the input! I am pretty new to programming in general and JS is my first actual language, so I'm not sure if I'm 100% clear on your terminology or the use of these tools/how they work. If you have an extra moment, would you mind explaining specifically what you mean by "compiling step"?
Will the variables and functions have access to those in different files before combining them with those tools?
This question is better suited for /r/gamedev I think. Many game engines these days are scripted in lua, so that'd be my first priority for languages to interpret if you want to give people a relevant tutorial.
You are already on the right track. Sure you could spend a long time reinventing the wheel but if you don't have much experience you are much better off learning a framework which has already implemented some good practices. As you learn more javascript you will learn how to take more control and maybe use frameworks when you have to. Although saying that it doesn't mean you should always start with a framework but a SPA that needs a backend database is likely to benefit from one.
&gt; Most people are running away from JavaScript You unintentionally reinforced my point exactly. I stopped reading after this.
How many people use this kind of color scheme in their text editor? It's not a good color scheme for a blog. Even if you personally like it.
Yep, if you just cover your ears and just go "LALALALALA I CAN'T HEAR YOU", none of your views will ever be challenged.
Debugging JS is witchcraft. 
Normally I wouldn't but your comment sounded like troll bait from the start and gradually rolled into something valid. The reason why many people currently bother with a build step is because that is what the tools require and not for any other reason. In that regard the tooling is the cause and not the effect. I think you got this wrong because your bias tells you the tooling is required, which it isn't, its just extremely common.
They will if they're available. Remember that Javascript uses lexical scoping. Any globally defined variables will populate the same namespace regardless of what file they're declared in. This means that, in the browser, all global variables will be declared against the window object. This works differently than PHP or Python in which cases you must import, include or require modules from other files. Given this, to avoid naming collisions, it is advisable to avoid global scope by using namespaces.
You don't. You can't. It's not your decision and there's nothing to prevent them from or make them do it.
Import image into *canvas* html element, and then use CanvasRenderindContext2d to allow user modify image.
I personally don't like it, but I learnt to accept that my taste is not necessarily a universal metric of good.
By writing an image editor in javascript (or in whatever language compiles to javascript).
&gt; In that regard the tooling is the cause and not the effect. In this context, "tooling" refers to things like call-tips, auto-complete, type-checking, refactor/rename, and things like that. Things your editor/IDE can do for you because more information is available to static code analysis. It's about the "toolability" of the language itself. TypeScript and Dart can offer much better tooling than ES6. ES6 is a big improvement over ES5 though. Modules and classes add a lot more structure in a declarative manner. Now you can do things like jumping to the definition of some method which you imported from some module or renaming some method/class/module. Your tools now know where all these things came from and they also know about all the other places where they are used. With proper tooling, more information is right at your fingertips. You can just look at the methods and fields some object has. You'll be also told about the return value of some function and how many and which kind of parameters it expects. You have to check the documentation a lot less often. Additionally, now the entire program is plastered with sanity checks. If you screwed something up or if some external library had some breaking changes, you'll be told about this problem right away. It's true that unit tests also help with this, but most people actually can't be arsed to write that many tests. Just adding some types to fields and function signatures, on the other hand, takes virtually no effort at all. You'll also feel more inclined to do that because you'll already benefit from this as you write the code.
Thanks for the tips! I'm working on a new version which hopefully increases performance.
This isn't about my taste. When I said "physically painful", I really meant exactly that. Well, text is easy. Just go with black-ish on white-ish with a contrast of at least 7.5 (WCAG 2.0).
Utility wise q, lodash, nconf, lru-cache, dependable and moment are in pretty much all of my node projects.
This is pretty fun! Good job 
Table rows are structural elements without visibility. The color won't show. Set the color on each cell
Actually really fun to play. I like the physics as they are right now. Just the right amount of time to decide to go up or down based on the obstacles direction. 
Tutorials on what? You can't stop them from editing it if they want to.
&gt; They are not painful at all to my eyes. That's nice. I can eat peanuts, milk, eggs, tree nuts, fish, shellfish, soy, and wheat. Anyhow, it doesn't matter that you're fine with it or that OP is fine with it. If you use an exotic color scheme for the body text of your blog, fewer people will read it. *That* is the thing you have to be fine with. Do you like the color scheme of your text editor that much that you'd rather have fewer people read your articles than use a something more default?
"How do i allow a user to edit a photo". He doesn't want to stop them. He wants to let them do something with the photo.
Thanks! How's the performance on your computer because on my laptop it runs pretty slow?
Boring. You won. Have a nice day (painted in your preferred colors).
I like it.