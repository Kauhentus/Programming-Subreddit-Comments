One thing I dislike about the proposal though is there is no way of dynamically accessing or setting "jailed" fields inside a class, like `this.#[secretKey]` where `secretKey` is a symbol or string. IMO they put a little too much effort into making them secure, to the point of disallowing features that would not have compromised security.
I can only see that the commands are queued. I don't see any code that start the queue processing.
This would require also defining `undefined?.z` to be `undefined`, to enable `x?.y?.z`. 
I don’t see how that changes my point? Just replace the word “article” with “library”...
I see a pair of empty parenthesis after `result.data`. Are you expecting `result.data` to be a function? If it is not, the attempt to invoke it will produce an error that will prevent logging to the console.
Ok. I didn't really say that RESTful Node API were totally outdated or irrelevant, as in "don't use them anymore". I'm working with REST every day. What I meant is that a new library in that space (Node, Mongo, REST, etc) would have been a lot more relevant 3-4 years ago and it's not really where innovation is headed which is why I'm surprised someone would put so much effort into that *today*.
If you do JSON.parse(xhr.response) you will get the array. The API being free isn't a signal that it's bad or low quality. Everything you're doing is normal. The response text IS a string and should be.
very basics
If there was a post like "How to Read Legacy Code: jQuery Edition" then that would be great! But jQuery should not be taught as a solution for anybody writing anything new. 
I was merely expressing a concern that a significant portion of developers might expect `a?.b` to operate more like `a ?? b`, which seems to be validated by some comments here and in part by the data, with nearly 1 in 3 respondees who recognized the operator expecting it to return `null`. The issues in an existing codebase only evidence that the behavior is not well understood, and not that the original choice was incorrect--I didn't make that codemod. Ultimately this boils down to a question of interpretation and expectation. Given that it seems the expectation is more for `undefined`, I'm happy to concede that that should be the behavior. Without discussion though, we probably wouldn't know to expect such widespread misunderstanding when it launches, nor the exact ways we should watch out for it to break.
I agree that this is the crux of the issue.
Awesome! Good to hear! Yeah that's exactly the kind of situation we had in mind while making this :)
Heh, `?.` does actually short-circut though, hence the confusion I think :)
It is promises but it's still an open question. There is work into finding a more ideomatic way of doing asynchronous stuff in general. Promises work for now though
Generally rollup is recommended to build libraries, and webpack to build websites. Although it is not clear from your post what do you need the build step for. Do you have static assets (images, css, etc) that you need to bundle? Are there any other consumers?
What is Reason? I use music software called Reason so it's polluting my searches.
I made sidecar to simplify my modular nodejs workflow. I'd like to know if sidecar seems useful or if there's a better way I could be achieving the same result. Thanks! https://github.com/quinton-ashley/sidecar
Ehhh... yes and no. `undefined` can also be used to signify "use the default" for optional function arguments and spreading (and consequently default props in React).
It's optional. But if you want your extension to be the only one that can access the proxy, then that's basically impossible, because there's no way to securely store data into a browser extension.
Ignore everyone else and use Pug
I'm not for or against the look of it (at least for now) but it makes me wonder how annoyed some will get when coming from languages that use `#` for commenting a line. Imagine if I run over to another language and their private syntax was `//`
nobody?
That’s a fair point. I tend to agree.
Not quite. - Use `null` to represent a *value of nonexistence*. - Use `undefined` to represent the *nonexistence of a value*. This is consistent with both the property accessing and uninitialized variable cases, as well as its use with default function arguments, spreading, and even React props. Let’s look at some examples. First, it’s worth noting that undefined is the value of a variable that has been declared but not defined: let foo; console.log(foo); &gt; undefined Consistent with that idea we use `undefined` to represent that (temporarily or intentionally) a value has not been defined. `null`, however, is a value in its own right, explicitly representing an empty or none value. For example, one could write an async fetching API where: query.result === undefined // Query is still fetching query.result === null // Query returned no result Here `undefined` signals that the value is not yet resolved, whereas `null` represents a resolved value of nothing. But `undefined` can be used in non-temporal examples too. Consider a survey where: participant.hair === undefined // Participant did not respond to the question participant.hair === null // Participant is bald In this case, we use `undefined` to represent the nonexistence of a value, whereas `null` represents a value of nonexistence. This is important because JS (and React) actually treat these cases very differently. Take default function parameters for example: function setMeshes( face?: Mesh = DEFAULT_FACE, hair?: Mesh = DEFAULT_HAIR, eyewear?: Mesh = DEFAULT_EYEWEAR, ) { … } setMeshes(ROUND, MOHAWK, GOGGLES); // Sets round face, mohawk, goggles. setMeshes(OVAL); // Sets oval face, default hair and eyewear. Default parameters that are unspecified are simply variables that are declared and not defined, which we know are `undefined`. Knowing this allows us to explicitly trigger default parameter values by passing `undefined`: setMeshes(OVAL); // Sets oval face, default hair/eyewear. setMeshes(OVAL, undefined, undefined); // Identical. setMeshes(OVAL, null, null); // Sets oval face, no hair, no eyewear. Note that `null` does not trigger default param behavior. This pattern also carries over to React props and defaultProps, where optional props are simply those that allow `undefined` values (expressed in Flow with a ? before the colon or, rarely, void). This gives us a rare example of where it is actually correct to use an optional and nullable field: type Props = { title: string, icon?: ?Image, }; class InfoLink extends React.Component&lt;Props&gt; { static defaultProps: $Shape&lt;Props&gt; = { url: 'http://oculus.com/info', icon: INFO_ICON, } … } &lt;InfoLink title="Default info icon" /&gt; &lt;InfoLink title="Also default info icon" icon={undefined} /&gt; &lt;InfoLink title="No icon" icon={null} /&gt; &lt;InfoLink title="Custom icon" icon={WARNING_ICON} /&gt; In fact, a similar pattern is common in RESTful server APIs with mutation objects, where the fields of the object are used for setting/removing fields on a server entity of the same shape: post('/meshes', { face: 'ROUND', // Sets the face mesh to 'ROUND'. hair: undefined, // Leaves the hair mesh unchanged. eyewear: null, // Removes the eyewear mesh. }); This is similarly reflected with `JSON.stringify()`, which removes `undefined` values but preserves `null`s: JSON.stringify({a: undefined}); &gt; '{}' 
Full source code top to bottom? Rarely. Partial source code to see how other people implement specific features? Often
[a lot of loading and then nothing :(](https://i.imgur.com/LN5fzee.jpg)
The number of bytes is a best guess based on your Internet speed. You likely didn't receive the final file. Try refreshing. e.g. If your firewall prevents MP3 files, you won't receive the MP3 file at all, despite the counter assuming you are still downloading a 5MB file at X bytes/second.
ReasonML, a compile-to-js language. https://reasonml.github.io
Does this work on linux?
is that this? [http://oli.cmu.edu/coming-soon-oli-website-redesign/](http://oli.cmu.edu/coming-soon-oli-website-redesign/)
Yes! And that is no reason to hate rocks.
Oh, reddit just got worse, thanks redesign!
 &lt;input type="checkbox" onclick="foo(this)"&gt;&lt;/input&gt; &lt;script&gt; function foo(objv){ objv.style.display='none'; } &lt;/script&gt;
&gt;I can only see that the commands are queued. I don't see any code that start the queue processing. It gets automatically started when tcl.queue is called.
It never replies to some command. Therefore, the callback is never called. However, it quickly responses to the command if a system is currently responding in real-time. Is there a hack around this?
This project was actually started a few years ago, so the technology was a bit more relevant back then. It's possible that if the project had been started today different technologies would have been used, however I don't believe that takes away any relevance to the project, since it's focus is not on the tech being used but the _utility_ that it provides, which is minimizing the time it takes to build an API for an MVP. Also, since REST is the current standard and this project is meant to help developers _today_, I believe that actually makes it more relevant.
It is supposed to be a function. It works for some of that commands that respond. Also I put a console statement to make sure that that wasn't the issue. Happen to know of any hacks around this? Thanks
Yeah, I realize that `x` in this case wouldn't be a proper option abstraction, I just thought it might act like one. I'm not sure if I'll find this useful yet
Seems to me `undefined` is correct, but `null` is more useful in actual code. Think of it like this: Normally `x.y` returns the value of `y`, because `x` is defined. If `x` happens to be `null` in that particular situation, your code is still written as if `x.y` is defined, but you want to avoid null reference errors. True, `y` is not *actually* defined in that case, but the way the code is written, it's handing `x` as a type, and that type has `y` defined. Do you get what I mean? In isolation, `x.y` is `undefined`, yes, but in the actual code that's using it, `y` normally *IS* defined. So since that's the case returning `null` is just more useful to the programmer. Another argument: var x = {a:1}; var y = {b:2}; var z = null; x?.a returns 1 y?.a return undefined If you have `z?.a` return `null` that lets you know that `z` was `null`. If it returned undefined you can not tell if z was `null` or if `z` did not have the property set.
Anti-pattern of what? and why an anti-pattern? Anyway, that was just a (contrived) example of the meaning I give to `undefined` and `null` and why we can't really make that distinction between the 2 in a real world. You're reading too much in my comments, let's keep the context in mind ;-)
The problem is that cmd1 is supposed to get executed in normal manner, however if the system it's calling is taking too long to respond and that just stalls the entire program. This happens because tcl.queue is using the same shell, so as long as cmd1 is on that shell, cmd2 wont be executed. So I wondering if there is a way to say if cb is not triggered in 5 seconds, then do something (clear the shell and move with cmd2). Thanks
Any chance we could see the code?
You can use 2 shell instances. I doubt there will be much of a performance difference. Or you can use setTimeout to check if the callback was executed, and if not, clear the shell. 
See, here's the thing. Would I ever use jQuery on a new project? Likely not unless someone else needs it... But why does everyone ignore that jQuery is a pretty big part of the web today. Maintaining existing projects or continuing work is something that needs to be accounted for. Learning it isn't imperative but making sure you can play ball could make a difference.
Well, regardless of what I think, congrats on the release.
Thanks! :)
Impressive, it really works. Mind to explain why?
/u/noisylettuce is correct. `this` inside `function foo()` references the function itself, not the element. `this` inside the `onclick` attribute of an element, references the element. as far as #2 goes &lt;input type="checkbox" onclick="foo.call(this)"&gt;&lt;/input&gt; &lt;script&gt; function foo(){ this.style.display='none'; } &lt;/script&gt; should work.
My apps have a lot of downtime so it may be a good idea to use reason, as well as rationality and logic. Currently I'm not using any of these tools when it comes to deploys and managing uptime.
https://gamingmedley.com/engine/scripts/gamengine.simple.js :P
That's awesome! Have you made any other game-like programs since then?
Answering your second question: You could pass _this_ to the function by using the call() method like: foo.call(dummy) The call method makes the first parameter available as _this_ in the functions scope and runs it. Since _this_ in the onclick handler already refers to _dummy_ you could just pass this to foo(): foo.call(this)
fuck rocks tbh
Probably because of their "Don't break the web mantra" that said I can't wait to smoosh my #private vars
&gt; it gives you information about z Yes, but that is not the motivation for the operator. This operator is, in `x?.y`, focused on `y`, not on `x`. It is not intended to be used to retrieve information "about `x`" but for the situation where you want `y`. Remember that this operator is motivated not so much by `x.y` but by `v.w.x.y.z`. With this in mind, I can't really think of any reason I'd be interested in knowing that in `v?.w?.x?.y?.z` "one out of `v`, `w`, `x`, `y` or `z` is `null` but I don't know which one". Also, the same example you give can be seen from the other side. How would returning `null` differentiate in `x?.y` that `x` or `y` is `null` if it can happen that `x` is `{y:null}`? One case or the other, depending on what behaviour you choose, is always going to be un-differentiable. What the spec does is simply acknowledge that indeed we don't really want to differentiate. The point you're making sounds like an attempt to abuse for unintended purposes. While I won't discuss the merit of such purposes, I don't really think any specification would be _better_ if it was written with the idea of allowing abuse. In any case, I was just explaining the rationale that makes `undefined` a more common expectation as expressed by the spec itself, but I'm not the appropriate person to discuss the _usefulness_ of one option or the other because I don't have that much interest in the operator either way.
&gt; With this in mind, I can't really think of any reason I'd be interested in knowing that in v?.w?.x?.y?.z "one out of v, w, x, y or z is null but I don't know which one". Actually that's an even better example! If you start with `null`, anywhere, it continues as null. Switching to `undefined` means "the variable existed, but did not have the property". While `null` tells you the variable was `null`, end of story, we did not even look at the properties. Actually your argument has convinced me that `null` is the more correct thing to do.
&gt; should work. Yes, it worked. But I still need to understand what this `call` keyword means. Currently, I only understand why `foo(this) + function(obj)` works ...
Perfect, crystal clear explanation. Thnks! +1
&gt; that can handle millions of requests per second That's great but realistically 99.99% of developers will never need that kind of performance. For most projects developer productivity is far more valuable. Not saying that Phoenix doesn't accomplish that though, just making a point about performance.
I don't know how it tells you that. Say the operator has the behaviour you propose. Say you have: x?.y?.z And it returns `null`. Can you tell which one of `x`, `y` or `z` is `null`? All these values for `x` return `null`. { y: { z: null } } { y: null } null On the other hand, you're assigning a meaning to `undefined` that is not what it is meant to convey. Returning `undefined` is **only** meant to convey that there's no useful value for that expression.
Contrary to what's been said so far, `this` is _not_ the function itself. In fact `this` will rarely if ever reference the current function. `this` will generally be used to refer to the object from which the function was called, for example if you called `foo` like: myObject.foo(); Here, inside `foo`, `this` would refer to `myObject`. This is not the golden rule, but it is the most common for most function types. Different functions behave differently (arrow functions, for example, have a `this` matching the value of `this` in the context in which they were defined), and sometimes when functions are called, they can have their `this` values set to something else - something that happens a lot with event handlers. In fact when you write: &lt;input type="checkbox" onclick="this.style.display='none';"&gt;&lt;/input&gt; You're actually creating a function with the body of `this.style.display='none';` and assigning it to the `input` element's `onclick` property. &lt;input type="checkbox" id="dummy" onclick="this.style.display='none';"&gt;&lt;/input&gt; console.log(document.getElementById('dummy').onclick); /* onclick(event) { this.style.display='none'; } */ _(Side note: its recommended you use methods like `getElementById` when referring to elements by id rather than referencing their id names from global, e.g. `dummy.style...`)_ When you click that checkbox, the `onclick` function is called and the `this` value is set to the `input` element itself. You can see that function getting called as: input.onclick(event) // &lt;- called from input, so `this` becomes input When a function is called by itself without an object, it has no `this` to refer to so it falls back to using the global object, `window` (or it can also be `undefined` in strict mode). foo() // &lt;- no object, no known `this`, use window When you set onclick to call a function like foo this way, you get foo called by itself within the onclick function which is called from the element: &lt;input id="dummy" type="checkbox" onclick="foo()"&gt;&lt;/input&gt; console.log(document.getElementById('dummy').onclick); /* onclick(event) { foo(); } */ So while `this` in `onclick` is the input element, `this` in foo is `window` when called. What you want is to give foo access to the input element so it can use it as you could as the code used directly within the `onclick="..."` attribute could. There's a couple of ways to do this (which have been correctly described so far). One way is to use the `call` method to call the `foo` function with the `this` you want it to have. Inside the `onclick` that would be `this` since there, that refers to the input element. &lt;input type="checkbox" onclick="foo.call(this)"&gt;&lt;/input&gt; The other approach is to just pass the input element into your `foo` function as an argument. No weird use of `call` needed, though you will need to make sure to rewrite your `foo` function to refer to the argument rather than `this`: &lt;input type="checkbox" onclick="foo(this)"&gt;&lt;/input&gt; &lt;script&gt; function foo(input){ input.style.display='none'; } &lt;/script&gt; When you set event handlers in JavaScript and not in the HTML, the handler function is automatically called with the `this` set to the element which may make things easier document.getElementById('dummy').addEventListener('click', foo); // foo called with `this` = input `addEventListener` basically does the `call` for you when it calls your function in this case.
I think the current error is better than "Unexpected token '.'"
I don't think OP has an issue with privates. The issue is the wacky # syntax. Why not just use a 'private' keyword like every other language?
I'll give it a go. 'this' refers to the checkbox only when its used in the html there. When you use 'this' inside a function/object it refers to that function. So you carry whatever 'this' becomes in run time through the function where it can be used. Otherwise you need to reference the object from its root like document.getElementById("id").style.... you could do this if you passed the id name through instead of the 'this' reference to the checkbox. 
&gt; This is not the golden rule, but it is the most common for most function types. `this` rules might also at different browsers? Or `this` is pretty standard cross browsers? &amp;nbsp; &gt; its recommended you use methods like getElementById when referring to elements by id rather than referencing their id names from global Mind to explain why? &gt; `this` in foo is `window` when called. What is the `Window` ? The entire tab in the browser that contain the page!?!?
I tried to find that song, Macrocosmos, but couldn't find it or the artist, Raivu, anywhere. Where did you get it?
Here's an unminified version: http://jsbin.com/xoyaxahuqu/edit?js
The use of `#` has been part of the spec since before becoming stage 3. `#` was seen as a requirement to help allow distinguish between public and private members. If you have a private `x` and a public `x`, how would you differentiate between the two? ActionScript, being close to JavaScript, had support for private variables and used a `private` keyword, but it handled them through namespaces. If you had both a public (outer) member and a private member of the same name, you could get to the public version in the class using the `public::` namespace prefix. JavaScript doesn't have namespaces, so a similar approach isn't possible. Instead the `#` token is being used to make this distinction. And while `#` is ugly (I don't disagree), I think it was one of the few left not already in use by the language. There's a discussion that goes into this in more depth and explaining things better than I have just now, but searching just now, I can't seem to find it. If you dig around in the google enough, you'll probably land on it sooner or later.
I think most people stick to Ableton these days
Yeah most don't, however its good to have quality options when you do. With [rest-hapi](https://github.com/JKHeadley/rest-hapi) our top priority is developer productivity so we chose technologies and standards that we thought reached the widest developer audience while also simplifying the developer experience.
undefined
From Raivu himself. He was a regular on a forum I administrated. I love the song.
None as nice as this one. It's always been my favorite.
It is not ugly.
&gt; this rules might also at different browsers? Or this is pretty standard cross browsers? Rules around `this` should be completely consistent across browsers. If not, then it would be a bug in the browser or its JavaScript runtime. But the rules can also get confusing. It's not always clear what `this` is given that it's value can change based on many factors. MDN has some documentation around it: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this &gt; Mind to explain why? It makes it clear that you're referring to a DOM element and you're reducing the change of bugs from naming collisions. For example: &lt;!-- HTML: --&gt; &lt;div id="bob"&gt;&lt;/div&gt; // JavaScript: // somewhere up in the code bob = 10; // ... // somewhere lower in the code console.log(bob); // 10, not the div or &lt;!-- HTML: --&gt; &lt;div id="alert"&gt;&lt;/div&gt; // JavaScript: console.log(alert); // function alert(), not the div The fact that ids get defined in the global namespace is not good. You generally want to keep as much as possible out of the global namespace for this very reason. It can get cluttered and you can have conflicts when you have similarly named items there. &gt; What is the Window ? The entire tab in the browser that contain the page!?!? In browsers, yes, basically. Its a little overloaded but `window` in browsers serves two purposes: 1) to represent the browser window or tab and contain the methods and properties that relate to that "window", and 2) represent the object containing all global variables used by JavaScript - the variables that can be accessed anywhere, no matter what function you're in. Again, you might be able to start to see a problem here with conflicts. What happens when you want to define a global variable called `name`? Well, you might have problems because browser windows also have a `name` property setting a global name doesn't just give you a global variable called "name", it also sets the name for the browser window. Depending on where you run your JavaScript, the global object isn't always `window`. In Node, for example, where there is no browser window, the global object is accessed through `global`. Makes a little more sense, right? But browsers are weird :P
I'm at work right now, but I'll post it on GitHub when I'm home. I made a [repo for it](https://github.com/GamingMedley/rpg-overworld-engine), but simply can't populate it from my work station. I hope I still have a copy!
What differences are there between the bundles? If it's user data, I'd include that in a separate script.
Shared link does not work :) use this URL instead: http://justgage.com
&gt; you're reducing the change of bugs from naming collisions. Perfect! Thnks. +1
me cri
well, I do self promote in this sub sometimes, not for cv, I’ve got a cool job, I spend a lot of efforts on each post, I share my, I believe, unique experience, I just don’t want my efforts wasted. May be a special tag for self promoted post could help.
And reading this comment made my heart jump too, I thought you were the one mentioned in the article!
That is a fucking horrible idea. Literally no purpose to doing so in any modern framework with a virtual dom. Obviously some libraries like D3 do not work at the virtual dom level so you have to manually rerender when props change but jquery isn’t one of those libraries. It’s not used internally and shouldn’t be used in conjunction with react/vue ever. If you have an older jquery codebase, you should replace functionality one component at a time in isolation.
It's called simple.js because of how simple it is!
Youu managed to made something work at ie6? I don;t care who you are, but you have my respect.
I think that it will turn into TypeScript in the end, and because Microsoft owns it they will destroy it at some point. Other then that yes.
React or angular?🤔 I'd personally go for react
Backwards and cross compatibility was my specialty. I thought it would be all the rage to learn the tricks to support all browsers, but as they grew and converged, it's proved to be a useless talent.
Oops, that should have said "chance" ;)
&gt; JavaScript doesn't have namespaces, so a similar approach isn't possible. Instead of actionscript take a look at typescript, which seems to be the testing ground for a lot of new ES features. They utilize the private keyword, no namespace required. The typescript approach also has the benefit of using the same syntax that has been used by a majority of programming languages.
&gt; Without discussion though, we probably wouldn't know to expect such widespread misunderstanding Judging from your detailed first post, you clearly already knew of several scenarios a naive codemod would break before posting that issue on the proposal's repo. You mentioned you work at Facebook, so I can understand why it might seem easier to argue for a change in the semantics of one tiny proposal than figure out how to roll it out robustly across a monorepo with hundreds or thousands of projects in it. I'm curious what was the motivation behind the exercise though. This is a stage 1 thing. I also do work with rolling out codemods to other teams' projects, but never for TC39 proposals. In my company, we consider non-spec syntax to be unsupported (with exception of widespread things like JSX and Flow), precisely because supporting people using proposal syntax tends to be a pain.
Of course 99% of developers don’t need such a thing but what most developers do need is a fault tolerant backend and OTP which is something that ships with Elixir and nowadays most modern apps do require OTP. The fact that Elixir can handle that high level of requests is just an example of its power and speed. As SPAs start to become the standard approach a fast API is a necessity and the milliseconds count, waiting on a slow API server side is not fun for anyone. The users and industry want PWAs and if we as engineers don’t supply that demand efficiently then we’re not doing our jobs. In any case, you’re best doing it right from the start. Most web apps these days require persistent connections, need to plug third parties and with GraphQL slowly and surely making its way into the stacks Elixir is the sane choice. In terms of productivity, you can generate a solid JSON api with Phoenix is under an hour (yes, literally) and you can deploy this API virtually anywhere on any device and hook your SPA accordingly and it’s not going to cost you or your company much, I mean it’s byte code, just look at WhatsApp as a use case example running on Erlang. I don’t mean to ramble on here but while most developers and projects don’t require such performance they do require the availability options but most of all they require the speed. Speed is everything and Elixir delivers. 
Hi /u/throw_at_work_away, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
Hi /u/laugh3x, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/stockrco, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/Mark_Messa, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/pragya91, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/froooast, For javascript help, please visit /r/LearnJavascript. Thank you!
Does the link to the GitHub have to be the main submission or can it be in the comments?
Typescript is a superset of JavaScript that gets transpiled down into JavaScript. It's private variables aren't truely private and ultimately become public members in the resulting JavaScript classes. TypeScript's use of `private` is only to provide compile-time hints helping enforce your usage of those variables during the compile process. Any dynamic access will be able to pick up TypeScript's "private" variables without problem and there is no separation of scoping meaning collisions between privates in different classes can still occur. class Foo { private bar:number = 1 } let foo:Foo = new Foo() console.log(foo['bar']) // 1 - not so private The proposal for supporting privates in language will have privates that don't suffer from these problems, instead storing the members in internal slots with a hidden visibility protecting it from both dynamic (or any outer) lookups and collisions. I'm not trying to say _there's no other way_. I'm mostly reiterating what I've read in discussions that covered this topic. After going through enough, you kind of go, "oh, ok, well... whatever, FINE, if that's how it has to be" and accept defeat.
Adding a new reserved word is not the issue. Take this scenario for example: If you already have a private member called "a" inside object "x" what would you like to happen when you try executing x.a = "test" outside the object class. 1. Obviously fail on compile since there is no public property called "a"? Nope, this is JS, if the property doesn't exist it will try to create it. 2. Throw an error saying you don't have permission to access/create this property since a private one already exists. Nope, you just leaked your private class member information. 3. Try to hide the private property and create a new public one? Also doesn't work since this object would have to have 2 properties with the same name in run time. And the actual solution is to specify that private property names need to start with a specific character that is only legal for that usage so you can avoid public and private property name collisions.
Which shared link does not work?
Thnks! I've also posted there: ['This' inside function](https://www.reddit.com/r/learnjavascript/comments/8ubxyo/this_inside_function/)
It's because you are re-creating the regexp each time. When using `/g` in a regexp, it has an internal state. so instead of doing `something.match(/myregexp/)` do const myRegexp = [regexp here] .. all the something.match(myRegexp) statements here It is important that they all reference the same regexp variable, so the internal pointer that comes with global flag (aka `/g`) can be used properly. So no. It's not an inconsistency, it's just that everything in JS is a reference (except literals) and you were not using the API as you should have been :)
I understand the semantic difference, I just think you make too many mistakes when you lean heavily on the difference between them. Even in your comment you've used == which will treat undefined and null as the same thing. It's kind of like how in English we use 'yes' and 'no'. But in some languages (Swedish, I think is one) they have three or four words, affirmative yes, negative yes, affirmative no, negative no. This clears up the ambiguity of an interaction like "didn't you do the dishes?" - "Yes". Cause there is a word to say "yes, I did" and one to say "yes, I did not". The analogy is we live in a world of English speakers (Java,C,whatever) speaking in Swedish (Javascript), and you're going to get issues if you start using those extended forms. Also the analogy holds that it's not an indisposable construct - you don't really suffer a lot by not using it.
I'd go with learning 6, at my company all of our newer projects are created using current versions but a lot of our older projects remain 1.6. I think even if you learn the latest version you could easily adopt 1.6 style angular pretty easily, the concepts are similar enough that they're pretty transferable despite there being a lot of changes.
Dude, this is fucking impressive. You made this pre-canvas, I used to make games this same exact way, over 10 years ago, using the actual DOM for the game entities, the map, sprites, etc. Mine were never this sophisticated though, I would do things like make pong clones, space invaders, etc, using the dom. I only ever knew of about 2 other people doing this at the time, nobody was making games using the dom, they were all on the flash train. Really cool to see somebody else doing this. Would love to see the un-minified code.
I agree with everything you've said. &gt; you can generate a solid JSON api with Phoenix is under an hour (yes, literally) Can you point me to an article or tutorial on how to do this?
Thats a really good point I hadn't even thought of. Have an updoot!
&gt; Edit: I'm dumb, obviously they can't use the keyword because that would require adding a reserved word to the language. Still looks ugly and unintuitive... maybe the best option though That's exactly what that reserved word was reserved for ;) It's how ES4 was using it: &gt; Syntax: Some identifiers that were legal names in ES3 (let, yield, cast, is, and a few more) are keywords in ES4. Other keywords in ES4 were future reserved words in ES3, and correct ES3 programs do not use them (class, interface, public, private, and many others)... And its what happened already with `class` (also seen above) in ES6.
Did you bother to test that first and see if you were right? Because I just did what you said and I'm still getting 3, 3, 3, and 2.
React/vue ;) unless you *really* have to go angular than take latest
It's preferred to be a top-level comment (you shouldn't have to be prompted for it). Also, and I thought this would go without saying, but it has to contain the actual code.
Why not just use a maybe monad? e.g. const maybeX = Maybe(x) const maybeB = maybeX.map(_ =&gt; _.y) const b = maybeBe.unwrap() If that isn't terse enough, you could even muck about with proxies and getters: const maybeX = Maybe(x) const maybeY = maybeB.val.y // val trapping lookups using proxies const b = maybeY.real
A lot of stuff might fit better in /r/learnjavascript
Here's a sneak peek of /r/learnjavascript using the [top posts](https://np.reddit.com/r/learnjavascript/top/?sort=top&amp;t=year) of the year! \#1: [If you're looking to learn javascript, a professor at my college made a really cool free to use online textbooks that includes: exercises, clickable links, and lots of example files.](http://profsamscott.com/javascript/) | [4 comments](https://np.reddit.com/r/learnjavascript/comments/7xd7x0/if_youre_looking_to_learn_javascript_a_professor/) \#2: [To everyone currently enrolled at a college: don't forget to get your Github student developer pack. It contains a free domain name, digital ocean credit and much more.](https://education.github.com/pack) | [13 comments](https://np.reddit.com/r/learnjavascript/comments/8b81be/to_everyone_currently_enrolled_at_a_college_dont/) \#3: [Algorithms and data structures implemented on JavaScript with explanations, examples and links to related YouTube learning videos](https://github.com/trekhleb/javascript-algorithms) | [6 comments](https://np.reddit.com/r/learnjavascript/comments/8l09o2/algorithms_and_data_structures_implemented_on/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
I'm fine with not adding more syntax for this. Destructuring with default values is quite clean and does a great job of this for 99% of the situations I'd use a `?.` in. It has the added advantage that there's no dissent over what the values should be, because I'm setting them explicitly. Sometimes it's a destructuring assignment, and often it's on the args too. `({ foo: { bar } = {} }) =&gt;` is pretty clear that bar will be undefined. 
I used babylon.js for the game engine. The website is written using node.js, using preact and preact router to render all the static content. Babylon has been a great tool to work with, the typescript bindings make 3d development a lot easier, and the shader support is great (I use a custom shader for the greedy-meshed voxels and the editing tools). I bundle everything using browserify (I prefer it to webpack, and really like the budo development server). The backend data is stored in postgres using the straight `pg` npm module (no ORM, just hand written queries). And finally, everything is deployed on Heroku. I initially had it deployed on AWS Lambda, but was getting weird database time outs (which wasn't how I thought lambda worked) so just moved it onto $25 / mo heroku hosting. I've sold a few dozen parcels of land, so can afford to pay for hosting now. ☺️
Good bot
That's an extremely valid point frankly which I hadn't considered.
&gt; if(bX + bird.width &gt;= pipe[i].x &amp;&amp; bX &lt;= pipe[i].x + pipeTop.width &amp;&amp; (bY &lt;= pipe[i].y + pipeTop.height || bY+bird.height &gt;= pipe[i].y+constant) || bY + bird.height &gt;= cvs.height - fg.height){ location.reload(); } Maybe this code could be easier to read. Maybe that would have value not only for tutorial readers, but also for code authors who wanted to modify part of it. Because otherwise most beginners may just copy and paste and take your word for it that it does what it’s supposed to, without understanding what’s going on. 
Gladly for us and sadly for you. Still, amazing job, for real.
Actually, there are no big differences after 4.0 release. Check out this tool to see what has to be changed when updating - [https://update.angular.io/](https://update.angular.io/) It's safe to learn the latest version. You'll still be able to work with earlier versions.
I thought r/javascript was : 
Yes I know. I just can't submit the code from my work computer. I'll re-submit the link whenever I have the Github up, though I'll prolly just do the Github link at that point.
You replied to the wrong person, but as the right person I never said anything about React or Vue, did I? I said "tools" specifically and not js frameworks. Bootstrap, which you have to admit is a popular web-dev tool bundles jQuery. Or did until recently, idk if it still does. I'm going to assume there more users than just me in this thread who are familiar with Bootstrap. 
It _may_ help to actually output the results instead of their length :) The thing you need to consider is that, $ and ^ represent _positions_ between characters, not characters themselves. So you split before the line break (`$`)? Great. But the "end of line character" itself is still there, and so, will be in the fragment following the split (and so you get an additional fragment with just the final `'\n'`). You split after the line break (`^`)? Great too. But the "end of line character" is still there and now will be included in the fragment _previous_ to the split. As for `match`, it captures _the match itself_, and as you're matching only the special `^` and `$` you will get empty strings at those _positions_. As explained [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters)... &gt; ^ Matches beginning of input. If the multiline flag is set to true, also matches immediately after a line break character. &gt; $ Matches end of input. If the multiline flag is set to true, also matches immediately before a line break character.
I thought r/javascript was : ""All about JavaScript programming language!""
No way this is a legitimate article.
Not user data. Some parts of the code itself will be different. If we continue with the Google Analytics analogy, then let's say Google **switch** to a freemium model, i.e. some websites will pay to get more advanced features. So a website begins with including the [bootstrapping snippet](https://developers.google.com/analytics/devguides/collection/analyticsjs/) in their web pages. When users visit those pages, this results in their browsers making a call to load https://www.google-analytics.com/analytics.js . This is a single 35kb file, that was probably **packed** from many source files, hopefully **transpiled** from ES2015 or later, aggressively **minified** and is now just being served **statically**. So after said **switch**, the server at google-analytics.com will look at the Referer header and go "*Oh, this is from a user who visits example.com, they paid for features X &amp; Y, so I'll send an enhanced analytics.js which have them.*" or "*Hmm, a request from reddit.com, they paid for P &amp; Q, so here's their variant*". Note: there's only a single request to the server (in case this is what you imply with a separate script). One approach is to build (the pack/transpile/minify process from above) according to all possible feature permutations beforehand and then continue with the static serving. But I'm interested in the other approach: how to build those files **dynamically**.
Go with Latest Angular known as 5. The devs are pushing a regular update cycle and 6 will be here soon. Do yourself a favor and use Angular CLI. 
What is the benefit of sidecar over say \`npm link &lt;package&gt;\`.
Version 6 was released 2 months ago.
I see. Ya I think pre-bundling makes most sense, until it doesn't (only thing I can think of is if the bundle contains data from the req, even then I'd split those 2 parts: prebundled tiers, and one with req data).
Haven't seen this mentioned, but today ES2018 (or ES9 if you want to go there) has been posted on ecma-international.org. It has been finished for a while and includes some regex changes, object rest/spread, promise.finally, and async iteration: https://github.com/tc39/proposals/blob/master/finished-proposals.md but has only just been posted as the current ecma spec. Ecma news ref: http://www.ecma-international.org/news/index.html#Docs115thGA 
And that... is a microcosm of the JavaScript world right there. 
Looks ok to me. Is there something you see that's looking fishy?
Undefined because if x is null, y doesn't exist.
I've used this before: https://github.com/jhen0409/react-chrome-extension-boilerplate
There is a [version of Bootstrap](https://github.com/react-bootstrap/react-bootstrap) with the JQuery parts refactored to native React. I'm doing a project now with it that was originally written in Bootstrap/JQuery. 
Looks similar to Raj https://github.com/andrejewski/raj
Here is a bare basic [JSON API](https://youtu.be/X9AggnaEXrM) video tutorial. If you don’t bother with including the JSON specification you could knock this out in 30 minutes and push it up to Heroku. It’s a 50 minutes walk through tutorial. **How is this possible?** Phoenix has generators which automatically do all the nitty gritty shit for you, so developing a CRUD API resource is literally a few console commands. If you want to go a bit further, the Elixir docs and Phoenix docs are very detailed. The only issue I find is the fact that Phoenix ships with brunch and I generally don’t include brunch in my builds but instead implement Rollup to handle assets and bundling. It’s very easy to get that up and running and you only need a few extra modules and with Phoenix you can even watch your compiled assets in conjunction with the Phoenix love reload implementation by making some minor adjustments to the config watchers option within Phoenix. Message me if you need support moving forward. 
According to this: https://github.com/tc39/proposal-optional-chaining#base-case It desugars `A?.x` to `A == null ? undefined : A.x`
All good points, didn't realize `private` was a reserved word
Thanks for all the info!
No problems brethren. Join us! 
Highlight rule: setCharVisible('#', false)
Man I’m still learning ES6! What could this mean for newbie like myself?
It's just some improvements, nothing from ES6 is being deprecated. (I think. I still haven't fully reviewed it.)
Don’t worry about it. Focus on the basics and learn new things as you become comfortable with the basics. Once you have a strong grasp of the fundamentals, it’s easy to pick up and make use of new language features 
Can you imagine authoring a document with a 46-page long ToC??
It just means there’s slightly more to learn now! Your existing learning is still applicable. Keep it up :) 
It means more things to learn! But don't worry, all of these new versions of the specification are much smaller than ES6 was, with far fewer new things. In the thanksgiving feast that is ECMAScript/JavaScript, ES6 was the 80 pound turkey (crammed with stuffing) while everything after are the smaller side plates that go along with it. A good reference is the kangax compatibility table: https://kangax.github.io/compat-table/es6/ ^ that lands on all the ES6 features. And there's a bunch. If you click on the ES2016+ at the top, you'll see all the features released after, spread across multiple versions that came after ES6 (ES7, ES8, etc., which are more commonly referred to by their release date, ES2016, ES2017, etc.). http://kangax.github.io/compat-table/es2016plus/ And you'll see that this list is still far smaller than the original ES6 set. This round of new features mostly consists of enhancements of existing features. New regex thingies, new Promise method (finally()), support for more things using the ES6 `...` syntax, and some updates for async/await stuff.
Just because I often equate `null` and `undefined` together with double-equal operators, it doesn't make the distinction between the two worthless. They both may be empty (and are equated together when one wants to check empty vs not empty), but `null` is explicit and `undefined` is implicit. In the same way, just because a Swedish speaker might have to limit themselves to just "yes" and "no" when communicating in English, doesn't mean they have to make the same restrictions when speaking Swedish. `{ x: undefined }` can be equated with `{}` (and will `JSON.stringify` to that value), but `{ x: null }` is distinctly not equal to `{}`. In a real-world example, say I have a React component with state that will be serialised to JSON, and I want to unset a key in state. State changes are only done via the `setState` API. With a state of `{ foo: 1, bar: 2 }`, calling `this.setState({ foo: undefined });` will update the state to `{ foo: undefined, bar: 2 }`. This will `JSON.stringify` to `{ bar: 2 }` when the state is serialised, successfully unsetting the `foo` key. If I had used `null` instead, the key would still stick around (`{ foo: null, bar: 2 }`) because `null` is a valid value to keep in state. So while even JSON doesn't support `undefined`, I have a real-world reason to pick between `null` and `undefined`. Also, as I saw in another comment here, parameter defaults will only default on an `undefined` parameter, not on a `null`, because that's a valid value.
I hate submitting twice, but the mods deleted the first one (for not including source code), and everyone seemed to enjoy it. [Source Code](https://github.com/GamingMedley/rpg-overworld-engine)
It's all about delegation https://media.giphy.com/media/xT5LMrxYauvZhhzL6U/giphy.gif
That's fine -- thank you!
Hi /u/stojceodbizikovo, please refrain from personal attacks. Thanks.
Hi /u/NicosReddit, please refrain from personal attacks. Thanks.
;)
https://www.npmjs.com/package/selenium-webdriver 
The `'` stands for "pplication".
Raj is view layer agnostic but does work with some view libraries better than others. I have not used lit-html to really know how it would work integrated with Raj, but it would be certainly interesting to see.
Wow, the ECMA website is straight out of 1998, and most of the nav links don't work! I'm surprised that they still post language updates there.
this requires a ton of manual setup though, doesn't it?
Does Typescript include these changes? 
Let this be the one. Get it? 
Don't ever mention this in the /r/php subreddit. You'll just have people defending Wordpress.
Oh boy I'm looking forward for named regxp groups and lookbehind, lookbehind is something I'm missing so bad from c# days.
Yes it is! Very a much still a work in progress, but we have some very smart people on the team pushing hard to build the platform out.
Ohhh
I think TypeScript has had these for a while. Async iterators since 2.3-2.4 or around there and object spread even before that. A quick search indicated the type definitions for promise.finally were added in 2.7.
If you've got a glass house problem though, nobody wants to start throwing bronze
Great idea, gonna start forking repo's for my portfolio. Yes, I'm the creator of React... and Vue.
You can't exactly modify the script, but you could monkey patch the functions it exposes. This is tricky as it depends on what the original script is doing. Basically I need more details on what it is you are trying to accomplish.
[Cypress](https://www.cypress.io/) is pretty cool. 
Like TodoPPLICATIONs?
Lookbehind ELI5?
ReasonML is nice, bucklescript binding are awful. It's not awfuls APIs, i don't know how I would improve it, it's just awful by nature.
Im trying to disable the idle logout on portal.my-canopy.com In https://portal.my-canopy.com/js/app.js there is a function called idle which I wanted to disable or just increase its number to a really big number.
Damnit nothing about decorators !
yes exactly, don't know why this isn't obvious to people
Unfortunate that @decorators still seem to be caught up in limbo for now
Iterestingly https://tc39.github.io/ecma262/ names it "ECMAScript 2019" ;)
This looks like an angular(v1/2) app so this is going to get tricky.... First off you need to get a hold of the module/app/injectable you want access too. This is pretty specific to how the app was written so you will have to play around with it, I don't have access to that particular website so I can't help you out with that. A good place to start is this [stackoverflow question](https://stackoverflow.com/questions/15527832/how-can-i-test-an-angularjs-service-from-the-console) Once you have access to the object that has the function you can try to monkey patch it. Example (something like this) someObj._oldIdle = someObj.idle; someObj.idle = function(param1, param2, etc) { //do you stuff here //call the original if necessary someObj._oldIdle.apply(someObj, arguments); } Hope that helps. 
I am the editor for this specification. It's... pretty fun, but also very challenging. Tooling helps, e.g. [ecmarkup](https://bterlson.github.io/ecmarkup) generates the ToC and a whole lot of other things.
You and me both. Now we just need everybody to have a browser that supports it!
I renamed it once we forked ES2018 into a branch!
Ok, so that one is rnamed because it's now a working draft for 2019?
That's the current draft. Once they finalized 2018, they kicked the current version over to 2019. For a while there, this version was 2019 and the ecma-international site was still 2017 and 2018 was basically nowhere to be found 🙃
we should start a club.
Something to standardize across implementations of ECMAScript... Yeah, that'd be good.
That's right.
Groaaaaan
Still patiently waiting for pipe operator support. Probably not going to happen any time soon but one can dream
Because the 800-odd page spec is a bit heavy for 1AM reading, does include the `|&gt;` pipeline operator?
Da fuq chyu tryin ta do?
// BEGIN EDITING YOUR CODE HERE function createSawBlade(x,y) { var hitZoneSize = 25; var damageFromObstacle = 15; var myObstacle = game.createObstacle(hitZoneSize,damageFromObstacle); var obstacleImage = draw.bitmap('img/sawblade.png'); myObstacle.rotationalVelocity=0.75; myObstacle.x = x; myObstacle.y = y; game.addGameItem(myObstacle); myObstacle.addChild(obstacleImage); obstacleImage.scaleX = 1; obstacleImage.scaleY = 1; obstacleImage.x = -25; obstacleImage.y = -25; game.addGameItem(myObstacle); } function createDeath(x,y){ var hitZoneSize = 20; var damageFromObstacle = 9999; var myObstacle = game.createObstacle(hitZoneSize,damageFromObstacle); myObstacle.x = x; myObstacle.y = y; game.addGameItem(myObstacle); var obstacleImage = draw.bitmap('img/sawblade.png'); myObstacle.addChild(obstacleImage); obstacleImage.x = -30; obstacleImage.y = -30; } function createBox(x,y) { var hitZoneSize = 50; var damageFromObstacle = 10; var myObstacle = game.createObstacle(hitZoneSize,damageFromObstacle); var obstacleImage = draw.bitmap('img/Dovakiin.png'); myObstacle.x = x; myObstacle.y = y; game.addGameItem(myObstacle); myObstacle.addChild(obstacleImage); obstacleImage.scaleX = 0.65; obstacleImage.scaleY = 0.65; obstacleImage.x = -65; obstacleImage.y = -80; game.addGameItem(myObstacle); } createBox(2000,300); function createEnemy(x,y) { //Red Box var enemy = game.createGameItem('enemy',25); var redSquare = draw.rect(50,50,'orange'); redSquare.x = -25; redSquare.y = -25; enemy.addChild(redSquare); enemy.x = x; enemy.y = y; game.addGameItem(enemy); enemy.velocityX = -1; // enemy.rotationalVelocity =10; enemy.onPlayerCollision = function() { console.log('The enemy has hit Halle'); game.changeIntegrity(-5); }; enemy.onProjectileCollision = function() { console.log("Halle has hit the enemy"); game.increaseScore(100); enemy.fadeOut(); }; } createEnemy(450,groundY-25); createEnemy(900,groundY-50); createEnemy(1275,groundY-65); function createEnemy2(x,y) { //Red Box var enemy = game.createGameItem('enemy',25); var redSquare = draw.rect(50,50,'red'); redSquare.x = -25; redSquare.y = -25; enemy.addChild(redSquare); enemy.x = x; enemy.y = y; game.addGameItem(enemy); enemy.velocityX = -1; // enemy.rotationalVelocity =10; enemy.onPlayerCollision = function() { console.log('The enemy has hit Halle'); game.changeIntegrity(-5); }; enemy.onProjectileCollision = function() { console.log("Halle has hit the enemy"); game.increaseScore(100); enemy.fadeOut(); }; } createEnemy2(500,groundY-25); // createEnemy2(900,groundY-50); // createEnemy2(1275,groundY-65);
This is what I got so far.
Wappalyzer tells me the site was built with dreamweaver. Oh dear...
They're still stage 2. Don't expect them for a couple years.
Just needs to advance through the standards process. Firefox already has it implemented behind a flag.
I wanna add a coin image that moves towards the character, so that he collects it and it gives him not only more points, but also add in an if/else statement that says if he is below 50 health then add 50 integrity if not then he gets 15 integrity along with 500 points added.I'll add a file that you can access
[https://ide.c9.io/hunterhoward/huntersfirstwebsiteoutsideofschool](https://ide.c9.io/hunterhoward/huntersfirstwebsiteoutsideofschool)
Maybe you can use dynamic analysis. Stub `React.createElement` and make it write the incoming prop to an object. Render once and then check the object. Much less work than a babel plugin if this is a one-off thing. 
I see what you did there. 
I instantly fell in love with the song :)
Really confused as to why they don't just adopt `async/let!` from F# and call it a day... ``` let fetchHtmlAsync url = async { let uri = Uri(url) use webClient = new WebClient() // Execution of fetchHtmlAsync won't continue until the result // of AsyncDownloadString is bound. let! html = webClient.AsyncDownloadString(uri) return html } let html = "https://dotnetfoundation.org" |&gt; fetchHtmlAsync |&gt; Async.RunSynchronously printfn "%s" html ```
This code is pretty shit TBF. You'll need a lot of help. Good luck.
 { ...youre, ...gonna, ...love, ...it }; 
Thank you for the help, ill give it a shot when I get home. Also I love how you said "Monkey patch it" thats just the best haha 
Yeah... maybe. It’s just weird that there isn’t a parser for this? 🤔 Maybe I’m seeing it as way more easy than it actually is :D
Messenger is powered by ReasonML, that's enough of a large user base to go off of.
They're going to ask for stage 3 in July, fingers crossed
what's the point of this kinda comment? just being a straight up dick?
A pipe dream, thanks - I'd have missed it
I don't even understand the confusion. It very obviously should return `undefined`. Only brogrammers would get this wrong.
Why would you want to specifically target them? Imho, just use es2015 preset
I don't think you're getting what he's saying. Whenever I check whether a value is set or not, I use `if (foo == null)1 That covers whether foo is null or defined, so I don't really care which it is.
This disgusting mess is a direct result of non-Javascripters trying to bring familiarities from other languages across due to not (or mis-) understanding Javascript.
A straight up dick is better than a limp one, youngblood.
I agree 100&amp;#37;! I'd say designers that procude designs not programmable are print designers, not web designers. As a web dev, I know how to use the design tools, I have knowledges of UX and it makes me a better dev and being able to advise my customers. I'd be able to say that, for instance, they are some UX issues on a design I am given (probably made by a "print designer) ; like misplaced button, low contrast, under the fold… And it's really good that you're learning, a designer that can code his designs, wooow, that's good! What I was trying to emphasize is that, "I am just a designer" IS NOT &lt; "I am a dev". Whatever the job, your days are only 24hrs and the amount of things you can learn in the time you have is not infinite. Technologies and trends evolve so fast that it's hard to keep up. I am myself a fullstack dev, so it means I have to deal with loads of things, from front to back to Linux hosting and security. Obviously, I can't be a specialist in all these areas. I can dev a perfect JS SPA, but frontend advanced animations are not my area of expertise. I confess things like \[SVG animations\]([http://slides.com/sdrasner/svg-can-do-that#/](http://slides.com/sdrasner/svg-can-do-that#/)) or \[advanced CSS design\]([https://codepen.io/JoseRosario/pen/OvXdYy/](https://codepen.io/JoseRosario/pen/OvXdYy/)) or \[webgl creations\]([https://moments.epic.net/#](https://moments.epic.net/#)) are things I don't master at all. I'd finish with this epic strip about \[fullstack dev\]([https://www.commitstrip.com/en/2016/11/07/which-full-stack-developer-are-you/](https://www.commitstrip.com/en/2016/11/07/which-full-stack-developer-are-you/)) ;) 
https://www.reddit.com/r/javascript/comments/1aif3z/how_to_copyextend_constructor_function/ Quoting; `var Construct2 = function (x, y, z) { Construct.call(this, x, y); // or Construct.apply(this, [x, y]); this.third = z; }`
Luckily I like learning, but yea it can be a bit overwhelming.
Thanks @ChronSyn
If ES6 is an option for you, you could also \[extend\]([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends)) the base class.
A JavaScript API for Face Detection, Face Recognition and Face Landmark Detection
That was my first idea before actually. It would be easier
A quick summary of all the new features: [https://pawelgrzybek.com/whats-new-in-ecmascript-2018/](https://pawelgrzybek.com/whats-new-in-ecmascript-2018/)
TypeScript tends to add support for proposals when they reach Stage 3, so yes.
&gt;async iteration: ah, thank god 
What is this useful for?
Holy shit lol dreamweaver...... Memories are rushing back!
i have a list of urls that i have to fetch, but im rate limited at cca 1 req/s. i cannot await response and sleep 1s in forEach. i have to make a workarounds and with this i hope it would work as intendet.
'this.state' is this react? if so, i highly recommend not using for loops, instead use array methods like (map, filter, reduce, etc..) i think this might work if you can wrap the whole for loop in a function and returning 'text' from that function like so: function myText(){ var text; // your for loop return text; } then when you call myText(); it should return the text based on the condition you created. also you can compose text with variables with template literals like so: var text = `&lt;Picker.Item label=${rI[i]} value=${rV[i]}/&gt;`;
Thank you, I'll look up array methods 😄
Lots of great things in the pipeline. Nullish coalescing and a match operator, each stage 1 iirc, will be enormous QoL improvements.
I've used it as a way of doing "streams" that isn't event based. Async iteration combined with generators means you can create a "stream" that will only run when there is data from the source (push), and can have "backpressure" to only run when the system is ready for the data to come in (pull). 
If `x = { y: null };` Then `x?.y` should give us `null`. Because that's what it is. If `x === null;` Then `x?.y` should give us `undefined` because it has not been defined. If, in the last example, it would give us `null` then it would make sense to assume the property `y` has been set. So we would expect it to be in the object if we enumerate it. Except you cannot enumerate a `null` value. People who argue in favour of a non-existing property to be `null` are wrong because they are... well... not right. What a weird debate.
1. Has it been defined? 2. Is it null? So yes, it should be undefined. Because it has not been defined.
However Typescript is free to use the private keyword then compile to #privates...
First - what do you mean by "overlay"
Hm not sure I understand what you what's an example of this?
Still I can't find a data structures in JavaScript book 
Queue another year of medium articles where nobody has any clue what is actually in the specification. 
Ended up using [this plugin](https://www.npmjs.com/package/babel-plugin-async-to-promises) without presets, because of lots of support issues for async, await, yields and generators. I really have no idea what the problem was though. What Im trying to do is to embed some ES7 scripts into Xamarin WebView renderers.
I made this search component using semantic ui react for a technical test for a job. [https://github.com/justrdk/h4ndshake](https://github.com/justrdk/h4ndshake)
I honestly kind of wish they wouldn't and that TypeScript would just specify preprocessed annotations so that you could have an understanding of your new class/method/property at write time like using Lombok for Java.
I am a freeCodeCamp coder :)
Thanks 
Yeah. Learning by doing is the best!
 async function example() { const response = await fetch(url); for await (const chunk of streamAsyncIterator(response.body)) { // … } } with `streamAsyncIterator` being: async function* streamAsyncIterator(stream) { // Get a lock on the stream const reader = stream.getReader(); try { while (true) { // Read from the stream const {done, value} = await reader.read(); // Exit if we're done if (done) return; // Else yield the chunk yield value; } } finally { reader.releaseLock(); } } 
An external program always on top that u can click trough and render some stuff 
private, public and static properties did not make it. sigh. 
It is easy to make it yourself. Create a string containing the "haxxor code" and read a line or a few chars from the string when user presses a button. Then output the read string with some styling to whereever you need it. (To a HTML div in case of HTML/JS)
That sounds like it needs integration with windows forms directly. 
Perhaps partly because the proposed syntax has experienced [significant opposition](https://github.com/tc39/proposal-class-fields/issues/100).
That's true. It'll be interesting to see what they do there. If they go that route, it'll be a breaking change. Otherwise they'll be supporting two variations of privates - which I actually suspect they'll end up doing instead.
You are returning inside the loop. That means it stops the loop after only the first iteration. When you console log, it prints 5 inidivudal times because the console.log does not stop the loop. You will want to concatenate your text into a single value and return that value after the loop. Or push each text to an array and return the array. Something like that
Yeah - because piggyback of private on top of public and static that have been accepted and stable for ages. ¯\\_(ツ)_/¯ 
I'm not sure if this is actually possible yet (making an always on top transparent overlay), but you could look at https://github.com/parro-it/libui-node - or, if you want something a little more high level, then https://proton-native.js.org I have no experience with these tools so they might not do what you want, but they seem to be the most likely candidates.
That's odd behavior. How is Resource implemented?
Sorry, but I don’t think you can do that. Even if you know JavaScript you won’t have the ability to run that script anywhere but on your own computer. For all other users their machine will only run scripts provided by the game website. Unless you convince them download and run your own program. What you can do however without any knowledge of programming is speed up your own mouse which may counteract whatever it is the game is doing. You can do that in the control panel in windows and in the settings on Mac 
JavaScript is not able to slow down mouse movement. Mouse move events are generated natively by the browser, and JavaScript simply receives those events as fast as the browser generates them. There are alternative methods - you could hide the cursor with CSS (`html { cursor: none; }`) and then implement your own custom cursor that follows the original mousemove events but with a delay (a linear interpolation animation should suffice). However, the drawback of this approach is that you would have to implement a custom mouse cursor for each operating system, as well as the fact that it can simply be fixed by injecting `html { cursor: auto !important; }`. Another option is to use the [Pointer Lock API](https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API), but I'd seriously recommend not doing so as it hides the native cursor entirely, which can be a serious issue for user experience.
Web frustration #1: Overriding default platform behaviour for scrolling, mouse speed, or other core UX. You wish to punish your visitors for a problem caused by the creator of the game? That's not going to achieve what you want, unless you want to drive people away from your site. I know I wouldn't blame the creator of one product being the cause of a 'behaviour' introduced in a different one. As far as I know, there is no way to control the cursor speed or acceleration as these are set at OS level.
You can also either use typescript or let typescript check your javascript. On my phone so sorry for the formatting. If you don't want to use ts: In vs code put // @ts-check at the top of the file. Now after getting a DOM node you can check for its type using: const node = document.getElementById('someform') if (!(node instanceof HTMLFormElement)) throw new Error('type mismatch'); After this ts knows that the variable 'node' is a form element and you can do stuff like node.submit() without ts throwing warnings at you. You also make sure that the element is really a form, bot that someone changed it. I created a very tiny library for that which automatically does the error throw for you, so if you are interested just let me know
do you mind explaining this part a bit? 
You can thank AirBnB for that. 
Learn on your on time. Reinvent the wheel on your own time. Use tested and mature product for your client. 
I never said React, and obviously not every one shares your lack of doubt.
&gt; You can also either use typescript or let typescript check your javascript. I will check out TypeScript this afternoon. Does TypeScript include some kind of helper methods in order to catch such errors in the compiled result? The problem is that the DOM nodes I am scraping are from a third party chat application, so it could unexpectedly change.
I've done a fair bit of vbscript which uses `'` to do comments. Safe to say that was confusing for the first 10 seconds, but then you get used to it. Especially since what you use to detect comments tends to be colors in the editor, and not the actual symbols themselves.
You want to hook into DirectX calls or possibly OpenGL calls, i.e. you want to create some middleware for the calls to the different rendering API's. Check out something like Overwolf. It takes a lot of time.
btw this is super simple using bluebird. Promise.mapSeries(urls, url =&gt; fetch(url).then(res =&gt; res.text()).then(processHtml).delay(1000))
How are you using the image? If you're drawing it to a canvas you can just re-use the same one or have references to the same Image element like in your second example. If you want multiple elements to add to the DOM you can clone it: Img.bullet2 = Img.bullet1.cloneNode()
**Promise.prototype.finally: a practical guide** In the late 1990s when JavaScript came on the scene, the internet was very static. JavaScript was a tool used to add *flair* to your website, whether it was a trail of stars following your mouse cursor, or if you were lucky, auto-advancing input fields for the three sections of a standard US phone number. Nobody cared about asynchronous operations in JavaScript because AJAX hadn't even been popularized at that point. In fact, developers were still passing strings of JavaScript code as the callback to the setTimeout function! Enter Google. In 2004 Google had a crazy idea: use JavaScript to make server calls without reloading the page, and then change the UI with the DOM API based on the results from the server. Google's "Suggest" lab did exactly this. Getting search suggestions in real time as the user typed was absolutely revolutionary. Fast forward 10 years and the web has changed. "Web sites" morphed to "web applications" that are constantly talking to servers. To make life easier, developers created libraries to make dealing with asynchronous server calls easier. The vanilla way to handle a server response is to provide a callback that gets executed with the results of the call. But this can get tricky to manage. You end up with chains of callbacks that some have dubbed "callback hell". This quickly turns into spaghetti with race conditions left and right. Mix that with JavaScript's closure semantics (see my other article on [closures in JavaScript](http://reddit.com)!) and you have yourself a real nightmare. But eventually along came the *Promise*. A number of libraries implemented the Promise, but eventually the ES committee caught up and added it to the official spec. Browsers began to build Promise directly into the standard library. Promise is just a wrapper around callbacks to make it easier to reason about them, particularly when there are complicated interactions going on between your frontend and backend. Although libraries like Q and Bluebird implemented a wide range of Promise features and utilities, when the ES spec came out it was very simple. The Promise prototype (in other words, members that are present on every instance of Promise) contained just two things: `then` and `catch`. In fact, `catch` wasn't even necessary, since it is just sugar around filling in the second parameter of `then` (there's a gotcha though - for more details see my article [A deep dive into ES6 Promise](http://reddit.com)). Many people likened the `catch` method on Promises to a `catch` block in a try-catch statement. And this is for good reason. The `catch` callback is executed whenever a promise is rejected, for example, when a server call results in a 500 error. And since try-catch statements have an optional `finally` block, developers have been clamoring for a `finally` analog in Promises. Well folks, it's here, *finally*! Let's take a look. The `finally` method on a Promise is used to register a callback that will always get executed. Do you see the parallel between this and the try-catch's `finally` block? Regardless of whether your Promise succeeds (that is, it is *resolved* or *rejected*), the `finally` callback will always get executed. Furthermore, it will happen after any preceding `then` or `catch` callbacks execute. The `finally` callback is perfect for cleaning up your state. Let's walk through a practical example. Many web applications utilize what is known as a "spinner", which is a piece of UI that indicates that a long-running operation is underway. Since server calls tend to be long-running operations, we will show a spinner so long as the network request is being made. When the request is done (even if it has failed!) we want to remove the spinner UI. We could duplicate the code to remove the spinner - once in the `then` callback and once in the `catch` callback. But this is bad! We learned in programming 101 that DRY ("don't repeat yourself") is a sacred principle never to be violated. So `finally` to the rescue! Just add a `.finally` to the end of your Promise call chain and pass a function that cleans up the spinner UI. Now your UI will always reflect your state accurately! Horray! If you enjoyed this article, please follow and check out my Twitch programming stream, Tuesdays and Thursdays from 1-4pm PST!
Not sure, I haven't used ts like that before. But basically it just compiles to normal javascript. Maybe there is some configuration you can set though
I've been using Vue for about 2 years. Developer for about 8. When I first started to learn Vue I decided I would learn it out in the "open" by opensourcing a simple notes app that had fuller features like user auth using JWT and full CRUD note actions. This was partnered with a [backend node API](https://github.com/johndatserakis/koa-vue-notes-api) built using Koa. Recently, even though I really dig Vue, I'm interested in React and decided to jump right into it - and I figured what better way then to recreate the the notes app. In the process I've learned all about React, Redux, React-Router, Styled-Components, the render function, Higher Order Components - it's been fun. Happy to answer any questions. [Link to the React version demo](https://johndatserakis.github.io/koa-react-notes-web/#/) | [Link to the React version github](https://github.com/johndatserakis/koa-react-notes-web) [Link to the Vue version demo](https://koa-vue-notes-web.innermonkdesign.com/) | [Link to the Vue version github](https://github.com/johndatserakis/koa-vue-notes-web) [Link to the backend Koa github](https://github.com/johndatserakis/koa-vue-notes-api)
&gt; Does using const imply that the collection is immutable I think it would be a huge mistake to assume that. It's not just about array, object defined with const are mutable as well (you can assign a property). the only thing const means is you can't reassign 
Nah. `const` in JS doesn't "imply" immutability. All it "implies" is what it *means*. If the author interprets `const` as immutable he's just wrong.
I think the "don't push" thing is just an opinion. I tend to use const for what it is meant for: variable cannot be reassigned. When I write code everything is a const unless I explicitly need the ability to reassign it later on. Just my two cents.
As long as you use it consistently in the codebase, I think it's okay either way. Using `let` and using functional programming (avoiding mutation) is another alternative.
Back when worrying about code bloat on the web wasn't a thing 
The GitHub is updated if you could re-approve this one.
Same here. Default is const until I need to reassign it
I will but it's likely going to fall off the front page due to age.
I'm not sure what you're getting at, but `const` and functional programming are not mutually exclusive
Ce la vie.
You wouldn't be able to overwrite the variable with const
Do you have a clear winner in mind between the two? It is super vague of a question but I imagine a lot of folks would be interested to hear a kind of quick take on what you view as the more pleasant (or unpleasant) parts of each development experience, especially in relation to one another. What sorts of things from each workflow do you miss when working in the other?
Do you have pros and cons of each?
I can't open the Vue ones menu when I tap. Chrome Mobile on Android
Same
Great question. All in all - I did like React. Not too hard to pick up. It's complete, and has a great community. The thing is, it seems like there's less batteries installed. That can be a plus at first, but after you sorta get the idea of how things work, it seems like you're just writing more code then needed. Like with React-Router and how, if a component was not a direct descendant of a `Switch` statement main route definition, then it didn't have access to the `history` prop - and I had to wrap it with the `withRouter` HOC. That was just a bit funny - although I do like how some components are truly *dumb* vs *smart* - I guess that's the intent. It's just a bit different from having the `$router` always available to use through `this.$router` in Vue. Small things like that stood out. The strangest thing for me in React was the render function. In Vue it's just so easy to loop over data and spit out elements or show/hide data based on state/store variables - in React it felt pretty strange to have to create my notes loop outside of the render. In Vue, if you want to show or hide something - just use `&lt;div v-if="myVariable"&gt;Lorem...&lt;/div&gt;` and it'll be based of your `myVariable` truthiness. In React it seems like you have to do: ```javascript {this.state.myVariable &amp;&amp; &lt;div&gt;Lorem...&lt;/div&gt; } ``` It's a little more verbose, and doesn't support that instant-helper looping that Vue can manage. But of course, after I familiarized myself with how to do those normal little things, it didn't seem too odd. It's like, ok, whatever - that's just how you do that. One other thing - the redux and react dev tools are definitely not as nice as the Vue tools - from the style, to having to open a huge tree of elements just to see a component's state - it made it a bit tough to get a view of my app's variables. I may be missing something here though or using a version that isn't the current community standard. I definitely like React, and I do feel it was important to spend a solid month with it to learn its intricacies, but I do think I'll be using my Vue setup going forward for most things. It's less code and a simpler coding experience with helpers that make sense and are just magical enough that they're helpful, but not too magical that I lose track of what's actually going on.
Or Observables. 
Np 
Darn, sorry about that. I know this is ridiculous, but's here the links that are in that nav: https://koa-vue-notes-web.innermonkdesign.com/user/login &lt;- login page https://koa-vue-notes-web.innermonkdesign.com/user/signup https://koa-vue-notes-web.innermonkdesign.com/user/forgot https://koa-vue-notes-web.innermonkdesign.com/account &lt;- account dashboard I'll adjust that later today.
Don't worry, it'll be another decade before popular browsers support the interesting features, another 5 years after that before enterprise clients locked to Edge will get it, and at the end of the day, you'll still have to write ugly polyfills to deal with Internet Explorer.
See my response below. Basically I dig React - but I fuck with Vue heavy due to having just enough magic to be super helpful, but not so much that I feel separated from the code.
Hi /u/draber06, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/yossers, this post has been removed. If you'd like to post a link, please use the "Submit a new link" option. Thank you.
If you're doing "functional programming" you are not overwriting variables.
My linter doesn’t allow “==“, and in my example “!account” works fine, since account is only ever either an object or null. Undefined and null are semantically different.
&gt; Like with React-Router I dislike this about react-router too. Way too verbose. Version 4 is better than previous ones, but still too lame. `@reach/router` now that's a router I love! It makes routing in react easy and fun. Too bad it doesn't support hash history. 
I appreciate this run down and overall agree. But its interesting you seem to still be leaning towards React - to me, we share the same opinions; although I am a tad harsher on React ( there are just so many special idioms and complexity compounds quickly on larger projects ). I just find it interesting that you seem to land on a different ultimate conclusion. To me Vue is the way forward, its simplicity and ease of cognitive overhead is refreshing while supplying most of, if not all of the benefits of React
Seems like we agree - maybe I wasn't clear in my comment. I will be using Vue going forward for most things! (Will probably do a few smaller things in React to stay sharp at this point) &gt; there are just so many special idioms and complexity compounds quickly on larger projects Exactly
&gt; @reach/router Hmm I'll have to check that out.
Reddit automatically highlights links, you only have to do `[]()` if you want to name the link.
Is there a reason that the two different apps have two different APIs? Seems like you could have just one API that served both the Vue and React front ends.
React-router IMO is the weakest of the bunch when it comes to mainstay react libs.
Same for iOS
Interesting. Basically one of my main goals in life is staying as far away from the DOM as possible. 
The whole having to pass history via a HOC in RR4 is mind boggling to me. Like, how do you re-write a routing library and make that shit explicitly opt-in? If I'm using a router, I don't want to worry about passing routing around. 
&gt; Do you have a clear winner in mind between the two? well the vue version doesn't work so....
Yup! They're both using the exact same backend - at the same time ha. The code for the backend is here: [https://github.com/johndatserakis/koa-vue-notes-api](https://github.com/johndatserakis/koa-vue-notes-api) - that's open-source as well and using Koa on Node.
Vue's magic isn't really DOM-related. It's more stuff like having e.g. `v-if` attributes instead of returning an array via a JS map in React.
Yeah I agree. For being the defacto rooting library for React, it makes some mind bogglingly strange decisions. Is there another routing library that you prefer?
I regard to the return function, I see it as more separation of concerns. JSX is already being intermingled within each component alongside the normal JavaScript. For me, I'd say it helps keep the UI and Data separated more. What I found when learning React was that it tries to rely heavily on vanilla js where it can. Learning React taught me a lot more what could be done with vanilla js and has improved my overall understanding of just javascript as a whole. And with that, it's fairly easy to loop over data within React just with plain javascript. Simply map over an array and pass in a component or element to be returned. let state = { array: [1,2,3,4,5] } render(){ return( &lt;React.fragment&gt; this.state.array.map(number=&gt;&lt;span&gt;{number}&lt;/span&gt;) &lt;/React.fragment&gt; )} Which will be rendered as the following into its parent container &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; You can also use the filter and map functions in conjunction to check whether an item should be rendered at all.
Follow up: any idea why it appears to be using old-style hash history locations? 
you forgot the "{}" in: &lt;React.fragment&gt; {this.state.array.map(number=&gt;&lt;span&gt;{number}&lt;/span&gt;)} &lt;/React.fragment&gt;
Sorry 'bout that bug - the nav bar works now for mobile and you can login/signup no problem.
All set - sorry about that
Hi /u/Ijustwanttocode101, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/MrMuscleDeveloper, For javascript help, please visit /r/LearnJavascript. Thank you!
Yea usually I do that by having nginx or apache serve the index.html at all times - works great. But the thing is that this is served on GitHub pages where you don't have access to the server - so I opted for the hash version so it would work with no problems on there.
You'll really need to evaluate how strict you want to be in your codebase. `const` in javascript means the variable _reference_ cannot be changed (but keys/data inside is still mutable), but has other implications in other languages (true immutability, in most cases). The big question you need to answer: Are you on a multi-disciplinary team or are other people going to use/maintain your code? If so, they may already understand const as complete immutability, so you should probably treat it as such. I can't speak for the whole JS community, but in the company I work in, we've typically tried to enforce full immutability when we use `const`, and I personally don't think that's a bad idea.
Hey all, I'm the author of this tutorial. I recently built a blog using Node.js and thought it might be interesting to write up an article about how I did it for beginners. If you have any questions, hit me up. Thanks! &lt;3
Can't believe I forgot that. Thanks, I've edited my reply
I see you are using quite a modern style with backend (async, OOP, classes, testing). I am primarly a Java programmer and doing a bit of node on my own - I can write Express based REST backends, but it is pretty basic. Any suggestions how to pick up this things (async synthax, classes with js, backend) or just keep coding in Node? 
&gt; It's private variables aren't truely private and ultimately become public members in the resulting JavaScript classes. Why is Typescript doing this? In ES5 class definition you can have true private variables without problem. 
What are you doing in ES5?
 This Rosetta Stone approach makes it one of my favorite posts ever. Thank you so much. 
Also from the article: Mozilla is working on adding TOR to Firefox
That issue doesn't speak to his experience with the two development platforms. Get outta here with that snarkiness.
Sorry, that was the point I was trying to make. I love React because aside from `ref`s I *never* touch the DOM, and even then it's a one-time thing that gets encapsulated in a Component. 
Actually that's exactly what it does. He tried something in two frameworks and had a poor result in one
Controls are a bit weird /sensitive on mobile but still pretty neat. Framerate appeared smooth when moving etc. 
Could you setup a route that updates the config values in memory? Something like /api/config?option1=newvalue I know you don’t want to hit a db, but key value stores like Redis are pretty damn fast- you could put the configs there. Even if you did store the configs in a database you wouldn’t necessarily have to call the db on every route call.
No he had a bug in one. It's software, bugs are the norm. There is nothing magical between the two that makes code 100% bug-free. Yes the way you work in a framework can introduce behaviors that are bug inducing but the idea that this single bug tells us what we need to know is laughable.
So just to be clear, he tried two things, and had more success in one compared to the other? I think that speaks to his experience. You can also see it took him &gt;4x the commits to create the vue SPA, which again I think speaks to his experience. No need to get upset,his experiences and my snarky comment don't make your frameworks better or worse. 
Interesting idea! I've been using Brave on Android for over a year and love it.
Vue has more special idioms than React imo - Vue has its own dsl in html - can you explain what you mean here? I think where React shines compared to Vue is when an app becomes more complex: When a piece of state updates in Vue, you set its new value. Is another piece of state being updated here at the same time by listening to this value? You don't immediately know and need to look around - tracking the state changes can be difficult. When a piece of state updates in React, any other state changes that occur at the same time are immediately obvious.
https://www.crockford.com/javascript/private.html
&gt; Learning React taught me a lot more what could be done with vanilla js and has improved my overall understanding of just javascript as a whole. I can completely relate. 
Thank you for checking it out. Well I think the biggest thing for me when learning is to make little/medium sized projects that have a specific scope. As you move through building an app, you're forced to deal with very real issues that really teach you so much. For example, really ironing out the rather complicated JWT User Auth has been a great teacher. Really, the whole User Auth part, on all the apps, is such an important and large part that you're bound to see pretty much everything there - like a micro-ecosystem. As far as async/await goes - it's something that I think scares people a bit - but people should actually be happy to see it because it allows you to be removed from the callback hell that exists with *then* promise handling and older plain callback handling. So just keep coding - decide on a side-project you're interested in - and code the hell out of it like you're going to show it to Linus himself. I find myself feeling uncomfortable in my code all the time - that's how I know I'm making progress. Peak at the [https://github.com/johndatserakis/koa-vue-notes-api](koa backend) when you need help - I made it specifically to help those stuck on some of these concepts.
perhaps the controversy is from the fact that the term "constant" does imply immutability. if you don't read the docs, I can understand why someone would think const means immutable because that's intuitive.
Thanks for checking it out - hope it can help
And now you're changing the behavior of your class based on your privacy. For a public method to access a private member variable, it has to be instanced with the class instance and not shared in the prototype which could cause unexpected behavior. Typescript keeps close to JavaScript, maintaining the same behavior, only including additional annotations (with some feature implementations like decorators) that are used for error checking during compile time without changing the behavior of the code when executed. If privates in TypeScript were implemented that way, they'd be changing how a method ultimately gets implemented at runtime.
It requires you to have clearly defined outcomes ;)
Hahaha I don't have a favorite in this mix. I'm suggesting that he would have a better understanding of his experience with the two than you or I would and that is why I was asking him for it. 
If you use const x = Object.freeze([1,2,3]); Will make an immutable variable that cannot be reassigned. But properties won't be frozen on the object, because it doesn't do a deep freeze. MDN has an example on deep freeze: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze And another thing to watch out for is that the prototype object can change. So for maximum safety do: const x = deepFreeze(&lt;value&gt;) ; deepFreeze(&lt;value&gt;.prototype) ; But this can break third-party code. If the third-party code expects the prototype object to be mutable. Or use immutable.js (or mori) then you will receive a speedup in the immutable data structures it uses. 
You should check out rxjsz it has Observables which solves the same problem
The worst I've run across is the IEEE 802.11-2016 standard which has a 67 page ToC covering 2530 pages of main body content (3534 pages front to back). They release it as text and PDF... it's a pain in the ass to have to ctr-f to find what you want in the ToC.
The [repo](https://github.com/GamingMedley/rpg-overworld-engine) is now populated, my good sir.
In a nutshell, you want something like this: const configService = {config: await db.getConfig()}; app.post('/config', auth, async (req, res) =&gt; { await db.saveConfig(req.body.config); configService.config = req.body.config; });
Using a service or really anything async isn't an option. This is production code where we interact with different advertising partners and clients. We have hard caps on our latency for a request, and basically the more latency we have available the more we can monetize each request. Reading the config has to be a synchronous operation.
Why not? I don't want routing available in components that don't need to know about routing. This lets me be explicit about what I pass in. Why should my say Text component need to know what the current route is or have the ability to change it? 
What are the special react idioms? To me React has _less_ "React" stuff than Vue does "Vue" stuff. 
Maybe you misunderstood. It's asynchronous to write through your configuration editing UI but it's synchronous to read. You just do: app.get('/your-endpoint', (req, nes) =&gt; { console.log(configService.config) }) 
Taking some idiom and always doing it brainlessly is the easiest way to guarantee you're not using best practices, and instead writing stupid code.
An important point you're missing is that any component that is receiving route information as props will be re-rendered anytime the route changes. On top of the other points mentioned above, opting in to receiving routing props is 100% the correct decision. In real applications only very few top-level components require any route state. If child components require it they can opt in or you can pass it down through the prop chain. React is all about giving control to the developer you do not want anything to be automatic or implicit.
Constant doesn't imply immutability. I think the problem is most JS developers don't realize objects are references. The pointer is constant and unchanging. Nothing about const says you can't mutate the thing it points to. const getFukt = document.body; // good luck now
There's a hacky workaround for this using 404.html, https://github.com/kevinkace/lyrite/blob/gh-pages/404.html
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [kevinkace/lyrite/.../**404.html** (gh-pages → 6fb661c)](https://github.com/kevinkace/lyrite/blob/6fb661c7696e0f4f54b2c7a5a22db84dc8d3a810/404.html) ---- 
Wouldn't I need to restart the server for a config change in that case?
JavaScript's new browser?
You've posted this to the wrong sub.
Separation of concerns wins again!
The inventor of JavaScript's (Brendan Eich) new browser. :) 
[https://www.reddit.com/r/golang/comments/6c3bmw/how\_mature\_is\_graphql\_with\_go/](https://www.reddit.com/r/golang/comments/6c3bmw/how_mature_is_graphql_with_go/)
Go through the React docs tutorial ( I'm sure Vue is great too but I don't have the experience to recommend it). It gives a basic understanding of how JS client libraries work now. I know what you mean, the JS ecosystem can be extremely weird for someone coming from a traditional LAMP/MVC background, but you can pick it up fairly quickly. 
Nope, when you POST to `/config`, the in-memory config is updated in this line: configService.config = req.body.config; Then, when another request comes in to `/your-endpoint`, it reads the updated config in the same tick as the request callback call.
A few months ago I posted the first draft of my presentation here. Last night I finally got to present it to my local JS meetup and the video made it online today. Feel free to let me know if you have any questions, comments or suggestions!
It has the best name though. It sounds like it’s the router that you’re supposed to use. 
I've actually been looking at Vue the last few days and I think it's fantastic. But it seems like most of the libraries out there need unmentioned other libraries/technologies/setups for them to work.
I think this is exactly the main difference between React and VueJS. Vue requires you to be comfortable with magic and tbf that magic makes 90% of use cases really easy to spin up and develop. React on the other hand has a small surface area. It really is basically `(state, props) =&gt; view`. It's essentially functions all the way down. With React you know exactly when and why a component will re-render at the cost of maybe having to write more code (personally I think it's a small price to pay). If you're building a few pages and forms you should probably go with Vue, you'll love it and it'll really speed up your development. If you're building a complex desktop grade application React gives you more power to realize that and the explicitness is a godsend for maintainability. 
What are some of the decisions you find strange? 
Why did you dodge angular 2+ ?
the word "constant" by its very definition implies immutability. Thus, if you did not know what is actually immutable, then its very understandable why someone would intuitively assume that you can't add an item to a const'ed array. 
You're using Windows?
Can you recommend any resources I can use to learn how to write good tests? Or just writing tests at all. I've literally never written one.
`&lt;React.fragment&gt;` elements can be replaced with empty-bracket elements. Eg: &lt;&gt; {this.state.array.map(number=&gt;&lt;span&gt;{number}&lt;/span&gt;)} &lt;/&gt;
`&lt;React.fragment&gt;` elements can be replaced with empty-bracket elements. Eg: &lt;&gt; {this.state.array.map(number=&gt;&lt;span&gt;{number}&lt;/span&gt;)} &lt;/&gt;
Okay well the pointer is immutable. You got what you want. Nothing about the object it points to is immutable just because the pointer is.
If you're going to get into current frontend I think this is a bad attitude to have. These things exist for a reason and instead of dismissing them or complaining about them (not that you really did) people should take the time to learn _why_ things are done the way they are. There are a lot of smart people in this space and most tools provide a tangible benefit. That being said here's a brief overview of tools you'll probably run into: **NodeJS** Allows you to run Javascript on the backend **NPM** Node Package Manager allows you to install dependencies. Think pip or apt or brew. **Babel/es6** ES6 is just javascript but with more features, I think it's now referred to as ES2016 or something. Not really something you need to know. Babel is a transpilier that enables you to use modern javascript features (es6) even where they're not supported natively. **Webpack** Kind of like a makefile but tailored for the javascript ecosystem. This is probably the most complex part of modern development. It usually takes all of your dependencies and turns them into a single script file you can deploy. **require/import** Instead of having multiple script tags you now require your dependencies. This prevents polluting the global scope and brings it more in line with other languages. **CDN** Content delivery system, if you use a CDN it's more likely that users will have the file cached and it decreases load times. Those are the tools you'll probably run into. **Concepts** If you're familiar with jQuery you'll know that the approach it takes to update the UI is: find DOM node -&gt; change DOM node. Current frameworks instead take an approach that is closer to server side templates. You have data and a view/template and your view updates when the data changes. How that actually happens depends on the framework but the concept is the same `(data) =&gt; View` For example a simple React component definition and usage looks like this function Hello(props) { return &lt;div&gt;Hello {props.name}&lt;/div&gt;; } function App() { return &lt;div&gt;&lt;Hello name="world" /&gt;&lt;/div&gt;; } The main takeaway is that we no longer mutate the DOM, we update our data and tell the framework what the UI should look like for that data. This is a really good article that I used when I was first learning React. (sadly it's no longer maintained) https://chibicode.com/react-js-introduction-for-people-who-know-just-enough-jquery-to-get-by/ The video where React was first introduced is actually a really good primer into how these things work and not enough people actually watch it. https://www.youtube.com/watch?v=XxVg_s8xAms It is definitely a lot but you don't have to learn it all at once. Only bring the tool in when you have a problem you need to solve. 
It’s really a toss up about the SEO question. Google supposedly since around 2015 has been executing JS. I still worry about it, but the best thing to do would be to experiment with it. Hook it up to search console and see for yourself. See if your page is getting indexed, what it looks like, etc. You also might want to think about putting a disclaimer on your site about the Spotify logo. You are using their official logo but you are not part of their app/site. :)
lol!
Thanks! I do need to fix the sensitivity on mobile, it's way too fast. Even on desktop, people walk too fast so it's hard to follow people around the world. :)
Hi /u/northern_hippie, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
Hi /u/T_O_beats, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/Hypersapien, For javascript help, please visit /r/LearnJavascript. Thank you!
Are there good alternatives? 
Do you do any front end work? Often you can do more async stuff on the front end and the apis are quite similar. 
What's the idea behind putting actions here: \`/src/reducers/searchResults/actions.js\` instead of here: \ `src/actions/searchActions.js` seems a little weird for actions to be in the reducers folder. 
I handle this by taking advantage of process.env.WHATEVER. My node apps are deployed to Elastic Beanstalk. There is a settings section where you can set up and configure your environmental variables. For local development I have a file containing a set of ENV\_VAR=whatever. File is loaded automatically when I start app in vscode.
I have never heard of this browser till this post. How doe it compare to Firefox 57+ or Chrome?
You're mixing const and object.freeze.
I feel you, man. I’m a hobbyist who took a hiatus from JavaScript for a few years and barely recognized the landscape when I came back a few months ago. What I’ve learned is that while a lot has changed, it is mostly changed for the better. JavaScript’s syntax changes are really intuitive. The new arrow syntax instantly became my preference for writing small functions. Destructuring of objects and arrays is incredibly useful, as are the rest and spread operators. I’m sure there’s stuff I’m forgetting right now, but for the most, if you learn this stuff, most of the code you come across will be familiar and you’ll quickly come to appreciate how these changes have improved the language. I haven’t gotten into playing with new features of the language much, like async/await, generators, but they seem pretty powerful. React is neat, but it’s a whole lot different than any front-end frameworks I’ve used. It’s definitely earned it’s place and I can understand why it gets so much acclaim, but it’s almost comical how overhyped React is. People on this sub will recommend it over anything else without even knowing your use case, it’s really ridiculous. Same with Redux. It’s a great piece of software, but people will tell you that you need to be using it before they even know what you’re tying to accomplish. Both are very powerful, not terribly difficult to understand, and are well worth learning, in my opinion. Just beware that they may not be the right tool for whatever you’re trying to accomplish. Something else that is way overhyped is functional programming. Its advocates will swear to you that every problem can and should be solved with FP, but almost no one can adequately explain *why* one should use FP. The usual answer is that it’s more readable, which is laughable. And almost no one seems to appreciate that things like avoiding mutations and using IIFEs wherever possible come with inherent performance costs. Functional programming is a great tool, I’m just not convinced that it’s a particularly good tool for the purpose of web development. Frontend development has become a whole lot more reliant on tooling. There are a bunch of options for package management and bundling. And transpilation, while requiring an extra build, is 100% worth the trouble just to be able to take advantage of new language features and syntax without worrying about whether the runtime supports it. It is a *lot* to get caught up on. I’m now six months into reinvesting myself in JavaScript and it has been a lot more challenging than I was expecting, but I’ve learned a lot and I’m mostly really happy with the changes. 
I'm not arguing how it behaves in JS. I'm pointing out that if you didn't know how it behaves in JS, then making the assumption that a constant is immutable in its entirety is reasonable.
I am not an expert as I have never used the `module` type but my understanding is that older browsers will not attempt to execute scripts that have a type attribute set to `module` because they expect either a missing type attribute or one with a JavaScript MIME type. If my understanding is correct then, yes, you can use `module` and `nomodule` to control for modern and old browsers.
I don't think it's safe. The compatibility chart on mdn suggests some browsers module but not nomodule which kind of defeats the purpose. https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#Browser_compatibility
Instead of pulling in the file using `require`, read it using the `fs` module at any time you want. You don't need to read it every time; you want to cache it in memory so you can use it synchronously and then only update it by reading it again when it changes. This is a type of "hot reloading" although you'll more commonly see that term used when talking about UI, it's still a similar concept. How you detect changes is up to you: if you want it to automatically update when the file changes you can use the `watch` functionality of `fs` for example. You could also make it so when you post to a certain api endpoint it reloads it (make sure to authenticate the endpoint in this case). 
What about it?
caniuse shows it is safe now. https://caniuse.com/#feat=es6-module I'm guessing what you say is true though, since I can't find examples of it in the wild yet.
Thanks. I'll take a look.
That's what it seems like. I'm just wondering if there are edge cases where modules won't get loaded correctly, or if there are other problems you might run into. No one seems to be doing it (or at least talking about it yet).
My main language is C# so I instantly recognised arrow syntax as what we call "lamba functions" that play a big part in Linq. Still haven't figured out how to get JavaScript to recognise them.
I checked in the browsers themselves, the MDN data seems to just be out of date. The current versions of Safari/Edge (which most people are using for those browsers) support the `nomodule` attribute just fine.
I would think the current browsers to be ok, but its those browser versions in between, like iOS Safari 10.3 according to caniuse. Is that the only browser that has the missing nomodule problem? Seems that way (caniuse shows back to when it wasn't supported for most of the other majors without that footnote, except edge),
This was one of my options, however. Dealing with Elastic Beanstalk has made any local filesystem and terminal endeavors a lot more difficult. This could be my inexperience with that platform though. Just saying it's not a local server I have total control over.
My point still stands. Fix your linter.
I'll stick with AirBnB rules, thanks. I'll use a utility function for that.
Module support is very recent and so it’s possible that there simply aren’t many people who have tried it. As far as blog posts go, trying it, testing it one a bunch of browsers, and writing about the results, pros, cons, etc. would be novel content and likely much appreciated.
Most modern browsers should be able to interpret arrow functions (which are often called lambda functions in JS, too). But Babel is there to fill the gaps between what the language is capable of and what various runtimes are capable of.
Now benchmark them
I can't speak for BuckleScript nor ReasonML. I'll just give you facts about Scala.js, and let others do the same for the others. Perhaps someone can draw a comparison. &gt; but I read that it has large overheads when importing standard libraries Everything is relative. You won't get a 2 KB .js file out of Scala.js, but the "overhead" is still smaller than the react.js library, so as soon as you start doing real world stuff, the "overhead" of Scala.js is dwarfed by the libraries you use and your own application. &gt; is the most functional Scala.js, just like Scala, can be as functional as you like, or as imperative as you like. If you're the purely functional kind of person, you can use scalajs-react in full Scalaz mode. &gt; has real world companies that use it Scala.js has real world companies using it. SAP for example. &gt; is more future proof Scala.js is deeply ingrained in the Scala ecosystem, now. It will last as long as Scala lives. &gt; simpler to use with libraries that don't have its types files? In Scala.js you use values of type `js.Dynamic` to manipulate JS libraries in a dynamically typed way. You can `import js.DynamicImplicits._` to further remove boilerplate around that. However in practice real users tend not to do that. They write the least amount of facade types (our types files, as we call them) to suit their needs (there's really no need to write the types for the entire library before you start using it; one method at a time is a better strategy). The experience is simply better if you have tiny tailored facade types than if you use `js.Dynamic` all the time.
Yeah, if you're supporting `Safari 10.3` you might just want to ensure the code can't run twice, e.g. just store some global state and check it before the main application runs (obviously this can be more difficult depending on certain architectures).
The same
"Javascript inventor's new browser"
Well I know what I'm doing this weekend...
Y’all know tor is the dark web that sounds really stupid
Except that they point to objects that are very clearly not immutable. Hence `const getFukt = document.body;`. It's a misconception of the user that creating an object will freeze it, not a misnomer of the language.
It's a Chrome-based browser, but for development is sucks because it's toolset isn't mature/docked/etc. Saying that, I use it on mobile and for my work-admin browser.
If privacy and security is an issue. Then storing sensitive data on the client side may not be the best idea... what are you requirements ? Maybe you can erase the browser cache when a new user has logged in and force a re-fetch ? This library wrapper around the browser html5 storages looks interesting for storing data. [https://localforage.github.io/](https://localforage.github.io/)
Primitives are cheap to pass around, not in excess. Objects are pricy to pass around, in any case. The more parameters, the worse it becomes. - Clean code - Variadic JS functions - Needing parameter names One of these things is not like the other, for several reasons.
I completely disagree with this author. It is a misunderstanding that `const` means immutable. It does not. If you want to imply immutability, use a library that gives you actual immutability. 
Is that an appeal to authority? I'm not interested.
Of course. I don't disagree with you here at all. I would simply rather the product my clients use is mine. Nothing wrong with that, surely?
Hmm nice I'll have to check that out.
I'll chime in - one more thing I though was sorta not nice was that there is no more query parameter support - so I had to download \`qs\` (I think it was called) to parse query parameters from the url. Wasn't too happy about that, although not the biggest deal.
Haha I didn't dodge it - well, I guess I did. At the moment I don't have any plans to make an Angular version. Although I'd love to look through something similar just to see how it's setup.
Ha yup - that would be a good idea.
I was just wondering if it was because angularJS is no fun as compared to angular2 with CLI. I crammed react and angular 2 at the same time a few years back and found them to be very similar. Chose google over facebook rather than preferred syntax/stacks.
Ah yeah I can get behind that. I'm always torn on things like that. Like I get that there's a perfectly good package out there to do it and I get the argument that different users have different needs but damn it query params are part of a route! 
That may be one of the worst endpoints from a security standpoint. Not to mention it doesn't work in a distributed environment at all. You definitely want to have something highly consistent and unlikely to lose the config. To actually update the config you either redeploy or the applications go check and point in your infrastructure for their config. An example is to use AWS SSM ParamStore to host your configuration as key-values (it also support encryption which is a big plus). You query the params by path and pull it down and build your config live. Since this is potentially expensive your internal config service caches it and when the cache expires you still return the cache but spit off an async task to update the cache. 
I don't recommend following these suggestions as it adds an extra service that you have to build to even update the configurations. The services should be _pulling_ their configuration from somewhere and caching it for some period of time. [I explain it here](https://old.reddit.com/r/javascript/comments/8ulroa/best_practices_for_decoupling_config_from_code/e1h0jb5/)
Environment variables are good for non sensitive configurations but terrible for sensitive information, especially if you plan to containerize your application.
&gt; "constant" does imply immutability In most mainstream languages `const` (or `final`) works the same as it does in JS. In C++ it means all kinds of different things.
The issue is it's almost required to be backward compatible since the language is interpreted client side. This isn't an issue for the server side or if JS was able to be compiled.
Couldn't you just make an object of the values you cared about? ``` this.$secrets[secretKey]; ```
Twitter would be very different.
Check out NestJS, Thank me later :)
Y'all know there are legitment reasons to want to stay anonymous online. 
`resp.json` also returns a promise. You need to wait for it to return. A single promise being returned from a `.then`handler gets added to the promise chain, but a promise hidden inside an array doesn't - your final `.then` handler gets given an array of unresolved promises.
Actually I just started working with React Router V4 and it's actually pretty good
Like what illegal things? If you want to go private then just go incognito your service provider might be able to see your activity but whats wrong with that if you aren't doing anything illegal! Giving the dark web easily to the mass majority is not smart. You can hire hit men, buy guns, and sell sex all on the dark web. 
When you return a promise from `then` then that promise can be waited on by continuing the chain. This behavior does not extend to returning an array of promises since it’s not clear how you might want to wait on them.
Iv read that storing the JWT token in the localStorage is less secure than using Secure cookies + CSRF.
Well for 1 your ISP can sell your internet history. Your logic of "well if you aren't doing anything illegal" is so flawed its painful. Look at the entire encryption debate a few years back under Obama. The dark web is already available to the mass majority. Its open source. Anyone can download it. You can hire hitman, but guns, and sell sex on the regular internet too. Much like the dark web you just need to know where to look. At the end of the day Tor is just a routing protocol. 
How can you make a recommendation without understanding the requirements? There are perfectly valid reasons to have configuration management interfaces and I'd go as far as saying they're not even that uncommon. Heroku and Wordpress are two examples that come to mind. 
It might help you to understand if you see the *third* way: ``` Promise.all(urls.map(url =&gt; fetch(url) )).then(arrayofResp =&gt; { return Promise.all(arrayofResp.map(resp =&gt; resp.json())) }) .then(array =&gt; { console.log(array) }) ``` What is happening in your second snippet is that `arrayofResp.map(resp =&gt; resp.json())` is returning an array of promises. Since the array itself is a value, the next `then` gets a resolved promise equal to the array. Nothing waits for all the promises in the array to resolve. If you add the `Promise.all`, as above, the second function returns a promise that only resolves to an array of values once all the promises have resolved.
Just threw it into the debugger and played around a bit, looks like Response.json() will also return a promise. So, mapping inside the Promise.all() means the console log function will wait for the Response.json() to resolve before executing, but mapping outside the Promise.all() means you're getting the array of Response.json() promises and the console log function is being executed immediately.
[This might be worth checking out](https://youtu.be/568g8hxJJp4)
Yes, I have also reversed dumb questions into questions into a job. &gt; How much width does a div with display block overflow hidden with a width of 350px and 10% padding occupy *seriously checking my math?* &gt; BOM: Which box sizing *What? My interviewer doesn't know about box sizing?* &gt; Whats box sizing *Oh* &gt; BOM: With border box its... content box its... hired(true).then($ash).then(money) Okay maybe not so much that but after I was hired the interviewer actually was brought in test my basic Debian Experience and didn't know CSS himself. My interview was later used as a use case to pair interviews rather than 1:1 them during tech assessments. 
looks like other people answered your question, just wanted to point out something else. The first way is the best way to do this(even if you fix the second method to wrap the res.json() calls in a promise.all). The other methods will wait for ALL of the fetches to complete before beginning to process the .json() calls, while the first one will .json each response as soon as its corresponding fetch is complete. Probably won't be noticeable in practice, but I just wanted to explain it for the sake of explaining the concept and not just for performance reasons
Well, that's awesome. Thanks for releasing this!
It's really not that simple. If `Options` had extended `Component` rather than `PureComponent`, there would have been no improvement in performance -- perhaps even a decline. And depending on what `props.whatever` was and how you mutated it, there might be no change in performance with `PureComponent` at all. It's about knowing when and how to use `PureComponent`, not code organization. Also, are a list and its options really separate concerns?
(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+)(+_+
I hear you. I've read that whether you're storing JWT's in localStorage or in cookies you still have to keep an eye on security. Ways to do that are by setting a short expiry time on the JWT (it's set to about 15m here), and by encrypting the the JWT (it's encrypted with a key so if it's changed in any it's declined). Also of course the other routine things you do to keep things safe. But I def hear you and it's important to keep an eye on these types of security issues.
The issue with query strings is that there's no standardised way to parse arrays and nested structures. There are at least 3 syntaxes that see common use, and each parsing library usually only supports one of them. So react router had to make the tradeoff between convenience and staying unopinionated, and chose the latter, leaving it up to the user to pick their library of choice. For future reference, there is now a built-in web API [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) that can parse query strings. It only has basic array support (retrieved via [.getAll()](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/getAll)), but it can work for simple use cases.
Have you turned around a situation where you got nailed for not knowing the formal term for something? I recently got nailed for, among other things, not knowing what "IIFE" stands for in JS (I know what a self-calling function is; didn't know the glossary term)
[https://www.npmjs.com/package/dotenv](dotenv) console.log(process.env); but basically environment variables. If it goes to the frontend; reconsider your approach. Maybe JWT but definitely not. Frontend === "no bueno"
Did you read it wrong? His preference was for vue.
https://www.visualstudio.com/en-us/products/visual-studio-community-vs
probably did
Probably did, but for instance - reread his last paragraph and tell me how that sounds to you?
probably did
It's not whether a list and its options are a separation of concerns but rather the rendering of a component and the data that goes into it that was not being separated. So it is that simple 😀
yup; Linked List. I was applying for a JS-node job and its not a formal part of JS. FFS a linked list is a for loop in JS and you gotta be a damn fool to never had used one for those and I had mentioned I built a IE7 (Maybe IE6) compatible SPA-Router back in the day. I also talked about things I had thought of but didn't realize had been included in commonly used frameworks. Or how when you pass an object into a function (in JS) its an address of the object (pass by reference) not a copy of the value (pass by value). I never heard of an IIFE in my life and I been in web for like 11 years. Thats why I said prepare. The only way to avoid those traps is to prepare for interviews. I do all sorts of online quizes, hacker ranks and computer science tests. Interviews are all over the place. Oddly enough I ended up at a place that likes someone like me who likes to know lots of things about different languages and didn't care about anything I had to prepare for other interviews. Not saying you need a magic bullet of a job.... just that you can't be the perfect interview. The field is super deep/wide different jobs need different things. If you are hard up to get hired (my first job was super hard to get) then you gotta just be prepared for anything or all things you can within 'x' time allows and still feed/clean/maintain yourself. Otherwise you gotta prepare for what you can. Job descriptions and the companies websites are good places to start and take failures as opportunities to learn. I would take that not knowing what IIFE means is that job is hightly technical needs people who read glossaries. Theres two ways you could have prepared for that. Either had read more about computer science.... or two would have found a way for the interviewer to clarify the question. They were either testing your knowledge or your ability to communicate through something you don't understand. If its your knowledge then I would be worried about fitting in. If its your ability to communicate; then its an opportunity to grow.
&gt; `&lt;React.fragment&gt;` elements can be replaced with empty-bracket elements. Only with Babel 7, which is still in beta (and maybe Typescript?). &gt; And, furthermore, you can return bare arrays of rendered elements, so even that is unnecessary. You'll still get a warning about missing keys though (which means it's less optimized).
It's relevant to an ad network so there is definitely a need for speed and scale.
a linked list is basically a class with an add, remove and enumeration method. It has a head and tail field. You add or remove instances of a node class which has a value field and a next field which points to null but when you add a node it becomes the value of the next pointer and also the new tail value. That's why it's called linked list... I don't really see how a for loop is a linked list
You could use nightwatch, cypress, selenium IDE or selenium-webdriver.
 [https://addyosmani.com/largescalejavascript/](https://addyosmani.com/largescalejavascript/) has a good explanation of architecture consideration for JS based apps. You could also use MVC in native JS [https://alexatnet.com/model-view-controller-mvc-in-javascript/](https://alexatnet.com/model-view-controller-mvc-in-javascript/)
How are you in this sub..
I want users to access my app even if they are offline. If I erase the content on logout and if the same user logs in again in offline mode immediately he/she will not be able to access the application.
Some stylistic choices I would do personally do differently: - Try and have your variable names accurately describe their purpose. Verbosity is encouraged. `el\` should likely be \`elements\` to infer its a Map of DOM nodes. - \`var vars\` does not give any context to the purpose. In this case just set a variable named contextmenuopen, variables are cheap. - CamelCase variables and function names (but this is a personal preference) - One statement per line, do not chain multiple statements together with a semicolon separating them. each display property change in transfers_icon() should be on a new line. - Prefer addEventListener over inline onclick handlers, this allows you to add/remove listeners, add more than one listener to an element, specify bubbling or capturing depending on your needs, and a whole host of other things I can't remember. - You use `document.getElementById('folder-name')` multiple times, cache this early on in your elements variable at the top. - Don't chain var statements. Declare each variable with a new line using var/const/let whatever at the front. This can help prevent multiple problems, mostly around human error (forgetting a comma - auto semi colon insertion) and some other stuff. - You have a lot of anonymous functions doing the same action, give those a name and reuse them. Overall, good work. I like the pattern of exposing only the init function. 
If you're in the learning process, I would say good job; and yes, this is totally okay. Honestly, if you're learning, and it works, it's always okay. You can always refactor later once you learn more patterns. Some comments: * In my experience, most folks use camelCase for names. Not a big deal, but it tends to be the convention. * I'd recommend using `let` and `const` instead of `var` for declaring variables. `let` lets you reassign a value to the variable, where `const` does not. Note that `const` does not make the value immutable, just the reference, so you can, for example, add/remove items to an array you've declared with `const` or add/remove properties to an object you've declared with `const`. It's nice being able to see whether or not the value will be reassigned, though, and can save you headaches down the line. * I tend to name my functions to be more descriptive of what they do, or at least prepend the word `handle` to them just so I know they're functions later on. E.g. the name `home_icon` suggests to me that that is an element, when really it's a function. * I noticed some repetition that could be cut down with the use of some higher order functions, like `Array.forEach`. For instance, for all those elements that have the same onClick function, you could do something like this: --- [download_link, share_link, get_link, rename_file, properties, delete_file].forEach((el) =&gt; { el.addEventListener('click', () =&gt; { vars.contextmenuopen = false; div.remove(); }) }); --- * This is def personal preference, but I tend to avoid innerHTML and build out my elements using `createElement` and append them. If you wanna make that easier, you can write a helper function to help you out, like this: --- function makeEl(type, attributes = {}, children = []) { const el = document.createElement(type); Object.entries(attributes).forEach(([attribute, value]) =&gt; { const attributePath = attribute.split('.'); attributePath.reduce((acc, property, i, arr) =&gt; { if (arr.length === i + 1) { acc[property] = value; } else { return acc[property]; } }, el); }); if (children) { children.forEach((child) =&gt; { el.appendChild(child); }); } return el; } // Example usage: const innerEl = makeEl('span', { className: 'cool-span', 'dataset.type': 'cool', innerText: 'I am one cool span' }); const outerEl = makeEl('div', { className: 'wrapper-div' }, [innerEl]); // Outputs: &lt;div class=​"wrapper-div"&gt; ​&lt;span class=​"cool-span" data-type=​"cool"&gt;​I am one cool span​&lt;/span&gt;​ &lt;/div&gt;​ --- All that said, though, good job and keep at it. I will say, though, that I would probably not try to build my own SPA using only vanilla JS if I thought it was gonna turn into a real thing someday. Frameworks do a lot of stuff for you, and they're not as complicated as some people make them out to be, IMO. I'd look into React or Vue if this project keeps growing.
Hell, half the time I end up just assigning a new const with the same name but 'new' or 'current' amended to to it, you know, in case you need that previous value.
Ahh, I see. Thanks a lot. Your explanation gave me that 'OOHHH' moment. I appreciate it. 
Gotcha. So that means if I wanted to print each object as they became available I should've used forEach instead? Makes me wonder what the practical uses of Promise.all are if the next .then will have to wait for all the promises to resolve.
If by scale you mean multiple servers, yes, this simplified illustration is not good enough because it only syncs the in-memory state of the responding server. But the point of the example was to clear up the misconception that it is in fact possible to have atomic reads with an async source-of-truth. Pulling the config data via a cron is one way to support horizontal scaling. We use that technique for translation caching at Uber. This technique is OK for that use case because it isn't that timing sensitive, but might actually not be the best if there are timing concerns for, e.g. ad campaign configuration. For example, if there's an outage on a conversion page, you want the ad campaign to be turned off immediately, not in 5 minutes (or you'll be wasting a lot of money). There are also other architectures, such as using RabbitMQ to sync all the servers' cache. Obviously more complex, but if you need the responsiveness, it's an option.
I use Tor for most of the browsing on my desktop. If you have nothing to hide, live in a glass house. Who needs curtains? You could be doing something illegal in there! You’re kind of missing the point of privacy. What I do online is my business and no one else’s - even if it’s just looking up recipes.
Juat because you have nothing to hide doesn't mean you have nothing to lose
But we don’t have any privacy! If you even walk outside in public most likely you can be tracked. There are cameras everywhere! If someone really wanted to track you they can. Remember when the FBI wanted Apple to unlock a criminal phone, well Apple refused but the FBI was still able to unlock the phone. If you like privacy then that’s fine but something like Tor where you can access illegal things with ease is so stupid in my opinion. Yeah Tor is open-source and everyone can get to it but some people in this thread were asking if it was better than Firefox or Chrome, so when you introduce this stuff to people where you can buy stolen things at very low prices or pay someone to hack PayPal and give you more money than you payed, people are going to buy that. You can’t introduce this to the masses it will cause a crisis!
You can't return the value from an event handler. Where do you want the value to end up?
Try this: (remove eval, user square brackets) { input: someString, output: { [variableName]: 1 } }
Hi /u/oariik, For javascript help, please visit /r/LearnJavascript. Thank you!
Eval = evil Call variables as keys by wrapping in square backets
A few years ago, I went to an interview (it was an Angular job). They gave me this 10 page test asking, among other completely irrelevant things, to explain `volatile` (the Java keyword), questions about servlets and several puzzle questions (you know, the how-many-ping-pong-balls-can-you-fit-in-an-airplane kind). I got about half way through, said fuck this shit, gave the test back and walked away. A day later, the recruiter calls me saying... they want to move on to the next round. Apparently nobody else got that far. I'm already rolling my eyes, but the recruiter says in this round I get to talk to the the tech director, so ok, fine, let's entertain them. I go talk to them, they spend like 2 more hours asking even more dumb questions, like naming GoF patterns, and some questions that I had already answered in the previous test. Judging from how it went, I'm pretty sure they were going to offer me the job, but the whole experience was just so appalling that as soon as I got home, I just politely told the recruiter that I was no longer interested in the job. 
I get the feeling you have misread what \`eval\` does. Eval is used (rarely) to evaluate code from a string. What you want to do here is to add a property to an object where the variable has the property name. You can do this in two ways: function func(variableName) { var myObj = {}; myObj[variableName] = 1; } or if you can use ES6 features: function func(variableName) { var myObj = { [variableName]: 1 }; } You can [read more about objects on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer).
Thank you, I'm always curious how unusual stuff like that is built!
Thank you so much!
This. I also tried making games without canvas, because with canvas I might as well use real game engine, and that takes away the fun. But he even made it work on IE6, impressive AF
I have a method called getHeight() and I want to use its output some other place. Is it not possible?
Lets say we have a function called `getData` that returns an `EventEmitter` that can emit a `data` event. If you want a function that returns the result of the data event you can do that in two ways: // Callback function function foo(callback) { getData().on('data', function(data) { callback(data) }); } // Promises function foo() { get }
I tried using Promises, but to no luck: getHeight(){ new Promise(function(resolve) { var stream = db.createReadStream() var heights = [] stream.on('data', function(data){ heights.push(data.value.height); }).on('end', function() { resolve(heights.length); }) }).then(function(height) { console.log(height) // 2 return height; // undefined }); }
You are still returning the height into the void. You need to return the promise itself.
Oh, you’re one of those recipe weirdos aren’t you? /s
Small nit: Linked lists can be implemented with classes, but are not necessarily classes. The only requirement for a linked list is that it should be composed of nodes, and that each node has two slots (data and next, aka head and tail, etc). Class methods are merely conveniences to make it easier to work with them in OOP-land. Lisp, for example has `cons/car/cdr` and friends instead. In JS, a linked list is basically something with a shape like `{value: 1, next: {value: 2, next: {value: 3, next: ...}}}`. If you ever traversed up a DOM tree via looping through `while (el = el.parentNode), that's pretty much the same concept as linked list iteration.
Turkey is evidence of this 
Not. If you have so many parameters that they are hard to keep track of then you need to reconsider code design. If it's not clear what 1 or 2 parameters a function is expecting then a rename is in order. Extreme edge cases need not apply.
I edited the file: return Promise.resolve(heights.length); Now i have a promise pending. If I store it in a variable and then .then it, I get nothing :P (sorry for being a newb)
You are not returning the correct promise. // Promises function foo() { return new Promise(function(resolve, reject) { getData().on('data', function(data) { resolve(data); }); }); } vs // Promises function bar() { new Promise(function(resolve, reject) { getData().on('data', function(data) { return Promise.resolve(data); }); }); } In the second example `bar` does not return anything. In the first example `foo` returns a promise that will be resolved when the data has been found. foo().then(function(data) { // Do something with the data }); bar().then(function(data) { // Uncaught TypeError: Cannot read property 'then' of undefined });
&gt;FFS a linked list is a for loop in JS uhhh, what? I don't think thats a true statement.
Brb checking out vue 
Why Google over Facebook? I don’t have any particular leaning either way, just wondering. I chose React over Angular 2, because I had a terrible time with AngularJS and saw that Angular 2 was essentially following in the wake of React. That led me to believe that developers in general (even at Google) saw React as a superior paradigm, and would therefore lead to more job opportunities since Angular would have to fight too hard to regain market share that they must have lost to React.
You are right, bottom line for me is that these are quite useful concepts to know, in any paradigm.
But in JS, functions are themselves objects, no?
Thank you, good advise, I agree with doing small complete projects with specific scope. I have quite the same approach actually; I made similar apps in different (back-end) technology - I've built Angular polling app with [Java Spring Boot Backend](https://github.com/kle-pra/polls-spring-boot) and [Node](https://github.com/kle-pra/polls-node) back-end, but Node version is pretty basic - no tests etc. Also some other [logger](https://github.com/kle-pra/daily-logger-spring-boot) like app. Pretty simple and not really polished yet, but I like the feeling of building a complete application, even if it is very simple - and you can add-on to it in the future. I agree on jwt/auth part - I've recently started to implement it in my learning projects (both, Java and Node), although I am not using refresh/access tokens yet - only one. I will check out your approach with JWT. I guess once you understand how to implement user authentication in a specific technology you are starting to get pretty comfortable with it. I guess I understand async/await but not quite used to it yet as I don't really work much with JavaScript directly, apart from checking out some videos/tutorials - as a Java dev I am pretty comfortable with Angular but I will dig into React more in the future and make some simple apps as I believe it will improve my JavaScript understanding. And also switch Express for Koa. My day-job is mostly maintaining legacy Java applications so I have to keep myself up to date by learning on my own. 
Mostly Angular as far as front-end goes, but subscribe model with observables is more often used then promises.
JavaScript = crime against humanity. 
Looks really good. Gotta find time for trying it out soon :) 
I'm using scalajs on my daily work more than 2 years right now. It is very stable and there is lot of scala libraries compiled to scalajs world. Many javascript libraries have facades already published to maven repo. 
Does "less code" really imply a "simpler coding experience", though? As a 3rd-party reading your code, I look at something simple like your [App.vue](https://github.com/johndatserakis/koa-vue-notes-web/blob/master/src/App.vue), and look at how many modules are implied to have loaded without actually specifying its source. The `&lt;footer-main&gt;` for example, requires that your router.js is loaded, which registers a `Vue.component` (essentially a global) so `footer-main` is your Footer.vue. Not only is it harder to reason about, but it limits us if we want to code-split the chunk too. If you're using direct imports, every missing one shows up as a big squiggly red line from static-analysis in my editor long before runtime. Every non-trivially small component can be included via an `import()`, so it only gets its chunk loaded when I decide it's needed. There's a lot more that forgoing pure ecma for a micro language hinders you for too. Dead-code elimination is basically impossible, both because Vue.component and router are essentially globals, and because so much of the control logic (e.g. `v-if`) is in microlanguage. There's the complexity of needing to learn, write, and reason in multiple languages at once (both harder to build and reason about -- with React and emotion, I don't need a single line of CSS, or to write any HTML beyond the tiny boilerplate react-create-app makes). Don't think I'm being too critical - super happy you wrote this and released it to everyone. I do think a lot of your problems with react are based more in familiarity with vue, and React not being enough like vue isn't really a flaw. Some of your criticisms of individual libs (especially router) are pretty spot on, but you're also not following some basic patterns that React devs (especially the FP-loving ones) routinely use. e.g. out of array methods `map`, `reduce`, `filter`, `find`, `Array.from`, `[... ]`, etc., I find only a single `Array#map`, which is pretty unusual for a React app. React's all about passing in the same collection as a prop to different components, and rendering them differently, e.g. a collection of restaurants could be mapped to a bunch of pins on a `&lt;GoogleMap&gt;` in one place, a text list in your `&lt;Itinerary&gt;` somewhere else, `Vegan options: {restaurants.filter(({ cuisine }) =&gt; cuisine === vegan).length}` in another component, etc. 
They asked if BRAVE the browser is better/worse than Firefox/Chrome. Not Tor
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [johndatserakis/koa-vue-notes-web/.../**App.vue** (master → 33c1d59)](https://github.com/johndatserakis/koa-vue-notes-web/blob/33c1d59a6d9a26805af1200f18a09f62c7f46bc1/src/App.vue) ---- 
I've always called Brendan Eich by his true name: JavaScript.
I feel like I am getting there, but, still not quite. I changed it to your second example: return new Promise(function(resolve) { and then later when I call it: getHeight().then(function(result) { console.log(result); // 2 return result // Promise { &lt;pending&gt; } })
Filthy R casuals. Julia is where it's at. 
I think it's the best mobile browser on the market. As for desktop, it is my primary browser. However \-Some people don't seem to like the UI \-Extension support is lacking But, all this will be resolved in September approx. as Version 1.0 will be released. Which will have Chromium look and full extension support.
Okay I’m done! I’m not going to delete this thread of comments but yeah I think privacy in the digital age is irrelevant. Face it, we can’t be completely private in America at least. If you were born in a hospital, BOOM a record of your existence. If your friend posts a picture of you on their Instagram, BOOM a record of your existence. That anyone can hack may I add, find your IP address (if not using VPN) and start to know more and more about you or someone else you know. I don’t think a private browser like Tor is really necessary. If you want to keep your feelings private than do it. By entering the world of the internet you understand that you can be seen. I personally hate when people say Google sells your information, and they do, but what do you expect?! It’s a business. The internet isn’t just a way to have fun. It’s way to interact with people good or maliciously. You can’t be private in 2018. I don’t think Tor is a good thing, because it give people access to highly illegal things while remaining anonymous. If you like Tor because you don’t like being tracked good for you, but now you know my opinion. So yeah, nothing is free without a catch. Privacy is the internet’s catch.
Syntax error.
You did not mention different between call() &amp; apply()
Narc
Work. To be honest it is 2 years in production. Project has ~30k lines of scala code, over 300 scala files and most of that is on scalajs site. All is arranged in 7 sbt subprojects. I share all models and many algorithms between clients (there are 2) and serwer side. On shared code i have access to many libraries from scala world (here are few important for me): upickle, circe-generic-extras, utest, scalatags, sourcecode, shapeless, scalactic, monix.
I can't see the point. I will answer the question and then explain why it's not a good idea, or has little practical value, probably with examples if it's that type of interview. You never really know what the interviewer knows, often you don't even know what the interviewer's relationship with your potential new team is. You certainly don't know if they're the snowflake type who will be immediately offended, cry and soak up their tears with your CV if you question their authority. It's just not worth the risk. Play along, don't insult the interviewer, do be constructive: "That's a silly question, I won't answer it" = bad "The answer is *x*" = better "The answer is *x* but in practice we'd shimmy up y" = best
A self-calling function is *recursive*. An *immediately invoked function expression* doesn't call itself (not necessarily, anyways), it's just... immediately invoked.
`data` and `next` are not synonymous with `head` and `tail`. `data` is the content of a node, `next` is the node after the current one, `head` is the first node in the list, `tail` is the last node in the list.
I'm curious why are objects expensive to pass around in js? In most languages passing a reference or pointer or whatever equivalent is relatively cheap, say something like 32 or 64 bits. What makes js objects expensive to pass?
I like vue before, then I go to write some app in react, and when I comeback to vue, I just can't stand vue template, I prefer JSX more.
Thanks for that, a very good way to do some comparisons between frameworks, much better than the usual fanboi wars. Also like the fact that your app more or less is kinda complete. You don't mind if I take a good look at your code concerning your auth techniques, right?
Caddy server does it beautiful: [https://caddyserver.com/docs/http.jwt](https://caddyserver.com/docs/http.jwt) 
correct me if i am wrong... call() binds the context and call the function whereas apply() just bind the context.
[removed]
OP I was going through your backend code and there a lot of bad practices with Koa routing. For example in your Routes files you declare your routes like this: router.post('/api/v1/user/signup', async (ctx, next) =&gt; { await userActionController.signup(ctx) }) when it can be set up like this: router.post('/api/v1/user/signup', userActionController.signup) Also instead applying the same middleware to 10 routes individually, you can apply blanket middlewares using 'router.use()' And I'd also use route prefixes for common routes things like '/api/v1/' instead repeating yourself.
A hearty chuckle to you good sir 
It would be. The 'next' would be n+1. It's not formalized its implied. JS doesn't need the formalization that Java would. Sure its helpful for those that need it; but if you were to build a link list in JS you would start with an array and some kind of pointer. To get the next its counter +1. If you stored the next in the array the you are just making it more complicated. 
Do you have any plans to simplify JS? It's accreting so many features that it's becoming almost as bad as C++...
What about adding TypeScript &amp; storybook? I've found both kind of indispensable for larger projects.
More companies use Scala.js, that being said learning OCaml(bucklescript, reasonml) might prove to be very beneficial to you.
Just that you don't need all that extra. I think I need to clarify; if you have an increment you can get the next/previous value. You don't need a whole api around it for i+1
Did you try something like this? https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Array/filter I would rather filter it with a query instead of filtering dozens of data entries on clientside
You can use filter method on your array. It takes one argument which is single element from that array, and after that you must return true or false. You can get more information by searching "array filter" in google.. 
If you are allowed to use async/await then this approach would work. ```js let list = ['a', 'b', 'c'] const promisifiedSomeCall = (input) =&gt; ( new Promise((resolve) =&gt; ( somecall(input, (data) =&gt; resolve(data)) )) ) async function f(i, list) { if( i &lt; list.length) { const r = await promisifiedSomeCall('input') list[i] = r await f(i+1, list) } } const b = async () =&gt; { await f(0, list) console.log(list) } ``` 
I was looking at Apple's MusicKitJS as my first encounter with JWT. I'm not a developer anymore, I do network stuff, but I have a development background and I occasionally write stuff. Basically, I'm out of the loop. In Apple's example they were using JWT for authorization into the Apple's servers, from the client. At the time I was immediately hesitant, and this article hasn't helped, so maybe someone can help. What stops a client from just pulling information from my webapp, and using it on their own webapp? Apple will see the requests as if it's from me, to my understanding, and if they spam the hell out of Apple it comes down on me. Am I fundamentally missing a piece of JWT? 
One way to do it. Is to have a state item that would indicate loading. Have your loading animation play while this is set to true. Then have your call back from the fetch set it to false after it sets state for your data. Like this this.state ={ Data: [], isLoading : true } Fetch ( something ). Then( this.setstate({ Data: dataFromServer, isLoading:false}) 
Upvoted. I don't think you're being too critical. It's just one of those things where this is a full example, so there's a lot of moving parts. I would argue that *things* like `&lt;footer-main&gt;` all follow the same exact pattern, so while it may seem strange at first, you'll pick up the structure right away. Regardless - there's definitely something to be said about how you have to explicitly do certain things in React - like adding routing support to the footer if you wanted to push from there. I can definitely see the argument that it keeps things more focused and compartmentalized.
If someone copies your token they will have access in any system. If you mean can they simply replicate it if they know the contents, the answer is no, unless they have the secret used to generate it.
On a related note, here's an article to read when determining if you actaully need JWT's (answer: for most applications, no). http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/
Of course - hope it helps.
Def interested in both. Going to research them for sure.
Thnx , nice and simple.
Thanks for the feedback. I'm not so sure about you example though - if you look at the first example on [koa-router](https://github.com/alexmingoia/koa-router) you see they have it like I have it. That's not to say your way isn't better - but to say that they way I have it, the official example way, is bad practice - I think that's a bit too intense. I'm about as smart as a bag of bricks though - so I could be doing the whole thing wrong haha. &gt; Also instead applying the same middleware to 10 routes individually Are you talking about the JWT middleware? That's only for protected routes - I'd like to keep that separate and only apply it when I'd like. Thank you for the perspective!
Counterpoint: JSON Web Tokens Suck - Randall Degges (DevNet Create 2018) [https://www.youtube.com/watch?v=JdGOb7AxUo0](https://www.youtube.com/watch?v=JdGOb7AxUo0) I saw him give this same talk at CodeMash 2018 and he makes a lot of good points. JWTs don't solve much that session cookies didn't already solve.
First I thought you just made a simple mistake but your reply tells me you don't seem to understand basic JS. The example on Koa Router Github is not using any imported controller methods like yours. function callbackFunction(ctx) { //do something } router(callbackFunction)
My dude - I head what you are saying. I know what your example is showing. I'd like to have it like the official documentation has it. Does that mean I don't know how JavaScript works? I guess. Thanks for the feedback. I can tell you know a lot about this, and although you tone is off-putting, I'm still going to gather positive feedback from you reply. Thanks again.
Hi /u/giugiuglia, For javascript help, please visit /r/LearnJavascript. Thank you!
TL;DR: Their list: 1. Esoteric as %^&amp;*! (e.g. Brainfuck) 2. PHP 3. JavaScript Reasons for JS? - ASI (Automatic Semicolon Insertion) - Weirdness around arrays ¯\\\_(ツ)\_/¯
Somehow, this was cringier than I expected. JavaScript sucks because of ASI? Get the fuck out of here. I've been semicolon-less for about 3yrs, you know how many problems I've ran into during that time after 100 of thousands of lines of code? **Fucking 0**.
Tell me what other language runs natively in the browsers that is better. 
Is it easy to import and use libraries that don't have the facades?
I disagree with a fundamental premise of that blog post: That we should still be using sessions *at all*, at least under most circumstances. Sessions are a clunky mechanism, prone to failure and scalability problems. Once you reach the point where you have to load-balance your back end in some way, you need to start either replicating your sessions or storing them in a shared location, like a database. This will get more and more difficult the more scaled up your environment gets. JWT is a much more elegant solution. Any server in your environment can validate a JWT, regardless of whether or not it generated it, which solves the scaling issue. And done right, JWT can be as secure as most session-based environments. Another thing: I note that the blog post is two years old. A lot has changed in the last two years, and the industry is rapidly moving towards embracing stateless JWT.
Wow, I had never heard these arguments before ! (or did I...)
Sorry to ask,but are you talking about react or vanila js?
I regret giving this article a pageview.
We are talking about react. 
Un-necessary destructuring is un-necessary
Ok,tips for doing in vanilla js
My problem with JWTs is that there's no way to revoke them until they expire, save for attaching them to backend state, at which point they're a complicated session cookie. So if you've got some sort of situation like a security breach or a malicious user, where you need someone locked out NOW before they start trashing the place, you're stuck waiting at least until the token expires.
entirely agree :) 
Don't worry about scale until you need to worry about scale. You need sessions. Users expect sessions. JWT are not stateless (you need to encrypt them do you not? Where is the key stored?). How do you invalidate JWT sessions?
&gt; In Vue, if you want to show or hide something - just use &lt;div v-if="myVariable"&gt;Lorem...&lt;/div&gt; and it'll be based of your myVariable truthiness. In React it seems like you have to do: &gt; &gt; javascript {this.state.myVariable &amp;&amp; &lt;div&gt;Lorem...&lt;/div&gt; } Yes, however, if you simply want to hide a component and do not care if it is attached to the `DOM` you can use `hidden={true}`
There actually is a good solution for that. Have a token blacklist. When a token becomes compromised, simply place it in the blacklist, and it's done. And your blacklist doesn't have to be particularly large (unless you're getting compromised all the time, in which case you have bigger problems). Once a blacklisted token expires, trim it from the blacklist as it's no longer necessary to have it there.
I'm okay with using them through typescript for now. It's not perfect but the intellisense and compile time errors are there.
With Autht0, you can restrict origin, so tokens only work from certain ones.
No you're not hearing what I'm saying. You don't even seem to understand that there's difference between your Koa-router code and the example on koa-router github page. You're using 2 extra lines of code per route. If your app has a 100 routes, that's **200** extra line of code that shouldn't be there. This is completely unacceptable.
You can have an HTML element that is animated with CSS like a spinner, but has `display: none` by default. Right before the fetch, you can use vanilla JS to select the element and make it displayed, then after the fetch is done, set the element display back to none.
I clicked the link because I misread "when i was high in school"
Thnx, i wasnt even considering something so simple 
Honestly, I've seen the word `tail` be used both ways. Here are a few links from some quick googling: https://en.wikipedia.org/wiki/Linked_list &gt; The 'tail' of a list may refer either to the rest of the list after the head, or to the last node in the list. https://en.wikipedia.org/wiki/CAR_and_CDR &gt; the operations are sometimes given the names first and rest or head and tail https://stackoverflow.com/questions/30440260/singly-linked-list-tail &gt; The tail is equal to head-&gt;next I've also seen the equivalent of the `const [head, ...tail] = array` idiom in many languages (Haskell comes to mind, for example)
I assure you that not only are those two things not mutually exclusive, they are in fact both true statements.
'''TLDR;''' Destructuring uses more memory than not using destructuring ... but the author offers no assessment of the actual performance impact of that memory usage, and then goes on to say "and none of this really matters because readable code is more important than performance."
I think this is a pretty important topic. I'm not longer a developer, but I still code for my job. I believe unless you're unemployed, and just need income, you're interviewing the company as much as they are interviewing you. What does it say about the company if they are asking you irrelevant questions? It says they prob. don't have a very good set of hiring processes. It says they prob don't have quality people who work there as a result of that. It means there will be less people who you will be able to learn from. When I hire a new employee I only have HR validate the "culture fit" section. Simple things any decent human can sense like: Do they seem to be a nice person Can they articulate their thoughts in a constructive manor etc. Without fail, representatives from my technical team and I interview every candidate together. This allows the technical team to understand who they could be working with and provide feedback. It allows me to see the dynamic of the candidate and the team. It allows the team to ask for questions I may not think of. Hopefully you can find a job in a good company where you enjoy working. The hiring process can tip you off in a big way if that's possible. Just my two cents...
Oh ok, nice. But that's not reactive right? Or could I use `this.state.boolean` as the `true` value there to make it reactive?
That's a good point, and I suppose while it's still stateful to a degree (just with a default state of "not revoked"), it's probably a lot cheaper to look up each time, but just as effective.
When you don't understand JavaScript you gotta put it in a black list I know the feeling bro 
PHP and JavaScript have three things in common: 1.) Ubiquity (though it's not been the case for PHP for years now) 2.) Huge evolution in their use case. 3.) Appeared at the same time as Java. So my theory is that it was popular among Java advocates (trained in schools soon enough) to bash both PHP and JavaScript, pointing out the quirks gained from their awkward births. Pythonistas would occasionally chime in, being a more mature and much loved scripting language that was also taught in schools - though it *feels* like most Python advocates would usually complain about the C-like syntax, which I understand. PHP and JavaScript are not bad languages; it just became popular to mock them (out of some kind of professional jealousy?), and that popular bashing simply infects peoples' opinions. It's pretty sad that some people succumb to hyperbole and opinion osmosis like in that article.
You can pretty easily do that with JWT as well though, can't you? You can pretty much add whatever you want inside the token. Source: I did something with JWT a few years back, so don't trust me.
I appreciate your reply. Here are my thoughts: &gt; prone to failure Sessions are much more time tested. I think it's far more likely for a developer to mess up with JWT's. For example, storing them in localStorage, creating a XSS vulnerability. &gt; scalability problems The scalability of stateless JWT's are rarely a factor in most applications. Most developers aren't working on Reddit, Twitter, or anything that requires that kind of scale. &gt; Once you reach the point where you have to load-balance your back end in some way, you need to start either replicating your sessions or storing them in a shared location, like a database. You can also use sticky sessions which take no time to implement. Some products like in Azure, do it for you already. &gt; I note that the blog post is two years old. A lot has changed in the last two years I don't see anything out of date in the article. Can you name something specifically that is no longer relevant? Comparing the pros and cons of the article, and your reply, I can't imagine anyone thinking we should no longer be using sessions for "most circumstances". Also, when you start fixing problems with JWT's, like invalidating tokens, you are just reinventing sessions: http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/ JWT's definitely have their place and are a good tool to have in your toolbox. My point is that most applications will not need them. Note: I don't mean to sound combative :P, we both bring up some good points.
Probably yeah, my main experience with them so far is Auth0.
Can you point me to where JWT is actively used for session management. I'm absolutely not challenging what you said -- particularly where you said, "done right". My understanding is only that moving state to tokens still requires some way of identifying and preventing token reuse (replay attacks) and I really want to see how that is being done currently. I wrote a fairly lengthy comment earlier that the mods silently removed -- perhaps I said something factually incorrect in it. I am hoping to see how replay is mitigated. It is certainly not handled in post's linked article at all, so my view is that this article is possibly harmful.
What does "simplify" mean to you? Which features do you think cross the line?
I’m not but it does seem like I’m one 
Perhaps worse than the performance implications are that the runtime error is now coming from generated code if the passed value is null, undefined, or some other unexpected thing. This can be more confusing to debug, and in my experience is more likely to be introduced in an oversight than explicit property accessing/assignment.
A selection of the features that worked well, and a plan for how to deprecate the things that didn't. I'm old, I know naming features isn't the problem. What I'm asking you is how you plan to deprecate things. My first stab at the problem would be automatic polyfilling. Perhaps someone else has a better idea, but what's the plan?
Yep. It's only stateful insofar as temporarily storing anything on the server is stateful in a sense. And the nice thing about it is that most of the time (assuming you have otherwise good security) the blacklist will be empty.
I just want to laugh every time I hear someone complain about JavaScript’s treatment of semicolons. Use them or don’t use them. Outside of a handful of edge cases that you should avoid anyway, it literally does not matter.
I don’t feel like that was a fair comparison. Shouldn’t it really be framed as an arguments object vs positional arguments? The ES6 destructing is just syntactic sugar.
I think it should be self-evident that introducing an extra object and making two property lookups to retrieve values and then assign them to variables will be more costly, as compared to directly assigning these two values to variables. This is true even without using destructuring, property lookups are expensive as is.
I'm wondering what you think we should remove. There is no plan to deprecate things. As long as features are used on the web, they will stick around. We have no desire to break the web or create a python 2/3 situation here.
As soon as I name a feature, it's my personal preference. I'm asking you for a plan for how to generally update the web. If you can have new browsers running old code and it all keeps working, you're meeting your main criteria for not breaking the web. So automatic polyfills for new browsers loading old code would be one approach. Do you have a plan?
It's an added layer, sure... but it's no more complicated than maintaining different configs, and you're also able to maintain a single build so that you're effectively deploying the same codebase to any environment.
I'm not sure what you're asking about, sorry ☹ But I think the answer is "no" if you're talking about removing significant features from JS.
You can't just add endlessly, you need a process to clear out old decisions that didn't work out. In code, it's called refactoring. Look at smoosh. Look at #private... you're already being forced into decisions because of legacy issues. This will just get worse. If you have options like detection of Mootools and loading in polyfills, then you can deprecate on a continually viable platform. Otherwise, it's like every other platform in the past. It gets old, it gets barnacles, it's full of historical crust and dies after all.
But it is.
I look forward to seeing your proposal to delete features from JavaScript without breaking anybody! Truly a workable proposal there would be amazing.
Babel? You just use preset evn and target browsers as your product specification needs.
&gt; Ian Buckley started out with a degree in Music composition, before devoting his time to DIY tech and coding. He now works as a freelance journalist, performer and video producer living in Berlin, Germany. When he's not writing or on stage, he's tinkering with DIY electronics or code in the hope of becoming a mad scientist. Ok then.
I don't understand why this was tested vs positional arguments instead of being tested vs a non-destructured object argument. The article ends up measuring the wrong thing. 
Thanks for your thoughtful reply. And don't worry, it didn't come off as combative. &gt; *Sessions are much more time tested. I think it's far more likely for a developer to mess up with JWT's. For example, storing them in localStorage, creating a XSS vulnerability.* While those are certainly possible, sessions are by no means immune to problems unique to them. Race conditions, for example, are ridiculously common with PHP sessions once you're dealing with concurrent requests that involve caching information in the session. &gt; *The scalability of stateless JWT's are rarely a factor in most applications. Most developers aren't working on Reddit, Twitter, or anything that requires that kind of scale.* Fair enough, but I would argue that stateless JWTs are all you need in most situations, so the fact that they operate well at any scale is an argument in their favor. &gt; *You can also use sticky sessions which take no time to implement. Some products like in Azure, do it for you already.* Depends a lot on your environment, but I'm happy to agree with you on that one. Sticky sessions solves some (not all) of the issues with sessions scaling. &gt; *I don't see anything out of date in the article. Can you name something specifically that is no longer relevant?* I wasn't referring to anything technologically out of date. I just thought the author wasn't aware of just how popular JWT would become and the sorts of mechanisms people would invent to smooth out its rough bits. &gt; *Comparing the pros and cons of the article, and your reply, I can't imagine anyone thinking we should no longer be using sessions for "most circumstances".* What environments do sessions still make the most sense in? I would say there are three categories of web-based applications with regards to JWT and session security: Those that should use sessions, those that should be JWT-based, and those that could reasonably use either. I see the first group shrinking, and the second two expanding. &gt; *Also, when you start fixing problems with JWT's, like invalidating tokens, you are just reinventing sessions:* So looking at his flowchart, I think he's being very unfair with the blacklist option. Yes, just like shared sessions, you would need a shared blacklist. But unlike sessions, if the shared blacklist goes down for some reason, most of the time the impact will be nonexistent, because most of the time, a well-managed blacklist will actually be empty; once a blacklisted token has expired, it should be removed automatically.
[Allow me to drop why to not use the env for sensitive information](https://diogomonica.com/2017/03/27/why-you-shouldnt-use-env-variables-for-secret-data/). If you don't have a great risk and you correctly follow least privilege practices then you might mitigate, but otherwise you need a better way to secure your secrets. 
&gt; but if you were to build a link list in JS you would start with an array and some kind of pointer. That's not true either. A linked list would consist of only nodes that contain a `next` pointer. A `push` to an array results in a new array being allocated and assigned to that variable. (unless you defined your array with a fixed length. but even then once you go beyond that you are back to reallocating memory) By using an array as your underlying data structure for a linked list, you are missing the point and memory benefits of a linked list in the first place. https://gamealchemist.wordpress.com/2013/05/01/lets-get-those-javascript-arrays-to-work-fast/
But the point is memory consumption. Pushing to an array beyond its current length allocates a new one in memory.
To simply reset the configurations across your cluster _now_ is you'd do a rolling restart of all your nodes. Alternatively you'd add an endpoint (protected by a token) that could be queried to manually purge the config cache so it'd refetch. At the scale of uber you could start rolling restarting the pods. The applications should be resistant to dropped connections anyway. This method still doesn't need an external resource to reset configurations. There are dozens of ways to do this all with their tradeoffs, but I think keeping the number of excessive subservice tooling to a minimum is the best approach.
In my time using Vue, the only time I've manipulated the real DOM was to pause/play a video. It really isn't that common
I made a CLI tool for doing three-point estimations. https://github.com/gsipos/esti-mate-cli
Yeah angular is really heavily setup with observables, which don't seem to have taken off hugely with any other frameworks. Promises are fairly similar to be honest, but if you wanted to use them more, you may want to take a look at react or vue 
You can try ngx-boostrap
We do do gradual rollouts for feature releases, but ironically, that incurs quite a bit more infrastructural complexity than a caching+pubsub service.
Yes, you can `state` or any js to make it "reactive/dynamic".
Will be fixed today. Thanks for pointing it out.
[bootstrap-vue](https://bootstrap-vue.js.org/)
If you _already_ have pub/sub infrastructure in place it doesn't add much to complexity to use it. Which, like I said, depending on the scale you're operating at you can take difference approaches to this issue. It may not make sense to roll out pub/sub for a configuration management solution.
I've worked on some pretty large systems (Yelp most recently), and I've yet to see the first one where using a key-&gt;value store for users sessions is a scalability problem.
Fixed it.
Have you learned/used React? Do you really think that React can just be replaced with template literal strings? What 3-4 technologies are you referencing? 
&gt; replicated with modern JS/CSS You're not going to find any organizations building large enterprise web apps without some framework. If you do, we probably have different definitions of what constitutes "large enterprise web apps."
You aren't missing much. There are two things that are used to mitigate this. One is limiting the validity of tokens with timestamps placed inside the JWT signed payload. They can use them, but only for a 5 minute window, then they have to get a fresh token. Some systems will push this time window down even more, and/or make it mandatory to refresh the token often. The other thing is that only the backend can create the tokens, because it has a secret key that the frontend clients don't get to see. So a hijacker can reuse existing tokens, but can't create them at will. If you're asking whether the backend can differentiate between the official client app and a 100% compliant hijacker, the answer is no. It's a classic problem with backend APIs, you can never rely that requests are coming from the official client.
Of course, hence "unless your job requires it". Frameworks are definitely the way to go when you have a bunch of devs working together on something big. But why is React the one that "won"? Why something that so radically deviates in terms of syntax from the core tech you are using?
[SpeakJS is pretty good!](https://discordapp.com/channels/239433591950540801/)
Right but linked lists don't formally exist in JS so the point is mute. It's purely conceptual in JS ES5
Right but there is no linked list in JS ES5
okay updated. still working on changes but this is what I got so far now - https://pastebin.com/raw/nk1hsFyn
I'm not so sure that React "won". Angular is probably close to the same business usage and Vue is rapidly approaching. I also don't see radical deviations. Sure, there are structural differences, but it's still JavaScript, HTML, and CSS.. I'm not sure why you're intimating that frameworks are team-friendly.. The two are disconnected. We use Vue for our business and it's faster-to-build, simpler, and more feature-rich than using no framework. My personal opinion is that frameworks are better for business as well as many personal use cases. I think you have a good question, but it seems as though there are still some missing pieces for you to learn about. Hopefully our comments can help you out with that. 
Oh, good call, my bad. 
How are you learning 3-4 technologies to use 1 technology? If all your apps can be built with template literal strings then fair enough don't use a modern framework but they can't be very complicated apps.
vue++
Good luck!
At first glance, I can see why one might think React is over-hyped, if all you consider is small little components that don't change. I think the part you're missing is how React handles state. Imagine you have some data from an API, maybe it's a list of things, and that list is going to grow and shrink during it's lifetime on the page. Without React, the approach is likely to involve nuking parts of the DOM and rewriting it with new elements regardless of if there's new data or not. Maybe you get smart and write something that checks the length of the data to see if it actually changed, but you're still manually keeping the DOM in sync with your new data. The idea behind React is that you write your markup once, and every time your data changes, it automatically keeps the DOM in sync with your new data. That's really the entire point of React, keeping the DOM in sync with your state. The component based API and mixing JS with XML literals are just side effects of how it solves the problem, they're not really the selling points of React.
Please don't rely on that article. The author is making a mess of mixing up concepts like storage, session, cookies etc., sometimes using them interchangeably, sometimes artificially differentiating them to suit their point. Almost every statement in there is of dubious value. Just don't.
If the JWT is manually changed, the signature will be invalid without the private key and the API will not allow it. The private key is held by the issuing API.
&gt; If someone copies your token they will have access in any system. And this is why JWT should have a relatively short lifetime (15 minutes or so).
I'm assuming that the engineering teams at Facebook are more talented than me. Main advantages of React are: real-time re-renders when state changes, and incredible performance due to using a virtual dom rather than modifying the actual dom. I wouldn't know where to start building either of those myself. 
[Chartist](https://gionkunz.github.io/chartist-js/)
I like to destructure with default values wherever applicable.
Fuck that, we need to battle this out with mud wrestling...
https://www.chartjs.org/
It does feel like react has "won" at the moment, but winning is a ridiculously transient thing in the javascript ecosystem 
That answer to your question is that, for even a small to medium size webapp, frameworks end up being less troublesome than no framework. 
When you write `Promise { &lt;pending&gt; }` that is not the return value of the callback function inside the `then`\-call. It is the promise that has not resolved yet. Have you read up on how javascript works when it is asynchronous? There is a [great article about promises on Google Developers Blog](https://developers.google.com/web/fundamentals/primers/promises) and [MDN's page about async functions explain await/async](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).
I think you mean "moot". And it isnt. JS doesnt have a stack or a queue either. They are data structures you implement. Them not being in the standard lib doesnt matter. eg: You can easily make linked lists in C if you wanted despite them not being part of the language spec. That does not make them less valid linked lists.
JS doesnt have a stack or a queue either. They are data structures you implement. Them not being in the standard lib doesnt matter. eg: You can easily make linked lists in C if you wanted despite them not being part of the language spec. That does not make them less valid linked lists. I think you might still have some learning to do about the what and why of linked lists.
Sorta but origin is also super easy to fake.
another day another unneeded framework comparison blog post
Sparkline or spark.js, I can’t recall which is which but it’s easy to use and well configurable.
...posted by the author of said post.
Not a fan of sessions for the reasons you mention but JWT isn't a "more elegant solution [than sessions]" because it doesn't replace them. Either you store enough data in a JWT to _replace_ the need for sessions, which means you're going to have to trust the client a little more (JWT has been successfully attacked in the past) or you don't put session data in the JWT so you're going to need to fetch it anyway (you effectively have a session at that point). Also, people have different things in mind when they think of sessions which can make these discussions extra difficult, heh.
That was one that I thought might be acceptable. The line graphs can easily be styled into area graphs.
Not just that but no one should want any one framework to "win". Competition breeds innovation and monopolies breed stagnation. It's far better to have multiple choices that all have enough market share that the others don't sit on their laurels thinking they "won" and therefore can just stop improving.
Are you sure about the name? I can't find a reference to spark.js, and sparkline is a type of chart. When I google that, all that comes up is how to make it in other libraries.
I thought the whole point of JWT is that you don't have to store a session on the server. If you have to keep track of/invalidate JWT tokens, doesn't that mean you're just creating a more complicated session store than storing a session id in a cookie? None of this make sense.
My apologies. This is what I meant to say. Of course I know what recursion is.
This doesn't add anything to security tbh, there are many ways to fake your origin, you can do it easily with postman. Also origin is generally going to be the main app's domain anyway so I'm not sure what's the point
"I believe unless you're unemployed, and just need income: Yes. "What does it say about the company if they are asking you irrelevant questions?" I'm not sure but they're all like this
Yes you can use an access token to do arbitrary requests from outside the app, but that it's the same for any kind of authentication. You can do the same for sessions, you just need to copy the cookies involved. Not sure if you are concerned about exploiting the app or stealing access. If the backend is competetent there should be no real way to exploit it, as for stealing access (getting someone else's token), it's is possible because it is stored in the client side, but the access should have a short lifetime.
Thing is, for this blacklist, you need a database. If you need a database to check, you are doing the same as session does. Not saying you are wrong, but when you need to invalidate a token, JWTs are no better than a session based authentication.
There's one big difference between a database of sessions and a database of blacklisted tokens: Size. If you have 1000 users online at any given moment, then you have 1000 entries in your table of active sessions. In contrast to that, if you haven't had a token compromised recently, then your blacklist table has 0 entries in it, as long as it's properly managed. The only tokens it makes sense to keep in your blacklist are unexpired ones. After they expire, they can be removed from the blacklist automatically. And if you have 1000 compromised tokens... you've got bigger problems than token management.
Awesome. Have you tried to use Physics equations to make the bounce more realistic?
OP, I'm looking forward to your next article about the wetness of water
What JWT tokens give you in this context is the ability to send the client some information which they cannot alter, which they can use in future requests for authentication. As a high level example, you may have an login method that works like this (in pseudocode): function login(email, password) { userData = database.getUserOrFail(email, password) loginData = { id: userData.id, expiry: currentTime + 15 minutes, roles = userData.roles } return signedToken(loginData) } The client gets the token. They can access the id, expiry and roles, but cannot alter them, as it is signed by the server. Then the user may want to edit a product, which requires the admin role. It could work like this: function editProduct(productId, productData, loginDataToken) { if (not tokenIsSignedCorrectly(loginDataToken)) fail if (loginDataToken.expiry is before currentTime) fail if (not loginDataToken.roles.contains("Admin") fail Database.editProduct(productId, productData) } Note that: 1. If the user doesn't have the admin role, absolute 0 server state needs to be queried to determine that. 2. Only one database query is required if the user is an admin. 3. There is no centralized session state, it is all stored client side. 
This is one reason it's good to give JWT's a very short lifespan. Or, include a per-user nonce (stored in the backend) in the token so that you can rotate the nonce if the user is compromised, invalidating all tokens issued with that nonce. Checking a user nonce is still a call to a persistent store, but can be quite lightweight. Or use a combination of the two: accept a JWT for a certain (short period) of time without revalidating the nonce, then if it's too old, revalidate the nonce, accept the token, and issue a new token on the response as well.
uh i'd love to, but seeing as I haven't taken physics yet it would be great if you just pointed me in the right direction.
You're redistributing content... so yes each proxied source should have licensed (be it open or not) that content to you. However, i can't think of any meaningful usage or RSS without an implicit consent of allowing redistribution of that RSS content. I suppose there is no legal background on this... is it ?
You are right, this is an advantage. A very small advantage tho, a table of 1000 is a pretty quick select anyway, the main point is that you are accessing a database in both. 
I was thinking about some legal background because if you're talking about licensed distribution, maybe there could be a problem. Although, RSS feeds from media companies are free to be accessed by anyone, there's my confusion.
You don't keep track of a growing list of which JWT's are valid or not on the server. JWT's have an explicit expiration time encoded. When you make a request, the API checks whether the JWT is valid or not based off the expiration. If it's valid, the request goes through. If it's not, a 401 error comes back. One thing you will need to keep track of though is a list of refresh tokens. These are usually just GUID's with a 2 hour or 10-20 day expiration (depends if the "remember me" is selected at login). You're probably thinking, well this is retarded.. lol. However, these refresh tokens can also track which devices are logged into the app. I'm sure you've seen some websites that say "a computer in Denver, CO has signed into your account. A phone in Denver, CO has signed into your account. Click here to revoke access to each device." Well, those are valid refresh tokens (in the db at least) on those devices. Here's a standard JWT flow (that made most sense to me) with standard JS apps (let's use a react app, for example): * When a user logs into the app, a JWT with a 15 minute expiration and a Refresh Token with a 2 hour expiration are sent back from the API backend to the React app. * When a request is made while the user is logged in, the JWT is attached to the request header. The API looks at the JWT, determines if its valid, and then processes the request. * If the JWT expiration time has passed, the API returns a 401 (unauthorized). When this happens, the refresh token is then sent to the API for new JWT. If the refresh token is valid, a new JWT is reissued, along with a new refresh token. The existing refresh token is then invalidated in the db (I usually just delete it because it holds no value). * What I usually do is check the token validity in the client app before a request is sent. If the JWT is invalid or has less than 5 minutes of validity left, I'll send the refresh token first and get back a valid JWT to be sent with the request (because 401 errors will show up in the console in the browser). So what if the tokens get compromised? Well, whoever hacked the token has 15 minutes to do what they want to do or maybe they stole an expired JWT - which does nothing. If they happen to get a hold of a refresh token, yes, they can create more JWT's, but the user can just log in and revoke access to particular devices. Now is this better than cookies? Honestly, I'm not sure. I think it's just another way of doing things and personally think it's overhyped just like most things are in JS. It's maybe just a little bit more secure than cookies. With cookies you have to deal with XSRF attacks. And with JWT's you have to deal with XSS. However, Angular 2+, gives out of the box XSS protection, but React and Vue do not (to my knowledge at least). JWT's do have some advantages though - such as you can pick and choose which requests use them (cookies are sent on every single request). JWT's can also be used for multiple apps/domains, while cookies are domain specific. Hope this helps.
Sure thing, mate. It's simple Classical Dynamics and conservation of momentum. I'd be happy to contribute if you uploaded it on GitHub or in any open source repo. It looks really amazing as it is! Well done!
&gt; However, i can't think of any meaningful usage of RSS without an implicit consent that allows its redistribution. What do you mean? RSS feeds are intended to be consumed and aggregated at the end point by a client application. There is no redistribution required in order for that to work, and certainly no permission to redistribute is implied. 
Oh, I know it's not a huge benefit, but it is present, and it means that even if there is something a bit session-ish about that setup, it's still got a bit of an advantage over actual sessions.
There's nothing inherently illegal about circumventing CORS, but if you are redistributing content as kapouer said, you need to have explicit permission. If you're not redistributing, meaning your reader runs client side either as a browser plugin or client side web-app in something like Angular, then you're fine. 
Thanks, I needed this two months ago! No way I'm gonna switch now!
Talking about that, I'm not thinking on redistribution, just want to link users with the media news website. I'm planning to develop this RSS reader using PWA, redirecting each link to their website. Thanks for the response.
That's the point of the article, that it _isn't_ syntactic sugar and actually has a computation and memory penalty for using it.
It sounds like it's *your* CORS headers wherever you're hosting the app that are the problem, actually. 1. User loads **webapp** from **mydomain**. 2. Webapp from site **mydomain** loads a resource **R** from site **otherdomain**. It is the CORS header from **mydomain** that tells the browser if scripts are allowed to load external resources from other sites. In your case, it sounds like the remote resource **R** on site **otherdomain** is the RSS feed. However, it's the CORS headers on site **mydomain** that dictate what the scripts in **webapp** can do. The CORS/same-origin headers from **otherdomain** aren't consulted. 
The one with all the bold in it basically says this but boiling it: CORS Anywhere is just a simple forwarding proxy you run locally to rewrite headers as they come back. It’s very much a personal run on your own box/container solution to hack around API restrictions, not something you integrate into a service. For a web-based reader, you’re serving, you are the forwarder so you do this. It’s your job to fetch the content on the back end (only browsers are bound by CORS, not Node/libcurl/etc) then pass it to the browser with proper CORS headers for your server. 
Are you sure about that? That's not what I understood about all of this situation. What I have been reading is that the other domain XML file must have the "Access-Control-Allow-Origin" open to everyone ("*") or to certain domains.
Thanks for the response! By the way, do you recommend this approach or there are another or, possibly, better solutions for this?
I don’t want to comment on the legality of taking an RSS feed and redistributing it. I have no idea tbh. If you were rendering the reader view on the back end and pushing a static render, or sufficiently transforming the content stream for dynamic render on the front end, that might be different (and better) than simply echoing an Atom or RSS feed but I honestly couldn’t say for sure. Technically speaking, what I said (and what you want) is pretty much how any API server works, so would be the path you’d take. 
I understand that. But he’s comparing passing an object vs two scalars which are not equivalent. I’m saying destructuring is just syntactic sugar on top of the former and not relevant to the performance comparison.
Well, you learn something every day. I'd never encountered this before, but you're right. You need to either proxy those requests through a 3rd party service (or your own), or do what you're already doing via CORS Anywhere.
You should fetch and treat RSS feeds on server side. IMHO, beside CORS problems, fetching external RSS data on client side, in real time, can lead to all sorts of performance and inconsistency problems. RSS wasn’t designed for such usage.
I'm a rookie web developer. If you have some links or more information about it, it would be so valuable for me! &lt;3
Very well written. Thanks for that! What's your opinion on 'sliding sessions' and token blacklisting via ID stored in JWT and on user model?
JavaScript isn’t that efficient for real-time XML parsing. IMHO, your reader should have a backend to deal with login/settings/subscriptions and to fetch content. This backend would fetch, treat and store content in a proper database. This backend would also provide an API which your web app would consume. Your API would return preprocessed, optimized content in a browser-ready format like JSON. That’s how Feedly has been doing it, for example.
To start, JWT's would never have a sliding session because of the way they're designed/encoded. For refresh tokens, I don't like sliding sessions because if a hacker steals a refresh token, this could go unnoticed by the user, as the user and hacker would both be able to use the same refresh token to create JWT's. In my example above, if a hacker steals a refresh token, the user would be kicked out of the app when they try to access it. And the hacker would then be kicked out when the user successfully logs back in because each refresh token represents a device. For blacklisting, are you talking about blacklisting devices or specific tokens?
I'll be adding a lot more code so I don't think I can recycle some of the functions just yet. this is my current progress - https://pastebin.com/raw/bCkxP91V thanks for your input!!!! this is going to be a cloud storage service. I'd prefer to avoid using frameworks for this project... maybe on the next one..
&gt; Choosing the “next” thing, and not the “current.” &gt; Being more unique; leading the herd and not following it. &gt; Better promotes Full-Stack culture; allows cross-product development. Does anyone has any idea what these mean?
On a website running WordPress?! Oh, the fucking irony!
And thus you have made my point that this question doesn't belong on JS interviews
So thats where all the missing brackets in my Python code go
Thanks for the reply! I see what you are saying. What is confusing to me is the refresh tokens (in a web app). Are you saying that you only use them once per device or per request? I am just confused how you would track if 2 people were using the same token? When the token expires, you get a new one with the refresh token. When the refresh token expires, even if you are actively making requests, would they be force logged out and have to log back in every &lt;$expTime&gt;hrs? Wouldn't issuing a new refresh token extend the time period similar to a sliding session? &gt; For blacklisting, are you talking about blacklisting devices or specific tokens? I was talking blacklisting used a specific token ID that's stored on the JWT id claim and on the user model in the DB and then just blacklisting that ID if compromised and set a new id on the user?
There are some deeper problems with ASI in JavaScript that prevent the language evolving significantly without breaking features. This is a biggie. Article is a little naive in this respect.
&gt; another day another unneeded Medium blog post FTFY
Think of this way. When user logs in, they get 2 tokens. JWT and Refresh (usually stored in local storage). * Can only make requests with JWT * Refresh token has 1 purpose: renew JWT * JWT lives for 15 minutes. * Refresh lives for 2 hours * When that 15 minutes is done, refresh token is sent to API for new JWT. * When the refresh token is used to create a new JWT, that refresh token is deactivated (I drop them from the db) and a new refresh token is created. * Both tokens (new JWT and new Refresh) are sent back to the client app (same as initial login). * Refresh token will never expire when there are active JWT's because every new refresh token will have a new 2 hour expiration vs 15 minute JWT expiration. * The idea for a 2 hour (or 15 day if "remember me" is checked) refresh token expiration is if a user logs into the app and then leaves for a 1 hour lunch break, they can come back and not have to log back in again (when they go to the app, it checks if there's a valid refresh token on initial load - if valid refresh token, the client app sends it to the api to get a new JWT). * Another thing to consider is that if a user upgrades their account from basic to premium (opens up features in the app), the JWT account type claim would need to be updated. When this happens, you use the refresh token for an updated JWT to reflect account claim changes For blacklisting, you wouldn't need to do any of that because JWT's are worthless once they expire. If an account is compromised, the user would automatically kick out a hacker when they sign in because the new refresh token would invalidate the hacker's refresh token - this is especially easy if you only allow 1 device per user to access the app. If you want multiple devices to be able to log in per user at the same time, then each refresh token would represent a device. If I stole your laptop refresh token, I'd be kicked out when you went to the app on your laptop (you'd be forced to log back in because I used your refresh token to create a new JWT). Another thing you can do is check for anomalies. Say you live in Denver, CO and I still your laptop Refresh Token. If I'm in San Diego, the app can say "hey, wait a minute... this refresh token is for a device in Denver... make the user log back in manually!"
I don’t think the author has run very many projects, or he’s just jaded. Your proposal includes costs for all the things that you can control and SHOULD KNOW how to estimate. The rest is either mistakes on your part (which you eat) or changes requested by the client (which you charge them for).
that would be amazing also time to spend an hour being confused [https://github.com/pointfour/bounce](https://github.com/pointfour/bounce)
Since you aren't doing any 3D rotations, the simplest way would probably be to render your images on a canvas. Since every individual part will always have the same shape and the same position, you can toggle then on the fly with ease, while having the result looking seamless and complete.
Care to add safari support?
This helps clarify things a lot actually. I was always confused how the flow worked with the reset token. One last thing; Do you store the refresh token and refresh token expiration on the User model?
If you go this route, instead of a nonce you could use a timestamp. Since JWTs (can) have an "issued at" claim, you consider any JWT issued before the timestamp as invalid. So to invalidate all currently issued tokens you would just set it to "now".
I would be interested in looking into it, do you know if you need macOS to develop safari extensions? I run ubuntu so it might be a bit tricky if that's the case.
I believe you can make simple extensions such as this one that don't need to access the browser API. I think it's called something like "safari extension builder"
The refresh token would have it's on table in the db. In the table, you'd have fields such as Token Id (which is a guid), Expiration, User Id, Device, Device Location, etc. When you send the token to the client, you can include the expiration data there too, you'd just make the user log in before a 401 error would be sent back. If you are familiar with c#, here's a sandbox solution I came up with: https://www.reddit.com/r/dotnet/comments/8gf30i/is_it_ok_to_store_user_id_as_name_identifier_in/dyb975g/
I mean, technically there's one reliable way that doesn't require hitting a data store... changing the secret. That will log out everybody of course, so at least you have it as an emergency backup/last resort.
I see that they are not colliding and going through each other
[documentation](https://developer.apple.com/library/archive/documentation/Tools/Conceptual/SafariExtensionGuide/Introduction/Introduction.html). I could take care of the developer account. 
You got to read their terms and conditions but generally speaking if they are offering an RSS feed they don’t give a damn how you grab it.
Hey I'm a network guy going to web development...can we trade past experience on our resumes?
Oh sweet thanks, I’ll hit you up when I start looking into it.
eCharts is amazing. Has both canvas and SVG options. https://ecomfe.github.io/echarts-examples/public/index.html
Thank you , will try it and let you know
I think this is it https://github.com/fnando/sparkline
Ah okay, fair, I see your point. You're saying that the object creation is what is the overhead not necessarily the destructuring? It would be interesting to see if that has a difference.
React is a tool that has a specific use. It is not for static websites, or websites with little interactivity. It is for highly interactive websites that has to behave like apps. Here is why react is great for that 1- it allows creation of extremely complicated websites that executes fast and components that work independently. Such as the Facebook main page where every post manages itself. And can change without changing the entire page. 2- when you use vanilla js, you write your website in multiple pages. Even with the use of templating engine, every time the user navigates to a different page a new page is downloaded. When the page hasn’t changed at all from the last time it was accessed. The browser just retrieve the page from the local cache. For a highly interactive website, that means the pages will have to be redownloaded a lot slowing the website. In React, you build your JavaScript app as an application, using the same philosophy you would with a desktop or a mobile app that only pulls the data as needed from the backend. That means the user will download you react build once, which can be quite large. But then every time after that the app will pull only what it needs from the server. This point isn’t unique to react, and can be done vanilla Js but react makes it either to construct 3- React uses a virtual DOM, meaning it doesn’t change the page, it shows you a fake page built by react. I don’t know the details of it but the fake DOM executes faster that vanilla js manipulating the real DOM. It has something to do with how there is two engines in each browser one for DOM and one for JS. Interacting between them is slower than something executing entirely in one engine. 4- React is difficult because it uses JS features that are advanced, like ES6, JSX etc. if you want to do advanced JS, you will have to learn all that once you learn all that you practically know 90% of react and then you can also use node comfortably 5- react-native is a huge deal. It allows you to create apps for IOS, Android, desktop etc using the same structure and syntax used for the web. So one developer can learn react for the web and then go on to write mobile apps, desktop apps and backends without having to learn any other language
For some reason I find this unsettling. Neat project though
Hi /u/scaredibis, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
I've been developing software for 15 years. Trying to predict any costs associated with a software project is an attempt at divination. I've seen a lot of approaches over the years, including the attempts and approaches listed in the article. I've seen those approaches come close to an estimate, and I've seen them be wildly off base. Here is the reality, you absolutely can not predict how much it will cost to build software. It just can't be done. You can fool yourself into thinking it can, and maybe you've had success with a method or two, but at some point that selection bias is going to rear it's ugly head and fuck you. Here's the best thing you can do on a limited budget. Set a budget for the entire project on what you're willing to spend. Then start building. Every week prioritize what you want done against how much left you have to spend, then build based on those priorities. Repeat this process until you run out of money. If you need more money, then go raise funds. Otherwise start selling the crap out of what you built. If noone is willing to buy, cry yourself to sleep or go raise funds. Otherwise, take that revenue and re-invest it in the software using the method above. Can we please stop lying to ourselves about this? Please? Pretty please with a cherry on top?
https://github.com/axios/axios
I don't like facebook's disregard for privacy. Nothing to do with the code, but good point regarding angularJS market loss. 
They ran away with the static types 
&gt;After months of experience, many tutorials, reading lots of documents and experimenting on production. Hey sorry you feel that way. We recognize this was one of the hardest migrations to make so if you had to update and the process was shitty, its on us, and we've promised to improve on that. If I could ask, please provide some feedback we can take back and run with. Although we were all (except maybe Sokra really) UX / Web Devs before maintaining webpack, we still are all guilty of losing touch from time to time. Feel free to reach out via twitter, or email too. ( you can find on my GitHub). 
[https://vega.github.io/vega-lite/](https://vega.github.io/vega-lite/)
I thought it might be beneficial for you to see an example of this done in such a way. [Here you go](https://codepen.io/timhuff/pen/pKqBpL?editors=0010)
I thought it might be beneficial (both in learning programming and physics) for you to see an example of this done in such a way. [Here you go](https://codepen.io/timhuff/pen/pKqBpL?editors=0010)
material sucks. don't use it.
When cat has nothing to do he is licking his balls
How come?
its worse than bootstrap. i mean if you're a backend engineer and don't want to hire a designer, go ahead and use it I guess.
Wait, Echarts can do svg? We thought it was canvas only so we rejected it. We might have a winner. I'll take a look monday and let them know.
programming sucks. don't use it.
material is bootstrap by google. fuck that.
No I was born fluent in es2018
So bootstrap also 'sucks'? What lib/frameworks would you use for frontend development instead? 
I would use this as a Screensaver
I have little time so I'll be brief, others will hopefully flesh out the answer. I think there are three topics that are relevant here: 1. Algorithm complexity (which is a general CS topic) 2. Garbage collection (which applies to all languages with managed memory) 3. Profiling ### 1 Algorithm complexity: Given a collection of N elements, you must avoid if possible functions that go over them `N ^ 2` times or `exp(N)` times (noted `O(N ^ 2)` and `O(exp(N))`. Data structure and algorithm complexity is a broad CS topic, you'll get more helpful answers if you can identify problematic code (either by reviewing it, or by profiling, see (3). ### 2 Garbage Collection Every once in a while the JS runtime reclaims the memory used by objects that are no longer referenced by any live code. This takes time and introduces pauses that can be catastrophic while processing live audio. You must avoid allocating temporary objects and arrays as much as possible. Pre-allocate at the start of your program, and work within those pre-allocated arrays and objects. ### 3 Profiling In order to indentify the bottlenecks in your program, you'll have to learn to use the profiling tools provided by the browsers.
Have you considered d3-ez (it’s free!): https://github.com/jamesleesaunders/d3-ez https://www.npmjs.com/package/d3-ez d3-ez is a library of reusable charts which use D3.js. Inspired by Mike Bostock's tutorial Towards Reusable Charts, the aim of the library is to harness the power of D3, whilst simplifying the process of creating charts and graph making with D3. d3-ez makes it easier for people who are still learning JavaScript or D3 to quickly produce data visualisations with minimal code.
jQuery UI
Stop marketing bad software. I have enough experience to say this now. Docs are still old. Good luck at ms.
I think about Javascript at day and dreamt about me writing Javascript code everynight
Study? No. I’m a mostly Go dev with about 10 years experience programming (mostly PHP and JS before Go). While JS has changed and all that, I’m confident enough to read the basic docs of something and start out, and Google/SO what I don’t get immediately or when I run into trouble. That being said, recently I spent about 5 hours reading the Vue docs and trying shit out in Codepen when we decided to prototype our new UI with it. So to answer your question, I don’t spend time studying per day. I’m a senior dev and paid to work and value my free time. However if I have to learn something new I will dive deep and take as long as I need to get a basic understanding of it, at least enough to become productive. I do bill for this time and am upfront about it. I’ve had some serious imposter syndrome in the past, but got over it enough to know what I do know and admit what I don’t. 
I really don't like python, it is ugly, and I miss the semicolons at the end of a line
Is it me, or do you want to add an in click to the page to bounce them up?
JavaScript is a bit like Ninjitsu, "studying" it isn't going to help you one bit in writing apps, but practising it is surely going to work wonders. There was a time when I used to watch a ton of videos and read several articles on things like AJAX, promises, callbacks, constructor patterns, etc. but felt like I wasn't going anywhere. These days, I don't do any of that, just concentrate on my next web project. If at all I do any reading, then its only in the context of that project and specific to some problem for which I need a solution. This way, I've reduced the "study hours" to a manageable level and yet gain a lot from that.
That "//" is for mark as a comment....
I actually mean explain what "i PROMISE never to CALLBACK" entails
UnhandledPromiseRejectionWarning
I average 1.5 -2 hours then code other projects to make sure I'm writing and refactoring JS code often.
Exactly. Default values and handle the null case. It's no different than what we've been doing with non destructured arguments for years. 
Technically yes, you are using promises correctly. But I see a problem: If one update fails for some reason, technically all your update should be reverted. Maybe a user is trying to update his email and password, the update on the password went has planned but the email got some error for x reason. Next time the user try to login, he wouldn’t be able to do so. And even if you catch the error, what are you going to do? Display an error message to the user “Sorry your email couldn’t be changed, try again but without password” You can solve this using transactions from Sequelize, if an error in one query happend, it reverts all. Also has an implementation for making updates cleaner. If you need snippets or examples I would love to help. 
I have nightmares regarding unhandled promise rejections 
Change them to normal brackets and make fun of people who use lisp... /s
For what it's worth, it was mentioned in the Adobe forums that they plan to work on it for the next 10 years at least, IIRC. And as an AS3 developer, I'm kinda salty about how things played out, because it was a damn good cross between JS and Java. Whenever I use an application and it lags on my computer - a fairly low end budget laptop fwiw - I search and find out it's made in Electron. Not to stereotype, but yeah, its performance is trash, at least on low end computers. AIR for the most part, well I don't even _know_ whether an application is made in AIR or not unless I specifically check, because it presents no problems whatsoever.
I can't think of any possible counter-argument here.
Zero, but spent 2/3 of time to code es6.
Well, this is a "portfolio project", you see, so I'm not using any frameworks (and boy, has the learning been awesome). BUT: I didn't know about issues like this at all, thanks for bringing it to my notice :) &lt;3 I'll see if I can figure it out on my own.
To cleanup the code you should use async/await. For example await the open() to db variable so you dont have to write everything inside that function. For the columns foreach, separate that update into its own function and then you can use: const updateres = await Promise.all(columns.map(updateUser)); When using async/await you will use try/catch to catch any errors.
[You are absolutely right](https://codepen.io/timhuff/pen/pKqBpL?editors=0010)
Got it, it'll be something I'll do, certainly. I'm already working on a separate version of this that uses async/await, so I'll save this for reference, thanks!
finaly i use this : var FilterID = data.filter(function(id_prov) { return id_prov.id_provinsi == "&lt;?php echo $get_id ; ?&gt;"; }) and now i'm looking to filter multiple data, i hope i can find it.
Well, they're empty objects so what would you expect? :p
So good 👍
I’m a full time generalist software maker working on web projects in JS. I’m often making software 100% of my time. 50% is non-code stuff like talking to / emailing people, talking about layouts on the whiteboard, helping other people with their projects, etc 20% of my time is in browser, looking up stuff and reading about stuff – libraries, best practice, how-to-X-in-React, etc. Mostly directly project related, sometimes random stuff that seems cool and/or might be useful at some point 5-10% of my time writing new code 15-20% testing and debugging it Any remaining time is dealing with annoying stuff like upgrading servers or dealing with yet another poorly thought out update to the corporate firewall rules TLDR: I spend about 20% of my time learning new stuff.
if you use React, take a look to Semiotic https://github.com/emeeks/semiotic
What a fun thing you made :)
You can provide multiple filter criteria using &amp;&amp; with another value to compare against it filter (in this case, before the semicolon)
I don't really need any of the new features to get work done. I'm always coding, building things, and "studying" is very low on my list when I'm getting shit done. Creativity and output is more important than the 'new shiny' where I'm concerned. 
HTML. Yeah, I know, it's a markup language, but at least it doesn't have those dastardly semicolons and 'weird hibberdy jibberdy arrays' to deal with! /s
im not an echarts user but the documentation tell us that we can choose canvas or svg renderer
I am currently busy, but I would love to tinker with your code for a while later. Might submit a PR :)
Tail can be used to mean "rest" in contrast with head, but in the context of the building blocks of a linked list, it is the last node (accessed in order to append new nodes in constant time rather than having to iterate over all existing nodes to reach the end - a common operation in some languages, less so in others). It is more commonly used to mean "the rest" when you are *accessing* elements of the list. In either case, the tail as a concept is never equivalent to `next`, although `next` can be the first node in the tail. 
Needs more Jquery
I did see your (now deleted) sarcastic comment. It surprises me that you don't see the value of planned deprecation, which is available in other languages. There are several ways to do it, and I'm again surprised that you seem to think it would be impossible for me to propose something that already exists.
isn't coding it "study" - I have to say it is the one language I learn something new almost every time I code with it
i don't study it. i often find myself describing parts of it to myself to make sure my model of it makes sense. e.g. describe in words the stack, the heap, and the event queue. explain in words what a closure is.
Yeah. After I saw the comment I went and looked. It does say that it's in beta, though. All their demos are canvas and it didn't occur to us that it could do both.
&gt; The scalability of stateless JWT's are rarely a factor in most applications. Most developers aren't working on Reddit, Twitter, or anything that requires that kind of scale. Don't Reddit and Twitter both use session cookies? `reddit_session` and `_twitter_sess` /u/kescusay 
I may be misinterpreting the question so someone can throw me rope here... but being modified “in place” to me just means you’re not creating a new array, or using additional space? First of all JS isn’t a static typed language so you’re not going to have arrays with memory locations calculated by memory offset. Because it’s not fixed length you don’t need to worry about it moving the entire array on a push. Instead, JS arrays are objects. So adding an element to array is akin to adding a property onto an object, where the key is the index of the element. If u declare var arr=[], you can also set the property arr[100]=“foo” now what’s the length of this arr? Check it out. If you’re looking to go deeper beyond how are JS objects are implemented, you can look at how V8 implements it with hidden classes which I find cool. Otherwise thinking of it like hash table is fine too. 
Not sure what you're asking here. Do you want an explanation of how it works internally? Or how you'd do it with JS? &gt; Is only possible with 'reference' data types like objects and arrays, or is it possible everywhere? Ignoring the fact that everything is a reference for now... Yes, you can only modify Objects in place (which includes Arrays, Functions, Dates, etc). &gt; How does one go about defining this behaviour? No clue what you mean here
All data types are reference types in JS. While under the hood this is not necessarily so, in terms of semantics, you can assume it's the case. That said, some primitives are immutable: boolean, number, string, null. Hence you can't modify them in place because you can't modify them at all. Operations always return a new item.
curl is a program, like Firefox. What you mean is HTTP request. Yes, it is possible to add custom headers to Ajax requests. https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader `setRequestHeader()`
I'm really sorry, the "computer science" words like"hash" went over my head, I'm new to the "science" in "computer science". And, whoa. Setting a[100] for an empty array *fills* it with 100 `undefined`s, wow. What I meant was, why does Array.prototype.slice *return* an array whereas Array.prototype.pop *modifies* the original. And considering arrays as objects, it makes sense. Probably, `pop` modifies the `thisValue` itself, whereas *get* methods like `slice` are methods that don't modify the `thisValue`. Huh, I guess that's why they call it 'impure function' and 'pure function', eh? Anyway, thanks!
Sorry, it was badly worded on my part. Refer to my answer above, can you please correct me if I'm wrong? Thanks!
I understand now, when you consider everything as a manifestation of Object, it all makes sense. Thanks for the input!
I understand what you mean, and yeah, everything is a reference type. But just know that numbers, bools and strings are not objects. There are object wrappers to them (which no one uses and why they exist is a mystery), but you don't use them in your code when you assign a literal number/bool/string to a variable. This is all a historical oddity in JS. Ideally they'd all be Object. They kind of work this way for the most part. But they're not.
&gt; Setting a[100] for an empty array fills it with 100 undefineds, wow. No it doesn't, it just sets `length: 100`, the rest is just how chrome or whatever displays it &gt; why does Array.prototype.slice return an array whereas Array.prototype.pop modifies the original. Because there are mutating and non-mutating methods. There was a reference on here or /r/learnjavascript recently but I can't find it in my 10 seconds of searching. &gt; I guess that's why they call it 'impure function' and 'pure function', eh? Different concept, all array methods are impure as they depend on the array and the mutating methods produce side-effects.
Here's a sneak peek of /r/learnjavascript using the [top posts](https://np.reddit.com/r/learnjavascript/top/?sort=top&amp;t=year) of the year! \#1: [If you're looking to learn javascript, a professor at my college made a really cool free to use online textbooks that includes: exercises, clickable links, and lots of example files.](http://profsamscott.com/javascript/) | [4 comments](https://np.reddit.com/r/learnjavascript/comments/7xd7x0/if_youre_looking_to_learn_javascript_a_professor/) \#2: [To everyone currently enrolled at a college: don't forget to get your Github student developer pack. It contains a free domain name, digital ocean credit and much more.](https://education.github.com/pack) | [13 comments](https://np.reddit.com/r/learnjavascript/comments/8b81be/to_everyone_currently_enrolled_at_a_college_dont/) \#3: [Algorithms and data structures implemented on JavaScript with explanations, examples and links to related YouTube learning videos](https://github.com/trekhleb/javascript-algorithms) | [6 comments](https://np.reddit.com/r/learnjavascript/comments/8l09o2/algorithms_and_data_structures_implemented_on/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
once i come back home ill give your code a look
Thanks a lot! :)
&gt;No it doesn't, it just sets `length: 101`, the rest is just how chrome or whatever you're using displays it Indeed? I see, so that means length is computed as last index plus one? I didn't know this, thanks &gt;all array methods are impure Huh, I read a post on medium saying that slice is pure, because it doesn't do modifications 'in place', so no side-effects.... So thanks for the clarification?
That is one possibility to solve your problem. I would rather use the $get_id value as criteria for a database query to fetch only relevant data directly. Simply use your $get_id as where clause in the id_provsini column and that should do the problem
Yeah, that's something to be careful of when coming from a non-JS background, Strings are also primitive data types here. &gt;Ideally they'd all be Object I assume you mean the 'type: [Number]', etc. vs the `var a = new Number (42)`? Yeah, but aren't the object wrappers useful because of stuff like `Number.isNaN`?
This reminds me of Dwitter - https://www.dwitter.net/
 componentWillReceiveProps()
I’m currently on my iPhone but for sure I will check t out. Really happy for you that you’ve made your first chrome app. Long may it continue! 
Perpetually pending 
&gt; Huh, I read a post on medium saying that slice is pure, because it doesn't do modifications 'in place', so no side-effects.... const slice = (ary, ...args) =&gt; ary.slice(...args); would be a pure function as it depends on data passed to it. It's true that `Array.prototype.slice` doesn't cause side-effects, but I'm kinda on the fence about calling it "pure" since it relies on `this`
But 101 doesn’t make sense right? That’s the point, which is to show that Js array is different from “traditional” arrays. Length of arr in JS is just a naive implementation where it’s just highest+1. 
(Hopefully this fits within the self-promotion rules?) This is a bunch of my ideas on how I would approach creating a new javascript ecosystem beyond npm. Any thoughts or feedback are very welcome :)
I finally got my head around d3.js zooming. Added to my Hans Rosling bubble chart here: https://beta.observablehq.com/@jamesleesaunders/hans-rosling-poverty-bubble-chart-with-d3-ez Pinch to zoom! Made with d3-ez https://github.com/jamesleesaunders/d3-ez
Nothing needs more jquery :(
Awesome😎
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Thank you! This is very helpful! I will be looking into these :) 
Nononono lol sorry this isn't for me This is just circumnavigating the reason we stareted using components in the first place. I like a component to "do it all" - that is, do all the things and be all things that it's *supposed* too. Separating the logic just fragments my code, now i have two places to go and maintian, and deal with. Just my 2cents :)
hot take: it's better than bootstrap
I have been wanting to create a library that handles GraphQL or JsonApi responses automatically, integrates with any state management system (Redux, MobX, React setState, Unstated, Plain JS Object so far) and uses ORM selection to use in components. Finally put the time in and got it started. https://github.com/mfpiccolo/blue-chip
I was going to say the same thing :D
Thanks Bot. It is specified in the package.json but I just pushed MIT to the repo
It does not shine when your logic is simple, but look at react virtualized for a good example. Virtual windowing, data syncing, infinite scrolling, and element autosizing are all logic only components. You do not have to use all of them at once or even in the same order. Only rendering is left out of the library and up to you.
Urgh, another package manager? Why not just take whatever new ideas are in here and add them to npm/yarn/any of the dozen others?
I suppose if your logic is really complex... but in the articles example, i wasn't feeling over whelmed yet... I guess i've just gotten used to if, if, if, else, else, else sort of programming lol. It doesn't always look the cleanest but commented nicely it's just as easy to read/understand and it's simpler, one less component in the structure of things. My one consideration for something like this would be if I was building an app wrapped with cordova or similar, like, if it needed to support 3 front ends (web, iphone, android) - maybe then this would really shine.
I think these ideas would be better off in a github issue against yarn/npm. That way you can discuss with the teams and then actually implement if there's enough support.
Neat, but impractical from a branding point of view. [Here](https://i.imgur.com/LRF9K1N.png) is the real swoosh overlaid on top of the author's version. Blue is where they match, pink is where the original differs, black is where the author's differs.
One hour a day on the train into work (netflix or a book on the way back). I generally watch videos or presentations as I'm to lazy to read docs like a proper dev.
Also, if you want to reuse that logo on multiple places I would use a class, not an id.
https://xkcd.com/927/
It's just IIFEs and statements that start with \[ that you need the leading semicolon right? I've been thinkiing of dropping them myself
If you need reusable logic, just put it into a store (redux, mobx), and then you can use your logic not only in components, but in other parts of the application as well. With the additional benefit of reactivity between components.
Java is to Javascript as Ham is to Hamster. Check out /r/learnjavascript for advice on learning it. If your goal is to "make browser games", though, you might want to check out Unity instead. 
I’m just going to start saying aloud “xkcd 927” whenever these conversations occur. 
Hey there thanks for replying! Thank you, I will check that subreddit out. I have unity and unreal installed. I thought it would be a little too deep for me to jump into such a rich framework before I can swim no?
IMO making games without a game engine is a *lot* harder than using Unity. Sure, you could probably make a simple text-only game with a few buttons, such as an incremental game, but even that would still probably be easier in Unity. In addition, you'll find *tons* of tutorials on making games in Unity, and not nearly so many in Javascript/HTML/CSS. And the ones you'll find won't be as helpful as the Unity ones. And I say this as someone who does JS/HTML/CSS as their day job.
You forgot semicolons at the end of your statements. ;)
JavaScript is always evolving and has many nuances. I'm a senior JS dev and still read JS docs. How much per day is really up to me. I don't do it because I have to, most the time. I do it because it interests me, and I want to know said nuances.
Promises and callbacks are both ways of handling asynchronous programming.
Or victory charts! [https://github.com/FormidableLabs/victory-chart](https://github.com/FormidableLabs/victory-chart)
I've been building my own JavaScript framework that includes a built-in router, Redux style actions/state management, and a small bundle size (~2.5 kb gzipped). I'm building this mostly as a learning exercise, but I welcome any feedback or contributions. https://github.com/johnsylvain/kobra
Naturally
If you wanna make browser games and learn JavaScript I highly recommend PhaserJS: https://phaser.io If you still wanna learn Java doing games (with is possible to export even to browsers) I would say to you go with LibGDX: https://libgdx.badlogicgames.com Both aren't engines, but frameworks so you won't have a rich UI besides your code Editor or tools like Tiled (https://www.mapeditor.org), I've made small games in each framework they are quite realible and have a good community ecosystem (obviously nothing compared to Unity or Unreal).
Thanks for the response dude, you give a good argument dor jumping into unity. Does unity let you write in javascript or do they have their own js-like scipting language? 
Thanks for the response dude, I will defo check out phraser
I'm new to coding (to clarify my point of view), so when I'm not learning during the day I don't typically study at night. I find letting my brain get a bit of rest has been helpful, but I do study a few hours on Saturday's and sometimes Sunday's to buy I do it early like 7am-10am so I can enjoy the rest of my day and as others have said I definitely value my time away from work. 
Palantir is not Cambridge Analytica. Peter third owns palantir (or in part). The Mercers own CA, now called something else.
Oh boy! Can't wait for all the politically motivated unlinted code. o_O
I meant to put something along the lines of (of CA infamy), but unable to edit titles.
I was thinking more about their data collection, selling, etc. and how we as devs usually blindly trust packages
I've been working on self-designing web pages. With every refresh it create a new design. The small button on the bottom right also refresh the design instantly. Built with react and mobx. http://launchero.co 
😂
Basically any line that starts with `([\``. Use the eslint rule `no-unexpected-multiline` and you should be fine.
Erm... arrays start at 0 in most languages
I'm not sure that makes sense either tbh, true they are a data company, true they are probably up to stuff we wouldn't like. But data issues around privacy aren't contained to just these two companies. 
Been looking for a good JS game framework myself, excited to check out Phaser. 
I've been working on a Pong clone using [PixiJS](http://www.pixijs.com) but mostly because it's used at work so I don't have much of a comparison to other frameworks or Unity. I can tell you it's very easy to get started with for simple 2D browser games.
Congrats and welcome to the ranks of Chrome Web Store devs! You got a pull request! ;)
Thank you! Will check that out
It's because Hamsters love to eat Ham. Javascript loves to incorporate Java!
I did need to learn React for my job, but I'd wanted to learn it before that point (I was too comfortable in Angular to find a reason to switch). I'm going to assume you're talking about the ecosphere associated with React. Webpack and Babel aren't something you need to learn for the most part unless you have specific requirements (the default values are good enough for many projects but sometimes you need to tweak them). This is what stopped me learning it much earlier - the transpile flow of React wasn't explained well, and create-react-app wasn't around (or at least it wasn't well promoted). State management libraries can throw people off. I know that I'm still not a fan of Redux, opting to use MobX instead (I just find computed, action, observable and observer easier to understand and work with). JSX was initially difficult to wrap my head around, and I've written some really bad JSX when I first started working with it. It's hardly unexpected that people might struggle with it if they've come from a traditional JS background. Once I got into the habit of writing it well, I found my code is easier to understand and break down which is good for testing. The other bonus of this is that it really brings home the idea of component-based design. JSS shouldn't throw anyone off. Perhaps the biggest benefit that React has brought to me is the ability to write very similar code for the web and mobile (React and React native, respectively). There may have been platforms like Cordova that had a similar idea in the mobile space, but none seems as smooth as React Native (especially with Expo). Finally being able to lay to rest the thought that I might one day have to return to Delphi's Firemonkey framework to build a mobile app has been quite relieving.
Hi /u/FlameGrill3d, For javascript help, please visit /r/LearnJavascript. Thank you!
Everybody should use jquery, it's great because it's good and you can use it for lot's of things.
Hi /u/AcrobaticAbrocoma, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/cristi_salcescu, For javascript help, please visit /r/LearnJavascript. Thank you!
https://javascript.info
tl/dw - someone stole this dudes free content and put it on Udemy as their own content, dude blames the platform instead of the individual and doesn't want to go through the hassle of having it legally removed.
Launched an application using WebRTC and Web Audio to create a sound detector for the web. You can try it here: https://apps.paramountpictures.com/movie/aquietplace/detector/ And read about how it was developed here: https://medium.com/@leemartin/a-quiet-place-7d3e712b7cd7 Lots of tech: WebRTC, Web Audio, Paper.js, Vue, Nuxt
You missed an /s
That's looks like a cool idea. Will definitely try it out. Good luck with your extension! :)
Great idea!! 
no it isn't.
purecss.io
&gt; And considering arrays as objects, it makes sense. Probably, pop modifies the thisValue itself, whereas accessor methods like slice are methods that don't modify the thisValue. different intents in the methods. `pop` is meant to remove the last item from the array. it gives the item to you as a convenience thing. slice is meant to create a new subarray from an existing array.
there's a difference between a pure function and a function with no side effects. a pure function is one that only interacts with the arguments passed in. `Math.abs` is a pure function, because it relies on a number being passed in. `Array.slice` is not pure, because it's an OO method that operates on an object (you have to have an array instance to call `slice` on it). `Array.slice` is a method without side effects though, in that it doesn't change anything about the array it's operating on - it returns a new one.
const person = { firstName: ‘John’, lastName: ‘Doe’ }; const { firstName, lastName: aliased } = person; console.log(firstName, aliased); // John Doe Done. Your welcome. :)
I do not study. I just code. While coding skills improve by themselves with very little efforts.
Kyle Simpson
The arrogance of developers who propose creating a competing standard in a problem space where they have little experience working in never ceases to amaze. Your eagerness to improve the JavaScript community/ecosystem is great but maybe get into the npm source code and start hacking away at some problems there? Open Source doesn’t work when people just try to create new solutions over and over again to the same problems. It works by people working together to improve on already existing solutions. You say NPM is “wonderful” so why are you proposing that to community abolishes it in favor of your new tool? I think some of your ideas are amazing and could be added to npm or yarn. 
Nice work man. I was wondering if there's a way you can monetize these extensions ?
Boa would have said the same thing about python ;) But yeah, I work on js in my job and python for my thesis, and that transition is painful every day for me. Sometimes I go about my day without initializing variables, expecting it to run. 
None. Go build something. You'll learn far more far quicker than you will by following a tutorial. Set a goal and just do it. Build a calculator, build an image editor w/ canvas, build a 3d engine, build a game.
404 not found. :-( Can you post a working link please?
Pretty much never. I prefer array methods: Object.entries(items).forEach/map/filter/etc As it allows for much cleaner code
pssst we're talking about the length. 
For the purpose of exploring an idea, starting from scratch is much better than building from a complex foundation. If OP’s idea is successful, the good parts can be integrated into NPM or yarn. 
Yes, which is why 101 makes perfect sense. If you have `arr[100]` there are 101 items. Arrays work like this in the majority of languages, nothing special about JS here
I use https://regex101.com whenever I need to figure out a JavaScript regex. It can also do php, python and go regexes (be sure to select the right one). 
I really like vuetify. It's super simple to get going with. I built a little sample app while learning the basics of Vue and wanted to test out a UI library, so I used this. It feels very much like a Vue equivalent of Material-UI. I highly recommend it. 
I see... The post I read gave no distinction between the two, and hence my confusion. Thanks!
I see. But you can't break nor return...
You are probably talking about methods that mutate vs methods that don't. Checkout https://doesitmutate.xyz it has more details on which methods do and don't.
There are plenty of array methods that will do what you want and then stop, eliminating the need for breaking, and you could simply return the result of that operation.
You can return with `.map`, `.filter` but not `.forEach`. So just use `.map` instead of `.forEach` if you need to return. `break` is a little trickier - it's used to short circuit a loop. You can functionally short circuit an iteration using `.every` and `.some`, though. So, technically, you can do anything a regular for loop can do by combining these functional operators in specific ways.
Great idea! Can you give us a brief overview of how it's coded? Do you look for certain keywords/phrases/variable names on each label &amp; checkbox, or was there an easier way? Downloading it now.
link is perfectly working bro but still try [this](https://kartik1225.github.io/gradient-from-image-demo/#/) 
Are you a beginner?
So... Now we're sending stupid jokes to the sub?
filter, includes, some, etc do this depending on exactly what you’re trying to do
Never use `forEach` it’s a lot slower than a for loop and ofc carries overhead for each callback. 
And a forEach is slow... 
Heres what ive been doing https://github.com/ellisgl/epsiom
Premature optimization loses to readibility
Horrid advice. Array methods improve readability and allow for functional patterns. The odds of an array loop being your bottleneck, or even reasonably contributing to it are pretty much nil. And if it were to happen the correct solution would be to transpile it out with babel
Yeah pretty much
Thnx, but im not at that level yet.
There are a couple links in the readme that talk about file structure.
What’s wrong with a for loop? A for loop is specifically designed for iteration, while a `forEach` loop does iterate it has to invoke a callback on each iteration. A for loop doesn’t effect readability at all. As long as you’ve indented properly and spaced your code out it’s just as readable as a `forEach` 
I’m sorry I don’t get what difference in readability a for loop makes over a forEach?
I will check it out
I built a semi-working raycaster (like Wolfenstein 3D) https://raycaster--udxs.repl.co/
Would a negative while loop be even faster?
A while loop would be faster as it’s not invoking a callback on every iteration. 
An often misquoted and overquoted XKCD. As it is now.
[regexr](https://regexr.com) for regexp [css-tricks](https://css-tricks.com) kinda surprising but good all around for any type of development
Aren't they shutting down the Chrome Extensions? I thought I read about something like that, if I read correctly.
Proper css grids
No, nothing like that.
My guess is that you're either talking about Chrome apps being deprecated, or inline installation of extensions and apps being deprecated. Extensions will most likely stick around for quite a while 
See: functional programming
He also mentions how udemy's monetization system promotes shilling in every article you make.
I'm just seeing a blank page on mobile.. 
Yeah, I think I was too lol. My bad.
doesn't webpack replace destructures?
And what you pass as then or catch handlers are in fact callbacks
Fucking hell. Welcome to the future baby.
I’ll keep using a for loop thanks. 
BOUNCING B. . . oh. brackets.
[Mozilla Learn Web Development](https://developer.mozilla.org/en-US/docs/Learn) //Learn basics of web dev [javascript.info](https://javascript.info) //General resource and guide for understanding JS concepts [Regex101](https://regex101.com) // Learn the basics of Regular Expressions [Regexr](https://regexr.com) //Test Regular Expressions [CSX](https://csx.codesmith.io/home) // closures, scope, callbacks, higher order functions, async, etc. [CodeWars](https://codewars.com) //Practice, practice practice and skill up [LeetCode](https://leetcode.com) //More advanced coding challenges [NodeSchool](https://nodeschool.io/) //A bit outdated but good resource for learning web dev skills
You are not giving any argumenta for your case and not helping the conversation :/
Cool, thank you!
/u/BreakThings does make a good point, it is often best to build back into an existing platform, especially one that has so much traction like npm. Though I agree, from scratch would allow me to figure out what exactly an ideal package manager etc would look like. And for me, I feel like there are some core issues I have with npm that would be impractical (if not impossible) to solve without a clean slate.
I dread to think where we would be if we limited ourselves to just the one standard / framework / way of doing things. Programming thrives on everyone building and sharing their ideas.
I can respect that perspective. Best of luck going forward. 👍🏼
I use for-of loops when they make sense, e.g. when I need to run a list of async functions in series (rather than in parallel) for (const fn of fns) await fn(); I still prefer map/filter/etc for the cases they are designed for though 
Same here, I hardly ever use `.forEach()` anymore, just `for-of`. Benefit: consistency with, and easy migration to, async iteration and `for-await-of`.
I’d argue that `.forEach()` is much less FP than `.map()` and `.filter()`: you rely on side effects.
&gt;[/u/BreakThings](https://www.reddit.com/u/BreakThings) does make a good point, it is often best to build back into an existing platform, especially one that has so much traction like npm. In some circumstances it may be, but in many circumstances it is not practical or even possible without significant changes to the fundamental structure of the source codebase. It is certainly a point to consider, but as an offhand suggestion it is shallow and naive. &gt;Though I agree, from scratch would allow me to figure out what exactly an ideal package manager etc would look like. Precisely my point. Were you to start "hacking away" at NPM, you'd likely spend the majority of your time learning the intricacies of a system you desire to change, and fighting against the structure and code that already exists. &gt;And for me, I feel like there are some core issues I have with npm that would be impractical (if not impossible) to solve without a clean slate. This was the basis of my critique of /u/BreakThings' comment, as he seemed to be basing his suggestion off the naive and poorly conceived idea that the best path to progress must always start from "hacking away" at already existing, incredibly complicated codebases. As I said, in some cases that may be the best approach, but one should only offer that suggestion when they are grounded in an understanding of the nature of the problems that are being addressed, because in this domain there is never a single approach that is universally applicable. 
Please don't just mindlessly parrot arguments without understanding them. The readability arguments compares array methods with old for loops. for-of loops don't require an index variable and are not subject to the same criticisms as old for loops. Also nobody uses for-of loops for performance, they're not as fast as old for loops. for-of is syntatically less noisy than forEach, and there are cases where map/filter/etc don't cut it, and where for-of loops are better.
I think calling it "naive" is perhaps a bit harsh, it is just a different priority / focus. Something I saw the other day: &gt; There is no such thing as best practice, only good practices It is both good practice to hack away at existing widely used tools to improve them, and equally good practice to experiment and iterate on ideas from scratch.
It works on my phone too.. but still you can try it on desktop.. I really don't know why this is happening..
True! Actually I was wondering what was the performance of for-of in comparison of other loops. I'd run a JSperf if I'm not too lazy.
True.
Yes ofc I still use map. I think it's unavoidable.
&gt;I think calling it "naive" is perhaps a bit harsh, it is just a different priority / focus. It is an idea that is grounded in an incomplete understanding of the complexities of the problem domain, likely due to a lack of experience working on complex problems. Here is the definition of naive: &gt;having or showing a lack of experience, judgment, or information I'd say it fits perfectly. &gt;It is both good practice to hack away at existing widely used tools to improve them, and equally good practice to experiment and iterate on ideas from scratch. Yes, that is true. As I said, it depends on the nature of the problem. Best practices *do* exist within the specific constraints of a problem. The issue with the concept of a "best practice" is that many people apply them blindly to problems that are outside the constraints of the solution, because they did not take the time to learn the problem at hand. They naively applied a solution to a problem that the solution isn't intended to solve.
Faster than forEach? Yes, but faster than the classic for? Yes and no. V8 engine isn't optimized for negative while loop. [https://medium.com/kbdev/voyage-to-the-most-efficient-loop-in-nodejs-and-a-bit-js-5961d4524c2e](https://medium.com/kbdev/voyage-to-the-most-efficient-loop-in-nodejs-and-a-bit-js-5961d4524c2e)
Literally no reason to use for...of. Anything you can't do with map/filter/for Each (not that I'd ever use forEach), you _can_ do with reduce. Not sure how you think "for (thing of things)" is less "noisy" than ".map(thing =&gt;", so I'm just going to assume that you're unfamiliar with the definition of "noise." 
I’ve sat on tc39, I’m not mindlessly parroting anything
There’s nothing wrong with it, there are just patterns that are more usable. I’m primarily against your advice of “never use forEach” which is ridiculous 
Unfortunately I believe you spelled "relevant" wrong everywhere. 
What about callback hell with the forEach? I’ve never had readability issues with a for loop 
https://www.watchandcode.com it’s the best that I’ve taken and I’ve taken a lot. It doesn’t just learn you the language but how to work and think like a programmer. In the premium it learns you how to read documentations and other people’s code.
Callback hell is no longer a thing. See promises and async/await And I promise you you’ve had readability issues. Literally every dev ever has and if you don’t think you have you just haven’t realized it yet. Look back on the code you’re writing today in 10 years :)
As other have said, I primarily use `for..of` when I want to do some kind of async operation in series on an array of items. It's not that common but it does popup. Outside of that use case I primarily use `Array.map/filter/reduce/etc...` because it looks pretty readable to me, and they usually indicate right off that bat what you are trying to do. If I'm trying to filter a list of items and I see the `filter` keyword I can immediately tell what I or another developer who wrote the code is trying to do. Same for `map`, it's used for transforming a set of data in an array into another set of data. In the case of `for...of` it's not immediately noticeable what the develop who wrote the code is trying to do. Don't get me wrong there are use cases for traditional for loops as well as for of, but I find those are very few/rare. 
im sorry i took over 9 hours to reply, i was very busy... anyways give me like an hour or so to check it out if you dont mind
https://www.youtube.com/watch?v=jkTzHEtHd54&amp;list=PL41lfR-6DnOrwYi5d824q9-Y6z3JdSgQa
People say this all the time, but it makes no sense. If I am new to programming, I need to learn how the language works before I can just build something. It is like asking someone to just go to France and speak French when they do not know what a noun or a verb is. 
a forEach is too slow for me to want to use it. My code runs twice as fast using a for loop, neatly laid out and I’m having zero issues. If I were to use forEach loops in my current project, it’d be too slow to want to use it. 
Write it yourself? 
Except the issue the article is trying to solve is not that there are too many package managers, but the current ones aren't good enough. Irrelevant XKCD if you ask me.
A weird thing I do sometimes: ``` for (let [key, value] of Object.entries(someArray)) { console.log(key + ': ' + value) } ``` Takes advantage of array destructuring and Object.entries() while preserving readability and ability to return or break. 
&gt; Except the issue the article is trying to solve is not that there are too many package managers, but the current ones aren't good enough. So what you are saying is there are currently N package managers and the solution is to create a new one? seems accurate.
I use map/filter/reduce as well. I don't think anyone would use for of instead of those.
Please can you differentiate between running async functions in series and parallel? 
I'm saying the problem is "there are bad package managers", not "there are too many". The solution is to make a better one, not to make a unifying one. 
Learn me?
Agreed it's silly when someone says this you can't just "build something". When you don't know how it works or what it can even do
Lol. You keep believing this. You clearly have no interest in actually learning anything.
gonna give this a read tomorrow
You'll probably have better luck asking this in /r/MQTT/
Strange that no one's mentioned [freeCodeCamp](https://www.freecodecamp.org/).
You can learn to speak a language in 3-6 months by immersing yourself in it and using references. 10 years of school doesn’t get you as far. Programming is the same way. Start building something and find references to help you build that thing. You don’t know how to use canvas? Look *that* up. Same with dom, classes, etc. Yes, you need the very very basics, but that’s literally about an hour or two.
Which is exactly what the comic is making fun of, you think none of the existing solutions are good so you want to make a new one.
An hour? Never
Sigh, not with that attitude. I’ve taught plenty of people in an hour enough to push them to build what they wanted to build. It’s the correct way to learn.
It’s how to loop. I’ve got no issues with a for loop so have no reason to impact performance of my code using a forEach loop to satisfy the pedantry of some guy on the internet. 
What do you think about `deno`'s idea of scrapping the package manager and registry altogether and use direct URLs to import packages?
Yaakov Chaikin's stuff on coursera in the Johns Hopkins program is a good intro. His angular js class was just ranked the best course on coursera, I believe. He teaches in an easy-to-follow way, but in a rigorous way that doesn't skimp on programming language concepts. https://www.coursera.org/learn/html-css-javascript-for-web-developers/home/welcome
I don’t care if you change your code but your ignorance and stubbornness is going to your growth as a “programmer”
Egghead.io
Yeah I'd love to know how it was all put together
Serial: for (const fn of fns) await fn(); Parallel: await Promise.all(fns.map((fn) =&gt; fn())); 
Took me way too long to find JavaScript30. Wes Bos’s course. 
Okay thanks alot. But one more thing, please can you explain their use cases as well as where they can come in handy? 
You taught them. That is not the same as teaching yourself
i too hate this, but english doesn't seem to be their first language - at least learn them the right word. *teach*
Utterly missing the point and focusing on an irrelevant detail
https://github.com/getify/You-Dont-Know-JS
Practice.
List of reasons why for/of is nice: * Works with built in Map and Set, not just Array. * Works with algorithmically defined sequences, not just in-memory ones. * Can await inside them without creating yet another async function. * Can yield inside them without creating yet another generator function. * Can short-circuit the loop using break. * Can jump to next iteration using continue. * Anything can be made for/of-able by making it iterable. * It's built-in and plays nicely with other aspects of the language. 
Thanks! Pretty much what you said, it searches the dom for checkboxes and then attempts to find the text associated with each one. The native checkbox dom elements have a 'labels' property which is an array of label elements, I plan to add more sophisticated fallback search in case the html isnt structured properly. It pulls the innerText from the first label in the array and then categorises it by searching for keywords. It's super lightweight as its built with only vanilla javascript and minified with webpack so the files are tiny (total extension size is 9.9kb).
not sure if reddit notifies you for a reply on a comment that you also replied to, but brief explanation is above.
I find for-of loops easier to reason about, for simple things. They have the advantage of not introducing the conceptual overhead of a stack frame. Of course, they're also faster. For cases of multiple transformations, done consecutively, functional style clearly wins, for its conciseness, but I only do that if I have a lazy library at hand. Otherwise, the resulting memory use due to consecutive allocation is, for me, pure waste and negligence. I confess I am a bit sick of the functional style fans that see everything better solved using their functional hammer. I argue that some things are easier to reason about when written in a procedural style. Functional spaguetti also exists.
Daniel shiffman on YouTube is one of the great practical tutorials people. He takes a lot of concepts and gets them to an almost ready stage then encourages his audience to make something cooler. 
Came here to say this. “Coding Train.”
Returning in map, filter, whatever just returns from the inline function, not the outer function. OP is correct that you can't early-return using array methods. 
Actually, some of these ideas are great. 
You basically just need to add this to the updateList function (done mine for a JSON source)... if (this.options.source) { var source = this.options.source; var params = this.options.sourceParams; $.getJSON(source, params, function(data) { if (data) { $.each(selectorOptions,function() { var selectClass = ''; $tmpThis = $(this); tmpVal = $tmpThis.prop('value'); if (!$tmpThis.nodeType) { //array, not a node. tmpText = $tmpThis.prop('text'); if ($tmpThis.prop('selected')) { tmpSelectHtml += '&lt;li class="lwms-selectli" data-value="' + tmpVal + '"&gt;' + tmpText + '&lt;/li&gt;'; selectClass = ' lwms-selected'; } } else { tmpText = $tmpThis.text(); if ($tmpThis.is(':selected')) { tmpSelectHtml += '&lt;li class="lwms-selectli" data-value="' + tmpVal + '"&gt;' + tmpText + '&lt;/li&gt;'; selectClass = ' lwms-selected'; } } //if option is preselected then append to selected and add lwms-selected to the available side tmpAvailHtml += '&lt;li class="lwms-selectli' + selectClass + '" data-value="' + tmpVal + '"&gt;' + tmpText + '&lt;/li&gt;'; }); that.$element.append(tmpAvailHtml); that.$selectedList.html(tmpSelectHtml); that.$availList.html(tmpAvailHtml); } }); } else { //what was here previously } and add this while you're initialising the multiSelect: $('#test').lwMultiSelect( { source:'data.json', sourceParams:'stuff here if required I guess' } ); and data.json: { "0" : { "value":"1", "text":"Select 1", "selected":true }, "1" : { "value":"2", "text":"Select 2", "selected":false } }
Considering the state of machine learning hiding behind everything these days, it might just be. 
Thank you!
Nothing irrelevant about the method of teaching. 
LOL, I think knowing how memory allocation works is valuable for any programming job. Your smug ignorance is proving the point of every interviewer that looks for algorithmic knowledge. Based on your reasoning, knowing the difference between `call` and `apply` *should* be in JS interviews because it is specifically a JS question. But, the fact remains that knowing how memory allocation works will be far more frequently useful than memorizing the difference between call and apply. You go ahead and maintain your ignorance instead of admitting you were completely wrong with your understanding of what a linked list is. Good luck. You just make it easier for the rest of us to get jobs.
This one I saw in a thread a couple days ago here or on the learnprogramming sub, looks really neat, and a good way for me to review and refresh everything I have been learning from a different view.