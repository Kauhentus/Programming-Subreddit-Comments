Could you tell the iOS version of your iPhone 8? I will try to reproduce your environment.
I'm confused. Why does it matter what language it's written in? Unless you are extending it you don't have to touch a line of ruby. Meh. 
I like it for babel macros. As example you can use the idx macro (basically optional property chaining) and typescript even figures out the correct partial type &lt;3
(author) I'm happy there are people using this and enjoying it, thanks for sharing!
[removed]
I think they're talking about Liquid.
&gt; emoji to the commit statements I think we'll be seeing more of this as the recent millennials and younger age groups starts entering the workforce and continuing to OSS. As long as it's not too annoying or intrusive, Im fine with it 
You're a bit of a jerk huh? 
I've used this a couple of times. It's pretty handy. 
Yeah people still do... I used it once for a client project, it's pretty good. But yeah, not a really good experience for me, my macbook fan keep screaming while running the serve locally lol
Extending it as in actually writing the site? Or are you just copying a theme? Because to make this apples to apples, the same could be done with Gatsby, for instance.
You can use the `gh-pages` node package to accomplish this with other libraries.
Hi /u/mgorabbani, this post was removed. Job and job-related posts are prohibited * Job postings: Please post to /r/remotejs, /r/forhire, etc. instead of here. * Job/Career advice: Please post to /r/cscareerquestions instead of here. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
When I complete something I just rush home.
Awesome
Does it work navigate via fetch between pages with non equal Dom structure?
Hi /u/ruviSol31, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
sorry. Thanks for letting me know
Even if i don't see the usefulness of emoji commits, i don't dislike it. I mean: "Fixed [üí©](https://emojipedia.org/pile-of-poo/)" would fit pretty well
I'm talking about Jekyll, the application. 
Ha, I feel less bad about passing over that bit now. I forgot how complicated vectors/rotations are. But the game works perfectly. Kudos to you for taming that beast.
Not exactly a language.
I found https://www.11ty.io to be the Jekyll alternative for static pages without using Ruby 
How does this compare to what I assume is slightly more readable ramda? Never thought I‚Äôd say that 
Give https://www.11ty.io a look. All liquid glory + extendable by just using JS
I hope you intentionally wrote "kit" and didn't mean some other word. üòÑ
Should have called it jetpack.
The emojis aren't really detracting from anything when you see how [non-descript his commit logs are](https://i.imgur.com/in0mBVF.png).
You have better alternatives?
That's a fair question. To be clear this does not replace ramda but could instead be used alongside it - I'm pretty sure that's what you meant though. I'd say it's not necessarily an alternative to the more explicit functions you'd manually create, but instead an alternative to using runtime partial application (like ramda's `partial`) as this has far less overhead. Well, zero at runtime. It's sugar, and I'm aware people won't agree on it. It's for people who like the features referenced in Scala/Kotlin or those that are impatient about partial application in JS. I should add that as much as I like to use this myself, it's best used in moderation just like any syntax sugar. I'll cede that it can become hard to understand when it's too dense.
Gatsby or CRA. I'm partial to CRA. It requires more boilerplate to achieve the same thing, but it's infinitely more flexible.
Nice ! The worst tools never made for web development together ! The name should have been HIDE... 
&gt; the amount of time it takes to process even a trivial amount of it varies greatly between devices. This is why I can't get into the whole CSS-IN-JS bandwagon. As why would you wan't to add more load onto the Browser?
Well, I found it funny.
I still experience a rush of regret when I complete a challenging project.
Someone works hard on something, and releases it for people to use for free, and the top comment is bitchinf about emojis in the readme? Really gross. That said, the library looks great.
There's a lot that Webpack can do to work with Jekyll. Processing images, inlining SVGs, etc. y u hate on emoji? üëøüôÄ
JavaScript is a language. Nodejs is a portable runtime for JavaScript. AngularJS and React are UI rendering libraries built in JavaScript
How did you think calling me a jerk would work out in your favor?
so angular and react are frameworks ? like an API ? no bro i'm dead serious lol 
JavaScript is the language all of those things are written in. Programming languages are how you write instructions for the computer to execute. Everything else that you listed is written in JavaScript. AngularJS and ReactJS are frontend frameworks. They provide tools and a lot of pre built features to help make building a frontend UI easier. They are each different, but they are both written in JavaScript. NodeJS is an application that runs JavaScript server side. Traditionally JavaScript is a browser based language, meaning it only runs in web browsers. NodeJS brings JavaScript to the backend, allowing you to run JS code on your server.
No, they're libraries. Angular (v2+, not angularjs) is a framework. There's a subtle difference between library and framework that Google should be able to provide a good answer for. The libraries have APIs to interact with them.
&gt;So what is the point? a team has a 3 year old JS app with 200k LOC supported by babel. they want to use typescript. it is not feasible from a technical, product, business or risk perspective to cut over to typescript in one move, so to get fully on typescript, they're gonna need to support both babel and ts.
Apart from ‚Äútweak‚Äù I was able to follow most of it
No. Customizable content extraction is in development.
Hi /u/arden446, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
&gt;github.com/zavele... It's funny cause it's true... or at least could be üòµ
My sister's group made this for a project. If you're good a typing or just know where the keys are, try it out! (I'm currently first) http://pandance.herokuapp.com/
literally just began development on my first Jekyll site last night, lmao.
This is not how April's Fools work... try harder.
While they all are different, they are all required for every web based project. In fact, they are all also required APIs for windows app development, just Swift for MacOS. Be sure to include three or four versions of each in your projects, just to be sure.
Not sure what the end game is but this is not right. var submit = sf.sengines.options\[sf.sengines.selectedIndex\].value + escape(sf.keyword.value); window.location.href = submit; I don't think it's a very good search facility anyway, why copy it?
never mind I somewhat got it, thanks 
Sorry i will add more docs soon 
Tools like [linaria](https://github.com/callstack/linaria) are babel plugins so if you want to use them with TypeScript you either need to compile with both (unsupported, doesn't work in all cases) or use `@babel/preset-typescript`.
Well Gatsby runs with react which I find more complex to grasp than just yml and markdown and liquid. It only took me a week to get comfortable with jekyll whilst trying to get started with Gatsby I gave up after a few days (probably my limit of not being comfortable enough with React and Graphql...)
It's only really complex if you don't know JavaScript. If you know JS, getting something up and going is straight forward. I'm not trying to sound exclusionary or anything. It's just that it is a great tool for programmers. If you are not one or don't know JS, then I can see Jekyll being more appealing. 
lol this is why companies should stop pushing the 'we are a family' message...its a team not a family.
Hi /u/0xmtn, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Title gore
I would imagine the multiple security issues stemming from the litany of npm interdependencies would be leaving a lot of people sore at this point, but I guess people are still cool with relying on un-reviewed software if the price is right.
I bet the joke is lost on a huge number of people who don't know the whole "NPM is not an acronym" line too.
"Nice people matter" not in a VC funded growth-oriented company they don't. If they're not a coop, they can STFU. If they are, then _maybe_ it's actually practiced. Maybe. But it's not a coop, there's like half a dozen of those, worldwide, and including other industries.
Well their website also randomly cycles through joke abbreviations for NPM
&gt;But it's not a coop, there's like half a dozen of those, worldwide, and including other industries. There are [300-400 worker-owned coops](https://institute.coop/what-worker-cooperative) in the US alone. The largest coop, [Mondragon](https://en.wikipedia.org/wiki/Mondragon_Corporation), is headquartered in Spain and employs 74k people.
True, most folks will just make a new \`YYYY-MM-DD-topic.md\` file, but with issues anyone can comment &amp; ask questions without Disqus or the like.
The price being absolute zero? Most businesses will bite...
So, have you ever heard about hyperbole? 400 is not a lot of companies. And yes, I know about Coop, Migros, Muszynianka and Motion Twin, I'm a low-key fan of coops.
NPM stands for National Association of Pastoral Musicians which is why one of Isaac's earlier rants - on the npm site - was that it will always be `npm` bc those church going musicians have the trademark.
Funny thing is !! Only occurred to me after seeing it in minifier output. So yeah, better to write it as idiomatic they take care of it already 
How much do you estimate hosting this will cost monthly, all components considered?
This sounds fun, do you have a link?
Unfortunately. Software as a commodity is bad for pretty much everyone except the bean counters and the scammers selling botnet access.
Hi /u/Gehtdich_Nichtsan, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/Omgshakir, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
On the internet, hyperbole is often mistaken for idiocy.
Project Page (?): https://github.com/oguzeroglu/ROYGBIV *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
i mean searching `NPM` brings up [their website: npm.org](https://npm.org/)... but a link to what i claimed... sadly no. I looked and cant find it.. even went to the wayback machine. do you recall the header that would randomly generate `npm` acronyms? if you clicked that it took you to a block post isaac wrote before his #scalenpm user on the blog.
Depends on volume, but for anything that doesn't get much traffic, a few dollars.
Nobody need this, sorry
Cool! Well I‚Äôm a big fan of co-ops, so I wanted to add some info about them :)
If you wanted to say "people on the Internet often suffer from a superiority complex," then yes.
It‚Äôs kinda silly. It‚Äôs a package manager for node called NPM but totally not Node Package Manager.
When I did DoD work we had to justify _every single npm package_ we wanted, including its dependencies. This led us to doing a lot of stuff in house and trying to pick packages that had few to no dependencies. Builds were near instance. It was quite nice but also difficult in the way the JavaScript community works nowadays. I'd love a solid set of libraries that are all little to zero dependencies.
It was at one point the Node Package Manager if I recall, they just decided it had no specific acronym when it became common to host frontend packages too. 
I work in the security sector and, yeah, we try to build our work with as few dependencies as possible, because everything does get audited (in multiple ways). I do wish secure coding practices (at all levels of the stack) were promoted more often.
Trademarks are industry specific, and there doesn't seem to be a lot of overlap there...
if you think your company cares about you...I have a bridge to sell you
Yeah 300 literally ain‚Äôt shit 
The site I'm trying to make would have the same basic function as the site http://p90.zone/
I believe the issue is that you're not using a string for the hyphenated example. As a result, it's being evaluated as 123 *minus* 456 *minus* 7890 which results in -8223, something that doesn't match the pattern. `/^([0-9]-?){10}$/.test("123-456-7890")` returns true
Might be an unpopular opinion (and I say this respectfully) but remember the #1 goal of business is to make money. If this dude 10-20x‚Äôd the company he‚Äôs doing a damn good job. Also if they ask people questions and they *openly and naturally* think differently than the companies vision it probably makes sense to let them go. It‚Äôs not a nice move, but can be necessary. However on the other hand, after 10x‚Äôing you‚Äôd imagine you‚Äôd be pleased and want to keep things moving as is. Also asking for people‚Äôs opinions and then firing them isn‚Äôt the best way to have your team to open up and trust you. It‚Äôs okay to make change in a company and sometimes it‚Äôs necessary. However it can jeopardize how the public and your employees feel about you as shown by the replied ITT. Just wanted to offer a less emotional response. 
Thanks! You're right
It isn't so simple. The WWE is such because it became so big that the World Wildlife Fund was materially hurt by confusion with the World Wrestling Federation. &lt;/pedantic&gt; Neither org here is big enough to warrant this kind of lawsuit, so I don't get it. Probably a simple way to shut down the topic.
since you're accessing `responseFinal` as an array on line 21, I suppose you didn't mean to restructure it in line 24? message.channel.send("**Here, have a cute doggo!** :dog:", { files: [responseFinal] }) to message.channel.send("**Here, have a cute doggo!** :dog:", { files: responseFinal })
then() can receive a second failure callback. Add one and console.log out the result. 
What about this? `(?:-*\d){10}$` `-*\d` matches a `-` zero or more times (`*`), then a digit. It'll match all these: ---------2 ---3 ----2 2 -1 I put that in a non-capturing group `(?:)` so it doesn't pollute your matches, and then repeat it 10 times `{10}` and finally match an end-of-string/newline with `$`
The CEO is a complete lunatic. Trust me, I worked at his previous company. I know first hand what it feels like to watch your coworkers get fired over night by Brian.
I didnt mean it to imply there was anything legal/lawyerly involved... it was a post more about they are lowercase, that is their brand. Uppercase refers to these other people you may not know about
It‚Äôs The Register. The Daily Mail of tech should really not be allowed on this subreddit. 
`THREE.WebGLRenderer: Error creating WebGL context` (all demos, chrome / macbook air)
Yikes, I just realized I've been calling them all "node packages", front end included.
This is why i haven't drank the cool-aid yet.
Really hoping that improvements in tree shaking reduce the amount of micro packages out there. The situation today is pretty ridiculous. 
It's just syntactic sugar, and there are quite a few people in the front-end development field who are already using it, and if you don't like it, of course you can also use it in a different way than decorators.
The A in JAM stack stands for APIs. This generally refers to the services that you use to get your content. Contentful and Ghost are some examples. You can either query those APIs at build time or at run time. If it‚Äôs at build time, often your CMS will expose hooks that allow you to send a signal to your site to rebuild. 
&gt; The San Francisco startup's dismissal of five people two weeks ago didn't strike observers as particularly considerate. For an outfit that proclaims, "Compassion is our strategy," it rubbed those let go and members of the JavaScript community the wrong way. ... what does compassion have to do with the company not having enough money? This idea that your job has something to do with you personally isn‚Äôt a healthy mindset.
..they got a new CEO who bought in his own people..yup that would fu\*k up the culture big time, every time
The largest company in my country is a co-op
I remember when npm didn‚Äôt exist yet and then a year later the first 10 people contributing to nodejs went crazy on libraries and systems and frameworks and then shortly after everyone tried to make money out of it...
Haha yea. Also I noticed that recent CLI's are also adopting emoji's too, like Vue CLI
This is probably not a problem with npm itself. There is probably additional logging above.
That‚Äôs because they are... packages for node. Node.js is just a JavaScript framework, and NPM is a package manager for that framework. It has uses outside of the backend. You still need a server to host the front end and that‚Äôs why people use node, cuz it‚Äôs a server. 
&gt; You still need a server to host the front end and that‚Äôs why people use node, cuz it‚Äôs a server. Most people don't use node to serve static assets. Nginx exists.
True. It‚Äôs awfully convenient to use node during front end development though. Plus I‚Äôd argue if you‚Äôre using the NPM you‚Äôre still using node, as the NPM runs within the Node.js executable. I‚Äôm not familiar with a way to download packages from NPM without using node. 
Ok, it's syntactic sugar, but I'm not sure what the syntax without decorators would look like so the example isn't clear to me. Also I'm guessing that many potential users would be using Create React App, and I'm not sure if that have decorators enabled by default.
Have a read of the article. The guy says he doesn't care that he was fired (üí© happens), but that they got third party hr contractors in to do it and didn't even tell his direct manager that he was being fired. Also that it seemed to be retaliation for bringing up issues in an all staff meeting for bringing up issues (the 5 fired were the only 5 that spoke up in that meeting)
What does that mean? Is the daily mail like national enquirer?
Kind of how PHP originally stood for Personal Home Page
What if we had a standard library but we demanded that part of it was a tiny tiny module with it's own versioning, authors, licensing, governance, support, testing or lack thereof, etc? And then people could build larger and larger modules, with the same lack of governance, and that's how we'd handle your credit card transactions?
Looks like a nice library, thanks. I wonder if you could use [a repeated letter regex](https://stackoverflow.com/a/1660739) to convert letters in a single pass, rather than repeated passes for each symbol.
When I was hired on at my job, I was one of the last groups to have a meeting with our CEO, because we are growing too large. Someone mentioned something about us being a family and he quickly corrected them and told them that we were a team and as a team member we have to all keep performing to stay on the team. I **loved** that. I've worked places where people don't get fired and nothing sucks more than pulling someone else's dead weight. I've been here a year and haven't seen a single person fired either. I lived in contstant fear at my last job because even high performers would get fired for political reasons.
Use break to get out of the while block, then concat the rest. 
True, but how do you pull those packages from npm and get them in a state where they can be served as static content? I'm guessing it's nearly always through node.
They are just stored as tarballs that could be downloaded and extracted following a url pattern based on package name and version. It's possible to do so without node, buy very unlikely. Most probably require commonjs or at least ecma import/export to bundle anyway
Whoa! That‚Äôs so screwed up if true. :(
Are you being sarcastic
[removed]
Not OP but there are more companies full of slackers who don‚Äôt care about their craft or the business than not. Maybe not in SF but in middle America the average programmer barely even Googles, they just sit on the same task for weeks. I definitely understand the frustration.
&gt; fired over text message Ouch 
nice 
Individuals in the company care about you. I put a lot of effort into protecting my teams. But if they start lying to me they're gone. It needs to work both ways.
Thanks for the feedback, will investigate. The weird thing is that I implemented all the demos using a Mackbook air :)
Thanks for the suggestion :D
NPM was (partially) staffed by a bunch of immature kids. Remember when a whole bunch of their SJW types went off the rails a while ago? 
I wonder if anyone read the piece. &gt; The layoffs actually started last summer. The biz hired a new CEO, Bryan Bogensberger, to take the company from about $3m in annual revenue to 10x-20x that, explained an early NPM employee who spoke with The Register on condition of anonymity. And then a lot more of that. So typical case of new management wrecking existng culture for money.
I don't see anything about that comment indicating sarcasm.
&gt; Might be an unpopular opinion (and I say this respectfully) but remember the #1 goal of business is to make money. There needs to be balance, because no one wants this: &gt; Musing about the worst possible outcome, she said, "You could imagine this new CEO selling the company to Oracle."
I mean this in the best possible way, Dan is an absolute machine (and treasure for us all).
Have you considered using a for.. in loop? You could return out of the callback all chars that don't equal " ". I assume you'd consider using something like split as defeating the point of the exercise? Also remember that because js is loosely typed == can behave weirdly as it will compare value and not type. 1=='1' is true 1==='1' is false
Hi /u/nightman, this post was removed because your title included a URL. Please use the `submit a new link` option with a descriptive title. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Hi /u/nightman, this post was removed. Since we are a programming subreddit, there are very few instances where visual media is valid content for /r/javascript, including screenshots, demos, etc. Memes and other low-effort content are already prohibited. Please use the `submit a new link` option with a valid source URL, whether it's the project homepage, a blog post, etc. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Repository URL - [https://github.com/lukejacksonn/perflink](https://github.com/lukejacksonn/perflink)
They will use node to create the static files though
Interesting! Thanks for sharing.
It's funny reading the Redux documentation now a days. He put in a comment about how he no longer supports the idea of using container components and instead to use React hooks. 
Hi /u/BelgianGal, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Close. Though IIRC the Enquirer and its readership have at least a modicum of self-awareness, where the daily fail seems have itself (and its readers) convinced that they are a reputable outlet full to brimming with accurate news and correct views.
Nice one. I'll use it instead of installing jupyter for markdown. Was planning to install jupyter just for markdowns..
I love fun fun function. 
The WWF/WWE thing was more a matter of broken agreements. Back when they were smaller the WWE made an agreement with the WWF in order that they could both use the initialisation. In the 90s the WWE decided that they were big enough to ignore some of the terms of the agreement. They assumed that the WWF wouldn't call them out on it and were proven wrong, it all back-fired, and they ended up with far less legal right to use the name than they had under the original relatively informal agreement. Despite the legal result only requiring they change some things going forward, they threw a hissy fit and went back through archive footage and censored uses of the WWF logo (perhaps to try make the situation look more unreasonable and unfair to them?).
:) Chrome 72.0.3626.109 (Official Build) (64-bit), it all seem to be related to a Uncaught `TypeError: Cannot read property 'getExtension' of null`, hope it helps.
It would be great if JS land could move to a culture of fewer dependencies, but failing that, I would love to have some kind of way for people/organisations to audit and "approve" packages registered in NPM. When selecting a package from NPM I want to be able to see that people/organisations X, Y and Z have all audited that package+version and given it a thumbs up. The closest proxy to this info at the moment is choosing packages which are not bleeding edge and are used by many big popular projects/packages. It sounds like some companies and most likely bigger companies, are already auditing their dependencies but don't have a way of sharing that work (or benefiting from the audit work of others). 
There is some alteratives for markdown as following: * [https://github.com/codemirror/CodeMirror](https://github.com/codemirror/CodeMirror) * [https://github.com/JedWatson/react-codemirror](https://github.com/JedWatson/react-codemirror) * [https://github.com/scniro/react-codemirror2](https://github.com/scniro/react-codemirror2) * [https://github.com/Microsoft/monaco-editor](https://github.com/Microsoft/monaco-editor) (the core editor of VS Code) * [https://github.com/react-monaco-editor/react-monaco-editor](https://github.com/react-monaco-editor/react-monaco-editor) * [https://github.com/benweet/stackedit](https://github.com/benweet/stackedit) (only this one is a markdown editor, above are text editors) &amp;#x200B; I use **Code Mirror** as the editor. So I can config the Code Mirror to match my requirement. react-codemirror and react-codemirror2 both are a wrapper that enable you to use Code Mirror in react, but if you want to config the editor, you still need to read the official docs of Code Mirror.
Thanks!
DoD uses NPM? Wow the US are totally screwed. If just one package does a malicious update in the 'minor' version then your code will fetch it and automatically and compromise the software. Secure JS === zero use of NPM. Nada. Include your JS the old way and code review the libraries.
Or just trying (successfully) to get some media attention. To this day, people still talk about that and people are reminded that the WWE exists, even if they aren't fans. It was pretty successful, if that was their goal.
Good Monday morning!!
Hi /u/RosyGeorge, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Nope. I worked a job where one of the members on my team watched movies all day and would purposely derail projects to avoid doing work. I left that place 3yrs ago and he's still there.
It makes sense, but I still enjoy making container components purely so that I have some pure UI components that are reusable and can be shown easily in Storybook.
This list could have been written in 2017. 
Hi /u/mukesh_reddit, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
So bat boy articles?
Have you got any citations on this?
People abandon their family all the time though
Guys, it's "Sass", not "SASS". Thanks.
Especially in this industry, you can absolutely find companies who genuinely care about you. I'm fortunate to be at one of those companies. 
Solid post. +1 Looking forward to part 2
Apparently it‚Äôs in the comments of Redux
Where? [https://github.com/reduxjs/redux/search?q=hooks&amp;unscoped\_q=hooks](https://github.com/reduxjs/redux/search?q=hooks&amp;unscoped_q=hooks)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/webdev] [Presenting babel-plugin-cloudinary](https://www.reddit.com/r/webdev/comments/b8imn5/presenting_babelplugincloudinary/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Hi /u/____undefined____, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/treyhuffine, this post was removed. Prohibited low-effort content includes: * Questions that are easily Google'd. * Memes, jokes, etc. Please post to /r/ProgrammerHumor instead. * Most images and gifs. * [Listicles](https://en.wikipedia.org/wiki/Listicle). Please just no. * Polls, surveys, etc. unless from an accredited academic body or trusted source (StateofJS, etc.). Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/holy_serp, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/expl0itz, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/notsporadic, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/midnighttoker89, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/tomByrer, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/dlsso, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/ominous-light, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/ImTropixz, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
[See also](https://www.reddit.com/r/javascript/comments/b2o6f2/whats_your_favorite_most_useful_javascript)
This exactly! If possible try to avoid state and data access as much as possible in your components and only use it at the top level. Keep em pure!
Node is a Javascript engine, not a framework. Something like Express or Hapi would be a framework that runs on Node. 
Love your job but don‚Äôt love your company cause you never know when your company will stop loving you. 
The part about sarcasm is the implication that layoffs are due to you being lazy
Me too
https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0 not exactly what op means , think he mixed it up 
It's a business, not a family. A company has no obligation to keep anyone employed, unless stated otherwise in a signed contract.
Lol there are some gems in this video that hit close to home pair programming in my last position. 
That‚Äôs false actually. Node runs on the V8 JavaScript engine 
I agree it's technically not an engine (it _contains_ one), but Node is not in any way a framework. 
I don't understand how this is a 'newbie' question? I'm looking for a JS project.
More accurately: Node is a Javascript runtime that utilizes the V8 engine. It's an implementation of the V8 engine. Node does not run 'on' V8, as it is not written in Javascript ([Node was written in C/C++](https://github.com/nodejs/node/tree/master/src)). Either way, it is not a framework.
tat's cool
&gt; but in middle America the average programmer barely even Googles, they just sit on the same task for weeks. I can't even wrap my mind around this. As someone who is learning web dev by themselves and trying to get into the industry, literally most of my progress and learning has been a result of Googling. It's second nature to me. I can't believe they're employed. 
No where did I imply anything of the sort. 
I‚Äôm glad you‚Äôre able to Google. ‚ÄúThe core functionality of Node.js resides in a JavaScript library. The Node.js bindings, written in C++, connect these technologies to each other and to the operating system.‚Äù - https://en.m.wikipedia.org/wiki/Node.js It‚Äôs semantics. The node runtime provides a framework to build server side applications. Regarding V8: ‚ÄúNo. The current node.js binary cannot work without V8.‚Äù - https://stackoverflow.com/questions/42616120/what-is-the-relationship-between-node-js-and-v8 Go be a pedant somewhere else. You aren‚Äôt wanted here. 
I dunno. I'll get off my downvote train. But you also said "we definitely don't live in fear" when there are no firings which conflates again firing vs layoff. To me a layoff can have financial reason and even non-fat can get cut but obviously npm here is playing a weird game
I can see where you got confused and I apologize. I meant it as the opposite side of nobody getting fired, which was actually the situation I moved into after that job. Layoffs are different and usually have more business oriented goals. The things that happened at npm sound more like firings, than layoffs, though. Performance isn't the only reason what could could cause someone to get fired. If your best performer is toxic and creates an environment where others do not perform their best, then that is just as detrimental. That said, the case isn't looking good for npm based on the few things I've read. But, I've only read one side of the story and I doubt we'll get to see the other side. 
and I appreciate managers like you you sound like a 'shit umbrella' which is about the highest compliment I can give a manager you shield your team from the shit and let them work efficiently the opposite would be a 'shit funnel' which are gtfo managers still, I don't believe the company cares about employees, employees care about employees
If you can't modify the reference of that Element Node, no, because the DOM will stay modifiable (and that element will stay in the DOM). You can have that element off from your main code, and when you need to show it, you download it, add it to your DOM and then render it.
the user will be able to show/hide stuff thats in the DOM, doesnt matter if its inline styles or from a css sheet. i think the only thing you can do to prevent that is to no render the HTML until its needed, if its not in the DOM, the user cant mess with it.
I think you might have gone about this in a weird way. The element itself shouldn't really be your main concern, it should be what's inside it. And like pedro said, you can always fetch that info and then just remove it as you please. Then on your div you could toggle a ¬¥is-active\` class and have some a transition :D&lt;3
&gt;I‚Äôm glad you‚Äôre able to Google. Says the guy using Wikipedia as a source. &gt;‚ÄúThe core functionality of Node.js resides in a JavaScript library. The Node.js bindings, written in C++, connect these technologies to each other and to the operating system.‚Äù This does not counter anything I have stated. &gt;It‚Äôs semantics. The node runtime provides a framework to build server side applications. Yes, it is semantics. If I pointed to a building foundation and called it a framework, then defended it with "well, you can build a house on it", you would call me an idiot and then build a shed on it. &gt;Regarding V8: ‚ÄúNo. The current node.js binary cannot work without V8.‚Äù I never said that it could. You've been implying that V8 executes the code that Node is made of. As V8 cannot interpret or execute binaries written in C, this is incorrect. The relationship between them is more that Node calls V8 to interpret the JS code. Of course Node wouldn't work without V8. &gt;Go be a pedant somewhere else. You aren‚Äôt wanted here. Do I look like I give a shit?
Me and my friend participated in angular attack hackathon over the weekend and built these apps. Darts game (not mobile friendly) [http://www.angularattack.com/entries/104](http://www.angularattack.com/entries/104) &amp;#x200B; American Sign Language translator(Works on any device) [http://www.angularattack.com/entries/168](http://www.angularattack.com/entries/168) &amp;#x200B; If you like the entries, please consider voting for us.
I love both Dan and MPJ, they're awesome!
MPJ and Dan. Awesome. Thanks for sharing :)
Couldn't you still have simple components that only have view logic, then have container components that are built using hooks? 
The docs say: &gt;The current suggested best practice is to categorize your components as ‚Äúpresentational‚Äù or ‚Äú*container*‚Äù components, and extract a connected *container* component wherever it makes sense [https://github.com/reduxjs/redux/blob/231f0b32641059caab3f98a3e04d3afaad19a7d1/docs/faq/ReactRedux.md#should-i-only-connect-my-top-component-or-can-i-connect-multiple-components-in-my-tree](https://github.com/reduxjs/redux/blob/231f0b32641059caab3f98a3e04d3afaad19a7d1/docs/faq/ReactRedux.md#should-i-only-connect-my-top-component-or-can-i-connect-multiple-components-in-my-tree) &amp;#x200B; &amp;#x200B;
replace your `0` with a `-100`?
for(int i = -100, i &lt; 100, i++) { console.log(i)}
Or maybe "sarcasm, and tone of voice in general, is hard to convey on the Internet?"
Hi, Thanks for your suggestion. I was actually thinking about doing this earlier and I'll try and implement it soon. Meanwhile, if you'd like to give it a go yourself and create a pull request, would be very nice üòä &amp;#x200B; &amp;#x200B;
Try applying inline `display:none!important` style to the element. e.g. theElement.style.display = "display:none!important"; That won't easily be made visible by overriding the page's CSS using browser extensions such as Stylus. Those who can made it visible are only the ones who know JavaScript and DOM.
oh it's actually that simple
Not really, no. How about "nerds are obstinate and annoying by nature and use cheap excuses to cover up for it."
[removed]
More info: https://www.reddit.com/r/javascript/comments/alxz04/how_to_call_method_as_function/
I'm using Chrome on Linux... upgrade to Edge or Safari? Good work /s 
That makes sense. I guess I never really thought about it but I definitely had the idea in my head that parens "returned" whatever value was inside of them.
To add a bit to the link already provided... The `()` in `(foo.fn)` doesn't call GetValue on `foo.fn`. [See here](https://tc39.github.io/ecma262/#sec-grouping-operator-runtime-semantics-evaluation). Particularly the note that says: &gt; This algorithm does not apply `GetValue` to the result of evaluating Expression. The principal motivation for this is so that operators such as `delete` and `typeof` may be applied to parenthesized expressions. This is different in e.g. the comma operator, which does perform GetValue. [See here](https://tc39.github.io/ecma262/#sec-comma-operator). So... (0,foo.fn)(); // -&gt; false
```javascript (new Array(201)).forEach((n, i) =&gt; console.log(i - 100)) ```
Hi /u/shrithm, this submission was removed because you used a URL shortener. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
It works the same way as [https://browserl.ist](https://browserl.ist/). When the supported browsers query is \`last 3 edge versions, last 1 safari versions\`, the recommended browsers will also be the same. 
I learned multiple things! &amp;#x200B; Thanks!
Dr. Node From NPM with Love Modules are Forever For Your Code Only One Module is Not Enough I can‚Äôt settle on the new 007 title yet but I know the plot revolves around NPM. 
I feel like I've used `species` once before, but I can't remember when or why. It's not something that is commonly needed, and I'm not sure of the use cases where you'd want operations like map to downgrade your type as MDN seems to suggest in all their examples. By default, these implementations lean on the value of `constructor` for creating new instances, so you're already getting your (presumably) desired `MyArray` instances from the native implementations of `map` and others of the like. And given that `constructor` is configurable and inheritance is not dependent on it, instead relying independently on the prototype chain, you can configure generated instance types outside of `species` without having to independently override each of those methods. myArray = new MyArray(); myArray.constructor = Array; myArray.map(x =&gt; x); // returns Array But given `constructor`'s exposure as a public property, it's probably best not to modify it for these kinds of purposes. Having a configuration-style property through a symbol key fills that role a little better. 
Why not both?
I have these bookmarked when I have to argue against containers on a new job: [https://twitter.com/dan\_abramov/status/668585589609005056](https://twitter.com/dan_abramov/status/668585589609005056) [https://twitter.com/dan\_abramov/status/802569801906475008](https://twitter.com/dan_abramov/status/802569801906475008) 
for(let i = -100; i &lt;= 100; i++){console.log(i)}
Hi /u/ed-r-2087, this post was removed. To show off a project (i.e. a finished or semi-finished page, demo, working example, etc.), please include one (1) of the following: * A link to a project page with unbuilt/unminified source code -- sites like GitHub are perfect for this. * A write-up about the development of the project. This can take the form of a blog post, a `README.md` within the project, or a comment on the post itself. The details are up-to-you; you can write from a high-level about your architectural decisions, or you can write on a lower-level about the pros &amp; cons of specific libraries and frameworks you used. The main point is that you're discussing your code -- or your approach in creating the code -- in some way. * A working codepen/jsfiddle/etc. of the code. One of the easiest and most common ways to satisfy this requirement is to simply include a ["Fork me on GitHub"](https://github.com/blog/273-github-ribbons) ribbon your site. Another way to satisfy this requirement is to comment on the post itself, with either a link to a write-up, or with the write-up as the comment. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/Asmor, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
It's a support question. It also kind of falls under the "low-effort content" clause as well, you're basically asking us to be your Google service for you.
Hi /u/Anato33, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/ToddMcNab, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
*Composed of #FTFY
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), ‚Äúnobody‚Äù starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
One hour just barely scratched the surface. Anyone could've taken Dan's place for shallow of a scratch.
brb gonna write a Chrome extension to automatically turn single returns into double returns when adding Reddit comments, then get bored of it and turn it over to the first Bitcoin mining hustler who asks
Hi /u/Code_For_Fun, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
I think what we really need is something like the distinction between ubuntu's "main" and "universe" repositories. If there was a small, heavily-curated subset of npm packages that are well-vetted, use consistent conventions, and only depend on other packages that are also in the subset, it would make npm a lot less of a minefield.
Don't care if it was removed lol already got the help
They just copied everything from a reddit thread without ever attributing the source
Hi /u/orkhanjafarovr, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
DADD &amp;#x200B; Dan Abramov Driven Development
I haven't seen anyone do this, so it's a good thing we have Dan.
I'm not sure. I remember seeing a link to this article in the Redux docs but I can't seem to find it now. It might of been removed. 
Hi /u/richardalpa, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/harshalitalele, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/hoosierincaptivity, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
What's hero.y?
I wasn't being critical. Just found it funny that I can't really use those browsers on my OS! &amp;#x200B; In any case, shouldn't it work without the query string? You can have that as an object in your code, query it against the user agent, then make suggestions?
They're likely using \`getBoundingClientRect\` and doing a bit of math. There is a new API to make this easier called \[IntersectionObserver\]([https://developer.mozilla.org/en-US/docs/Web/API/Intersection\_Observer\_API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)) but Safari doesn't support it yet.
Hi /u/ImTropixz, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
&gt;ork is under exclusiv Thanks, bot. I added MIT license file to the repo.
Well, now I realize that plug in shameless plug is not a 'plug-in' : ) Hm... Original idea isn't mine and belongs to another developer. It was described in readme from the beginning in the [second commit](https://github.com/rumkin/pill/commit/58370e02b1c54bf6825cd1bb15b89f7d439cf94e#diff-0730bb7c2e8f9ea2438b52e419dd86c9R7).
You have a source for this? I still use container components with the latest React so I'd be curious if I *shouldn't* be anymore.. still feel like I need "Redux Container components" but not container components for React local state anymore because of hooks.
Haha, totally! :) And thanks for the compliment on my Tetris project. It has been really fun to work on -- I even picked it up again the past couple weeks to make changes to the build system and refactor to newer coding conventions I've learned. :) 
Nice dude! :D Sorry for the delay in response, I got sick and felt like my brain took a vacation... lol I'd love to give more feedback. I've found that the best way to share feedback and open up conversations about it is to use "pull requests" -- have you heard of that? I didn't really do it until one of my jobs had it as a standard, that all new code be reviewed in a PR first. 
No I Haven't But I'm Totally Down to learn! &amp;#x200B;
Dude , You Should look at the project now, I removed the P5 library and completely rewrote it in TypeScript!
Great point, I had been looking to understand what "hooks" `species` latches on to and hadn't considered `constructor` as that hook. The idea of reassigning a constructor on either an instance or a class prototype is pretty dangerous, but having a symbol configuration seems a bit a safer. What I still don't fully understand is how and when this occurs and does this only apply to native objects? &amp;#x200B; ```javascript myArray = new MyArray() myArray.constructor.name // "MyArray" myArray.map(x =&gt; x).constructor.name // "Array" ``` &amp;#x200B; I agree that the examples of "downgrading" type isn't particularly useful. One scenario that recently came to mind would be in unit tests for mocking/ stubbing objects. Or more generally, swapping types based on some configuration, though I feel this approach is probably better suited for [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy).
Is it worth sitting through two hours of it though?
Maybe something like this &amp;#x200B; [https://css-tricks.com/basics-css-blend-modes/](https://css-tricks.com/basics-css-blend-modes/) &amp;#x200B; with a one minus src blend mode
Here is an analog style VU meter using the JavaScript Web Audio API and HTML5.
Interesting problem. &amp;#x200B; What do you envision as the target audience for reuse of this solution? When you mention about being a great problem to solve, do you mean as interesting from a technical standpoint, or are there consumer domains where you've found this is a costly issue? &amp;#x200B; What have been the bottlenecks in your solution, so far?
The hook happens when a method is called that returns a new instance rather than simply mutating the original. `push()` for example, only mutates the original array, so species isn't used there. `map()` on the other hand creates and returns a new array, and that new array is what species will be used for. `map()` will create a new instance of the array checking for species and using that class as the constructor for what is ultimately returned. If species isn't defined, it falls back to the constructor of the instance `map()` is being called from. The implementation of `map` is very roughly... Array.prototype.map = function (callback) { let klass = this.constructor[Symbol.species] || this.constructor; let mapped = new klass(this.length); for (let i = 0; i &lt; this.length; i++) { if (i in this) { mapped[i] = callback(this[i], i, this); } } return mapped; }; Each native method that creates a new array in a return value would do something similar to help maintain the type of array being retained. Assuming you created a custom method that did something unique, you could also do something similar by checking the species, not unlike the made up `map` above. class MyArray extends Array { emptied () { let klass = this.constructor[Symbol.species] || this.constructor; let emptied = new klass(this.length); for (let i = 0; i &lt; this.length; i++) { if (i in this) { emptied[i] = null; } } return emptied; } } let emptied = new MyArray(1,2,3).emptied(); emptied; // [null, null, null] emptied instanceof MyArray; // true Then if that class was ever extended, and that subclass specified its own species, your custom method would respect that. class SubMyArray extends MyArray { static get [Symbol.species]() { return Array; } } let emptied = new SubMyArray(1,2,3).emptied(); emptied; // [null, null, null] emptied instanceof SubMyArray; // false emptied instanceof MyArray; // false emptied instanceof Array; // true It's the responsibility of the implementer to make sure species, if it exists, is respected. Existing classes in the JavaScript language do this already (Arrays, Promises, etc.), but it's something you could be doing as well, if not already. And this can be with any class, not just builtins. class Foo { static get [Symbol.species]() { return Date; } clone () { let klass = this.constructor[Symbol.species] || this.constructor; let copy = new klass(); return copy; } } let bar = new Foo(); bar.clone() // Date object :P
It's getting better, but imagine if you are a manager of software developers. Things are never complete on time. You Google around a bit and you find it's perfectly normal for software to be late and that most software is late. The developer has seemingly good reasons why the software is late. Unless you were a developer, you have no way to know if they are telling the truth or not, and even if you suspect they're mediocre, you know that at the salary you're allowed to offer, most of the candidates would also be mediocre and again you'd have the problem of knowing which one wasn't. Anyway if you're in the US shoot me a PM sometime.
Late reply, but thanks!
They listen to scroll events and toggle classes. &gt; Are these 'custom elements'? They are using Custom Elements and HTML Templates. They got like 19,000 lines of JS. I'm not sure why. The scrolling behavior is nauseating.
I cheated. This was a snippet of ActionScript 3, oscillating an object on its Y axis but it would work in Canvas (pretty much) so I showed it. 
There is the new prefers-color-scheme css property. But I think it only works in safari
the link says that the page doesn't exist. Did you delete it?
Omg. This is way awesome. Can‚Äôt wait to try it out.
You can wait for the edited version on YouTube. The stream is better to watch live because it's interactive.
From a marketing perspective it's difficult to drill down to a target audience, since the applications are broad. For a shot in the dark I'd hazard a guess at SMEs transitioning from digitized documents to integrated processing - they've already got the documents on their machines, but they're still performing data entry by hand. For the rest, that's covered in the series, if you get the chance to read it (~20 minutes, give or take).
I laughed way too hard at this
 function fibonacci(number) { let phi = (1+Math.sqrt(5))/2; return Math.round((Math.pow(phi, number) - Math.pow((-1/phi), number)) / Math.sqrt(5)); } 
&gt;var x = 1; &gt; &gt;var y = 1; &gt; &gt;var z = 1; &gt; &gt;var alpha = 2; &gt; &gt;var Fib = \[\] &gt; &gt;for(z = 1; z &lt; 1000; z++){ &gt; &gt;alpha = x + y &gt; &gt;y = x &gt; &gt;x = alpha &gt; &gt;Fib.push(alpha) &gt; &gt;};
Been using Aurelia in production since late 2016, the APIs are all so stable and well thought-out with typescript support, I really enjoy it. 
 function fibonacci(number) { let phi = (1+Math.sqrt(5))/2; return Math.round((Math.pow(phi, number) - Math.pow((-1/phi), number)) / Math.sqrt(5)); } let Fib = []; for (let i = 0; i &lt; 1000; i++) { Fib.push(fibonacci(i)); } 
&gt;function fibonacci(number) { let phi = (1+Math.sqrt(5))/2; return Math.round((Math.pow(phi, number) - Math.pow((-1/phi), number)) / Math.sqrt(5)); } let Fib = \[\]; for (let i = 0; i &lt; 1000; i++) { Fib.push(fibonacci\[i\]); } &gt; &gt;//square brackets for list items &amp;#x200B;
&gt; //square brackets for list items `fibonacci` is a function `fibonacci[i]` will just return `undefined`.
So sick of all these people.
/*I just realized that, */
It's a shame it's lacking adoption and therefore community ressources. Between Vue, React and Angular, Aurelia has caused me the least headache in the last three years. It's API is so stable I never had to rewrite a single thing. Working with it is a charm! 
 function fib(i=0, a=0, b=1) { return i ? fib(i-1, b, a+b) : a; } fib(10); // returns 55
I think Dart is going to be a contender in a few years when FuschiaOS releases
Not really. It's an hour of setting up screen-share + chatting, and then another hour converting a tutorial codebase with classes into functional components with useState (which is probably the easiest hook to grasp).
Can this be used in angular app? 
Pretty awesome. You need to disable the play button after mp3 start to play otherwise hitting the button multiple times makes your meter perform like a seismometer that measures earth quakes. 
Looks like you can just press Ctrl+shift+d to bookmark all tabs.
Of course. I use it with angular and it works.
Access to other tabs info could be a really big problem and serious data breach
I really wanted to do it with bookmarklets, but this seems to be the easiest solution by a stretch. Thanks !! :)
I'm using Brave browser but it thinks I'm using Chrome Mobile 73 and told me to upgrade to Edge or Safari... No thanks.
Chrome has a performance checker that also shows what event/function takes more time
Are you talking frontend performance or backend performance? I test them very differently. Also is your frontend rendered through SSR because that changes things. For just frontend, you can use react dev tools and check how many renders you are having. Are you memoizing? Are you using Fragments to reduce your dom levels? 
Could i use this in an app?
I was working on generating a large pdf with up to 100 pages and around a thousand images. The problem is a bit different to parsing pdf's, but we ran into some performance issues with event-loop which we solved with worker\_threads. It's an experimental feature but it solved our issue perfectly :D [https://nodejs.org/api/worker\_threads.html](https://nodejs.org/api/worker_threads.html)
Not sure how it would scale though :/ Our solution was for small user base.
[https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/windows/getAll](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/windows/getAll)
Lighthouse is available as a CLI and as a Node API (see https://www.npmjs.com/package/lighthouse). You could create a script that using lighthouse performs benchmark of the app load times and performance metrics. As you would have access to the chrome instance, you could make a special build of you application which would perform some actions on the website as it is loaded and that way you could get the performance. I am lazy, so even if I think there is a way to simply take puppeteer, activate profiling and manipulate the UI with it, I am not willing to do more research.
can we use it in a CI? automatically to generate score? I use it to debug indeed but I think it's too limited for this use case.
Thanks! Edited the question: Front end performance. No SSR. also we don't really have problems on app initialization (atleast that is not our focus right now). We memopize many things (perhaps too many?) using fragments and many things that should improve performance indeed. But our biggest problem is to measure if anything changed and to track performance regressions in real time. This is why we want to add something that measures it to the CI.
Thanks! This looks promising. Can it be used to check performance of scenarios or only of the site's loading?
That is something i don't know. srry
&gt; I am lazy, so even if I think there is a way to simply take puppeteer, activate profiling and manipulate the UI with it, I am not willing to do more research. I did the first step of the research for you: https://duckduckgo.com/?q=puppeteer+lighthouse&amp;t=canonical&amp;ia=software :)
Good idea, bad implementation, or.. You know. Why the fuck would I as a chrome user switch to IE or Safari in any universe? :D Not even for a million dollars mate :D
/r/typescript
I like composition in JS and wouldn't like to go back to OO. TypeScript helps with static typing, but having it built into the language would be nice.
Do you mean JS will never support optional type checking?
How would you go about implementing it? Have you tried a little experimentation to see? I would personally try the simplest solution first. I would probably get the offsetTops of each section with a different colour background. Then, as the window scrolls, detect which section I'm currently over by looping over the offsetTops and finding the furthest section the scrollTop exceeds. Perhaps something like: const sections = document.querySelectorAll("section"); let logoClass; for(const s of sections) { if(window.scrollTop &gt; s.offsetTop) logoClass = s.dataset.logoClass; // derived from the section DOM data attribute data-logo-class } document.querySelector(".logo").classList.add(logoClass);
I prefer strong typing, OO or not. VSCode is great, has what I need, no need for anything heavier. Don't know enough about WASM to comment.
Datadog launched a new product : [Synthetics](https://www.datadoghq.com/blog/introducing-synthetic-monitoring/) . I didn't get the time to look at it more in depth but I think it fits your needs.
He must've thought people had a really short memory
Correct. 
The main goal of JS is backwards compatibility with a half-assed programming language that was created over a weekend in the 90s. It will never get fundamental changes such as this, Typescript is as close as you can get.
I'm in the process of moving my code to Rust and Web Assembly. It's not OO, but it‚Äôs definitely strongly typed. The first part of that transition is currently in beta testing, and it‚Äôs looking good.
Also: https://github.com/1-liners/1-liners/tree/master/documentation
No benchmarks or stats? 
Rollup. Far user friendly than webpack and more customizable than parcel. 
bundlers are not usable at all, especially webpack
This is super neat. I wonder if there is a way to make it work with typescript.
The webSocket - are you pushing the canvas bytes out to the server, unprocessed, or are you doing some fancy compression, perhaps the mediaEncoder in some way? It's a fascinating project!
This is probably the best option. I investigated this a little bit but never got enough time to implement it. The only issue with this in terms of CI is it takes a while. Lighthouse CLI can be used to generate a JSON report and you could commit that, but I think the issue is that you'd want to test it in the same environment everytime, so you'd have to build it, deploy it somewhere, and then tell lighthouse to go there, generate the report artifact and then you could view it later. That or a really lengthy git hook that builds the app on a push, deploys it to a simple local server or something and then adds the report to your push
Rollup. I dislike Webpack. 
That's actually exactly what we do + asset and entrypoont size limits on webpack builds. We also use [SpeedCurve](https://speedcurve.com) to set alarms and help us debug when performance deteriorates. App is https://quintoandar.com.br. We have a fairly large PWA built with react/redux with over 2M DAU. Disclaimer: there are SEVERAL performance fixes, major and minor, that we already know that we need to do mainly on lowering JavaScript size. But still trying to find space for them in between what we have to do due to business needs. But these tools help us beware of just how much of the performance we're compromising. 
It seems odd to me that you'd put in a section of this article railing against "hype driven development" where you complain about people constantly asking you why you chose Flow over Typescript when in the end you decided that Typescript really was better after all. Have you stopped to consider that maybe they already knew it was better and were wondering what you thought made Flow better, and were honestly curious if they'd missed something? They weren't driven by the hype.
None, but if I have to use one then Rollup.
I'm not sure you have made a conclusive argument there.
For performance don‚Äôt use Selenium. You need multiple simultaneous user activity. Use Jmeter to simulate the load and use activity. You will also need some kind of monitoring at the server site to see what is happening there. Also make use of Chrome developer view, it can tell you some optimization that will reduce the page load time. I do this for a living let me know if you need any other help. 
Other people are already mentioning tools so I'm going to go a little left-field and suggest something else: "don't". Even github, one of the most visited sites on the internet, don't do stress testing (at least not according to some of their employees). Instead they sunk loads of effort into MI and CI such that deploying something to production is so easy that they can just roll it back if it caused issues, then the stress testing just happens in the field. Sounds sacrilegious but if you get your CI nailed down and are constantly releasing / rolling back then there is less of a need to make sure your software is "correct" before you deploy it.
how can you have static type checking (non-runtime) in an interpreted language? You pretty much need a compile step if you want to avoid finding things at runtime, which isn't very script money.
A _linter_ is enough for type-checking in JS world, therefore a compiler is not needed.
The interpreter can also type check. I don't see how a precompilation step would be necessary for type checking. 
Lets just say you need a build step then, which isn't interpreted code anymore, unless your linter physically deletes the code if it doesn't like it, then it is just a really crappy compiler.
how do you define "runtime" then?!?
No build step is needed for a [linter](https://en.wikipedia.org/wiki/Lint_(software)). Currently I am using TypeScript's type annotations as comments in .js files with, therefore I can avoid compilation step completely.
Hi /u/methecoder, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
my god you are being thick. You have to pre-process the file, whatever. You aren't just running it raw, choose whatever terminology you want, but you aren't directly interpreting the source, you are doing stuff with it first. And presumably you are not running it if typescript gives an error. But that sounds like a you problem.
Didn't download the project as i will be doing that part of the udemy course soon, but 2 things to help you: &amp;#x200B; 1) As others said, including images helps a repo a lot from an outsider standpoint. It's a good habit for a dev 2) You say contributions are welcome, but you are not including a license ([LICENSE.MD](https://LICENSE.MD) or smth like that format). Nobody can contribute to your code if you don't include one, because code is copyrighted by default if i recall correctly, so if you want everyone to have the permission to work with it copypaste an open source license in your project (MIT and GNU3 are the most trendy ones for this). This is important, right now you are welcoming people to act illegally, and while a typical rookie mistake, an expert dev may cringe to this kind of detail. [https://help.github.com/en/articles/licensing-a-repository](https://help.github.com/en/articles/licensing-a-repository) &amp;#x200B; Kudos for learning D3, really cool library. &amp;#x200B;
I like webpack 4. But every bundler I have used always has an issue and in today‚Äôs nature of web development, you can‚Äôt create even a simple website without so much extra baggage. Makes you want to move on from web development- very annoying. But yeah, parcel is quick! Roll up never used and browersify is awesome because you can view all your web development demos on all devices connected to your IP address, if I remember correctly. Never used roll up yet. But also all docs for bundlers or anything isn‚Äôt good so it‚Äôs hard for a newbie. So after a lot of trial and error buying courses on udemy..webpack 4 works for me. But it wasn‚Äôt easy for me.
Hey! I didn't ask about requests and initial loading time. I'm asking about performance of front end in several scenarios in terms of "time to finish scenario" and "fps" and to run them on "average machine" and add it to our CI-
The point is I simply integrate a _linter_ with my JS code editor, the _linter_ is working automatically while I am typing stuff, I simply write my code, then if the _linter_ found something wrong (type checking), it will show me how to fix it. It is way easier than a compilation step which creates another file for me.
still quite outside the domain of the interpreter though.
Interpreter just have to allow optional typing syntax, then it will ignore types as same as Python's type hints.
Thank you for all the replies, I edited the question to make it more specific about what I'm looking for.
but you won't know until runtime (i.e. more obscure browser console errors), and who said python is a good model anyway?
Did I say? :) &gt; but you won't know until runtime (i.e. more obscure browser console errors) This is how TypeScript works.
no, that is how typscript as a linter works. typescript as a transpiler will tell you if your types are wrong, again providing feedback BEFORE runtime.
TypeScript type system is not safe either: https://www.joehaines.co.uk/why-i-dont-like-typescript
Hi /u/rmkn, this post was removed. Since we are a programming subreddit, there are very few instances where visual media is valid content for /r/javascript, including screenshots, demos, etc. Memes and other low-effort content are already prohibited. Please use the `submit a new link` option with a valid source URL, whether it's the project homepage, a blog post, etc. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Nothing is "safe" in the wrong hands.
Hi /u/TheHoleInMoi, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/TsaiKoga, this post was removed. Posts must directly relate to JavaScript. Content regarding CSS, HTML, general programming, etc. should be posted to their respective subreddits instead of here. Here's some related subs that might be useful: * /r/css * /r/php * /r/html and /r/html5 * /r/webdev * /r/frontend * /r/programming Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/vaporcasts, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/bubble_cord, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/_fourzerofour, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/davchx, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/thisidntpunny, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Do you have a code sample that I can refer too. I am using canvas in my app and have trouble accessing it in the app.component.ts. I am really new to angular. 
You will have to manually measure your functions and renders . No easy way
Thanx for the reply! I had this question my self!!
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), ‚Äúnobody‚Äù starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
I had a general sense that you wanted to "teach" or communicate lessons from your journey of software development mastery, but it was a lot of fury and feelings, which made it a distracting read. Good job on you and your progress though.
I don't know the JS equivalent but Python has a pretty nice library to simulate hundreds of users on your application, it's called locust: https://locust.io/ Pretty straight forward and has a nice built-in dashboard.
Then you should learn how to use and implement services. My app uses a service for setting up the whole PIXI stuff. The service exposes all PIXI relevant functionality. The components use the service as a dependency.
Hi /u/th3originals, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Can probably use headless chrome in ci. 
It looks like you'll hide the invalid / animated characters for anyone using screen readers? 
Nope. It's fully accessible by screen readers and has proper a11y attributes set.
Thanks, that's probably the most clear explanation I've found! I did find an [article about JS metaprogramming](https://www.keithcirkel.co.uk/metaprogramming-in-es6-symbols/) that discusses `Symbol.species` in much the same way. The example of `TimeoutPromise` is probably one of the better ones, being able to extend a class with added functionality that doesn't impact the whole class chain. Now I'm curious where this is found in practice. Are there JS libraries or frameworks today that are actually taking advantage of these symbols? Time to keep digging, thanks for the pointers and examples!
The project created using the Create React App don't have decorators installed by default, but installing and using decorators is simple. Just need to eject this project, and install '@babel/plugin-proposal-decorators' to use it.
Github though is also generally a non-disruptive service in that most deployment pipelines don't switch over if Github goes down and the deployment cannot happen. It hurts productivity sure, but it doesn't 'cost you money'. Compare that to anything that actually will result is customers loss of revenue and you get a different set of parameters to judge whether or not you should do this. I think this is a good reason to know your customers and products. Test when it makes sense, don't waste time testing if it doesn't.
They have an npm module with CLI, so you probably could integrate it to your CI.
Same. Used to it since Beta. Moved to Vue last year because of lack of third-party packages and documentation. I was surprised it was still continuing.
This isn't exactly stress testing, but I really admire how \[Next.js\]([https://github.com/zeit/next.js/pull/6762#issuecomment-475879409](https://github.com/zeit/next.js/pull/6762#issuecomment-475879409)) uses GitHub Actions to compare bundle sizes and memory usage as a part of their CI process.
We do some fun stuff with Zone.js to measure task execution time: https://www.lucidchart.com/techblog/2018/11/09/tracking-javascript-performance-zone-js/ Not only could you use this to gather metrics in the wild, but you could make a suite of e2e like tests in puppeteer/selenium and plot out average task execution times while running the test. 
You need a demo site.
You should put this on github pages
Push to production and wait. I'm going to go ahead and NOT recommend this avenue. 
What are a11y attributes?
I don't know of e2e solutions in this space, (would love to hear about one!) but IME careful management of redux state updates (to eliminate needless changes to object identity), windowing of long lists, and liberal use of PureComponent or similar are critical for runtime perf in a react app. Out of curiosity, what kind of problems are you seeing?
I also used to create a browser animation using pixi.js and DragonBonesJs. I created animations using Blender with coa\_tools plugin
90% of the reasons you'll be turned down for a job in your life will be political and have no bearing on your skills. If you've graduated and you're studying constantly, you're job ready. The rest is navigating the labyrinth of nepotism and favoritism. You can minimize this by going for startups where the bureaucracy isn't in full effect yet. You may also have to move, go where the work is.
Thanks but I ask about front end performance
Navigation Timing API, specifically Performance. Add performance.mark() to gauge execution, log it. https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API https://developer.mozilla.org/en-US/docs/Web/API/Performance
great suggestion! :D
You might be interested in New Relic.
Thank you! I added MIT License
Hi /u/GPLink, this post was removed. Since we are a programming subreddit, there are very few instances where visual media is valid content for /r/javascript, including screenshots, demos, etc. Memes and other low-effort content are already prohibited. Please use the `submit a new link` option with a valid source URL, whether it's the project homepage, a blog post, etc. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
That's a good point. This is a piece of a larger application that handles those issues.
This is really neat! Just a note that the last example where it requires you to agree to the terms breaks a bit at \~120WPM+. The input couldn't keep up with my typing and kept getting stuck/missing characters I typed.
a11y -&gt; accessibility These are attributes like aria-label and aria-role (and a lot more) which aid screen readers and other accessibility software to understand the content of your site.
Well, types are hard, and the compiler loves to tell you no. They force us to violate the sanctity of Javascript's summer of love, anything goes dynamism and start doing things that may not be optimally efficient in the name of safety. The thing about adopting types in a language like JS is you have to start thinking in terms of those types, how they transform and not simply using them as object classifiers (that at least is the most common mistake I see). Typescript is at its best when everything in the application is typed and the compiler can follow your intent, that's the real key to avoiding the pain. As for VSCode, I prefer Webstorm for most things web-related. VSCode is great, but yeah, plugin hell is definitely a thing. So, selling points: * bridges the gap between the functional and traditional OO hybrids that are so hot nowadays. That's not just JS, it's all over the place with reactiveX, java streams/linq, C# pattern matching, etc. * Discrete type transformations allow us to define our application as a series of transformations and have confidence what comes out the other end of the pipe will obey the rules we define (un-typed javascript in the hands of the uninitiated tends to have a problem where you ask the jungle for a banana, and somewhere in the churning morass of application spaghetti, things happen and it gives you jesus riding a velociraptor instead. The things I've seen...). * Interfaces even on objects allow us to avoid fat-fingering, no spelling errors resulting in runtime exceptions (ex: &lt;Person&gt;{name: ...} // inference to person properties is projected by the language service) * Union types allow us to model interfaces that have inconsistent or multiple outputs, which allows us to strictly adapt and codify legacy code that may have been poorly architected * The compiler will always catch typed unsafe transformations (and in some cases unsafe nulls, unhandled type branching) * Allows us to lean into the compiler for our immutability checks, rather than assuming our code is correct. * Allows us to safely use R/FP libraries like ReactiveX or Ramda and have the machine double check each branch of our application to ensure we're returning what we think we're returning. * has a flag for strict null checking, so the build will fail if you haven't handled a potential null (crossing my fingers for a future maybe/none type encoding, the ask is out there) * Tuples! (because it's 2019 and yeah they're just arrays, but they're typed and allow for safe destructuring without class formality) * Intellisense! (with results provided by the language service, based on types you defined, so it is more than just a symbolic guessing game of things the index has seen before) * Composable, targeted decorators that can be compiler augmented There's like a billion more things, so I'll stop here. To me the bottom line is: Can you keep every branch and path of your application in your brain at all times? If you can, you're awesome and are totally fine with a purely dynamic language, you stud. If not, you might want to consider types and a compiler :D Typescript does this exceptionally well. p.s. Anders Hejlsberg is a total boss when it comes to languages. My background includes a number of languages and platforms, but his languages (turbopascal/delphi, C#, typescript) have never let me down and hold a special place in my heart, though the platforms they've occupied are a different story altogether. They tend to build upon the lessons he's learned in the past, and they explore in a conservative fashion that doesn't force you to deal with significant breaking changes. He's reliable and predictable, the rug will never get pulled. You might say he's earned my trust.
[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference)
There are two "normal" ways of doing this: the first is to benchmark hot paths out of band using a benchmarking library (similar to how you'd unit test a module), and the second is to use the Performance API and some logging/metrics framework in band. The former is geared towards the use case of wanting to trigger warnings in CI, and the latter is geared towards production environment observability.
Prime example of overkilling the usage of SPA framework in this age... This site is way too heavy for what it is... "40kb of JS"?! all you need is 2-3 lines of javascript? You gotta do addeventlistener and change a class of wrapper which holds background color/ image... Then the effect for typing the title out, there is a library called typed.js, which I believe minified version is 12kb at most? &amp;#x200B; THis is a overkill, looks nice... but a huge overkill
This hash map can only take strings as a key. It'd be a better challenge to design a hash map that can take any object or primitive as a key.
Hi /u/googlebih, this post was removed. Prohibited low-effort content includes: * Questions that are easily Google'd. * Memes, jokes, etc. Please post to /r/ProgrammerHumor instead. * Most images and gifs. * [Listicles](https://en.wikipedia.org/wiki/Listicle). Please just no. * Polls, surveys, etc. unless from an accredited academic body or trusted source (StateofJS, etc.). Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/atacamasand, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
&gt; This timeout promise could be created to perform an operation that times out - but of course you don‚Äôt want one Promise that times out to subsequently effect the whole Promise chain, and so Symbol.species can be used to tell TimeoutPromise to return Promise from it‚Äôs prototype methods. This is indeed an interesting use case, but species is not how I would solve for this. I would expect TimeoutPromise to be configurable (with a timeout) and if that timeout is not set - for example when the default constructor is used internally by a `then()` - that the timeout behavior would not come into effect. But at the same time, why keep creating TimeoutPromise instances in the chain if they can only pertain to the first promise in that chain? So maybe as an optimization it works better there. :)
Check out hackerrank and geekforgeeks
Map m = new Map()
This was my first ever attempt to implement clipboard interaction myself: https://github.com/CharlesStover/use-clippy It comes in the form of a React hook package, so it may not be conceptually accessible to just any JavaScript developer, but I am interested to know if I implemented it poorly.
JSON.stringify() üòÅ
This really only covers the very very very basics. Normally you wouldn't want the implementation to be able to allocate all the memory available with a single insertion (which is possible here, since the hash function is exclusively a function of string size and not of hashmap capacity) A more proper implementation would resize the backing array on demand by keeping track of capacity and what's called a loading factor. The Java collections implementation is a pretty readable example of a what production-level hashmap ought to look like. Another problem here is that the hashing function is _really_ bad. It makes it extremely easy for this implementation to effectively behave as a linked list, since inserting permutations of the same characters (e.g. `abcd, bacd, cabd`) and similar strings (e.g. `aadd`) will all hash to the same key and cause lookups under that key to be O(n). Not to mention that since the hashing function is a sum of digits in the ascii range, you're always going to be allocating memory at the beginning of the array that is never going to get used.
Not to be contrarian, but I've been using CSS for more than 20 years at this point and I still kind of hate it. I consider it boilerplate grunt work and would prefer to have tasks with more meat.
Hi /u/ReadyPlayerOn, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/adriansky, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
This isn't really doable unless you have access to pointer arithmetic (which you don't in JS), or unless you make your hashmap have O(n) complexity (which beats the point of using one in the first place)
I built a prototype of a stock market dashboard using React. Here‚Äôs the live [site](https://www.lrnztrading.com). (Not optimized for mobile) And here‚Äôs the [repo](https://www.github.com/Ll2NZ/securities-app). 
No it‚Äôs doable, and with average O(1) insertion and removal dependent on the hashing function. This was a technical question asked in an interview. You can hash your object properties and then use a linked list for each hash value in your hash table. You store the reference to the given object in the linked list. When retrieving, you use the hash to find which linked list to search and then use the equality operator to find the exact match. 
Thanks mate! Most people that have experience of the courses mentioned seem to agree that Grider is the best. Will definitely take his course.
Will do!
For anyone interested, not really worth your time. Doesn't really go deeply into hooks at all. All they do in the video is convert two classes to functions and then use the \`useState\` hook in a very simple way. With that said, some of the discussions were kind of interesting and it was entertaining.
We are using Katalon to test oƒ±r react Web apps. I do not know how to use it but oƒ±r experienced testler is saying that its beter than Selenium so i recommend you to search about it. 
Weekend project to try out the Intl API. Missing a bunch of locales that are honestly not necessary for the basic. Roast it!
&gt; You can hash your object properties No, that's not how maps work. Map semantics is this: const myMap = new MyMap() const a = {} const b = {} myMap.set(a, 1); myMap.set(b, 2); myMap.get(a) // should be 1, not 2 Typically in lower level languages like C/C++, one uses the numeric value of the pointer as the input to the hashing function. In Java, there's the hashCode method which is guaranteed to give you a unique number for a unique object. In JS, there's nothing of the sort. Using the key/values in the collection as inputs to the hashing function provides incorrect equality comparison semantics. 
Hi /u/DirtyZickes, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
A bit late for April fools, eh?
Hi /u/CuriousProgrammable, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Your argument is invalid. a and b will have the same hash, yes, but my implementation will then iterate through the list for that hash and do a comparison with the === operator. Then the appropriate object will be returned. This is like a simple polyfill for the Map data structure. 
?
But then your implementation suffers from a similar O(n) worst case scenario I described in the other comment. If all your objects look the same structurally, (e.g. a map of locks), you're right back at the "unless you make your hashmap have O(n) complexity" problem. And you can't argue that keys won't have similar structures because one of the main use cases for Maps is precisely to do Map&lt;K, V&gt; where K conforms to some interface.
Hi /u/PunchyTinkerton, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Yeah so I have another solution to that, but involves adding object properties to a given object. So there is a trade off. Have this implementation, which may perform poorly if all your objects look the same, or our set method can have side effects on the object we pass in. For instance, we can add a property name as "__id__" which we generate randomly e.g. uuid. Then we can hash that. The idea is that it's a challenge, and not that you know the basic implementation of a hash map. Java uses a similar method of having a hashcode.
&gt; The idea is that it's a challenge Ok, that's fair. &gt; For instance, we can add a property name as "id" Yeah, that's one workaround, though it's admitted far into the hacks territory since it violates encapsulation rules. With that said, it does have precedents (Angular 1 and MongoDB come to mind). 
Waiiiit, the translation thing was a joke? I never read the comments
I started building a parser for PlantUML using PEG.js: [https://github.com/Enteee/plantuml-parser](https://github.com/Enteee/plantuml-parser) &gt;The aim of this project is to provide a feature-complete, well tested, and maintainable [Parsing Expression Grammar (PEG)](https://github.com/Enteee/plantuml-parser/blob/master/src/plantuml.%60egjs) for the [PlantUML](http://plantuml.com/) syntax. The parser is designed to be used as [JavaScript library](https://github.com/Enteee/plantuml-parser#usage) or from the [Command Line](https://github.com/Enteee/plantuml-parser#command-line-interface). Every feedback or contribution is welcome. Thank you.
... a what? I can't see the reason for this to exist.
I am posting in hopes of getting a little feedback on the first major project I have (mostly) finished. I made a golf score tracking and handicap calculation app. It uses a Node, Express, Sequelize backend with a React/Redux frontend bootstrapped with create-react-app utilizing ReactRouter, Bootstrap4, and D3. I utilize JWT for user authentication. I am still tweaking a few layout things to make sure everything is mobile friendly but I'm pretty happy with the desktop experience so far. I will also post a Readme for the repo in the near future but the app should be relatively intuitive for golfers at least lol. &amp;#x200B; Users should be able to register their own account but if you want to see a profile with mock data already in place PM me for login details. A few specific areas I'm looking for feedback on are overall app structure, api routing and JWT implementation, and production database management (migrations, seeding, uzmug). Eventually, I'd like to look into code-splitting or optimizing bundle size to ensure good performance now and for larger apps down the road. Thanks for taking a look! Live site - [https://handycapped.herokuapp.com](https://handycapped.herokuapp.com) Repo - [https://github.com/EricGaupp/HandyCapv2](https://github.com/EricGaupp/HandyCapv2)
I think you should market this to Enterprise Business Intelligence and maybe Actuarial devs if you wanted some contributors. Not many devs here care about spreadsheet manipulations.
OK, I'm baffled.
PHPStorm is WebStorm + PHP support and DataGrip features.
Slack is not good for communities.
Why not? 
First, Slack is a walled garden locked to a single vendor and app. Second, the type of communication that Slack (and Discord, and others) implement leaves no records and artifacts, that can be used later by someone, who doesn't participate in real-time. Also, [this](https://dave.cheney.net/2017/04/11/why-slack-is-inappropriate-for-open-source-communications) has good points.
New to JS, made this calculator. Feedback welcome. [https://codepen.io/infensus/pen/eopJNY](https://codepen.io/infensus/pen/eopJNY) 
That's probably because those "Java" developers tend to work in bigger corporations with bigger code basis. Where CI &amp; CD is the way to do things. Within that environment things like VSCode painfully fails to address the problems developers have. Now for a person who doesn't work in that environment it will be difficult to understand what's the fuzz about. Because the editors gets the job done without "bloat" or "faster". As for things like "create-react-app" any editor is sufficient.
npm has always had a crappy attitude if you ask me. They totally broke create-react-native-app for months with horrible bugs in a supposedly stable version of npm. They refused to do anything about it and were rude to any who filed GH issues about it. I would NEVER give npm $ myself not would trust their mythical enterprise product for my business.
I don't understand what point you're trying to make.
I generally agree with you. But when business velocity is critical e.g. at an early stage startup, it often makes sense to consciously take on tech debt in order to validate business assumptions as early as possible. So code quality or architecture can slip a bit sometimes and that‚Äôs not a bad thing if it was an intentional trade off.
I'm below Features, Requirements, Screenshot and Quick Start, and I'm still not quite sure what this is about. Perhaps you could consider some up front use case description.
It's spreadsheet syntax that works with your application. Quite common in enterprise applications where there's a finite base implementation that has to be customized for a client without really changing the workflows much. Think of ERP Software, you would use such a framework to define simple relations between fields of items. Or trigger updates. Something you can't or don't want to implement in the product because the next customer wants it exactly the other way around. For some reason - the humble spreadsheet reigns supreme, closely followed by Visio.
This is awesome! I'll have to check this out later when I get the chance
Awesome! Good luck
I mean that static typing *might* have some value, and it is debatable, not exactly a science to declare one way or the other, mostly a matter of internet opinion. You can't do static typing with javascript though, or python, or other languages, and dumping type errors to a browser console (if the browser even has one) half way across the planet is pointless. Dynamic typing isn't really good for anything. And guess what, you can do that already with JavaScript, it is completely optional. But nobody does it because it makes things slower, and doesn't really buy you anything. For the type happy crowd, they typically use typescript and use it statically, i.e. before runtime, and only if it passes does it generate the output javascript. But since I get downvoted for discussing this, I'm done. If you have any further questions for me, you can just keep them to yourself.
Okay a lot of comments seem to be from people who are confused about the purpose of the library is. This library is a "Rule Engine" with the focus on spreadsheets as the template for setting the rules. I was inspired to write this by Java's KnowledgeBase library: [https://www.baeldung.com/drools-excel](https://www.baeldung.com/drools-excel). A "Rule Engine" helps separate some of the logic from the code. If you have bits on logic in your code that need to change frequently and can be set by non-engineers, such as a ticket price or something like that based on the ticket type (one-time seasonal etc), than this library helps you separate that logic out of your code. 
Neat. Can this also be used to deduce new information using inferencing?
Does it require a spreadsheet file eg xls to be store locally in nodejs? so it is updated from non engineers?
Just a quick look, but aren't you setting the WinScreen\_Choose() before the SetChoose()? Resulting in a check for the winscreen before any input from the players
Haha, come on, you're offended but not confused.
Oh yea, didnt notice that, thanks. But the issue still stands tho oof.
Secondly, you setting the new variables wrong with double == instead of = Setting Pick2 == 1; should for example be Pick2 = 1;
Thanks again, not even my friends could help me on this oof.
when decided get the outcome consider if(pick1==pick2){ console.log(‚Äútied‚Äù); }; to see if the players tie
Thanks for feedback. This is a react related problem, I don't think it can be solved soon. I'm planning to create web component from it in the future what should solve the issue with speed.
If the guy was trying to offend me cause he thinks my library dumb then whatever, he doesn't have to download it. You don't have to either.
You have to export the spreadsheet as a CSV file then add the path to the CSV file in node
You have any other ideas on why it might not be working?
thanks, part II is out, [https://medium.com/@noringc/ngrx-from-the-beginning-part-ii-redux-6305b481c55](https://medium.com/@noringc/ngrx-from-the-beginning-part-ii-redux-6305b481c55)
Uhmm I guess you could check WinScreen\_Choose everytime ScoreKeep is updates, so inside ScoreKeep
lol number 9 is a Nono for any proper codebase
YOOOOOOOO THANKS HOLY SHIT
It worked it FRIGGIN WORKED THANKS MY SAVIOUR
Great concise article! 
This is shifty... you made it sound like you're asking for communities but just advertised yours
Its a great day. I learned something new!!! Thank you.
Static typing doesn't mean it has to happen before runtime, it simply has the advantage that it can already be checked before runtime. 
Thank you! That's what I was aiming for!
Why is this any more "readable" than a well formatted config file???
Awesome! I'm glad you enjoyed!
Hahah, glad I could help
In my apps I have used `xlsx` because people complained about having to export and import csv. Now I don‚Äôt have to listen to their complaints haha. 
I'm trying to get my head around it... `// declarative` `const shortNames = names.filter(name =&gt; name.length &lt; 5);` But isn't the filter (function, method, proto what ever it is) just doing the imperative code you had above this? I don't see how the two examples are that different? &amp;#x200B;
I love functional programming and want to be better at it. The codebase I‚Äôm working in now has thousands of lines of code per component file, with literally multiple-hundred line block if statements. It‚Äôs exhausting and terrible and highly prone to mistakes. I want to be able to make things in a more functional manner, myself. So, I need to learn more and practice. So thank you for this article, it nailed it. 
It‚Äôs a cool idea. I‚Äôve used spreadsheet formulas in JS apps myself. I think the library I used was called ‚Äúformula‚Äù or something like that. Very handy.
Ok, there's a lot to unpack here (both in your question and the article). For starters, the `filter` method is a built in language feature. OP didn't implement the for loop logic in his own filter method. Thus what the filter method is doing under the hood is irrelevant. What matters is that to the user who is reading or writing the code, they can see that `filter` is being used, which automatically conveys that the goal is to get a subset of the names passed in. That information is not clearly conveyed by the for loop unless you take the time to read it and figure out what it's going. Secondly, the difference between the two is the first example is very "manual". You have to manually loop over the array and keep track of the index to achieve what you want. In the second example, you let the higher order filter function do that for you, and you merely give it the only meaningful piece of code you need: the logic for which names you want. Why is this significant? Because it expresses your intent better. What you *really* care about is applying that filter logic (`length &gt; 5`) to obtain a new list of names that match the criteria. THAT is what really matters. The for loop and tracking the index are ancillary to that goal and just create unwanted noise that you or another developer has to grok to understand the true purpose of that block of code. The second example doesn't have that noise. You are using a purpose-built abstraction (`Array.prototype.filter`) to do what you want, and this makes the intent more clear. The code is a bit more expressive and easier to read. You could take that a step further and write your own abstraction called `filterNamesByLength(names, 5)` which is even *more* expressive. You could take that one step further and wrap that in its own abstraction called `filterNamesShorterThan5Characters(names)`, which is more expressive still. And this leads me to my next point: there is no dichotomy between imperative and declarative code. It's a spectrum. Some code is *more* declarative than other code, but it's not binary. But in general, the word "declarative" rubs me the wrong way because it's not intuitive. I don't consider the use of `filter` to be declarative in a semantic sense. It's a language construct, no different from `for`. It just happens to be more specialized in its purpose than a generic `for` loop, and as such results in more terse code when used in the right situations, but it's still a language construct. As such, I don't like describing code as "declarative" vs "imperative". I only talk about code in terms of whether it is *expressive* or not. Does it *express its intent*? In that regard, I would argue the use of `filter` does indeed express intent better than a simple for loop. And a method named `filterNamesByLength` further expresses intent even more, etc. So, IMO, don't get hung up on the semantics of what "declarative" means.
They are the same in that they have the same output, so you are right in a sense. The difference is that the declarative pattern has an additional layer of abstraction where useless implementation details are left out: it just describes the "What", not the "How". But yes, you can see it as if the imperative code happens under the hood. I don't know if you are familiar with SQL, but SQL is a declarative language if that can help you get you head around it. Or maybe you are familiar with React? It's a declarative framework where you don't explicitly describe the changes needed in the DOM yourself, you just tell it its new state. Wikipedia has a great article about declarative programming that goes into more details: [https://en.wikipedia.org/wiki/Declarative\_programming](https://en.wikipedia.org/wiki/Declarative_programming)
I wouldn't have said it better! And I do agree that it is a spectrum.
I feel like Spectrum is better for communities that solve those issues but it's very buggy in my experience. Hopefully it will get better.
That is my first ever blog post, so that means a lot to me. Thank you kind redditor &lt;3
In the end, all concepts of a config will need to become UI that never fails and marketers can log into. 
But this solution totally meets a need.
This just a whole bunch of awesome! Great post. 
Yes I think it's sinking in, been looking at some examples in other code. `filterNamesByLength(names, 5)` in my mind looks right and `names.filter(name =&gt; name.length &lt; 5)` should throw an error lol . But I'm coming round to it. Thanks for the great reply, it has helped.
Funny you should say SQL, I was just looking at some examples which made sense. üëç
Any type of attribute on a JavaScript instance object can be modified
Please see comment above
We have this on my project. We use a variant rule engine that uses Excel spreadsheets. Calling it a cancerous fucking plague is an understatement. Some fucking stakeholder, that's no longer with us, really wanted it and now we're figuring out how to get rid of it.
Xlsx files are binaries in git. Multiple people can't work in the same rule and the can't find bugs by diffing the definition.
We used something like this in a serious production environment and literally all of these things happened.
Other rules engines exist that aren't written with spreadsheets. Those should be your go-to for numerous reasons. (Version control, ease of use, j-curve, documentation, debugging, etc etc)
step 1) close your javascript development environment step 2) install Haskell step 3) do real functional programming
I work at a very large company with an extremely large and complex code base. You will have heard of it. We use a lot of VSCode. You will find at very large tech centric companies, editors don‚Äôt do the job either, we have lots of purpose made tooling to manage getting code into prod. CI/CD using built in editor tooling probably isn‚Äôt very advanced. I want my editor to help me code, Ive got other better tools to do the rest.
``` // impure (using shared variable instead of argument) function addTaco() { return [...globalArray, "taco"]; } ``` It might be worth clarifying that this function is perfectly pure and acceptable in functional programming so long as `globalArray` is immutable (Or treated as such). You're still allowed to refer to the outer scope in a pure function.
Is a const array immutable? What prevents your program from adding, removing or changing values inside the array?
I feel like we're getting these types of functional programming articles once every week. It really starts to become annoying
Does it help your comprehension to see it written more classically: names.filter(function(name) { return name.length &lt; 5; }}; ...or, maybe better... const filterFunction = function(name) { return name.length &lt; 5; }; names.filter(filterFunction); Sometimes, I personally find the more concise ES6 syntax to be somehow harder to grok... but then, when you've been reading and writing JS for over 20 years, there's a lot of cruft in the 'ole brain to work through sometimes.
You are a sad existence.
Yeah this package (via Medium I think) popped up in my Google news/suggested articles feed yesterday, and despite being familiar with JRools (a Java rule engine), it was hard for me to understand what was going on.
It happens because people afraid of technology need to define rules, so this is what they clamor for.
Cool read!
you are a very sad frustrated person. I can tell you hate your job, your username says it all. We use a rule-engine at work and while I which we didn't have to use one it is a necessary evil. 
The SpeakJS discord channel is fantastic and very active.
Cool, but how do you do anything useful with pure functions and immutability?
Sounds like that some of functions or "parts" of your app that need to do calculatipns are demanding. In that case I would actually look to improven those calculations by analysing things like time and space complexity (often referred as Big O). To "benchmark" those functions you could throw in a Date.now() or Performance.now() (basically timestamping before running the function) and then after the calculation is finished, you do a timestamp again and look at the delta time (aka how long it took for the function to run). Then you just try to improve the speed of it. But there are also other parta that need so be improved like caching, critical render path, code splitting, minifying, using newer image formats to save file size etc etc
And that's what JetBrain do - make purpose made tooling. VSCode is not purpose made IDE, it's a generic code editor. Depending on the language you are working it comes from decent to poor. You mention CI &amp; CD and people think of specific tools specific companies provide. My god. CI &amp; CD is not tooling, it's a work flow. There are tools which help to manage it. Tools themselves do not define them. Where JetBrain editors help in CI &amp; CD is integration part. VSC support is unparalleled by anything on the market to this day. Stand alone tools do not have anything in this regard even remotely as useful. Matters when you work with 5+ people the team. Another great part related with versioning but not with GIT is local history cache and shelving patches or applying changes from raw diffs automatically. Another part which touches on integration part, is 'find usages'. VSCode still doesn't have it. And it doesn't seem that it will. JetBrain IDE's when seriously considered are simply better than things like VSCode as they offer more relevant features which make development safer and less needlessly complex.
Yeah, i prefer functional programming myself, but I wanted this article to show me more real life architecture problems rather than the very very basic ideas of fp
JavaScript is a sad existence.
No, const only means that the variable cannot be redefined. You can still mutate it by pushing or changing some value in it.
We threw out selenium for Test Cafe, uninstalled java from our servers and dev machines and haven‚Äôt looked back. https://testcafe.devexpress.com/Documentation/ I believe there is a timing plugin but ive never used it https://github.com/jimthedev/timecafe We use k6 for load testing https://k6.io 
Correct me if I'm wrong but here is how I understand it. A variable is like a pointer, a reference to some location in memory. If you use this space to store an integer for instance, you can only modify the stored value if you declared the variable using let or var. If you used const you can't. Now things are a bit different with more complex objects like Arrays. In this case, the size of the in-memory space that needs to be allocated in order to store its value is not always predetermined and could change. So what is really stored is a reference to another location. This one reference still cannot be modified if you used const. But the content of the array can be, as it is located elsewhere.
`const a` in JS is similar to `Foo* const a` but not `const Foo* a`. While there's no keyword to prevent an object from be mutated, [Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) can be used for the purpose: let a = Object.freeze([1, 2, 3]); // a.push(42); // Fails a = [...a, 42]; // OK a.push("ü§î"); // Works because this is a different object Object.freeze(a); a.push("üòÇ"); // Fails &amp;#x200B;
&gt; That information is not clearly conveyed by the for loop unless you take the time to read it and figure out what it's going sorry, that's silly. collection.filter(filterFunction) is a common pattern, just like const newCollection = []; for (let i = 0; i &lt; 5; i++) { newCollection.push(oldCollection[i]); } is a common pattern to anyone who has programmed in a non functional paradigm. you make good points about why deferring extra boilerplate code the compiler is good, but you're making a value judgement call on which pattern is better because you happen to be more familiar with it. if we're being intellectually honest we show the example where imperative code is much clearer: converting an array to an object, which requires reasoning about accumulated values in an imperative style, and requires the local creation of 3x as many variables, plus another function. const arr = [1, 2, 3, 4]; const newObject = arr.reduce(function(acc, cur, i) { acc[i] = cur; return acc; }, {}); vs const newObject = {}; for (let i = 0; i &lt; arr.length; i++) { if (arr[i]) { newObject[i] = arr[i]; } }
Why the hell are you wasting your time in this subreddit then?
Step 1: () Step 2: =&gt; Step 3: { return }
Monitoring the chaos and degeneracy
You use pure functions to create descriptions of what shall be done (actions or whatever), and let a runtime handle the dirty parts. &amp;#x200B;
Haha okay. I see. Edgy comp science student. Let me give you one advice: the more you think you are right, you have probably missed something. Now go use that advice and get some good grades! Gl on your first job. And remember people skills are equally important as software development skills.
Lmao I have worked at several different companies and I have a lot of experience with PL, Haskell, and JavaScript. One of my jobs was actually JavaScript compiler development. I can assure you I have not missed something and that JavaScript is a terrible language. But nice attempt at being condescending, funny stuff. 
&gt;const newCollection = \[\]; for (let i = 0; i &lt; 5; i++) { newCollection.push(oldCollection\[i\]); } But there is no filter condition there...
‚ÄúWe made a game in project class‚Äù haha you are so full of bullshit. 
I very strongly disagree...
Yeah senior year at MIT. So I had a full stack web dev job in highschool (helped me get in), compiler dev job after freshman year, full stack web dev job after sophomore year, JS compiler dev job after junior year, now working at a company a friend and I started.
Thanks for proving my point.
Lmao if you think I proved your point then you are an idiot. I know my shit when it comes to PL and particularly JS and Haskell, I have more than enough domain specific expertise to make statements about the quality of the languages, I guarantee I have read a lot more of the JS spec than you have.
Sorry mate, but no. You're making some wild assumptions. I've written plenty of code in the "imperative" style as well as the more "declarative" style. I started off writing imperative code and looping through arrays with standard for loops long before I discovered higher order functions for doing that. I can say with absolute confidence that code which makes use of `filter`, `reduce`, `map` and other higher order functions is easier to read and grok than imperative code is. The mechanics of iterating is abstracted away, the higher order function conveys intent, and then the only thing you have to worry about groking is the iteration logic. There is no question that more expressive code results in lower cognitive overhead no matter how familiar or comfortable you are with imperative for loops. I will grant you that `reduce` is probably the least clear of those higher order functions, but your example is also something I consider an odd case. I've needed to use the index argument in a reduce function maybe 3 times in my life. 99% of the time I use reduce, I only need the accumulator and the current value. That's it. Many times you can just use `map` instead of `reduce` to get data in a different format. Map doesn't *have* to transform an element. It can just return a different element altogether. If you had an array of user objects and you only wanted an array of their usernames, you could just do `users.map(user =&gt; user.name)`. No need for `reduce`. The chainability of higher or iteration methods on arrays is also extremely easy to read and makes for highly composable, reusable code. You can immediately start transforming your data without the ceremony of a `for` loop or having to do gnarly function nesting (or constantly re-assigning to a temporary variable). const namesOfPopularUsers = users.filter(isActive) .filter(withFollowers(100)) .map(user =&gt; user.name)
üòÇüòÇüòÇ
React largely depends on pure functions (the render function) and immutability to achieve what it does. It is an order of magnitude faster to compare whether a new array is different from an old array (by reference) than it would be to diff the arrays element by element (and potentially recursively if the elements themselves are iterable objects).
I‚Äôm guessing you‚Äôre assuming that since you are older that you are automatically right? Or what is your angle here? What are your credentials exactly, what kind of compiler dev have you done / what does your education look like? Because to the outside you look like an idiot, and if people agree with you here it‚Äôs just because this is /r/JavaScript and almost everyone here has Stockholm syndrome.
Ok. So now that I'm ~70% in Max's course and ~50% in Andrew's I have some thoughts about both of them - Andrew is doing it more in course way and Max made it a big knowledge base. Imo everyone should get both of them, but start with Andrews, he teaches more about the whole idea and is more beginners friendly. On the other hand Max's course is faster paced, there are a lot more topics covered, but it's harder to keep up. Feel free to ask any questions :)
I think it's exemplary for posts on medium.com: they scratch the surface, but that's all they do.
You're not wrong, somewhere along the line the computer must execute certain operations in a sequence. But what does the computer do when you program `4 + 3` ? Even basic addition can be broken into steps. The ultimate goal here is to have the computer understand our commands. But we humans also run programs. You don't have to consider every power of 2 to add a number in your head or on paper. At a certain point, we need to abstract our programming constructs to match the abstraction level in our head. It wasn't always so easy to say "Computer, add these numbers!" Here's a functional implementation of filter. Exclude is just a helper. const exclude = (a, i) =&gt; [...a.slice(0,i), ...a.slice(i+1)] const filter = (arr, pred, i=0) =&gt; arr.length == i ? arr : pred(arr[i]) ? filter(arr, pred, i+1) : filter(exclude(arr, i), pred, i + 1) // example usage const a = [1,2,3,4,5,6]; const p = c =&gt; c % 2 == 0; const even = filter(a, p); // even === [2,4,6] And [here](https://gist.github.com/jistjoalal/d051e7a273916bdfd3f835ebaf228491)'s a readable version. JavaScript is something else...
Pssh, [no true javascript functional programmers](https://en.wikipedia.org/wiki/No_true_Scotsman) use `{`. They just use `=&gt;` and implicitly return the single expression.
The thing that keeps data immutable is the programmer. You can't reassign a const variable. Array's and objects remain mutable through their methods. const a = [1,2,3]; a = [1,2,3,4]; // error a.push(4); // OK
The same way you do useful stuff imperatively. But this way the code is easier to read.
I think you misunderstand a bit, it's not 'clarity' that is on trial. Imperative/declarative has slightly different meaning. In your example, the reduce version is not much more declarative than the loop. Writing it more declarative would be if you wrote a higher order function called arrayToObject (or whatever you want to call it), using reduce, then you would end up with: ```const obj = arrayToObject(arr);``` This is much more declarative than either example. It's shorter and faster to read, and it expresses the intent of the result. That is the point of the functions and function composition. 
Poor grammar and typos. Pretty much what you'd expect from someone that saw a rules engine built around Excel and thought "hey that doesn't sound at all retarded" My user name is a quote from the venture Bros. It's about a stripper with depressing tits. The kind of tits powered by an Excel based rules engine.
have you tried using svg to draw the document? it allows you to draw text-boxes, anchor them just like MS Word however calculating height / width of the component is a pain &amp;#x200B; do you know of any way to calculate the size of component before React renders them or somehow hook on to that? &amp;#x200B; i once tried rendering all the components in one big blob without pagination, then use DOM methods to calculate the size, then re-set the layout
A similar horror story for us. The desire was for code that could be modified after it's been deployed without recompiling. So far we've realized people that write software professionally hate touching it, let alone people that are "good with computers"; and the call stack alone for this abomination leads to tremendous memory usage and lag.
Most people won't. I'm worried about the poor idiots that will download it.
Hookedreactris [https://github.com/Pokute/hookedreactris](https://github.com/Pokute/hookedreactris) &amp;#x200B; Tetris made with React hooks.
If your senior product-owner tells you that you have to use a rule engine then you have to use a rule-engine, you can fight reality or evolve with it
I'm sorry using a rule engine at your work ruined your life 
Lol I have no opinions on other things being said but this is a funny response 
How many such posts does the world really need. What does this add what wasn't already mentioned in the hundreds (!) of other such posts before?
Hi /u/tjdalsvndn8, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
IRC is 1000x more active.
codecdemy if you have zero experience and freecodecamp after that.
He's only taking the first 5 items in the old collection, so that's kind of a filter.
There is: `i &lt; 5`. That snippet would be the same as `const newCollection = oldCollection.filter((val, i) =&gt; i &lt; 5)`
Huh. What is the name of class of functions that depend only on input parameters? Memoizable?
In Swift we call them guards :) Really cleans up the curly braces.
but on freecodecamp should one just skip the responsive web design certification (its 300hour O\_O ) and jump onto JavaScript?
I have Written a short blog on "A Comprehensive Guide to JavaScript", You may find it useful, check it out Here
&gt; perfectly pure and acceptable in functional programming There are two different points here. One is "perfectly pure", the other is "acceptable". These are very different things. _Perfectly pure_ is not something, so let's just assume "perfectly" is there just to emphasize that "this is _indeed_ a pure function". But is it? The problem is you're making an assumption. "so long as...". In essence, that assumption is saying that no, this is _not_ really a pure function in itself, but if we apply certain restrictions to the whole of our program, then this function will exhibit the properties of a pure function. Unfortunately this assumption largely invalidates the benefits of using "actual" pure functions, because we're letting the guarantee of those properties and benefits step outside of the function itself and reside somewhere else. In some cases ("is immutable") that guarantee will rely on the properties of the referenced variable. In others it's actually much worse ("or treated as such") because it then has to rely on each and every line and piece of the program to respect those constrains, and so the _guarantee_ becomes much less of one. So, "perfectly pure" it is not. You could say, at most, that "if we observe some other constrains on our whole system, then this function will have, to some extent, the properties of a pure function". And while this may sound like nitpicking to some, it is a fundamental distinction. For the second point, about this being "acceptable", this is related to your conclusion: &gt; You're still allowed to ...and of course you're _allowed_ to do whatever you want to do. Functional Programming is not about _allowing_ or _disallowing_. It's about helping you manage some particular concerns through some approaches and techniques. The problem, though, is that while you're _allowed_ to do as you please, sometimes doing so may mean that you are not following those approaches and thus will not be getting the promised benefits (in total or in part). So, you are _allowed_ to refer to `globalArray` if you want. There's no "FP-compiler". You will get no error saying "Function is not pure. You've abandoned FP. Will not compile.". But then again, you _will_ be risking the benefits and you may not get the results FP promises. In the case of pure functions, the promise is that you don't need to care about anything at all outside of the function itself to know the result. Now you've gone and made an assumption. I insist that, sure, you're allowed to do that. But now the assurance that you don't need to care about anything outside the function is lost. You now have your assurance elsewhere. Now you _need_ to care that `globalArray` is indeed immutable ("or treated as such"). This may or may not seem like such a big deal, but it undoubtedly destroys the promise of the pure function. So to the argument of _being allowed_, sure, you're allowed to do exactly whatever you want. But to the argument of this being _perfectly pure_, no, I'm sorry, but it is not.
This is nice philosophical bullshit, I'll grant you that. But I'm afraid that the example is, in fact, perfectly acceptable and downright common in a purely functional codebase. 
You weaken any argument by the personal attack you start with. Completely unnecessary and rude.
If the same input always yields the same output with no side effects, it's a pure function. 
Ah, okay. Now I see your argument. But the globalArray really has to be immutable.
Some [experiments](https://type76.com/) made with three.js and canvas. The top one is an actual job, so I will move that in future
You sound very confident for someone with so little reading comprehesion.
Two examples where immutability is nice: Distribution of computation and asynchronicity. The first, you can distribute the load over several threads (or workers in JS), and even different machines (e.g. see Spark). For the second, when you don't know the sequence that your code may execute you are better off when a function doesn't use a pointer to a structure that can be mutated by another piece of code that may run at random times. For example, I have a piece of code that writes an object to persistent storage, after computing a hash over its contents. The hash creation is asynchronous. That means that between receiving the object and writing it the function is interrupted, to wait for the hash. If the object is mutated after it was given to the write function the object actually written is the one after mutation, and the hash still represents the old version originally submitted. This can easily happen: Imagine somebody wrote a loop writing several objects, and they don't create a new object but mutate a single one and call the write function with it.
It's kind of a fragile pure function, in that it's pure but that purity can easily be broken by other things outside of its scope messing with the global it depends on.
The mechanics are basically correct. I'd use some different wording, though, and I'd also avoid any mention of how memory is managed since I have absolutely no clue how JS manages memory. But in short, a variable stores a value. In the case of primitives (e.g. string, number, boolean), it's literally just the value of that primitive. In the case of objects (including functions and arrays, which are specific types of objects), the value stored is a reference to the object, not the object itself. When declaring a const, you can't change the value after it's set. So in the case of primitives, a const is always going to "look" the same. In the case of objects, the specific object referenced will never change, but the properties of that object *may* change.
I feel like trying to treat JS objects as immutable is a losing battle. They're not, and acting like they are relies on the discipline of everyone who will ever touch the code to 1. know that's the goal 2. never forget about it 3. know *how* to handle them. E.g. `Array.prototype.sort`--unlike `map`, `filter`, etc--mutates the array. So someone might do `sorted = original.sort(...)`, think they're doing everything right, but in reality they've mutated `original`. There are libraries that handle this, like [immutable.js](https://github.com/immutable-js/immutable-js).
The way i like to study is through books and i would like to recommend Eloquent Javascript 3rd edition for you. Also there are ton's of free books available which you can choose from here [https://jsbooks.revolunet.com/](https://jsbooks.revolunet.com/) 
&gt; But the globalArray really has to be immutable. That's true, but it kind of has to be anyway even if you pass it directly to a function - it could still end up being mutated halfway through the function. In Javascript we can squint a little bit and say "But it's single threaded so the array won't change!", but that's not inherently true in all cases, and certainly doesn't apply for most other languages. And then what happens if we partially apply the function? Even with the single threaded nature of NodeJS, something could mutate the array between the first and second application. 
&gt; You sound very confident for someone with so little reading comprehesion. Do you always lash out when somebody disagrees with you? Let's try some examples. Is this a pure function? `(array, y) =&gt; array.contains(y)` How about this? `(array) =&gt; (y) =&gt; array.contains(y)` How about if I partially apply that? Is `fn2` a pure function? const fn2 = fn( array ) const result = fn2( 7 ) Now how about this? const fn = (array) =&gt; ({ has: (y) =&gt; array.contains(y) }) Is `has` a pure function? What about function module1( globalArray ){ return { has: (y) =&gt; globalArray.contains(y) } } How about function module1(){ function globalArray(){ return immutable([1,2,3,4]) } return { has: (y) =&gt; globalArray().contains(y) } } And what about function module1(){ const globalArray = immutable([1,2,3,4]); return { has: (y) =&gt; globalArray.contains(y) } } At what point did that stop being a pure function?
Thanks!
Don't look at bad examples of imperative style and throw away the whole thing. There are truly horrific examples of functional programming as well. My advise to you is: use the best parts of functional programming and incorporate it into an imperative/OO style. Ideas like immutability, no side-effects, etc, are a godsend and should be heavily encouraged. Truly not enough programmers do that. However, even that has limits. If you go too crazy you end up with monads, an idea that is trivially simple to implement and reason about in imperative/OO style.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), ‚Äúnobody‚Äù starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
[removed]
&gt; Do you always lash out...? Nah, mate. Only when someone starts using terms like "this is bullshit" and then try to disagree by saying something I already said. It's all good, though.
Thanks, yes I think this is where I'm getting lost. In my old brain variables are variables and functions are functions, but no a variable can be a function, ooo errr. Back to the books... Your first example looks better to my eyes.
Great clarification, thanks for your comment. 
[removed]
Try this: * https://github.com/micromata/awesome-javascript-learning * highights: * https://developer.mozilla.org/en-US/docs/Web/javascript * https://github.com/30-seconds/30-seconds-of-code
Couldn't hurt to try this free resource: [javascript.info](https://javascript.info).
The editor comes with its own layout engine. Width / height of pages, blocks, lines and words are calculated before rendering to the view. If you inspect the demo, you'll see each line rendered as separate divs, just like Google Docs. The editor has no dependency on React, by the way, I'm just using React in the demo to wrap the editor.
I guess you're technically right. I understand you aren't saying that is the best way to achieve that result, but I would definitely question why the person didn't just use \`\`\`oldCollection.slice(0,5)\`\`\`.
Hi /u/obkladacka, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/redsnow73, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/piyiotisk, this post was removed. Prohibited low-effort content includes: * Questions that are easily Google'd. * Memes, jokes, etc. Please post to /r/ProgrammerHumor instead. * Most images and gifs. * [Listicles](https://en.wikipedia.org/wiki/Listicle). Please just no. * Polls, surveys, etc. unless from an accredited academic body or trusted source (StateofJS, etc.). Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/Nymrinae, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/obkladacka, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Please quote the insult.
Likewise. Though tearing existing components in their entirety and to just rewrite in a conceptually better style for the sake of it may not be as productive. I would suggest to start the practice (with functional programming, or any other techniques) in new features, or when a revision for existing ones is due. Look to apply especially functional hooks, if your dependencies tree is already locked at React 16.8+. They offer a simple interface to lead you onto (usually/hopefully) the best parts of functional programming with JS. Have fun!
A couple of great resources you can try: * Wes Bos &gt; [https://javascript30.com/](https://javascript30.com/) * Good fun actually building real life js projects. * Javascript Teacher - free js walkthrough &gt; [http://www.javascriptgrammar.com/](http://www.javascriptgrammar.com/) * Looks great - visuals always help me understand whats going on better.
This is a project where we're moving Adobe Experience Manager code and building Angular 7 components to replace that AEM code. And, we're writing the HTML templates, while there is a team in India, who is not highly skilled, who is writing the TS code. It's some of the worst code I've seen. When you open it in VS Code with ESLint/TSLint on, the files are just solid red from linting errors, just as a simple example. Multiple 'debugger' statements per file, hundreds of lines of commented out code that has not been removed after 2-3 months, nested nested nested if statements, etc. 
 [This might help üòâ](https://aforeverrecovery.com/behavioral-addictions/shopping-addiction/) 
Hahahaha! I do love shopping but this would be more for a business idea on buying and reselling. 
I see. And apologies for making a tunnel-visioned assumption of React (there was a brief mention in the article so somehow that impression stuck). In that regard I would usually apply the good old technique of slicing those flow controls (if/else/cases/iterations) into functions (pure or impure), and see if they can be cleaned up. At worst you can place them in an util module and reduce the overall visual complexity of the actual components.
&gt;You're still allowed to refer to the outer scope in a pure function. I think there's an argument that could be had here. Most notably, memoization. You have to have some kind of outside-function-level cache. That keeps the idempotency of the function (the same inputs will still generate the same outputs), but technically there is a side effect. In practice I consider it "pure enough", and oftentimes some dirtiness is definitely worth trading for massive performance. That said, it's good to point out this little inconsistency, because errors can sneak in. I've seen issues with Observables where the async nature of the initial call was necessary, and when the result was cached and returned with Observable.of(value) an issue appeared. That's because Observable.of is synchronous which can cause oddities in async zones and dirty checking. Now, you could argue that the cache was actually caching a different value and thus broke idempotency. That would be fair, but the dev in this case wasn't aware of that slight change, and so thought it was a pure function. I think in the end caching as a side effect is probably fine, but it is important to keep an eye on it because it can introduce complexity while appearing to be pure.
When I was googling the answer to my question some time ago, the answer (in other programming languages) was basically implementing event loop, but with recursive function, and pass the state to this recursion. In JS it would look like `function main(state){` `let IO = getIO() //somehow check input, like what keys were pressed, mouse coordinates, etc.` `let newState = stateReducer(state,IO)` `render(newState)` `return main(newState)` `}` &amp;#x200B; But in JS we don't have call-stack optimization, so we'd had to use the setTimeout trick to achieve this infinite recursion. 
You sound real upset.
It looks cool, but I can't move my cursor with the mouse...
Really? I'm not upset at all, actually. I wonder why I may sound upset to you. I've just pointed out something without using any sort of aggressive language or curse words, so... well, I wonder, really.
I like it! It's a great introduction level post with clear examples and explanation. I'll be sharing this with friends :)
It's really difficult for a reader of code to be sure that the globalArray is immutable or treated as such. `function createAddTaco(initialArray) =&gt; {` `return function() {` `return [...initialArray, "taco);` `}` `}` `const addTaco = createAddTaco(globalArray);` Would be a better choice here.
To answer your question, first check if the site has an API that lets you get the price + allows you to buy an item. If not then the best way I know how to do this if the site does not have an API you can use is to scrape their site for the prices and if it is on sale then send a request to the site to make the purchase. You can use node, [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) and [Cheerio](https://github.com/cheeriojs/cheerio) to scrape the site for the price and place the order. You can then schedule your program to execute every hour or so (what you want). There may be other services that scrape sites for you that you can pay for. You may want to search for such a service if you don't want to scrape sites yourself. 
You've got to stop saying "grok"
This isn't pedantic, I think. If the burden of purity falls almost entirely to the programmer, the purity isn't meaningful at all
Hi Kenman, I did attempt to find the correct sub and didn't see anything about asking questions in the rules. I'm fairly certain none of the other subs are appropriate: This is not JavaScript help, it is about resources/tooling related to JavaScript. It is not beginner content. It is not framework or library specific. It is definitely not html or css related. Could you 1. Point to the rule that says no help/questions and 2. Let me know where such questions should go? &amp;#x200B;
There's nothing wrong with rules engines. Excel based ones are the problem. Excel based anything is a problem.
I know what CI/CD is, I work on a team that deploys prod at least daily. That code makes its way through our pipeline before being deployed to hundreds of thousands of integrations in real-time. All of this can be monitored and halted/reversed with the push of a button. I promise, big shops with thousands of engineers use VSCode and even Vim and Emacs. You don‚Äôt need jetbrains when you have a legion of support engineers building tooling that is custom made for your pipeline. This is the norm in big multi-billion dollar tech companies. That said, IntelliJ is the best Java IDE in the market, and it is definitely used by the teams that are responsible for the bits of Java that we have in our codebase.
Thank you for that. I know part of it would be scraping the site but how would I go about the automated purchasing part of it? I don't want to have to do anything as soon as it goes on sale. So the flow is like Scrapes data for when price drops If price drops Add to cart Checkout. 
find out which HTTP requests are being made and what data is being sent in those requests when a purchase is made 
To me, it's /u/2bdb2 who sounds upset 
Should I be using like maybe a headless browser through all of this? 
Really cool. Nice work.
Very simple and concise tutorial. Nice work!
looks decent, but is there some reason to use this over native `JSON.parse`?
Hmm... Providing examples + talking calmly vs. ranting and providing no examples... Yes it's pretty clear who's actually upset here.
Because I want get the specific message or position when user inputs wrong json
1. function declarations like the second example get hoisted to the top of the scope, so you can call them even if it looks like they haven't been declared. ``` const one = getone(); function getone(){ return 1; } ``` Would work and one would have the value `1`. Don't do this though, since it makes your code harder to read. 2. Are you ever going to use `this` in your function? If not, it doesn't matter which one you use. 
At the top of the guidelines, and in the presubmission text, it has: &gt; # /r/javascript is not a support channel If you're not aware, _support_ is asking for help of any kind. &gt; This is not JavaScript help Yes, it is. You are asking a question about how to do something. That is the definition of asking for help. &gt; Let me know where such questions should go? Well, /r/LearnJavascript is one place. Maybe /r/webdev, /r/frontend, etc. as well.
Example 1 is immutable and can't be redefined at some other point in the code, but it has to be defined before you can use it. // This errors handleSuccess(); const handleSuccess = () =&gt; {}; Example 2 is mutable and can be redefined elsewhere, but it gets hoisted to the top during runtime so you can use it before you actually define it. // This works handleSuccess(); function handleSuccess() {} 
Declarative patterns are so beautiful. For front-ends at least, let me add a 4th step: Learn reactive programming patterns. I'm redoing a small app from a legacy (AngularJS 1.6) system using mostly RxJS 6 and it's BEAUTIFUL.
Hi /u/vishabh_goel, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Go through the checkout flow like normal, and note the steps that are taken, most notably the ids of the buttons that are clicked, the ids of the fields where the info in entered, etc. then use something like puppeteer to replicate that process in a headless browser. Not all field have ids so you may need to use other creative methods to locate the fields or buttons you want, but this should get you started.
I've tested your idea and I understood the use of both examples. Thank you!
{ "x": null } doesn't work but is valid JSON. 
Yup this is perfect. Thank you very much! 
&gt; If you go too crazy you end up with monads, an idea that is trivially simple to implement and reason about in imperative/OO style. What does that even mean?
 this.currentUser = JSON.stringify(user.user); Whatever `user.user` is, when you do `JSON.stringify` you're converting it to a String -notice **string**ify-. JSON.stringify(7); // -&gt; "7" JSON.stringify({}); // -&gt; "{}" JSON.stringify([1,2,3]); // -&gt; "[1,2,3]" class User { constructor(name, role) { this.name=name; this.role=role; } } JSON.stringify(new User("Mike", "developer")); // -&gt; "{\"name\":\"Mike\",\"role\":\"developer\"}" So, whatever you have in `user.user` you are, for some unknown reason, converting it into a string. Later when you read `currentUser` it will be that string. It will _not_ be a User object or whatever else you expect.
Hi /u/JohnJohnPT, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
As an example, having a class method Increment() that increments some internal count is trivially easy in OO, but will send you through contortions in a functional style.
Prior to switching to ES6+, I coded in 2000's jQuery-era JS. I'm very happy with the brevity.
You Saint 
That's implied by the mathematical definition of a function
Well, most of these reasons are holding true for spreadsheets as well. Especially ease of use and learning curve - you can't beat good ol' Excel since most people know pretty well how that works. And there is a plethora of training material if you don't. I don't see how documentation has much to do with this, since it depends on yourself if you provide it or not. But I'd wager that even there spreadsheets are winning the argument because people know what to expect from a spreadsheet. But I guess you had a specific point in mind? Version control with a static rule medium never worked out for me. Either use file based version control (git, tfvc) or don't use a static rule medium but wrap it in an import/export process that allows you to retrieve a versioned copy of the rules. But that really depends on your available infrastructure and your workflow, so generalized advice is not really helping. Also at least Excel comes with Tools specifically made to compare and merge spreadsheets. In some environments it's neigh impossible to even get modern browsers installed, and having to sift through 1200 lines of json with notepad isn't that fun. Debugging is usually not done in the medium you used to define the rules but in the executing code or maybe (if you have it) a validation step beforehand. It's really the same as with documentation - I have seen rule engines that do a perfect job telling you what you did wrong, others just expect you to do it right. Maybe I just misinterpreted what you meant. In some cases a purpose built rule medium is advantageous, but you can't dismiss spreadsheet based rule engines that easy. It depends on the proficiency of your customers and implementation engineers.
Same for: [ ] and [ ]
I found this an interesting little read today, explaining something i've always wondered about but never looked into. &amp;#x200B;
I still struggle with the concept of immutable variables in javascript. Even after reading articles like this i can declare: var str = 'hello world'; and then str = 'goodbye cruel world'; There i changed it. I've read that they are talking about the way javascript allocates memory? like the values don't get assigned to the same memory locations? not sure how that applies to or changes anything about how i would use variables in javascript. 
It's just as easy in a functional language/style if you're predisposed to thinking about it that way.
Some clarifications: &gt; ...But that doesn't work. And even more strangely, it doesn't trigger an error. It does throw an error in strict mode &gt; Apart from null and undefined, each primitive type (string, number and boolean)... Symbols should also be included. And all though you can't use `Symbol` as a constructor, you can still convert symbol instances into their respective object forms using `Object()` (which also works for other types as well) let sym = Symbol(); let symObj = Object(sym); typeof sym; // symbol typeof symObj; // object This is similar to [BigInt](https://github.com/tc39/proposal-bigint) which is right around the corner as the next new primitive type in JavaScript let bign = BigInt(1); // or 1n let bignObj = Object(bign); typeof bign; // bigint typeof bignObj; // object &gt; When we directly check the type of a string primitive we get "string" as expected, but when we check the type of this in a method executed on a string primitive we get "object". Again, something that changes with strict mode. In strict mode, you don't get the boxed value in methods, instead getting the primitive. String.prototype.reportType = function () { return typeof this; }; String.prototype.reportTypeStrict = function () { "use strict"; return typeof this; }; var fred = "Fred Flintstone"; console.log(fred.reportType()); // object console.log(fred.reportTypeStrict()); // string
In JS you can pass the object as the key. In this case ‚Äúsome_func‚Äù is the key. For example: let a = 10; let o = { a, b: 5 } console.log(o.a) // 10 console.log(o.b) // 5
Hello you can leave out the function with es6: https://dev.to/sarah_chima/enhanced-object-literals-in-es6-a9d
There is a problem with async, which is that it introduces a new type of function that is kind of like the normal type of function, but not. The benefits outweigh the costs though: we called it "callback hell" for a reason. If you use Typescript it will catch the kinds of errors you are most likely to make by reasoning incorrectly about a promise.
This is a [method shorthand](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions) syntax that's new with ES6 (though a similar syntax was available for getter/setter functions in ES5 too). The key there is `some_func` with `async` as a modifier declaring the function as asynchronous allowing it to use `await` and enforcing that it always returns a promise.
 var str = 'hello world'; var foo = str; str = 'goodbye cruel world'; I added a line. You can see at the end that `foo` is still `'hello world', even though `str`. What you did is point `str` to a new string object. The original one remains unchanged. var list = [1, 2, 3]; var foo = list; list.push(4); In this case, both `list` and `foo` have four elements, because you mutated the list itself. That's something you can't do to a string. For example, you can't add a character to the end of a string, only create a new string with the character added. 
While this is a shorthand for object key-value initializers, it is not the same as what is being used for `some_func`. That is simply a method shorthand. `some_func` does not have to exist outside of the object literal.
Thanks!!
`In JS you can pass the object as the key` Do you mean, you can pass the function as the key? was it a typo or am i missing some implied stuff here?
I think your co-worker is used to callbacks and doesn't want to adjust. Async await is the best thing that has ever been added to JavaScript
Yes. [Here's a headless version of Chrome that you can use with Node](https://github.com/GoogleChrome/puppeteer). 
I do automation with promises. Rejecting can be kind of annoying, as you have to create an entire new function to handle it. ex. This is nice and clean let ret = await myRestCall(); Unless the promise rejects. It almost makes me want to always resolve, returning an object resolve({err: null, ret: {...}}); But that's bad practice. Ultimately though, I prefer promises to callbacks and I'm sure a lot of other people are happy to not have to use `async.series/waterfall/etc` anymore.
Great point, my example doesn‚Äôt show that behavior
Yes, but in this case they are passing the function as a key-value and initializing it in the object. The key is the name of the function and the value is a pointer to the function code. You could just as easily define the function outside the object, and just pass in the name. Or you could do it in the object, as is shown in your example 
Er, I don't say this often but your coworker is plain wrong. Compare promise chaining to the equivalent with callbacks, it's a damn mess to reason about. And you can't pass around an asynchronous value to multiple consumers because your API only lets you supply a single callback function.
I almost upvoted you, but there's no way async/await was a better addition than arrow functions.
"pass the object" really means "pass the _variable_". If you use an existing variable in an object initializer list without a colon to separate key and value, the variable name is used as the key. So let a = 10; let o = { a, b: 5 } is the same as let a = 10; let o = { a: a, b: 5 } where just `a,` is the same as `a:a,`. It requires that a variable by that name (here, "a") is in scope for the initializer to have access. 
Everyone's entitled to their opinion, and every workplace has some divergence from "the hive mind". But that being said, the pretty vast consensus is that promises are far easier to reason about than callbacks, and the fact that your co-worker is dishonestly pretending otherwise because he prefers not to learn the newer/better way speaks a lot about him.
Just look `return new Promise((resolve, reject) =&gt; { ... }` At how pretty `var x = y = &gt; { return 3; }` They are `TypeError: this.execute is not a function`
Callbacks are incredibly difficult to reason about. I know of 0 node developers that prefer callbacks over Promises or async/await? Even Ryan Dahl said the callback structure was a mistake in the implementation of node. ------------------------------------------ I know some who dislike `async await` because many jr developers don't fully understand the abstraction that is occurring and can use it incorrectly. But I'd recommend asking your co-worker why promises are bad abstractions, I'd be curious to hear their answer.
I'm not really sure why the author calls out &gt;'By the way, did you notice how shortNames also became immutable in the process?' As in both examples they're immutable due to the const. 
Is there really evidence that the coworker is dishonestly pretending anything? Or that they haven‚Äôt learned promises? They may truly find callbacks easier to reason about. There are a lot of unfair assumptions here. 
I do performance work also.Have profiled bit of javascript apps related to angular.There are ways to measure what you are doing for. Browser Dev tools helps in profiling for both CPU and Memory. Just try that. For graphics, I am not sure as how how you are drawing but if functions are stateless and not tightly coupled then probably you can write some functions to measure timings by calling them directly. Just google How to measure browser graphics performance. I remember reading article on developers.google.com You want to follow similar approach.I don't think there is any commercial tool out there to measure all these metrics. If you have any specific use case let me know. 
Ok fair enough, I don't know the OP or their co-worker. But like I said, I think all programmers do this to an extent. There's what you're comfortable with, and what others are comfortable with, and you want to keep doing what you're comfortable with (again, human nature). To keep doing what you're comfortable with you have to make arguments that convince your co-workers, and the best way to do that is to sound as objective as possible, eg. "it's not that I don't like promises, it's that callbacks are easier to understand (when they're clearly not)". So of course, I don't know if this is exactly what's happening or not, but it's a pretty common pattern and again I think we all need to check ourselves for it.
Who cares? He‚Äôs entitled to that opinion. I like async/await &amp; Promises, but he may not. As long as he knows why he prefers callbacks.... not just ‚ÄòI do it this way‚Äô type of thing.
Including the gif would be a good start ;)
Yeah, I agree with that part of what you said. We like our comfort zones. 
Thanks for letting me know. But, I did, and I see it. Investigating. 
sounds like co-worker can't adjust or doesn't know how they(read: promises/async) work. reading pyramid of doom style code is far more obtuse than promises or asyc/await imo. a bit of devil's advocate, however. I do agree on a team codebase you want to keep it as simple as possible and avoid any cute _tricks_ for readability and understanding... but this is a bit too far imo.
I didn't love promises until async/await.
Comes in handy with structured code for example in VueJS you often see: methods: { myFunction() { .... }, myOtherFunction() { .... } } or such. You get used to it really quickly, b/c it's just very sugary syntactically.
It works on my laptop, but not on mobile. I added a direct link to the post. Thanks for calling it out.
That last animation happens right before the loop, and it's too hard to really look at the result. I'd either add more time afterwards, or stop the looping.
Once I gained a good understanding of asynchronous/await I use it when it‚Äôs still clear to others what‚Äôs happening. Fallback to promises. Only use callbacks if forced to do so. 
Thanks for the feedback. Good point. I'll adjust.
I like promises ... but that's just because I haven't bothered to dive into async await... but callbacks are no fun.
When an awaited promise rejects it throws an error.. you can use try/catch like you would with synchronous code. Maybe I‚Äôm misunderstanding you
I see it now üëç
I prefer async/await, callbacks, and promises in that order. I find callbacks to be the most elegant and simple to understand (and you don't suffer from callback hell unless you take shortcuts), but I can't deny that async/await is pretty great.
Will the next GIF explain WTF this has to do with REST ?
Your coworker is lazy.
Not sure what you mean by creating an entire function to handle rejections. Although I admit the syntax can still lead to tricky situations. For instance if you don't await a Promise immediately you can easily find yourself in "uncaught rejection" situations which can take a while to understand: ``` let promiseA = getA(); let b = await getB(); // if promiseA fails while waiting for B there's no one to catch it let a = await promiseA; ```
Not REST as in RESTful, but as in JavaScript (ES6) Rest Parameters (i.e. '...theRest' in the animation): [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest\_parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)
That has not been implemented yet, but it's not hard to do. Although, I am planning to change how cursor tracking is done to delegate to browser via contenteditable, once that's in you'd be able to move cursor via mouse.
Agreed. I've seen a lot of confusion caused by forgetting that async functions return promises themselves especially in `Promises.all(arr.map(async a=&gt;...))` etc and also by failing to await promises. Typescript will help catch that. 
The try/catch ‚Äúhack‚Äù ( I know it‚Äôs not a hack but it really feels like it) is my single biggest grief with async/await, as much as I love it. Most times I‚Äôd rather use promises and chain thens to one catch that handles errors than have try/catch littered all over the place. We need a better way to handle exceptions and a/a will truly be golden. 
Full-time Node developer since 2012. I prefer callbacks, though I understand both styles and work with both styles on a regular basis. To me, promises are a solution to a problem that never existed. I've never experienced "callback hell" because I understand how to do flow control with callbacks. Most popular npm packages, many of which are still relied on, were built using callbacks. Some have transitioned to promises; some are being deprecated. The ecosystem of promise-based packages is way younger than that of callbacks. To me, callbacks were clean and simple. Code was readable. Great libraries like `async` offered flow control solutions for almost any scenario. Now I'm forced to find new flow control solutions in a younger ecosystem. All for what - because some people didn't understand callbacks and developed bad patterns? Not to mention, you end up having to use libraries like `bluebird` because native promises don't have enough features. Essentially I see literally NO advantage to the switch to promises... I had no problem with callbacks, neither did anyone I worked with on several large-scale applications. Switching to promises has yielded no significant benefit in code readability IMO, while introducing ugly try/catches, util.promisifys, and younger shittier npm packages all over the place.
I can understand why people might think async/await is a bad abstraction, because it hides the nature of your code running in a separate continuation from being easily noticed. I can even understand having criticisms about the Promise API, because Bluebird continues to exist. But to think callbacks are better? What's his reasoning? Can you ask him and post it here?
Yeah sorry, I'll show an example Callback wise superagent .post(url) .end(function(err, ret){ if (err) { /* handle error */ } else { /* handle return */ } }); Promise wise you'll always have to catch and it isn't a pretty one-liner. let ret; try { ret = await superagent.post(url); } catch (e){ // handle error } Else you'll get `unhandled promise rejection error` And the bad practice always resolve let ret = await superagent.post(url); if (ret.err) { /* handle error */ } else { /* handle return */ }
I prefer async/await in some situations, but sometimes a callback makes more sense.
I love promises, but am not 100% a big fan of async/await. Guess the functional programmer in me doesn't allow an imperative abstraction to shadow a functional concept.
The "whole new function" I'm referring to is when catching: `var response = await promisedFunction().catch((err) =&gt; { console.log(err); });` I'd still take promises over callbacks any day, it's just a little tedious when I wish we could just do: `let err, ret = await promisedFunction();` But that's a python thing. 
Preach it brother. 
&gt;Even Ryan Dahl said the callback structure was a mistake in the implementation of node. Do you know what the alternatives were at that time? Did he say something about it?
Ooo close toss up for me. Async/await, arrow functions, and destructuring everything are my top 3. Hard to pick my favorite. Like if I had children and had to pick a favorite child. Or if I had pets and had to pick a favorite pet. Or if I had shoes and had to pick my favorite shoe.
Using try/catch is perfectly valid and I understand it but the whole idea of adding a scope to handle errors is very strict. I feel like I have no control over how my code will be organized. const url = "xxxx"; const response = await getData(url); if (!response) { console.log(false); } console.log(response.status); Compared to: const id = "xxxx"; try { const response = await getUser(id); } catch (err) { // console.error(err); console.log(false); } console.log(response); You're left to wonder: can I use `response` after the scope closes? I have to keep track if I used `var`, `const`, or `let` or if I made the right organization decision because the code looks hacky somehow. To avoid having to deal with try/catch I have to resort to this strategy: async function resolveOrDefault(promise, default, logError = false) { try { return await promise; } catch (err) { if (logError) { console.error(err); } return default; } } var response = await resolveOrDefault(getUser(id), false); console.log(response);
Ah. My apologies then. I was not viewing the word "support" the same way. Thank you for the sub advice.
i prefer promises to callbacks and async/await. async/await is designed for the common use case of asyncOperation.then(response).catch(error) but when people try to use it for something like asyncOperation.then(response).then(otherResponse).then(lastResponse).catch(error) confusion abounds
Normalizing catching rejections feels more pythonic. I didn't think we're supposed to throw errors willy nilly in JS
The number should be ~0.
He removed promises from the original implementation of node because he felt it should be minimal, but refers to it a foolish mistake. Watch the video here: https://youtu.be/M3BM9TB-8yA?t=307
Callbacks should be tossed into streams if your coworker wants to do things that way.
Even better: ```var sq = x =&gt; x * x;```
Maybe I misunderstand but you absolutely don't need to add try...catch to every await statement. What you describe as a chain of promises with one catch is also perfectly supported. ``` try { await ...; await ...; } catch (e) { } ``` And you don't need this in any function either. You only need to catch if 1. You can successfully handle the error. If you want the operation to fail, don't catch it. 2. You should have one top-level catch in your application 
Generators bruv 
Arrow functions are more than a pretty face, they have practical purposes too. Just like the classic function keyword has practical functions.
Added 5 seconds. Increases GIF size, of course, but sticking with it for now for portability/postability sake. Thanks for taking the time to comment!
When I started with Node, there were only callbacks. I was comfortable enough with them but enthusiastically picked up promises when they came around. I don't really think either promises or callbacks are easier to reason about, but promise code (and async/await code) is cleaner and easier to read.
I think your coworker means "promises are hard to reason about because I'm unfamiliar with them". Any time someone tries to tell me callbacks are just as good, I give them these challenges: Write a function that runs an async action on every value in an array in sequence and resolve the results in order. And fail if any action fails. Then do the same but run the actions in parallel. This is trivial without any libraries using async/await or even plain promises.
Async/Await is easy as f\*ck
Actually your solution with spread only works for relatively "short" lists. It will suddenly start breaking on chrome for lists longer than 65 536 elements, which is not that big when compared to what you could do with the reduce solution. Source: [https://stackoverflow.com/questions/22747068/is-there-a-max-number-of-arguments-javascript-functions-can-accept](https://stackoverflow.com/questions/22747068/is-there-a-max-number-of-arguments-javascript-functions-can-accept)
Disagree, it‚Äôs an imperative black box. Solutions like Ramda‚Äôs composeP are much cleaner and clearer. 
Oh, always resolving isn't bad practice at all. Using exceptions for control flow is bad practice, so it's definitely better to always resolve. In fact there are languages with task-based asynchronous programming that don't really have a concept of try/catch (Elixir), so that's the only way to handle errors and it works extremely well. JS is a bit lacking as a language, so you can't just do something like `resolve({ :ok, result })` then pattern match it somewhere down the line, but you could always approximate it with `resolve([ Symbol.for('ok'), result ])` then go back to using if statements and whatnot for control flow.
Why did you delete this post. It worked perfectly. 
I can't think of any!
I actually use all of them at my work. I don't tend to write my APIs using a callback style, but if I am using an API that asks for a callback I don't immediately feel the need to promisify everything. I will if nesting starts to snowball. Same with promises. I'll pull out async await if it makes my promises easier to read. Its about clarity. There is a benefit to sticking to one consistent style but as long as you aren't all over the place, you can use what works best. 
&gt; I think both promises and async await are bad abstractions, and harder to reason about. Fuck that guy - PrestigiousInterest9 
When showing async to people for the first time it's a good idea to shout "ASYNC FUNCTIONS ALWAYS RETURN PROMISES" at them once or twice
There‚Äôs a reason the term callback hell was coined
Or if you had categories of things from which you have to pick a favorite, and you had to pick a favorite category.
If he finds callbacks easier, then he hasn't done anything above a very basic level. There is no way that waiting for multiple things is easier with callbacks.
Hi /u/keetor, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/Deviso, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/nitinsh99, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Good to know -- thanks!
Hi /u/pantrynod, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
I'm exactly like you 200%... I've worked on a lot of pretty complex applications, and I've always just felt like Promises are some sugar sprinkled on top of Callbacks. If you organize you code correctly, you shouldn't run into "callback hell". Bring on the downvotes, but the really only time I ever use a promise is to use the fetch api... which I usually ended up wrapping in my preferred callback paradigm.
Me. I don't mind Promises but async/await is some sugary bullshit that is completely unnecessary.
Hi /u/thegrandechawhee, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
I feel the exact same way about ES6 class syntax. I know what‚Äôs going on under the hood with prototypes and constructors and application of ‚Äúparent‚Äù constructors, etc. I don‚Äôt like for my code syntax to paper over the real thing. And yeah, for FP, async/await feels so foreign and impractical.
Will do. Thanks.
Promises till I discovered async await then I never looked back.
Native promises have plenty of features. I've been exclusively using them in every project I've worked on over the past 5 years without a complaint. You could make the same complaint about the complete lack of standardized flow control for callbacks Sure you can reinvent sync flow control in an async world with a library or you could use promises and async/await and use the existing flow control that the language offers without relying on another dependency. You don't need to "find new flow control solutions" just use `Promise.all`, loops, and conditionals. That's the magic of async/await: it unifies sync and async flow control.
&gt; Callbacks are incredibly difficult to reason about. Well, since you mentioned async/await: There are times where you cannot reasonably resolve or reject a promise in time, and where you don't really _care_ about the result of a function, other than "the arguments you provided me were well-formed enough to let me start doing my stuff). In that case, a callback makes perfect sense: Return immediately, and call the callback whenever whatever job you started is done. I did pretty much this earlier today: A user agent calls service A, running on server A, asking it to perform a task. This task is handed over to server B, which can take anywhere from "A few seconds" to "A few minutes", depending on the complexity of the task at hand. In this case, it makes perfect sense for server A to merely validate the input from the user agent, and return as soon as possible. It makes equally perfect sense for server B to simply do the same with the request from server A. However, server B needs to acknowledge to server A what the end status of whatever command it was given, which is where a callback comes in handy: Merely register the callback, and call it whenever it's done with it's long running tasks (think: analyzing large log files, or start a lengthy build or deploy process. In other words: They're not hard to reason about or for, but they're not always the right tool for the right job.
&gt;and harder to reason about. w h a t
I like promises but I‚Äôm not a big fan of async await. Callbacks are a mess, although for a single use (not nested) they are good too.
Wash your mouth!
My preference is async/await, followed by promises and then callbacks. Though I‚Äôm not totally against callbacks - different tools for different jobs - if I find a package that has only callbacks support in the docs I‚Äôll move on and look for something else. 
I had the same thought as your co-worker when I first started to learn how to use promises. The abstraction of ‚Äúmuch like a promise it must be fulfilled/resolved...(or rejected? Who rejects a promise?)‚Äù is bit confusing. However, once you start working with promises and particularly if you wrap any asynchronous code with a promise the fluidity of its use becomes second nature...you don‚Äôt even think about the abstraction. Considering the real world headache that examining and implementing ‚Äòcallback hell‚Äô is, Promises and Async/Await imo are a much more practical approach than callbacks
What, no love for RxJS?
I don't know that I would call this gif helpful. I'm not sure if it was the format or layout or what, but I found it hard to follow even though I already knew what to expect. I wish I could be more help in terms of how to improve it, but I'm not sure. It just felt confusing instead of informative.
Well here's a case I ran into yesterday: I needed to run some parallel async functions and limit their concurrency. There's no concurrency option built into Promise.all as far as I know. What would your approach be? With callbacks I would just use the `async` lib and `async.parallelLimit`.
I was afraid that when I started reading these replies I would see a ton of people saying "me! I love callbacks" and I'm pleasantly surprised that it's the opposite.
I prefer not to use callbacks, but I'll play devil's advocate. Developing with JS can sometimes be like being in quicksand. You spend more time learning the latest framework, tools or refactoring code. And less time just getting on implementing run of the mill projects. So he probably just wants to stick at where he's currently at. As long as it's quality code and works it probably doesn't matter that much.
I think they're actually minor. What do they do? Save a few keystrokes and automatically bind 'this' context. Compared to async/await, the difference is major. 
I mean, for classes, I managed to learn them because of how frameworks make heavy use of their syntatic sugar. But I still prefer arrow functions, record-like objects and `this`-less programming.
I second this. I'm sorry that OP has to work in that codebase
What kind of madman uses var and arrow functions in the same sentence o_O
Because a 5 layer deep ".then" chain is way easier to read. 
Not that Im recommending the use of an external library because this can be done natively; bluebird's map function has a concurrency option. But, this particular thread is about native callbacks/promises anyway.
I'd use a [`chunk`](https://lodash.com/docs/4.17.11#chunk) function with `Promise.all` and a `for..of` loop: ```js const values = [ /*lots of stuff here*/ ]; const results = []; for(const chunkValues of chunk(values, 10)) { results.push(...await Promise.all(chunkValues.map(someAsyncFn))); } ``` You could re-use this logic in a function: ```js async function promiseAllChunked(values, asyncFn, chunkSize) { const results = []; for(const chunkValues of chunk(values)) { results.push(...Promise.all(chunkValues.map(asyncFn))); } return results; } const results = await promiseAllChunked(values, asyncFn, 10); ```
async/await, arrow function, and destructuring are what made me finally love JS more than Ruby 
I might agree with you if 95% of the code I've seen that uses callbacks is a mess and horrible to debug. Using `async` and `await` makes async code read like imperative code, and most of the code I've seen in that style is far more readable and easier to debug. 
There is nothing wrong with callbacks per se. They aren‚Äôt ideal for async a lot of the time, because of callback hell. But speaking purely from a functional programming POV, they are pretty kosher. Promise chains are basically chained callbacks instead of nested ones. The problem with async await is that 1) You can only await a Promise. The Promise API leaves a lot to be desired. Pretty restrictive. 2) You can only await in an async function. This causes ‚Äúasync‚Äù hell, where you now have to mark a ton of stuff essentially as a Promise. Also, async IIFEs feel so gross. Once you see that async await is just a native abstraction for the gen runner pattern many js libraries already have, you can mix &amp; match all of these so that the end result is the most expressive. 
This is my only gripe with async/await as well. Throwing and catching errors in seems like a bit of an anti-pattern in JS, being notoriously averse to errors from the very beginning. I may be the only one to think this, but I prefer returning error states when possible over throwing an error. No matter if you use try/catch or error states, the caller needs to handle errors in some way. It makes more sense to me personally to handle specific return values than catch errors, especially since it's cleaner to handle each error state individually.
I use both, callbacks are nice when you have multiple waiting steps, async/await made promises easy to use but hard to debug
&gt; I've always just felt like Promises are some sugar sprinkled on top of Callbacks The biggest difference is code written with callbacks jumbles inputs and outputs. Promises stick to the battle tested pattern of returning return values which allows them to act like regular synchronous functions when combined with `async/await`. I can't comprehend how anyone could prefer this: ```js getThing(1, thing =&gt; { getThing(thing.friendId, thingFriend =&gt; { console.log('Got the things', thing, thingFriend); }); }); ``` Over ```js const thing = await getThing(1); const thing = await getThing(thing.friendId); console.log('Got the things', thing, thingFriend); ``` 
Not seeing anything in the readme about nested modules. One of the things I like so much about Vuex is that I can split parts of the tree into separate files. One for layout variables such as sidebar expanded/collapsed, one for holding identity/profile data, etc. Is that supported?
Hello! Thanks for the reply. I think my coworker has a similar mindset as you, and the async library is used a lot in the API. I agree it is more bare bones, therefore you can follow it to more degree of certainty. and if you code it in a way that's not horrible, it's not close to as bad as people say. Personally, the use of async is parallel to needing bluebird, except nowadays there are very few cases where an additional library is needed at all. And you need async to do the most basic callback task. And ease of reading code is important. I think callbacks (and node in general) tend to make you not consider proper code boundaries... But that isn't a direct symptom of callbacks. There is a lot of patronising comments in here. Like my coworker is afraid to learn a new thing, lol. Although I don't like callbacks, but I get your point, thanks for responding.
I'm fine with it. It's basically just `do` notation. The thing that annoys me is that they limited this whole new syntax just to one thing (async), instead of making it a general interface (\*cough\* monad).
Until you need to pass intermediate values between `.then` closures: ```js getThing(1) .then(thing =&gt; getThing(thing.friendId).then(friend =&gt; ({ thing, friend }))) .then(({thing, friend}) =&gt; console.log('Got thing and friend', thing, friend)); ```
I actually don't mind it as long as you take your functions in your thens and abstract them. I personally think, ``` function doA() { } function catchA() { } function doB() { } function catchB() { } return request() .then(doA, catchA) .then(doB, catchB) ``` is a bit more readable than ``` try { let result = await request(); let aResult = await doA(); } catch (e) { await catchB(e); } try { return await doB(aResult); } catch (e) { return catchB(e); } ```
.then() &gt; cb()
You bet me to it üò∫
On a systemic level, callbacks are incredibly powerful tools. Being able to pass a function as a value (function as a ‚Äúfirst class citizen‚Äù) is a foundation for function programming. It allows you to compose (or pipe) higher order functions out of other types of functions. If you‚Äôre operating in a world where any function can do anything it wants to do inside the function body, and can take any random sequence of arguments, then yes, callbacks are very difficult to reason about and work with. And so is your application logic, tbh. But if 90% of your functions fall into one of 4-5 categories, based on their inputs, outputs, and side-effects, then callbacks can become an powerful and integral part of your codebase. You could write functions like this: ``` const processInputStr = pipe( parseInputStr, sanitizeStr, filter(byToken(‚Äú*‚Äù))(ToArray), reverseArray, arrayToString, cleanUpString, returnData ); const newStr = processInputStr(inputStr); ``` It can dramatically improve your testing experience, because the only way a chain of functions could possibly work is if they are set up correctly, and you will know instantly if something goes wrong. And you don‚Äôt have to wait until some random function happens to mutate your global object in order to detect a bug. Instead, you can just pass all kinds of data through your composed function, and if it comes out the way you intended, and handles all known edge cases, then you know your function is pretty rock-solid, and you can use it anywhere to perform more abstract operations. And callbacks make all of that possible.
No problem - I did see a lot of comments calling your coworker an idiot so I wanted to give my perspective. I wouldn't necessarily say callbacks are better... just that I prefer them. And of course some of that has to do with familiarity. I'm slower navigating the new world of promises because I'm used to callbacks. Ultimately, it looks like everyone is moving to promises, so I'm forcing myself to make the switch too. Maybe I'll like them better at some point in the future :)
bad interceptor. now its pointless to have known axios if you change the api like that. now imagine if you also were calling an api that was using the "json:api" standard which has data at the top level. now which data is data. [https://jsonapi.org](https://jsonapi.org)
Nice solution - thanks for the example!
Fair point!
Thanks - I'm learning more about bluebird and I'm liking it. I'm happy to use external libraries when they're good and they help keep things simple.
How are Promises a "functional concept" where at their \_very core\_ they are based on side effects and state???
Your co-worker is wrong, full-stop. async/await are an abstraction of promises - and _not_ a bad one. Promises are an _encapsulation_ of callbacks in a standardized, containerized form. Neither is harder to reason about than callbacks, and _both_ are a shit-ton more readable.
Promise is not a monad, though.
&gt; There is a problem with async, which is that it introduces a new type of function that is kind of like the normal type of function, but not. I think about it a different way: it's literally the first sniff of strong typing in Javascript. That is, if you have an instanceof AsyncFunction, you know exactly one thing about it: it returns a Promise. Every time. That's useful information.
Aw yiss, if we also had blocks... Many say block are not needed when you have arrow functions, but I absolutely love how Ruby allows using `return` and `continue` in `each`.
I think you mean `const sq = x =&gt; x*x;` &amp;#x200B;
I fail to see how it's similar to `do` notation. `do` expressions are something I can't wait to see, by the way
Callbacks, async/await, promises are all combined to maybe be the most annoying part of Javascript today. It's not a surprise that anyone wouldn't want to change if they understand 1 of the 3 well. Especially when really if you know one of them, you're going to be able to do basically everything. Everything is harder to read when you start. 
after working for the first 6 months of last year on a personal node project that was using the latest and greatest node available, and had await async, and all the nice things, i spent the next 6 months working on a project that required node 6, and doing all that work in Promises alone was kind of a fucking mess, compared to what it would've been with async/await. OTOH, if I'd been stuck with a version of node without Promises, I'd have just shot myself in the face. 
I mean the Haskell `do` notation, not the JS `do` proposal. Sorry for the confusion. See: https://gist.github.com/MaiaVictor/bc0c02b6d1fbc7e3dbae838fb1376c80
My only complaint about Promise.all is that you can't destructure it away from Promise.all. I assume it's because it needs a reference to Promise to work correctly.
Functional programming has side effects and state. Otherwise programs written in a functional style couldn‚Äôt do anything. Promises are a functional abstraction to create a composable way of managing asynchronous effects 
Not sure, reddit is not very big in Europe. I always thought of as 'that US thing'. I just started exploring it recently. Twitter, on the other hand, already had the JS community when I joined it few years ago.
HTML and CSS are REQUIRED if your goal is to do anything front-end. A big part of Javascript is manipulating elements from HTML, and another big part is manipulating classes and id's from CSS. So, no, you shouldn't automatically skip it, but it depends on your goals.
I'm not a functional programming expert, but Promises kinda pass all the criteria to being monads. I say "kinda" because instead of `map` and `bind` it only uses `then` for both cases. Also, I'm not that kinda fully pure functional programmer, I just like to isolate my side effects. But side-effect-wise, using Promises vs `async/await` doesn't make much of a difference.
Then you probably LOVE machine code. Stupid Assembly papering over my 0s and 1s
Ability to perform all your error-handling code in one `catch` at the end of promise-chain is not an advantage to you? What's a good pattern for that using raw callbacks?
Oh, sorry. I have very little Haskell experience. By the way, that is brilliant. Thanks for bringing this article up.
With promises callbacks are never the right tool for the job anymore. A promise in its simplest form is not much more than a callback, but with the option to extend the behaviour with rejections and/or proper error handling.
I was speaking to try/catch statements when using async/await, not promise.catch
You could still store the resolve callback in the same way and still return a promise 
I find async/await to be much more readable, and that's among the most important factors I consider.
But what if there is an error in the lengthy task? That error has no way of being returned to the caller which simply thinks that the task is being exceptionally lengthy this time. Sounds like the perfect use case for a promise to me. 
I do miss ‚Äòtap‚Äô from my rails days though
Interesting that you say that, considering async/await is very minimal syntactic suger around promises. If you understand promises, async await doesn't add anything new.
I love that I can build my blog pages in React. It makes running page specific code really easy, so I can just embed working code samples or experiments into the page.
Async/Await *always*. Unless you need parallel execution, then `Promise.all`. Callbacks are to be avoided at all costs. I will reject code that uses callbacks in review.
That's kind of the point, Promises are a nice functional abstraction over an inherently imperative concept, not the other way around.
In my own case, the error is sent back as a separate http request back to the origin. As I said, the job started is long-enough running that the sender cannot be expected to keep any network connection open while it‚Äôs being performed. There is an outer promise that handles acceptance or rejection of the original request. 
Except error handling ends up in try catch hell.
Promises don't pass criteria for being a monad, you can google it.
Because of [this](https://buzzdecafe.github.io/2018/04/10/no-promises-are-not-monads)? Then yeah, strictly they aren't. But they could've been. JS wasn't exactly designed with monad laws in mind. :) In any case I think it would have been feasible not to tie down the `async` syntax to a particular interface.
Agreed. I guess I'm not suggesting callbacks are bad by any means, but I've seen way too many functions where: function fetchEffect(cb) { fetch('www.somesideeffect.com', function(res) { return cb(res) // no idea what cb will do. }) } When used properly in functional programming, agreed that callbacks are incredibly helpful and easy to reason about especially when you pipe/compose your logic. It's primarily side-effects that callbacks become a problem.
Yeah that's why I said I just haven't gotten into it. Just not a pattern I'm using at the moment ... will pick it up sometime.
This article maybe explains why the author disagrees with you--mainly debugging, it seems. [https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9](https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9)
I know that (although I would contest it's as scary as you make it sound), I just disagree that it's "easy to reason about" in imperative code. Monads aren't the thing that "give you side-effects and state", you *could* have a singular and much simpler structure describing most of that functionality (in fact there was a time when Haskell didn't use monads). The value-added of monads is that they describe a common, abstract notion in computation (that of binding), not that they "enable features" themselves. This connects types to a whole myriad of cool features, like piping through a Maybe chain, traversing a data structure of I/O actions, explicit reasoning about computational context, and so much more. The point is, functional programming *is so much more* than sprinkling in a few maps and filters and some vague notion of elective immutability, it's what happens when you apply structure and mathematical rigour computation. And you can't really do that without going full-in which is what I suggest everyone try. It's definitely not easy in the beginning but it does become trivial, I guarantee you that no one who uses a pure language is bothered by the same problems that people who just stumbled upon the idea usually are, these issues get resolved early on.
If it wouldn't be tied to interface, then it wouldn't work with pre-native implementation, which would be a great shame as they are often vastly superior to native.
One line it to shorten it. Space it out to pretty it.
I never write callbacks nested like you have written here. It would probably end up something like this: &amp;#x200B; aMethod=()=&gt;{ getThing(this.\_getThingComplete); } \_getThingComplete(thing)=&gt;{ getThing2(this.\_getThing2Complete); } \_getThingComplete2(thingFriend)=&gt;{ } &amp;#x200B;
IDK, when you say Reddit is not very big in Europe, that‚Äôs what I think is weird. 
Yeah, I‚Äôve definitely gotten used to it for the same reasons. I just think they tend to pigeon-hole your class-creation patterns into one specific ‚Äúblessed‚Äù pattern. For example, you might want to inherit multiple prototypes from several ‚Äúparent‚Äù functions. The ES6 syntax doesn‚Äôt really allow that. You just end up modifying the class using some older techniques, which defeats the purpose of the ES6 syntax entirely. I‚Äôll admit it does look cleaner though, lol. And I‚Äôm with you on arrow functions. Definitely a much needed addition to the language.
It comes down to solving a problem at hand. If your API is simple and talks to database, using async/await or direct promises makes alot of sense. Testing will also be somewhat simple, compared to callbacks. Callbacks can be simple too, especially compared to direct promises (promises run when created, callbacks do not, and this is what async/await solves). Now, enter complex scenarios when you want to process thousands pieces of data in parallel, serial or mixed way. You will need to use a library of your choice to help you with that. For callbacks it is async.js, for promises it is Bluebird or Aigle. Pick and choose. But please do not simply blanket whole topic as "callbacks are bad". It is simply a tool. And certain situations prefer different tool. While I do like callbacks for their simplicity, I can also see usage of promises, but only with new async/await, if I don't have to construct promises directly via new keyword (remember, they run right away?) Those libraries I outlined (with exception of Bluebird which really tries to be a polyfill for Node's Promise) handle catching in their own way just fine. Whenever I see people mentioning try/catch as solution for promise/error handling/bad coding/act of god it is a very good example of lousy code (Promise.catch actually falls into that category too). And to those callback lovers, count me in. We exist :)
Here's the thing. There's people who space out their operations and there's Nazis. I mean that in the nicest way possible.
I think back to when I learned about both, and when I learned about arrow functions, I was like "oh... okay. nice i guess." When I learned about async/await, I nearly vomited because I just slammed out a bunch of garbage code without it. Async/await was the best for me. Not even close.
Yeah, I feel like people just need a bit of discipline (and training... looking at you, bootcamps) to consistently write functions that don‚Äôt completely pwn your application with side-effects coming out of left field. I guess that‚Äôs what code reviews are for, though.
Sure you're avoiding callback pyramids of doom, but your solution still lacks error handling and a way to signal that `aMethod` has finished. Add those and you get something like this: ```js aMethod = (callback) =&gt; { getThing((thing, error) =&gt; { if(error) { callback(error); } else { this._getThingComplete(thing, callback); } }); } _getThingComplete = (thing, callback) =&gt; { getThing2((thingFriend, error) =&gt; { if(error) { callback(error); } else { this._getThing2Complete(thing, thingFriend, callback); } }); } _getThingComplete2 = (thing, thingFriend, callback) =&gt; { console.log('yay?'); callback(null, {thing, thingFriend}); } ``` I'd argue it's significantly less readable and more error-prone than the 3 line `async/await` version.
I don't know that callbacks are much easier to reason about then promises. I like to use all three. Depends on what's the most readable thing to do at any given moment. 
Sooo... dont learn react?
```const xoxo = xo =&gt; xo*xo```
From the people I have had met, talked and had chance to actually sit down for a conversation (even over a PR) I've understood that majority of what they describe as "callback hell" is simply their inability to justify using a library to manage said callbacks. When you show how complicated some pipelines can be using promises, there is usually no argument since they are accepted as a norm (remember when callbacks were norm?). So we're looking at simple preference, not technical solution or even productivity enhancement. How many people actually involve other libraries to manage their functions/promises like async.js, Q, lambda, Bluebird, run-p or Aigle? I would love to hear more from people who actually understand why these libraries exist.
I think promises are better than async-await. Async/await is great for knocking out a few lines quickly. However I think it gets sloppy as you gotta try-catch which isn't better than having a 'catch()' in promises. With promises at least you can setup a bunch of operations and use one catch. But generally I don't overly favour one over the other. I do find that people who don't know how to chain promises tend to not have a preference. I think chaining is promises real power. If setup correctly they can be super clean and easy to read. Callbacks are great as well. You can a really clear call stack with your errors; but generally when I use callbacks I start implementing something that resembles a promise pattern (a utility that calls one function if successful and another on failure). I agree with the general consensus that it was an early attempt at handling asynchronous-ness of node and Promises were the winner during the inception but they may have been stubborn in not implementing everything as promises early. But my reasoning has nothing to do with the abstraction.... when I hear that reasoning its usually someone who has a stronger preference in the generator space might be coming from Java/C#/C. Really when I hear someone say that Promise/Async-Await is a 'bad abstraction' all I hear is "I don't get it". Every language has a preference for how it wants you to interface with it; if you don't get the abstraction that the language wants you to use... maybe you shouldn't be coding in it until you do.
You seem to be confusing creating Promises with using them. When you use `async`, it's just syntactic sugar for returning a promise, so they also "run right away". Calling `await` is the same as calling `then` on a Promise. Callbacks are analogous to only being able to call `then` once on an already-instantiated Promise object. Callbacks only run when they are called, just like the `then` clause only runs when the promise resolves.
Try Aigle. It is very similar to async.js Documentation is not that great, however it has many of functionality you would be looking as substitute. Welcome to callback lover club.
I prefer callbacks over promises, but in an await environment, I don't care.
Man, I really want to work with Swift, but it‚Äôs kind of niche for what I‚Äôm doing... seems like a cool language though!
This is not a repo but a codepen, showing my calculator. Hoping for some feedback, i threw myself into it with a lot of if/else conditions. [https://codepen.io/infensus/pen/eopJNY](https://codepen.io/infensus/pen/eopJNY) 
Nah, go ahead and learn it if you need it for work or whatever. Its learnable in a short amount of time. 
Not trying to be offensive but IMHO it's for two reasons: Twitter has social network critical mass and r/javascript is mostly comprised of newbie lurkers. Not many prominent bay area folks are on r/javascript. I only know of acemarke (of react/redux fame), arcanis (of yarn fame) and bterlson (of TC-39 fame) posting here on a semi-regular basis (and only on their respective topics of expertise, for the most part). All the notable bay area tech folks are on Twitter though, so that where they go to connect w/ each other. Almost half of r/javascript subscribers are new people (i.e. less than 1-2 years here). A lot are newbies to JS and very few here have original stuff to say (from the perspective of a senior level Bay Area JS person). Also, twitter as a platform lends itself more to informal social things like insider jokes than reddit.
Ha Hahahaha Oh lord. PROMISES WERE CREATED FOR A REASON
Well if you're from a C/C++ think function pointers (which is what they are under the hood!) 
The one thing I prefer about callbacks over promises is that they can be called multiple times. That's it. For single-shot callbacks, to me at least, promises offer a standard implementation of the callback mechanism.
Yeah, you just end up writing a long list of wrapper functions that essentially perform the normal imperative operation, just so you can use them in a `pipe`/`compose` function and reuse it. I often wonder how much those additional function calls impact performance... but you really can‚Äôt beat idiomatic function composition and reusability.
No. I am not confused by async/await. It is automatic promise creation without keyword 'new'. With async/await promise is only created when function is called. With direct promises you instantiate promise object with keyword new and off it goes. See the difference? Nuance of course for people who are not familiar with concurrency set up. About your example. You can pre-create promise for .then() chaining, so your promises may resolve before even starting chain. Not so with async/await function. let task = new Promise() ..... // more code here task.then(..) 
Async/await is just syntactic sugar over promises, so I think you like promises more than you realize. :P
You‚Äôre right about the need for total buy-in. FP requires discipline, but the overall reduction in technical debt is absurd.
Nothing is stopping you. Actually, functional is better with await. a(await b(await c)) Or just make a, b and c take promises as arguments. .then and .catch method chaining is just annoying. 
Callback hell is when backend is bad or the arhitecture in general is bad. There should be no reason to have 2 calls one after another. There should be in parallel otherwise why the hell use xhr in the first place. As in my workplace now look what backend decided its a nice arhitecture: Post data &gt; catch id in response &gt; post this id &gt; make a get in another xhr to get if the action was executed. So well this is a callback hell since well you have 4 calls that need to go one after another and every single one of them can fail... So yes, backend should design after frontend but in general is the other way around and well, this happens. This is bad in promises and callbacks no matter what.
&gt; With async/await promise is only created when function is called. ...which is exactly what you would do when using Promises directly. Again, async/await is literally just promises under the hood. Watch: Async/await: ``` async function getFive() { return 5 } async function useFive() { const five = await getFive() return five } ``` Is equivalent to: ``` function getFive() { return new Promise(resolve =&gt; resolve(5)); } function useFive() { const five = getFive() return five } ``` `useFive` returns a Promise in both cases, regardless of if you use async/await or not. They are the same.
I don't think anyone is arguing against using higher-order functions. Otherwise using `map` and `reduce` (and `then/catch`) would be discouraged. This thread is about the pros/cons of using callback args to handle async results/errors. 
I prefer code that i can read and understand. What happens when you're asked to go in and change something years later? Will you still understand all these condensed arrow functions?
Unfortunately, Ruby also has Procs and lambdas, which is super confusing
If I had to rank them, I'd rank them in order of preference: 1. async/await 2. Callbacks 3. Promises Mostly because I have an irrational and unfounded dislike of Promises. For whatever reason, when I first learned about promises, they didn't make intuitive sense to me, and I was like "Nope, hate it." On top of that, there are a **few** rare cases where callbacks are useful, but they are very few and far between, and almost always in very, very simple code that will be thrown away soon. 
I used Promises before without async await and it's still better.
Generators too
I understand the point you're trying to make, but well structured callback code can be reasoned about just as easily as promise chaining or even async/await. The issue is that getting well structured callback code requires quite a few utilities, e.g. The popular async module, lodash, et al. These utilities can address the issues you have with callback code succinctly, but it's still annoying requiring them all the time, no doubt about that. I'd take async/await over callback code any day - because the code is cleaner, without requiring utilities, but not necessarily would I say it's always easier to reason about.
Don't you have to go if(err){....then write the exact same code as you did in the catch block?
Or like when someone eats too much chocolate cake and then barfs it up
Well said. The async library makes dealing will tricky callback situations a breeze. 
the core deliverable of the current frameworks is the DOM reconciler. how do web components solve the case of moving dom node Z ahead of dom node A when the underlying data changes? it sounds like you still need either imperative logic to insert/remove sub-components or re-create the same reconciler that already exists in frameworks and ship it together with your components. the fact that web components have lifecycle hooks, "slotted" templates and DIY reactivity covered doesnt mean much, honestly. the main value provided by e.g. React is that you dont need imperative logic to wire it all together. do web components have any notion of "keyed" components that will re-order efficiently if the underlying state changes?
`const x=x=&gt;x*x`
Lmao OP is really out here fresh into a company trying to get them to rewrite all of their stuff. Hate when new guys pull that shit. Just do your work and shut it
I don't think you understand that I'm not arguing what Promises are and how they are compared to callbacks. I do understand that you want to prove a point. Look at my example. You have promise that is created, then some more code is executed which can contain creation of promises. With async/await you simply cannot do that since 'await' keyword will wait for resolution of your promise. Again to reiterate. I understand that you are bringing these examples due to either simply proving a point without anybody providing you the ask. Or you are simply confused how promises are even used.
Aren‚Äôt you cool
I like to think so
It sounds like your service example is referring to HTTP callbacks not JS function callbacks. Service B would likely call back to service A by sending some kind of HTTP request to alert service A of the finished job, but this isn't really the kind of "callback" OP is referring to. Internally, either service could be using callbacks or promises: - User agent sends a request to service A using `fetch` (promise) - Service A sends a request to service B using `request` (callback) - Service B runs a job and waits for it to finish (either) - Service B sends the job result to service A using `axios` (promise)
Callbacks &lt; async/wait &lt; promises Although I‚Äôll use async in certain situations I hardly use callbacks since I learned the other two methods
I LOVE destructuring and arrow functions. I came onto a NodeJS project last year that was handed over to me from a very senior, very functional-programming developer and looking at his code sometimes blows me mind. ES2015 and functional programming are so beautiful to read when used well!
Yeah that tends to completely undermine m8's credibility in complaining about new language features.
If a function takes a callback, you can't pass the value returned to multiple consumers. That's a pretty hard limitation that no amount of utilities can get around, afaik. Also the fact that you don't really have any flexibility around error handling; you have to possible call the same error handling code at every level of nesting. This means that you have far more code paths to consider, and therefore makes it harder to reason about. I can't see how callbacks can match Promises in terms of reasoning power.
Not Kyle Simpson!
&gt; With async/await you simply cannot do that since 'await' keyword will wait for resolution of your promise. You can do that, if you just don't call `await` until you need it. Async functions still return Promises. Async/await isn't "better" or "worse" than promises, they literally are Promises. You keep saying "promises get run immediately", but that's exactly what happens with async functions. They run when they are called.
All I know is (and I know what sub I'm on) writing code in Haskell or Elixir feels so much better than JS to me. I like the front end ecosystem JS has but I have a pretty passionate dislike for using it on the server side.
use both? if the callbacks are in the proper place and format you can use promisify. node has a native promisify now or there are a few packages that do it
To be fair though, shouldn‚Äôt ever piece of the system be self contained? I can understand the need for outside data to be fed in but the logic should live with the component imo. 
I agree with you, but maybe what the article is pointing out is that you no longer \*need\* a framework to make composable UIs. Frameworks like React will still have many benefits that make it worth using. I could even see a world where React changes its implementation of React.Component to use Web Components internally.
What company do you work for ? 
Word. Haskell is amazing!
Orlikewhensomeone bets the house on the ponies? Also r/unexpectedjohnmulaney
OP didn‚Äôt say anything like that. 
The dog, of course. Everyone loves dogs. **DISCLAIMER:** I like my cat best. The fish are nice too.
Can you possibly redirect it to which of these you might find best suitable, I'm on mobile and cant copy and paste.
that's a tough one for me too
I'll try to finish a tech plan during this weekend to adress this issue
I think it is not possible to block websocket that got upgraded from a secure https channel. WebRTC is a different story
As with anything, it‚Äôs all about the right tool for the right job. Sure, there are contexts where overly condensing a function into some obscure one-liner decreases readability, but there are definitely plenty of situations when arrow functions are arguably _easier_ to mentally parse and understand at a quick glance. e.g., ``` people .filter(person =&gt; person.age &gt;= 18) .map(person =&gt; person.name) ``` vs. ``` people .filter(function(person) { return person.age &gt;= 18; }) .map(function(person) { return person.name; }) ```
I'm developing [https://foda.app](https://foda.app) for 5 years and never found need for promises or async. But I guess it's about how much the callback abstraction feels intuitive to you. I find it very good but I do see a lot of ppl struggling, and I do agree that they should search their own ways. 
Damn I just literally started a project like this..... well time to scrap it
No joke, I had to convince someone to use arrow functions. He was so close minded
Do you have any examples of good practices that has good patterns that we should adopt? Or any resources that will help me better understand how to improve readability when using callbacks and not reach "callback hell"?
You're gonna have a hard time convincing me that `this ain't the best ${thing} ever`
Yes, I will, because there's practically no difference between "condensed arrow functions" and `function` keyword functions. And where there is a difference it's usually in the arrow function's favor (lexical scope, aka "you know what `this` when reading the function"). And map/filter/reduce with inline predicates is very idiomatic across domains and languages.
What a fantastic piece of Programming Software! üòÄ
What's the difference practically? 
It doesn‚Äôt fit for all situations. It will be freezing if asyncFn doesn‚Äôt have constant O(n) time. I would use something like worker‚Äôs promise which gets one value/function from array/queue and runs it with await/then. Workers should resolve after queue is empty so you could spawn as many workers as you want and put them in Promise.all() which resolve after all tasks are done. It should be parallel and shouldn‚Äôt freeze. Ps. Sorry for any mistakes in my English but writing without keyboard and translator is hard for me
How is error handling more succinct without async/await?
&gt; Callbacks can be incredibly difficult to reason about -- especially when dealing with side-effects. I'm not really an FP guy (was originally a Java/OOP guy who has become mostly JS developer the last couple years), but I thought FP was generally about eliminating side effects altogether? 
I would still learn it because most jobs out there use React.
Actually it's a big problem for that development team if one member insists on an outdated approach that significantly impacts the maintainability of the codebase. In fact, if he can't convince that developer to change his ways then he may want to reconsider taking the job.
Hey anon, I‚Äôm a little bit curious, how would you implement something similar to promise.all with callbacks? 
Thanks, I have already fixed this bug
Thanks, I have fixed it.
I use promisify for callback's..
I don't think your co-worker is an idiot at all but I would say that if can't convince him to change his ways then you should actually consider backing out if that job. Because callbacks are going to reduce your code maintainability significantly and having a problem like that right off the bat makes it seem likely there will be more serious issues like that.
The happy path ends up in the then function, the sad path in the catch function, letting you read through the happy path to grok the ideal outcome easier. Async/await by its nature reads more imperative. It's a preference thing but I stylistically I write more functional code, with data flowing more cleanly through functions if it exists/is valid, vs kinda "littering" the happy code path with error handling.
i think the following async alternatives may be better: async function processInput(str) { let result = str result = await parse(result) result = await sanitize(result) result = await clean(result) return result } async function processInput2(str) { return Promise.resolve(str) .then(parse) .then(sanitize) .then(clean) } async examples(str) { try { const result1 = await processInput(str) const result2 = await processInput2(str) } catch (error) { error.message = "process input error: " + error.message throw error } } i think the best part about async/await/promises is the elegant error handling, which bubbles up nicely and is easily catchable callbacks require every error to be handled explicitly on-the-spot (error-first) new async code practices fix the error handling by allowing us to cast a wide net to catch errors at a higher level in the application
But promises are just objects with predefined callbacks.. It's not a bad abstraction- it's a standard!
using call backs, never have time to 100% understand and master it so I avoid it for simple things... ... if anyone has a really good tutorial/example link for me that explains the under the hood... make my day ;)
i think this is the right way of thinking about it going forward when i see a callback, i expect it to be called multiple times: otherwise it would be a promised result an "onProgress" callback is a good example use-case
Essentially same reason PHP gets much hate then? You can write really disgusting shit with it and thus, people did and now it has a bad rep.
So long as things are typed - I'll work with whatever.
&gt; callbacks are just as good as fancy async stuff! &gt; &gt; *but then what about the error handling?* &gt; &gt; i just.. i just don't really do much error handling... &gt; &gt; *ok bye!*
He‚Äôs wrong. Async / await is quite simple, as are promises, and they lead to cleaner and less error prone code. 
&gt; There is an outer promise that handles acceptance or rejection of the original request. huh, so you are using promises? i strongly suspect your use-case would be elegantly served with promises you mentioned "returning right away", which is of course possible with promises const promise = Promise.resolve() .then(someLongTask) console.log("right away") await promise console.log("finally done now") as u/davesidious helped point out, the differences between callbacks and promises seem to be: - promise errors bubble up - callbacks can be called multiple times because of the superior error handling, promises should always be preferred, and callbacks are necessary for things like progress update handlers, events, and the like
Or like when someone buys too many scratchy lotteries. 
Two. One to write the callback and the other to
hmm. I guess i don't understand what's preferable about then/catch compared to try/catch. I use both since i do both backend java and frontend javascript but it seems equivalent to my eyes.
have you looked into lit-html and LitElement and lighterhtml? and my personal favorite -- haunted these are very thin libraries on top of web components that use template literals to replace JSX natively -- it's amazing actually also, these libraries allow you to, optionally, plug in a virtual dom library to optimize your performance very cool stuff, i've been catching up on it recently watch this space! PS, imo, shadow dom is useless until the shadow parts features land, because parents need to be able to apply styles to children, which seemed to be a major oversight by the initial shadow dom spec so in the meantime, folks like me are disabling the shadow dom and rendering only light-dom components for now, which is a convenient option in say, haunted *sorry no links on mobile*
learn haunted instead, stay cutting edge mate!
My dad always said that he liked me best after the dog. I had several of his other children beat, including the ones we never found out about, as well as other pets.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/webapps] [Add PWA Featrues to any website with this lib](https://www.reddit.com/r/WebApps/comments/b9lkde/add_pwa_featrues_to_any_website_with_this_lib/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Try/catch becomes an inline block so to speak, and often the happy path can only continues in the try block. Then/catch the logic flows through then functions cleanly, putting all the messy error stuff in catch functions.
How about... ‚Äò‚Äô‚Äô function isAdult(person) { return (person.age &gt;= 18); } function getName(person) { return person.name; } people.filter(isAdult).map(getName); ‚Äò‚Äô‚Äô (Not sure I would do this exactly, but I think it makes the last line pretty readable.)
It was easy enough to add so this sample can be correct.
Maintaining `this` context is pretty huge.
yes, i'm familiar with these. personally, i'm not a fan of stringly templates - i'm more in the hyperscript / pure javascript camp. besides, my library (domvm) does a bit better than lit-html in the perf department, too [1] ;) but tell me, if i still need a frontend library to work with web components non-imperatively then have they really removed the need for frontend libraries? [1] https://krausest.github.io/js-framework-benchmark/current.html
I found this tiny library great for controlling concurrent limits with promises. [https://github.com/sindresorhus/p-limit](https://github.com/sindresorhus/p-limit#readme) I enjoyed reading the code for it to, learned lots.
I'd pick right.
OPs edit should have been the top reply to the comment they suggested rather than the comment itself
Something like puppeteer would be a reasonable tool to make the purchase. And you can have a scraper service that periodically checks prices by searching the dom the for their values. You might even want to incorporate a payment / banking api such as stripe or plaid depending on your scope. The big issue I see is if the website you're purchasing from supports this as they often prevent this with captcha tests. Amazon might have a API that things like Alexa use but I think that's specifically for reordering something you frequently buy. 
You're not wrong. But... You can do a bunch of amazing shit with GOTO statements too. Amazing power and good, sane software engineering don't necessarily fully overlap.
Preach
I'm a much newer JS developer, only been doing it since 2016, and it's my first async language. How do you handle scenarios where you need to do 7 or 8 tasks in order without promises? I've only ever seen callback hell as the solution to that problem
Perl, too
&gt; I don‚Äôt like for my code syntax to paper over the real thing. Then just write in assembler and get the real programming experience. All higher level language paradigms are papering over the real thing, why not allow something as awesome as classes to enable you to encapsulate, extend, and architect your structure relationships into your syntax?
at work, we are still on node v6, so we use callbacks and caolan's async library. We don't use promises and prefer using the async library because its much more readable imo, and also we try and keep to a coding guideline (so no promises)
&gt; For example, you might want to inherit multiple prototypes from several ‚Äúparent‚Äù functions. I didn't think JS really did function polymorphism, I thought it was the required-first approach that had you sending optional arguments later in the param list?
Saying ‚Äúit‚Äôs fine if you use it correctly‚Äù doesn‚Äôt quite hold because you could use that logic to defend most anti-patterns, most deprecated features, most bad practices in coding. That being said, even if you do it ‚Äúcorrectly‚Äù in a way that doesn‚Äôt create callback hell, the code flow is generally far less readable in my experience. Something as trivial as an asynchronous function call to get some data or to mutate an object shouldn‚Äôt always divide your code into multiple smaller functions. Callbacks force you to divide logic in a sometimes unnatural fashion, and you have to make an extra effort just to salvage some level of readability.
It's using latest ES2019 features like class fields to make process of custom errors creation simple. Custom error creation: ```javascript import Error3 from 'error3' class NotFoundErr extends Error3 { code = 'fs_not_found' format({ filepath }) { return `File "${filepath}" not found` } } ``` Usage: ```javascript const error = new NotFoundErr({ filepath: './index.js' }); error.toString() // -&gt; "NotFoundErr: [#fs_not_found] File "./index.js" not found" error.message // -&gt; "File "./index.js" not found" error.code // -&gt; fs_not_found error.details // -&gt; {filepath: './index.js'} ```
Or like when someone smokes too many cigarettes?
It is, but not in comparison to async/await, I think, mostly because async/await adds new capabilities to the language whereas arrow function is syntactic sugar for stuff that already exists within the language. 
Sure, not disagreeing with the relative important of a/a, just that the scoping is non-trivial.
Why not just use all of them at once? function killMe() { return new Promise( async (resolve, reject) =&gt; { try { const whatTheHell = await ohGodWhy(); resolve(whatTheHell); } catch(err) { reject(err); } }); } const seriouslyKillMe = (input, callback) =&gt; { input = whyWouldIDoThis(input); callback(); } seriouslyKillMe(somethingAwful, killMe); Oh. That's why.
 function promiseAll(asyncFns, cb) { let n = asyncFns.length; const result = new Array(n); function loop(i) { if (i &gt;= n) return cb(result); asyncFns[i](function(y) { result[i] = y; loop(i + 1); }); } loop(0); } I defend nothing about that code. It used to seem simple and natural to me.
Promise is a little complicated in its syntax, but I love async/await syntax
Unfortunately I can't help I can only commiserate. Dealing with iOS safari issue for getUserMedia to record audio was a nightmare, and continues to be kind of screwy. It's really frustrating that Apple just blocks access to media devices outside of safari proper. Can't use "Chrome" or a PWA because the mic is silently blocked in WebViews. Safari really is the new IE.
Filtering intellisense is the big win for me
Is there something listening on localhost:6030 ? 
Meter updated to work in stereo.
0 of them prefer callbacks.
Doesn't this mean asyncFns are called one after another, since you call next function in a callback of the current one?
React, Vue and Angular are the most popular in the job market, so just choose on of them. I don't think we components will replace anything any time soon. 
machine code? ha! real programmers code in cpu firmware
Touch√©
From your point of view everyone is wrong - ES standartizatiob organization, users that asked it and half of the community that felt like call backs is hell, and it's so funny to read. Yeah, you may be right used to it, but it's not saying it's better, right? If you're used to get punched into face and know how to take that punch with minimum DMG doesn't mean that taking it is something good? 
Do people enjoy them because of the automatic `this` binding? I find the syntax cryptic
Ok I can look at it if you want 
Arrow functions are pretty solid. I like `document.write` though. You can just put things on the page - like words!
Which part of it feels "simple and natural"? That one with if statement that depends on the on variable outside of the function scope?. Or that part where you pass function as a parameter of the function that are called in side of other function? 
 somePromise .then(fn1) .then(fn2) .then(fn3) .catch(errhandle) versus let passableValue; try { passableValue = await somePromise() } catch { handleError } let { passableValue = await fn1(passableValue) } catch { handleError } // you get the picture
There is a very small number of edge cases where you actually need callbacks, otherwise async/await is the way to go unless you have a really strong fondness for syntax trash. Async await usually is a bit less clean when using debuggers (+ source maps), but not a reason not to use.
Improvement! try { const promise1 = processInput(str) const promise2 = processInput2(str) [result1, result2] = Promise.all(promise1, promise2) } Now processInput is not blocking processInput2, but rather they can run in parallel.
&gt; The one thing I prefer about callbacks over promises is that they can be called multiple times Can you give me an example of this? I'm failing to wrap my head around it. You can define a function fn1 and then use it over and over again with promises: somePromise.then(fn1); someOtherPromise.then(fn1); You can also reuse the promise itself: let p = somePromise; p.then(fn1) p.then(fn2) fn1 will operate on p's return fn2 will also operate on p's return depending on whether p's return is a primitive or not, fn1 and fn2 will or will not be independent
What year is it?
You can never eliminate them altogether. It's about containing side effects to small surface area of your program.
React isn't a framework but a library. 
Dude, you're wrong. Pay attention to the guy explaining things to you. He's right.
It is actually the opposite: async/await is just sugar around Promises whereas arrow functions are behaviorally different. 
&gt; (Forgive my code formatting, i dont know how) For future reference, you put four spaces to the left of each line of code
I actually do prefer callbacks to promises. But, I prefer a sync/await to callbacks. I can't really give any rationale for it though, it's just a preference. Then again, I honestly prefer classic function structure to arrow functions, but I seem to be the only one on Earth with that opinion, so what do I know.
Christ! You just invalidated your earlier point with that dumpster fire. 
I think the point here is that the loop is blocking. The setTimeout functions have to wait until the stack is empty to be called.
Meanwhile I'm sitting here with IE11 which don't support ES6 let or const...
"timeout function callbacks" isn't referring to the function \`setTimeout\`, it's referring to the callback you're passing to \`setTimeout\`. There's nothing unusual going on with the \`setTimeout\` function itself, it's being run in the loop. &amp;#x200B; You're saying "hey \`setTimeout\`, here's a function. Can you please call that function for me in X seconds?", and setTimeout says "OK, I'll do that at some point". Then the loop continues. But setTimeout hasn't called the function you've passed it - that's done later.
Thanks for the reply. &amp;#x200B; So why is there a call stack issue here? I thought JS executed asynchronously -- why can't the \`setTimeout\` callback and the loop run concurrently? 
I guess I'm still confused. Why can't `setTimeout` execute its callback until the loop ends? Like, if the `setTimeout` duration is set to 0, it still has to wait until the end of the loop to execute.
&gt; why on earth do the setTimout functions not run until after the loop ends? No other function runs that way Uhhhh... Read what setTimout does. It waits for the time in milliseconds before executing. If you're saying why doesn't it block the loop until the time passed well I can say it's because nothing blocks in javascript. This is so other code can execute and the page doesn't lock up waiting for something. Hope that helps.
PHP has a [lot](http://phpsadness.com/) [more](https://whydoesitsuck.com/why-does-php-suck/) to hate than that. 
Your arrow functions and async/await can both shine the array methods shoes.
This is the best discussion of the call stack and the event loop I've encountered: https://youtu.be/8aGhZQkoFbQ 
 const isAdult = person =&gt; person.age &gt;= 18; const getName = person =&gt; person.name; people.filter(isAdult).map(getName); Or, with destructuring: const isAdult = ({ age }) =&gt; age &gt;= 18; const getName = ({ name }) =&gt; name; people.filter(isAdult).map(getName); But still I prefer: people .filter(({ age }) =&gt; age &gt;= 18) .map(({ name }) =&gt; name);
tbf though, arrow functions are always anonymous and can make debugging trickier. see this part of Kyle Simpsons *Functional Light JS* - [What's in a name?](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch2.md/#whats-in-a-name)
The function `setTimeout(f,delay)` runs the function when delay milliseconds have passed. When this time passes, the loop counter is at 6. &amp;#x200B; The loop is sync code, that means that as soon as setTimeout returns, the execution continues normally. setTimeout does not work like sleep() in other languages, it runs asynchronously which makes it run later. &amp;#x200B; If you used only console.log you would get the expected answer (without the delay of course) because it's a sync function. &amp;#x200B; If you want to use the async setTimeout and get the expected results, there are two ways: * The way useful to learn JS that is using closures, which "binds" the i to the current value * Using a less known parameter to setTimeout, to make something like: `setTimeout(function timer(i){console.log(i)},i*1000,i);` which runs timer(i) with the current i value. &amp;#x200B; The reason of why it would still run with timeout 0 is that JS engines only run the async events (timeouts, i/o, etc) when there is no sync code running, that is why a infinite loop would avoid any timeout from running. &amp;#x200B; For example the following code will never print a single value: `for (var i=1; i&lt;=Infinity; i++) { setTimeout(function timer(){ console.log( i );}, i*1000)};` &amp;#x200B; The infinite loop will avoid any "nothing to run" moments where JS runs the timeouts.
I've really only decided to use either when I come across where either would work better with the rest of my code on the spot. When I discovered asynchronous functions I was pretty excited to use them, but now I don't really have a preference. Don't know if that's good practice though... Usually when I'm pairing with another coder we will use their preference if they have one, since I'm indifferent. Sorry, I don't think that answer will answer your question, but I assume that for when you're working on code for your workplace, you can stick with what your fellow coders prefer. It will avoid any conflict on the issue as well, as some people are reeeeally opinionated on things like this. Haha
It's the underlying implementation of setTimeout. It's not that setTimeout *can't* execute it right away - it's designed not to, even if the delay is zero. It always puts the function aside for later and lets the loop finish. There's no technical reason why setTimeout couldn't be rewritten to immediately call anything with a delay of zero, except it would break every website out there that depends on that behaviour.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block
I‚Äôm using an express server listening on port 6030
 function all(fnArray, cb) { let results = []; const tickle = (...args) =&gt; results.push(args) == fnArray.length &amp;&amp; cb(results); fnArray.forEach(fn =&gt; fn(tickle)); } use it like: all( [ cb =&gt; cb(1), cb =&gt; cb(2) ], data =&gt; console.log('mom im done', data) );
Picking favorite child or pet is easy. Saying it out loud is hard.
I love that so many of these types of questions about web tech ultimately end with 'it could be otherwise.. &gt; except it would break every website out there that depends on that behaviour.
Do a search online for the Producer-Consumer design pattern but pay more attention to the Consumer end of things. How that gets implemented would be the ideal solution. &amp;#x200B; Essentially you have a serial queue that all your operations get added to. When one operation finishes, you check the queue to see if there's anything left. If there is, you continue onto the next operation in the queue, otherwise you're finished.
I‚Äôm sorry, but I‚Äôm not quite following what you‚Äôre saying. Could you elaborate?
I‚Äôve been writing JavaScript since 2001, async await is almost the best thing that happened to me other than TypeScript in general. Frontend is practically fun again. Your coworker either doesn‚Äôt understand promises or is just generally stubborn. I have new APIs that don‚Äôt offer at least the option of promises (some APIs offer both a callback signature and a promise one) 
And there is rawact. It's more likely that frameworks (even existing ones) will just comile to webcomponents if one intends it to be a web component. And secondly, there isn't much incentive to go web components, unless one is making a component library, and want cross framework support. But cross framework support is quite rare requirement.
Callbacks and async/await "behave" differently. I would never argue using one over the other in all cases (at least for myself personally). Sometimes I have found practical situations to use async/await and other times I have found practical situations where callbacks are more suitable. Javascript is single-threaded as far as I am aware, so it confused me since I was originally was exposed to async/await from C#. &amp;#x200B; Does your co-worker know how to use Promises and async/await? I had to use them in a few simple cases before I became comfortable with them. Unless you've worked with them before and see for yourself how it changes the flow of your code it is hard to make harsh judgements - such as claiming that it is a "bad" abstraction. Did he explain why he thinks that it is a "bad abstraction" or harder to reason about? &amp;#x200B; I guess if you get the program working correctly it doesn't really matter which you end up using. As this thread demonstrates, people have their preferences. If you can come up with a more elegant solution using one or the other, then that's probably good enough. &amp;#x200B;
I don't think its a matter of perference for me. It's situational. I'll go with async await first. some cases need to fall back on promises and their utility. Then, even fewer times, callbacks are a better situation. They are all tools in your development toolbox. learn to use them and do go down the preferential route :)
I can‚Äôt upvote this enough 
I'd say they're about equal for me. I would be devastated if either were removed
...is increasingly evolving into a universal programming language, allowing Javascript developers to program for almost any application...
Good for Lisk.
uuh, just wrap it all in a try/catch? let passableValue; try { passableValue = await somePromise() passableValue = await fn1(passableValue) passableValue = awiat fn2 passableValue = await fn3 } catch { handle }
Passing a function as an argument isn't a callback. Callback is a function that is executed once an async operation is finished.
Should be able to do 4 line breaks prior to the code. Save you some time. 
`const result = await myAsyncFn().catch(() =&gt; null)` Async functions return a promise, they work with `Promise.all()` as well.
Link where?
Link?
That's quite a big reaction to a small problem, in my eyes. &gt; In fact, if he can't convince that developer to change his ways then he may want to reconsider taking the job. Not taking a position due a single paradigm not being to their liking is a huge red flag to me.
It‚Äôs been amazing for years...
Oh, I added the link!
Not really. One definition of frameworks Vs libraries is that you call a library, while a framework calls you. In that sense, React us definitely a framework, since you hand react your component tree, which react calls internally.