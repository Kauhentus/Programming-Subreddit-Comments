scope-creep
A lot of people prefer functional programming. `dayjs` is not functional, `date-fns` is.
Only use ternary operators if there is a need for it, they can get messy to read. I dont think colons make enough to express what is going on there. KISS
More. Trust me you’ll get very very used to it! Make sure you’re using prettier so that formatting doesn’t sway your opinion. Also you have to keep in mind there is an actual different between the two: lexical scope. Using arrow functions by default will make the side effects of your code more intuitive, readable, and scalable. 
 I am going to have to Google what’s “lexical scope”. I know that if the internal code is one line, you don't need {}. I know that if no arguments you can use an underscore. I know that if there is only one argument, you don't need the (). But I have no idea what you means by “lexical scope”. 
If I want a new`this` I use `function`. If I want to reuse `this` I use `=&gt;`.
Everyone here is so much smarter than me...it's a humbling experience. 
I think you get too bogged down with semantics - JS Sets are not the same as sets in mathematics. They are basically arrays.
1. It means an arrow function is fully under the scope of the enclosing function, including the value of `this`/ 2. Correct. 3. Not technically correct. It's just a convention some people take from functional languages. In JS, an underscore can be used as a variable name just like any other Symbol. Some people use it to indicate that the argument doesn't matter or shouldn't be used. 4. Correct.
Don't worry. You'll get there :)
Sorry if you don't mind me asking, I don't even think you could know the answer since you are not the developer of three just but I will ask anyway since you have experience using it. Why does three.js API keep on changing ? Was it really that badly planned at the beginning ?
There is a source code archive link at the end of tutorial. You can download it and run it within seconds. The reason there is no demo is because JSFiddle, Codepen or any other don't allow uploading custom resource files for free and in my tutorial, I load characters from an external txt file. Because there is no demo, I added a gif animation which shows how the effect looks like (also at the end of the article). Next time, read the whole article, and think before criticizing, please.
Honestly its MUCH more readable to use the arrow function. You get the 'correct' this for free. And also once you start using it all the time it will become more readable very quickly. If I was like your teacher or something I would insist you use only arrow functions because I know eventually you will see why they are so much better. You just have to trust us when we say just keep using them, you'll thank us later. 
Move element with index ‘dnum’ To the front. Might do what you want or might not, zindex is a bitch
Also, performanter (function calls can be expensive!)
If `dnum` and `nwich` are equal, assign a `z-index` value of `tp` element to 3. Otherwise 1.
A ternary operator is shorthand syntax for writing if/else statements. ``` if(num1 &gt; num2) { console.log(num1); } else { console.log(num2); }; ``` Is the same as: ``` num1 &gt; num2 ? console.log(num1) : console.log(num2) ``` After the statement is written, the result written past the ? symbol will be the result in case the statement is correct. The colon represents the result if the statement is incorrect. Hope this helps!
damn dog, you are just totally embarrassing yourself out here. take the advice of... literally everyone replying to you and read up on this
The long awaited Rollup 1.0 is almost ready! [https://github.com/rollup/rollup/projects/1](https://github.com/rollup/rollup/projects/1) They have been updating the docs and plugins, maybe give it another try when it is out? If you are using ES6 modules then Rollup is the easiest to use! I think it would be cool to add that to your review. For apps using ES6 modules I think Rollup is awesome, it can be just one one command line, no plugins, bloat or messing about: `rollup --format=iife --file=dist/bundle.js -- src/app.js` Just add that to your `package.json` scripts, can't get much easier than that :) [https://www.pikapkg.com/](https://www.pikapkg.com/) &gt;Modern Code Runs Faster: &gt; &gt;ES module syntax (ESM) is JavaScript’s modern native module system. Its import / export syntax is more compact, more easily analyzed, and more reliably optimized by build tooling like Webpack &amp; Rollup. ES module dependencies result in smaller, faster JavaScript bundles. &gt; &gt;Unfortunately, most packages on npm are only published as Common.js modules using Node’s native require() and module.exports syntax. Bundlers have a more difficult time analyzing &amp; optimizing these modules. Plus they’re more likely to be filled with slow transpiler bloat only needed for old versions of Node.js. &gt; &gt;How do you know which of these two systems your favorite package is using? Well, it’s not always obvious. Modern packages work by defining an ESM “module” build in their package.json manifest. But [npmjs.com](https://npmjs.com) and other package search engines don’t readily show this. Before now, this left us digging through GitHub repos &amp; source code. &gt; &gt;That’s why [pikapkg.com](https://pikapkg.com) was created. Use the search bar at the top of the page to find fast, modern, native ESM packages that match your keywords. Your results will only include packages that are built with modern ESM syntax &amp; include a defined "module" entry point in their package.json manifest. &amp;#x200B;
You must have realised by the number of replies by now that only one of two things can be true: * You are the only Javascript programmer in the world that uses const correctly * You are incorrect in this instance Do you really think the former is more likely than the latter? You keep repeating that everyone else is wrong but have you even considered a little bit that you might be?
Is Bloomberg considered a big JS company? Why? Is there some history there where they have contributed to the spec or something? 
Pretty sure OP was not familiar with ternary operator at all. As long as the condition and if/else branches are very simple ( which is the case in the current post), I really don't see any difficulties in reading it.
That's good that it's humbling. It means you're willing to accept that you don't know it all and learn from others. That's a VERY GOOD THING. I'll throw in my two cents here, whether it's popular or not, and say that technical aspects of programming, such as understanding and using arrow functions correctly and efficiently, are the skills that separate professionals from students. I'm not saying you can't be professional without using arrow functions, but the more of these concepts you understand and implement correctly, the better you are at doing your job. Now I'll say it: If you want to code javascript professionally, you're going to have to come to know arrow functions intimately, sooner than later in most cases.
I guess you never use arrow functions either?
I mean, I don't know what you're expecting but... const a = condition? 1 : 2 // assigning 'a' with const let a if(condition){ a = 1; } else { a = 2; } // a is not 'const' here :( // also the code is longer
Where do you draw the line? You can argue that operators like `+=` are terse and confusing for newer developers. Everyone’s gotta learn sometime. 
saving this for later
To add to that, people might think "well duh, but the `?` is only used there" but the distinction is important. Several languages allow for a concept called optional access(Swift comes to mind), where you can use the `?` token to determine that a given object might be null - in which case, the entire expression evaluates to null. [there's a proposal for that in Javascript](https://github.com/tc39/proposal-optional-chaining), at which point the `?` token will no longer be exclusive to the ternary operator. 
As a heads-up (as I often struggle with how to properly compare adjectives myself), I'm pretty sure it's "more performant" :)
Just like a question in English it’s an if statement. Is x == y? Return this if true : return this if false;
&gt; and `var` never. I'd disagree here, there are use cases. E.g. I want to declare variables as shorthand to access properties on `window` and they should be accessible in the entire function scope, but only if run in a browser. (as there's no `window` in Node) So I do const isBrowser = typeof window !== 'undefined' if (isBrowser) { var w = window var d = w.document var docEl = d.documentElement } You could of course declare the variables either way and use a ternary with `isBrowser` to assign them to `null` or something, but I feel like this is pretty expressive and valid.
You guessed incorrectly lol
Better remove your mlab credentials immediately! Consider using something like dotenv for credentials. Besides, looks good!
Sure, so think about what could happen later on in the code if that http variable was const vs if it were var. Basically, if it were var (or let) you could (probably accidentally) overwrite it with a different value. If you then tried to use any of the http module methods (expecting the original value) your code would throw an error. If you have code that accidentally overwrites this variable it isn't a security issue in and of itself, it's just a bug. The bug is the accidental overwriting of the variable though, not the use of var. Const was added to help prevent these sort of bugs; so, like everyone else in this thread has said, it's a good idea to use it when you can to help prevent you from making mistakes. It's always possible that a bug in your code can cause security issues, which is why I said it's not *likely* to be a security issue. More likely though, accidentally overwriting a variable will just crash your code. This has nothing to do with whether a *user* if your code can change this value if that's what you're concerned about. Generally, your users can't run arbitrary code alongside your code (except if you let them do so using dangerous methods like eval).
Yep, a performanter is somebody who performances.
Someone once told me the shortest way is not always easy to read. Seems like they were talking bullshit. 
Now that you know it's a ternary, I'm just going to comment that you should always use triple equals.
That's such a terrible way to teach. I wonder how many others lose motivation due to similar teaching practices.. 
Unfortunately the syntax is not as ergnomic as with LISP, otherwise I'd use Ramda's [cond](https://ramdajs.com/docs/#cond) all the time.
And reset them
Ah the old ternary operator... Useful, but less readable. var Apple = true; var x = Apple ? 5 /*True output*/ : 7 /*False output*/; console.log(x); //Output: 5
According to the docs, `jqXHR` implements the Promise interface, so it might indeed wor
Done, thanks!
I'd argue the shortened syntax makes it more readable, that being said I write lots of c# as well Which takes longer to read? const bar = foo .filter(function(x){return x.bar &gt; 7; }) .map(function(x){return x.name; }); const bar = foo .filter(x =&gt; x.bar &gt; 7) .map(x =&gt; x.name); 
"Performant" is also industry jargon that we all just made up. Say "performs better" so that people not in webdev (like our bosses!) know what you're talking about
lol so at what point do you come out and admit you were completely wrong? you're all over this thread speaking down to people, and yet you are objectively wrong about `const` &gt;ES2015 const does not indicate that a value is ‘constant’ or immutable. A const value can definitely change. The following is perfectly valid ES2015 code that does not throw an exception: https://mathiasbynens.be/notes/es6-const
Dude, you don’t even understand what the word “variable” means. Stop preaching about best practices. It’s really simple. A constant, even one whose value is assigned conditionally, is a fixed value, not a variable value. It cannot be changed once assigned, so it cannot be a variable value. The fact that you don’t understand this simple fact is a sign that you aren’t probably shouldn’t be one to tell others what they should and shouldn’t be doing.
I’ve never heard Bloomberg referees to as a “big JS company”, but they are TC39 members and they do no have quite a body of open source JS work.
This was a very Good read. He mentioned that V8 used to have two parsers ( parser and pre-parser). The pre parser was 'lazy' handled eager parsing only for the functions that need to be executed immediately called Immediately Invoked Function Expressions' Now that there is only one parser have they dropped the lazy evaluation for IIFE? p.s. on mobile sorry for poor formatting.
There's is no lazy parsing as such! All the code is converted to a bytecode which is used as a source of truth!
cool. I would suppose that solves the problem of evaluating the same functions twice then.
or your boss is german and he knows anyway.
Yes! It does
”dear mom, thank you for the sweater. I will let Chuck know about the state of your bronchitis. Love Steven” But then again I’m not fluent so it might be a bit off
JavaScript `const` is indeed like Java’s `final` keyword in that the reference can’t be reassigned. Static implies that it’s a shared reference across multiple instances of a class.
Something is missing here. Don’t you need some library to speak to the PI from node?
Right you are! I did not do a good job with my research :)
Have tried this solution? https://stackoverflow.com/questions/8825144/detect-double-tap-on-ipad-or-iphone-screen-using-javascript
The touch events contain a property, called touches, which contains all the touch points available. You can read more about [TouchEvents on MDN](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent). In your case, you would need to check the length of the touches property: someElement.on('touchstart', function (e) { if (e.touches.length &gt; 1) // do what you like here });
 &gt;// a is not 'const' here :( Thank you, that's exactly what I was asking! I couldn't associate what you said earlier with this, so thanks a lot!
Anyone could make API calls to skew your stats no ?
I hope Java would get switch expressions with pattern matching soon, maybe you could switch over a boolean then too...
What does this solve above using VSCode + rollup/webpack + babel with the http-server package and running the output directly in a browser with livereload?
Would be interesting to see a real comparison, including how well a JIT could inline it if you call it often enough... I doubt it makes any difference in almost all cases, and functions make complex code cleaner if used properly. :)
I tried this, it did not work
I could find a proposal for pattern-matching (which that is) for EcmaScript, but no idea if it's going anywhere. Something like this would be useful in many cases: [https://github.com/tc39/proposal-pattern-matching/blob/latest/CORE.md](https://github.com/tc39/proposal-pattern-matching/blob/latest/CORE.md)
I am not looking for a double tap.. I am trying to click two elements at the same time and it is not working...
My bad I put up the wrong link before. Fixed it now. 
Well look at that, internally, it *does* use `===` ```let isMyself = mightBeMyself =&gt; mightBeMyself === isMyself; module.exports = isMyself ``` 
So would you assign the output of a function to `const`?
Sure, but why not take advantage of the tools you do have natively? There's no reason not to use `const`. If nothing else it will help build good habits.
I’ll give you the bad variable names but the parentheses help readability here.
I revisited some code I wrote over a year ago last night. It was fine. 
Perfect! Thanks so much
If you need unix utilities in your package.json scripts entries, the cash project really is a boon (there are many `cash-*` utils. They don't implement the full functionality of the originals, but they are compatible enough to be useful in this context). Add the utils you need as dev-dependencies and forget about it. They will come installed automatically on any machine when you run `npm install`.
We have a similar setup at work except the Firehose pumps it in to RedShift and we use Metabase to query and graph it. 
Yeah, but that's not a weakness particular to this solution though? Any sort of mechanic that measures visitors can be "attacked" by flooding with fake visitor requests.
I'll be honest, I'm absolutely shocked that this was t he only comedic answer that I got......and it made me laugh pretty damn hard! 
&gt; All I wanted to say is my life is easier without React/Angular. That’s great and I don’t doubt it one bit. I also don’t doubt that you haven’t built any client side app with a modicum of sophistication. If all you care about is a box with styles and an event listener, then you’re not building things that would benefit from a library like react. &gt; I mean there will be a even better one, and even even better one pretty soon, they contributed to the slow evolution of the web. And here you’re seemingly contradicting your entire point. ¯\\\_(ツ)\_/¯ 
This code is from an open-source project I contributed to. It avoids a divide-by-zero error while drawing a line graph: const degree = update.value.duration === 0 ? 0 : update.value.accel / update.value.duration This code just pulls in a setting and sets it to a default value if it was not set: const maxDepth = options.max_depth != null ? options.max_depth : 10
I wouldn't block your PR or anything, but my preference would be to use `let w;` or `let w = null;` outside of the if block, and then reassign the variables.
Side question: is it really “serverless” if it only works by calling APIs on someone else’s server?
Happy holidays :)
Making this a function moves the mental context somewhere else. It might make sense to put in a function if you reuse it, but if you don't I usually prefer to see the actual code over a function name.
The problems with Sets and Maps go a lot deeper than this too. If you need the functionality, you really just have to use a 3rd party library for the time being cuz we're a long way away from them being remotely useful. It sucks, but that's just how JS is right now, but maybe in a year or two the standard library will be more useful.
Serverless: CDN edition
There is always a server somewhere even for the static page. I think this qualifies because it is all high level stuff (well above server infrastructure).
Disclosure: self-submission.
i don't buy that reassignment like this: let computedValue = 'defaultValue'; if (someCondition) { computedValue = 'foo'; } is necessarily worse or harder to reason about than this: const computedValue = someCondition ? 'foo' : 'defaultValue'; they both have pros and cons. the ternary expression inverts the default / happy / expected path, or needs to have a negated expression to maintain that. i think that's a fair trade off for a few more lines. some people don't like the extra lines and syntax. some people can't get past reassignment. the point is, there are many ways to express the same thing in programming, and they often have tradeoffs. be wary of people saying "this is better always" because they often haven't thought through the alternatives.
This feels like ideology, not logic. My guess is he's going to double down on his position and conclude all JS developers are amateurs. 
1. I don't need to use rollup/webpack + babel and the http-server package! That is a massive load of dependencies I never have to think about, learn, configure, update etc 2. I don't want the test results to appear in the browser, I would like them displayed in rear time in VS Code. The browser might not even be open, and it does not alert me of test failures unless I have the console open or a special overlay programmed to go on top of the page. Check out [Test Explorer UI](https://marketplace.visualstudio.com/items?itemName=hbenl.vscode-test-explorer) in VS Code Thanks for the input, do you have a specific set-up you use? I don't see an actual test runner in your dependencies?
also use === unless you have a GOOD reason to use ==. 
https://www.npmjs.com/package/rpi-gpio
Why are you using setInterval for this and not just a standard for/while loop?
Because I'm running it in the console on an external webpage and don't want to send a barrage of requests to their servers.
Congrats!!
When I try to learn again I'll definitely be more project-based this time and try to incorporate everything I learn into a mini-project of some kind, rather than just continue to type the same syntax over and over in an attempt to memorize it all.
Isn't this the whole point behind the serverless movement?
your if statement should definitely be something like: (thisElement !== null &amp;&amp; thisElement.length &amp;&amp; thisElement.length !== 0)
\+1, here's a great definition: [https://aws.amazon.com/serverless/](https://aws.amazon.com/serverless/) &gt;Serverless is the native architecture of the cloud that enables you to shift more of your operational responsibilities to AWS, increasing your agility and innovation. Serverless allows you to build and run applications and services without thinking about servers. It eliminates infrastructure management tasks such as server or cluster provisioning, patching, operating system maintenance, and capacity provisioning. &amp;#x200B;
Very good point, with a basic implementation from the blog post we literally just count number of clicks (it's important, though, that we validate calls to Firebase and only allow increments of 1). The next step would be to issue each user a uniq ID/fingerprint and store it in the cookie. This way we either can disable clicks for them / don't call API / store records like "user ID + timestamp" and then count uniq fingerprints as "votes".
Fair enough! Seems less readable/clear to me personally – but preferences, man, it's almost like we all have them :)
You could rate limit by making the client solve a proof of work with difficulty set by the server. As their rate increases difficulty goes up. Doesn’t matter how much computing power they have bc you can just keep increasing indefinitely. It would be easy to check/reject PoW at the edge.
Yeah, all serverless uses servers, it’s serverless to YOU, not the person maintaining the containers that spin up. 
Yeah, I can definitely see that. It is definitely clunkier. My thinking is that you get the benefits of block scoping and better predictability (no hoisting, no redeclaring the same variable, etc). That extra predictability less error-prone behavior seems worth the extra line of code to me. As a result, I have not used `var`, only `let`s declared in a wrapping scope for problems like this for the last year or two. Similarly, in your example I _might_ go so far as to use `const` and ternary for all three, even though it is arguably clunkier still, because then I get the benefit reassignment-protection as well. Added functionality for (debatably) less readable code. I don't think there is a perfect answer here though ¯\\\_(ツ)_/¯
Good points here. Personally I would probably still choose the reassignment-protection, but hopefully I have been clear that my preference for ternaries + const is just an opinion. 
What about \`R.path\` from Ramda?
The redux advice to define them in separate files to "save ourselves from typos" is unncessary in a strongly typed setup, as the type system protects us from those typos instead.
Hi /u/ArtSchoolRobot, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
`x == list.length-1` should be `x == list.length`. Since you're incrementing x after the click is done, you're really checking how many clicks you've done and how many array items you've "ticked off". So you want to tick off as many items as there are in the array, i.e. its length. 
You're testing if the variable exists, not if it's not null. Use if(socket.worker &amp;&amp; socket.worker !== null ) 
Main difference here is script size. Minified and gziped, mjn is just 307 bytes!
If you can only have one radio button checked at a time you should be able to do it with querySelector: `const checked = document.querySelector('input[type=radio]:checked');` That should return the element in question, and from that point you can easily access the id.
What the bloody fuck is that link? Or were you trying to use markdown in non-markdown wysiwyg mode?
if socket.worker is null it is false in condition. So second condition won't execute.
No problem man. I like this concept. Feel free to ping me on Twitter(qbllr_) if I need a review will talk to you. 
I am a noob myself but I’ll give it a shot... you have to create a onChange attribute that calls a function which will store your value into your local state. 
Perhaps I'm being cynical, but why should I trust any given company? If I have my own server I can control everything and move to another provider in a few hours maximum. I can also audit everything at the lowest possible level. With serverless, I'm putting a great deal of trust in a provider like AWS and because AWS serverless is meant to only work with other AWS products, I can't switch my serverless provider without switching everything else, and I can't audit things as easily.
`if (socket.worker)` will evaluate to true if worker is NOT one of: `null`, `undefined`, `0`, `false`, or `''` (empty string). This is just the nature of JavaScript. The `if` check is basically checking for truthiness as he had it written. As to the error he is getting, that shouldn't be happening given the code posted in the thread. I would be interested in seeing more of the code...
Do you say that `if(null)` can be sometimes true and sometimes not??
Thanks, I'm way noobier than that though I'm afraid. Will do some research and see if I can figure it out!
If socket.worker is a built-in type then it might have odd rules that aren't normal, like evaluating to 'null' when trying to use it as an object, but evaluating to truthy in other situations.
Congrats! 
 if (socket.worker) {} socket.worker.postMessage() If this is how it is interpreted (after a minification or some removed code in your example) that could explain the error you are seeing.
nice work!
That's the kind of thing I was trying to do, but it gives a syntax error for some reason for me :(
What I use is as I've described, strictly speaking for browser based canvas games. I've not found a reason to use test runners when the UI is mostly within the canvas itself, it doesn't make it easy to repeat/automate interactions with mocha like if it were a dom. I'm not trying to dissuade you or knock on testing, it's mandatory for everything else everywhere so why not this too. I just wonder if using mocha/jasmine/etc and something like an image diff would be worth anything for games? Charts/graphs where representation of data is crucial sure, games not as much. Maybe testing to make sure functions are called / particular drawing calls are correct? I get using a mocked canvas so you can verify validity of drawing functions and eventually pass it a real canvas, but strictly personally, it's too much overhead for not enough gain. I can visually diff across multiple screens and I know the expected outcome. When it comes to testing on different browsers/OSs/screen resolution I can just open the other browser window or set the user agent or the computers/phone/tablet sitting next to me as it's already being served up by http-server so it's local network accessible. And there's a few plugins for different browsers that can nearly emulate other browsers/OSs/resolutions/etc. The only workflow is: automatic watched code change -&gt; automatic build -&gt; watched file change -&gt; automatic reload of http-server package in node and automatic refresh of browser and this works for at least 50% of the work. When I want to reload to specific content, I have to mangle the game code to allow that as a starting point and making sure the load is congruent with that point in the game. So that would be the hurdle to overcome for me.
Can you please paste the full error you're getting? Which browser are you using? &amp;#x200B; There is also one other thing you can try. If all the radio buttons share the same class, you can do a multiple selection: &amp;#x200B; `const radios = document.querySelectorAll('.ss-input-radio');` &amp;#x200B; You can then iterate through all of them, see if it is checked and then act upon that condition: &amp;#x200B; `radios.forEach(radio =&gt; {` `if (radio.checked) {` `// do something` `} else {` `// do some other thing` `}` `});` &amp;#x200B;
I go test it.
You probably want a different event handler than onclick. Try onchange
This shouldn't happen other than with the single exception, the oddball `document.all` - which is actually doing the opposite. It's even explicitly called out in the spec: &gt; Objects with an [[IsHTMLDDA]] internal slot behave like undefined in the ToBoolean and Abstract Equality Comparison abstract operations and when used as an operand for the typeof operator. &gt; &gt; NOTE &gt; Objects with an [[IsHTMLDDA]] internal slot are never created by this specification. However, the document.all object in web browsers is a host-created exotic object with this slot that exists for web compatibility purposes. There are no other known examples of this type of object and implementations should not create any with the exception of document.all. To me, the only time OP's issue should be possible is if `worker` is a getter and its value nondeterministic. Get it once, it returns a value, get it a second time directly after and it decides all of a sudden to return null. I wonder if this would make a difference to OPs code: const worker = socket.worker; if(worker) worker.postMessage(...)
I think its meant for startups looking to minimize the costs of infrastructure. That comes with your invested trust in aws/whatever cloud platform you choose
That should never be the case. Assume that to never be the case.
Are you closing the socket somewhere else? My guess is you have a race condition. Javascript itself isn't multi-threaded, but it does parallel work in slices. If in a slice you are closing the socket, but not removing it from a list you are maintaining, then something weird could be happening.
... And don't forget our old friend, [Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)!
I think you are testing in a different way to me with a different goal. My goal is to test individual functions rather than validate what is appearing on the screen. For example, my collision detection function and test look like: detectCollision(other) { const left = this.xPos; const right = this.xPos + this.width; const top = this.yPos; const bottom = this.yPos + this.height; const otherLeft = other.xPos; const otherRight = other.xPos + other.width; const otherTop = other.yPos; const otherBottom = other.yPos + other.height; return !( left &gt; otherRight || right &lt;= otherLeft || top &gt;= otherBottom || bottom &lt;= otherTop ); } &amp;#x200B; import OnScreenObject from '../src/classes/base-class-on-screen-object'; describe('Base class', () =&gt; { describe('detectCollision()', () =&gt; { it('should return true when testObject is colliding with onScreenObject', () =&gt; { // Arrange const onScreenObject = new OnScreenObject(100, 100); onScreenObject.width = 100; onScreenObject.height = 100; const testObject = { width: 1, height: 1, xPos: 100, yPos: 199, }; // Act const result = onScreenObject.detectCollision(testObject); // Assert assert.strictEqual(result, true); }); }); }); I agree that testing games in the same way as DOM stuff would be overkill and not worth it, I am really talking about only testing functions with inputs and outputs. All the Canvas mocking stuff is just to get the code to parse properly. I have tried to separate the Canvas stuff as much as possible and make the code testable.
It makes sense. socket can be `null` and you never check if `socket` is `null`, you check `socket.worker` which will throw if `socket` is `null`
Hoo boy, it's still a new file extension, then
There is a third option: That something _else_ is going on but you are not considering it. _Most probably_ this means that there could be something else in your code that is the actual problem. But this presents an additional difficulty: That you are _not_ showing your **actual** code that is being run. So, the code you have shown may not have the relevant thing that makes it fail, which will greatly difficult any chance at helping you. You need to: show our actual code, mention any libraries or tools you may be using, give more details about the point of it happening "sometimes". Ideally you'd set up a failing example live (maybe on JSFiddle, CodePen, etc, or on your own site) where people could actually experience the problem first hand. But if this is not possible, you'll need to, at least, provide the other things.
congrats !!!
I'm pretty sure the `as` prop and route masking is completely optional. You could just use `href` and search parameters. I'm pretty sure `href` needs to be unmasked to make it easy for Next to determine which page is being linked to. The masked route in your example is fairly simple, but you could use a path that doesn't line up with your `blog` page easily. For example if you wanted to use `/post/:slug`, Next would have no way of knowing you want to render the `blog` page.
I'm also not sure why there's a random pic attached to my post while viewing it on my phone lol 
This wouldn’t work with bind either. Although I feel like both bind and pipeline are useful as long as JS remains a multi paradigm language.
btw worker is experimental Worker class of node.js &amp;#x200B; i manually exited my worker. my test in main script: worker.on("exit",function(){ { if(worker) console.log("is true") if(worker!=null) console.log("is not null") console.log(typeof worker) if(worker.postMessage) console.log(worker.postMessage) console.log(worker.postMessage()) } }) return is true is not null object [Function: postMessage] TypeError: Cannot read property 'postMessage' of null I am not sure now what condition I should use.
btw this is not my problem.
1. it's own fucking logo 2. 84357923748 fuckboi badges 3. a 20000x20000 screenshot in the README 4. a fucking ToC in the README 5. totally useless demos, each with their own 20000x20000 screenshot, for 10000 different frameworks 6. FP buzzwords sprinkled everywhere 7. code coverage configuration for a &lt;20 lines package 8. using unconventional expressions such as \`void 0\` just to get started &amp;#x200B; I know I come of as a huge douchebag, and perhaps I am in this case, but come on... I swear I've seen full-fledged frameworks with less content in their READMEs. OP, it looks great and very professional, but it's not done in the right context at all.
How has this taken so long? Support for ES modules with a special `.mjs` extension by 2020? Actual interoperability with real `.js` files by ???? I appreciate there are some technical challenges here, but this was an _ES2015 specification_. What. The. Fuck?
Something I find neat about `reduce` is it's like the mother of all the array iteration functions. Using `reduce`, you can easily implement `map`, `filter`, `some`, and `every`: ```js const map = (array, fn) =&gt; array.reduce((result, value) =&gt; { result.push(fn(value)); return result; }, []); const filter = (array, fn) =&gt; array.reduce((result, value) =&gt; { if(fn(value)) result.push(value); return result; }, []); const some = (array, fn) =&gt; array.reduce((result, value) =&gt; result || value, false); const every = (array, fn) =&gt; array.reduce((result, value) =&gt; result &amp;&amp; value, true); ```
congrats
This design is so ugly, holy shit. It's like they intentionally try make it unusable and unreadable by anyone.
How do you figure?
I use node.js. See my comment.
Phase 2 seems to solve this
It really depends on what the function is doing. Naming things is hard, so if a function is fairly self explanatory and is only used in one place (callbacks, iterator functions, etc), an inline arrow function is usually more readable. If that arrow function starts to grow or gets redefined in multiple places, I might move it to a higher scope (or its own module) and give it a name.
worker is experimental Worker class of node.js &amp;#x200B; i manually exited my worker. my test in main script: worker.on("exit",function(){ { if(worker) console.log("is true") if(worker!=null) console.log("is not null") console.log(typeof worker) if(worker.postMessage) console.log(worker.postMessage) console.log(worker.postMessage()) } }) return is true is not null object [Function: postMessage] TypeError: Cannot read property 'postMessage' of null I am not sure now what condition I should use.
`worker.on("exit"` is a red flag. This means your worker has stopped. You shouldn't be able to post a message to a stopped worker. This then suggests that your post message error isn't from the worker itself, but probably from the MessagePort the worker is using. Presumably, worker.postMessage just wraps a port.postMessage and if port is null, you'll get that error but where null is in reference to the port, not the worker.
How often do you find yourself defining functions for the sake of a new `this`? I don't think that's something I've done since `class` became a thing.
Thank you :)
Thank you :)
Thank you :)
Thank you :)
Thank you :)
&gt;Node.js should stay as close to browsers as possible. uhh... why? 
https://www.youtube.com/watch?v=YG6DifUtPvs
It _could_ be that that `null` is not referring to `worker`. `Worker#postMessage` calls [this](https://github.com/nodejs/node/blob/966a2df0f620cfe59e6ce2b161ff8bf7446b46ee/lib/internal/worker.js#L376-L378), which is a _different_ `postMessage`. So the error may be that your worker is not correctly initialized.
I also just started toying around with Typescript. These docs have helped clear up a lot of my confusion regarding the type system: https://www.typescriptlang.org/docs/handbook/basic-types.html https://www.typescriptlang.org/docs/handbook/advanced-types.html
Principle of least surprise
I just deleted my comment just after you reacted to it. Maybe post it again to my new comment (I moved it)
`worker.on("exit", ...` is a red flag. This means your worker has stopped. You shouldn't be able to post a message to a stopped worker. This then suggests that your post message error isn't from the worker itself, but probably from the MessagePort the worker is using. Presumably, worker.postMessage just wraps a port.postMessage and if port is null, you'll get that error but where null is in reference to the port, not the worker.
this looks to be problem. so solution is probably on exit event update socket.worker to null for all sockets that have exited worker &amp;#x200B; worker is probably correctly initialized but it is terminated (by me or by some conditions)
yeah its a good idea not to reply to yourself or it might go missed ;)
There are currently lots of libraries you can use across node and front end.
&gt; A ternary is the only way to go. ```js const a = 1; const b = 0; const c = b &amp;&amp; 'lol' || a ```
- Inability to import es modules without extension(article doesn't state that Phase 2 fixes it) - Inability to import directory(article doesn't state that Phase 2 fixes it) - Inability to import packages(we can only guess that the mapping in Phase 2 is going to involve some sort of field in package.json and if it's not going to be "module" then it won't be compatible with existing tools, like webpack) - createRequireFromPath. Wtf, seriously? Can't "require" be supplied to the module as a global variable? "createRequireFromPath" could then still be used if you wanted to dynamically change the "import.meta.url" property, which is allowed by spec. Unclear what "Support for file name extensions other than .mjs. That includes support for ES modules in .js files.". Does it mean that everything will be allowed to import everything? Import .js from .mjs and vice versa, not use .mjs at all if you don't want to etc? Also what's the benefit of "browser equivalence"? Why is it important? When have developers ever expected node modules to work in the browser(and vice versa) without extra steps? Compiling es modules to commonjs with babel seems to be way simpler and more straightforward than this spec.
I still don't understand why they couldn't just parse the file and check whether or not it has an `export` statement to decide whether to treat it as an ES module or not.
Why should I care about this?
Remind me in three days
yay!
Great explanation @Funwithloops 🙏 &amp;#x200B; I wrote a full/detailed explanation of how the router works and why it does things the way it does here: [https://github.com/zeit/next.js/issues/2833#issuecomment-414919347](https://github.com/zeit/next.js/issues/2833#issuecomment-414919347)
Oh boi, that’s ugly. But functional, soo.. congrats I guess?
Looks like you need to learn how callback functions work. I wouldn't worry about promises or async await until you grok callbacks. \`\`\` function aFunction() { console.log('hi'); } aFunctionThatUsesACallback(anyFunction) { return anyFunction(); } // a working example: window.setTimeout(aFunction, 10000) // or window.setTimeout(function() { console.log('hi'); }, 10000); \`\`\` if you need to perform multiple async actions and then do something with the data after it all resolves then you should learn promises and then learn how Promise.all works.
what is ESM?
Check out the concept of promises. It handles asynchronous tasks like charm. 
Whether you want to go with Promises or plain callbacks, that 'hi' will always log first because your https.get is async by nature. To get the 'hi' to appear after as your code is, the only way is to include it on the \`end\` handler of your response after logging the actual \`charInfo\`
congrats, but be careful in the readme file there is " whish" instead of "wish".
can u elaborate? you mean by adding res.end() and passing in my charInfo
In the case of fetching data from an API, I find implementing async-await is the way to go. It ends up making the code much more readable. [https://javascript.info/async-await](https://javascript.info/async-await)
These are a few FAQs: * Why the different file name extension `.mjs`? * Every solution has pros and cons. Using a different extension is a reasonable compromise. Details: http://2ality.com/2017/05/es-module-specifiers.html#why-new-extension * Why should Node.js stay close to the browser? * That makes it possible to reuse code. For example, to write libraries that work both on browsers and on Node.js. * It also makes it easier to switch between frontend and backend when coding. * Why all these restrictions w.r.t. interoperability? * Structure (static vs. dynamic) and loading process (async vs. sync) of ES modules and CommonJS modules is quite different. The restrictions keep things simple – considering the long-term future where ESM will be dominant. * Why does all of this take so long? * There are many stakeholders and many different platforms involved (Node.js, npm, browsers, JS engines, TypeScript, TC39, etc.). If we end up with ES modules working well everywhere then it’s worth it to wait, IMO.
Look for boilerplate projects, or a yoeman generator. 
ESM = ES modules = ECMAScript modules
Even if this is your opinion, why wouldn't you leave constructive feedback? 
the course you posted has all the basics, once you get going with react/angular etc you will be googling a lot regardless, just make sure to take the time and play around with the boiler plate and basic tutorials for which ever framework you start up with and just google like hell. not sure if testing is in the beginner courses but that is something you will want to start getting familiar with as well. 
Good job my only feedback is on the font: use a sans serif font or it looks a bit dated 
What does your app do? If it's just a cli, you don't need either one. You can use something like pkg. If you need a GUI but you don't need custom elements, take a look at Proton. If you need a customizable GUI, use Electron. 
Basically, there's no way to 'pause' and wait for your data to arrive. Even if there was, you definitely don't want that as it would block all other Javascript from executing on the page while you are waiting for your response. What you want to do is without going into the concept of Promises, is let the user pass a third argument to your function, which is a function and execute it for the user once you have fetched the data successfully. In your case: function getAttr(attr, id, callback){ let attrValue = attr; let charInfo = ''; https.get('https://swapi.co/api/people/' + id + '/', function(res){ res.on('data', function(data){ charInfo += data; }); res.on('end', function(){ charInfo = JSON.parse(charInfo) console.log(charInfo) callback(charInfo) }); }); }; &amp;#x200B; And then a user would call your method like: getAttr('attribute name', 123, function(charInfo) { console.log(charInfo) }) &amp;#x200B; I strongly recommend reading in depth about how async, callbacks, and promises work before continuing your library! I'll help out a ton
Thank you for attempting to help, I am making my own GUI and also a mix of JQuery UI which is pretty much a library and not a framework. 
You probably want Electron then. 
awesome out of the entire internet so far you helped me the most! The way you explain it makes total sense and if you have any resources for learning the concepts and such or any good articles for sure post them here so I can read up, guess its's time to start learning promises 
honestly though I still need to add to this function I want to be able to take the data from the api call, add it to the charInfo as a parsed JSON data, and then be able to search for a key value pair with the attribute given so I still need to wait for the data to be finished before manipulating it
Good to know, thanks! Honestly when I used Rollup for library development, I enjoyed it. I think the reason it was cumbersome this time is that I was integrating it in the ready app, which has quite a lot of legacy dependencies. I'll definitely try it out when v1.0 will be released!
Please release Windows and Linux versions. Very Interested
There’s a lot of shade being thrown in this thread but I know you and others have been very hard on making this work without breaking the existing ecosystem. Thanks for the hard work.
Nice to hear! I'd recommend to get comfortable with callbacks and how async js works before heading to promises, since promises are merely an abstraction on top of callbacks. don't really have any links sadly, I mostly just try things out and google specifics when something doesn't work like I thought it did ... Once you understand everything you should be able to refactor your method into something that returns a promise and nicely handle cases when the inner \`https.get\` fails so that the user knows what happened. Good luck!
I actually think it is looking great!!
&gt;Sure, so think about what could happen later on in the code if that http variable was const vs if it were var. &gt; &gt;Basically, if it were var (or let) you could (probably accidentally) overwrite it with a different value. If you then tried to use any of the http module methods (expecting the original value) your code would throw an error. &gt; &gt;If you have code that accidentally overwrites this variable it isn't a security issue in and of itself, it's just a bug. The bug is the accidental overwriting of the variable though, not the use of var. Const was added to help prevent these sort of bugs; so, like everyone else in this thread has said, it's a good idea to use it when you can to help prevent you from making mistakes. &gt; &gt;It's always possible that a bug in your code can cause security issues, which is why I said it's not likely to be a security issue. More likely though, accidentally overwriting a variable will just crash your code. Right. I guess the "likelihood" statement could be construed as saying *it's unlikely that if it's a vulnerability it should be one concerning for you*, in which case someone might want to refine your description there because *security isn't supposed to be left up to chance, any possible vulnerabilities should be analyzed and factored into an assessment to prescribe best practices* or so on. But I took it to just simply mean *it's unlikely that that particular unknown would cause you a security problem*. I knew what the sort of problems it could cause were, but it's always helpful being explicit and informative, unpacking stuff, etc. And I figured it could leave open some kind of vulnerability with "over the shoulder" attacks. &gt;This has nothing to do with whether a user of your code can change this value if that's what you're concerned about. Generally, your users can't run arbitrary code alongside your code (except if you let them do so using dangerous methods like eval). A user can run arbitrary code in their own browser, but that can only affect them and not other people or your website backend. Well, I originally asked this in the context of Node.js, but that remark about security was meant just generally, I guess. One vague possibility I had in mind---I forget what they call it---but where malicious code or whatever payload is loaded through importing libraries/modules (in this case with `require`) so that whatever methods or code is invoked from that library at compile time instead executes the malicious code. I guess using var could be a threat with loading libraries if they are able to alter what gets assigned to e.g. `http` to call methods from malicious code. Of course, it looks like const would only mitigate that if in strict anyway, and if they had permissions to alter the code, maybe they coukd do worse. Still, maybe it coukd be done to go unnoticed? Anyway, I was just saying that, yeah, it might be unlikely to *happen*, but best practices shouldn't really be determined by chance or whatever. I'm sure we agree, but thought it would be good to unpack my intuition there. Anyway, thanks for the response; informative.
I absolutely love it! Great Job!!! 
Wow, that was unexpected for me. Importing as `import { path as get } from 'ramda'` ended up being 1.5k. I thought Ramda would be way bigger than Lodash, especially because I didn't do a custom build or anything.
Putting in query params after ? Allows you to name them such as ?name=param and allows you to pass multiple params ?name=param&amp;friend=param. Then you can easily grab these values from something like query.params.name. If you strung them all together as /param/param you lose this ability. It’s not necessarily that the server/client can’t handle it
Many linters would flag it as superfluous.
I've updated my app, but debugger stopped work(
Found a hacker here
Same here. I've been learning Javascript and was loving it until I came across React. For some reason I'm just not connecting to it and it all seems weird and counter-intuitive. 
I read [an article](https://hackernoon.com/node-js-tc-39-and-modules-a1118aecf95e) a couple of years ago that claimed "there are a number of edge cases that make it difficult to achieve" but I still have no clue what those edge cases are.
Great work!
Thanks! I’m really just the messenger, but I like the most recent decisions, because they do make things simpler (which we’ll benefit from, in the long run).
Because that's not enough to tell whether a file is a module. A file could be a malformed Script. If the file is supposed to be parsed as a Script, then a parser must throw a SyntaxError upon finding an import declaration, not assume it's a Module. Modules and Scripts have different grammars. If a file has no import/export declarations, a parser would still need to decide which grammar to use to determine whether to throw a SyntaxError or not if it finds a `with` statement or a legacy octal. If a parser encounters a file with both an import declaration and a with statement, then it needs to know which SyntaxError to surface.
i’m sorry but I’m a noob, what are those?
Angular and Vue have their own little languages in the templates, but React is quite bare-bones. There might be a minimum level you need in order to be *effective*, but I don't think starting with React too early will hurt your JavaScript learning. Just go for it. 
I've been grinding on a project for the past few days that's sort of clearing some things up. I can link you the repo if youd like
Out of curiosity, how long have you been programming JS? 
thanks 
thats cool, maybe change the font from default(times new roman) to something else (you can try the css `font-family:sans-serif`
Wow, that's interesting. I didn't realize that even the parsing was totally different, or that JS scripts supported HTML comments. So it isn't possible to just parse the entire file and delay deciding whether to throw a SyntaxError until _after_ it's determined which type of file it is? Not even if they broke backwards compatibility with esoteric features like HTML comments in scripts?
Congrats on providing absolutely nothing of value to the post or for anyone to help you.
Google's got ya on those ones, the MDN docs should be able to give you a great rundown
Depends on what you're looking to accomplish. Unless you're a huge firm being able to provide and maintain servers in multiple continents is really hard. Pushing that cost over to Azure/AWS becomes noticably cheaper in that context. You obviously lose some level of control but depending on the use case the benefits may outweigh that. 
You can check d3. A little hard to start but lots of examples online. D3: https://d3js.org/ Gantt tutorial: https://medium.freecodecamp.org/d3-visualizations-with-datasets-how-to-build-a-gantt-like-chart-9c9afa9b8d9d
Irony
It's not possible to determine whether something is a module just by looking at code, simply because a parser has to decide whether to surface an error or not based on grammar differences in some cases. Even if a JS engine developer were to completely ignore Annex B (which they could!), there are plenty of other cases where the spec dictates that code is supposed to run in one grammar but surface errors in the other (import/export, with statements, legacy octals, ...). And it's not limited to parsing either. Unlike Scripts, Modules always run in strict mode. This means the `this` keyword point to different things in functions in Scripts vs Modules (among many other differences) so code can do wildly different things at runtime depending on which grammar we're using.
Interesting, well Ramda is set up to handle treeshaking 
Fe
When you think about it that way, it actually kinda makes sense for modules to use a different file extension; they're almost a different language in some ways.
Express generator for expressjs, knexjs for sql. 
You may be are looking for "AdonisJs" (nodejs framework) Take a look in their website you'll be amazed how elegant it is 
Something I should have specified that varies from a regular Gantt, is that because there are almost 500 relatives, I want the ability to put some on the same line as previous ones, even if they're unrelated, to save space, and somehow specify that some relatives are ancestors of others, etc. I realize that does make my case much more unique.
I’ve written an overview: http://exploringjs.com/impatient-js/ch_modules.html
Looks good! How much hours did you put into this? Curious because I will soon dive in into building my first full stack app as well. 
Congrats. 
Yeah, and apparently very well suited for it. I know lodash often relies on a lot of internal helpers, so even when it's perfectly treeshaking (the `import get from 'lodash/get'` and `import { get } from 'lodash-es'` should be doing this) it'll bring in some boilerplate, but apparently it's "a lot". Of course, all of this is a little funny. 6kb is absolutely nothing in practice, especially when it's before gzip. Still pretty impressive on Ramda's part. That said, Ramda and mjn take vastly different approaches as far as I can tell, where they demand the path be specified in one format (period separated string, in the case of mjn; array in the case of Ramda) while lodash can accept either of these and I believe more formats (for indexes, it can use `array.2.something` or `'array[2].something'`, for example, I believe, and perhaps it can also use `'something["somethingElse"].0'` etc., but I haven't checked)
That’s interesting. I’m not surprised lodash is the most popular, it’s very flexible and does a lot, but I have to say I love the Ramda codebase, it’s a very consistent functional library and I found that switching from lodash was not difficult at all. The docs are a bit more academic than lodash, however, and maybe that’s even an understatement. 
There's nothing in the changes that I can see that would warrant a 4.0 version instead of just a 3.x.x one.
It probably won't be adopted because it seems like it'll require two types of deliverables. However Typescript and jdalton's esm module made it _work_ is just too hard to implement I guess.
You can learn React while learning javascript. It's not a framework in the traditional sense but a small javascript based view layer. You'll be dealing with regular language constructs and a minor DSL for the templates, which are pure javascript again. I wouldn't make such a ceremony out of learning stuff, you'll face problems that need solving soon enough. Look over [this article explaining es6](https://babeljs.io/docs/en/learn) once then jump into any tutorial you like, for instance [eggheads](https://egghead.io/courses/react-fundamentals), and building apps. 
Everybody’s fucking clapping for job well done without constructive feedback and I am the one called out by you? Fuck off.
The node JS version bump?
Closures are a fundamental part of JS: whatever you're doing in the language you need to understand how they work (and it's not hard; shouldn't take you long). Prototypes are JS's wannabe OOP functionality. React started heavily focused on OOP (you had to use a class to make a component). However, since then the library has done a 180 degree turn, and they're latest addition to the framework (hooks) removes all need to use classes. So you definitely don't need to worry about them. As for arrow functions, you never *need* to understand them: you could write a million line application without ever once using a single arrow function. That being said, they're easier and more convenient, and their main downside (not being able to reference `this`) is irrelevant if you avoid OOP (as you should). Also they're super quick to learn. The same is true for the spread operator: you don't need it, but it makes life easier. It will probably take a little longer to wrap your head around it than arrow functions, but once you do its pretty simple. Finally, callbacks aren't even a part of the language so much as a concept or way of doing things. Callbacks are all the more important with React's new addition of hooks, but really they're pretty important for React just in general, because you need them to "invert control" (let your "smart" components handle all the logic, but then pass callbacks to your "dumb" components so they can actually bind event handlers and such). Hope that helps.
Yeah. I choose to use lodash/fp most of the time. Lodash just seems to have much higher adoption, so using the fp variant will come more naturally to more developers.
I agree that those congratulating should also give constructive feedback, however you're being needlessly negative without saying anything constructive. At least they are likely to motive op to keep improving where as your comment only demoralizes with no help on how to improve. 
I often see myself writing reduce and after finishing, looking at my code, and accepting that foreach is way nicer and refactor it. What is more performant? Are there cases, where you need to use reduce?
Electron will make everything into a single *.exe where I only have to give someone a single *.exe ? Where in the documentation talks about how to do that ?
Oh yeah, yeah, the type who reads a medium article and thinks the world would end if he didn't do exactly as it says. Gotcha.
Arrays and sets are both collections, but that doesn't make them basically the same. A Set collection is well established in others libraries and languages, including the typical operations of intersection, union, and difference. Their absence in JS is pain, and makes them unnecessarily awkward to work with.
We used doors in my company to represent database connection hangup and automatic retry. It served us pretty well and thought it would be great to gather your feedback and make it better. Merry Christmas. 
Electron, like many other projects (e.g. react), use semantic versioning. A bump in major version has nothing to do with “now we have enough great features to justify that”. See here when they bump major/minor/patch: https://electronjs.org/blog/electron-2-semantic-boogaloo
Yes. Yes. Yes... Hm.... not always but yes. Also sharing and collaborating is fun and educative and very rewarding.
It's all of the above. And none of the above. There's as many different reasons why people open source their code as there are people.
A lot of people just enjoy coding and making things that solve problems for themselves or as a hobby, why not share it? It's not like monetizing code is as easy as saying: 'Actually... I'm gonna sell this instead'.
When you start selling you commit to a huge responsibility to maintain. 
They literally say why in the next sentence
Why do you hold the door open for others? Because you know it's nice not to have a door shut in your face. It's a crude analogy but the world has been dominated in some regions by bait and switch practices whereby businesses lure you into their domain of service, get you reliant on them while you're naive and then shut the door on you once you need next level access / configuration of the software you rely on. Many Open Source Softwares aren't proprietary with a bunch of profiteering conquests hacked into them. The developers creating them know it's useful but not so useful to be their sole focus so they release them into the wild so it can grow (or die) on its own via community interests (or lack thereof). It's not wasting time. It's maximizing potential while hopefully minimizing costs.
I believe the concept is that these are tools that they made to make their job easier. Monetization will only give them so much money. But sharing it for free with the hope that others too will is way more useful than any little money that can be made off monetizing the work that they did. That said these developers usually monetize their work by setting up their open source work for customers that don't want to go through the hassle themselves. The code they wrote is rarely a product that can be used out of the box and always needs another dev to make it work for a customer. So in essence it's devs helping other devs out by modularizing the work that they do. Instead of hiding behind IP and copyright which would stifle this growth.
Yeah, this + ego I think. Coding is fun, and having your name be sort of kind of not really but sort of famous is something people desire.
Honestly because I rarely feel like my code itself is worth enough to be sold. Even if turned into a service, only a small portion of my code is the business logic. If I knew that putting my code behind closed doors let me directly earn an extra 100 bucks a month, I'd do it, but a lot of my personal code is for my own learning and knowledge or experiments. This idea is I think something that Microsoft has learned recently. My understanding is that TypeScript started as an internal project that was eventually open sourced. Its not like Microsoft would have made a direct profit off TypeScript, but the services they write with it will. Its also free storage for some. A resume builder for others. Finally, code is different than other raw materials. Its one thing to say "I give away my 3D prints for free" due to the material cost, but for code, the cost to distribute to anyone who wants it is virtually free. The code doesn't matter: its the backing product/service. 
Browser is IE8 which is probably a problem, as it doesn't apparently support a lot of newer CSS stuff very well, including apparently querySelectorAll: "Partial support in IE8 is due to being limited to CSS 2.1 selectors and a small subset of CSS 3 selectors (see notes there). Additionally, it will have trouble with selectors including unrecognized tags (for example HTML5 ones)." Silly idea posting the question on a Friday, will have to wait until Monday to get the full error, but it was something like syntax error line 0 character 2
Because of the ***opportunity cost*** of monetizing. If I have 3 apps, A will make me 5 million dollars, B makes me 1 million and C makes me .5 million and they will all take the same amount of effort to market and monetize the correct thing to do is monetize A and give away B and C. If you waste time monetizing B and C and reduces the revenue of A by 2/3 then you are losing money.
Oh man. Imagine if index.html or index.php couldn't be assumed in a directory. I could see them ditching the package.json parsing but getting arid of index.js seems crazy. Web servers could easily have rules added to them to detect that a module was being requested and then to check for index.js. It seems like this working group is run by camel monkeys.
But you just created competition for yourself by giving away the code to B and C. You spent x months refining a concept, designing it, implementing a working build, and then the entire world can now compete against you it would be smarter to just shelve B and C until you have proper time to monetize it. no?
Stupid question, what's wrong with common js and the require function? I get that es modules are cool and all but I don't get why nodejs needs it. Also now this is something different to standard es modules? Can somebody explain the motivation like I'm a 5 year old? 
this whole .mjs extension is utter bullshit and will never be used by anyone ever.
how so?
I'm a developer and all of my applications are available for free on GitHib because I do want to give back and have no interest in monetizing my apps.
Obviously B and C is not your secret sauce. The chances of side apps being a difference maker for your direct competition is very low (almost none...) in practice. There are numerous benefits to open sourcing that you would enjoy: * personal authority / reputation * testing and code contributions from the community * easier hiring * more qualified workers If you don't open source you lose out by letting these benefits go to waste. Letting your own code sit on the shelf does nothing for you, it's just a pure loss.
Yay I just got my Electron v3 app working! Time to break it again for another frustrating 2 months of development.
besides what was mentioned below, why wouldn't they do it? what is there to gain? in most cases it's not really something you could sell anyway.
i just upgraded my 1.8 version to this one and i dont see any issues
This is the "canonical" answer, published by the same organization as express itself, but it doesn't really address what OP is looking for, as it doesn't really include much aside from templating and other light scaffolding.
&gt; The code doesn't matter: its the backing product/service. Meh I do think there is something wrong with this logic. Maybe because you're an eng and the code is the ez part for you, but a business guy might think the opposite. Don't undersell yourself.
my code looks like this: &amp;#x200B; fill(255, 0, 0); var z; var cr; var ci; var r; var i; var screensize = 2; var itrations = 10; &amp;#x200B; for(var a = 0; a &lt; screensize \* 100; a++) { for(var b = 0; b &lt; screensize \* 100; b++) { r = a + screensize / 100; i = b + screensize / 100; cr = r; ci = i; for(var c; c &lt; itrations; c++) { r = sq(r); r += sq(i); r += cr; i += ci; } z = sqrt(sq(r) + sq(i)); if(z &lt; 2) { z = 0; } fill(z, z, z); rect(b \* screensize, a \* screensize, screensize, screensize); } } &amp;#x200B; &amp;#x200B;
Well I've been doing the freecodecamp exercises but am getting some books so hopefully it will make more sense from a different perspective. 
this update broke node-abi. my app is borken
I dont think this logic translates to an individual. Netflix has employees who they pay to do projects based on their priorities. An individual only has time they are given to spend. Why spend it on something you just give away so another can carry the ball to completion? 
You spend your time because you need it and you give it away because you gain more from giving it away than from not giving it away. Basic logic.
Static resolution and analysis allows for better tooling and optimization.
Discussions like [this one](http://tc39.github.io/tc39-notes/2018-11_nov-27.html#dynamic-modules-layering-change) give some idea why.
Thanks I was looking for something like this.
They just released 3, three months ago. Are they trying for a much faster cadence? 
You're getting downvoted because your own comment brings nothing of value either. The downvote button is there for that.
They have a list if breaking changes in the link from OP. SemVer my dude
That’s totally doable with D3. D3 is just a visualization library and can draw (almost?) any data.
That’s totally doable with D3. D3 is just a visualization library and can draw (almost?) any data.
Part of learning that is what makes you hirable or an asset to your team. 
Historically, there was a split in the JS ecosystem (if you want to use modules natively, without a build step): * Server: CJS, sync loading * Browser: AMD, async loading ES modules undo that split. [Other advantages](http://exploringjs.com/es6/ch_modules.html#sec_advantages-es6-modules): * More compact syntax * Static module structure (helping with dead code elimination, optimizations, static checking and more) * Automatic support for cyclic dependencies
Good to hear. I'll check it out and see if the learning curve is within my timeframe :) It is a library I've heard a lot of good things about... so either way, learning it can't be bad.
Good for you, keep at it.
Good job! Mocking can be very frustrating but it pays off when it finally works. You have more control over your tests and less side-effects. Regarding your concerns: Looks like you can rely on your tests. This setup appears to be sufficient for what you want to achieve atm. Most people would probably use a test runner like Karma for this. It would add dependencies and you would need to spend some time to configure it properly but it's really nice when it finally works. This would give you canvas support without mocks and you can still write your tests with mocha and get results in the terminal. Global variables are rarely encouraged but sometimes it's not worth to avoid it. Since this is for running tests I'd say it's fine. 
Thanks! It's very nice to gain some insight onto his. I would very much like to understand more about this point: "Con: There are files that could be either CJS or ESM – files that neither import nor export. For example, polyfills that install things into global variables. These must be interpreted differently depending on whether they are CJS or ESM." Is there an example available? It's the most import any point on the page for sure. And the ts compiler manages it in a more elegant way (auto detection and metadata)
The fact it hasn't happened in practice is evidence otherwise. Half of Facebook and Netflix are open source. Granted, not all of their apps. Do you feel these businesses have been destroyed by competitors because of this?
Yeesh, looks like somebody's still working exclusively with ES3!
Take a look at any language polyfill, e.g.: https://github.com/zloirock/core-js The point here is that such code often does not export its functionality (then you can detect ESM or CJS), it installs it into global data.
https://electronjs.org/docs/tutorial/application-distribution
Doesn't the internet already have enough scolding, sarcasm, and venom?
Very rarely. I write angular.js and occasionally (twice in the past 14 months) I do it in a Factory. app.factory('BlahFactory', function() { const func = function() { this.a ++; } let a = 1; return { a, func } }); The reasoning here is that you get a new `a` every time you inject the factory, and you don't need to call `new BlahFactory`. That being said, I found a new appreciation for `function` after learning a bit of Haskell. You could write pure functional Javascript if you only put variables on `this`, and you can use `bind` to make monads.
As I understood it, there's no server, like express sitting there running all the time, but the serverless host routes it to a single script/function each time the URL is accessed. No need for long running process
My comment provided to /u/dima11221122 that he provided absolutely nothing for anyone to help him with. "I've updated my app", okay, cool, what does that do for anyone? "but debugger stopped work(", what debugger, what part stopped working? The electron debugger? The node debugger? What error? Did you try anything? Everyone here is getting a hardon for downvoting what this community has an issue with and it's useless complaints about things being broken and that person never responding other than "It don't work". I'm just glad reddit doesn't run stackoverflow.
&gt; Dynamically importing ES modules (always possible via require() in CommonJS): import() Hell yeah.
There are many many reasons: 1. Selling is 1 thing but doing support is another thing. Who wants to turn a hobby into a chore? Especially if the software is not selling well and you have to support those 7 people for a long time. 2. You already mentioned secure day job, but in addition the day job might be boring, conservative, and unimaginative. Where else can you exercise you creative freedom? 3. Open Source contribution is almost like a second resume. In some companies, OSS contributions increase your odds of getting a job. 4. Some OSS came from inside corporate walls. The creator decided that it’s better to release them free instead of rot inside private corp git repo. 5. Some other OSS came from inside corporate walls as well, but they are part of strategic initiatives. Think of Red Hat, Ubuntu, Android, or Kubernetes. Kubernetes might be combination of point 4 or 5. 6. Some small companies released free code with hopes that they can upsell extensions and support. I think NPM model is like this.
Nice, been waiting for this. Brings with it support for BigInt, and other such things which is useful.
You cant compare these companies to individuals. Its like comparing a car engine to a rubberband lego car and claiming they can both move forward so they are equal. Yes I think individuals shoot themselves in the foot if they post projects that increases the competition for the very jobs they will seek in the future.
Thank you! Just upgraded **Video Hub App** to v4! [https://github.com/whyboris/Video-Hub-App](https://github.com/whyboris/Video-Hub-App) &amp;#x200B;
I had 0 issues upgrading to v4 - there were no code changes needed in my app.
thank you! :)
I created **Video Hub App** ([https://videohubapp.com/](https://videohubapp.com/)) and I finally open-sourced it two weeks ago. I welcome feedback, comments, and pull requests ❤️
Deckard Cainabis lol
It sounds like what this community has an issue with is unnecessary hostility. If you’re unhappy with the downvotes, one way you might solve that is to just be less actively hostile to other commenters. 
Upvotes/downvotes are just arbitrary numbers I don't really care, I'm just amazed with how it's a bandwagon to agree with the mob. I don't believe there was actual hostility from my comment, more annoyance than anything. Still not hostile, I wasn't attacking him by calling him an idiot. Everyone else I assume implied by the word "Congrats" that I called him an idiot. I guess everyone who doesn't get hyper offended on the internet is on vacation.
Fair enough, it’s not like that doesn’t happen. It totally does (and it is annoying). I just think it’s maybe less a bandwagon thing in this case, and more just that your comment reads as or could be interpreted as excessively harsh. Idk 
How are custom fields implemented? 
Code has no value in and of itself, it’s a means to solve problems. Sometimes you can sell a useful/clever solution to a problem - but mostly it’s just making tangible the specific goals of a given enterprise, so what is there to sell other than time? Most of these people already have jobs - this what they chose to do with the rest of their time.
There is never an actual good reason to avoid using TypeScript for any package imo
Have you been using angular? Create react app seems like pretty little set up to me.
https://birkir.github.io/prime/#/guides?id=implementing-a-custom-field Docs on demand bro
Awesome
check out create-react-app on npm
I think people like react because of its freedom, you can do any shit you want and the way you want hahaha.
i'm such a fan of cellular automata, \`addFlakeToBack\` is my favorite part!
not like that many would give money to such projects anyway
From the the link under "Why the different file name extension .mjs?": &gt; In order to distinguish between CommonJS modules and ES modules, you need some kind of metadata Why do CommonJS modules need to be distinguished from ES modules? &gt; ES modules can import CommonJS modules via createRequireFromPath(). &gt; CommonJS modules can import ES modules via import(). If these are the only way to import CommonJS modules from ES6 modules and vice versa, then can't it just be assumed that, imported via an `import` statement in an ES6 module or an `import()` call in a CommonJS module, the file is an ES6 module and if imported via the `createRequireFromPath` mechanism in an ES6 module or a normal `require` in a CommonJS module, it's a CommonJS file?
It's community driven, so there's no clear vision.
Of course code has intrinsic value. A recipe for transformation of information. Quick sort implemented in code can be ported to any other language. So it has in and of itself the value of a process to, well, quickly sort things. 
My plan with this was to grow snowflakes using the rules that ice crystals follow. I mainly used this site for research [http://www.snowcrystals.com/growing/growing.html](http://www.snowcrystals.com/growing/growing.html) The way it works is there is a hexagonal grid (based off of some great info here [https://www.redblobgames.com/grids/hexagons/](https://www.redblobgames.com/grids/hexagons/)), and for each "generation" some percentage of cells (which sort of represent water molecules) will have new cells grow around them. Cells that have fewer existing cells around them are more likely to grow more cells. This is what really happens with a snowflake, which is why it starts as a hexagon and then the points start to grow out farther to form "branches" which make them grow even faster, and then those split off as well. There is some randomness thrown in to mimic changes in temperature and humidity which affect how fast it grows and the percentage of cells that grow other cells near them. As you can see, they don't quite look like snowflakes, but occasionally they are quite snowflake like. I am still messing around with it, but I decided it was worth sharing since today is the winter solstice and I'm not sure how to improve it at this point.
Thanks! Me too. Every once in a while I get back into conway's game of life and marvel at the insanely complicated stuff people have created. Have you seen this video? [https://www.youtube.com/watch?v=C2vgICfQawE](https://www.youtube.com/watch?v=C2vgICfQawE)
Looks retro I like it
I've seen some hard to debug stuff coming from moment's internal mutability, having a set of functions is pretty straightforward in comparison.
I must be missing something because I can't really see how it's significantly different from finder/file explorer.
Before you use any new technology you should always ask your self this: What purpose does this serve and why should I use this. React is great for a few reasons. It’s mostly just JavaScript so if you have a good understanding of JS then you should be fine creating React applications. It’s also very easy to get set up if you use create-react-app. You can get to building your project right away and don’t have to worry about much set up. I like it the most because it throws away separation of concerns. I like have my HTML(actually JSX) in the same file as my JS. It is convenient and easy to debug. I personally also love Vue.js but React is also still my go to framework. 
&gt; Upvotes/downvotes are just arbitrary numbers I don't really care After editing your first post your complaining about the downvotes is three times as long as the original text. Kind of sounds like you do care about them.
But didn't you already have that freedom with just plain js HTML and css ? React just puts restrictions over it to conform to their standard
Yep. Use it exactly in that way. Dumb svg components driven by redux / one-way data-binding, using d3 scale helpers in selectors. We also leverage d3 tick generation helpers similarly. That’s all we needed from the library. 
I have. Ive built a few apps with it as well. It was certainly convenient, but not game changing in any way, hence the question
By setup I mean all the additional things it installs for even the simplest of applications. Even Vue and angular just have a simple CDN link we need to just call to get it working.
&gt; The kernel achieves that by making the resolution of *module specifiers* (the URLs pointing to modules) simpler This the next sentence. &amp;#x200B; Show me where it says "why".
A lot of reasons. It enforces modular code, allows you to manage render updates, abstracts component state, and a handful of other juicy things. I love it because it allows me to abstract things in a declarative language that works within the DOM. Its also easier to debug because you aren't managing the DOM yourself. There are some trade offs of course, but feels like a large net positive.
Yes but it becomes unmanageable pretty quickly. React components can encapsulate functionality and abstract away the DOM very easily.
\&gt; I still haven't figured out what the whole hype is about Is there *hype* about React these days? It seems to me, it's just what a lot of people use. React is like the new jQuery — it's hugely popular, and it’s the default choice for many. Historically, React came with a good story for how to easily keep UI in sync with the application state. Before, there was Backbone, which was not even concerned with this problem, Knockout and AngularJS, which went with two-way data binding, and Ember, whose approach I don't remember. React introduced the novel approach of one-way data binding and re-rendering the whole portions of DOM when data changed. That was bold, and, for those days, more performant than the competition. I think it also popularized the way of thinking of javascript apps in terms of components. \&gt; Yes it's highly optimized What do you mean by that? Highly optimized in what way and compared to what other frameworks?
I came across this thread when doing a search for information about JavaScript static variables. I am writing a JavaScript program that does some discrete mathematics and it includes a sub-routine that computes the derivative of a function numerically. In case you don't remember much Calculus, the derivative of a function is simply the rise over the run: dy/dx. In other words, (i) calculate the function value, y1, at x1; (ii) increment the x-value a small amount, h, and compute the function value, y2 at the new x-value, x2; (iii) compute the derivative as dy/dx = (y2 - y1)/(x2 - x1) = (y2 - y1)/h &amp;#x200B; On to the JavaScript . .. The sub-routine that computes the derivative of the function takes h to be the square root of the machine epsilon, for example, &amp;#x200B; `function calcDiscreteDerivative(X, coeffVec, FxnVal, DBL_EPSILON){` &amp;#x200B; `// Computes the derivative of a function numerically, by Forward Difference Approximation.` `// DBL_EPSILON: Machine Epsilon for type double` `// X: the present value of x` `// FxnVal: the function value at x` `// coeffVec: function parameters` &amp;#x200B; `var h, tempX, tempF;` `var eps = Math.sqrt(DBL_EPSILON);` &amp;#x200B; `tempX = X;` `h = eps*Math.abs(temp);` `if (h === 0.0) h = eps;` `X = temp + h;` `tempF = calcF(X, coeffVec); // Calculate y2 at x2` `X = tempX;` `return (tempF - FxnVal) / h; // Calculate and return the value of dy/dx` `}` &amp;#x200B; I am now wondering, Is it possible to turn the variable eps into a static variable? The variable eps does not change within the sub-routine, and is the same each time the sub-routine is called--which may be thousands of times. After eps is calculated the very first time in this sub-routine, it should hold its value and never have to be re-calculated. I have seen mention of IIFE functions, but it seems to be just a fancy way to re-calculate the value of Math.sqrt(DBL\_EPSILON). Any advice? &amp;#x200B; A related question: assuming an IIFE or some other technique is appropriate to emulate a static variable, is the overhead small enough to justify its use? (If it's not, re-calculating Math.sqrt(DBL\_EPSILON) might be the lesser of two evils. Though I would like to speed up program execution if possible.) &amp;#x200B; &amp;#x200B;
What restrictions do you mean? But components are the “standard” abstraction devs like for the web, people want to use them. Web components have become a standard, but we are just reaching the point now that it might be feasible to start building larger apps with them. Companies prefer mature, stable, and supported technologies to mitigate risk (and to attract talent in some cases). There is no “go to” router with this new paradigm, or build process, or state management, etc. Once a few large, high profile, projects have been made with it AND it looks attractive enough to switch, there will be a snowball effect most likely. This is all ignoring other benefits like being able to hire someone who knows react well, easily. It ignores benefits like perfomant diffing. TL;DR: people want components, web components are just becoming viable, companies do not like taking risk, and it fast enough. 
Not sure what you mean by “enforces modular code”? You could write an entire app in a single JSX file?
Get a solid understanding of the terms "Closure", "Async" and "First-class", and the patterns these things lead to. Once you've got that down and you begin to realise the beauty that makes Javascript the gosh-darn greatest language ever concocted, it's pretty much a game of perpetually defending the language against those who refuse to understand it themselves. Be prepared. (Note: this comment will inevitably be downvoted to oblivion)
I don’t think there is hype either. People are more hyped about not using React and Redux than using it. 
The entire job industry general demonstrates that isn't true. Do you really think I could put something on Github and then a company will literally decide they don't need to hire someone because there's a codebase ready to go? That's not how most organisations work. Pretty much no app anywhere involves just pulling one codebase and putting it on the Internet.
But that’s just a directive man... easy to change. Defined earlier on. Mime isn’t implicit. Camel monkeys are just the beginning.
Commenting here as a previous jQuery + Bootstrap user. That shit was nuts, with React everything is more organized and easy to work with with people, and most importantly everything is just performant. Start with benchmarks about react to convince yourself, then move on to things that you're having trouble right now and see how they're being handled in react. For example: events, application state, component state, component rendering performance, the list could go on and on.
No you are misunderstanding. it increases the supply of talent. And lowers rates. 
You might want to go through some of the react tutorials on the site. Just having a state that when it changes updates the various components on the site is so nice compared to "traditional" (no idea what to call it) HTML + JS. 
I'm glad there's at least a plan for a .js extension at some point in the future. &gt; Looking at the pros and cons of all approaches, using .mjs is not the best solution, it’s the least bad solution. I can't speak for anyone else, but all of my projects are already written in ESM format, and I use `.js` for all my file extensions. Renaming all of my .js to .mjs means loosing easy access to history for every source file in GitHub in all of my projects. This isn't the "least bad" solution, for me it's a non-starter. How about: If `package.json` has a `"type": "esm"` in it, then all `.js` files are ESM, and all `.cjs` files are common-js. This gives you an easy way to port your existing babel project to node-with-esm without renaming anything? Again, I can't speak for anyone else, but that's a way less bad solution for me. It's true that this means you need to "look somewhere else" to find out what type a file is, but that's true in the browser, too. Or, even better: if I `import` a file it's compiled as esm, if I `require` a file it's CJS? Then it's just like the browser - the file requesting the module defines the type of the module. We already have this `createRequire` thing for loading CJS from ESM. I could even write a clever module that does something different depending on whether I require it or import it! 
&gt; I like it the most because it throws away separation of concerns. I like have my HTML(actually JSX) in the same file as my JS. It is convenient and easy to debug. That's funny, because that's the exact reason I don't like React. I'm not saying it's bad or you're wrong. I just find it funny.
Thanks! This looks very nice. Interestingly, I'd almost prefer something that was _less_ all-inclusive, and instead put together several high-profile packages. I think of it like diversifying my architecture. If any one package/project stops being supported, I'd be able to swap it out for something else. That's harder to do when the whole application is so closely tied to a single framework -- if that framework goes defunct, I'd be screwed. That said, Adonis definitely ticks a lot of boxes. I'll probably end up trying it out with something.
Some people have mixed feelings about throwing away years and years of best practices and I completely understand that. I just personally like it. 
And `flatten`. But [we can't have nice things](https://github.com/tc39/proposal-flatMap/pull/56). :P
We have the same idea and implemented it few months ago! https://plainlogo.joytocode.com totally free and open source :)
It's when you use imports instead of require
I suppose I could have a build step that renames all my .js files. :P
There are many facets of life that this can be applied to, but the simplest is; I solved a problem that a lot of people were looking to solve. I spent hours working on it - that much is true. But the same can be said about Calculus, the basic laws of Physics, or any other number of crucial discoveries that make up the world around us today. I am not in the camp of giving away ALL of my code, but I do give away answers when people ask. I give them the building blocks, I give them the foundation to create amazing inventions. Now I'm not saying my small piece of Javascript code is any comparison to that of the wors of Newton or the like. &amp;#x200B; But the idea is the same. I'm trying to further a community that has helped me so much. I can honestly say that almost every single Job that I've gotten an interview for (or subsequently been offered a position) has been based on my Github repos, or at the very least, I've been asked to expand upon what I worked on in that project. &amp;#x200B; Keeping a solution that is trivial (to a certain extent) is just like keeping a "super duper innovative idea, that will revolutionize the industry of xyz for abc reason". An idea is a dime a dozen. The way I solve a pinch to zoom directive on a camera plugin isn't going to hinder my chance at success. I know how frustrating it can be to be looking for a solution for hours, days or weeks even, so If it's something that not a market trade secret, then you better believe that I'll share it on Github, or write a Medium post about it. &amp;#x200B; I've contributed to the community, because the next time that you can't figure something out, and are googling it, there's always that chance that someone else posted a similar question, and you have found their answer to the problem. So in a way, it's like paying it forward. &gt;**Ideas** are a **dime a dozen**. People who implement them are priceless. No one cares what your idea or solution is, if you can't implement it correctly to make yourself marketable and sell it. You have to recognize what will better the community by open sourcing it, and what will benefit yourself by keeping it closed. By open sourcing it, I might find a better solution by someone looking at my code and going "hey, I think this could be implemented better if you do this".
I liked it
You don't need it if you have your own framework and app boilerplate. For team projects, I never found a team which would like to learn how to use the framework I use for my own projects, because, in the end, it does the same thing that React do (and they already knows React). So, you will need to know some of these frameworks or have much persuasion to work in team. Note: React setup is near to 5 minutes (from scratch) even if you're not using Create-React-App. If you have your own boilerplate, it's zero minutes.
You're reply was about upvotes/downvotes so you clearly care....
of course it is. and that's a good thing. if it wasn't a problem we wouldnt have jobs. honestly this article just sounds like a bunch of pointless whining.
So happy you typed this for me. I too found it peculiar, but I don't think I have the foundational education I need that would have allowed me to dismiss it. What resources do you recommend for me to fully understand classical lambda calculus?
Benefits of open-source: * giving back to a community one has benefited so much from * equalising society by allowing the most poor access to advanced technology * removing power from corporations that engage in damaging behaviour to protect/increase profits * establish reputation * improve security and quality by increasing eyes on codebase * allow for liveability - project doesn't have to die when author dies or when author chooses to no longer support it
Expecting a node.js fork in 3....2....1....
Exception to this is Google. When they don't feel like supporting it any more they just yank it from market. Oops, did you start to rely on that? Hahahaha *fool*!
But it also allows dynamic imports so static analysis is partway down the toilet anyway
I guess I like reasoning about all of these patterns more like "who calls whom". Maybe I'm a dolt.
sure but even then its a module and doesn't touch the global scope. Promotes is a better descriptor I guess.
Useless article.
The code itself doesn't have really much value compared to the time and energy put in. And contributing code that solves a problem for others to maintain (by putting forth their time) can be really convenient for keeping things running smoothly. If you fix a bug for some tool you use, you might contribute it back such that others will improve the fix so you have to deal with it less yourself as you change machines or environments. Or maybe you're on the engineering team for some service, and you contributing patches to the open source projects you develop on means you have a much less painful time in re-applying all of your new development work whenever you spin something up. In either cases, ease of maintenance and reduction of wasted time is much more important than individual pieces of intellectual property you produce. Anyone could re-implement your algorithm for their needs without your source code if they needed to, but if you were to be monetizing, the incentives and ability to better support, maintain, and ensure the quality of what you're releasing should be your advantage. Also, code you publish really can be really educational for yourself, or act as a resume. And lots of people find freedom of information really cool.
Made my day
Do you think after all these constant API Changes, three.js is not on par or better than Babylon ?
You get more than 1 screenshot (10 at the moment), you have a filmstrip view (video preview coming soon also), better search options, and you can preview media that's on an external hard drive that is not connected (and other features too).
I was given the impression recently that Electron had been sort of shunned by developers in the last year or so because of how heavy and compute-heavy running its applications was. Is this true? Is it used in the industry much?
A ton of it is build tools
Discord, Skype, Slack, VSCode and Mongo Atlas all run on Electron, to give you an idea of how popular it's become. It's hard to say for sure how memory intensive Electron is as some people report reasonable memory usage (for what it's supposed to be doing) and others find it to be an absolute hog, but it does seem to generally be more memory intensive than a purely native desktop app. I work for a large corporation and we're moving our internally used sales web app to use Electron. It gives us full control over the browser and versions so we don't have 15 different sales galleries telling us half are running in IE and the others are on some weird version of Chrome that has a unique bug. It's been working out really well and I personally love it. Doesn't seem like it's going anywhere soon unless the programming community can figure out a better solution that leverages languages that are easy to hire for and allow for cross platform compatibility and ease of hybrid integration. 
If you're sure that's what you want to do with your life, here you go: - [A Tutorial Introduction to the Lambda Calculus](http://www.inf.fu-berlin.de/inst/ag-ki/rojas_home/documents/tutorials/lambda.pdf) (shorter) - [Introduction to Lambda Calculus](ftp://ftp.cs.kun.nl/pub/CompMath.Found/lambda.pdf) (longer) - [Wikipedia article](https://en.wikipedia.org/wiki/Lambda_calculus) is pretty good - Church's original article, [AN UNSOLVABLE PROBLEM OF ELEMENTARY NUMBER THEORY](https://www.ics.uci.edu/~lopes/teaching/inf212W12/readings/church.pdf) (fairly short and readable) That's not, like, *fully* understand — don't think anyone does, and people spend decades over there, but should be more than enough for whatever you're trying to achieve.
Lambda calculus (also written as λ-calculus) is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution. It is a universal model of computation that can be used to simulate any Turing machine. It was first introduced by mathematician Alonzo Church in the 1930s as part of his research of the foundations of mathematics.
I’ve seen more support and attraction than all the years before. People complain a lot but then there’s reality, and currently there’s no alternative for vivid cross platform applications with that kind of upside to it. Native doesn’t come close to the speed and ease of development, the support for controls and components. I don’t think electron will go away until native JavaScript rendering becomes more prevalent.
I agree with this for bigger projects but I've worked with sails js. Gave the devs more flexibly while maintaining the same structure requirements
Thanks for the feedback. :) I did plan to test out different fonts at some point. 
From my personal experience from a recent app that I've built. I agree with you mostly. But sometimes I just see myself doing hacks just to make simple things work. Maybe I'm doing something wrong. But thats the experience ive had. Hence the post. 
Which I see as mostly unnecessary unless required. Having built some tools myself .... I believe that unless a tool is necessary it probably shouldn't be there. But I agree that's hoping for too much. This post is mainly to identify why react is what so many people swear by. Having just dabbled with it I just wanted to know if I was missing on something important. No hard feelings to anyone who does or doesn't use it.
Es6 now has classes for that. I could easily see one using that for encapsulation as people usually did in other programming languages.
From the link posted: &gt;Support for file name extensions other than .mjs. That includes support for ES modules in .js files. 
It does not throw away separation of concern, it was the first framework that actually did it correctly. React separates between logic, which is cleanly and explicitly separated as props with a one way, top down dataflow, and the view layer which consists of the view itself and the presentational logic. The last two belong together logically, and that frameworks previously separated them was a mistake. In older frameworks the presentational logic is part of the view as well (no-if, v-for, etc), but in a way that warrants templates, controllers and inversion if control, as well as a complete cut from scope. Everything you have access to is magically injected. This is all explained here (scroll to "why JSX"): https://reactjs.org/docs/introducing-jsx.html 
First of all I like TypeScript, but as with any tool its usage depends on your problem. I do not see any reason to use it for a pretty small 10-20 line function, but I would also never use such small modules. All the benefits that TypeScript provides are mainly not used in this module. Its internal methoda being mainly consisting of working with the types any or void is not helpful in any way. So all TypeScript does with this package is adding complexity and reducing maintainabilty, by adding another build task, more node modules and higher bundle size.
node.mjs*
It does not throw away separation of concern, it was the first framework that started to do it correctly. React separates between logic, which is cleanly and explicitly separated as props with a one way, top down dataflow, and the view layer which consists of the view itself and the presentational logic. The presentational logic literally builds the view, therefore it belongs to the same layer logically, but it is completely cut off the business logic. In older frameworks the presentational logic is part of the view as well (ng-if, v-for, etc), but in a way that warrants templates, controllers, inversion of control, and a complete and irrational cut from scope. Everything you have access to is magically and implicitly injected for no reason at all. All that this type of "separation" brings is added complexity. This is all explained here (scroll to "why JSX"): https://reactjs.org/docs/introducing-jsx.html
When someone tells you that Electron is heavy and sluggish just rub VSCode to their faces.
I have. Hence the post. Agreed that it maintains state, but that isn't as common from personal experience. And it's benefit mostly seems limited to it's necessity. I was just having a hard time understanding how everyone is moving to it when in my case it only seemed relevant to only a few use cases. I was just trying to make sure I didn't miss anything important.
VScode runs on Electron? Thats one of my favorite IDEs. Its so light.
Thanks for the reply. I had just started learning Electron for fun when I got a bit discouraged and stopped. Maybe I should pick it up again.
I didnt know VSCode was run on Electron. It feels so light. 
Yeah, they really screwed over [draw.io](https://draw.io) recently. 
They are trying to catchup with chromium version number 
[According to W3Counter](https://www.w3counter.com/trends), IE8 right now holds less than 1% of the market, so you should not be touching that at all. Even if you want to target old browsers, you should probably be developing on a modern system and then use things like [Polyfill.io](https://Polyfill.io) or [Babel](https://babeljs.io/) to recompile to older Javascript. Trying to write IE8-JS nowadays is going to be pretty painful.
Because the people making it know what they're doing which is more than most people releasing Electron apps besides the big names.
Good for decreasing development cost. Shit for users. Just like corporations like it!
A friend of mine would say because private repos are paid :/
I’ve used GoJs in the past 
Amazing thanks for sharing &amp;#x200B;
&gt; *We should see front-end development as a unique skillset that is critical to the success of any project.* Nobody cares if it's a unique skillset or not, it's about economics.
Nah, shorter development time is better for everyone
Did they fix the video playback performance problems? Playing 1080p video smoothly in an electron app on a raspi 3b is impossible as far as I experienced it https://github.com/balena-io/resin-electronjs/issues/9 
I wonder if VS Code doesn't rely upon so many dependencies? How do they run such a fast app?
Thanks so much, this was just what I was hoping to hear. Merry Christmas!
Even though this is /r/javascript, you will find it difficult to argue that missing native level of integration is better for users.
Doesnt that take away almost the entire benifit of using modules? You'll lose static analysis capabilities
Wonderful project. Spent quite a bit of time trying to get various shapes and really had a blast. Thank you!
I've read somewhere on reddit that vscode is using electron for display only. For other functionality (like file search, linter) they are using other language / magic and not electron / javascript, so that it can be fast and optimized.
This reminds me a lot an answer I left a month ago [there](https://stackoverflow.com/a/53179716/2494754), after some struggling! 
While you’re completely correct about people asking for help, I don’t think dima11221122 was actually asking for people to solve their problem. They just commented that something didn’t work. 
Depends how complex the logic is, but in this case, with such weird variable names and magic numbers, the code would be more self-documenting with a well-named function...
Workin hard on open source task manager - [https://github.com/taskill/taskill](https://github.com/taskill/taskill)
It's gotten really easy and quick, and there are a lot of benefits.
First, we're missing a huge chunk of context - and that problem would be solved with good variable names. 
That’s a nice find mate, but damned if i’ll ever write code like this intentionally
Everything is an object in javascript :3
I liked the user profile pictures 
Looks cool, but I’m curious to know why you’ve chosen Electron and Angular for a desktop app in comparison to other technologies like React or even native frameworks. Would love to hear some insights and experiences you’ve made. 
Why should Node.js stay close to the browser? That makes it possible to reuse code. For example, to write libraries that work both on browsers and on Node.js. It also makes it easier to switch between frontend and backend when coding. 
I don't see many people commenting on the one most important thing for me, which is the fact that you write components as a function of the state, and never have to worry about keeping your UI in sync with the state. Before React, you had to *update* you DOM tree accordingly to your application state. That usually involved one of two bad options: * Throwing everything away and re-rendering everything from scratch, which very often is not an option because you don't want your stuff flickering and * Changing the UI programatically, adding or removing classes, changing the contents of some nodes, adding or removing nodes, etc. This is messy and a never ending source of bugs, where the UI is not correctly updated to reflect the state or you have an only partially updated UI. React changed this in that you write *only* how to render your UI from the state *as a function*, from scratch, and you never have to manually change your DOM. React figures out what changes are necessary to change from one state to the other. This simplifies things a lot and results, IMHO, in cleaner and less buggy code.
Isn't es7 await/async exactly this as native?
No just noise on places like reddit. 
This is getting pretty academic already, but if a one-line comment would make the code more obvious, then it's not obvious enough. Granted, this fine example by the OP would probably be clear as crystal just with proper variable names and constants, but things get hairy pretty fast when the conditions get more complex, or the number of options increase... Anyway, my original point here was that ternary is not the *only* way to "avoid mutation/reassignment" -- you can do the same thing with a function.
It's actually very convenient when you want to omit properties of an object in a immutable way. const copied = { propertyToInclude: source.propertyToInclude, ...(source.propertyToOmitIfFalsy &amp;&amp; {propertyToOmitIfFalsy: source.propertyToOmitIfFalsy }) }
This is not remotely true. 
Thank you!
JS is a special creature :)
Why not just use webpack.config.ts? 
I'm not sure how it's broken down, but when it makes sense, VSCode will use other tools to perform functionality. For example, it ships with [ripgrep](https://www.reddit.com/r/rust/comments/5zu1z0/vscode_adds_support_for_ripgrep_in_latest_nightly/), and ripgrep is written in Rust.
Primitives aren't objects, but just are autoboxed to look like they're objects, and null or undefined aren't even autoboxed.
Really think Flutter on desktop will cut into use of Electron at some point. What is interesting is the two both leverage Skia. The biggest difference is Dart with Flutter versus JS with Electron.
Thank you for taking the time to type up an example, I appreciate it! Personally I would still write an util function to loop thru object keys and remove falsy value because I think it’s easier for others to read, but I can see how it’s useful for an object with only a few keys &amp; you know exactly which key to check.
This! Thank you!
[removed]
Why do people always post literal pictures of themselves along with their article on web subreddits. 
Can you help explain what is technically challenging or difficult in implementing jdalton's esm approach? I'm no expert here and I know there is a lot of backwards compatibility to address but I was hopeful the official approach wouldn't require mjs extensions.
A cleaner alternative is to create the object in one step and then do an if statement for the false value and only add the key then. That’s the more conventional way. But if you have more than one conditional property that can get repetitive. 
[removed]
not really sure how that actually works
What are the benefits against using one of the jsonschema-validators?
Just wrote an [elaborate answer](https://www.quora.com/Why-choose-React/answer/Robin-Wieruch) on Quora today. Maybe it's helpful.
i mean it's cool if you have a hard requirement that you're not allowed to use `delete` but often times just looping and checking conditionals and deleting ones that fail is much easier for most people to read and follow.
Do not Open Source your main business. Google (Search Engine), Adsense, YouTube, Windows, Office, Facebook, Amazon are all not Open Source.
if that was true, you could call methods on `null` and `undefined` like you can call methods on `nil` in ruby.
Thanks for the question! Primarily my choices pivoted on what I knew: JavaScript and Angular (had to learn it at/for work). In part the idea originated at work when I had to implement a search bar that auto-updated results live: it took so few lines of code with Angular (using a *pipe*) - it blew my mind. I also realized that I wouldn't have to learn how to code a UI (user interface) since I could just use HTML. And Electron allowed me to effortlessly generate the app for Windows, Mac, and Linux without changing any code! Once I saw the pieces could work together, I started. I *really* love Angular. It's powerful, and allows many people to work together on a large project without stepping on each others' toes. I'm sure React is similar in these ways. Vue wasn't really on my radar since I wanted to code fast and create the app rather than learn something new. I've only used React for a few weeks while touching a project at work; I'm confident it's an excellent alternative to Angular (even for what I've built), but Angular was a better fit for me. As a side note, take a glance at this mind-blowing UI - a React &amp; Electron app: [https://github.com/fakob/MoviePrint\_v004](https://github.com/fakob/MoviePrint_v004) 
ps - as a bonus, since I'm using a web technology for the app, I was able to create a "web-demo" of my app. Needless to say it's missing the most important parts of the functionality to be useful, but it allows you to see how the UI, search, and animations work: [http://dev.yboris.com/vh/](http://dev.yboris.com/vh/) (please note this is based off version 1 that came out February 2018).
Well, first time i used react i found pretty hard to config webpack properly, but im newbie.
&gt; Which I see as mostly unnecessary unless required. That's baffling to read really. In what kind of project build pipeline is not required? You don't have to support old browsers? You gonna ignore asset bundling, code splitting, tree shaking? You really want to ship inferior, less performant mass of code?
why do you post your comment for free?
Agreed, VSCode is easily my favorite IDE and I've used quite a lot. It still has a long way to go in replacing an IDE like IntelliJ if you're in Java or some other specific language, but for Javascript, Node, and front-end development, it's amazing. 
const trace = console.log; If you come from ActionScript 3.
For the sake of humor, I see his/her point, but you’re right, it’s not really true. But getting results from the `typeof` operator might lead one to believe otherwise.
technically `typeof null === 'object'`
&gt; typeof 5 &gt; "number"
I mean everything can be traced to an object except for primitive datatypes.
Nice! You should also check the responsiveness. Some text overlapping but, still super cool! Would be cool to see it native too.
I would actually challenge the claims that this is harder to read. I find it easy to read. I think "harder to read" in cases like this is actually "I haven't learned about this language feature" and "I'm not accustomed to seeing code written this way". I don't think either of those issues warrant much consideration when you think about how to write your code.
And this is like what? Readable?
Yes, obviously it works as expected most of the time. But `typeof (someArray)` will return ‘object’, as will `typeof(null)`, both of which are results you would not *necessarily* expect (though you should at this point, if you have experience with JS). Also it’s a bit ambiguous what `typeof new Number(1)` *should* return. Without any experience with JS, I’d believe you if you told me it returned ‘number’, but instead it returns ‘object’, which is also something I might expect. The point is, the `typeof` operator doesn’t always produce the most *intuitive* result, and ambiguously typed operands return ‘object’ fairly often.
There are some good use cases for this. Stemming from the fact that accessing undefined object keys returns `undefined` values which are falsy. Imagine a state object holding a set of other "staged" change objects indexed by a unique key. May be used for an "undo" behavior or a form or whatever. As you edit fields of an original object, they become "staged" and now need to be merged with whatever changes were there previously. You _could_ null check existence of the key, assign the key to an empty object and then mutate it, but that's cumbersome. You can instead unconditionally (and safely) update state via spread the way OP highlights. Example update = (key, changes) =&gt; { this.staged = { ...this.staged, // the value of this.staged[key] may be undefined [key]: { ...this.staged[key], ...changes } }; } So yeah spreding falsy values is actually pretty useful in real world problems. 
It’s the eternal struggle.
Typings aren't included in the bundle, it's transpiled to js.
This should work in Rhino ... [https://github.com/agershun/alasql](https://github.com/agershun/alasql) AlaSQL.js - JavaScript SQL database for browser and Node.js. Handles both traditional relational tables and nested JSON data (NoSQL). Export, store, and import data from localStorage, IndexedDB, or Excel. [http://alasql.org](http://alasql.org/) 
A couple years later when a junior dev foolishly starts using that object elsewhere and spends three days trying to figure out why the property they expect occasionally disappears,… you can say, “try grepping the whole project for `delete`’s, then please refactor that shit to behave immutably.”
I use floorplans in one of my applications, and have had good success using non-geographical maps in Leaflet.js. You can find details about how to set it up here: [https://leafletjs.com/examples/crs-simple/crs-simple.html](https://leafletjs.com/examples/crs-simple/crs-simple.html) &amp;#x200B; All you need to do is define all of your x and y coordinates, and you're good to go. &amp;#x200B; Alternatively, since this sounds like a program that doesn't need to be replicable, you might consider drawings up an SVG in a CAD program, illustrator, or something else, and then adding code on top of it. 
I started to play with JS at the beginning of this year. I coded a few times a week, an hour or two after I came home from work. But from July this year, I have really kicked up the tempo and set myself clear goals on what I wish to acomplish in the next 8-10 months. This includes a personal website and a portfolio with 3 projects which I can showcase on job interviews. I just finnished my second project. Next is React. For the next two months i plan two learn it and have a complete project using that framework as well.
Thank you for pointing that out to me. :) I will correct it. English isn't my native language so I probably make a lot of spelling mistakes. I guess I'll start using a spelling and/or grammar checker.
Thank you for checking out my app :)
Thanks for checking out my app :) I appreciate it.
Thank you for the advice, and for checking out my app. I have been planning to try out different fonts and see how that fits with the overall design. 
Thanks 👍I appreciate it.
Mmmmmh not exaclty. The object spread works fine with ALL values (not only falys ones) because if you use the object spread with a non object, JS will wrap it in its object counterpart (sometimes referred to as "autoboxing"). And you are misunderstanding the following: `{ ...isFine &amp;&amp; { fine: true } }` You have to see it like this: `{ ...(isFine &amp;&amp; { fine: true }) }` &amp;#x200B; What if `isFine` is a **truthy** value? It will become: `{ ...{ fine: true } }` What if `isFine` is a **falsy** value? It will becomes: `{ ...isFine }` For example, if `isFine` it were the Boolean `false` value: `{ ...isFine }` \-&gt; `{ ...false }` \-&gt; `{ ...new Boolean(false) }` \-&gt; `{}` Why the empty object? Because a Boolean Object has no own property
&gt; “I haven't learned about this language feature" and "I'm not accustomed to seeing code written this way” It’s kind of a Luddite view. Now when people call modern js bad because they refuse to learn the language, I just link them to the MDN doc on destructuring &amp; some DocAxe tuts. They usually get kind of excited about it after that. 
Thanks. I like them too 🙂 They look very goofy and play very well with the overall design.
Yes, there are still some finnishing touches that need to be applied, across the entire app, not just the responsiveness aspect. I am currently learning React. After I create a project using that framework, I plan to check out React Native, and maybe rewrite this app for mobile. After all, it is more useful to have this kind of app on a mobile phone, not in a browser. Thanks for checking out the app 👍
I have been working on this app for two months. I have put in a minimum of 4-5 hours per day, on average. I needed that much time because i was learning a lot at once. Node, Express, MongoDB, ES6 JS, RESTful APIs, Mocha, Chai, writing integration tests, using webpack etc. When you try to streamline so many new things into your learning process at once, things move much slower. But I knew it was going to be that way. I wasnt in a hurry while I designed the app. I was trying to internalize everything at a slow and consistent pace. The opposite approach is to build many small projects, and add 1 or 2 new technologies on every project. Thanks for checking out the app. 👍
Today’s language feature is tomorrow’s anti pattern. I agree with your sentiment in general, but I think people are skeptical of this for reason similar to why many folks believe falsy equivalence ‘==‘ should never be used.
It really depends on what are you looking for. This lib will return on first failed check. What means you loose the ability to get all errors from all invalid properties of a data like in other libraries. But thanks to that you gain a lot of performance comparing to throwing an error on failed check. So, I'd say the only real advantage is performance, which may matter when designing public APIs. And ability to validate other JS objects like Maps, Sets (don't really know if there is a use for it though). Although, like AJV this library needs some time to compile validation functions. For example if a value fails some checks you might want to get some information about this value in error message. Like printing the value to the error message, printing type or any other information. But this will cost you, in some cases a lot. JBQ for now prints the type of the value, but you can change it any time. 
That's totally fair if it should be avoided because it's an anti pattern.
Well, obscurity of the feature should be considered. That's going to cause maintenance problems for non-senior devs and engineers.
Well you're comparing it to other fully featured IDE's. Is VSCode light compared to Notepad++ or vim? No.
Because of how GitHub url resolving works.
to add to this comment, look at the history of open source, The internet wouldn’t exist today without it. GNU/Linux is open source. BSD is open source. much of what powers the internet and allows companies to flourish is open source software.
FWIW Typescript throws a nice sane error on this: &gt; Spread types may only be created from object types. http://www.typescriptlang.org/play/#src=const%20a%20%3D%20%7B%20...false%20%26%26%20%7B%7D%20%7D%3B
Had this same "issue" with some folks I worked with in a perl shop a year ago+. Trying to introduce map to former Java devs was like telling them their children were going to grow up to be serial killers. They just weren't having it. There was one guy there who actually took the time to look into it and couldn't see the utility of it, but the others were grappling their for loops and array recreation strategies to the end.
If it's possible, consider dropping down to Java. Its ecosystem is far larger than Rhino's.
I actually hate that GitHub does that, and I thought about sharing the docs page instead. I am sorry
Ever heard of the "give a man a fish, teach a man to fish" thing? People volunteer at food banks etc to help people in need. They want to help. I don't think there's much explanation required there. People doing open source work are kinda the same, except that instead of just giving people food for one day, they provide tools that others can use to make a living. And not just make a living, but make enough money that they too can have extra time to do things they want. Things like paying it forward with their own open source work.
Atom and VSCode: A Tale of Two Electron Based Editors
Learning and relearning javascript canvas. "modern art generator" [https://imgur.com/a/LB7rGZN](https://imgur.com/a/LB7rGZN) var canvas = document.getElementById("canvas"); var ctx = canvas.getContext("2d"); &amp;#x200B; for (var i = 0; i &lt; 100; i++){ var r = Math.floor(Math.random() \* 65); var g = Math.floor(Math.random() \* 134); var b = Math.floor(Math.random() \* 244); var r1 = Math.floor(Math.random() \* 255); var g1= Math.floor(Math.random() \* 95); var b1 = Math.floor(Math.random() \* 15); var grb = "rgb(" + r + "," + g + "," + b + ")" var grb1 = "rgb(" + r1 + "," + g1 + "," + b1 + ")" var x1 = Math.random() \* 890; var x = Math.random() \* 890; var y1= Math.random() \* 700; var y = Math.random() \* 700; var w = Math.random() \* 100; var h = Math.random() \* 100; var Csz = Math.random() \* 50; ctx.fillStyle = grb ctx.fillRect(x, y, w, h); ctx.beginPath(); ctx.arc(x1, y1, Csz, 0, Math.PI \* 2, false); ctx.fillStyle = grb1; ctx.fill(); }
Thanks for the explanation &amp; code example, I appreciate it! What's the different between spreading key like you did vs. spreading `changes` directly into `key`? If I understand it correctly, even if `this.staged[key]` is undefined, it'll be overwritten by `{ ...changes }` anyway. ``` this.staged = { ...this.staged, [key]: { ...changes } } ``` Also, this is assuming that `key` is always an object, is it correct?
Oh wow, u/lhorie replied to my comment? This is better than being gilded. mithril hold a special place in my heart, sir.
Alasql is amazing. A few quirks. Well worth it when you know sql
I hear you just making sure we're comparing things fairly. They main draw for react is the virtual DOM so definitely read up on that if you haven't already. Vue has a virtual DOM as well though
This isn't standard behavior, it only works in chrome. It's a proposed feature that may appear in future versions of the language.
[removed]
VScode might not be as feature heavy as eclipse let's say but it still has a ton of features. I found it's performance comparable to sublime text which is just a text editor. 
no problem, really glad some of this info can help others!
Merry christmas!
Its in there, read though the 'Getting Into The Code' and 'Running your code' 
You don’t ** need** all of those things. All you need is: ``` &lt;div id="root"&gt;&lt;/div&gt; &lt;script src="https://unpkg.com/react@16.0.0-rc.3/umd/react.production.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/react-dom@16.0.0-rc.3/umd/react-dom.production.min.js"&gt;&lt;/script&gt; ``` Reference: https://egghead.io/courses/the-beginner-s-guide-to-react
Yes, `key` is always an object. The code example also implies that different changes are applied to the same object in several passes. As in one pass may alter the field "bar" but the next may change "foo", so both need to be tracked.
I actually wrote code Friday where I would have needed exactly this syntax. 
For the record, Java and JavaScript are two different languages with nothing in common. 
Sorry! I’m kinda doing this on the fly and google is no help. I can delete and move if needed, but when I searched for JavaScript Reddit this is the first thing that came up. I realize now this is only java. My bad. 
You might try STFW first: [Why Did We Build React?](https://reactjs.org/blog/2013/06/05/why-react.html) [When Does a Project Need React?](https://css-tricks.com/project-need-react/) [Thinking in React](https://reactjs.org/docs/thinking-in-react.html) TL;DR It makes implementing and managing changes, especially those based on application state, to the DOM, much easier. 
I've done it like this, which I think is more readable: const copied = Object.assign( { propertyToInclude, propertyToInclude2 }, propertyToOmitIfFalsy &amp;&amp; { propertyToOmitIfFalsy }, propertyToOmitIfFalsy2 &amp;&amp; { propertyToOmitIfFalsy2 }, )
In JS, however, they are. The biggest difference (besides the api of course) is that members of sets are unique.
Ok thats one point. But why not implement a fail-on-first validator on jsonschema? I mean, why should I ever want to relearn a validation-standard when there is no benefit.
lava lamp: [https://hapax.bitbucket.io/lava/](https://hapax.bitbucket.io/lava/) reload to restart
Yes. We write a lot of object mappers, and this pattern proved to be quite useful, and pretty readable.
We actually enforce immutability with [https://github.com/jonaskello/tslint-immutable](https://github.com/jonaskello/tslint-immutable)
[https://codepen.io/MrVincentRyan/pen/pqeEYE](https://codepen.io/MrVincentRyan/pen/pqeEYE) &amp;#x200B; I reskinned space invaders around gatwick. Could anyone help me implement touch controls. I am really struggling on figuring out how to set it up
No they don't.
Who have I spoken down to? You seem upset that someone doesn't agree with your opinion.
We require arrow functions.
Electron is not the final destination of this train, eventually we'll create better and more efficient tools, but for now Electron is an incredible step in the right direction, the cycle of better software will continue churning. I'm not positive what you mean when you say electron is missing native level integration, but I'm assuming you mean the abstraction of using a rendering engine instead of making api calls to render os-specific ui- but one could argue that having an abstraction layer above the os api is both common (see wxwidgets, qt, libgtk, sdl, sfml, unity) and necessary. I believe that the impact on the user is directly measurable and negligible, how exactly do you think users benefit from having "native code"? Do you think that the user's inputs are delayed when using electron? They aren't. Do you think that the increased ram usage causes any large portion of the general population direct pain for some reason? Seeing the bar 5% higher causes them a panic of some sort? Is it possible you think that user's energy bills are affected by using electron?
Popular opinion can never be wrong, eh? You should google "argumentum ad populum"
I'm good. I know the correct way to use consts and will stick with it.
LOL okay bud
Ternary operators are never necessary. They're handy, yes, but never the only possible solution to a problem. Considering how often new developers get stumped by them (see OP), it's easy to simply prohibit them in our ESLint config and not worry about it.
Why would a user ID change?
Parentheses only have a detrimental effect on readability
In terms of raw functionality, no, it isn't a constant value, but that's a weakness of the language. Const is only half-assed in its implementation in JS. Using it correctly solves the half-ass nature of it though.
&gt; half ass-nature *** ^(Bleep-bloop, I'm a bot. This comment was inspired by )^[xkcd#37](https://xkcd.com/37)
If ticketPrice is a variable, use let. Clearly it's a variable if the value is different with different input.
Yes it is.
You don't seem like someone willing to learn though.
That's simply because const was not implemented correctly in the language. This is why JavaScript has such a bad reputation. The correct usage of const is a value that never changes.
I honestly have a hard time following what your comparing react to / figuring out what you imagine working on where react isn't useful.
Why would you pretend to be someone else and get butthurt when I respond to you as if you were the original commenter?
I strongly disagree with that rule and thus don't use it. 
I don't give a single shit about your opinion.
Appreciate your extension. Yeah, I could've written the whole how *Logic And Operator* works and how *ToBoolean* conversion works, but I just wanted to leave a quick note and get back to work :) But thanks, it really is useful addition to my post!
Actually I just normally asked a question in the conversation. Where exactly did I pretend to be the other guy?
You responded to someone else's comment chain and acted butthurt that you were mistaken as the other person. Fuck off to my block list you lazy troll. 
It’s worthwhile to consider that you already trust several companies. You don’t make your own capacitors, CPUs, hard drives, routers, operating systems, or web servers. And when you write software, you don’t write your own language and use only your own libraries. You don’t make your own CPU because making CPUs isn’t your goal. Likewise, serverless is attractive when managing servers isn’t a goal.
You're welcome. I thought that your version could lead to unnecessary misunderstandings, the language is also too criticized so I added something :)
WebGL simulation of what would happen to the rings of Saturn if you put Earth in orbit around Saturn. You'll find it [here](https://thehappykoala.github.io/Harmony-of-the-Spheres/#/scenario/Earth%20VS.%20the%20Rings%20of%20Saturn).
I'm blown away that you're still holding this position despite the multitude of well reasoned counterarguments and reference material provided in these comments. You have not once even attempted to provide a reasonable argument to back your claim up. Talking down to people, being unable or unwilling to form logical, coherent arguments, and blindly follow dogma are definitely not hallmarks of an effective engineer, leader, or professional of any kind. If you were on one of my teams, we'd already be having discussions about how to deal with the /u/Historical_Fact problem and considering cutting you loose. If this is how you behave out in the real world, your success will be severely limited. I sincerely hope you eventually grow out of this.
 const scoreModConversionTable = [ { limit: 3, mod: -3 }, { limit: 5, mod: -2 }, { limit: 8, mod: -1 }, { limit: 12, mod: 0 }, { limit: 15, mod: +1 }, { limit: 17, mod: +2 }, { limit: Infinity, mod: +3 } ]; function scoreToMod(score) { return scoreModConversionTable.find(function(c) { return score &lt;= c.limit; }).mod; } scoreToMod(3); // -&gt; -3 scoreToMod(7); // -&gt; -1 scoreToMod(17); // -&gt; 2
Why would I care if a handful of trolls don't agree with my position? How does that affect me in any meaningful way? Why does it affect you? And I'm not at all concerned about your fictional revenge fantasy because some guy on the internet doesn't accept your opinion. How do you feel about the fact that I'm the one at my company who makes the decisions about what syntax to use or not? I'm the one who decides how to configure ESLint and I'm the one who decides if pull requests get merged. Does that trigger you? Good.
The same way you build any other string... document.getElementsByName("bla" + someVariable + "otherstuff") But, as the name suggests, `getElementsByName`, gets **multiple elements**, so it will always return a list of elements. This means you **can't** get the value like you're doing. You'll need... document.getElementsByName("bla" + someVariable + "otherstuff")[0].value In any case, for this type of question go to /r/LearnJavascript
Awesome. Thank you. One other question if you don’t mind. Say I have one box labeled Score and one labeled mod.. How would I display that? 
Now I am confused. What does this have to do with Java? If you're writing a script that will run inside a PDF file, that will be JavaScript, not Java. In any case, there are many ways you could do this in JavaScript. One simple approach would be to use an array: const scoreToMod = [ undefined, undefined, undefined, // 0-2 -3, // 3 -2, -2, // 4-5 -1, -1, -1, // 6-8 0, 0, 0, 0, // 9-12 +1, +1, +1, // 13-15 +2, +2, // 16-17 +3 // 18 ]; const mod = scoreToMod[score]; if( mod !== undefined ) { // Do something with mod } 
I think the first reply is mentioning how I did not fully type out JavaScript in my post but I corrected that in an error. I had a feeling someone would mention arrays and I was dreading it because that’s what I could never wrap my head around when I was learning to code. Granted this was in C++ but still. Either way,if I were to have two text boxes, one being the score and one being the modifier, this code would obviously go into the modifier box but will it auto display. Another answer posted code but I couldn’t get it to work. Would I need to name one box “mod” and one box “score to mod” for this to go properly?
* “Why do CommonJS modules need to be distinguished from ES modules?” * Because they need to be executed differently, due to how their imports&amp;exports are handled and due to them always being in strict mode. * Infer the type of a module from how it is imported? * That is indeed something that the new rules _almost_ enable (it would work similar to browsers then). But there is still the very first module.
For detecting the module type, you need to pick one of several approaches ([for details, look here](http://2ality.com/2017/05/es-module-specifiers.html#why-new-extension)). Each has pros and cons.
Yeah, that's a good question and answer. Generally on production projects it's quite obvious choice that you'll go with validators that support JSON Schema. No more reasons are needed besides that it has been around for some time and it's well thought. I just didn't choose JSON Schema because implementing it would require a lot more time that I have right now. So, there was no point in starting a project that I would never finish.
Nice bait m8.
More like it confirms that the JS community is very hyper-sensitive. No wonder it has so many political issues.
Thank you for replying. I'll re-ask there.
Don't be afraid of arrays. They are one of the simplest things in JavaScript and in other languages too. Does the array example above make sense? The big array literal creates an array with values filled in as shown. And the expression `scoreToMod[score]` fetches a value out of that array depending on `score`. Let me know if you have any questions about it. Regarding the text field names in the PDF, no, their names don't have anything directly to do with JavaScript variable names. You use the `getField(name)` function to get a _reference_ to a field in a JavaScript variable, and then you use properties of that field reference to access or change the field's value or other characteristics. For example, let's say you have a text field named `MyScore` and another one named `MyMod`. You could fetch the value from `MyScore`, look up the appropriate mod value with the array above, and store the resulting mod value into `MyMod` with code like this: var fieldScore = getField( 'MyScore' ); var score = fieldScore.value; var mod = scoreToMod[score]; if( mod !== undefined ) { var fieldMod = getField( 'MyMod' ); fieldMod.value = mod; } You will want to refer to the [Acrobat JavaScript Reference](https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/js_api_reference.pdf) for these details of how to access PDF form fields and other items, as it is quite different from the browser or Node-based JavaScript you will usually see discussed. The _JavaScript language_ is the same (except for being an old version), but how you get to stuff in the PDF is different.
This is going to be fun :-) [https://github.com/cztomsik/node-webrender](https://github.com/cztomsik/node-webrender)
&gt;They are all 403 errors, which means Forbidden. In other words, the server understood the request, but will not fulfill it, so it returns you a 403 codeCheck if those files are accessible, or do you have the necessary permissions &gt; &gt; &gt; &gt;I am trying ''inspecting elements'' in order to learn javascript, anyway in simpler words, those files are not accessible, some one on the serve side has made a block on them? I am also learning cybersecurity as an hobby. If some one stranger would know the contenents from a stranger of this files may be dangerous for a company, for example? &amp;#x200B;
Yes.
You shouldn't be getting mangled symbols, unless your opting in to a minified/prod build.
I am building an open-source e-ticket system and I am looking for contributors! Budapest already tried accomplishing building an e-ticket system several times with projects like Electra or RIGO, but they’ve always failed because of bad resource/money management and/or several time overruns. Because of this, some of my classmates and I decided to build our own modern, ReactJS and NodeJS-based, secure, reliable, open, free and well-designed e-ticket system in the person of Pass. Our goals include a QR-code based ticket system, NFC and electronic ID card support (like RIGO or Oyster), support for prepaid card types (like MetroCard) and porting all of BKK’s ticket and pass types onto our system to make it suitable and usable for most cities. And we are looking for contributors: developers, patrons, white hat hackers, people of the press, head of public transport companies, anyone who may be interested in this kind of project. &gt; If you are a developer or hacker, obviously you can help us by developing new features, fixing bugs, searching for security issues, maintaining the code base and writing documentation. We will try to give every help for you make you feel home in the project. More details: https://github.com/dandesz198/pass &gt; If you are not a developer but have some spare money you can donate to us once or regularly, you can donate for us on Patreon. More details: https://patreon.com/passtransport &gt; If you can’t or don’t want to develop or give money, you can still help us by spreading the word and sharing the project, so that the project gets into the ears of the press and maybe even the government.
Argh, I like having types but TypeScript is in my way a lot of times. This syntax is very nice for writing in a functional style. Especially, if you like short functions.
I never even stated an opinion, just for the record.
If you want to integrate with optimized code your code should be used as a ‘require’ or npm package that can be included at build time with the rest of the code. You should never be trying to access classes of optimized code externally.
I second this. Trying to predict how optimization would affect elements is the wrong way to go. If something else you haven't coded for optimizes differently, your code doesn't work. 
The best part is how it makes me think “why didn’t we do it this way from the start” which is the hallmark of a great framework. It’s so intuitive and grokable, and feels good to visualize
So you don’t care about newer developers being confused by arrow functions? They’re even more terse than ternary!
After you've seen it a couple times. Yes. It can obviously be more tidy than their example. 
Var + Let? :) &amp;#x200B;
That's a beyond reasonable pace. I read somewhere that node takes a month of studying to be relatively good. 
They're not more terse than ternary operators. They're necessary for preserving context. 
I am impressed by how pretty the readme is!
lol nope &amp;#x200B; You don't have HTML and CSS in flutter which makes it just like QtQuick. Not dart which makes it faster (have anyone noticed how they say they needed to use dart because js can't 60 fps but on every other page they praise how js is fast and good enough for 60 fps on web?). Also new web standards incoming will make it even faster. &amp;#x200B; But would be good if flutter came to desktop I guess.
Yeah, looks like rot.js used to modify the prototype of `Function` to include an extend method. You can see it here: https://github.com/ondras/rot.js/blob/f8dfeb711bcef2659c491be11ee044e84bd01857/src/js/function.js
This is commonly used in React components and also in the official docs for Conditional rendering: https://reactjs.org/docs/conditional-rendering.html#inline-if-with-logical--operator
```javascript document.querySelector("[name='fielda["+$countForm+"]']").value ```
There is web Flutter already. Flutter is really a scaled down Electron with a better developers US. https://medium.com/flutter-io/hummingbird-building-flutter-for-the-web-e687c2a023a8 Hummingbird: Building Flutter for the Web – Flutter – Medium 
that's actually really good to know. i know of a few places where i could've used that, but i just went with the const x = { ..whatever.. }; if (y.thing) x.thing = y.thing; 
having used languages that have had modern JS style array mapping functionalities going back as far as the early 90's, it's something that i've really missed in many languages up until now. 
Vscode performance is far from sublime text performance, wether you use cpu cycles, memory or starting time as metric.
 My company wants to implement something like a prettifier + linter. But, we don’t want to loose the “git blame” does anyone know of anyways that we can just format the diff from each commit rather than all the code in that particular file?
please share your tsconfig and webpack.config.js. with the right configuration. then you won't see a difference in the code after its bundled
embed it as a ifram html code to the other webaddress
I think this behavior actually allows for a very useful pattern: conditionally setting properties during object construction. I would probably use null and a ternary to be really clear about my intentions, but something like this has been really handy: const obj = { a: 1, ... hasB ? { b: 2 } : null };
thanks for sharing this, I'll try to see how far i can push webpack, before it gives compiler errors
I don't think so. You just have to bite the bullet, apply your code prettifier once to your entire codebase, and then after that git blame will work fine. If you need to check git history from before the great formatting, you still can, you just have to git blame the commit before the reformatting.
If you want your code to be approximately 90% slower -_-
As I said in the article, this code was adapted from a simpler snippet I've found elsewhere. This is not an excuse of any sort, just a little thing I overlooked &amp; fixed now :) Thanks for reading and pointing it out!
https://hackernoon.com/javascript-performance-test-for-vs-for-each-vs-map-reduce-filter-find-32c1113f19d7
Thanks. How do I find the embed html from the map site? 
In the actionhero project, we make “standard” (standards.com) a prerequisite to any PR. It’s run just like the other parts of the test suite. It’s a wonderful system that defers “style” outside the .org. 
search google for ... convert url to iframe
Please don't just down-vote this. As somebody who has already got their hands dirty with this version in production, it's very important that /u/yboris should take part in this discussion so he can answer questions about it.
Aha, interesting. Do you have any suggestion for re-coding that if using a new version of the library? 
thank you.
With you on all counts except that I have 4 electron apps I use regularly as a user. That 5% just became 20%. See where I'm going?
Not sure about you but all corporate software I use is both native AND shit for users.
Pretty sure for loops are more performant but I doubt the performance hit of using reduce matters much. Do whatever you think looks cleaner.
Why is anyone still using AngularJS 1.x? Move on to the current version of Angular or a new framework.
I think I have seen this post REALLY recently
It's what we have already and it still fulfills our needs. 
Flutter for web is not electron/flutter for desktop. How to trust Google if once a month there is something new like angular/polymer/gwt/native/kotlin/flutter and then their "electron". 
&gt; The disadvantage of all three is that they’re all non native Apps built on Electron. It’s great because of the cross platform part of it, but I have a personal preference for native apps when free to pick. VSCode is built on electron so don't let your personal bias get in the way of your own dream. Use electron as a springboard to quickly get out the MVP so you don't fail hard spending 10x the time building a native app.
Usually something better. Flutter being the best. I do not know what you are talking about with flutter for wev is not electron. Of course not. That is what Flutter is.
It's been modified since then
Aahh. That's good to hear. 
It wouldn’t for a specific user. But what if you need to reference multiple users? What about if you had an array of user IDs which needed to change? 
You wouldn't use a const for an array.
I said I'm waiting for flutter desktop version and you replied there is flutter for web. I don't need flutter for web, there are tons of other frameworks already working. Is already iOS version fixed? Does it run smoothly? Also do you maybe know or have any resources about implementing on top of flutter my own widgets? I mean if I wouldn't want to use matrrial/iOS theme. 
Excuse me, I was talking to a friend about something else and got mixed up with this thread. Here's a better example. Say you have a game with three difficulties. Say something like enemy hit points gets multiplied by 0.75 for easy, by 1 for medium, and by 1.5 for hard. This multiplier never changes once it has been assigned. Therefore, you'd want to declare it with a `const`. Why would you use `let` if you never need or want to change it?
There is already desktop. You do not make sense? https://github.com/google/flutter-desktop-embedding GitHub - google/flutter-desktop-embedding: Desktop ... 
update babel using npm 
Read the caveats...
already did. thats why im confused [package.json](https://github.com/alkapwn3d/react-resume/blob/master/package.json)
It is early days. Caveats will go away.
Activate - Activism App: https://jddelia.github.io/activate/
I dislike prettier with a passion. It's creator's opinions on good-looking code are asinine as Crockford's.
Lol...
If you really need those milliseconds, forEach is not your only problem. Performance isn't everything.
How so? I would only use this for initialization, for example, loading all modules within a specific folder so I don’t have to keep an index
Sorry, I understand that they need to be processed differently. I mean more that there's no reason to try to infer the module type from the file name or contents if you can determine it via the import mechanism. For the initial file, it seems pretty easy to have a single special case where the type is determined by parsing (the case against parting send only to apply to files being imported by other files, not the initial file) or a command line flag.
You can just include the code from the file somewhere early in your code. Or you could rewrite it to not screw with the `Function` object, ie turn it into a function like `extends(child, parent){ ... }` which really would just entail changing `this` to `child`. If you don't understand what it's doing I suggest reading up a bit on javascript's prototypal inheritance, it's pretty core javascript concept. 
If your tooling can't figure out in compile time what files are used, then you won't be able to run bundlers, code analysis, get intellisense etc. I understand your point, but what I mean is I thought the devs of the module system has decided that static analysis capabilities were important enough that they would do away with dynamic loading
Lol lol
You can hijack the internals but it’s silly because the diffs will go crazy. 
You could use https://github.com/okonet/lint-staged to only apply Prettier to changed files on all your normal commits, thus incrementally formatting your codebase without having a dedicated, giant formatting commit.
Not just a native app, but 2/3 depending on support goals. 
try deleting node_modules and re-installing. Sometimes I have this issue and that solves it. 
I use tools in 
why not just use an empty object in the place of null though?
You know, I don’t know. I feel like I had a reason at some point, but I can’t think of it now. Good suggestion. 
Lol the screenshot says assing.
Who cares
I too hate Prettier's choices and wouldn't have considered it in the past, but since working on a project where it was used I will always use it. It completely frees your mind from thinking about formatting at all and allows you to focus on what the code actually does.
It can also be used for react props, so you don’t have to pass a value, so you don’t have to use a ternary. 
Seems interesting but your website needs some editing and and grammar clean up if you want your value proposition to be clear. If English is not your native language, I'm happy to help edit.
The Eve link is also broken under the Chris Granger discussion.
Yes, you can, but only if you're okay with creating a new Git history chain. This works best if you create a new repo, rewrite its history, archive the old repo, and have everyone clone and work from the new one. I recently wrote a blog post about how to do this: [Rewriting Your Git History and JS Source for Fun and Profit](https://blog.isquaredsoftware.com/2018/11/git-js-history-rewriting/) If you've got any questions about how I did this, ask away!
Can confirm this is a good way to go. I have multiple projects that I introduced prettier to, some all at once and some incremental. lint-staged was added to all of them, but some of them I hit with prettier in its entirety since they were relatively new and small. Adopting a formatter has been a great experience. Though now I have to keep explaining to engineers originally from other teams why it is useful and they keep pushing back...
Thank you. 
Welcome
I use it too. But only until I finish my version of prettier.
Title is misleading.... More like "Thoughts about a prospective functional IDE for React". Clickbait, and the mockup is just like a quick mashup of VS Code and and Light Table.
First thing: with an iframe Second thing: no without access to their actual implementation or their API which will just make it impossible on a square space site 
Put it on your resume.
&gt;You know, I don’t know. I feel like I had a reason at some point, but I can’t think of it now. Pretty much how I feel about and explain my code right there. 
“JavaScript doesn’t have Classes, Even though it is Object Oriented Language.” I mean it does tho
It’s part of prettier’s official documentation. It even works on partially staged files. https://prettier.io/docs/en/precommit.html
https://prettier.io/docs/en/precommit.html
I mean even that’s iffy. It’s really a prototypical language, and it’s class syntax is just a fancy way to create an object. 
Everything in Java extends Object, so are Java classes just a fancy way to create an object? JavaScript classes in es6 are classes I don’t see any ambiguity 
Correct. The problem I was having is using an arrow function and miss understand how "this" works inside an arrow function. One day I'll get on top of "this"
Correct. The problem I was having is using an arrow function and miss understand how "this" works inside an arrow function. One day I'll get on top of "this"
The prototypes and prototypal inheritance that we associate with JavaScript isn't as uncommon as we think. In both Python and Ruby, for example, classes are themselves objects, and inheritance is done by delegation. Here's [JavaScript and Python classes side-by-side](https://i.imgur.com/p9Kw815.png), demonstrating classes as objects and inheritance as delegation. And in fact, since Python's classes are themselves objects, you can even create objects ex-nilo. Here's [JavaScript and Python ex-nilo object creation side-by-side](https://i.imgur.com/o726cHj.png)
Heh, fair point.
QQ more noob
This whole post is pretty vague and only explains one of the bullets it touches on. The rest is left unexplained- is this made to make a “beginner” feel lost? Because that’s what it does.
In single post, it was not possible to explain everything. BTW, the purpose of the post was to let the developer keys fundamentals of javascript. They should know these key concepts.
Then you blog has a bad title. It seems to almost discourage beginners because of how much there is to learn and how little you make it digestible. 
Yeah it’s paramount that a single file doesn’t take up the entire editor window. That, or you put many things in one file a la Vue. So the former we must go 
The post doesn't contain any fundamental information. It contains a vocabulary list of fundamental concepts.
&gt; JavaScript is an interpreted language. You seem to throw this in as a forethought without explaining what it means. Who exactly is your audience? Because I’d bet JavaScript beginners won’t understand this. 
I wonder why it's 'mjs'? If it was JavaScript Module, shouldn't it be 'jsm'? Or even 'esm', since technocally it's an ECMAScript Module.
I will try to cover all points in upcomig posts. Thanks
Just at least have some note at the top that these are more advanced than “beginner” topics. Beginner topics are more like declaring a function and var vs. let vs. const. You dive right into fairly advanced topics (while interestingly skipping over IIFE, event management and the execution queue)
Thanks you realized me this thing. I will update the post soon.
Love this evidence based stuff 👏
Care to explain why? 
Glad to read that- we should all be trying to help each other get better at JavaScript!
If it's always the same value, it's a constant. If it's a variable value, it's a variable. Const is not meant for variables.
Stop using the abusing language in my blog comments. I dont know who you are and when u start programming, m not interested to know about u. 
Just rip off the bandaid and then make people use prettier-on-save from here on out.
We did this and had some issues, I forget the exact reason but it had to do with this issue [https://github.com/okonet/lint-staged/issues/366](https://github.com/okonet/lint-staged/issues/366)
The masterpiece of 1Kness: [https://js1k.com/2010-xmas/demo/856](https://js1k.com/2010-xmas/demo/856) &amp;#x200B; He wrote how he designed it here: [http://www.romancortes.com/blog/how-i-did-the-1kb-christmas-tree/](http://www.romancortes.com/blog/how-i-did-the-1kb-christmas-tree/) &amp;#x200B; And helpfully posted to Reddit 8 years ago a "de-crunched" version with code comments: [https://www.reddit.com/r/programming/comments/eovse/a\_christmas\_tree\_in\_1k\_of\_javascript/c19tuqn](https://www.reddit.com/r/programming/comments/eovse/a_christmas_tree_in_1k_of_javascript/c19tuqn) &amp;#x200B; I've simply modernised it a bit (requestAnimationFrame Vs setTimeout, etc...), and put it on CodePen to run directly: [https://codepen.io/SarahC/pen/ZVKQXb?editors=0010](https://codepen.io/SarahC/pen/ZVKQXb?editors=0010) &amp;#x200B; &amp;#x200B;
Right... which is why there’s nothing wrong with assigning to a const with a ternary... the initial assigning of the value of the const has nothing to do with if it will change later.
This is one of those comments that is probably only being upvoted because people share your opinion. This actually contributes nothing to the conversation - I would love to hear your thoughts on which decisions prettier made that you think are bad.
Hey ClassyCamel, I have ur IP address http://c-71-233-207-57.hsd1.ma.comcast.net/ and the comments. Don’t dare to abuse anybody otherwise I will complaint against you.
Am I really the only programmer who’d rather let everyone write code how they like? The straw man in the article who doesn’t indent code at all does not exist, or at least, the linter isn’t the best way to help them. The way I format my code helps me think about my code. Not everyone is going to think the same way. I spend as much time looking at code from other organizations every day as from mine so linter rules help me very little. We might all do better if we allow the notation to vary some when it helps us think more clearly, which I find is often.
They still want to be able to `import` CJS and use `.js` for modules so they're keeping their options open on how to handle it.
Why not upvote for modernizing?
I think a big part of using prettier and linters in a group is so the code doesn't keep flip flopping around each time someone else edits it. It also gives a more uniform style throughout a project. Working with 5 other people on the same project is hard enough with similar styling, can't imagine if each person was formatting different files 
I asked myself the same question when I stumbled across this a few months ago. I used it to conditionally insert an array item based on incoming values which could have been null or a user set value. Clearly I don't want null appearing inside the array so it became [ value1, value2, ... someCondition ? [ value3 ] : [], value4, ]
A ternary is used for a variable. The value is not always the same. Consts are not meant to be used conditionally
Is this user even a thing?
In my past experience where everyone writes how they like, they also don’t change the formatting of code unless they’re changing the code a lot.
3 month bootcamp is not an experience...
I felt the same way when I started using it. And I'm a guy who has used tabs for nearly 30 years and refuses to convert to space-based indentation, so I'm fairly opinionated about code style. But with a few tweaks to my config (below), I'm happy enough with the results that having automatic consistency is more important to me than any quibble I have with the author's militant opinions that I can't override. `"prettier": {"useTabs": true,"semi": false,"singleQuote": false,"bracketSpacing": true,"trailingComma": "es5","printWidth": 160},`
Why would I want all single quotes exchanged for double quotes? 
That's possible. I was just giving my personal experience with it. I found it on par, for the task I was doing. 
“Just” is usually a trap
You sound like you never worked in a team. Believe me, that guy who doesn't format anything exists everywhere and haunts my dreams at night. When we didn't have Prettier and ESLint the code looked like garbage. Consistent and clean code is no doubt a good thing. But yeah, some people are 100% fine with the code that looks like an exploded Word document from '97.
I told you, this shits fucking moronic
There are many developers who hate Prettier because they love 300-characters-long lines and messed up indentation. It's not a joke, though - they really do for some reason. But if you work in a team, such things as Prettier are necessity.
The easiest way is to use a routing plugin such as [this one](https://github.com/Turistforeningen/leaflet-routing)
i have little to no experience of using plugins, can i knw what to take care of, because i used some plugins in my map but i dont exactly know how they works, some plugins requires me to download file, some just linking in head section
To be fair though they are right, maybe they didn't go about saying it properly. The repo is specifically is about adding a standard lib to JS and how it would get consumed and loaded (with versioning) rather than the actual contents. Once they've got that down then they can go about what to add to it in separate proposals.
Okay again. Consts are only ASSIGNED once. You can assign any value you want to them just like with a let or a var. You can’t REassign them once they have a value. You can use a ternary to DECIDE which value to assign to the const when it’s declared. It then never changes after that point. Are you honestly suggesting that you should only use a const if you literally hard code the value you assign to it?
Regardless of semantics, I'm trying to build upon what I learned. But thanks for the help
Why are you trying to use a canvas polyfill module that needs Cairo, when you have the standard browser based implementation already provided by Electron? As for examples... You don't really need to do anything different in Electron. You use canvas in exactly the same manner you would use it in a browser. If you need any examples, just search for examples of using canvas in a browser.
The newest babel comes under the '@babel' package, not just 'babel'. You would need to change most (if not all) babel packages that way. Got the same issue a month ago, this worked for me.
regex
You can’t do it on wix. You need to make a real web app. Go to the WU front page, scroll to the bottom, and click on API. You have to pay them for their data. And you have to make a map app that pulls in data from the different sources and displays it as you wish. 
[removed]
Do you have anything on github? And if you don’t mind can I take a look at it? Ty
Well, when you put it \*that\* way, I'm not so sure. I'm liking "A Tutorial..." so far. So if I wrap my neurons around that, that will give me secret decoder glasses that allow me to see through the OP article?
It's not a matter of milliseconds it's that it's an entire magnitude slower. Sure if you're just doing a single foreach loop then it is what it is. But if you're doing a "common pattern" of filter -&gt; map I've seen all over code bases. And then you do that in 10 different places on a front-end application, all at page load time. All of a sudden you've added an entire second to time-to-interactive. I get the whole maintainability thing. And there are plenty of places that it ends up being much cleaner and easier to maintain using map/filter/reduce/foreach. And in some places you can add functionality with callback chains or async-await. But it's something to be aware of that I've seen many more developers just use Array functions as the "default" without thinking.
Not OP, but I'll add my thoughts. The method that prettier uses to enforce consistent code styling (line length) seems quite archaic. Examples: const x = { appleTree: 1, lemonSqueezer: 2, bigHouseOnAHill: 3, transAtlanticFlight: 4, } const y = { apple: 1, brackish: 2, cat: 3, dog: 4 } const y2 = { apple: 1, brackish: 2, cat: 3, dog: 4, elephant: 5, } `y2` is the same as `y` except `y2` now has elephant. That change mutates the whole display.. In addition `x` and `y2` are significantly easier to read than `y`. I'd much prefer a consistent format based on rules, not line length. ESLint provides options that allow you to enforce that each object property, array item, html property, etc should be on its own line. That seems far more consistent than line length.
Machine learning. 
My bad I already wasted much time. Finally I implemented it using plain JavaScript objects 
What you want is all quotes to be consistent - double quotes is just the one they picked. Probably because it’s a bit more visually clear since it’s larger.
this right there kills that approach for me. ESLint is amazing and we use that with our own config that we all agreed on. But Prettier, while awesome in concept, is way too opinionated to be useful.
But when you have some html in your javascript code than you might need to use quotes inside of quotes - meaning your outer quotes need to be single. That's why if you're trying to be consistent, it makes more sense to use single quotes.
Or the inner quotes need to be single and the outer double, it (usually) doesn’t matter much. Never had a problem caused by prettier changing quotes around in the years we’ve been using it.
When I was deciding whether I'll use single or double quotes, I did quite a bit of reasearch on the topic and found out that when nesting quotes, the inner ones should be double, that way it's more grammatically correct.
The efficient way to do this is to use https://en.m.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm.
Why wouldn’t “first name i” return “first name” and “first name is”?
'Boring'? You mean 'bored', right?
For an in depth understanding of JS I would suggest you read You Don't Know JS. It's a book series. You can find it on GitHub. 
Regex!!!
If you add a single line break to an object, after the first ‘{‘ but before the first item, prettier will wrap the object and leave it that way. Similarly, if you want to unwrap one that will fit in a line, you can just delete that 1 ‘\n’ and it will try to put it back on one line (assuming it fits). Also, if you’re using both prettier and eslint, you can have eslint do some work on the code after prettier to make it the way you want. So if you wanted every single object to always be multi-line, you can just configure eslint to do that work.
&gt; If you add a single line break to an object, after the first ‘{‘ but before the first item, prettier will wrap the object and leave it that way. I've never seen prettier behave like this. Is this specified somewhere? If so, it can't be applied as a company wide system like ESLint can. &gt; Also, if you’re using both prettier and eslint, you can have eslint do some work on the code after prettier to make it the way you want. I've always tried `prettier-eslint`, but prettier seems to win.. hmmm perhaps I should try the combo again.
It's Netsuite, I don't have any control of their ecosystem.. I'm told they are moving to GraalVM but on their own painfully slow timeline
TS throws lots of nice sane errors. I've never been ok with the JS approach of "let's just try and make this code work anyway even though clearly the dev screwed up". #soapbox
https://prettier.io/docs/en/rationale.html#multi-line-objects. It’s in the first paragraph.
Oh nice. At first I thought it just looked like lodash.get, but then I see the glob feature. That makes it pretty powerful.
I recommend you to read eloquent javascript 
And it looks like with ESLint you can even force it to break the objects if there are a minimum number of keys. So single entry objects would always be on one line, and anything greater than 1 could always be broken. https://eslint.org/docs/rules/object-curly-newline (I think eslint can only “win” over prettier if it can be applied with the —fix option)
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
If you don't care about capitalization, you could use Array.indexOf. Or you can set everything in lowercase in your array, and then set your input to lowercase, and then use Array.indexOf then. It's faster than RegExp for something like this.
Fast alternative to jsonpath?
No this is Bubbles... https://www.reddit.com/r/dogpictures/comments/a3td3d/bubbles_our_new_addition_sadly_37kg_but_neglected/?utm_source=reddit-android
Is it possible with js?
I will try, thank you.
Yeah, my team prefers to only use %3 of their 32 inch monitors, so we limit the line length to 8 characters. Now we can’t tell who wrote what code, which is great, because we can use a more advanced set of tooling (GIT) to blame the line and figure out who did. Plus having every 8 characters break to their own line improved readability. I can be 100% certain the variable I declared is being assigned at least 3 lines after where I declared it. This all proves how stylistic rules are the most fundamental principles of CS. Throwing errors in a console that prevent transcompiling really one of Eich’s main design philosophies we are finally getting right. As he always said: “I prefer hunting down errors by file name and line number in a different window over productivity, so long as I can write code on my 8x1 character lcd“. 
Yes buddy
Yes I will, thanks
I just tried `prettier-eslint` (which runs prettier and then eslint) and it's very slow. ~60s to format 115 files and not touch 468 files. :(
 You should only have to do that once. The rest of the changes should be hooked into a pre-commit hook that only runs on the changed files. https://prettier.io/docs/en/precommit.html Give that a whirl.
An idea... Right now, you have that, with a data such as the one in the example but adding a property `"nom"` to each item, with values say `"chicken"`, `"pizza"` and `"fruit"`, for John, Joe and Jane, respectively, if you query `users[].n*` you get: [ "John", "chicken", "Joe", "pizza", "Jane", "fruit" ] This seems not entirely useful and somewhat confusing. So I was wondering if it might be not a bad idea to instead try to have wildcard queries produce something like: { "name": [ "John", "Joe", "Jane" ], "nom": [ "chicken", "pizza", "fruit" ] } Or maybe some other similar structure (I know that i breaks the idea of always getting an array back). The thing is I'm not sure what the intention of the glob expressions is, but as it is right now, the above result feels fairly useless. I _could_ maybe imagine wanting a wildcard to get a number of properties values, but I really can't imagine a situation where it would be useful to have all the values thrown together with no way to distinguish which property they come from. ---- On a different note... All queries return back an array, _except if the last level array is indexed to one specific element_. That is... In the example in the playground... users[1].name // --&gt; "Joe" users[1].friends[].name // --&gt; [ "F2" ] This feels weird on the account of the thing I already mentioned: Why make this a special case where it doesn't return an array? IMHO this feels inconsistent. --- Finally, it seems like there's some additional confusion or, at least, unexpected behaviour, with indexed queries. Consider this query: users[].friends[1].name // --&gt; "F2" This actually looks like a bug, because to me, that query is saying: "For all users, get me the name of their second friend", so it should return nothing.
Set your `div`s and other elements to `style="display:none"`, then in your JS logic, show and hide them by referencing them and changing their style. `document.getElementById("login").style.display = "block"`
Necessity? Nope. I’ve worked on repos so large we had to clear out history in BitBucket so it did not get put into read only mode, without ever “needing” a process to homogenize line length. 
Exactly 
Build a portfolio. It can be assingnments you completed, personal projects, etc. Being able to see the work you produce speaks volumes more than a resume or pedigree.
Found the guy who likes single lines of code 3000 characters long. 
Secret decoder glass? Probably not. But you'll be able to write over-formalized descriptions of production technologies yourself! And if you then proceed to Turing machines and Church-Turing conjecture, you'll gain the magic power of converging every programming argument into a P=?NP debate.
I do? I didn’t know I wanted all my quotes to be consistent! Thanks! 
Recently web applications moved from ASP/JSP/BSP to client side rendering why go back again 🤦‍♂️
Right, I think lodash.get is very limited, it can't get all items in array you have to specify the index only
Nah, nice try though. I actually use ESLint and Prettier in my new projects and enforce line lengths to be 180 or under. My point is saying enforcing stylistic rules in not a NECESSITY. My point was he was exaggerating, like you are now, which doesn’t help frame a constructive conversation. 
jsonpath's syntax is based on XPath (XML), which is not intuitive imo. when dealing with json, I think it would be better if we can specify path the same way we do when we write code in js. (e.g. why we need "$." for every query etc). Just my opinion. 
Don’t bother. 
Great tip. Thank you. 
yeah the idea atm is to theme VS Code and add the functional part to it
agree on this, my idea atm is to theme VS Code and add the functional part to it as a plugin &amp;#x200B;
cleaning up now as we speak
Auth0 provide hosted pages so just use them?
Wow. That is basically all the JS technologies in one stack. Bravo.
The Eve website doesn't have TLS, fixed now with an http link
Wow, thank you very much for your feedback :) On the 1st note. Your idea is very valid. I can understand that it's not very useful when we don't know where the values come from. But on the other hand I just want to return the result as is, without adding the keys or something to the result. It's very difficult design choice imo. If we add the key to the result the consecutive query will be very difficult to handle. e.g. ``` 'users[].n*' { "nom": ["a", "b", "c"] } ``` If we want to go deeper, this will be a little bit difficult to handle ``` 'users[].n*[0]' // since we return { "nom": [...] }, this will be a bit tricky now. ``` On the 2nd one. For this one. When specifying single index (no slice). It behaves like actual js. ``` users[0].name // return single value "John" etc ``` When using `slice` or all array (or glob) it always return array of items. ``` users[].name // is similar to `users.map(u =&gt; u.name)` which returns ["a", ....] ```
Love it!
We went with a teeaked ruleset that Airbnb put out. I’m pretty sure it would format all 3 like x and y. I dig it as a linter
Because you can cache the rendered site on the server and dramatically reduce first paint times. 
This is technically the correct answer - you asked for "vanilla javascript" - but direct manipulation of style properties via js is considered an antipattern. A more conventional way would be to use css for the styling rules and js to manipulate a class. &amp;#x200B; HTML: `&lt;div class= "my-element hidden" /&gt;Content that starts out invisible&lt;/div&gt;` CSS: `.my-element {` `display: block; // technically optional on a div, but to make the example clear.` `}` `.hidden {` `display: none; // i override the first rule because i am applied afterward.` `}` JS: `function myFunction() {` `var elem = document.getElementsByClassName("my-element")[0];` `elem.classList.remove("hidden");` `}`
Contact small shops that service sectors, like car dealership websites and the like. Many small companies are still on phone but slowly transitioning to other backends/libs. You can usually get an entry level position with little experience, but the pay is abysmal, good experience though.
What do you mean "do that once"? A pre-commit will run on every commit which means my commits would need to lint for ~60s every time.. That's not an option.
I'm not super familiar with creating chrome extensions. Do they allow for css?
The main idea behind JS frameworks is to make things like state mapping easier to achieve. React (as well as Vue/Angular, etc) make you write declarative instead of imperative code. So instead of constantly having to worry about how to hide or show different elements in your HTML you can simply write conditionals that get evaluated everytime new actions occur, making the entire UI update process automatic.
What do you mean by "tweaked ruleset that Airbnb put out"? Meaning you've extended airbnb and tweaked it, or you've extended something else? If you have more details about your set up I'd be curious.
Well, implementing ML is, using the TensorFlow.js API. 
The pre-commit hook will only run against the changes files. Husky and lint-staged are set up to provide a list of files. So instead of trying to scan your files for what to do, it should get a list of 5 changed files and only run against those. 
You can use something like OSRM to generate the routes based on the lon/lat -&gt; choose the geojson format and display that or extract the overview as a lon/lat array and display it as a polyLine
I use Prettier and ESLint in everything. ESLint prevents stupid mistakes. As for Prettier, some people on my team don't like the formatting, but they can format the code to look however they like locally. Prettier is run as a precommit hook so I never have to look at formatting changes when reviewing pull requests. I don't love all of Prettier's style choices but I don't have to scrutinize stupid formatting changes so it's a win for me.
Sure, but then Jenkins will run them all. Increasing build times by 1 minute is not something I'd choose to do.
Airbnb has an eslint config, but I've never seen an airbnb prettier config before.
I’ll have to look but we took Airbnb’s rules and made a couple of changes for our needs
Why would Jenkins be running prettier as part of the build? 
I hate Prettier with a burning passion. It's inconsistent with its formatting and it royally fucks up any and all string concatenation it gets its hands on. If it'd just format everything the same way every time and stop splitting strings I'd be okay with it. Until then, I'll just use ESLint or something else that actually maintains consistency.
&gt; This all proves how stylistic rules are the most fundamental principles of CS. Very nice of you to show that you completely misunderstand everything there is about this subject. This is not about "CS", but about team productivity. 
It would run eslint to ensure it wasn't bypassed. Though you're right then Jenkins would just use eslint and skip the prettier bit.
Airbnb doesn't use prettier. See https://github.com/airbnb/javascript/issues/1548 I agree with Jordan with his points #1 and #3
Right, because if you ran prettier, and it was different, then what? Also, if it’s ignoring ~400 files and running on ~100, you probably need to tighten up your glob... Can you paste what you ran that too 60 seconds?
&gt; Also, if it’s ignoring ~400 files and running on ~100, you probably need to tighten up your glob... It searched all the files, but only formatted some. My package.json file: `"lint:js": "prettier-eslint \"./**/*.js\"",` Standard setup with parser: 'babel-eslint', extends: ['airbnb'], plugins: ['react', 'jsx-a11y'], ____________ But either way, I shouldn't expect my formatter and linter to take 60s. Even if I can work around it with having it only lint recent changes.
SEO, no initial wait for rendering a large application (which react apps usually are)
From what I've read so far, I'm loving JS design patterns. It's available online too. 
I think when you use the word team, it has connotations of the interchangeability of its members, and I don’t think that’s best. I’ve worked with someone who didn’t indent their code. I told them to indent it so as to convey the structure as they saw it. They did it. It was fine.
I could see how you feel that was about what I said, but it’s satire. Satire that also explores taking the 80 line rule, and making it more strict, bringing it to 8, which makes the flaws of this blanket styling rules more obvious. Productivity is not failing builds, transcompiles, code used to debug so everything looks like the same. A computer is supposed to help people not tell them what line in a file is “wrong” because it’s “too long”. Those kind of things ruin productivity. I think people often forget we are servants, of the company, board, stakeholders, stockholders, and users. If a dev spends 5 minutes a day fixing these non-bugs, and there are 50 engineers, that’s 150 minutes a day spent doing nothing. That’s almost 650 HOURS a year spent doing nothing. How would a stockholder or customer react to that if it was presented that way? Probably not well. “Well we could have fixed that bug, but we spent 650 hours this year fighting our tooling”. “That new feature that would have doubled our revenue will have to wait until next year, because we spent 650 hours fixing white space” I understand to a large degree these “problems” have automated fixes, but they don’t always. And the feedback you get is often in a git hook, which makes you scramble to find and “fix” them somewhere not in your console. It’s a waste of time. You lose expressiveness and readability. If someone is really making functions that are 3,000 characters wide and won’t stop... maybe you need new engineers, but to punish everyone, DECREASE productivity, and readability is the definition of waste. 
God jul til dig også
Tack 
I'm in total agreement with your post, though most of us will probably have learned this in the use of PHP. They probably choose the double quotes since JS provides excellent interaction with DOMElements and this will hopefully make you think twice before using `.innerHTML`
they didn't say until after they closed all my work, then went in public and asked other people for the same thing, then closed where i said "i already gave you this stuff" as disruptive
You may struggle with this description because virtually every course ever demonstrates by building a list app
This is for an internal tool, so 100% of the users will be on ie8. I know it's godawful, but I don't have any say in the matter! Thanks for the tip though, will give that a go! 
...constant cannot change through re-assignment ...constant cannot be re-declared Try using let instead 
Constants cannot be modified
Also there is no way to stop or break a forEach() loop other than by throwing an exception. If you need such behavior, the forEach() method is the wrong tool.
I yes, it was a stupid mistake\^\^. However, even with a let or var instead, the function doesn't work. 
Thanks for pointing that out :)! However, even with a let or var instead, the function doesn't work.
I will admit that I've never used the `prettier-eslint` single package tool, however I can provide you with some stats from my repo. sorahn@shyguy:~/s/work.repo (integ|✓) ➤ find src -iname "*.js" | wc -l 862 sorahn@shyguy:~/s/work.repo (integ|✓) ➤ time npx prettier --write src/**/*.js ...snip... 11.07 real 13.13 user 2.16 sys sorahn@shyguy:~/s/work.repo (integ|+66) 66 out of 862 files changed in 11 seconds. And that's with the full sweep, not even the pared down list that would run with the pre-commit hook. And eslint. sorahn@shyguy:~/s/work.repo (integ|+66) ➤ time npx eslint --fix src ...snip... 14.94 real 17.74 user 0.72 sys sorahn@shyguy:~/s/work.repo (integ|+66) Nothing should be taking 60 seconds.
Jamming a stick up your but is the new cool, get with it, or you will be kicked out of the Hip Kid Club.
Thanks I will try.
I quit my last job because we didn’t use any tools like eslint or prettier. With a team of about 15, mostly contract workers, the codebase became a huge mess. I tried introducing these tools, but it was “too much overhead” and “not a customer facing” issue. The bigger problem to me was that it signaled that the engineering manager (and team, to some extent), did not care about developer experience and app maintainability. It got old going through 1000 line backbone files and seeing inconsistent indentation and code structure. It felt like most of the company did not care about the quality of their work. Tools like this help you write better code for the next developer- which really who you are writing code for, unless you plan to maintain it forever. I left after three months and explicitly asked during all my following interviews how they enforce code quality, which led to some great discussions and I think also helped me stand out. 
Very nice article! I didn't realize you could set per language for prettier on save!
Thank you! This is what I was looking for. I guess I was just so used to maintaining the state my self that I never realized how react abstracts that for us. 
I understand but in the intro video he explains why lists and gave an example of virtually all the apps. Thanks
Might be a silly question but are you sure you’re passing in an array when you call the function?
What is " peopleInLine " that you are passing as a parameter defined as ? object? what is this objects structure? &amp;#x200B;
Your function makes no sense. forEach does not return anything, so returning yes or no within it is useless. You’re not even using the yes or no elsewhere in the function so it has no purpose as currently written. Check out https://javascript30.com/ then https://www.freecodecamp.org/ Trying to learn programming without structure is doing it in hard mode.
const can't be reassigned. You're also not returning anything from tickets. &amp;#x200B; I'm not understanding your question either. &amp;#x200B; Is tickets suppose to return Yes or No once, or for each person in the line?
Not a fan of prettier. Too nazi about it's rules with no configuration. I don't particularly find their default rules to be great out of the box, either (how is eliminating blank lines and smashing logical blocks of code up against each other making it more readable OR prettier? It's not). The maintainers, despite me seeing dozens of issues on Github contesting this, basically tell everyone to eff off. So, they have no intention of making a useful tool. They want to enforce their opinions. I'll watch Fox News if that's what I want.
peopleInLine is a random name given to the function argument. It will alway receive an array, with values of 25, 50 or 100. I'm reffering to this kata: [https://www.codewars.com/kata/555615a77ebc7c2c8a0000b8/train/javascript](https://www.codewars.com/kata/555615a77ebc7c2c8a0000b8/train/javascript)
Use prettier and stop thinking about formatting
Oh I see the confusion. What I meant came from my experience with other libraries. Vue for example did not need the build tools just to use Vue. Yes if you're shipping a well tested product , you need one. But just to get your hands dirty with it, a CDN call would suffice, over which you just write your code. With react however, the entire app needs to be built out from scratch to support it.
Yes, I'm actually reffering to this kata: [https://www.codewars.com/kata/555615a77ebc7c2c8a0000b8/train/javascript](https://www.codewars.com/kata/555615a77ebc7c2c8a0000b8/train/javascript) I should have specified it earlier, all my apologies.
X.ForEach() takes an array, my guess is that you are trying to pass it a simple value, say 20 or 55, meaning either 20 or 55 people waiting in line? If that is the case then change the forEach() loop to a simple For loop. E.g.: for(let x = 0; x &lt; peopleWaitingInLine; x++){ // do your if statements here and return “YES” or “NO” if he can provide change } Merry Christmas! 
[Guess I'll not read the article then.](https://i.imgur.com/QnQpjD4.png) Seriously wtf is wrong with Mediums UX. I get it they need money but that's not the way to get my money.
I'm actually referring to this kata: [https://www.codewars.com/kata/555615a77ebc7c2c8a0000b8/train/javascript](https://www.codewars.com/kata/555615a77ebc7c2c8a0000b8/train/javascript) I should have specified it earlier, all my apologies. &amp;#x200B; function tickets() is supposed to return Yes or NO depending on the ability of the salesman to give change to his client. 
Ah yes, I'll check it out. 
You can use React from CDN too with jsx. Just don't forget to add: `&lt;script src="https://unpkg.com/babel-standalone@6/babel.min.js"&gt;&lt;/script&gt;`
Oh wow how did I miss this. Thanks!
Thanks for your help, however the numbers 25, 50 or 100 are referring to the cash each person in the line has. So assuming the cashier has 0$ to start, the result should look like: &amp;#x200B; tickets(\[25, 25, 50\]) // =&gt; YES tickets(\[25, 100\]) // =&gt; NO. The cashier will not have enough money to give change to 100 dollars.
Thanks! Yes I was looking for something like this
Thanks! Yes I was looking for something like this
In your second if statement where you have (cash-people &gt; 0), try and rethink that because if someone walks up with 100 and the salesman has 75 the loop will throw a “no” but he would be able to give them change, he would just be back to no money.
Hi /u/jfet97, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Hi /u/MonsieurLeland, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/blu3hammer, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Unnecessary parens add confusion so this code does not communicate well to me. The examples creating block scope with extra curly braces are much worse in my mind-- functions are already scoped so what's going on there? Creating a new block scope so we don't have to write JavaScript in the idiomatic way that works for the rest of the world because one author sometimes gets confused about Python? This is designed so the author's teammates will ask about this weird syntax and the author will have a window of opportunity to explain that she/he ALSO knows Python. Where does it end? This creates new things to worry about for no obvious benefit. Should I introduce things from my favorite programming languages? What about the French I studied in college? Or can we please just write JavaScript for people who know JavaScript? All of that is pointless because you should have a styleguide anyway.
Hi /u/platnum42, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Yeah I agree with you. The fact that react alone was this popular got me wondering if I'm missing something big here.
Hi /u/harpyh8r, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/javahmmm2, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
ok. The issue you're having is that forEach is not going to return you from tickets, You'd want to do something like this: function tickets(customersWallets){ let salesmansCash = 0; for (let customersCash of customersWallets) { // Random name for our animal if ((salesmansCash || 25) - customersCash &lt; 0) return "NO" salesmansCash += 25 } return "YES" } 
Alas, I'm really crap at maths... This mistake was so stupid and obvious. But thanks to you, I can now correct it with: else if (people === 50){ if(cash - people &gt; 24){ {cash += 25; return "YES"} else {return "NO"} } else if (people === 100){ if(cash - people &gt; 74){ {cash += 25; return "YES"} else {return "NO"} } 
What other code formatters are there besides prettier? For the sake of equal advertising to all good formatters
I've been using JS frameworks for a while, and to be fair there was nothing that stood to me as amazing in particular when I saw it as well. State binding already existed years ago in the form of viewmodels in meteor, or in data-binding in AngularJS. Components were also quite popular back in the AngularJS days in the form of "directives" as well. I enjoyed React's simplicity and "hands-off" approach to things, and I suppose that's why it grew to become more popular than other frameworks, but personally I prefer the more "opinionated" and abstracted nature of the Angular/Typescript ecosystem.
Okay, my styleguide calls for parentheses. :)
&gt; Use prettier and stop thinking about formatting
Is getString magic? Where does the string come from and why does performAction know? &amp;#x200B; I can't tell what the actual issue is here because best practice for function design would have it so that pulling a value out of thin air from inside the function is a no-no that, if dealt with, wouldn't require you to do anything fancy with your parens. Also, since you're referencing transformStrings from outside performAction, I'm wondering what the point of performAction is at all? Why not just put the transforming function in a variable and the regex as well? \`\`\` str.replace(regex, transform) \`\`\`
Bow to the Chinese government and stop thinking.
This is just example code! Insert your favorite algorithm using parentheses that would otherwise mix Python's and JavaScript's indentation style.
Actually, initial wait with server-side rendering was one of the reasons we went to client-side. It’s better if user waits for your application to finish while inside of your application, rather than he looks at blank window and wonders if it is going to load at all. SEO is a legit reason, though. We lightly prerender on server some of our pages that require SEO.
Pre-rendering your HTML on the server and then hydrating it on the client is hardly "going back" to the traditional way of building a web app. You still get all the benefits of your frontend being an SPA and/or being able to use a library like React to build it, you just _also_ get the benefits of SSR, like faster loading times, SEO, and your non-interactive content not requiring JavaScript just to display at all.
I have been a webdev for a long time, I totally get what you are saying, and so do a lot of others. You just won't find agreement here, on this subreddit, because it is almost all kids who think what they are told to.
All good my friend, just a refactor I would do to collapse those two else if statements is just say else if (cash-people &gt;= -25) { cash += 25; return “yes”} else {return “no”} Let me know if that doesn’t make sense!
JSCS? I’m not really aware of others. 
That's a weakness of the language, only half-ass implementing const. The proper way to use a const is to set it to a value that never changes. If it changes, it's called a variable value, and it is a misuse of const to assign it to that. Let is for variables. Const is for cosntants.
&gt; That's simply because const was not implemented correctly in the language TC39 was very intentional with the implementation. I can understand that you're dissatisified with it but there is precedence in other languages.
Merry Christmas to me. Was looking for this kinda thing last night. Thanks for sharing!
ESLint, kind of. It can do style linting, and many of the style rules have automatic fixing. I honestly don’t know of any formatters besides Prettier that aren’t just other general-purpose linters, and of those ESLint is the best. However, I personally think Prettier does a better job because it’s more strict and there’s less to configure. I’ve had a lot of success with the ESLint plugin for Prettier, which disables all ESLint style rules and leverages Prettier under the hood for style-related things. 
Don’t you think it’s better to spend time on how your code works instead of how it looks? Using an opinionated code formatter removes your opinions, which if you’re working solo, may not be as important, but when you have other collaborators it helps remove needless arguments about style. 
why not store the html as a string?
Well, yes, picked the wrong word for it, I guess. But a very important thing anyway.
Very intentional in doing it poorly. JavaScript by nature is a hacky, inconsistent language. It's no surprise to me that they'd fuck up const so much.
Gotta argue that greatest language ever statement. I love JavaScript, but every language has it's strengths and weaknesses. I view them as tools, each one great at some things and bad at others. But we probably won't agree on this, so best to you.
Maybe look how headless CMS do it (or just use one, if appropriate). Like Prismic.io or buttercms. They store that kind of data in json. I don't remember their exact way, but maybe it's sth like {type: 'h2', children: [{type: 'em', children: 'lorem'}, {type: 'span', children: 'ipsum'}]}
Definitely the way to go, though I would advocate using querySelectorAll("jquerylikeSelector") and using visibility: hidden so that it still takes up space when invisible (so layouts dont get messed up)
On a similar note, some IDE extensions will show line history of a file as well (e.g. I use VS Code with GitLens).
&gt; helps remove needless arguments about style. Some people in [this](https://old.reddit.com/r/javascript/comments/8as6ns/i_dont_like_prettier/) thread say, they could quite easily agree on ESLint rules.
Ah, I use TSLint. Was looking up Prettier cos I want to enforce one code style to stick to
In which format are you accepting the text? I'm guessing it’s not HTML, as you'd already have done what @leolandleo suggested. If it is, why would you want to take this approach? As for Markdown, again, it goes back to how the text is provided. That said, it is a very good choice for writing. :)
I've used eslint for formatting quite a bit 
But what you’re proposing is not in the default list of eslint rules so now you’ll need to write an eslint plugin to check for it?
You can totally use Prettier and TSLint together! Even if there isn’t a plugin for TSLint, you can run both tools individually. You’ll just want to disable anything style-related in TSLint. Alternatively, ESLint works for TypeScript too with an alternate parser. In my experience, you just need to disable a few rules that TypeScript will cover for you anyway. 
Freecodecamps is fantastic if you haven't already run through it
The entire point is removing bikeshedding about formatting. No one gets exactly what they want, but everyone gets to actually work on features and not formatting.
Is there a list of SIP specs you support?
Well, I'm at least glad that this was simply your opinion and not an aspect of the language I was unfamiliar with At any rate, agree to disagree. I think `let` and `const` in their current formats are wonderful additions to the language
I'd use markdown
Except no one in my organization even gets to pick what those things are. I don't need prettier making calls in my organization for me. And sacrificing a small amount of effort on formatting for having to learn how to intuitively read code the way THEY want us to is not worth the trade. They refuse to even add configurability for these features. Not because it can't be added. But because they think that's how it should be, period, no arguments or differing opinions allowed. I understand having staunch defaults. But removing all other ability makes the product unusable for a great many. I don't need prettier to save me the oh-so-enormous time sync of occasionally hitting the backspace key.
We stripped prettier from our project about a month ago. Sure, it was nice not having to worry about it. But it's a VERY mild convenience at the expense of TONS of ability to have team styling guidelines. It's a novice's tool.
The world is constantly evolving. I don't see anything bad in theoretical discussions that could have an effect on us at some point in the future.
Arguably, it’s not exactly highlighted in the React docs themselves — the tutorials don’t cover this route. However, it is in the docs: https://reactjs.org/docs/cdn-links.html
You could gzip+base64 encode it. Text compressed really well. However it won’t be easily readable.
How long does it take to learn JS through there?
That's much better. I wonder if there is something wrong with the `prettier-eslint` lib.
It's not opinion that JavaScript is hacky and inconsistent. It's the nature of the language. They only half-ass implement things because they need to support the shitty applications people build in JS. Let and const are better than var, but still not as good as they should be, but novice programmers who break the language to build their apps couldn't handle JavaScript being more like a real programming language. At least there's Typescript for the people who give a shit about proper code.
Please do enlighten us with your ways of solving this problem. If you have a component-based UI, I don't see how wanting to prerender it on the server is in any way absurd. Stop pretending you are so above the community and give something palpable rather than your childish whining.
Didn't think of that. Not sure what would be semantically better, that or using markdown
Will definitely try to go through. Thanks for sharing
Don’t worry about learning JS with Udemy. Free resources are extremely high quality. Do https://javascript30.com/ and https://www.freecodecamp.org/ in whatever order. I only use Udemy for specialized stack / tech, but keep in mind 99% of the courses on there are average to absolute shithouse. And never pay more than $15 USD for a Udemy course. They can always be bought on “sale” at any time of year.
Interesting. I'll try this. Thanks.
Thanks for sharing!
Javascript understanding the weird parts is a great course to really understand language, keep in mind that its only a theory so if you can afford I would recommend taking another course which includes some projects building as well but imo this particular class is must take for anyone who just starts learning Javascript. Here is a link - www.udemy.com/understand-javascript/
https://www.udemy.com/modern-javascript/ this course from andrew mead is so good. This one is also up to date with the new features of js too. Ive been through a lot of different books and courses for js and i think this one is the best.
The one I found is supposed to be pretty good since it has something like 150K enrollments. So you'd rate 'your' websites higher than Udemy?
That all depends on you really. Everyone learns at different speeds. Fcc is one of the most respected free online web development education tools on the internet tho. 
+1 for JS30. WesBos is a Rockstar in Javascript and teaching 
So the best way to learn JS would be to buy that course and then use fcc to properly learn how to code?
Thanks for the reply! Thought about that one too but I'm having a really hard time picking one since there's so many.
From my experience - Yes
If I had a team of experienced devs who agreed on a standard style guide (and a linter to enforce it, I'd agree. As someone with two dev teams that have a majority junior-mid level devs, it is worth it. My other use case is more personal: on my own projects I tend to have analysis paralysis and formatting is just one less thing of which to think. Frankly I am surprised that I am advocating it because I'm pretty sure if you go back in my comment history you can see I had different feelings about it before. Our teams turned it off for a bit but quickly pushed to turn it back on. 
Thanks for this!
I just glanced at the website and saw that there's like 300 hours of material on JS alone so that's why I asked.
pretty much how/why i'm making my site. make it in react and some things, server sends static pre rendered files, react loads on client side to make it go faster and other logic.
Additionally, subscribe to r/javascript if you haven't already. They post free courses, sometimes even from Udemy if you're determined to use them. I'm not as down on Udemy as the other poster here was, but for beginner stuff, there's so much quality and proven great free courses online to learning JS basics that it doesnt make sense to pay even a penny for it. 
Might actually stick with the free websites instead of the 12.99 euros course on Umedy then.
Okay thanks! As I just mentioned to another commenter it might actually be worth it then to just stick with the free courses. Yeah, I subsribed to r/javascript a long time ago but never really got on with it because I'm not that motivated to really start you know?
I would recommend doing both FCC and JS30 combined for you. FCC is great but can be a little dry and by the books. JS30 has you building cool projects from the word go. 
Brb - creating skynet
That might be the better bet indeed! Just need to learn JS for my education and want to have some kind of basic knowledge in it.
I can't remember on top of my head all RFCs I used , I can come back to you later with that. The deprecation of Nashorn is definitely a concern. There is two courses of action: 1) GraalVM takes of and becomes a viable replacement for Nashorn. In which case I will be more than happy to port the project. 2) Nashorn die without a viable substitute. In which case I will have no option but to re-write the project en Java. In any case, I think I have a least a year before I have to make a decision. &amp;#x200B;
Awesome! I'd love to try and build some sort of AI chatbot so this will be a great start. Thanks for the share!
This particular problem cannot be solved the same way "as of old". But I get what you and your parent are saying. Most sites now a days should probably never be rendered client side. You could still have a small client side react-app inside of your server rendered site. But there you go, it's the new black. 
I mean yes I agree that JS has issues but I wouldn't feel that this particular one is an issue. There's precedent in `final` specs in languages such as C++ and Java. Do you feel similarly that those are poorly-made languages? Additionally, Typescript doesn't change the implementation of `const` to fit what you're describing. It's still just a block-scoped read-only value. It's actually quite useful when used in that manner and I'd encourage you to rethink your stance here. I think the word `const` is misleading you here, if it was `readonly foo` I think you might have a better go of it.
Eslint can do a lot for you if you use a good config like airbnb or standard 
Great library! It seems very useful. I wish I will use this one day. Starred 🌟 on Github
Not a fan. Unnecessary block scope + not great readability. Why not just declare the function and return the reference? ...or use prettier?
Better for doing what? 
[StandardJS](https://standardjs.com) , Prettier, and autoformat &amp; autofix on save turned on in VSCode. Consistent styling and rules every time
And this is how Prettier gets enforced at work
for some reason none of the hosted pages I've used so far have worked. 
Hey! Anyone with experience can tell me the pros/cons vs using Tensorflow JS? I built an app using TFJS and like it, but would use this if the performance is better
If that’s all you think prettier does, there’s no discussion with you.
JS30 is great but I wouldn't recommend it for beginners. It is a nice collection of small apps and exercises to go through once you already have a basic grasp of JS and html/css and DOM manipulation.
That's not an answer.
I'm not arguing what prettier does. I'm saying the implementation is useless unless your coding standards exactly match what they want. 
[Or a styleguide and the occasional ESLint rule.](https://www.reddit.com/r/javascript/comments/8as6ns/i_dont_like_prettier/dx1e3ew/)
I really like Colt Steele's bootcamp: [https://www.udemy.com/the-web-developer-bootcamp/](https://www.udemy.com/the-web-developer-bootcamp/) It starts from zero and goes though html/css/javascript to get you building and deploying a full-stack app. Some of the material is a bit dated (as one example, Promises and async/await are not covered at all), but it provides a solid foundation in what it takes to build a full web app. You can do all this through FCC too, so you should definitely start there and see how you like it. I just like Colt's teaching style and I'm not crazy about the FCC coding environment. &amp;#x200B;
Why is it bad for a programming language to resemble another programming language?
There is nothing like prettier. I mean other formatter can do similar things, but the point of prettier is that (a) the defaults are very sensible (b) it has so few configurable options it _forces_ you to stop thinking about it. The big selling point is (b)
Utterly pointless.
Yes, because server-side React is _exactly_ the same as JSP soup 🤦‍♂️
*** Grump Old Dino Alert ***
&gt; why go back again It's explained quite clearly in the second paragraph of the article. Which shows that you haven't read it. Which shows you are just an opinionated so-and-so that shoots down ideas without trying to engage with them or understand them. &gt; Recently web applications Also - "recently", LOL. Perhaps in your head we are still in the Glorious early 2000s...
The mixed style is bad. It should be either bracket-style or the appearance of an indentation-as-syntax language like Python with "open ends". 
No, what he wants is the code to adhere to his team's coding standard, which prettier will not allow you to do.
I'd be fine with opinionated if it didn't enforce things that you can't change at all, anywhere... Shy of making a fork and changing the code yourself. Makes it entirely useless for you if you don't want some random contributors on github to make decisions for your organization.
It would be even better if they let you configure your own settings, though, no? Then you can appeal to both groups. As it is, they've basically told everyone that they're too stupid and need to write code their way or don's use prettier. Personally, that second option works just fine.
[removed]
Why should it be that way?
I never said Typescript changed the implementation of const. But Typescript does address a lot of the problems with JavaScript in general.
How do u account for unique mutations like tree sizes? I can't imagine u have separate objects for each tree
I guess people are interested in the answer, I am super interested because I am trying to build web apps with body pose inference. &amp;#x200B; You can check out what I built here [here](https://dancebattlenow.com/xmas). I'm trying to increase performance so that's why I'm curious 
Still, I’d be very surprised if someone can help you on that alone. Any more details you can possibly think of?
When I work in a brackets language, I'm used to follow the indentation path back one closing bracket per indentation level. When this is possible sometimes and sometimes not, this is confusing.
I’m never saying the assigned value changes. In fact it can’t. JS throws an error if you try to change a const.
Personally I think it's becouse it's made by Danes and we have " on shift + 2 
You're the boss ;)!
No
Thanks man, I don't remember anything else. That's the only thing that stuck 
For chatbots in JS, check out the NodeJS SDK for Microsoft’s Bot Framework.
The pages that need SEO can be cached and then load time is no longer significant
Do you have any good resource to recommend? For a beginner JavaScript tutorial
Great idea, I can see myself using it to process deeply nested GraphQL results...
Hmm I’ve always been a big fan of anything by WesBos but his stuff isn’t free! Personally I think it’s worth the price though. It’s been a while since I was a beginner but for free resources I know people speak highly of free code camp.
Cool. Thanks man I'll take a look a code camp. Cheers. Merry Christmas
No worries, Merry Christmas to you too!
It’s worth documenting - implementing the basic SIP requests is pretty easy - implementing something that supports all the various RFCs and works in the wild is rather harder.
Which is why using a ternary to assign a variable value to a const is a misuse of const. It's breaking the system in a way that is never intended to be done. You can't do const someVal = null if (condition) { someVal = 10 } else { someVal = 20 } So why would you do const someVal = condition ? 10 : 20 Yes, it works, but it's a hack, and it's bad quality code.
You could have mentioned more details as to why they are adopting and for what purposes since NoSQL doesn't fit in every use case. Still, nice post about Mongo and stuff.
Good point.
I had hopes for MongoDB back about 10 years ago, but the whole anti-relation mind set for me ruined it. 
I don't understand why coding standards have be a application instead of communication with team members? 
I mean, it is though. It would handle all this formatting for you and give you a clear, consistent method that is already in place at multiple different companies and agencies. I guess if you want a literal “what do I think” answer - I don’t like it. It’s ugly, unnecessarily verbose and would be confusing to bring an external dev into. But if you’re trying to come up with a “best for me and no one else” system, it doesn’t really matter what others think.
Do you feel like fcc is a good learning environment of is one of the Udamy courses better? 
In an environment with a lot of turnover, lots of contractors, I might be completely on your side of the argument. I’ve been a contractor where I am a guest in the code base, sometime working in an unfamiliar programming language, I probably would have welcomed a linter.
Is this the same bot framework MS used that quickly turned into a racist asshole on Twitter? 
That's ridiculous. You're using a straw man because that's not what a ternary is doing. The following is an implementation of how a ternary actually works. function ternary(condition, value1, value2) { if (condition) { return value1; } else { return value2; } } const myConst = ternary(true, value1, value2); There's nothing wrong with this because all I'm doing is picking what value to assign to the const using a function. It never changes AFTER it's been assigned. Do you hard code everything that goes into a const? 
Wtf are you talking about? A ternary is just an if/else shorthand. It is NOT a function. You should probably finish whatever bootcamp you're part of before you try to correct an actual software engineer on the internet.
The point is to stop talking about coding standards. Just use it and stop trying to change it. Every option they give you to change is a entry point for bikeshedding. I’ve never felt more free writing code with “prettier on save” in vscode. I just type away, and hit save, and boom. It’s all perfect. Does prettier format it exactly the way I would left to my own devices? Of course not. But The benefit far outweighs my very specific personal preference that doesn’t actually matter a single bit at the end of the day. 
I didn't say it IS a function. I'm saying that's how a ternary OPERATES. Also, you keep telling people that they're wrong, but literally never answer anybody's questions. Do you hard code everything that goes into a const?
All of Mead’s stuff is good. Just go for it 
No it isn't. Not at all. A function and a conditional statement are not comparable at all. Just stop. You're embarrassing yourself.
Do you hard code everything that goes into a const?
Right but my point is that if you own or are loaning the server itself from the company, you can easily switch to another company or link to other services on another company. If you go serverless, AWS Lambda will only interact with other AWS things. If they fuck you and you need to hot switch to Azure you'd have to waste time rewriting your code to be Azure-equivalent-of-lambda compatible.
No. 
If you simply want to calculate when the last Tuesday was, that's relatively easy. const TUESDAY = 2; const DAYS_IN_WEEK = 7; const MILLISECONDS_IN_DAY = 24 * 60 * 60 * 1000; const today = new Date(); // The remainder operator (%) in JS is broken by design. It's not a proper mod operator. // So we need to add 7 to prevent the dividend being negative. const daysSinceLastTuesday = (today.getDay() + DAYS_IN_WEEK - TUESDAY) % DAYS_IN_WEEK; const lastTuesday = new Date(today.valueOf() - daysSinceLastTuesday * MILLISECONDS_IN_DAY); lastTuesday.setHours(11, 0, 0, 0); // Set hours in local time. console.log(lastTuesday.toString()) 
Having options doesn't hurt anything except their egos. If you like the defaults you don't even need to set them. Just run default. But enforcing rules that can't be changed? Nah, professionals don't have any use for that.
They have a bunch of options. But trying to get super specific options for all the weird heuristics is a waste of time for everyone. More options = more arguments about what those options should be. I’ve been writing software for almost 20 years and I can’t imagine going back. I only wish the rest of the languages I wrote had formatters as opinionated as prettier. Seems like it’s your ego that’s hurt because their style doesn’t match what you like. 
Yeah, the difference is I'm being paid for my opinion on my organizations code. The prettier contributors aren't
Yeah, but I didn't imply in my comment, that all of these were a singular case. Some pages require SEO and are prerendered, some are relying on dynamic data and are not. 
Yup, looks like your ego is the one that has a problem then. If all the JavaScript in your org was run through prettier it sounds like you’d be out of a job. Your sacrificing your developers experience because the output of prettier doesn’t match your personal preferences. I would hate working for you. 
If not open software, the only people who would be using compilers instead of writing machine code using punchcards would be people who work in private companies that can afford to develop their own compiler for X language.
Some people take to dictatorial situations and some don't. I guess you and I just stand on different sides of that line. Probably because of my ego.
Bitbucket has free private repos and is objectively better than github anyway.
If I was paying you to have opinions on the code, and your opinions were all related to the things prettier fixes, I’d fire you for wasting our time. The opinions you should be provided your developers should be about things like data flow and organizational concepts. We had a guy who basically spent every code review nitpicking white spacing and other tedious bullshit. Why waste anyone’s time with that garbage when no matter how you wrote it, prettier would fix it to all be identical. Then you would be focusing your “opinions on code” for the things that actually matter. Nothing that prettier changes affects the execution of the code. And something like uglify will come through and destroy all that nonsense for production code anyway, so you should be focusing on code problems that actually matter. 
Like I said, some people work better when other people run the show. That's you 
I'm currently like 60-70% through the Jonas S. course you linked in your OP (Complete JS course 2018: Build Real Projects) I say this as someone who has done 3 years of a BS in Computer Science (and slacked off more than I should)... The course is good. It teaches you quite a bit of theory about WHY things work the way they do in JS which is very useful to know because it can influence how you write code. To be successful you will need to take what you learn in the course and build your own projects, have initiative, etc. I've been doing like an hour a day for the past 2 weeks with a couple days where I've done like 5-6 hours and a few days where I haven't done anything. It was worth the $12 or whatever I paid. 
Nope, I do run the show. I just chose to spend my time and energy on the things that actually make a difference in production. I can forego my personal stylistic preferences to make life better for my team.
&gt;HTML and CSS are often seen as a burden. Because they are, thanks to every browser being a little whiny bitch just like whoever wrote this article and shoving their opinion down everyones throats, meaning web developers have to deal with as many standards as there are browsers. I don't think I even need to mention JavaScript... Yeah it's getting better everyday but still sucks ass and someone has to do it. Also knowing how to use bootstrap is a skill, because unlike libraries in any other language, bootstrap is what every single browser should fucking support by default so you don't have to think twice whether you're running on a Tamogotchi, Tomagatchi, a fucking toaster or a desktop Safari. Having to use libraries like bootstrap (and, long ago, *cough cough* jQuery) is like if I had to install 3rd party library so I could create a new folder, or be able to change my desktop wallpaper, because mr fuck standards Operating System that I have right here didn't really care to think about that thing that everyone fucking uses. TL;DR Fuck you and fuck off.
Cool for you. But I'm not forcing my people to get used to prettier in code reviews because, I don't know if you've noticed, JavaScript isn't known for longevity of technologies.
&gt; But I'm not forcing my people to get used to prettier in code reviews This tells me that you haven’t actually done enough research to implement it properly. If all the code in the repo has been through prettier, and the new code for a review has also been through prettier, there is nothing to see in the review but the written code. I’d encourage you to do some more research and try to see how the tool will actually help you.
Research already done. I have no use for it. ESLint gets the job done without authoritarian implementation. Prettier is, at best, kinda neat. But not useful without being able to align it with the way my organization is already running. I don't make changes because of some third party technology's inability to fit into my culture. I just don't use that technology. Easy. 
That's the reason why we're using eslint with an external config. That way we don't have to set options one by one, but we are free to tweak the options that matter to us
&gt; Research already done. Haha, nope. That part is pretty clear. &gt; third party technology's inability to fit into my culture Yup, your ego is the top dog.
You can fan boy your little technology. That's fine. Ultimately, if code formatting is such a pain that you need an outside organization to handle it for you, it sounds like there's just a lack of talent.
It’s not about pain, it’s about waste. Why waste my time manually doing what the computer will do for me? And literally make it 100% exactly the same every single time with no effort. You can also use eslint after prettier to enforce your ego standards. Eslint can’t break lines, but it can probably fix everything prettier does that you don’t like. You’re throwing the baby out with the bath water. 
It can't, actually. We use black lines to separate certain statement blocks as part of our coding standards. Prettier strips them and you can't stop it if you use it. Like I said, I have no use for it.
Black? do you mean Blank? You're right, it collapses all double returns to single returns. And relying on extra blank lines for that just sounds awful. If your blank lines are always consistent, there is probably already a plugin for eslint that can re-add them. And if they're not...
This post was removed. Please read our guidelines before posting.
eslint is the only truth. Don't listen to prettier heathens.
I am trying to implement the mocking bird example with a recursive collatz function that returns an array but can't get it to memoize. I have a suspicion that it's something to do with either how I wrote the collatz function or the memoize function. The memoize function will store the first key with the value of the first call and only match that for any subsequent calls regardless of input. &amp;#x200B; If anyone has any suggestions I'd love to hear them. Thank you `const memoized = (fn, keymaker = JSON.stringify) =&gt; {` `const lookupTable = new Map();` `//rest operator turns arg into []` `return function (...args) {` `const key = keymaker.call(this, args);` `console.log(lookupTable,key)` `return lookupTable[key] || (lookupTable[key] = fn.apply(this, args));` `}` `};` `const ignoreOthers = ([...values])=&gt;{` `return JSON.stringify(values.shift())` `}` `const mockingbird = fn =&gt; (...args) =&gt; fn(fn, ...args);` &amp;#x200B; `const _collatz = (myself,n,arr=[]) =&gt;{` `console.log('run',arr.length)//runs arr.length times` `if (n&lt;=1) return arr.concat(1)` `else if(n %2 === 0) return myself(myself, n / 2, arr.concat(n))` `else return myself(myself, (n*3)+1, arr.concat(n))` `}` &amp;#x200B; `const mCollatz = mockingbird(memoized(_collatz,ignoreOthers))` `console.log(mCollatz(10))` `console.log(mCollatz(5))` `console.log(mCollatz(5))`
Eh. The wisdom to take from that is that you need a balance, not that 80/20 is necessarily the right balance. If nobody learns (and therefore doesn't use) a framework it will be practically DOA.
The thing though is that if nobody ever used tools or frameworks you could just end up with siloed in-house hackjobs left and right. Just because you didn't use somebody else's doesn't mean the result is goibg ti be well engineered. I think the two problems that you identified are separate pronlens, even if they happen to intertwine. For the most part I only see web stuff from the outside, but who even defines the standard? Does something become a standard simply because everyone ends up following the leader? If so then there's little process or consensus. Imagine if there had been 25 competitors in the various media wars and there was no definitive moment when the majority of people switched to one of them...