I don't see the point with D3. It doesn't build the graphs for you, you still have to write all the CSS yourself manually. All that it seems to do is provide a bunch of selectors for you, which is a solved problem with Jquery. Is there any other library to whom you just pass on an array of data, and then call: var data = [...]; $("#myDiv)".barChart(data); or: $("#myDiv)".pieChart(data); And it takes care of building the chart and producing the css for it?
Appreciating the details: I love the post's use of the words "totally" "way more" "insanely" and also "moar." LOL
Cool effect. You have an off-by-one error with if (thisIndex === $('#decyphering li').length) { This is also a case where using setInterval is perfect for the job. See my revision here: http://jsfiddle.net/U4rUm/7/. I also cached the jQuery selectors and put everything in an IIFE.
D3 lets you bind an array of data to DOM elements in such a way that all attributes of those elements are built by data. This is why they speak of data-driven documents. As already told by bauser, you can build a layer of js functions upon d3. Another interesting library is protovis, a parent of d3. There is also [CCC](http://www.webdetails.pt/ctools/ccc.html ), an open source charting library upon Protovis, that lives in Pentaho environment. Maybe you can find there what you are looking for. 
In case you are wondering why... If you don't specify 'this.' it creates a new variable called 'method_1' and will hoist it up... here, read the answer to this: http://stackoverflow.com/questions/1470488/difference-between-using-var-and-not-using-var-in-javascript
These two approaches have different uses. If you want to make a my_class2 class, which inherits method1 from my_class, you should use the second method above. This cannot be achieved using the first method. The pros of the first method: (which by the way, is declaring an implicit global "method_1") are: 1. Method_1 cannot be overwritten, and will not be accessible to other code. 2. If used correctly, can avoid potential scoping issues. (if you are unfamiliar with how the "this" keyword works in javascript). Cons of the first method: 1. Does not promote code reusability. e.i., this method cannot be used by other code. 2. Larger memory footprint as a new function object is created each time an instance is created. Pros of the second method. 1. Promotes code reusability. 2. Smaller memory footprint. 3. Allows for modification during the lifetime of the instance. Cons of the second method. 1. Can lead newer developers to assume an incorrect "this" value. 2. Can be overwritten unintentionally. If you want to take a look at something that achieves both, https://gist.github.com/tencircles/6513760
True, but referring to the .constructor property isn't very reliable. In most cases you're much safer using the instanceof operator or Object.prototype.isPrototypeOf
No... AngularJS allows you to bind interactivity to a DOM element, while D3 binds SVG DOM elements to data.
There are a few good ones that I know about: * https://github.com/fullscale/dangle * http://nvd3.org/ * http://mbostock.github.io/protovis/
Where does it fail?
Idk what shoretel is but it could certainly be a firewall issue. If in doubt, turn off the firewall. If it's running on your local computer, grab putty and try to make a telnet / raw connection to localhost on port 31456. If you connect to an http server, you should be able to type "GET /" and press enter and at least get an error message from the web server.
&gt; I thought wireshark was strictly wireless. Lol! It used to be called ethereal and really it works for anything Ethernet and up (so TCP, IPX, etc...) It's really just a gui on top of pcap / tcpdump. It had a namechange a few years back. Yes it's going to be similar to fiddler, but it's more generic. I think fiddler also runs as a proxy, so whether it works with a given program or not is going to depend on how well that program behaves. Wireshark is going to grab all network traffic on a given interface. Curl is not like wireshark or fiddler. Curl will be used to initiate requests to your endpoint. It's taking place of your browser and javascript. Wireshark and fiddler are listening to the traffic and they'll show you what's going on. You can run wireshark while doing your Curl call and while running your browser call and see how they're different - if one works but the other doesn't, this can tell you why. The reason all 3 of those are important is because sometimes you are going to have a javascript problem - where the problem is with your programming, browser, or syntax. Sometimes you are going to have a service or HTTP problem that's got nothing to do with javascript at all, in fact your javascript will be perfect and correct, yet the thing you're building doesn't work for some reason. Knowing how and why your service works is what you will need to do to get things working in those cases. Remember that breaking down your problems into small pieces is going to make them solvable. In other words, put fewer lines of other people's code between you and the issue you're troubleshooting to narrow it down.
That's styling the width of a div element. http://en.wikipedia.org/wiki/Scalable_Vector_Graphics might shed some light on the difference between SVG and HTML.
The same method can be used on any element, in the examples given, all they're doing is changing some attribute (width, height, etc) of some element as well..
Love knockout! Been using it for over 2 years in various production apps. My main complaint has been that, although the binding architecture rocks, you're still left with typically messy and unorganized code which tends to make Knockout impractical for larger applications. This article has some good tips though. Also, if anyone else is interested, I'll be releasing a library myself that adds MV* structure to Knockout to help with this, called Falcon, relatively soon. Feedback welcome! Here's the current docs (WIP): http://stoodder.github.io/falconjs/
if your functions are direct attributes and you try to iterate over the properties of an object, you'll iterate over the functions as well. if they are functions on the prototype, they are hidden from the iteration.
No. ryosen did not give you an actual instance of inlining. However, when they said: console.log( function() { return 'Hi, I'm an inline function!'; }); **you** gave a manually inlined version of their code: console.log('Hi, I'am an inline function!'); 
Method 1 (assignment in the constructor) produces a closure, i e. actually a different function for every object instance. Method 2 (one time assignment to the prototype) uses the same function for every instance.
It fails during inheritance, constructor property will point to the parent constructor.
I'm not a big fan of this optional braces syntax - that's my biggest peeve with coffeescript. &gt;Because curly braces are used to denote the function’s body, an arrow function that wants to return an object literal outside of a function body must wrap the literal in parentheses. That's just messy. 
Protovis is actually the spiritual predecessor to d3 rather than a charting library built on d3. I've heard good things about nvd3 however.
I totally agree. I'm not sure where the arrow notation originated from, but I know c# already had it and there it made some sense. I don't like doing ascii-art in my code while still not reaching full efficiency/readability with the new syntax (but i have to say it's better to type than typing "function(…){return …;}" all the time). They basically want to create a lambda function. Some functional languages use "\a b.a+b". I find that that looks good. However JavaScript is partly a imperative language and to show that we usually use a statement block. However JavaScript has the problem that its object notation uses the same {} as the statement block. So we want something that ensures we don't confuse the two. In es6 they use {…} for statement blocks and ({…}). I get why I need to do this, but *looking* at the code {…} doesn't make this clear at all. On top of that looking at x =&gt; y will for quite a few people trigger the thought of x &gt;= y... Or the inverse of x &lt;= y... That makes sense I think, but they would be wrong. Now there's also the parameters. When you add a parameter to the function x =&gt; x + 1, how would you do that? Well, adding a "(", adding a ")", adding a "," and *then* adding your parameter... It's again a special case for multiple parameters compared to a single one... That isn't intuitive. The "," is also not needed, because JavaScript doesn't prefix its variables with types like c# does: (int x, int y). In c# it's just a necessity, in js it's bogus (of for people who find it more visually pleasing to separate words with ",", if that's the case I'm OK with it). So, i'd like to see some other syntax that's way simpler without the special cases and maybe even simpler to type and nicer to look at. "\" doesn't have a purpose in js statements or expressions, so we can use that... Certainly looks more like a lambda. Parameters can be added with just spaces and lastly the function body will always be surrounded by {…}. Instead of () =&gt; {…} you will have \{…} Instead of x =&gt; x + 1 you will have \x{1} Instead of (x, y) =&gt; x + y you will have \x y{x + y} Instead of (x, y) =&gt; ({x:x,y:y}) you will have \x y {{x:x,y:y}} And, while we're at it also let the last statement always return the value it resulted in: \x y { let len = Math.sqrt(x*x + y*y); {x: x/len, y: y/len} } Now these aren't the best examples, but a better syntax would have taken care of guessing games and mixing up syntaxes. It seems the current syntax is just copied from another language even though it doesn't fit js all that well.
Yeah - Rails gives you so much out of the box (conventions, security, convenience, etc.) that it's really hard for me to choose another solution. Yehuda Katz sums it up nicely in [this](http://vimeo.com/50451185) talk.
True. I haven't used nvd3 myself, but I've seen it in use... looks useful
Of course when using ASCII art ({…}) has a much older interpretation... someone didn't think this through.
Which is why you correct it to point to the right object. See any compiled TypeScript with inheritance.
Hope you don't mind me pointing out a few errors. return { d3: function() { return d.promise; } }; angular.module('myApp.directives', ['d3']) .directive('barChart', ['d3Service', function(d3Service) { return { link: function(scope, element, attrs) { d3Service.then(function(d3) { // d3 is the raw d3 object }); }} }]); In this first example of using the d3 service. You define it as an object with a d3 property but then use it as if you were returning the promise itself. Throughout the examples you seem to switch between using the service directly or invoking the d3 function on the service, which can be confusing. A bit later on you do this angular.element($window)[0] Which just wraps the window and then unwraps it immediately. Unless I'm missing something this is unnecessary. Also in this same snippet, you don't inject the $window service into your directive. .directive('d3Bars', ['d3Service', function(d3Service) { Also when using the $http service, it's probably better practice to use .success and .failure callbacks, rather than .then. Otherwise the article looks good. I'll probably give it a longer read through later. 
This article touched on something I've been wondering about recently: what is the best practice in angular to include a third party library like d3? I'm not a huge fan of returning a service/factory as a promise since most services/factories I write I will call directly rather than calling .then. Copying and pasting the library could be done in a Grunt task so I can use Bower to update the library and the changes will automatically be propagated. Is there some preferred way to do this?
1) It's not the naming, it's how you invoke it. You do both of these throughout the article d3Service.then(...) and d3Service.d3().then(...) It obviously can't be both, and going by how it's defined initially, it should be the latter in all cases. 2) It's not about the performance hit (is there one? as far as I know $window === window), it's the fact that you never injected it into the directive an unnecessarily wrapped it using jqLite (or jQuery). angular.module('appApp.directives') .directive('d3Bars', ['d3Service', function(d3Service) { return { restrict: 'EA', scope: {}, link: function(scope, element, attrs) { d3Service.then(function(d3) { var svg = d3.select(ele[0]) .append('svg') .style('width', '100%'); // Browser onresize event $window.onresize = function() { scope.$apply(); }; // hard-code data scope.data = [ {name: "Greg", score: 98}, {name: "Ari", score: 96}, {name: 'Q', score: 75}, {name: "Loser", score: 48} ]; // Watch for resize event scope.$watch(function() { return angular.element($window)[0].innerWidth; }, function() { scope.render(scope.data); }); scope.render = function(data) { // our custom d3 code } }); }}; }]); This directive isn't getting the $window injected and yet you are using it inside. Sorry if I mistook what you said but it seems you missed the first 2 points.
Looks interesting. Have you seen [Durandal](http://durandaljs.com/) or [Knockback](http://kmalakoff.github.io/knockback/)? How does your library compare to those two (if it does)?
If you really need to expose the library as a service to make it mockable in tests, I would just wrap it in a simple factory. It can be as simple as exposing the global object, no need to make it complicated. (function(angular, d3) { var mod = angular.module('deps', []); mod.factory('d3', function() { return d3; }); }(window.angular, window.d3)); Copying and pasting the entire library seems like extreme overkill. This is just my opinion. Somebody else may know better.
That's more or less what I've been doing. I don't really like copying and pasting either, mostly because doing so then makes you unable to load things like d3 or jQuery or whatever from a CDN. I was just curious if there's some recommended way to do it that enables testability plus offloading it to a CDN. It seems like your suggestion is the best way as far as I've seen.
I'm actually a huge fan of this approach to using more classical "classes" in js: http://ejohn.org/blog/simple-javascript-inheritance/ Like others have said, each method has an appropriateness which varies with context. One might consider taking the time to understanding how to work with javascripts model of prototypical inheritance versus forcing the paradigm with the aforelinked method. See: crockford.
If you're using murmurHash3 server side for screaming fast non-cryptographic hashing and you need to be able to generate the same hash locally. I had a project where this was *exactly* the case: I was hashing tons of web pages remotely so I needed the fastest algorithm I could find, and I needed my client side js to be able to generate the same hash to compare data. If you only care about client side hashing, then use whatever works for you; there'll definitely be faster hashing algorithms than this in that case.
Neat, but never go full functional AND introduce several technical caveats. For what little convenience this yields, I'm sure we'll get a shitload more headache for each JS developer that doesn't bother reading the spec details. Among other things, we'll now have two "function" types with no way to differentiate which is the arrow type using the typeof operator. &gt;--SpecPeople=&gt;
Biggest problem with the arrow syntax is when I showed an empty function to a buddy of mine: () =&gt; {} His first reaction was that this looked like some ascii art pr0n. More seriously, I'm using those darn things daily in a typescript-based project, and it's pretty nice. The sane `this` binding accounts for a big part of it. 
 var multiply = a, b =&gt; a * b The arrow syntax is based on various other dynamically-typed semi-functional languages. A language I'm intimately familiar with, Groovy, would define a multiplication closure as: def multiply = { a, b -&gt; a * b } Haskell also has an arrow syntax, though I don't know enough about Haskell to comment on how it is similar or different. I would be super-excited if ECMA strengthened its functional credentials, particularly with regards to performance.
As an aside, cool javascript interpreters will inline functions for you in the code generated by their JIT, whenever possible. There are a number of rules for that to be possible, and they tend to vary over time and browsers, but at the very least, your inline-hopeful functions must not use `eval` or `arguments`, and should not contain any inner functions. The simpler the function, the more likely that it can get inlined. Complex branching/looping may prevent inlining. Generally though, it's not something you spend a lot of time worrying about, unless you're near the end of your dev cycle and going crazy trying to shave one more % of performance on one specific browser. 
so firstly, i feel pretty confident that neither of these drawbacks begin to matter until you start to deal with large scales. while traversing the prototype chain involves more operations than accessing direct members of an object, it takes negligible time - until you multiply that small amount of time by, say, 10,000. likewise, having a separate copy of a member function in each of your instances requires an additional small bit of memory - which is not a concern until you are dealing with thousands of instances. so if you wanted to know which is better, you might think about it as: * are you dealing with thousands of instances? if not, the question is one of premature optimization * if so, do you care more about slightly faster execution speed, or moderately less memory consumption? if the latter, use prototypes.
I didn't have any luck using it with Backbonejs, the permission dialog keeps showing up, as if in loop, doesn't matter if i authorize or not. [Here's the code](https://github.com/jorgeguberte/Wikify/blob/master/views/index.ejs), the annyang call is on line 118. And [here's the app running](http://morning-dusk-7497.herokuapp.com/)
I simply said it's not reliable as in if you're working with codebase you're not familiar with or with minified code, or even with code your team has done, you can never be 100% sure that the .constructor property will be correct. Compiled TypeScript I'm sure is fine, but in compiled TypeScript you don't have this concern as you're no longer coding in JavaScript. By the way in the example above you don't need underscore. You can simply use Object.defineProperties(C.prototype, {});
Ok, now make an interactive visualization like [this](http://nickqizhu.github.io/dc.js/crime/index.html) with colored divs. dc.js works nicely with angular, btw. Angular is great *because* it allows you to integrate different tools and services painlessly. 
I guess they can always add it later...
The Groovy syntax looks like at least a step in the right direction from the arrow syntax in es6, since there will be less confusion, although for the more simple functions it does need more typing than the es6 syntax. Haskell uses \x y -&gt; x + y as its lambda syntax.
I meant that simply using the standard inheritance pattern, such as TypeScript compiles to, means you don't need to worry about misconfigured properties. Alternatively, use Object.create if your target audience isn't behind the times.
If you use the Object only once, go for a singleton pattern instead: Singleton = new function(){ this.method = function(args) { ... } }; // don't forget this semicolon, especially if followed by ()... Singleton.method(...); This way, you have the same open-ness of the prototype minus the additional prototype scope query.
The fuck are "arrow functions"? Oh! Lambdas.
lambda?
Great article on KO. A good deep dive. Thanks. I am also a big fan of KO. Main reasons are great tutorials, good docs, good blogs, and its focus on data-binding. The head space required for KO is far less than Angular. Having said that there's still plenty to get your head round in KO. Once again great article
Great feedback and I think you are right in all your points. I've been thinking about bundling the package with some sweet.js macros to make the channel communication more intuitive. The debug and scheduling problems I cant think of a solution for at the moment. The library is an experiment and more about showing off the flexibility of generators in implementing concurrency models than it is a serious alternative to the standard node.js way.
I haven't seen Durandal before, so I'll have to do some research and get back to you on that! Thanks for showing me. As for Knockback, both libraries were derived from the same concept. Providing the ease and structure of Backbone but still keeping to the idea of data binding and view models. That being said, the biggest difference between Falcon and Knockback is how we handle Views. Knockback doesn't really have a view architecture and really only utilizes Backbone's Models and Collections for data organization/syncing. Falcon has a concept of a View that each have their own knockout template and view model (hence isolating functionality to specific views). Falcon also has a 'view' binding that allows us to inject views within one another, which can be useful for adding multiple 'pages' to an application or just having a 'widget' that can be added however to different pages. I'll try to give you a quick, crude example: [Example in jsFiddle](http://jsfiddle.net/stoodder/m9myL/1/) 
&lt;html&gt; &lt;head&gt; &lt;title&gt;Hilarious Limerick Generator&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="limerick.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; /* Author: Glen Lambert */ alert('Hello There :)'); function getData() { var textstring = ''; // YOUR NAME var yname = document.getElementById('yourname').value; if(yname.length &lt; 1){ alert('You haven\'t filled in your name!'); document.getElementById('yourname').focus(); return false; } // CHARACTERS NAME var cname = document.getElementById('charname').value; if(cname.length &lt; 1){ alert('You haven\'t filled in your charcters name!'); document.getElementById('charname').focus(); return false; } // SEX var sex=''; if(document.getElementById('man').checked){ sex = document.getElementById('man').value; } else if(document.getElementById('woman').checked){ sex = document.getElementById('woman').value; } /* var varsex=''; if(document.getElementById('sex').value'{ varsex= document.getElementById('his').value } */ // AGE var age=''; if(document.getElementById('old').checked){ age = document.getElementById('old').value; } else if(document.getElementById('young').checked){ age = document.getElementById('young').value; } //VERB var verb = document.getElementById('verb').value; if(verb.length &lt; 1){ alert('You haven\'t filled in your rhyming verb!'); document.getElementById('verb').focus(); return false; } //NOUN var noun = document.getElementById('noun').value; if(noun.length &lt; 1){ alert('You haven\'t filled in your rhyming noun!'); document.getElementById('noun').focus(); return false; } // CHARACTERS JOB var job=''; if(document.getElementById('butcher').checked){ job = document.getElementById('butcher').value; } else if(document.getElementById('baker').checked){ job = document.getElementById('baker').value; } else if(document.getElementById('cleaner').checked){ job = document.getElementById('cleaner').value; } // TASK var task = document.info.task.options[document.info.task.selectedIndex].value; // PAST TENSE var past = document.info.past.options[document.info.past.selectedIndex].value; // DIRECTION var dir = document.info.direction.options[document.info.direction.selectedIndex].value; // RHYMES WITH DIRECTION var rdir = document.info.rhymedir.options[document.info.rhymedir.selectedIndex].value; // STRING textstring = yname + '\'s' + ' poem' + '&lt;br /&gt;'; textstring += 'There once was a' + ' ' + age + ' ' + sex + ' ' + 'named' + ' ' + cname + '&lt;br /&gt;'; textstring += 'Who' + ' ' + task + ' ' + 'more than he wanted to' + ' ' + verb + '&lt;br /&gt;'; textstring += 'One day' + ' ' + cname + ' ' + past + ' ' + dir + '&lt;br /&gt;'; textstring += 'And said with' + ' ' + rdir + '&lt;br /&gt;'; textstring += 'That' + ' ' + + ' ' + 'eating was more than a' + ' ' + noun + '&lt;br /&gt;' + '&lt;br /&gt;'; textstring += '&lt;img src="Images/lol.png" alt="lol"&gt;'; //WRITE TEXTSTRING document.getElementById('write').innerHTML = textstring; } &lt;/script&gt; &lt;center&gt;&lt;h1&gt;Hilarious Limerick Generator&lt;/h1&gt;&lt;/center&gt; &lt;br /&gt; &lt;form id="info" name="info" method="post" action="#" enctype="text/plain" onSubmit="getData();return false"&gt; &lt;fieldset&gt; &lt;div align="left"&gt; &lt;p&gt; &lt;label for="yourname"&gt;Your name&lt;/label&gt; &lt;input type="text" id="yourname" size="25" maxlength="20" name="yourname" /&gt; &lt;br /&gt; &lt;label for="charname"&gt;Characters name&lt;/label&gt; &lt;input type="text" id="charname" size="25" maxlength="20" name="charname" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="sex"&gt;Sex of your character&lt;/label&gt; &lt;input type="radio" id="man" name="sex" value="man" /&gt; Man &lt;input type="radio" id="woman" name="sex" value="woman" /&gt; Woman &lt;/p&gt; &lt;p&gt; &lt;label for="age"&gt;Age of your character&lt;/label&gt; &lt;input type="radio" id="old" name="age" value="old" /&gt; Old &lt;input type="radio" id="young" name="age" value="young" /&gt; Young &lt;/p&gt; &lt;p&gt; &lt;label for="verb"&gt;Verb that rhymes with your characters name&lt;/label&gt; &lt;input type="text" id="verb" size="25" maxlength="20" name="verb" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="noun"&gt;Noun that rhymes with your characters name&lt;/label&gt; &lt;input type="text" id="noun" size="25" maxlength="20" name="noun" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="job"&gt;Characters job&lt;/label&gt; &lt;input type="checkbox" id="butcher" name="job" value="butcher" /&gt; Butcher &lt;input type="checkbox" id="baker" name="job" value="baker" /&gt; Baker &lt;input type="checkbox" id="cleaner" name="job" value="cleaner" /&gt; Cleaner &lt;/p&gt; &lt;p&gt; &lt;label for="task"&gt;Task your character might do at work&lt;/label&gt; &lt;select name="task"&gt; &lt;option id="choose" value="" selected="selected"&gt;-- Choose one --&lt;/option&gt; &lt;option id="chopped" value="chopped"&gt;Chopped&lt;/option&gt; &lt;option id="cooked" value="cooked"&gt;Cooked&lt;/option&gt; &lt;option id="cleaned" value="cleaned"&gt;Cleaned&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="past"&gt;Pick a past tense verb&lt;/label&gt; &lt;select name="past"&gt; &lt;option id="choose" value="" selected="selected"&gt;-- Choose one --&lt;/option&gt; &lt;option id="jumped" value="jumped"&gt;Jumped&lt;/option&gt; &lt;option id="hopped" value="hopped"&gt;Hopped&lt;/option&gt; &lt;option id="sat" value="sat"&gt;Sat&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="direction"&gt;Pick a direction&lt;/label&gt; &lt;select name="direction"&gt; &lt;option id="choose" value="" selected="selected"&gt;-- Choose one --&lt;/option&gt; &lt;option id="right" value="right"&gt;Right&lt;/option&gt; &lt;option id="back" value="back"&gt;Back&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="rhymedir"&gt;Pick a word that rhymes with your direction&lt;/label&gt; &lt;select name="rhymedir"&gt; &lt;option id="choose" value="" selected="selected"&gt;-- Choose one --&lt;/option&gt; &lt;option id="delight" value="delight"&gt;Delight&lt;/option&gt; &lt;option id="contrite" value="contrite"&gt;Contrite&lt;/option&gt; &lt;option id="quack" value="a quack"&gt;Quack&lt;/option&gt; &lt;option id="clack" value="a clack"&gt;Clack&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;br /&gt; &lt;fieldset&gt; &lt;p&gt; &lt;input type="submit" value="Send my info" /&gt; &lt;input type="reset" value="Start again" /&gt; &lt;/p&gt; &lt;/fieldset&gt; &lt;br /&gt; &lt;/form&gt; &lt;br /&gt; &lt;p id="write"&gt;&lt;/p&gt; &lt;br /&gt; &lt;p id="picture"&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;
it doesnt look that bad in notepad ++
There's an error in your function, afterwards the console gets cleared, since the form is then sent. Try to call getData() manually in the console (F12 in any modern browser), you will find the errors (superfluous comment characters, field "his" not existent).
I didn't know you wanted to put in such a lot of multiple choice. Otherwise I would have told you to use a [simple templating system](https://gist.github.com/tkissing/1347239) for ease of use. In that case you could do something like A redditor {{verb}} wanted to write some poems, it took {{him}} all night with {{noun}} to replace by JS, but with grace but failed to get the {{curse}} thing right. dict = { verb: 'badly', /* really */ him: 'him', /* her */ noun: 'words', /* stuff */ curse: 'goddamn' /* crazy */ } Fill in the dictionary from your form elements and then use the templating to fill it in.
By "//" you make the rest of the line a comment (everything until the line break will be ignored). "\*/" will close a comment that goes over multiple lines, but will produce errors if not preceded by "/\*" (this was probably your first error). If the onsubmit-handler of a form encounters an error, the form will be send, regardless if there's a "return false;" afterwards, which makes debugging somewhat difficult. Pressing F12 will open the developer console in any recent browser (if it doesn't work for you, please tell me what browser you are using) - this will help you a lot to find errors and test code.
I understand, where ever you see "//" only the words in CAPITALS are a comment. Everything after is actually a new line. When i paste my script in this text box it leaves out all the appropriate breaks and makes it look messy, but i assure you its not. Im using chrome by the way
actually this is going to be a nightmare in coffeescript: a =&gt; {a} javascript: a coffeescript: {a: a} 
I loved KO. ... until I made the leap to Angular. I've never looked back.
..and changed the output, because you turned it into what OP **intended**. What OP actually **wrote** would output the function. In some environments it would end up outputting the text of the function, in others '[object Function]' or somesuch, because they left out the () to cause the function to execute. ;)
&gt; You can simply use Object.defineProperties(C.prototype, {}); Not if you want IE &lt;8 support. and not to mention how verbose defineProperties is. Instead of {foo : "bar"} you have to do {foo: {value: "bar" } }
I love it! Before you get too far, I'd suggest using bootstrap 3 instead of 2
You don't need the curly brackets for Coffeescript (and apparently Javascript, too). I don't see a problem. a =&gt; a javascript: a coffeescript: a Edit: actually, the above still doesn't work for Coffeescript because I forgot to add the parenthesis: (a) =&gt; a That should now work for both even though there's no point of this. 
try sticking it into http://gist.github.com and pasting the link
I'll share my initial confusion with the controls, in case that is helpful. First, I tried to view the layout at different screen sizes by clicking the 'small', 'medium' and 'large' buttons in the lower left. Those buttons didn't seem to do anything, so I clicked the plus sign to try to add a column. That didn't do anything either, but I did see the tooltip saying, 'drag to add cols'. So I tried to drag the plus sign, but it just drag-selected the page. After this, I realized I had to drag the things that looked like buttons. I would suggest making the plus sign look less like a button and adding text that says something like, 'drag to add'. 
I haven't really looked in to WebRTC, but isn't that suppose to solve this problem?
Agreed, a lot of the interactions with the various components on the page are not very clear and don't offer much in the way of "affordance". I'd recommend making draggable elements a little more obvious for a user; check out this helpful Quora thread for some ideas: http://www.quora.com/User-Experience/What-makes-something-look-draggable Aside from that; very impressive work. Makes me want to get around to learning Angular when I get some down time.
Seems like 'really fast slide show' would be more descriptive than 'video'
We used Ember for our application and I certainly have not been disappointed. However, I will recommend that you skip Ember-Data (which is a completely optional, but not yet production-ready component) and roll your own persistence layer instead. Ember makes this ridiculously easy to do, with various mixins you can use ([Evented](https://github.com/emberjs/ember.js/blob/master/packages/ember-runtime/lib/mixins/evented.js) and [Deferred](https://github.com/emberjs/ember.js/blob/master/packages/ember-runtime/lib/mixins/deferred.js) in particular) to create your own models to suit your API. I like Ember because every component I write (mostly) has a place it belongs, and small changes are almost always local. The API will simply will not let you (or give you lots of trouble) if you try to break its rules.
It's that if you use the same syntax for both then one will be different. It's not what you 'need' it's what you can do if you don't know any better
apart from that is basically the definition of a video ;) 
if asm.js finds its feet on more browsers we could see this type of thing happen more, websites not being constrained by what their browsers can do and just handling the problem themselves in javascript. 
If you don't know any better, don't use Coffeescript. I'm not really sure I understand your point.
I don't think "just don't use it" is a good answer. The issue is that it's a disconnect between the two languages. Coffeescript and JavaScript are very closely tied and if you write a line in JavaScript it will usually work in Coffeescript. I can see a lot of man hours lost because of this difference so I'll definitely be interested to see if this is taken in to consideration when extending coffeescript in future to take advantage of new language features.
Why do we need asm.js for that exactly? asm.js is just a potentially faster subset of javascript (If the lack of features is taken advantage of). All major browsers already JIT javascript. We do not really need asm.js for this.
because decoding something like h264 (this example decodes mpeg2) with regular javascript at a larger resolution (this example is a very low resolution example) would be really painful. if it could handle a standard 30fps stream at all, it would kill your battery. asm.js makes a lot of that almost go away. 
May I ask what made you narrow down your choices to those 2? Have you checked out resources like http://todomvc.com/? If you are set on those 2, I would suggest Angular. The biggest bonus to angular is that they make DI very, very easy. I don't know if you have done any Java dev but DI in Angular is a breeze compared to DI with Spring. "What is so great about DI?", you may ask, testing. When you have easy to use DI you can make tests easier. DI isn't the only thing that makes testing easy, they have Karma (used to be Testacualr and I wish they had kept that name) that is a test runner for angular unit and integration tests (use Jasmine for your tests IMO). Another thing about angular is directives. Extending what angular and HTML can do for you are really nice, and while directives can be complicated to master, they are pretty awesome. (Just go with the linux mantra on this one, 1 directive does 1 thing). There is also angular-bootstrap which is a community project to bring bootstrap.js to angular through angular directives, they have commiters from the angularjs project as well as others and it is pretty solid (well, it was solid until Bootstrap 3.0 came out, they are still upgrading some directives) I could go on for days about why I like angular and why you should use it. edit: speaking of breeze, you might want to check out breeze.js as they support angular
I guess what I was trying to say was write Coffeescript in Coffeescript and Javascript in Javascript. So when you write in Coffeescript, you omit curly brackets and semicolons. Why is that so confusing?
Just in case anyone hasn't tried it. For anyone who likes types, or c# style syntax, Typescript is amazing. More importantly, Typescript isn't a new language, it simply adds additional features on top of javascript. This is the kill distinction over coffeescript for me.
It really just depends on what market you are targeting. 
I wish more people would at least mess around with knockout, it's so much fun, I wonder if it has anything to do with the microsoft influence? I'm still going to use it.
My current project streams JPEG over websockets for video. We looked into WebRTC, but the support isn't there yet. The biggest problem with using websockets is that it's TCP based, so there will be lags in the video due to network delays, then quick speed ups as the images start to arrive. WebRTC would solve this problem. EDIT: WebRTC is also very heavy to support. You need to set up STUN/ICE servers, etc.
History API usage to remember which slider element is shown. That'd be nice. That way refresh would keep me on the last slide viewed.
Here's a simple answer: Promises are first-class objects for function calls http://blogs.fluidinfo.com/terry/2013/09/12/promises-are-first-class-objects-for-function-calls/
I did play with component and I've been able to get a great demo going for how it could simplify my company's code base. The standalone build is a life saver! Thank you for the nudge in the right direction!
I totally agree. And I think your falcon.js is the first big stepping stone for a larger audience to accept and use KO. So, thank you. I'm currently working on a socket.io based router / flatfile db / KO project, I'm going to look long and hard at falcon.js to see if it's a good fit.
Thank you! I've created an issue for that. https://github.com/karun012/bslider/issues/13
https://github.com/geuis/when-then
Not the best experience on an iPhone. 
I've made a few apps with ember-data as my persistence layer and haven't had too much of a problem. I used Rails and ActiveModelSerializers, which is really what ember-data was designed to work against, so I had a pretty easy time getting everything up and running. Rails pretty much auto-generates the API that I need, and AMS is similar to the Ember models on the backend, they dictate which attributes come through in the JSON. Using these two essential components, I can get an "Ember-ready" backend with my Rails app up and running very quickly. This leaves me more time to experiment with Ember and the front-end "client app".
Using Ember-Data becomes increasingly frustrating as the size of your app (and the number and complexity of relationships between your models) grows. Out of the box, it doesn't support even simple use cases like nested resource URLs. And rolling back changes and recovering from errors/invalid states is still a nightmare which has led to various convoluted workarounds. StackOverflow is filled with answers suggesting creative uses of transactions, creating regular objects in place of actual models and then replacing them with the real things, and tinkering with the internals of the DS.Model state machine in order to just be able to (for example) rollback a model after it has been put in the invalid state. (Although I think some of the latest changes have improved the situation somewhat.) We have made it work in our project, but it was not easy. Given hindsight and the ability to turn back time, I would have probably had us roll our own solution.
Thanks for the reply. I will keep an eye out on Falcon. 
It's JavaScript, by the way. Spelling it correctly will help you in interviews and generally create a better impression about you, in case you care.
Have you seen http://durandaljs.com/ ? If you have, how would you compare Falcon to that?
It seems to be done fine, but including jQuery UI as a direct dependency and then not using it seems weird, why would you do that?
If you need to select a span element - then probably you can write another directive ( if needed ) that will do what you need it to do on that particular span element? 
Well that was the aim. It doesn't require a library, it's just a nice solution to keeping track of a lot of asynchronous functions. I hope you find it useful!
Good to hear this worked out for you and the company. Thanks for the follow-up! :)
I like how you solved the problem of having to learn a bunch of new tools by introducing a new tool.
I actually just found out about Durandal in a different reddit thread, so I'm still learning, but from my initial review it looks like the structure behind the frameworks are quite a bit different. Durandal focusses on View/ViewModel where Falcon has a Model/Collection/View structure. Falcon's views are the equivalent of Durandal's view models, and knockout templates in Falcon (each view has a url to a template) are equivalent to Durandal's views. Both frameworks are compatible with RequireJS. Durandal seems to enforce it where as Falcon leaves that requirement up to the developer. Besides that, Durandal doesn't really provide a construct for interacting with server data where as Falcon implements, by default, a RESTful structure with Models and Collections (very similar to Backbone) that will autofill/serialize when being retrieved and saved. Hopefully I've got that all right. What are your thoughts on Durandal?
I played with this last night at home, can't believe it isn't more popular here. It's freaking amazing.
Let me get a soda pop from the icebox then we'll talk about it.
Thank you for noticing that. I thought that the easing functions used by the slider were jQuery UI specific. I was wrong. Will correct that. https://github.com/karun012/bslider/issues/14
Unfortunately, until we can kiss WindowsXP and all of it's IE8 users goodbye, anything that doesn't support that browser falls on the long list of nice things we can't have yet.
talk about burying your lead
Thanks for the feedback @jetRink and @drunkenfaggot ! I have changed the css styles for the buttons and also changed the overlay . Hope you find it useful.
You can generate the layout once the button on the top left corner It generates html based on the Bootstrap 3 Grid framwork http://getbootstrap.com/css/#grid
We've been posting a lot of angularJS stuff on /r/LearnJavaScript lately, if you're interested.
I found this polyfill for xhr2. Seems like a good starting point for ie8 support - I would probably try to remove the underscore dependency though. https://gist.github.com/lemonhall/3120320
Lovely!
So what makes this JavaScript? Did you make it with JS? I was kind of hoping this would be like that canon game where you control it using JS.
why the rootscope.$apply's in the service?
When I saw the name of the emulator I thought it was a Java SNES emulator. Looks good!
apparently i still suck at Super Mario 3, drats!
Demo isn't quite accurate, the lights on the modem image wouldn't be moving before the whole area of the image had loaded.
ok but except for that have you tried it on other websites? 
I got a Kinect hooked up for development and the array of microphones in there works wonders with this. I could almost whisper commands and it would mostly pick them up. The response is a bit on the slow side but very impressive.
Scroll down the page a bit and all shall be revealed.
http://fir.sh/js/jsnes-4e7a7260aa.js
Ah I noticed span +- at the top and thought it was still doing 2
Neat, but aren't you worried about Nintendo pressuring you to take down all those game ROMs on copyright grounds? (I don't think they should, but AFAIK they're protective, even of old content)
Is there any way to modularize a gruntfile, and have grunt run its own gruntfile on itself to perform tasks like r.js optimization, linting etc on the gruntfile?
siiick
Now it slides the smallest element to the row below the current row, so i think it's fixed :)
(-1, *Not asm.js*)
So the method on the parent scope executes in a digest cycle so UI updates are reflected in the DOM. I think I could remove the call to $apply from the getAdditionalData call.
You can lint a gruntfile just by pointing the linting task at the gruntfile itself. grunt.initConfig({ jshint: { all: ['Gruntfile.js'], options: { globals: {} } } });
I'm 99% sure op didn't make this, just found it. The author of this made it in 2009 and lives in London; so if he were the creator why would he wait 4 years to submit it? Moreover Op's post history indicates he lives in the states, seemingly Austin. I don't know why I felt the need to go all detective on his ass all of a sudden.
Very cool! I feel so silly doing voice commands though. I wonder if that's a common thing, or maybe it'll be natural for the next generation.
I put snes9X through emscripten to make a javascript version last weekend, was fun
I really wished this worked in other browsers than Chrome — especially Safari Mobile. My task app would absolutely benefit from this.
You've just said the opposite of what most other people say. Coffeescript is some of the most readable code I've ever seen and I'm not even a Ruby guy. 
Explain that there are no classes in JS and that the variable scope is bound to functions. That should help them make sense of closures. Anonymous and higher order functions should be fairly simple to demonstrate with a couple of examples. Both are available in AS3 as well. And having made the transition this year from AS3, I agree that these above are all techniques so common in JS that they are to be considered essential. 
Probably because you're a Canadian who doesn't like reverse gifs and plays DOTA.
That's exactly what somebody with no discernible information about themselves in their last 5-10 posts would say.
Whatever, *Liverpudlian*. I can't understand a word you say anyway.
The app is mostly for me, and I don't use Chrome, so: meh :)
^ Agree. Also let them know that functions are first-class in JS, so they can be arguments to functions, returned by functions, &amp;c. This opens the door to partial application/function composition, but I agree these topics aren't something you should cover until they're more comfortable with JavaScript.
If they're Actionscript programmers, they should be already be familiar with this setup.
I haven't seen the use for partial functions. I get being able to define specific scopes when calling a function, but even that is somewhat dangerous. It seems paradigms in javascript are being used because they're there, and no other reasons. Dynamically creating a function, high order languages, and closures are nothing new to programming. They've been around since the 80's. Javascript is the first to mainstream them. If you are teaching JavaScript to anyone who knows C/C++ you'll look retarded acting as if these are ground breaking features...
"The bookmark, it does nothing!" Well, all it's supposed to do is "slow" down the display of images by gradually revealing them. Perhaps test with a larger image embedded on a page: javascript: (function () { var e = document.getElementsByTagName('img'), t = 0, n = 50, r = function (e) { var t = document.createElement('canvas'), r = e.clientWidth, i = e.clientHeight, s = t.getContext('2d'), o = Math.ceil(Math.random() * 350) + 200, u, a = 5, f = function () { s.save(); s.clearRect(0, 0, r, a); s.beginPath(); s.moveTo(0, 0); s.lineTo(r, 0); s.lineTo(r, a); s.lineTo(0, a); s.closePath(); s.clip(); s.drawImage(e, 0, 0, r, i); s.restore() }; t.width = r; t.height = i; t.style.cssText = document.defaultView.getComputedStyle(e, '').cssText; e.parentNode.replaceChild(t, e); setTimeout(function () { f(); u = setInterval(function () { a += 20; if (a &gt;= i) { clearInterval(u); u = null } f() }, o) }, n); n += Math.round(Math.random() * 200) }; while (e.length) { if (e[t].complete) { r(e[t]) } else { e[t].onload = function () { r(this) } } } })(); 
I don't know what the function gibberish you mention is. So probably not necessary. I would do closures and promises though. And prototype chain. 
I hacked together a multiplayer version of this a bit back. The network latency made it awful and unplayable.
Should try peerJS
ha cute. check this out, just found it googling for sites that looked like a BBS: [http://www.masswerk.at/googleBBS/](http://www.masswerk.at/googleBBS/)
This is amazing. I've been trying to do the same thing for the past two weeks and it seems you beat me too it. Incorporating some native UI elements could make this amazing. Curiously, (even with node-webkit) how did you bind the html to the renderer? Is it just a timeout that throws every few hundred milliseconds?
Is the spellchecker slated for the next release?
I think you should use [App42 Backend API.](http://api.shephertz.com) I came across this a couple of months ago and got registered. They support all major frameworks related to javascript or HTML5 and also Backbone.js. Here is a sample of [Backbone and App42 Backend server.](http://blogs.shephertz.com/2013/09/10/backend-as-a-service-for-backbone-js-app42-cloud-apis/) May be this will help you. 
Thanks for this :)
Would be nice if you could support the most used shortcuts of other editor, like alt-5 and alt-6 to change indention of a whole selection of lines.
The scrollbar hiding/showing makes it really jumpy.
Life's a bitch...and then you fall down an exploding bridge. Seriously, how did the 5 year old version of myself make it across that bridge.
&gt; high order languages, and closures are nothing new to programming. They've been around since the 80's. Javascript is the first to mainstream them. Since the 1950's FTFY http://en.wikipedia.org/wiki/Lisp_%28programming_language%29
You say you are not yet entirely comfortable with concepts like partials/composition, so you should probably take baby steps - teach the bits you do understand and encourage exploration in the more advanced stuff. Map and filter are no-brainers, and understanding call and apply are obligatory for JS devs. I generally find it easier to understand patterns when I can see how I might use it for an actual problem - I struggled with OO for ages because of the generic Cats, Dogs, Animals examples that are used to demonstrated inheritance. With regards to partial/composition patterns, a primary motivation is to make functions simpler. The less arguments (and argument types) they accept, the easier it is to reason about their outcomes - to the point that they become interchangeable with their outputs. This also means that you are writing less code overall, which means less surface area for maintenance. You can see a lot of this in the D3 library, particularly in it's "range" api. Here's an example to make an email validation function: http://jsfiddle.net/sunwukung/YXUxK/ I love FP, it's kinda beautiful - but FP has limited scope in JS IMO, in part because of the limitations of it's type system. It helps you make simpler API's, but it comes at a cost in terms of performance and memory consumption, so you have to bear this in mind when building your application. Also, while each individual function is easy to get your head round, I find composed functions a little hairy to parse...
Partial functions allow you to create functions that are more specific than some very general function. For instance, you could specialize map to just return the ids in a collection, and name the resulting function get_ids. If you're commonly getting ids, it makes sense to want to use a function that doesn't require an anonymous function, and whose name clearly states what its doing. C and C++ did not have higher order functions or closures, at least until very recently (I've heard C++ has closures now) so I have no idea what you're talking about there. 
You didn't ask any questions or specifically mention what you wanted feedback on. It's not clear to me if you want feedback on your demo code, your library, your implementation of object pooling or object pooling in general. I think object pooling is a necessity if you can't afford to get screwed by the garbage collector. As for using a library for this purpose I'm not so sure. Tailoring your requirements to the library is likely as much work as doing it on your own.
ALRIGHT NO NEED TO SHOUT!
SORRY!
I love the irony of shouting about a speech recognition library...
voting down because already put up twice before this: http://www.reddit.com/r/javascript/comments/1m2la1/annyang_control_your_site_with_your_voice/ http://www.reddit.com/r/javascript/comments/1m92tu/annyangjs_voice_command_your_web_app/
This was posted here 20 hours ago...
i see nothing and my browser support WebGL edit: GET http://tweetmap.codevinsky.com/javascripts/underscore-min.map 404 (Not Found) 
Like the new name better! Told my friends and this looks pretty cool. Will definitely download it, try it out and report back on bugs / suggestions. Keep at it!
not sure the point of this - even more worried by the other tabs...
same here. the .map I'm guessing is a sourcemap so shouldn't effect it
indeed. what the hell?
I might be misunderstanding, but what part of [d3's range](https://github.com/mbostock/d3/blob/master/src/arrays/range.js) uses partial/composition patterns? 
Functionalish. I was trying to avoid debates with people claiming (correctly) that functional programming is about state, and that higher order functions and closures are features that exist within functional languages, but are not functional programming. 
Ah, my bad, I was just recalling from memory. Check out some of the scale and interpolation functions: https://github.com/mbostock/d3/blob/master/src/interpolate/number.js 
Please consider implementing [this view](http://www.mrdoob.com/#/146/html_editor). It's so good!
Array.map, filter and reduce etc have been in AS3 since Flash Player 9
What you are talking about is *partial function application*. *Partial functions* are a different thing; they're functions which are not defined for all possible values of the input arguments.
The Lisp world wasn't using lexical scope, and therefore closures, until the late 1970s, when Scheme was introduced by Steele and Sussman. So I'd say closures weren't invented/discovered until the 70s.
These are excellent points. Thank you. 
quotes don't bother me but I can see how not having them would be cool too, the different color and italics is enough. very nice! For me I'd actually use this on some rather large json strings we have here at work. Might be nice to read then the normal beautifier/formatter things I've used
nice! what are you using to render the html inside the app? edit: got an error: [http://i.imgur.com/4XcFCRU.png](http://i.imgur.com/4XcFCRU.png) here's what I did. * create new file * rename file to style.css * try and save file and error guess this editor only handles html and I have to edit my css externally?
Really nice. But it doesn't distinguish empty arrays ( *[ ]* ) from empty objects ( *{ }* ). That is kind of an issue for me.
I would rather loose some of that formatting (at least the italic -- makes it hard to read), and maybe keep the quotes.
It would be neat if the old content slid out as the new content slides in, or really any kind of transition at all besides instantaneously disappearing.
I've been in similar places before-- first teaching AS3 to Java people, then JS to Ruby people, and then JS to the AS3/Java team. I found the most success by scheduling regular sessions (frequency depending on urgency). I would bust out "JavaScript: The Good Parts" and "Functional JavaScript" and read it as book club. It also helps to not only be able to use map/reduce functions, but also understand how higher-order functions work. I would walk though writing a map function. Introduce them to underscoreJS, and demonstrate practical uses. Demonstrate functions returning functions and practical uses of those.
Property name column widths are inconsistent across multiple objects of the same "type" (ie, same set of properties). It'd be nice if property name column widths were "shink-to-fit" so they'd all align when rendering an array of objects of the same type. Add something like "width: 1px;padding-right: 10px;" to selector ".jh-object-key, .jh-array-key" to see what I'm talking about.
A couple of minor suggestions: - expand/collapse - display size of array next to its property name. Eg, "[5]" in a light font.
Thanks! I was trying to rework the date scale to work w/ only market dates last week and got stuck. I'll have to take another look at them keeping these ideas in mind.
I was kind of wondering/hoping that it would be editable and would generate JSON from modifications...
I don't find it that unreadable tbh.
I was thinking: td:first-of-type { width: 50px; padding: 3px 10px; font-size: 0.8em; text-align: right; }
@rhysbb follow me! there are plenty I have though: @addyosmani @aerotwist @alex_young @alphenic @angustweets @ariyahidayat @beep @bodil @brad_frost @BrendanEich @brianleroux @briantford @burkeholland @caolan @codepo8 @codylindley @cowboy @CrabDude @cramforce @creationix @csswizardry @dailyjs @danwrong @davglass @davidwalshblog @del_javascript @devongovett @domenic @drboolean @dshaw @ebidel @evil_trout @FremyCompany @getify @golike @grigs @hakimel @holman @html5hub @ifandelse @igstan @izs @jaffathecake @janl @jashkenas @javascript_news @JavaScriptDaily @jdalton @jedschmidt @jeresig @jlongster @johnkpaul @johnlindquist @jrburke @justinbmeyer @kangax @kitcambridge @kuvos @LeaVerou @littlecalculist @luk @maccaw @mahemoff @marak @markdalgleish @mathias @maxogden @mikeal @miksago @mislav @mjackson @mraleph @mrdoob @necolas @OliverCaldwell @paul_irish @Paul_Kinlan @peterc @petermichaux @phiggins @raganwald @rem @rhysbb @rioter @rmurphey @rnathias @rwaldron @sambreed @sethladd @sh1mmer @simpulton @sindresorhus @SlexAxton @slicknet @slightlylate @smashingmag @snookca @stoyanstefanov @stubbornella @substack @swannodette @tabatkins @tbranyen @thomasfuchs @tjholowaychuk @tlrobinson @tomdale @trodrigues @wilto @wycats @yaypie @zachleat I follow others but going through my list these are the people I remember having worthwile tweets
nothing is done with the user prompt. You also don't want the curly braces after Math.random() - it doesn't need to be a code block. Also you don't need to put "var" more than once.
http://jsfiddle.net/ is your friend when sharing code
Soon the world may invent XSLT for JSON.
Thank you so much. Edit: Derped out before
yup - just giving a few things that are wrong. It's a bit hard to fully debug unless you say exactly what "not working" means. Is there an error? are you getting the wrong output? "not working" never helps the person trying to help. Also it's be good if you put the code in something like http://jsfiddle.net/
Here's the syntax you're probably after... confirm("Welcome to Rock, Paper, and Scissors"); var userInput = prompt("Rock, Paper, or Scissors?"); var computerChoice; var mathRandom = Math.random(); if(mathRandom &lt; 0.34) { computerChoice = confirm("Rock"); } else if ( mathRandom &gt; 0.33 || mathRandom &lt; 0.67) { computerChoice = confirm("Paper"); } else { computerChoice = confirm("Scissors"); } Though, I'm not really sure why you are using `confirm("Rock"), etc...` rather than just assigning a value. You'd probably rather just set the value and `alert()` the computer's choice at the end instead.
 } else if ( mathRandom &gt; 0.33 || mathRandom &lt; 0.67) { If this statement is reached, it will always be true.
 computerChoice = 0.34 &gt; mathRandom ? confirm("Rock") : 0.33 &lt; mathRandom || 0.67 &gt; mathRandom ? confirm("Paper") : confirm("Scissors");
I found the output table to be even more unreadable.
This is actually really helpful for something I'm working on right now - the JSON that Google Docs Spreadsheets spits out can be an annoyance to check visually since you often only care about each feed.entry[x].title.$t and feed.entry[x].content.$t and nothing else, and that's only like 10% of the contents of the JSON they send. This makes it easy to quickly visually check the data without sorting through the extra crap. Good work, and thanks for sharing it!
I can't get it to work, is it just a json viewer? I really like this one: http://jsonviewer.stack.hu/
Nobody said it, so I'll say: **Indent your code!**
He probably meant to write &amp;&amp; instead of ||
why are you keeping the results in an array - it looks like you only take the last one when you call .value() I don't personally like chainable interfaces for this purpose, either return "this" or if a value comes back I prefer to build the function I want to use through currying/partial application. It also looks like you're jumping through a few hoops with things like Chainable.prototype. Also with things like this.[name] you're applying these functions to the instance and not the prototype. I'm guessing so that you can call any function that exists on the object. One thing I don't like is that functions need to have the "isChainable" check and have that dealt with differently. What you might want to do is have a check for all functions on the base object and set a different function on the wrapped instance that holds a reference to the function (as when you enter a "chain()" you'll only be calling methods that are chainable anyway). Also you may only want to evaluate the functions once the value is called - or not - depending on the use case
People have already linted it pretty thoroughly, but I saw a linked image, it had 1010+0101 and others like that, in the console, behaving in an unexpected fashion. I can shed light on that. In a bunch of languages, including JavaScript, a trailing 0 on a number with no decimal point and no digits 8 or above will be read by the language as an octal literal: 05,06,07,010,011,012... and so on.
I'm more of a fan of printing out my code, taking a snapshot of it with a polaroid, and faxing that polaroid to the people I need to share it with. I thought that's how everyone does it?
A ha! A ha A ha Aha! Figured it out! The main jsp just called a servlet with the form parameters. If I just use the servlet in my REST url, it looks like it does what I want it to directly!
Another option, if you wish to make this a text version - just convert the JSON to YAML and dump the YAML code. I've found YAML to be much more human readable.
Take a look at how [D3 does it](https://github.com/mbostock/d3/blob/master/src/layout/pie.js). 
Thank you for using the app and noting a bug. This is something I am currently working on fixing for the next version, so it should change in the newest version. 
I agree; however, node-webkit does not support shortcuts for mac yet, so I will have to wait to implement it.
awesome. It's pretty awesome. Especially good when you're building a new site from scratch. 
It looks like a cross between React and, I dunno, Knockback.js. Declaring tags programmatically with Backbone Models and data-binding. Aaand, we've hit full framework fatigue. It still looks somewhat interesting. But who cares? Everything that can be said within our current generation of frameworks has been said. But since I'll criticize anything once... It has a lot of gall calling what it does 'templating.' "Unifies templating of HTML, CSS and JS"--what does that even mean? I mean, I _know_ it's that OJ _thinks_ it's made HTML and CSS unnecessary, but misuse of the "template" concept is just one of many indicators that OJ has no concern for separation of concerns. 
Thanks. I actually just pushed the new version (0.0.3) that fixes that bug right now. You can get it by installing it from the site again. Enjoy.
Very cool. I'll look into that.
https://www.google.com/search?q=jsont
Okay, here's a question that's been nagging me for a while. What stops someone else from scanning your JS files, taking your Firebase URL, and posting their own data to it?
Can't you just use the CodeMirror keymap extensions? Speaking of that it would be very good if you integrate a bunch of CodeMirror theme and extensions. Is there anything technically blocking this? Also do you have a build script available to add to your github project?
Nice work, but tables are for tabular data. If your goal is human readability, you might want to transform into a more appropriate format. Nested ULs would be both more accessible and more semantically correct.
Fuck human beings - they are such an overused cliché. In project summaries too
It's best if you took some time to read some books or online tutorial on the generals of programming.
Yaah, that's a mess, editing for clarity,sorry
Damn. That is one helluva reading list you've got there. :)
The problem is highlighted here: http://imgur.com/ahbSS3v The first { highlighted should be changed to semicolon. The second one should be deleted. Notice your editor is helping you here - those braces are red. 
Thank you. Here's the issue for it https://github.com/karun012/bslider/issues/15. It's tagged with the first milestone. Will be fixed before first production release
Yeah, i corrected that later
Why are you accumulating all return values in `_results` when you are only ever accessing the last element of it? You could rename it to `_lastResult` and then simply override it. What you're doing now seems unnecessary.
Classes are for styling, so I would avoid selectors based on class. I think THAT should be a DON'T. I would also try to avoid magic stuff happening to elements that doesn't have directives on them. I'm not sure I completely agree with the author, though. I think it seems reasonable to have directives on "container" elements (like &lt;table&gt;, &lt;select&gt;, &lt;ul&gt; etc) that will trigger some changes on all children.
Hey, I figured it would take hours to check out all those names. So I took your handles and turned them in to a [nice list](http://pastedown.ctrl-c.us/#CQoIJ8UKkLaTgrsCrKn6-GcIhuQ.markdown) (will self-destruct in 7 days) with a tiny script
&gt; why are you keeping the results in an array - it looks like you only take the last one when you call .value() Chainable has a couple of other methods I omitted from the original post for brevity: this.values = function() { return _results; }; // process method values returned so far this.glimpse = function(fct) { if (fct) { fct(this.values()); } return this; }; &gt; if a value comes back I prefer to build the function I want to use through currying/partial application. That sounds interesting. Can you give me an example? &gt; It also looks like you're jumping through a few hoops with things like Chainable.prototype. It does feel like I'm jumping through hoops. That's one reason I felt compelled to seek feedback; I couldn't think of a simpler/cleaner approach for achieving the feature of toggling chained/unchained mode. However, I'm wondering if that feature is over-engineering and complicating the API in the interest of flexibility that has relatively low value. What do you think? &gt; One thing I don't like is that functions need to have the "isChainable" check and have that dealt with differently. Agreed. Would prefer a more generalized approach, but I'd like to avoid the overhead of duplicating function logic. &gt; What you might want to do is have a check for all functions on the base object and set a different function on the wrapped instance that holds a reference to the function (as when you enter a "chain()" you'll only be calling methods that are chainable anyway). Not sure what you mean here. Can you expand? What limitation is this meant to address? &gt; Also you may only want to evaluate the functions once the value is called - or not - depending on the use case. Interesting. I hadn't considered that as a possibility. Thanks for your thoughtful response.
And Contra... And Megaman... :'(
Your anecdotal "most people" is a cool story, bro. You are confusing something here While some coffeescript has less visible delimiters no curly brackets only whitespace this does not in fact make it any easier to read Significant whitespace opens the door for errors when someone confuses a tab with a space and then the meaning of the code changes due to invisible characters if you read this paragraph and you notice only spaces here one extra space is a period two extra spaces is a comma and three extra spaces are parentheses do you really think this makes it any easier to read No. The periods and commas that should be here are analogs for the curly brackets and parentheses in javascript. It gives an easy indication of where things begin and end and makes the meaning of the code unambiguous, and easy to comprehend because there is no ambiguity. Is it easy to spot the parentheses above? The placement of the period after the parentheses is ambiguous. I know this is not an exact correlation to how coffeescript uses significant whitespace, but this is meant to illustrate a point. When you read coffeescript, if you aren't completely sure of the exact meaning of a tab or a space, then you may not easily grasp what the code is supposed to do. It takes EXTRA WORK for someone reading the code for the first time to understand exactly what the code is supposed to do. With Javascript, there is no ambiguity at all, and the coder who is new to a project can read the code and be certain the first time they read it that they know what the code does. This should be totally obvious, but somehow coffeecritters just love their ambiguity. 
Uhm, awesome. X-post to /r/LearnJavaScript.
 &gt; It still looks somewhat interesting. But who cares? I care. I most likely won't use this library but it's an interesting idea worth exploring. I don't ever get tired of people proposing new ways of building software. Even the same way presented differently (better docs, community, whatever) can be valuable.
I actually quite like "on" and thought it was exemplary of concise and intuitive method naming. "On my cue, hit him on the head" maps quite nicely to `on(cue, smash.bind(him.head))` "Off" on the other hand did take some getting used to
I get what you're saying and I definitely wouldn't replace my whole setup with OJ (probably would never use OJ if I'm being honest) but as /u/radhruin said, I'm always interested to see new ways of doing things. It does remind me a lot of another JS -&gt; HTML framework I've seen (I'll throw it in here if I remember what it was called) but it's still kind of cool nonetheless.
Yes, if one needs that functionality JSON is definitely an improvement. But as I mentioned (or was is not clear enough?) the arrays I was dealing with contained _only_ numbers.
Question for the down voters: I'd like to know why you're voting this down. This is my first blog post and I'm aware that the content is nothing ground breaking. But still I'm curious. Feedback appreciated :)
You mentioned that. I was only mentioning a more bulletproof solution.
I find it pretty hard to navigate that website
... [React](http://facebook.github.io/react/)? 
There's a difference between exploring ideas and _fully_ exploring every idea that walks into your head. I explored OJ. I found: React and Knockback. 
You're a wizard. That's exactly what I was thinking of.
Submit them to /r/angularjs too
would the chain-able functions return something in relation to the input when not chaining? if not why have the wrapper seems like an unnecessary step
Thanks for the feedback, I added a few things yesterday, and it works well.
Interesting. My impression is that this is idiomatic old-school Backbone--that is, the state of affairs has moved on somewhat. Interrupt, having written the rest of this comment: this is _very_ old Backbone thought. For instance... * Using Underscore templates is like using only the installed apps on your smartphone.[1] * You can't get away with binding every change event to render for anything bigger than a ToDo or Contacts example app. I mean, it tells the whole app to re-render on every add and remove event. * Global namespacing for the app is definitely unfashionable nowadays, for better or worse. * His Router acts like a controller--more to the point, it's either operating on Views (which I've moved away from) or it's acting as an odd proxy to an API (with `'contacts/remove/:id': 'contactsRemove'`) * There's nothing here about subview rendering--there is an entire ecosystem of Backbone apps, Marionette perhaps being most prominent, to deal with managing layout and the subview hierarchy. [1] It's not just that, though; Underscore is basically nowhere near the controversial and highly important discussion on HTML templates. --- Actually, this is just weird: remove: function() { App.Browser.navigate('contacts/remove/' + this.model.get('id')); this.model.destroy(); } If you don't know why this is weird, you should be asking yourself why the [Router here](https://github.com/tlhunter/backbone-book/blob/master/scripts/router.js) doesn't try to delete that model _again_. There _is_ a safety check in the Router code (should that code run twice), but even so that Router code is _not_ called. Why? Because calling navigate only writes to the URL and browser history. If we want to trigger the Router code we have to pass either `{trigger:true}` or `true` as a second parameter. If you _still_ don't know why this is weird: we're duplicating the action of hitting the remove URL--that is, destroying the model. Suppose we get a bug report; suppose we have to call some user account action when a contact is deleted. We'll have to remember to call that action both here _and_ in the Router. There's actually a bug here already. When the route `/contacts/remove/:id`is hit directly, the Router calls a function on the View that redirects the page. But when you click "delete" on a contact, you will navigate to that URL for no reason and stay there. You can see him click through this _very_ scenario [right here](http://www.youtube.com/watch?v=j4SvBQk5rG8#t=1652), as he deletes a contact, staying at a URL, and then refreshes the page which triggers a redirect. --- Now the point of all this is that we've got a really uneasy abstraction going on with the url and browser history. I'm an advocate for sending _every_ url through the Router; having _every_ navigate trigger: true. Mostly this is because it **maintains** the validity of a Uniform Resource Locator. Your SPA should act the same at every URL, regardless of whether it was navigated to directly or arrived at within the App! Established practice [differs or is ambiguous](http://backbonejs.org/docs/backbone.html#section-181)--'not usually desirable.' In any case, this is a decent introduction to Backbone's basics, but not much more. 
Oh please. 
To give an update... Over the past couple of days I've migrated our codebase to use the Ember-Data 1.0 Beta API. And it definitely improves matters. 1) Transactions are gone (thank god), so there's that. 2) The state manager is still a pain to deal with, but we've written a bunch of code to overcome that so I'm not sure exactly how big of an issue that still is out of the box. 3) The API has been improved. Less magic. Simpler. *Far* easier to extend its behaviour. 4) Lots of broken stuff since it's still in beta... but (3) above means that it took only a day or two to replace the previous built-in functionality with our own. Overall I'm really excited about where Ember-Data's heading. Which is the first time I've thought so in a while.
Didn't work at all for me :/
I agree. When I write setters I always return this and it is much simpler than what you have going.
The issue has been fixed. It's also updated in the demo. Thanks!
The owner of this account has requested this content be removed by /u/GoodbyeWorldBot Visit /r/GoodbyeWorld for more information. GoodbyeWorldBot_v1.2
http://www.angularjs.org/ Not trolling, you'll seriously thank me later! Angular has the best parts of Backbone (dependency injection, MVC, routing, etc..) but with so much more! Two way data binding, inbuilt test suite, directives, etc... A joy to code with.
To be honest I don't see how this: myFunction(arg1, function(){ if (error) { console.log(error); } }); is any more readable than this: myFunction arg1, -&gt; if error console.log error
Can't read, too blurry.
Looks like I have bad CSS taste. Sorry about that. Removed.
I've used touch punch and jquery UI as well -- works better in iOS than android though for me...
Off topic, but I love the image!
I originally added some css to prevent this, but it looked not so good on mobile, so I decided to just go with it. 
That's right, both $.find and $.nodeFilter will correctly match _attributes_ having namespaces (you must escape the : ), for example: [find|nodeFilter].('a[xlink\\:href="http://www.w3.org"]')
https://github.com/bebraw/jswiki/wiki/Game-Engines
Thanks for the additional reply, my feelings were quite smooshed at the time. I'm glad I can at least code monkey well even if I'm an uncreative designer.
If you came up with it yourself you shouldn't be disheartened. That would mean that you are creative but that you need to spend a but more time reading and learning about things that have already been done. Use your creativity and craft skill to build on the shoulders of today's greatest :)
Looks great!
This was *REALLY* fun. Good luck!
Impact.js and Melon.js are pretty complete now. Phaser is pretty cool if you're at all familiar with Flixel in Flash and like TypeScript but has serious sound problems. Here's a more complete list depending on what you're looking for http://html5gameengine.com/
Thank you!
I like lychee.js https://github.com/martensms/lycheeJS
(Sorry for the late reply, I missed this). You're spot on. I've updated the article to fix these mistakes!
Am not convinced this is a good idea to implement. Say you make a function that accepts a nub object. You are not going to know what kind of result you will get from calling a method on nub and will have to surround all calls with: var value; if(isChainable(nub)) { value = nub.method('args').value(); } else { value = nub.method('args'); } 
Wow, that was extremely well executed. If OP is the creator, fantastic work! Very inspiring.
I'm not the creator but I'm friends with him - http://jackrugile.com/ . I'm stoked you enjoyed it so I know for certain he will be too.
Awesome! (I agree) :) I will pass on the good luck to my friend who made it -http://jackrugile.com/
Great! Uhh... What is it?
Like Underscore.js but much better.
How? Please elaborate. 
Awesome, very fun!
Its made by one guy, so is obviously better. Why would you doubt that?
https://github.com/angular/angular-seed &lt;-- Start all your apps with this! http://egghead.io/lessons http://code.angularjs.org/1.0.8/docs/api http://syntaxspectrum.com/ Have fun! :)
The author forked Underscore a while back, and then renamed it Lodash because he wanted to add/change things not in Underscore.
Still does not explain how its better?
It's a 100% underscore replacement, but faster and with extra useful functions. 
I know one controversial thing the underscore team did was support AMD/CommonJS loading and then took it away. https://github.com/jashkenas/underscore/commit/0d4b1247c45083c695cab4242c084a97aa600221#commitcomment-857644 
Yea, that's probably my biggest problem with this approach. I'd prefer Chainable not to be exposed in the API at all, but an inherent problem with implementing chaining in js seems to be that there's no native way to detect the end of a call chain. EDIT: I could probably do the end-of-chain detection with something like chain()(nub.id(13).name('foo')), but that syntax seems unwieldy to the point of almost negating the gains of chaining in the first place. Other ideas welcome...
That's amazing, the idea is quite unique and it looks great given that its only 1kB
lodash.com footer text: &gt; Lo-Dash by John-David Dalton, Blaine Bublitz, Kit Cambridge, &amp; Mathias Bynens
There is a whole community behind underscore, is been used for a long time. 
I'm currently working on a framework called Kran. It's not a game _engine_ - it's much smaller and simpler than that. It's an entity system micro-framework that provides a flexible architecture for game development. It's still under heavy development and not ready for prime-tme. But if you're curious you can take a look (there is an example game with crazy explosions and blood): https://github.com/paldepind/Kran Feedback greatly appreciated.
Dem Magic numbers... This is the most impressive piece of code I have ever seen.
fixed :) https://github.com/marianoguerra/json.human.js/issues/8
that's the idea
an object can be seen as a table where keys are on the first column and values as the second. arrays could be ul/ol, I will think about that.
seems it could be. it recalls the ruby quine that looks similar 
done! :) https://github.com/marianoguerra/json.human.js/issues/6
it's on the roadmap
which browser? do you have js enabled?
Quote from the pong tutorial: &gt; The move algorithm is the same as for the AI, so we just copy that to the update() method. Sounds to me like the architecture has some problems with reusing code. Copy-pasting should never be necessary. Besides that I have to say it looks _very_ impressive!
This looks incredibly much like something I'm cooking up myself right now. I can even recognize your design decisions, because I went with some of the same, while I scrapped others. From what I can see in the code, the only real difference is that I pool components and entities to avoid garbage collection.
Check my todo. I'm planning on pooling objects too &gt;.&lt; Oh well. Is your code online? I don't know how far you are with your project. But I'll be happy to accept contributions or if you'd like to share any ideas, opinions or feedback on my design.
Tried createjs, simple and good enough especially if you are familiar with flash.
http://stackoverflow.com/questions/13789618/differences-between-lodash-and-underscore
Too lazy to read the project's main page? https://github.com/lodash/lodash
If you're just getting started, the best engine is no engine. A lot of the frameworks out there are really leaky abstractions over a simple API. They can be extremely useful, but generally only once you understand the underlying technology. The base canvas/audio/input APIs are very easy to learn and work with and it's honestly about 10 lines of JS to set up a basic render loop. Start there with a simple game, and go from there slowly increasing complexity. When it is time for a library, you will know and you will be well equipped to understand what they are abstracting for you and in a general sense, how they are providing that abstraction. A lot of the higher-level frameworks boast the ability to throw together a basic game in 10 minutes. That makes for some nice demos, but it doesn't give you much of a real foundation. All you'll learn is how to use their exact framework.
The list is https://twitter.com/frontendrescue/cool-people/members I follow a lot of them but not all. I usually have a look at their profile and my rules are something along the lines of: - must tweet something relevant in the past two weeks - must be at least 50% about JavaScript/CSS (not all personal tweets about where they are or what they're eating) - must be likely to tweet something that someone else I already follow won't 
You could make this a bit more general by using a memoize function. I'm going to pretend we have underscore - though the functions are simple and can be easily done. So to do things in a functional manner: var arrayToUniq = _.compose(_.memoize(_.uniq), arrayToString); *edit* got the functions out of order. The array as a string should be passed in to the memoized uniq function
Lo-Dash is a library of useful functions. There is a build that can be used as a drop in replacement for the popular underscore library which describes itself as a "utility-belt" or as someone else once said "the bow tie to jQuery's tux". other Lo-Dash builds provide extra functionality and a couple of the functions may operate slightly differently (which may arguably be the way they're "meant" to work). The focus of Lo-Dash has always been on speed with solid testing, so it may be faster than underscore by orders of magnitude in some cases. 
Hooray! It's got the debounce optimization I proposed in my [blog post](http://modernjavascript.blogspot.com/2013/08/building-better-debounce.html) along with many others https://github.com/lodash/lodash#noteable-changes this is going straight in
Okay, so from looking at underscore it is like a data structure library?
That sounds incredible cool! The pause on one device, continue on another idea on the website sounds mega sweet. Anyway, the major reason why I picked on the copy/paste thing is because I'm currently working on [Kran](https://github.com/paldepind/Kran) which makes such kind of reusing trivial. Have you considered an entity system for your engine?
It's more of a "functional library". It basically gives you utility functions that are handy. So for instance it gives you things like "map", "reduce", "filter" etc. that when it came out were not native to JavaScript. The functions that it gives are split up on it's site http://underscorejs.org/ in to what type of things it takes as an argument.
/r/tinycode would love this by the way. 
"readable" does not always mean less text to look at. If that were the case then ppl wdnt h8 txt msgs. See what I did there? Less typing does not mean it is easy to understand. But we are talking about programming, and in the context of programming the first example gives much more structure and area of the function is clearly shown with a curly-bracket. There is nothing to guess at here. The mind does not need to do any extra steps to understand the meaning, because it is clearly shown. That is not the case with the second example. The second example looks open-ended. This is a very simple function and it no doubt is easier to understand than a larger function. If the function were, say, 50 lines then it would not be so easy to understand. The start and the end of the function would not be so easy to see. When I'm working with 10 or 20 other programmers, and I have to debug their code, I don't want my mind to have to do extra work just to understand where the functions start and end. I want the original programmer to have included curly brackets to make everyone's job easier. Javascript syntax is much more precise, and easier to comprehend. I would rather not have to figure out where code blocks start and end. Coding in coffeescript makes it more difficult for others to read your work. I don't care if it saved you a few keystrokes, you will pay for that down the road with developer frustration, ambiguity, and difficult debugging. No thank you. 
Well, if you pass a different type, then users of that object can reasonably expect it to behave differently: var chainableNub = makeChainable(nub); chainableNub.chain('method1','args').chain('method2','args').value(); That way nubs have nub-like methods, and chainableNubs do chaining on nub-like methods. And the amount of surprise is reduced. 
there's a whole competition and prize ... http://js1k.com/ you submit the best animation/thing you can do with JavaScript having only 1k of space avaialbe .... some people make incredible stuff using only 1k :) damn EX: A FUCKING 3D CHRISTMAS TREE WITH SNOW, LEAVES ... http://js1k.com/2010-xmas/demo/856
Magic.
Damn, that's some really impressive unreadable code.
Why not just use browserify at that point? (If you don't even need the lazy loading features in production)? 
I actually think this would be really useful if it converted JSON in an editable form with input fields displayed like this. Would be helpful in admin panels and such where you can edit JSON. Would be nice for the non-technical user to edit and not break the JSON formatting.
I don't know if I could have written a more convoluted piece of demonstration code if I tried... still, I didn't write a demo, so I can't complain too much. This code doesn't seem to demonstrate the most significant piece of the new arrow-binding syntax, the way that 'this' is bound, which is a significant departure from how anonymous functions work. The essence is that 'this' as used in arrow functions is the same as the 'this' from the calling context, always. In the long run, having different 'this' behavior for arrow-functions (why aren't they called lambdas?) than anonymous functions could cause confusion. The arrow function behavior is more how I would expect an OO language to function, rather than a functional language. In any case, 'this' binding is one of the most difficult-to-grasp parts of JS, so maybe this is positive... ?
Publishing every function as its own NPM module is cool: https://npmjs.org/search?q=lodash The creators of NPM always deride "grab-bag" modules like lodash or async. "Do one thing, do it well."
The build system you're talking about. Does is parse the code or how does it work? Replacing what rendering backend is used at run-time is very cool. I've looked a bit more at lychee and it's _very_ impressive! It's obviously much more ambiguous than Kran (I kinda like that tough). Just the fact that it can build Debian packages etc. is freaking cool! But I don't think we're talking about the same kind of components. Consider for instance the 10 lines of code from your pong tutorial that you copy pasted. Basically what they do is that they take a _thing_ that has a position, a target and a velocity. It then modifies the velocity so the position will move closer to the target. In entity system terms we have a _system_ that operates on an _entity_ with three _components_. The one-dimensional position and target component would look like this in Kran (this is using the shorthand syntax for components with just one property): position = component("y") target = component("y") The velocity pretty much the same velocity = component("size") The system would look something like this: system({ components: [position, target, velocity], function(pos, target, vel) { if (target.y &gt; pos.y + 10) { // do stuff vel.size = 100 } } } And then we'd simply add and initialize the components to the AI and the player when appropriate ai.add(pos, 50).target(1000).vel(100) Then when running the systems in the main loop all velocities will automatically be adjusted probably. So we get to share code between the AI and the player super easily - without having to setup an inheritance chain. No unscaleable copy pasting either. With an entity system sharing "methods" is so easy that you'd never have to copy paste - not even to make a tutorial simpler since it's already as simple as it gets. I hope my explanation clarifies things :) Thanks _a lot_ for your feedback on my library. You're without a doubt much more experienced than me at such things so I highly appreciate it! How do you think I could make use of valueOf() and toString()? I don't have any vectors ;) The link you gave was very interesting. I did not now about that technique. I actually have two kinds of event bindings in Kran but I'm guessing you're talking about the one for global events: Kran.trigger(). The nice thing about it is that it hooks into DOM events meaning there's no difference between listening for your own global events and browser events like "mousemove". What I don't like about it is that it relies on strings (garbage) and creating a CustomEvent object (more garbage) but I can't see a way to integrate with DOM events. Also my events are very different from yours. You simply call a callback while I need to integrate the events with my "functions" (systems).
That is one unreadable shitfest of a code.
&gt;Nice work, but tables are for tabular data. So many people that repeat this nonsense forget that "some things are actually (or are well represented as) tabular data." This is one of those cases.
I've updated the example in the readme on GitHub with one showing how to do gravity (I was actually considering replacing the previous example with such an example anyway). For a demonstration on how to do collision detection check out the demo game - it features simple collision detection between circles. I also now libraries like Box2D has been integrated into other entity systems in the past. [Here is the link](http://blog.gemserk.com/2012/02/02/how-we-use-box2d-with-artemis/) to what I was thinking about. I don't know how your other problem would be solved in an entity system, but I'd imagine there's a way. One can kinda "back out" of the entity system if one wants to and just do a bunch of thing in one single system. I've tried changing the properties on the CustomEvent object but they appear to be read only so there is unfortunately no way to reuse them :( That's at least one problem you don't have besides the other advantages :) I read your link and I do understand how the fake ops work. I can see how it could be useful for adding vector addition support. But my library doesn't deal with vectors.
"First, let's download the Engine." Nope.
No real reason. Was comfortable with require.js and r.js, and that worked out pretty well. I havent used browserify so I cant say if this goes for that as well, but r.js can be used out of the box with has.js for feature testing, and using that for custom builds, for different clients.
Ok, well, I disagree. I don't think a table structure is a good map for objects. And I don't think "tables are for tabular data" is nonsense either. But, you know, that's just, like, my opinion, man.
For some reason I found this code fascinating in a sickening kind of way. I believe the author has invented a new dialect of JavaScript/ECMAScript, worthy of a name of its own: Jrainfuck. I had to find out how this code actually works. First, the original Jrainfuck ([fiddle](http://jsfiddle.net/m6f69/)): ((index, prime) =&gt; {while(index &lt;= prime) { document.body.appendChild(document.createTextNode(index+' =&gt; ')); document.body.appendChild( document.createTextNode((((index, prime) =&gt; ( index &gt;= prime ? index=&gt;index : (index, prime, num) =&gt; (index &lt;= prime / 2 ? num : prime - num))( index, prime, ((index, prime) =&gt; Math.pow(index, 2) % prime)(index, prime) ))(index,prime)))); index++; document.body.appendChild(document.createElement('br')); }})(0, 1031); Let's indent that like normal code, with no other changes to start with. There are many styles of indentation, so the point here is to have *some* kind of indentation ([fiddle](http://jsfiddle.net/m6f69/1/)): ( ( index, prime ) =&gt; { while( index &lt;= prime ) { document.body.appendChild( document.createTextNode( index + ' =&gt; ' ) ); document.body.appendChild( document.createTextNode( ( ( ( index, prime ) =&gt; ( index &gt;= prime ? index =&gt; index : ( index, prime, num ) =&gt; ( index &lt;= prime / 2 ? num : prime - num ) )( index, prime, ( ( index, prime ) =&gt; Math.pow(index, 2) % prime )( index, prime ) ) )( index, prime ) ) ) ); index++; document.body.appendChild( document.createElement('br') ); } } )( 0, 1031 ); First thing to do is break out those repeated `appendChild`/`createTextNode`/`createElement` calls into functions of their own. We can also break out the main function as a named function for a bit more clarity. We'll stick with arrow functions ([fiddle](http://jsfiddle.net/m6f69/4/)): var logText = ( text ) =&gt; { document.body.appendChild( document.createTextNode( text ) ); }; var logElement = ( tagName ) =&gt; { document.body.appendChild( document.createElement( tagName ) ); }; var run = ( index, prime ) =&gt; { while( index &lt;= prime ) { logText( index + ' =&gt; ' ); logText( ( ( index, prime ) =&gt; ( index &gt;= prime ? index =&gt; index : ( index, prime, num ) =&gt; ( index &lt;= prime / 2 ? num : prime - num ) )( index, prime, ( ( index, prime ) =&gt; Math.pow( index, 2 ) % prime )( index, prime ) ) )( index, prime ) ); index++; logElement( 'br' ); } }; run( 0, 1031 ); Now there are all those other inner functions. We can pull those out as separate functions too. Naturally it would be good to give these functions descriptive names, but I don't know what the code does, so I'll just give them names like `f1`, `f2`, etc. for now ([fiddle](http://jsfiddle.net/m6f69/6/)): var logText = ( text ) =&gt; { document.body.appendChild( document.createTextNode( text ) ); }; var logElement = ( tagName ) =&gt; { document.body.appendChild( document.createElement( tagName ) ); }; var identity = ( x ) =&gt; x; var f1 = ( index, prime, num ) =&gt; index &lt;= prime / 2 ? num : prime - num; var f2 = ( index, prime ) =&gt; Math.pow( index, 2 ) % prime; var f3 = ( index, prime ) =&gt; { var f = index &gt;= prime ? identity : f1; return f( index, prime, f2( index, prime ) ); }; var run = ( index, prime ) =&gt; { while( index &lt;= prime ) { logText( index + ' =&gt; ' ); logText( f3( index, prime ) ); index++; logElement( 'br' ); } }; run( 0, 1031 ); Of course as stillnotworking points out in another comment, none of the code uses `this`, so you could use ordinary functions instead of arrow functions ([fiddle](http://jsfiddle.net/m6f69/7/)): function logText( text ) { document.body.appendChild( document.createTextNode( text ) ); } function logElement( tagName ) { document.body.appendChild( document.createElement( tagName ) ); } function identity( x ) { return x; } function f1( index, prime, num ) { return index &lt;= prime / 2 ? num : prime - num; } function f2( index, prime ) { return Math.pow( index, 2 ) % prime; } function f3( index, prime ) { var f = index &gt;= prime ? identity : f1; return f( index, prime, f2( index, prime ) ); } function run( index, prime ) { while( index &lt;= prime ) { logText( index + ' =&gt; ' ); logText( f3( index, prime ) ); index++; logElement( 'br' ); } } run( 0, 1031 ); And now it will run in most any browser, not just Firefox. Either way, this version or the one before it should be a bit easier to understand than the original!
This looks awesome but I'm wary of installing some random Node on my box. Am I being overly paranoid? Has anyone browsed the code to this? Sorry in advance for being a Don Downer.
node.js is very common and widely used, you don't have to worry. In fact, you need it for things like PhoneGap and stuff. It's pretty well known.
Sorry Don, you're paranoid. :) From [Node's README](https://npmjs.org/doc/README.html) regarding working with npm, particularly with `sudo`: &gt; npm will downgrade permissions if it's root before running any build scripts that package authors specified So packages are safe, even if you're using `sudo npm install -g something`. You have nothing to worry about, install like crazy.
This is kickass and also hurts my head. Can we get it running [one of those JS Linux implementations](http://bellard.org/jslinux/)?
The initial idea behind that statement was to get people away from using the table tag for doing layout. This. I agreed with from an idealistic standpoint. At the time it was first being parroted throughout the design community, it had a lot of practical issues. Browser support for float, etc. was spotty and unreliable to the point that people were writing some pretty nasty and awful code simply to avoid the embarrassment of having used tables. As it stands now: yeah, don't use tables for layout. CSS can handle whatever you need (only caveat: relative height is still a bit nasty, but pretty doable.) What I still think is nonsense, however, is people who avoid the `table` tag when it does make sense. If what you are making is a grid of repeating homogenous data organized into rows and columns, then a table is very much what you should be using. For this example? I think it's a nice representation. A tree seems more closely married to the underlying data structure, but the UI would not be nearly as conducive to showing the results in a clear and concise manner. If you've got a better idea for visualizing json data, I'm sure that everyone would love to hear it. 
Uh, no idea. But I forgot to mention that PhantomJS has to be installed and available in the PATH environment variable (typing "phantomjs" in a terminal should start phantomjs).
Would be neat as a backend for the collaboration feature on Plunker. 
Nice tip, thanks! 
I don't think what you're describing is possible. The browser doesn't have that kind of access to your filesystem. Grunt is heavily reliant on server-side Nodejs.
Author here. If there's any doubts / feedback you have, or any way you see I can improve the README / docs, please let me know :)
To be fair, that offers zero protection against rm -rf .
9Kb vs sammy.js's 79Kb... Lightweight is an understatement! Just had to implement some js routing at work, gonna roll this in tomorrow and see how it goes.
Beautiful!
are you asking for this? https://github.com/vladikoff/grunt-devtools
I bet. I hope it doesn't get that much bigger as you add on to it. It looks like it supports wildcard routes? That is something I've been longing for in routers and had to implement on my own through regex. Good work. I'll keep an eye on this.
Grunt's terrible anyway.
How is it terrible?
A few things off the top of my head: * You have to have grunt-cli installed globally, *and* grunt installed locally. wtf? * The method names are long and crappy * You spend a whole bunch of space configuring all these plugins in this obnoxiously declarative matter, even when declarative doesn't really make much sense The saving grace of grunt is its selection of plugins. It's annoying to use as a consumer, painful to use as a plugin author, but there's a reasonable chance someone wrote a plugin to do the thing you need. Personally, I'm a make kinda person. Yes, I know significant \t is bad. But not as bad as grunt. **EDIT:** Grunt's like the only time I'll write coffeescript in a javascript app, because then at least I can pretend it's bizarro yaml.
First, good job and congrats for finishing your thesis! I've been building apps using Phantom.js for awhile now so I know this is a very sizable effort. Beside that, the use case is unclear to me (but I guess it doesn't matter for educational topic). May I make a suggestion? How about tune this toward the Amazon Mechnical Turk model where there is some economic for repetitive human interaction on the web. Of course, they can do it on their browser but what if it's for a "authenticated page" or an "internal secured environment". Allowing external access through just the page for repetitive tasks would be best. Of course, I am not talking about things that Phantom.js itself can automate. How about scenario for UX testing where human must read or see images, etc...? You get the idea...
I think he's talking about [learnyounode](http://nodeschool.io/#learn-you-node) not [Node.js](http://www.nodejs.org) itself.
You might like Jake, then.
Yeah! That actually a good idea. I didn't occur to me but you're right. What I'm doing is pretty much a memorization.
It's not online yet, but I expect to push something to bitbucket later this week. As with yours, it's still very much a work in progress. Also, my example game is circle-based... :-P I can give you a pm when I publish the code.
Well, with anonymous functions _this_ is bound to the global object. You _never_ want that. I think the behavior of the array functions is clearly better. What exactly do you mean when you say that this behavior is not how you'd expect a functional language to function? I'm pretty sure, if it wasn't for backwards functionality they'd also change it so that this inside anonymous functions got properly bound. 
Will it work with marionette? 
**Bonsai** (http://bonsaijs.org) Bonsai's main features include: - Architecturally separated runner and renderer - iFrame, Worker and Node running contexts - Paths - Assets (Audio, Video, Images, Fonts, SubMovies) - Keyframe and time based animations (easing functions too) - Path morphing - and much more...
&gt; You have to have grunt-cli installed globally, and grunt installed locally. wtf? &gt; Makes sense for me, then you can have different Grunt versions for different projects. And if you don't like that, you should look up [npm link](https://npmjs.org/doc/link.html). 
Looks awesome, ive actually been looking for something like this ever since I started making websocket applications. I could never find a hosting provider that allowed any sort of websocket integration without it costing the earth. Looks like its also got a ton of supported languages, do you think you could look into Dart too (:P)? If not I understand why (Especially since there is javascript there already).
Thanks :) This is just an example I made up taking out things from my project mostly because as you said building with Phantom is not really straight forward, even more so if you try to use it for different purposes than the usual ones (web scraping, testing, ..). The actual master thesis focuses on building an infrastructure that allows creating cross device mashups at the UI layer, in a simple and fast way (without having to code anything). Clients can connect, create mashups, add components (web pages), select elements from those web pages, add inter-component communication, move things around easily with drag and drop, .. With something like this, you can for instance add a wiki component, a flickr component and a google search component, then link them together and use small devices (smartphone, tablet) to host a search bar, and finally show the search results on a large screen.. another example is taking a "single user" website and sharing it with others, effectively transforming it into a collaborative website (for instance you could open a sudoku website, and play it with others, heh). I need to think about more useful scenarios, but the project is done and I still have 1 and a half months left to write the thesis ;) 
| I want two-way binding only, but I'm forced to take the whole framework. There is too much overhead for me. Been there, done that. That's how laces.js was born: https://github.com/arendjr/laces.js ;) /shameless plug
What does it entail to set up something like this on your own server, does anyone know? It seems strange to need accounts if it's just a few API files or libs - so it's probably more than that?
It depends a bit on what kind of server software you want, but Node.js running the socket.io module is a very popular and proven solution that takes away much of the pain surrounding WebSockets. And it being Node.js it is relatively easy to build your custom app logic. Then you need to find a hosting solution that hosts Node.js and allows WebSockets: most but not all allow it, and some are weirdly Restrictive with sockets and maximum connection limit, so you need to scout around for best deal. There are some alternative modules that can do WebSockets, and other based server tech: even PHP can do it if configured correctly (using something like Ratchet). If WebSockets are a core of your project you'd want to run and manage the server yourself for maximum power and less artifical rate limits, but if you just need a splash of WebSockets as an addon then a service like OP's is of course very easy.
Do you need full duplex (both client to server and server to client realtime) or just one-way push (server to client)? If you only need server to client, you could consider using Server-Sent Events (EventSource) rather than WebSockets. Server-Sent Events are more widely supported than WebSockets both in terms of browser support, and server-side support. They use regular HTTP (as opposed to web sockets, which are a totally different protocol).
Its very easy to set Pusher up on your own server. Yes you have to add some api files, but otherwise setting up a channel and binding/triggering events is easy. I would imagine the reason for having accounts is that if two people use the same channel named "pusher-channel" the difference in API ID/key/secret will help tease apart any events fired on the channel.
&gt; Grunt's terrible anyway. I think you meant something like: "I personally don't like grunt" Nuance and shit.
tl;dr: use the right tool for each job! :) &gt; .. may be trendy now, but not necessarily in a few years' time. A few years is a long, LONG time in web technology: obviously some history of bug fixes and testing is a good thing but I think it is not realistic to require years and years of stability. It depends on what you use it for and how long that has to keep working and evolving.
Bad demo. Those who are interested in ES6 style arrow functions but can't wait for browsers to catch up should try TypeScript. It works really great with ES6 style `class`-es: TypeScript favours those (over vanilla prototypes) and thanks to the arrow functions and their scoped `this` you can easily work with callbacks while using an Object Oriented style (no more `var self = this` cruft to get scope variables).
Nobody can predict the future but history helps here. A simple and focused framework tends to last longer than heavy and complex. 
As some background, I found [Reflections on nodejs malware](http://www.webinos.org/blog/2013/06/17/reflections-on-nodejs-malware/), which looks into how it's totally possible for malicious code to be propagated through npm (and other package managers) but why it usually doesn't happen. You can look up the npm module by name on the npm repository website to find out more about it - [learnyounode](https://npmjs.org/package/learnyounode). This gives you a reference to the module maintainer [rvagg](https://npmjs.org/~rvagg) (whose page has a link to their email address, blog, and several other npm modules they are also maintainers of... so probably not a fake account just to host malware... but still no guarantee...) and also a link to the [github repo of the module](https://github.com/rvagg/learnyounode). You can look at the [package.json](https://github.com/rvagg/learnyounode/blob/master/package.json) of the module to see if it references any scripts (it doesn't, but it does list some dependencies). You can look at the [source of the module itself](https://github.com/rvagg/learnyounode/blob/master/learnyounode.js) which is really short - #!/usr/bin/env node const Workshopper = require('workshopper') , path = require('path') Workshopper({ name : 'learnyounode' , title : 'LEARN YOU THE NODE.JS FOR MUCH WIN!' , appDir : __dirname }).init() Unfortunately, it's basically just instantiating *another* project made by the same maintainer and referenced in the package.json - [workshopper](https://npmjs.org/package/workshopper) which appears to be a framework for running these tutorials on the command-line. You would then repeat the above process for this module and all other modules listed in learnyounode's package.json (*and* in all those module's package.json files ad infinitum), but I will leave that as an exercise for the reader.
You're awesome. Thanks for the detailed reply. :)
The thing I don't like about this and other collection plugins is they're usually a "read only" proxy. If you've got a sufficiently complex application this can cause all sorts of problems as really what you're trying to do is pass through the collection with all it's functionality that was added. I wrote https://github.com/rhysbrettbowen/Backbone.CollectionFilter and the whole point is that it acts like an actual proxy so you can add models to it (and thus the original collection) and call any functionality that you had mixed in on that. This means you can pass a module that expects this functionality and act on it without even having to know that it is filtered
If you're really worried about size then why even use jQuery? Have a look at PlastronJS (http://todomvc.com/labs/architecture-examples/plastronjs/) the todomvc example is 43kb TOTAL - That includes all the cross browser stuff, templates, binding, your code, etc, etc. That's 17kb gzipped across the wire. It works because it's based on Closure Tools and can be compiled with Closure Compiler in Advanced Mode (meaning it will get rid of all the cruft you don't need and then go ahead and make everything even smaller).
I would rather take KnockoutJS.
If you can't do 'node ./file.js', you've failed.
No, I meant what I said. I'll give many projects the benefit of the doubt, but grunt isn't one of them.
I like the sentiment, but I'm not sure those sizes really matter. Angular is 91k. Who cares. I think I've downloaded larger favicons. 
Considering the move to trimmed down and focused web servers (NodeJS/MSFT's Project Katana), specialized document DBs, bare metal linux OS distros, and the resurgence of C++, that logic is perfectly sound. Powerful frameworks are awesome. I love jQuery and .Net, and you'll have to pay me serious dough before I move off Windows. That being said, there is still very much a place for streamlined processes and trimming away superfluous frameworks. Hardware is not getting much faster, our server and mobile needs are getting bigger, and bandwidth is still increasing at an incredibly slow pace compared to the rest of technology. Hand waving away all this away in the name of developer productivity is itself the silly logic in my opinion.
It's not about download speed. It's about code maintenance. Less code is easier to handle.
Right, I wanted to avoid that complexity as it didn't fit my use case when I originally wrote these, but there's nothing about the design that means it couldn't be added. I agree that it could be very useful. I had somehow missed Backbone.CollectionFilter in the alternative libraries part of the readme. It's now added Also, I found your blog a couple of days ago and really enjoyed it. I especially liked your post on a better debounce. I'm currently working on series of blog posts explaining Angus Croll's mixin strategy, and how it can be used with Backbone.Advice :) Q: Would you be open to some pull requests on Backbone.Advice for things like a UMD wrapper and a package.json / bower.json?
http://imgs.xkcd.com/comics/standards.png replace "standard" with "framework" and this comic is incredibly relevant to our field, haha
Exactly right, and considering the massive growth of mobile internet access, it really does begin to matter. 
It's more about the parsing, according to tests google did in 2011[1], 1kb of js takes about 1ms to parse on mobile devices. So that's potentially ~100ms of latency the OP would be adding to every request by using angular. Not a huge deal but when your app has to be embedded in other pages every little bit counts. [1] https://developers.google.com/speed/docs/best-practices/mobile
Sounds a lot like long polling...
Another vote for knockout...if you mostly need 2-way binding it is what you want to use...also its size (~17kb minified) is *tiny*... It does what it does well, and sticks within its domain of concerns. It is very performant and I especially love how it handles long/complex dependency chains.
&gt;Amazon found every 100ms of latency cost them 1% in sales. Google found an extra .5 seconds in search page generation time dropped traffic by 20%. A broker could lose $4 million in revenues per millisecond if their electronic trading platform is 5 milliseconds behind the competition. http://highscalability.com/blog/2009/7/25/latency-is-everywhere-and-it-costs-you-sales-how-to-crush-it.html There's a reason why CDNs are so incredibly popular, why things like SPDY are becoming so popular, and why people bend over backwards to optimize for sizes. Sure people have huge favicons, but people do lots of stupid things, that's hardly an argument. Google maps even saw a 10% increase in traffic from a mere 20kb decrease in size. These things do matter. 
It's quite similar to using a "forever iframe" except error handling is much easier and the browser handles reconnecting in case of connection problems. The server sends data which the client fires as standard DOM events which you use `addEventListener` to listen for. I wrote something recently that uses server-sent events but falls back to a forever iframe for older browsers. Any server designed to handle the [C10K problem](http://en.wikipedia.org/wiki/C10k_problem) (like Nginx, Cherokee or Lighttpd) can handle this with no problems at all.
&gt; when you want a really responsive marketing site you want to keep it lean If you wanted a fast, responsive site, why would you be looking to JS at all? Render on the server, cache everything, serve static and compressed HTML and images.
I don't have a problem with anyone using a framework if they know what they are choosing and could have rolled their own instead. I do have a problem with people glomming onto x-framework and not understanding what JavaScript/DOM/the-architecture really is and how it works. 
As far as the animation goes, and the overall package, is it made for 2 dimensional games?
Did this page make anyone else's CPU spike through the roof? I thought there was a jet taking off of my desk.
&gt;When starting to design an API I always want to start from scratch. Just a clean table, a pen, and paper. I'm thinking about the API and the end user only. No frameworks are present at this point. ... This API becomes the Model in MVC, in a form of "Plain Old JavaScript Object" (POJO). What? The API should not be an implementation, it should be a contract for how your client and server communicate. Given said contract, I should be able to write my own client in Javascript or C or Brainfuck--as long as it pushes the right bits in the right order down the pipe to your server, it's compliant. Here it sounds like you're describing not an API but a reference implementation.
I think knockout should have at least been mentioned in this article. Learning curve is low, size is low and it does data binding well. I think with angular and ember you need alot of time to get your head around them. I do like how moot design their own controllers and do their own MVC. I need to read up on the Resig micro templating
&gt;Less code is easier to handle. ... &gt;The combined size of all the UI views and controllers (the glue between API and views) is just 40kb when minified. How much would that be with a framework? But you never answered this question. What if I told you that with Angular the answer to this question is "750 bytes"--did you actually discover the answer to this question to prove me wrong? The thing is, at least *some* of the 40kb worth of code you wrote replicates what Angular/Ember/Backbone already do. The only way for a framework to increase the total amount of code you have to personally maintain is if it's so poorly designed that not only do you have to write more glue code, you have to write *so much* more that it outsizes the redundant parts of the frameworks you're rewriting. None of the frameworks you identified are that poorly designed.
This was a pretty sweet talk.
Why spend the money on servers when the clients computer can do it. 
Yes, many people do. And Moot is also loaded from CDN. That's just one part of the minimalist equation. But we mostly care about code maintenance, quick release cycles and lack of boilerplate code. We strongly prefer our own way of structuring things. Apart from a custom event library there is virtually no framework code.
Or at least help maintain a popular open source framework.
They dont work for you because you really just wanted to write everything from scratch and get that "i'm better than everyone else" feeling.
Uh... Moot is a single page app.
There is no new framework in Moot. 
I don't buy it. It's embedded comments. You've got all the time the user's reading the article to run your non-blocking script. I know it takes me a lot more than a tenth of a second to read an article.
How about Backbone.Picky?
If your argument is about code maintenance, then I would venture to say that you should've kept looking for a framework that fit your needs. Using a framework doesn't mean having to maintain that framework, it means being able to offload a subset of your requirements and maintenance **onto** that framework. In other words, pick the right tool for the job and think less about having to do that job. In your article you state you wanted primarily data binding for UI...did you look into [KnockoutJS](http://knockoutjs.com/)? It is incredibly tiny (17kb minified, smaller gzipped) and very nice to work with... Also, another argument for using a framework is that they likely have already figured out a lot of problems and fixed edge-case scenarios that you would otherwise run into trying to solve the same problems.
Wow. Kinda like Maya's DAG nodes for Three.js.
I didn't re-write any of the features on those frameworks. There is very little framework code in Moot, it's mostly just application code. And yes, it feels pretty good. 
By all means, do what feels comfortable, but I have been through every stage of JavaScript code organization and can say that the path you are going down is going to become a bit awkward as your code base grows. Sometimes what feels good in the beginning will become unwieldy in the future and that is why so many expert JS devs have come up with the frameworks you mentioned from experience and making a 99% common solution everyone can adapt their problem space to. Consider taking the best parts from angular, backbone, and ember at least and adapting it to your framework. I would highly recommend using AMD and a class based approach to your modules as a starting point.
As an author of jQuery Tools and Head JS (among others), I've seen a few things here and there. I know quite a bit about Angular, Ember and Backbone too. I wrote the article based on all this knowledge. 
Does moot not support &lt;IE9?
Looking forward to checking out moot when it's released.
Not actually sure. I'm pretty sure you can make it work, but it might be tricky. I'll take a look at it later tonight.
With long polling XDomainRequest
Moot is currently in beta but we already have thousands of forums in production. You can setup one yourself from https://moot.it/setup/ The beta tag will be removed once the API is public and importer is ready. 
I'm...not exactly sure what your attacking here. Your essentially agreeing with my premise that NodeJS and Owin have use cases that frameworks are excessive form, and the you'll always find people misusing patterns or software. As courtneycouch mentions, there a number of high profile sites that implement these alternate data storage solutions quite successfully. In regards my Linux comment, yes, you'll probably have some hyper-visor solution, but inside those virtual machines you'll find everything from an OS that is barely more than a modified linux kernel to full blown server OS's. The hyper-visor solution itself can wildly vary. Again, framework when you need it, trim, purpose built solutions when you don't. . &gt; &gt;&gt; resurgence of C++ &gt; &gt;Has nothing to do with anything but the recent release of C++11. The release of C++11 and the upcoming C++14 are certainty contributing, but there are a number of other factors at play here. I'm not exactly sure why you're targeting this point. Sorry for the comma abuse
Redis alone is an incredibly versatile tool. You can use it as a robust caching solution, you can use it as a (psuedo) message bus with pub/sub. Mongo has it's uses, but the uses are more targeted. It's not the golden hammer that MySQL/Oracle/MS-SQL is. 
Sounds like it's just fine for your use case: data loss isn't catastrophic, your writes are mostly appends, you don't have to worry too much about maintaining relational consistency, and you generally don't have to do a lot of complex marshaling queries. While on the other hand, you were very much worried about performance. Most document DB implementations are just trying to sub out Mongo for MySQL in-place, because hey, Mongo Is Web Scale. Then suddenly they realize, shit, I'm having all these problems with consistency and persistence and replication and querying and joining and... Better write up our own transaction manager to make things ACID again. And then all of a sudden it's slower than MySQL ever was. Hell, I work on one of those in my day job. We use CouchDB and it was the worst choice we could possibly have made for our use case, but the choice was made years ago before I even came here and I'm a drudge, so whatcha gonna do. There are use cases for these things, but most people who choose to use them don't actually understand those use cases.
Seems a bit slow in generating, but it's impressive.
What methods do you use to make parsing (not downloading) of javascript a non-blocking operation ?
Here you go! http://github.hubspot.com/vex/
Sweet tech, but it suffers from the same problem most FBP tools suffer: finicky UX in the graph editor.
Why does it constantly change the title to show that some random user is typing in a comment? It's completely obnoxious if I'm there to read the article.
Don't hotlink to github, it detects it and quickly stops connections. Host it yourself. Everything the page tries to load fails connection, so it doesn't even slightly work.
Huh? Seems to work for me. http://github.hubspot.com/vex/js/vex.dialog.js 
I'd personally never replace `alert`, `confirm` or `prompt` with a custom dialog. Nothing will beat the native implementation of the browser. I mean, who else has a better knowledge of the device it's running in? Be it a tablet, smartphone, giant screen, whatever. I can do without the custom styling for these three cases (just those). Apart from that, it's visually beautiful (although the mobile version only shows one example?).
Direct linking works. Hotlinking in that page does not.
I could get using the built in version on mobile, but the native desktop alert and confirm dialogs are pretty visually terrible.
Excellent. Im only just getting my head around it so this might not make sense but say there are lots of records like 10,000 will the pagination pull them all out and just apply the pagination client side? Related to that if it is only pulling up records per page does the sort and filter refresh the query on the server side. 
It's totally fucked for me in Chrome 30.0.1599.14 dev Edit: I looked at it properly. The Ghostery extension thinks hubspot are some sort of nefarious organisation.
It's completely broken in Safari 6.0.5, FYI.
Here's one: https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers You could just as easily iframe the component if you're worried about old browsers.
On Chrome with the (font size: Large) setting, the text in the demo runs outside of the boxes.
Screenshot? Stack trace?
is that *coffeescript* in the docs?
i think its fine if people want to develop their own framework. More choices the better, that's what's so great about open source.
It matters for mobile.
You may want to use this if you're already using Bootstrap: http://bootboxjs.com
The demo is a sequence of popup dialog windows, with a forward arrow to go from one to the next, but no back arrow to go back to the one you just came from. If you miss something, you have to go through the whole set and start over. Usability fail.
Weight is only relatively important. Popular libraries are most probably already cached, especially if loaded through a CDN.
If you want any sort of animation you generally need js to cater for ie8 
Well... 1) Why would you do that? 2) Doesn't framework size fly right out the window at that point? It's like trying to get CSS3 into IE6. You can do it but there's no longer a semblance of lightweightness or speed. Unnecessary niceties have a cost, be it in performance or page weight or browser compatibility. Like [my reply to someone else](https://pay.reddit.com/r/javascript/comments/1mkaw1/why_angular_ember_or_backbone_dont_work_for_us/ccafggd?context=2), I don't quite see the argument.
Yep, vex lets you specify the classes attached to the dialogs, so just specify whichever Bootstrap classes you'd like.
Yep, do you find it difficult to follow?
Yep, it's just a quick demo to give you an idea of what's possible. Sorry you had trouble.
Just because you need `&lt;?php echo $user['name'] ?&gt;` doesn't mean you can't cache the shit out of the page and let a few lines of JS + cookies handle bits like that.
In the documentation page (Home), when a dialog is open, the page jump-scrolls to the top (bad usability). At first I thought that it was by default, but in the "Vex Dialog" page when they are opened, they don't scroll to the top. And there is no indicator in the docs as to how the scroll to top is set. Another thing: if you use coffeescript (or whatever), and want to show how it's done in the docs, at least present the javascript code too (not all people use transcompilers, myself included).
Is the demo supposed to ignore your attempts to close it and advance to the next dialog example each time you click the X? Cause that's happening to me in Firefox 23 and IE 10 on Windows.
Doesn't work for me in Chrome due to Ghostery thinking it's analytics. It thinks that the JavaScript is "HubSpot / Analytics". When I enable that it works again.
[Is this the problem for you?](http://www.reddit.com/r/javascript/comments/1ml9jk/vex_beautiful_functional_dialogs_in_javascript/ccagfom)
Not /u/utuxia but that would be difficult for me. These two quotes sum up my feelings on the matter. &gt;Every CoffeeScript developer knows JavaScript. The inverse is not true. - Tom Dale &gt;[Posting CoffeeScript in [documentation] strikes me as presumptuous.](http://gaslight.co/blog/does-coffeescript-have-a-future) - Joel Turnbull 
Hehe, when you click the (X) it does the same thing as the next button. Take that users. 
I actually completely disagree. Most native implementations look like shit and lack any flexibility whatsoever while also blocking all execution. Also, when you have a completely unique, but consistent custom UI, why would you let those items be inconsistent? It seems to me this inconsistency would be bad for usability/UX especially with the notion of progressive enhancement where you can easily fall back to the native implementations...
Haha. Exactly. Another person who doesn't appreciate the beauty if JavaScript. 
The scroll-to-the-top behavior you noticed was a bug in the docs. It's now fixed. Thanks for letting us know!
There's an issue on Safari, where the primary button is white until you click in the popup, at which point it appears.
What do you mean?
My best guess is that it's a rather specific need you filled that's not very likely to be applicable to most people. So perhaps folks are underwhelmed by the reuse value. 
On the client?
This is only applicable when you have the entire collection client-side. If you have to query the backend, then that problem is a lot harder and specific to the backend implementation. I know that Backbone.Paginator https://github.com/backbone-paginator/backbone.paginator tries to solve this for pagination, where it will map the current pagination state to query parameters, but I don't know if anyone has tried to solve it for filtering / sorting, or if you could come up with a generic solution there.
just use ruby.
stringify is surprisingly fast for this: http://jsperf.com/faking-associative-array-with-indexof The indexof approach is the only one guaranteed to work with any object, including functions, but it's unsurprisingly slower, although perhaps not enough to be unusable in every scenario. WeakMap. soon. 
It's a hotlink to HubSpot, not GitHub.
Interesting, for curiosities sake, I'd like to see Backbone + Marionette in there; although I'm not convinced TodoMVC alone is enough to pick a framework because its just way to simple to see how it will scale to a real application. That being said, I found TodoMVC very good when first looking at a few
Nice. Only as others has pointed out, it would be good to replace that coffeescript with vanilla javascript, so everybody can follow it. Does it support loading content from server (ajax)? I find this has a lot of potential, "just" fix those problems people are pointing out and this can be really powerful.
That's why I limited my answer to just those three (alert, confirm and prompt).
That made me feel slightly insulted in the smarts. What's wrong with plain JavaScript?
This will only work for random values &gt; 0xFFFFF, save for those between 0x100 and 0xfff, otherwise the preceding zeroes will be missing. The smalles working variant of a random hex color generator I know of is function(e){e=2&lt;&lt;23;e+=(0|Math.random()*e);return'#'+e.toString(16).slice(1)} 
have you considered mobile at all? Most of the binding frameworks do late binding as well, which means parsing templates on the client, inspecting dom, all of this is crap on mobiles. 
Nothing is wrong with plain JavaScript :)
Are you talking about Angular's codebase not scaling from experience? I have myself worked on atleast 3 codebases ( all in the range of 10k LOC ) and I would say that it does scale pretty well. I dont see it becoming a nightmare even if each of these scales to 100k. I have an application organization that scales pretty well ( based on angular's modules! ) .
Thanks for the feedback. The Closure example actually makes use of functions included in the Closure library, just like the jQuery and Dojo examples use functions provided by the respective libraries. All 3 of them are not MVC frameworks, that's right. The article should probably clarify this. What is compared are the implementations not the libraries, so why apples and pears? Are you sure there is no quality control in the TodoMVC project? Certainly the implementations are written by different people, but someone has to at least control, whether they have all the features needed. While that does not imply quality control, I wouldn't rule out that people, who are part of the project, actually care about the quality too. As mentioned in the summary generalizing these results doesn't make sense and comparing more complex applications would be interesting, but I don't know of a similar project that could be used for that purpose.
How does this compare to Raphael? Just curious.
yes from experience. our products tend to be 50-&gt;150k loc 
Ah, didn't think of that. I never encountered that problem before, as I work primarily with responsive websites, not full web apps, and few background actions take place (all of them can wait). I think most of the web apps are intended for desktop use, which negates my argument. If you need your website to work on mobile, tablets, or any other device you don't know about, I still think one must rely on the native options. Btw, as another argument, in Android you can use the "go back" button to close the dialog, whereas with a custom implementation you'd need to start messing with the history api (I guess).
Can you expand upon that? How does it fail to scale?
On quality control: I think it is up to the individual authors to control the quality. Since every second nathan barley has a web framework I would imagine this is a self controlling system. Unfortunately google gives a rats ass about what people think of closure, they are not in the game of marketing it. Apples and Pears in that you compare fully fledged frameworks to vanilla systems. You need to split that up, perhaps even cycle into the complexity of the underlying frameworks since complex problems require deeper analysis and debugging. Also, you need to find some way to bring in things like static analysis in your consideration. On large code basis it is invaluable.
I still think that comparing applications that use a library/framework or not is a valid approach, as long as it is the same type of application with the same feature set. This is not a comparison of the frameworks themselves, library code was removed before running the complexityReport tool.
Would be amazing if you can explain how it fails to scale. Though I have not worked on any projects that are 50k-150k LOC, we have precedent in Double Click and HBO's app which I think are both in that range. 
Well I'm used to javascript, so a little, yes. 
I haven't used svg.js, but if it's significant that you're using SVG, Raphael gets limiting pretty quick. It offers a bunch of convenience functions and is great for putting stuff together that will degrade well, but limited path support and (what seemed to me) bass-ackwards event binding get in the way for trickier stuff.
Ok, so let me try a different tack with my point. If you consider a code generator, then according to your complexity measurement the code complexity will be near 0. however debugging it will be quite difficult. Something I also just thought off, how do you consider the complexity which is introduced through the templates.
I agree that omitting the templates hides part of the complexity. Moreover, I do not claim that the metrics applied cover the topic of code complexity comprehensively. Also, as mentioned in the article, the size and complexity of the Todo app are both fairly low and larger more complex applications may present a different picture. Nonetheless, there are simple applications too in the real world and when starting a project getting things done quickly may be more important than having a robust foundation that scales up to millions of users.
&gt;&gt;I agree that omitting the templates hides part of the complexity. this is my apples vs pears crux. perhaps do a complexity analysis where other libraries are not "axcluded". The other thing I think you should consider is including the value of static analysis in your system.
Looks great. I'd drop the Hubspot tracking because of Ghostery, but it looks really nice. Thanks.
Awesome round-up
That would be the security Chrome has with it. If you run it on an SSL site, it will only ask for permission once. If not, it will ask for permission every time it starts listening. If you run it locally (ie file:/// URL), it won't work at all.
Thanks!
latency? 
Cool. It would be nice to have the exact pixel position of the guides displayed somehow when you mouse over them. Maybe even show relative guide position (relative to the nearest left/right guides or top/down guides).
Unreal Engine is 25 MB in JavaScript, and 5 mb gzipped? That's a lot of JavaScript but not that crazy. I've produced Flash games that are a lot less complex but still reached few megs of code-only SWFs (that is compressed bytecode that runs in the high-level plugin environment). But what is the problem here? When so many sites use huge high-res background images and everybody is streaming HD video all over the place. What is worse is what you do with the 25 MB of Unreal Engine. It will need hundred or thousands of megabytes of textures, models and all those other resources to actually make it run a game: that is where the real problem will be.
Hell yeah it is... my buddy and I just wrote a real time q&amp;a platform with this combo. It's amazing the things you can do. Firebase is going to change the way web apps are written. www.flawk.to =)
_See also: /r/tinycode_
An alternative to Firebase is [GoInstant](https://goinstant.com/). It's SAAS though, which can be a pro or con depending on your use. For mocking crap up, its nice not having to set anything up server side.
While there are some really marvellous minification tricks possible, some of them do have a negative performance impact while others make the code virtually undebug- and -maintainable. Abusing coercion is usually a good way to decrease performance, but usually saves some space. On the other hand, using the JS subset called asm.js leads rarely to smaller, but rather to faster, rather optimized code. If you want to learn more about byte-saving tricks, see https://github.com/jed/140bytes/wiki/Byte-saving-techniques
It's actually Ghostery blocking all hubspot.com domains, so we can't load the vex script itself.
Yep, the perils of being a marketing company. Shouldn't cause any trouble for users of the library though.
You should not be trying to show off your product in a context where it's broken on the demo site. It may be the best damn dialogue in the universe, but you're losing a huge percentage of the people who would use it when they come to the site and it's broken. I'm also seeing broken functionality, probably due to Ghostery. I was interested enough to pop open the console to check for javascript errors, but just pull out the offending code and have a demo site that will "wow" people. 
asm.js also requires a minimum 10 char tax. Namely: "use asm"\n
This is lovely and all, but what does it have to do with Javascript? I'm fully aware of what it is and I've linked it as a mirror when sites go down across reddit.
Best way to minimize: 1. Rely on libraries for all common tasks. 2. Get your libraries from a CDN (e.g. google). 3. Use UglifyJS, Closure Compiler, ... for what's left. Hand minification is a nice time waster but nothing you want in production. PNG loaders are awesome as a hack but who would want to rely on them? JSCrush and friends require the code to be unpacked every time and are too slow for larger chunks of code.
Since im working on a tool like this at the moment .. im quite curious as too what the UX problems are that you (and /u/fwsmacguy) mention? I was quite pleased with the interface and have slowly started to move my UX in this tool's direction..
This is a really good article. I'm not sure I agree with the emphasis on single page apps, tho. We've had great success using backbone as a web component foundation in our multi-page site.
whats the benefit of firebase over a vps?, it seems they charge a lot more and offer less power, what's the catch? is it their api?
Oh, it certainly could be worse. Here is a list of stuff that could be better (loosely ranked from basic stuff to crazy new features): The hitarea of the connection-points is too small here. It is difficult to disconnect/break connections. I want to be able to drag-slice to cut one or multiple connections (visual like a razor). The Output and Input connection-points should each have slightly different UX behaviour: if you drag from an already connected Input your should not create a new connection but instead move the current connection: this because an Input should only allow ONE incoming connection, while an Output can have multiple outgoing ones. I want to be able to quickly select parts of the graph and move them about: using the standard convention of shift/ctrl-click and/or mouse-drag selections. Copy-paste like stuff with some cleverness in how it handles connections outside the selection and where to paste and/or-re-layout nodes. I'd go for a background grid (like 10 or 20 px) with node-snapping, and for tight look also have all nodes be multiples of that size and the connection-points should also be nicely spaced. This is extra awesome with smart layout features that use this same size for spacing. Do this right for very organised looking graphs. Then some tools to line-up/ stagger/grid/column/row groups of nodes. Some intelligence in how the connections influence these auto-layouts, with minimal crossing or weird lines. (this is non-trivial to do right) A group-feature: bundle sub-graphs into own objects, add visual cue (background/border etc) and pull their external connections to the outside of that box, and allow to visually collapse the whole grouped sub-graph into a single abstract node (so it takes a lot less space), and allow to scope-in to edit in the group and then scope-out again to view the main graph again. This should support recursion (group-in-group-in-group) Take the group feature further and put the blue-print for the sub-graph into a local library (like a 'symbol' or 'class') so you can make instances of them. Then also allow to break-apart those instances so you can change them , and then of course you could regroup them as a new type.
I don't have firebase but I imagine the benefit is not having to think about or manage the backend/database, as well as not having to write anything but browser code...its a convenience/ease of use thing...
Awesome, thanks for the thorough write-up! These are all really good remarks, enjoy your upvote and the knowledge you helped a poor code monkey knock the ball out of the park.
&amp;gt;Oh pplease FTFYFF
12px font size for the body copy?! Are you serious? Please take this into consideration: body { font: 100%/1.475 Georgia, "Times New Roman", Times, serif }
YES! I've wanted to search for something like this to read tonight, and you just delivered it. Kudos to you. 
Cool: we expect you post it when it is ready! :)
sumerian.io is a JavaScript SPA (Single Page Application) development suite with an MV* (MVC, MVVM, and MVVMC) framework in Gilgamesh, a companion framework in Bitumen, a microtemplating engine in Uruk, and a Gilgamesh application optimizer in Ziggurat. This suite empowers frontend developers with the ability to build powerful applications that are robust, structured, and fast. 
It's possible http://opalrb.org/
Fixed
Thanks! Hope you enjoy it! I'll have to grab the link for part II from the author when I have more time. Pretty good stuff.
Access permissions are one of the biggest unsolved problems with the client side apps in my mind. There is an impedance mismatch between the state of code running on the client and the code running on the server. The client doesn't have things like the request-response process, which is the most obvious place to put in access checks. You almost have to run multiple parallel access check systems to handle the different environments (ie: do i show the button that will hit a endpoint which it doesn't have access for). And to make it more complex there's a whole bunch of permission checking that can never happen on the client (does a user with this email already exist?). 
Man, I just became aware of Firebase -yesterday- and have been having a blast with it. I was tempted to write a similar blog post to this one. 
see also: http://semver-ftw.org/
lel meemz!
Thank you!
This is a great point which I have run into as well. How have you dealt with Role based applications with a RESTful backend? 
I've got to agree with the gist of the other issues raised here. TodoMVC is not intended to be an example of best practices / scalability / maintainability, etc. It is just a common app, done simply, as an example. You are measuring work that is not intended to be measured for quality. And in so doing, are implying judgments on the frameworks that may not be accurate. Now what would be interesting would be to use your measurement to quantify exactly how much effort is needed to just "build an app" vs building a high-quality scalable, maintainable app. I suspect the differences in LOE between those two would show the true long-term value of frameworks. 
I wonder how vLine compares to other vendors like TokBox, etc.
Multi-media design is a class offered. 
We don't learn advance stuff like this there though! 
But... Mr. Johnson is there
You've said too much 
i guess that's right, but the cheapest firebase plan costs $50 dllrs a month, digital ocean offers a vps with twice the specs for $5 dllrs a month, is avoiding writing a code similar to firebase really worth the 45 dllrs a month difference?
We've spent a lot of time making a robust, scalable backend that is distributed across the world for low-latency. We've also put a lot of work into making sure that calls [connect under complex firewall situations](http://blog.vline.com/post/52644825765/tunneling-webrtc-over-tcp-and-why-it-matters). Also, our API provides higher-level constructs such as [presence, text-chat, and UI "widgets"](https://vline.com/faq).
Sorry for the unhelpful comment. I had a proper look, and it was the later-reported issue around Ghostery.
There's nothing more infuriating than trying to debug some crappy jQuery plugin that has been minimized.
 100 requests | 539 KB transferred | 13.85 s (load: 11.01 s, DOMContentLoaded: 10.86 s) :D
I used it at a hackathon last year, winning best use of the color green with [this](http://green.shoffing.com/). It's multiplayer, find a friend or open it in a second window or something. Got a full year of Linode for it. Good stuff.
Thanks man! Let me know if it works out for you, and if you end up using it, please star it so I know it's actually useful to people!
Really well done, definitely going to use this. I like the spinner as well (that it's programmatic).
Thanks for reminding me. It can be configured so it never gets inserted into the DOM, but I neglected to put this in the README. I'll do that now. Thanks!
Well I learned a new one from that. Never knew you could use functionality in arguments.
Firebase isn't a VPS, its basically a backend that's setup for you, and all that is necessary to use it is client-side JavaScript instead of having to write any serve code, meaning that you could potentially host a real time database integrated webapp on a static server.
I don't really like the major.minor.patch system, but at this point, I guess I'm resigned to it. Having a consistent system is probably more important than my feeling of revulsion at seeing "numbers" like "1.0.0-x.7.z.92". So, +1 for at least *having* a spec for people to work from.
I actually came across an older site that implemented huffman encoding (a very standard method of compression) and creates a self-extracting javascript source. I plugged jquery minimized into it and it went from 93K to I believe 88K, and its not a well built implementation. Granted, compressing javascript on the client side is somewhat pointless as gzip will make the filesize larger when the HTTP server tries to do a pass-through.
There's also Tint, it supports &lt;10.7 MacOSX but doesn't support linux.
Yeah the initial page load is a little brutal.. haven't really optimized anything yet. A normal use case only requires that you hit a new page any time you join or leave a session, and you won't be doing that all so much... but yeah need to speed that up =) Thanks for hitting it.
Thanks for feedback, good point about guide positions. I've implemented that, guide position is displayed while dragging and on mouse over.
The biggest problem with Firebase is searching data / queries. Using URLs as the backbone for data schema means that there's a lot of client side normalization required in order to make even pretty basic search functionality. There's the primary key as well but again outside of some very basic stuff it's not really a great solution. I get the sense that they mostly want to develop a system which is great for sequential data (where you can simply limit to data within a certain timeframe). If they added more robust search/indexing I would be using Firebase as my main BaaS. The other problem is the bandwidth - because I can't really limit how much data I pull each time I found even really basic operations seemed to consume a LOT more data than I expected.
&gt; TodoMVC is not intended to be an example of best practices / scalability / maintainability, etc. that's right &gt; You are measuring work that is not intended to be measured for quality. Would you only measure software that is written with the intention to be measured for quality? That's a pretty weird argument. Moreover, there are [contribution guidelines](https://github.com/tastejs/todomvc/blob/gh-pages/contributing.md) for TodoMVC and there is a *lab phase* for new implementations. So there is some kind of quality control in this project, probably more than what is done in many professional companies.
What's not to like about it :) ?
if the width goes over 100 in chrome it splits the width line into two
Thanks for feedback. Fixed
I could write an essay on the subject, but my own experience with several large software projects is that actually determining whether a new version is a "patch" or "minor" version is very difficult. Once you get over a certain size and number of clients using the API, it's impossible to predict what you can change that won't break some implicit dependency someone has on your implementation. OS projects run into this all the time - "minor" updates that break existing applications, because they optimize something, or remove an unintended side effect, and some app only worked because that bug was there. Back in the day, I tended to use major.minor, with the difference that I would sort 4.10 before 4.9 (i.e. in decimal value order). And I typically used 4.00 to 4.99 before moving on to 5.0. The implicit contract in this case is slightly simpler than in the Semantic Versioning system - if you start with some version 4.x, you *should* be able to upgrade to any other 4.x without any changes. If you want to upgrade to 5.x, then it's likely some rewrites would be necessary.
Thanks, that makes some sense. I have had a few occasions in my OS work where I got bitten by a patch-level update that did change some behaviours I accidentally relied on, like changing tolerance for bad input. What is sad in OS modules is how everybody seems to be scared of moving from 0.x.x to 1.x.x and they perpetually hang around in the low 0.x.x-levels. I rarely see something above 1.x.x. Even node.js itself is stuck at 0.x for ages now. Also for many users there is the misplaced concept floating around that 2.0.0 is more reliable then 1.10.33, because it looks 'newer', while according to the spec it would have major changes, and the x.0.0 tells us it hasn't received any fixes at all, while the messy looking 1.10.33 might be more robust has actually received many updates and fixes for its supposedly stable api version. But then, it's all human work, so I'm glad people are at least trying.
It's nearly impossible to use effectively without api documentation and it seems like it doesn't really support inheritance and you need to write a lot more than whats necessary to create a new entity. Also two of the code examples are missing ending brackets and all are missing semicolons.
&gt; Do you even lint bro?
Thank you for this. This is really comprehensive. Even though I've used backbone before I feel I've learned more from reading this article.
The lack of ceilings on bandwidth and connections worries me too. There is also the problem of connections being opened for every on() call, and the documentation for security has no reference to limiting clients or banning clients based on IP address. The closest thing to decent security I can find is requiring authentication, allowing your domain as an allowable origin, and using a reverse proxy such as nginx to monitor IP addresses. There seems to be the possibility to generate and use security tokens though so I'll have to take a look into that, but I don't know that the facilities exist to enforce a unique token per connection, supply a unique token for each authenticated user and drop all other connections that don't use the active and authenticated token. Another alternative is to force users to pay for their accounts but that's not feasible for all content types. I mean, my idea would have no concurrency except for 4 days of the month in which concurrency could hit 5,000+. Definitely not worth over $800/month.
In this regard their security rules can prevent a lot of this kind of abuse. It's the metered overages that are concerning, in my opinion.
Nice work, but doesn't the Array randomizer used to generate the initial board create unsolvable start positions 50% of the time? http://en.wikipedia.org/wiki/15_puzzle#Solvability
I was about to say the same thing. I wrote one of these in Visual Basic back when I was starting out programming as a hobby. I took this into account, so my shuffle function started out with a clean slate and just made a metric ass-ton of random moves. Easiest method of shuffling a 15 Puzzle IMO. I should note that a Rubik's Cube has a similar solvability problem, but far worse. 50% unsolvability would be a dream. That said, this is a good looking implementation. 
The PATCH number is so superfluous here. Increase MAJOR if it breaks compatibility, increase MINOR if it doesn't.
I don't really think he should be responsible for making sure it works with every single third party extension that someone might use. If you use ghostery, you know it sometimes breaks things, add an exception and enjoy the demo
Soo.. does that mean I can't solve http://imgur.com/K5nljs5 ?
You'r example of a problem in OOP doesn't really apply to JavaScript tho since you can just make it inherit the one it most resembles and overwrite the functions/properties that don't match by adding them to the prototype of EvilTree. On the subject of writing more you have misunderstood me, you could write something like this: function Foobar(x, y, v1, v2, weight) { this.x = x; this.y = y; this.v1 = v1; this.v2 = v2; this.weight = weight; } new Foobar(4, 4, 3, 10, 12); instead of: entity().add(position, 4, 4).add(velocity, 3, 10).add(weight, 12)
Don't work.
You're right. Current implementation is 50/50 solvable, though it's possible to produce only solvable board positions using the algorithm described at [Wolfram Mathworld](http://mathworld.wolfram.com/15Puzzle.html). I'm going to implement that.
Just did: http://ngmodules.org/modules/angular-loading-bar. Thanks for the suggestion!
358 moves :)
Yes you could do that, but that whould be cumbersome and you wouldn't be reusing code. Entity systems on the other hand completely removes the problem. And yes, you could define foobar that way - but that's more typing exactly as I said and on top of that you wouldn't get the other benefits an entity systems offer through systems. It's not that OOP can't do what an entity system can it just does less flexible and with more hoops. Anyway, I suggest you search for entity systems - there's a lot of well written articles about it. 
I accidentally ~~whole bottle of coke~~ fifteen puzzle first time in my life in [180 moves](http://dl.dropboxusercontent.com/u/4301006/Screenshots/8a.png)
I really appreciate the use of a component/entity system. Even though it's not entirely necessary in the prototypical paradigm, it's a very welcomed organizing method. I'm going to give this a try!
i LOVE IT
Why do you think it's less necessary in prototype OO? I don't think it makes a difference whether you're inheriting from classes or from prototypes. If you have any questions or requests don't hesitate to ask! Edit: I forgot to thank you for giving it a try :-) 
I've actually been heavily working on a FFI implementation bound to a vanilla V8 implementation. C wrappers are almost exactly the same as what you describe, you can either define a function with its signature and library, place/remove pointers from heap, define structs and use typedef. It uses libffi to do the majority of hte FFI work. It currently compiles and works on macosx, windows, iphone (with some cavieats) and android. At this point i'm finishing up bindings to objective-c (macosx/iphone), c# (windows) and using marshaling techniques that exist in those you can dynamically wrap C++. End result? With a dynamic library you pass in the path, a header (or just the symbols to extract) and it will create all of the wrapper classes/objects to play with it. It's a dangerous endeavor as it becomes increasingly easy (especially in C++ marshalling) to leave around tons of memory leaks so i'd doubt it would be for the average JS user. But, i've been able to recreate all of the functionality of nodejs and added quite a bit of new functionality with windowing/opengl/webkit bindings. Best part? It's 2.8MB when compiled with /Os in xcode, very very small memory footprint, and dead simple to add features quickly, it can even load up nodejs modules since they're just another dynamic library.
nice! I spent a while googleing before starting and only found crappy implementations. Obviously didn't look hard enough.
Sam Loyd's unsolvable 15-puzzle, with tiles 14 and 15 exchanged. This puzzle is provably not solvable because moving it to the solved state would require a change of the invariant. 
What are the rules? The wikipedia page nor the Github repo actually simply state what the rules are.
So, do you have a solver? Cause I hate 15 piece puzzles and want them to go away forever.
Really? Wu.js pretty much has the standard curry implementation now. It was mentioned in the underscore you're doing it wrong talk.
192
That's really awesome. I'm familiar with Artemis -the java library- which is very cool, that's great to have a similar thing in js. Keep it up!
http://puu.sh/4vowF.jpg 
http://imgur.com/ArLrWze It's on, lets see if we can get under 50 Edit: down to 100 now
The trick is plan the bottom row while you're still doing the 3rd row, or even the 2nd. I'm still stuck at 100, got it like 3 times now, but never 99.
$(".moves_bg").innerHTML = 49 I think making a real solver to do it in fewer moves will be harder than actually doing it
BTW one of the main reasons I posted this is we are looking for contributors. If you're interested, hit me up; all are welcome.
tutorial?
Really well done and fun to boot! You might consider reordering the games. The second is the most difficult and the last is the easiest IMO. Keep it up. 
Thanks a lot :) Indeed this is like a sister project to Artemis. Thanks for your comment!
A+++++ very informative post! On a more serious note, from the reddit faq: &gt;**Why don't my submissions show up on the New page?** &gt;reddit has a spam filter designed to detect spam posts and automatically remove them. However, legitimate posts are often caught by the filter. If a few minutes go by and your post isn't showing up on the new page of the community where you posted, it has probably been caught by the filter. This is most likely to occur if you are posting to a community that you have not participated in before. Each community has an independent filter, for example /r/help's filter doesn't talk to /r/pic's filter. In order to remove your post from the filter you need to message the moderators (this link can be found in the sidebar on the right-hand in that community, you can also manually compose a message to #communityname) and ask them to check the filter for you. Eventually the filter will "learn" that your posts don't need to be removed.
seems like a less developed http://postscapes.com/node-js-microcontroller-tessel
Yes, I think so too. Never mind, that's how Reddit works...
This is the sort of thing I would love to write as a 1-off ... using libraries takes the fun out of everything.
Is it possible to download these in one big swoop from anywhere?
You don't *need* a framework. Even more, never try to go applying design patterns just because you saw it somewhere. And also don't try to follow someone else's architecture if you don't fully understand it. Instead, my advice would be a small number of general and simple rules: - Focus on *doing it*, on finishing it. Focus on this above other considerations. Worry about doing it *better* later. I get you're doing this to learn, right? Well, you'll learn mch more walking the path than wondering if there is some other better path you might have followed. - Go for simple and well understood. If something feels confusing, either dive into it until you get it or simply don't use it. If something feels complex, you're probably better off doing something simpler (at least until you encounter some problem that suggests your simple solution is not good enough). - For general architectural practices, just take this one: separate unrelated things, and abstract repetition away when you find it. Following this path, you will probably reach some of those design patterns at some point, and you may find you reached the proposed solution (yay!) or that you now understand the whys and hows of the proposed solution and why it is better than yours (yay! too) - If you can, find a mentor, or at least someone who is willing to help you and does have the experience. (Better if it is in person, of course.) This one is not easy, but... it can help a lot. - Do pay attention to what you do. And here lies the main difference from what you're doing now. Instead of wondering if you could be better off using some framework, just look at your code. Look for things like repetition, parts that share too much but are separated, unrelated parts which are together... In general, I'd say don't fret about the big picture architecture, start focusing on smaller building blocks and learn the problems and solutions you find on those. Then, building a larger architecture from smaller blocks you understand is an easier task. And understanding those projects will also be less confusing. I had a very brief look at your code there... It's not *bad*. I mean, of course you can improve, but for a learning project I think you should just go with that and build on it and not worry about frameworks or stuff. I'd worry more about the smaller details. e.g. there's this: function advanceTurn() { turn = (turn === "black" ? "white" : "black"); if( counter.black === counter.white ) { counter.black++; } else { counter.white++; } } Why would you use that condition? What does that mean? And actually, does that work once you implement the capture? Wouldn't a more semantic condition make more sense ("if it's black's turn...")?
Why is the togetherjs website not using it?
Could you host your own [hub](https://togetherjs.com/docs/contributing.html#hosting-the-hub-server), and have data synchronization like in firebase?
I'd say make the *tiles* fall faster; as if they were falling, not as if they were gently going down on their own will. Just an idea.
It looks interesting but the readme doesn't explain anything and the demo doesn't work. Is the track you play generated from the audio or supplied by someone? Can you use any music? What other features does it have? Does it use the Web Audio API? Can you use multiple tracks?
I don't currently do professional development so my work flow is fairly simple. I just open up a Sublime and start writing. I'm far to lazy to learn bower's json so I just user bower install to grab the packages I need, jQuery, bootstrap, etc.Then I copy and paste in a pre-built gruntfile for minification and stuff.
Thank you very much for this ! I really appreciate it. Perfectionism sure is awful when trying to learn something &gt;:( Ok for frameworks, but what about unit testing ? Shouldn't I get this habit asap ? (even if i'm kinda screwed with my modules ahah). It seems heavy to learn and implement and it goes along with what you say about frameworks though. For the advanceTurn condition : yeah, i didn't think about how my counters would totally screw the entire turn process when capture will be implemented, since i haven't started to think about the capture part yet. I'm really bad at anticipating what will happen inside my code (lack of xp again), and sometimes when i have a new feature to add, i must rewrite lot of my code. That's partly why i'm so cautious with doing things right now :}
Thanks for gathering these data! The problem I have with "Maintainability Index" is not that it combines a bunch of metrics, but that it does so with an arbitrary weighting. Would your weighting of different metrics agree with mine? I don't know, and so I won't assume. To process this with fewer assumptions, I just looked at the ordinal position of each framework for each metric given in your post. For each pair of frameworks (X,Y), we say that Y is dominated by X if, for all metrics, X's rank is better than Y's. From here, a Pareto approach to optimization would say "if a framework is dominated at all, it should be removed from consideration". But since these complexity metrics may not be the only criteria used to choose between frameworks, I will just sum the number of times each framework is dominated. **Lower scores are better.** |Name |Times Dominated| |-------|---------------| |angularjs| 0 |angularjs-perf| 0 |emberjs| 0 |knockoutjs| 0 |backbone_require| 1 |canjs| 2 |agilityjs| 3 |backbone| 3 |yui| 3 |flight| 4 |jquery| 4 |knockback| 4 |maria| 4 |spine| 6 |dojo| 8 |closure| 10 |vanillajs| 11 
WebRTC.
Testing... Well, unit testing is a tool. Not only that but it's mostly a tool for the process, not a tool for the product itself. It may/could/can/will affect the code itself, in the sense that you will aim for *more testable* code, but *IMHO* it should not really affect your code *too much*. I would certainly recommend learning about and doing unit testing, particularly if you're interested in what it provides. But.. yeah, maybe it can be too much weight to add if you are doing a learning project. Maybe you could leave it out for this one but introduce unit testing in your next project. Maybe you could tackle a similar problem (not the same one, because that would be boring ;)) so that you already know some of the problems you will face but this second time focus more on unit testing or/and something else. You don't have to learn everything at once :) Also unit testing is a good habit and it does help to improve code quality, but it is a tool. Do you always need to use that tool? Hmm... (Of course take all my advice with a grain of salt. I'm just a randome stranger on reddit, I probably don't have all the right answers ;))
~~The demos at the bottom of the page are not working. I'd love to see it in action.~~ It's working now! Great job!
I myself have dealt with this same issue for a while, and namely how the heck do I organize everything. Over the last year, I've taken two older frameworks of mine and merged them together to come up with (shameless plug) [bmoor](https://github.com/b-heilman/bmoor) Why did I do this? Well, bmoor, at least the core, is all about structuring your app and allowing for clean and efficient autoloading. It works much like Require.js, but instead of going off of files, it goes off of functionality. For instance, you say require({ references : { 'jQuery' : 'location of jQuery' }, classes : [ 'some.class.Somewhere' ] }, function()) This allows you to link jQuery requests to one min file, or to autoload a package from anywhere you want. The framework also gives you functionality to support you in defining 'classes'. Now, the framework branches out from there and I actually have an MVC based on the loader, but the key to everything really is all the stuff in bmoor. I build one min file, and since the loader cares about attributes and not files, it just load it load in anything I might have forgotten. Make life a lot easier without too much over head. Eventually I want to build something that automates the making of the min files, but that's well down the line.
I'm using Firefox 24, yet it doesn't seem to do anything useful over here. Hell, the examples on their sites don't even bring up the expected controls. Maybe their hub is having issues? Maybe it only works on 2 separate ip addresses? What ports need to be open?
neat.
Yup that would be a very good solution I think. I've heard mixed things about it but in his case there probably isn't a lot of custom code required. He should hopefully just be able to drop his stuff in and have it work. Likewise on Android they recently released the native code thing or whatever it's called where you can package an Android app up as a native app. It doesn't support Android yet but I think that's where they're heading. I just figured I'd offer to help get this done as a full iPhone app if he was interested.
I use something that actually looks surprisingly similar to this, and it's sweet for building large complex objects. Alternatives for dynamic, complex objects, can get very unwieldy. Although in mine, everything is returned as a HTML Element. Nothing outputs to the document on it's own. Although things can get tagged onto other elements automatically, if they are created within those elements (through a special function). This is namely so I can easily pump a template fragment into a template fragment, with almost no boiler plate.
Me too. It tried to put it on an experimental page of my site (http://reeborg.ca/learn_js_together.html); it appeared to work ... but I could not share a session AND it broke my site by preventing some jqueryUI dialogs from showing up. Mind you, I do manipulate the url hash, which may be the reason why the sharing does not work...
Don't get me wrong, this is very cool. Maybe it's because I don't do a lot of aesthetic design stuff but why would you make an entire library for something like this? I can't imagine that people need custom flip clocks that frequently.
From our experiences, security releases or one small but significant bug fix are the main reasons for patch releases.
When are using so many libraries on one project I think it best to look at WHY you need all those libraries rather than how you could get them all down to the client. You're creating more problems than solutions really. 
i didnt make it, ... but i do make alot of other things.... of this fivilous nature.. so my guess is.. it urned out just being something the maker made for himself/herself and then just offered up the source to anyone else who wanted it... its not really a full library.. just a couple lines of code. that you would plug into your site
Well it's mostly just AngularJS (which is really modular since 1.2), bootstrap, jQuery, and my app files..
I'm in the staggeringly small minority of gainfully employed JS developers who does not use external libraries/frameworks in client side code. I use grunt for some workflow stuff and minification. In my opinion and the opinion of my company the benefits of using someone else's code in production do not outweigh the risks. EDIT: Context. We do audio/video/webGL productions. Performance, millisecond precision (for audio sync and scheduling) are all required and 100% necessary. Our reasons for not using external code in our productions is purely functional and has actually, in my opinion, saved us time. We have an entirely different set of concerns than people churning out wordpress templates, or facebook clones. 
Hey that's great thanks! Do you mind me adding this at the end of the article? Of course attributing you for it.
Feels like an easy meteor 
FFIs (typically to C) are a staple. Python, Ruby, and Haskell all have them for example. The problem they solve is there are **a lot** of libraries out there that expose a C interface which you may want to use. Need to compress some data? You could write the compression in JS, or you could just use the FFI to call zlib. Whether to wrap a C library or write something in JS from scratch is something you have to evaluate on a case by case basis, but it's very good to have the choice. As I touched on in the post: there's also an issue of bootstrapping. You can't write all code in pure vanilla JS; sometimes you have to interface with something else. Higgs itself uses the FFI to bootstrap functionality. For file I/O for example, I could write D code (The low level parts of Higgs are written in D) to extend the interpreter to have functions for opening/writing/etc files. With the FFI though, I can just write that in [JS](https://github.com/maximecb/Higgs/blob/master/source/lib/stdio.js); a process I personally find more pleasant. &gt; Wouldn't js-&gt;c compiler be a better solution Compiling JS to C is easier said than done. It also doesn't automatically solve the issue that we're talking about here. You'd still have to have some way of specifying what libraries you want to use and how to interface them with your code; so you'd have an FFI the compiler used to generate C, or you'd manually extend the generated C, or something like that. &gt; Isn't it easier just to have your code base in one language In some ways yes, which is one of the things we're shooting for here. Instead of having to extend the Higgs interpreter to do things you want, you can use the FFI to write your code in JS. In a case like that, you're not actually writing C code. You're just copy and pasting the relevent declarations. This saves you the trouble of having to describe things yourself (although you can do that too as mentioned in the post). Eventually I'll add a way to pretty much just point it at header files. Splitting your code base into multiple languages isn't always bad though, and a FFI can enable that too. If you wanted to, you could write parts of your program in C and then script them with JS using the FFI. You could also concievably use the wrapping functions to store or operate on some data more efficiently than just sticking it in JS objects, etc. In that case you may be able to write code in JS that you were considering writing in C. I'd note though that the Higgs FFI isn't really optimized for stuff like that currently.
By explicitly specifying dependencies between parts of your code, you can always refactor your code. Because of this you can usually dig yourself out of problems and convert your prototype to a real app (because your project is simple until it's not). Explicit dependencies between encapsulated modules is, IMO, the most important thing to do, whether you're in a small project or a large one. It doesn't need to be that hard. Specifically, watchify (part of browserify) makes this *super* easy. Give it a shot; it's basically watchify -o build.js src/main.js.
Simple is sometimes the most powerful: We just put in multiple plain &lt;script&gt; tags just before the close of the &lt;body&gt;. Then use Google mod_pagespeed to combine, minify, and rewrite the URL for those scripts through our CDN. The human-readable source code is then easily available while testing, and things are well-optimized for speed in production. And there's no worrying about build system compatibility in different libraries. Everything, at its most basic level, can be loaded in a &lt;script&gt; tag. And making sure they are put in the right order really isn't much of a pain point. The only more complicated thing we are doing now is looking into separating out code not related to the first page load, to reduce that initial payload by having that load and execute later.
This is a hotly contested issue among many proficient javascript developers. Many other languages have a "compilation" phase where the entire program is bundled up for deployment (JBoss's .WAR files come to mind). Programmers that come from more traditional backgrounds often favor this approach. Javascript has seen such growth in recent years that it is difficult to chart exact best practices, but those that appreciate the more functional nature of Javascript often prefer the module loading approach (like require.js uses). I wrote Frame.js which works much like require.js, so my bias is towards the module loader approach. To answer your question directly, yes, it is one or the other. Most that argue for packing your scripts into a single file believe it enables more compression and is thus more efficient. I believe the efficiency advantages of packaging are negligible in most cases because: (1) module load times are distributed over the entire session, (2) individual modules can be compressed to nearly the same percentage, (3) individual modules can be cached by the server and routers separately, and (4) loading scripts only when they are needed ultimately allows you load less code for some users and more code overall. In the long run, if you can see an advantage to dynamic script loading use it. If not, bundle your scripts into a single file. http://stackoverflow.com/questions/12232848/when-to-use-requirejs-and-when-to-use-bundled-javascript/12232921#12232921
You're not google or amazon.
How does it compare to [Lo-Dash's `_.curry` function](http://lodash.com/docs#curry)? They reference this page: http://hughfdjackson.com/javascript/2013/07/06/why-curry-helps/
Before you do so, I'd like to expand it a little bit- I only used Halstead Effort, but I *could* include the two basic Halstead metrics (volume and difficulty) from which effort is derived without too much more work. But yeah, I'll post another reply after I update my post with the new analysis.
I use requirejs. It lets me create a bunch of JS modules/patterns that I would use in a site (like a simple canvas animation, or a progressive date picker or something like that), and load them all up under a single namespace from different files. That way, at the end, I can minify with requiresjs bundler into a single minified, cacheable js file that will include only the stuff I need, rather than my whole codebase. And it's easy to load common libraries from cdns from this too, so I don't need to think about managing JS in my html. I do this with angular too, but I'm not sure its the best practice.
You can give [youtube-dl](http://rg3.github.io/youtube-dl/) a link to a playlist and it will download all of them. $ youtube-dl http://www.youtube.com/playlist?list=PL37ZVnwpeshF7AHpbZt33aW0brYJyNftx
I just use package.json's scripts field: "scripts": { "watch": "watchify browser/main.js -o static/bundle.js --debug -v", "build": "browserify browser/main.js | uglifyjs &gt; static/bundle.js" } Then locally for development I just kick off an `npm run watch` in the background so I can just modify my files and refresh as the bundle updates automatically. For production I can just do `npm run build`. For coffeescript you can just `npm install coffeeify` and then add `-t coffeeify` to both the watchify and browserify commands above. The benefit of using browserify (author speaking here) is that you can compose your application out of lots of tiny, well-tested modules you can pull in from npm. If you're using angular or other heavy frameworks you will get some benefit but the benefits mostly become apparent when you start using dozens of tiny libraries that each do exactly 1 thing well and might have rich dependency graphs instead of having to write them yourself, manually maintain the script ordering for module dependencies, or restrict yourself to shallow libraries without any dependencies.
Thanks again jpfed! I'll make a chart of it and add it to the post. Edit: the article is now updated.
&gt;In my opinion and the opinion of my company the benefits of using someone else's code in production do not outweigh the risks. *Really*? You think it is safer for example to write your own DOM navigation library than to use jquery? Do you write your own web server? Operating system? Web browser for clients to use? Compiler to compile those things? If not you are using someone else's code in production.
Thanks for the detailed response.
Dude, 1992 just called... EDIT: Backstory. I started my professional career in 1992. The "not built here" attitude was huge back then. No trust of anything 3rd party. We wrote our own printer drivers for fucksake. No Internet. No open source goodness. Barbaric times. I shudder at the memory.
I'm using a server side minifier that minifies the wanted scripts using minify.php and that is delivered as one big chunk of gzipped goodness to the browser.
The server is probably down. To get a working examples of this on your localhost: git clone https://github.com/mozilla/togetherjs.git togetherjs cd togetherjs npm install npm install -g grunt-cli #if you don't have it grunt build buildsite --no-hardlink cd build python -m SimpleHTTPServer # or run any other server able to serve static files in browser click on http://localhost:8000/ and you'll get a working demo of this. I'fe found the most useful stuff on url localhost:8000/the-developers/ this is the most basic stuff, but you can easily edit it and learn how to use it. It is really impressive and simple. EDIT: obviously you need to have node and git.
I guess that's comparable to Django Compressor?
I don't get if this is it or not, but I'd kill for a free Firebase using WebRTC between clients.
Never used it but according to the description it kinda is, without the automagic template tag. https://code.google.com/p/minify/
Is this like towtruck reimagined?
It asked for me to log in with twitter, so I closed it.
I wholeheartedly agree. Like you, many of us know how to code.
&gt;the benefits of using someone else's code in production do not outweigh the risks This has to be some sort of joke
&gt; I'm using Firefox 24, yet it doesn't seem to do anything useful over here. Hell, the examples on their sites don't even bring up the expected controls Yes, I couldn't connect to their hub. Trying it with your own hub does work here. Though, what I find weird is that I see all traffic going through the hub, instead of through WebRTC. Maybe some features WebRTC aren't fully supported yet on the stable browsers and it needs to fallback to the hub through websockets.
Cool, thanks!
With the current version of Backbone.Picky, no, but there's a pull request that should fix this: https://github.com/derickbailey/backbone.picky/pull/16
My two cents, remove this line : var self = this; 'app' is available on window, so you could just say, app.shuffle() app.links.push (...) etc.
Better idea: use Function.bind and be explicit that you're depending on the current scope.
OP does this in a $.getJSON 'done' handler, which is a little different. If going that route, it might be best to switch the $.ajax... here's a SO answer with example that shows how to make $.ajax work like getJSON and also passing the 'context' argument ('this' in the callback): http://stackoverflow.com/a/10694944
Sweet game! Finished all levels now. More please :)
Ignore the haters. This is lovely.
This *IS* towtruck 
Do you know how many JS frameworks came and went before jQuery got critical mass? Using the new shiny for an app expected to last many years is very risky. 
If you're building a JavaScript web application, where most of your application logic is split up over multiple files, it definitely is useful. We have many of our files split up into separate models, views, templates, and internationalization files, which might need to be loaded conditionally. In our case, it's really useful to have a loader so we can more easily divide up the work throughout multiple teams.
As opposed to rolling your own piece of crap that you can only maintain and will be required to be on hand for the next few years for maintenance? 
firebase isn't open source.
I worked on this years ago for Mozilla, cool to see it become kinda publicly available but kinda sad to see it being a bit of a half assed effort launch.. Ian B needs more people in his team, I'd double his team if I was at Moz.
When a carpenter says he uses a hammer do you attempt to ridicule him by asking him if he also builds skyscrapers with that thing? Your questions are as dumbass as you can get but, then again, I don't know you.
John Resig rolled his own (jQuery) by himself. Would you call that a piece of crap? Just because you don't have the knowledge to write proper javascript doesn't mean we all don't know how.
Yeah? Well go fuck yourself. You aren't Resig or Ashkenas.
At least you didn't come back and tell me you're a javascript god which also tells me exactly what I think of you. That you don't know anything of the subject but felt obligated to comment anyway. Typical of 80% of all redditors.
Yes I frequently ridicule carpenters by asking them if they use hammers when building sky scrapers.
Cryptic, but I'll bite. * This breaks strict mode, your usage is a lie: http://jsbin.com/aseyImi/1/edit?js,console * This also breaks "static" analyzers (jslint, jshint, etc...), since they can't tell what `modules(arguments)` returns * You better be sure that `modules(arguments)` returns a value created with `Object.create(null)` or you'll creep Object.prototype values into your scope.
Agreed, you almost got me to think that there actually was a good use of with :)
At least you're open to it as opposed to reacting in a knee-jerk fashion. Have you looked into Resig's ["Secrets of the Javascript Ninja"](http://www.manning.com/resig/)? He might further convince you.
I blogged this a couple of months ago: ["Does require.js introduce more problems than it solves?"](http://codrspace.com/dexygen/does-require-js-introduce-more-problems-than-it-solves-/). Then I didn't want to be a whiner, so I wrote [an (admittedly naive) alternative](http://meekjs.com). By the way, [Marionette's Derick Bailey ain't a fan either](http://lostechies.com/derickbailey/category/requirejs/) 
NIH
Really? I'm no require.js fan, but never using anybody else's code in production? That's a well known anti-pattern: ["Not Invented Here Syndrome](http://en.wikipedia.org/wiki/Not_invented_here)
No, I haven't. I think that with is more bad than it is good, mostly because it makes the few good tools we have worse (jslint, jshint, etc...). Maybe you really just want a combinator to give you the dictionary: function wrap(f) { return f.bind(null, modules(arguments)); } require(dependencies(), wrap(function(imports) { 'use strict' imports.App.run(); })}); Also, at IMVU, our base javascript library (dependency management, sane polyfills, underscore, backbone, tools to combine and minify dependencies) has an eerily similar interface to what this is all about: module.run({ 'App': 'app/app.js' }, function (imports) { imports.App.run(); }); Check it out: https://github.com/imvu/imvujs *edit*: left out the imports
No brains here.
No. The tools of the trade are javascript and the DOM. What the poster is saying is he needs tools to work with the tools. He doesn't use a hammer cause he can't do anything without a pneumatic hammer (and probably doesn't know how a regular hammer works anyway). He doesn't work with the DOM cause he doesn't know anything about the DOM cause he uses frameworks and libraries that hide such things from him. It's just like people who can't add or subtract numbers without a calculator. He, and those like him, are frequently like that. How many people who, when they have a 'javascript question' are really asking for a jQuery answer but couldn't code the same problem in javascript? Answer: 80%. 
I really like node style require. Just write your js module and end it with an assignment to module.exports. It's so much simpler to me than AMD style. I use my own require functionduring development, and browserify and uglify it all for deployment. Painless and seamless for my purposes.
a more informative readme would be nice.
unusable
[Team member here] It's actually echoing all the messages through the server, only the audio goes through WebRTC. The browser support for WebRTC is too limited right now to depend on, and establishing connections is quite slow compared to WebSockets. Plus you need the server to exchange WebRTC connection information, so there's no real serverless option. My only real hope for TogetherJS to move to WebRTC for all the data was if the browser took over the connection, so you could have a connection that persisted longer than one page.
The Get Live Help button does use it, though to be fair it's only setup to work when a team member is sitting around waiting to chat with you. Or open your console and enter `TogetherJS()` and it'll launch and you can hit the + button to share the session with another person.
Browserify feels so pure and clean like fucking a hot blonde 23 year old Swiss girl in the alps.
Horse shit. You AMD folks are snake oil salesmen. What part of "I don't give a flying fuck about asynchronous code loading because its quite simply a problem that 99.999999% of applications will never need to address" do you not fucking understand? Fuck off. Fuck the hell off.
Thank you for pointing this out.
Hurts so good.
&gt; What is your ideal JavaScript/CoffeeScript workflow? After a lot of sweat and tears, I'm writing my code in Coffeescript, and using Grunt to handle all the compiling and processing. Grunt is *amazing*. &gt;How do you get bower packages working? &gt; How easy is it to integrate other packages that aren't made properly (or broken bower packages that browserify+debowerify cannot find)?I'm not using bower, and I'm not sure value it adds. I find browserify-shim solved all my "bad package" woes. But again, I don't use bower, so I'm more concerned with jquery plugins and such. &gt; What advantages does browserify actually give you? If you're writing a large app, you *MUST* organise it properly. In my experience the main contenders are AMD and CommonJS formats. And while both look okay on paper, as a practical matter AMD is a *pain*, whereas CommonJS just works. And if you're using CommonJS (and you should be) Browserify is the best and most mature tool to work with it. So...essentially, the advantage of browserify is "lets you organise your code sanely with a toolchain that doesn't make you want to murder people". Which is nice. ;) Edit: Looking through this page I see a lot of people talking about how small apps don't need complicated solutions (true) or that require.js/AMD sucks (true). I think it's worse stressing that large, complicates projects benefit from structure, and a proper CommonJS/Browserify/Grunt setup is just *wonderful* to work with. &gt; How do you change things between debug and production? Turn on minification and compression, turn off source maps. If you aren't combining all your CSS and JS into one file each in dev, then I'd turn that on as well.
I see... and did you figure out if this is only for two users (opening a connection between the two) or if an arbitrary number can join the pool? Their site really isn't clear. I'd rather not put my data in someone's hand, but at least Firebase makes it exceedingly clear what it does.
Yo dawg, I heard you like functions
Thanks a lot for the comprehensive review! I took a look at your code for Streamus and it's really impressive -- there's a lot going on that I don't fully understand, but I'll keep combing through in order to piece it together (you may see me on IRC today!). As for my code: I'll definitely try to address some of the points you've brought up here. I've done a little bit of work with BackboneJS and I thought it would be overkill for a project like this, but you're right: it makes sense to get familiar with it on smaller projects. I have always had a little bit of difficulty working with asynchronous scripts, so I'm also intrigued by RequireJS. Again, thanks for the in-depth review. Your feedback is really appreciated!
No worries man. Good luck on the coding. :) I'm off to the office to work on Streamus today! Implementing YouTube OAuth2 logins!
*Finally*. Searching for the best/most relevant modules on npmjs is kind of a chore.
Going great so far! 
too bad the noobs are so many here. Just because someone uses the latest buzzword frameworks does not mean they are "doing it right". 
There is a bug in the last level where if you are on the far right cell and call pivot() to turn around, on the next turn `warrior.check("backward");` throws an error.
In the mean time, this bug can be worked around by taking one step backward first before pivot. I also triggered this bug on Level 6, trying to check behind the collected diamond for a wall and pivoting. On an unrelated note, I noticed that transitioning to Level 7 whacked all of my source. Thankfully I could hit back and copy it. Thanks for the fun game!
Oh! [I didn't even realize that was scrollable.](http://i.imgur.com/lMXwKq1.png)
Depends on the situation, I suppose. DOM traversal, manipulation and AJAX is pretty consistent after IE6.
As I said above, "client-side code". Meaning, javascript files included and run in the client's browser. You seem to have misunderstood me. We are a media production company generally doing projects showcasing newer web technologies. We don't serve users &lt; IE9, as such jQuery is really not necessary for what we do. I'm perfectly comfortable writing a dom manipulation lib, client-side templating, audio DSP, etc. etc. 
I should give some context. We work on projects involving video/audio where millisecond precise timing is absolutely 100% REQUIRED. Given that requirement, I do not run anything on the client side that I am not 100% certain isn't going to all of a sudden have the user listening to audio 50ms out of sync with video. I am not 100% certain about anything that I did not write, or have not personally read through, understood, and tested.
Depends on your use case. If you are a highly specialized, small company doing work with a demanding schedule for releases, it actually makes a lot of sense. 
classy, bro.
Our own piece of crap is the most advanced piece of audio/video software on the web and has won over 50 FWAs, been used in projects by google creative labs, north kingdom, acne, b-reel, and basically every other digital production company worth mentioning. None of us are John Resig, but if you know what the fuck you're doing, rolling your own produces great results. 
Well, honestly, jQuery isn't needed. The majority of animation can be (and should be) handled via CSS. Events can be handled through home-brewed pub/sub functionality, and you get the added benefit of getters and setters! Sounds like fun, honestly. :)
Thanks. I think frameworks are great for certain situations. I have no problem if other people want to use the MV* flavor of the month or jQuery or require or whatever, but I do have to say I hate using code if I'm not aware of how it's coded, and what it's doing. 
lol you mean angubatbone.js isn't the only way to create an app?
I just set warrior.currentCell for each level... is that not a good strategy? :P
OH sure, you want my wallet too?
&gt; to paraphrase Crockford “nobody wants to use something that’s weak” I want to use them. Lets say you are building a paint application, which stored all the operations you performed, to allow undo. Performing an undo would remove the last operation, and then re-drawing every operation it has stored. What if you have several thousand operations stored? It'll probably be slow, or more, non-instant, which is the real pain (undo should really feel like a no-op). So to speed it up, copy the results of every 10 or 100 operations, onto a spare undo canvas. Like a cache of all operations performed up to that operation. Now calling undo will remove the last operation, grabs the most recent undo canvas, and performs all operations since then. This could mean performing 10 operations, instead of 1,000s. What if you end up with several 1,000 undo canvases, won't they use up too much memory? Then put them in a weak map, done! There are a long list of caching-based optimizations, where weak maps are awesome. If you don't have an interest in them, then don't use them. Although they also become a lot more interesting, when you have more ways of describing how they work. Do they pick what to garbage collect based randomly, based on how much memory it's used, based on how often it's been touched, or based on when it was last touched? Ultimately this should be left up to the implementation, but there should be common ground hinting which should be used (if possible), or for you to be allowed to provide a hint on which is probably best. However they are not really an alternative to map/set/arrays/lists/whatever. It's more of an extension on top of weak references, as if you only had weak references in a language, then mixing them with maps (which is pretty common) will still eat up tonnes of memory. That is because the data internally, to store those mappings, is not automatically collected when the reference is too.
Um. No. Downvoted and fuck you.
&gt; We have an entirely different set of concerns than people churning out wordpress templates, or facebook clones. Exactly. The sites we put out are all unique. No one site looks like any other and are completely customized to the customer. In the publishing world, it would be like every magazine duplicating Time's layout, index, titling, etc.
I don't think it's better, but it is pretty cute.
&gt; The garbage collection semantics are the same as all JavaScript references. I do not believe that is true. The spec only gives a structure, to help explain the characteristics of the WeakMap/WeakSet. It does not specify how exactly the implementation should work. That doesn't answer my questions about what order weakly referenced objects will be reclaimed, if they are ever garbage collected.
my thoughts exactly
Global cheating solution: jsWarrior.turn = function(warrior){ var w = warrior, dir = w.check() == 'wall' ? w.pivot() || -1 : 1; while(w.check() != 'wall') w.currentCell += dir; }
Fun! but it needs to be faster.. Takes too long to watch the scene play out :)
Not only that but how their limited range actually works. They only attack when they have direct line of sight.
Rather than just blindly down vote you, I'll reply. http://requirejs.org/docs/optimization.html Building scripts is actually apart of require, and it actually is better than blindly just concat'ing scripts together. Not only can you combine the scripts, but you can minify them via other methods such as Google's Closure Compiler (which, if you haven't explored, you should, because it's damn awesome).
When you play the game you give the author unlimited permissions to your entire Google account. Or at least the permissions you grant aren't enumerated anywhere. And the game doesn't specify why it needs them, if there is even a reason at all, at least not before the "Play" button on its home page. So no. Fuck the author. Shit like this needs to stop. The public needs to take a stand against constantly leaking their information to app developers without regards to the consequences of doing so, and app developers need to start being cognizant of the consequences for requiring their users to grant permissions. One of those consequences was my down vote and boycott, and I'm not the only one.
Ah, well that's reasonable. It wasn't obvious to me at all that that is what you meant. Probably the reason for all the downvotes.
I know how garbage collection works, that is *not* what I am talking about. Lets say you have the code ... var wmap = new WeakMap(); wmap.set( keyA, objectA ); wmap.set( keyB, objectB ); Some time later you run out of memory, and the GC decides to reclaim some from the weak map. Which gets reclaimed first, keyA/objectA, or keyB/objectB? and why? That is what I am talking about, how it chooses which is reclaimed first, and yes that matters. JVMs for example uses heuristics to make their decision. &gt; There is no WeakSet in es6 Well it is listed [here](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-23.4) in the spec. &gt; the spec gets into detail about how the WeakMap is implemented Only to explain it's behavior. For example as it says for WeakSet ... &gt; &gt; WeakSet objects must be implemented using either hash tables or other mechanisms that, on average, provide access times that are sublinear on the number of elements in the collection. The data structure used in this WeakSet objects specification is only intended to describe the required observable semantics of WeakSet objects. It is not intended to be a viable implementation model. The really key bit being, that implementation details are to *'describe the required observable semantics'*. It describes how it should behave, not how it should be built.
garbage collection is outside the scope of the spec, there is no way to specify whether keyA or keyB is collected first nor know this, they will only be collected if there are no longer any references to them that can be accessed inside the program, i.e if you had written var a = keyA; var b = keyB; they could be garbage collected any time a and b would be collected in the same way. I stand corrected on WeakSet, forgot about it as it's not been implemented anywhere yet. But in general the spec never gets into how it should be build leaving that up to the implementation as they might think up a better way. It should be noted that these work on proper objects, so the key to a weak map must be something like {a:1}, never just 1 or 'a'. This means a key isn't a similar object, but must be the exact object, if you do var wmap = new WeakMap(); wmap.set( {a:1}, objectA ); wmap.get({a:1}) would return undefined because it's not the same {a:1}
My mistake, I presumed they were like weak maps/sets in other languages. If not, then that's a bit pointless. I can see still see a few valid cases for this though, I have some code where I've added id values to objects so I can use them as keys (where obj.id is used as the key). However proper weak maps would be much more useful.
A few points to clear up: One, you do not grant "unlimited permission to your entire Google account" or anything of the sort through use of OAuth. It just allows a developer to obtain a token identifying you to a third-party website. It exists specifically to avoid granting sensitive data to a third-party. Two, even if what you were saying were true and it did grant the developer full access to your account, it would be Google's fault for allowing such an easy avenue of exploitation of its data. And given the large amount of privacy concerns that Google has to address, it doesn't seem likely they would provide a magic button to obtain all your precious information. And finally: vulgarity is the calling card of ignorance.
warrior.hit(-100000);
Wow!! We honestly tried to come up with a general purpose solution, but couldn't. This is seriously cool :) We'l add more levels soon and PM you when it's ready.
Google has an API, and does give access via that API to your data. This is not unlike the Facebook API, for example. It doesn't provide all your information, but it does provide enough access to be worrying, especially if you are a Google Checkout, Google Drive, Google Play, or Google+ user. The fact that you don't know this is exactly the problem. The page wasn't just an OAuth page. It was the Google "Grant access to your Google account by this application?" prompt. At the very least you are allowing the developer to uniquely identify you and to use some unidentified subset of the Google API. Google is doing its due diligence by warning the user not to proceed. So how you can state that "it would be Google's fault anyway", I don't understand. Just like I don't understand why any app developer would think that I'd grant access to them without at least being told why first. My concern is that: 1. Requiring access to your account is obviously not necessary to play this particular game. 2. The developer doesn't tell users to expect a security prompt. The button is labeled "Play", not "Sign In Using Google". 3. The developer doesn't tell you why you are authenticating to begin with. 4. The developer doesn't tell you what Google APIs it uses, what permissions it's going to ask for, or why it needs them. 5. The developer doesn't even tell you what the game is before redirecting you to the Google authentication prompt, so as a user you don't even know why you'd grant access. Instead the developer is relying entirely on user's habit of "saying yes to anything", which comes of as shady as hell. ---- Edit: [This is on the front page of reddit right now](http://www.theverge.com/2013/9/21/4756212/linkedin-accused-of-hacking-user-email-lawsuit). I especially like the very first user comment after the article -- about the fact that Twitter uses the Google API to steal your Google contact lists and spam your contacts (as you). I suppose you think that's Google's fault too?
If you are a developer, you really need to learn how third-party authentication works. You have completely misunderstood OAuth, and you are insulting people who know better.
AutoHotkey and other solutions were meant, and some still mean, to bridge the gap between the default scripting/programming tools of a Windows install and full system automation. I do a lot of sysadmin work, and when it is Windows that means almost all batch scripts and VBScript (a garbage language, but still effective for system automation) to automate the *basic system operations Microsoft feel privileged to give you access from the command line, easing automation*. PowerShell is the newest language for that, but again, that still leaves something to be desired when you need to do the less appealing crap: automating programs and utilities Microsoft or others specifically designed without command-line automation in mind. However, since Windows is GUI-based, and lot of sysadmin work and other modifications offer no way to do necessary manipulation programatically, JsRoboKey and predecessors automated cool things like mouse cursor position, send key presses interactively to running GUI programs, and other UI operations not possible, or otherwise very easily done, with the standard tools mentioned above. To give you an example of the power of AutoHotkey, [someone even wrote a tiling window manager for Windows using it](http://www.autohotkey.net/~joten/bug.n.html), where as that would be a pretty lofty task for VBScript, and probably damn near impossible for batch unless you are orchestrating some binaries on the command line with parameters to make it happen. So if you do automation stuff for Windows, this is kind of interesting. I might try it out when I have time.
Just nitpicking here, but in this condition: if(warrior.check() == "enemy") If the check() method will always return a string (and not some object with a toString() method) why not use strict equal?
Read this: [http://www.theverge.com/2013/9/21/4756212/linkedin-accused-of-hacking-user-email-lawsuit](http://www.theverge.com/2013/9/21/4756212/linkedin-accused-of-hacking-user-email-lawsuit) That is at the top of today's news. Linked In, for example, uses the exact same Google feature that this game asked for access to. And it uses it to steal your Gmail contact list, and send emails to everyone (as you), inviting them to join Linked In. I can't believe none of you are aware of the amount of access you granted this game. I'm literally facepalming right now. ---- Edit: [Link to that discussion on Reddit](http://www.reddit.com/r/technology/comments/1mv5qi/linkedin_sued_by_users_who_say_it_hacked_email/)
How do we run this? Is it a module for node.js? The README doesn't say anything about this.
It would make sense that having used Linux for the past ten years I would have no idea what any of this stuff was.
I'm adopting pure-functional programming in Javascript more and more. Two non-trival examples from a recent project: https://github.com/jimhigson/oboe.js/blob/master/src/jsonPath.js https://github.com/jimhigson/oboe.js/blob/master/src/incrementalContentBuilder.js Good stuff.
Haha. As a sysadmin whose personal escape is in every Linux box, VM, and VPS, you have no idea. Haha. Jokes aside, if you are interested in seeing a more fun angle to this, I encourage you to check out [phantom.js](https://github.com/ariya/phantomjs), which is the same thing but for browser automation and screen-scraping. A lot of cool work is being done on that, and it makes [Selenium](http://docs.seleniumhq.org), for which it has a community-supported driver, a cheap toy in that field of utilities.
Google will alert you when signing in to a third party service which data they will use. By virtue that no notice is being given about your data, and given the very strict privacy policies Google has to implement given all the scrutiny about their services, **none of your data is being shared**. Your posts on this matter are alarmist and ill-informed. Additionally, I don't see how a random comment from an unrelated news post is relevant. I've worked extensively with the Google APIs that you are talking about, and they do not work as you seem to think they work.
Saw this yest'd at jsfooindia :)
Awesome!! :D Btw, if you play the game, and can come down to our office in Koramangala, Bangalore, you can still pick up your victory cookies :)
You must have [read my mind](http://www.reddit.com/r/javascript/comments/1mirar/looking_for_an_alternative_to_autohotkey_that/)! Edit: int rk.findWindow(QString,QString) -- find a window by title and/or class What are the two strings? Can you do partial searches? (ie: search for 'Notepad' to get the ID for the Notepad even though the window name is 'Untitled - Notepad') What if you have multiple Notepads? Could a method be created to return an array of windows?
This release is for win32 only, if you need compilation in linux or mac, you'll have to download and attempt to compile the source code. But for people who want a preview of the upcoming real release on Windows do this: 1. Download the 0.0.0 zip file. 2. Extract all the files to a single directory such as JsRoboKey/ 3. Double click JsRoboKey.exe 4. If you know javascript, start playing around in the Console Sandbox, and click the "Insta-Run" button to try it out. For example you can try: rk.addGlobalHotkey('Ctrl+Meta+N', function(){ rk.run('notepad'); }); And then click "Insta-Run" and try pressing Ctrl+WinKey+N, your callback function will run and notepad will open! Please look through the docs here https://github.com/relipse/JsRoboKey/blob/master/docs/functions.md And give some feedback! Thanks (author) **Actually I just found out that my rk.run() requires 2 parameters in 0.0.0, this will be corrected in the next release***
Yep I thought the exact same thing: Here is a screenshot for people who want to see what they're getting :) http://i.imgur.com/pP6ZiQK.png About your question, this is a prerelease so a few/several functions aren't yet finalized, such as rk.findWindow() the source code reveals I havent even started implementing it yet, sorry :): https://github.com/relipse/JsRoboKey/blob/b24d2f3b6ed791aa4765e57ae6f8f7ce9cda36e3/jsrobokey.cpp#L110
I'm on windows and it worked. In a way this tool reminds me of PhantomJS (and SlimerJS), or any other alternative JS environment. Maybe have a look at what they expose and offer as API and compare it to what you have and how Node.js does it. Node is of course the richest API and has NPM backing, but PhantomJS is decent enough to code stuff for, at least most of the stuff people are starting to expect from any JS environment. Some feedback: * Adopt the CommonJS standard: * Modules, via a global `require()` * Console API (`console.log()` etc) * Other API's and modules where relevant. * With a bit of luck you can source some implementations for much of this form other JavaScript projects. * Adopt Node.js conventions: * Drop the 'onEventChange' handler style and use either continuation passing (single listener) or `addEventListener()` / `on` (multiple listeners). * Add a way to communicate to outside processes, like a WebSocket service (or something fancy). So people can hook jsRoboHint into other tools (Node :) and rig-up crazy stuff. This could be very awesome: image linking a Node.js webserver to do work using a backend server running heavy-duty desktop tools like Photoshop. You could even do pretty advanced screenshots / demo capture stuff for games and what not.
Yes i'm looking for a ton suggestions and feedback since it is still early in development. --- Yeah definitely a great idea here and yes os-specific. I think the next step is to implement the already-cross-platform features that libqxt has seen here: http://libqxt.bitbucket.org/doc/tip/qxtwindowsystem.html If anyone is decent at C++ and Qt i recommend forking/and adding the function or feature they want as well, many hands make light work :) esp for cross platform stuff. 
I only use '==' for when I know I will have to do type coercion. When the types are the same 'equal' and 'strict equal' might be as fast, but we should still teach beginners to use the correct one.
Yeah, definitely probably a good idea to "group" the functions like that. You can even do that in javascript code and just call the rk. function it pertains to. I think it would make it more organized for sure. Although I can see how objectizing everything would take a lot more time than simply implementing a new method in the jsrobokey.cpp class but I would certainly be interested in it, using v8 engine with qt is still fresh to me so I'm learning what cool things to do. **EDIT** A few weeks ago I was on irc and someone suggested a sort of jquery ideaology as well. $('window class').on('activate', function(){ //do stuff }); Now the possibilities go wild. But you have to understand implementing a sort of generic function might be more annoying in c++, so a javascript guru could essentially just make their own sort of jquery wrapping rk. methods themselves. Since you thought of the idea ;), how about you take the functions that already exist in 0.0.0 and split them up into public static classes, and instansiated classes. You already did this with files, but what about the rest? I mean we should look at the design before going forward, it would be easy to split this stuff up now while still pre-alpha. 
[Autokey](http://en.wikipedia.org/wiki/AutoKey) works pretty well on Linux. I can normally adapt whatever ahk scripts/text replacements I need on linux with that. IronAHK is supposed to work on linux, but I've never gotten it setup. 
Yep loads of fun, need more levels, or what about a level editor so people can make levels themselves :)
Sure... I can take a look at it and try to categorize (and maybe come up with more ideas along the way) and document as much as I can. You can reject or add whatever you think might be possible as well. I admit, my C++ knowledge is sparse. The most I've done was read a tutorial on creating an OpenGL app and that was mostly just following directions. I didn't really dig into the APIs for window creation or any of that. It may be a day or so seeing how (real) work starts back up tomorrow.
That's cool, you give me the javascript you want, and i'll try to make it work in the back end provided it's decent **CHOOSING THE CENTRAL API: Anyone else feel free to chime in as this is developing the main api that once selected doesn't get changed frequently** 
Very cool! It would be nice if it had some shape presets, or hold-shift for drawing straight lines. Good job. :)
There's no limit on how many people can join a session, though the UI starts to get funky after more than maybe 4.
author here, glad you liked it! the "Draw Style" drop down should let you draw circles and squares, my repertoire of shapes is pretty limited tho :[ hold-shift sounded like a good idea so I went ahead and added that feature, thanks for the idea. seems to be working, but if you find any bugs do let me know. 
Nice little bit of code. Well done. I'm currently working on a project that allows users to load several widgets (iframes, videos, etc) into a finite space on a page, then drag/drop them around the area. I've been wondering how I was going to go about deciding where to put the "next" widget. Using "radar" to find a point on the screen with the most room is an interesting challenge. 
Tried it quickly in Safari (6.0.5) and it works. The only error that occurs on developer console is "'undefined' is not an object" (line 392 in shape.js). It doesn't affect how it works though
Change the for loop around line 85 of contour.js to a while loop. Easy fix.
Hey, That's a great idea. Putting it in the TODO list. Thanks.
Fix your font-css. Your local font is not available to me and the fallback is illegible.
heh heh sure! Thanks :)
&gt; What is your ideal JavaScript/CoffeeScript workflow? Stay with CJS style, and move to native ES6 modules when they'll be ready. Work with real package managers as npm (yes it's for client-side too) For CoffeeScript you can also work with [Webmake](https://github.com/medikoo/modules-webmake#modules-webmake) (I'm the author) &gt; How do you get bower packages working? Find they're CJS versions or prepare such. &gt; How easy is it to integrate other packages that aren't made properly (or broken bower packages that browserify+debowerify cannot find)? It's easy, but best is too use ones that are written originally in CJS style, they'll also provide best modularization (you take just what you need). &gt; What advantages does browserify actually give you? It allows you to work with CJS style and npm ecosystem, which is best designed and most powerful dependency management system that JavaScript has. (ignore Bower and other primitive attempts, they'll fade away with time and be abandoned, npm wouldn't). &gt; How do you change things between debug and production? Not much to do, do not produce source maps, and minify, that's the difference. 
What's the reason for only chrome support??
silly nhmood, for loops are for kids thanks for the fix, not sure how this wasn't obvious to me...
Awesome, thanks for running this down!
thanks for the info, i'll update my issues/footnote. i'll try to take a look at that undefined error too if i can get my hands on a mac or stomach installing safari on a non-osx system...
Let me know if you have any troubles. I can guide you through the setup and errors.
i added a local fallback of the font i'm using along with some more standard fallback fonts too, but i'm not sure that the layout will be the same with the other fallback fonts, any suggestions?
Because they lack color formatting, the code snippets in that article are an example of why CS is sometimes a little hard to read. Considering CS is nothing more than shorthand for JS, if you're posting an article in which &gt;90% of the people working with the technology are going to be using JS, you should post examples in JS.
the same reason for most poor decisions, laziness :-/ although i am hearing through the grapevines that safari works and i made a recent change to fix issues with firefox. this just leaves ie and mobile not working
I'm not sure I see the need for jQuery to be a dependency in this. You only use jQuery for some events, and to help parse JSON (and some minor utilities, like isArray and such). All of the supported browsers has JSON out of the box, and addEventListener could easily be shimmed for IE8.
Not sure what Lukifer meant but currently, holding shift draws a straight line from the start-point to the end-point. To me it sounded like his suggestion was to make it so when you hold shift, the line you are currently drawing will be straight. Though you would have to find a way to stop making a straight line in one direction and change the direction of the line so you're not finished after just drawing a straight line... Not sure how much extra work you really want to put into this but maybe making it so letting go of the mouse button doesnt end the drawing, it is only finished when the end is connected to the start? besides that, this is a cool project! ALSO: "knew this kid in hs, total fag, admitted he had a small dick in front of my family".
It's used to set up the on() event listeners because it was easier. I also needed a toJSON function which wraps various JSON.stringify methods because some browsers don't have JSON.stringify (older iOS). I guess i made a reasonable assumption that most websites would include jquery by default.
http://i.imgur.com/pP6ZiQK.png **Here is a screenshot**
I like the Bit Crusher effect. Do you just sample every X to make it? Looks trippy at high speeds - entertaining to watch. 
Is it just me or does this script save all its variables to the global scope?
It's better just to make a function like this: function range(n) { var arr = []; for (var i = 0; i &lt; n; i++) { arr.push(i); } return arr; } And use it in your code. It's much faster and far more readable and you can add things like start point, step size, etc.
**An example script I made to detect php or js on the clipboard, and show a message, saying that php or js was detected do you want to execute it** run = {}; run.php = function(data){ var php = "C:\\xampp\\php\\php.exe"; alert(rk.runWait(php, ['-r', data])); }; run.jsrk = function(data){ eval(data); } detectData = function(data){ if (/rk\./.test(data)){ return 'jsrk'; } if (/echo|if|\{/.test(data)){ return 'php'; } return false; }; tray_prev_or_exec = function(data, action){ var datatype = detectData(data); var run_call = run[datatype]; if (typeof(run_call) == 'function'){ if (action == 'tray'){ rk.trayMsg(datatype+' on clipboard?', 'Click to evaluate: ' + data, function(){ run_call(data); }); }else if (action == 'exec'){ run_call(data); } } }; rk.onClipboardChange(function(data){ tray_prev_or_exec(data, 'tray'); }); rk.addGlobalHotkey('Ctrl+Shift+R', function(){ tray_prev_or_exec(rk.clipboard(), 'tray'); }); rk.trayMsg('Clipboard Detector Loaded', 'Detect clipboard data and display data', function(){}); 
Yeah that's good, but if you're really calling `range(5)` I think `[0, 1, 2, 3, 4]` is even better. Beyond about 20, or if you need to use a variable, then it's worthwhile to write a function for it.
This is only measuring latency, not throughput or performance. Consider jsperf with simple callback which in reality gives easily [at least 100x-10000x (infinity really)](http://pastebin.com/BTma67DJ) throughput when compared to Q: http://jsperf.com/promise-comparisons/49 However this benchmark only shows a 4.85x difference. Very misleading. Or if latency was something you wanted to compare then you should have been more clear about that. 
That is an incredible explanation :)
If you're writing `range(5)` one single time, it's better -- but you're constantly adjusting the size of your array (e.g. if you're playing with test data), then using the function definitely wins.
We are intentionally measuring latency, it's always going to be slower then the simple callback (as calling it does so synchronously) but as fast as it can async. There are two parts it's probably not as clear if you start at part two like I more or less tell you to do by posting it. 
I'll try to figure out a better way to describe this if it isn't very clear to you.
That is a great explanation and a very beautiful piece of code, it's not the most efficient way of doing it since you have a function call for each number which is not cheap in clock cycles.
Simple Benchmark of the two methods: http://codepen.io/anon/pen/dgzmF
Basically all of them are. Creating an IIFE doesn't make a new namespace automatically, so all of your `this` variables are referring to the global object.
Every once in a while, I think about how useful the Array constructor would have been if it had simply made an array with its arguments, even for a single number (i.e. (new Array(100) //=&gt; [100])). And then I think about the fact that the guy who designed the language is still plays a large part in its development and cry.
Thanks for the informative article. As an aside, I'm also curious what was used to generate the diagrams. I really like the look of those.
Agreed 
Being able to specify an array length is more important than specifying members I think. Specifying members as constructor parameters is very rarely better than using either an array literal, push, or concat. Specifying an array length is great for allowing implementations to optimize allocation of memory (in practice, adding elements to a pre-allocated array is faster)
`call` and `apply` is where it really gets weird/fun.
Ahh I think I see the problem. This was a last minute change because if a complaint from jshint regarding the use of the new keyword. I suspected I should have told it to ignore that error instead of trying something different. Thanks for the look, I'll have it fixed in about an hour or two.
You don't have to make any assumptions, you can try it out in any browser and see for yourself! I tried in FF and IE just to be sure. Anyway, I don't think you can use the arguments use-case as a motivating example because arguments should have "inherited" from Array.prototype to begin with, thus making such gymnastics unnecessary :) Since I don't come across many other uses for making an array-like into an actual array, I still think taking length as a constructor parameter is superior as it will be used far more frequently.
The important thing to notice is how small the numbers are. I'm seeing 0.5ms vs 0.02ms. Probably not worth optimizing unless it's in an inner loop. EDIT: to be clear, I divided the output by 10,000, so those are my times for a single call. Yeah if you're generating 10,000 length-500 arrays, it's worthwhile to optimize, but chances are if you're doing that, you're doing something wrong anyway.
I've updated the code. Thank you again. I will also fix a few more things later, such as making private functions be closures instead of underscore functions on the PM object. I used the latter method for unit testing during development, but this can be done through unit testing on other methods instead.
i am new to javascript and i was playing this game to get better. but when i read your code. i am abit puzzled ,when i saw that your var thing return only one of these 2 values : true or "wall" i know you can access properties from objects like: warrior.reactTo["wall"](warrior.direction) how will you use the other properties other than "wall" in the warrior.reactTo object like that? ?.?
&gt; st com pre hen stio sss
I'm new to JavaScript, too :) This is really the first thing I've written in the language. It doesn't return 'wall' or true. It returns whatever warrior.check() returns, unless there is an error. The only purpose for the checkWorkaround() function is that there are some bugs in the game itself. Otherwise I'd just be using warrior.check() directly. Because of the bugs, I wrapped it in a try/catch statement so if warrior.check() errors out, I still get a useful value ('wall'). 
Those are all great, but don't forget the good ol' bound paper ones. I keep this next to me all day -- so useful http://www.visibone.com/ I know the visibone website is nothing to write home about, but I'm telling you, that guy does the best cheat sheets I've ever seen.
Yeah, that was a tradeoff I had to make. I wanted to conceptualize my solution as simply making the warrior react to the stimulus in front of him. It's a real nice, clean way of thinking of the problem and it meant I could use a simple 1-to-1 mapping. However, the game logic is a little too complex for that! walkCautiously() was originally called walkOrRest(). walkOrRest() is a more accurate name but it reveals the fact the function is doing too many things! A well-written function does one thing only. So instead of breaking my whole design to purge myself of that sin, I rationalized that "walking cautiously" is actually one thing -- it's walking that just happens to involve some resting. I should've left the old name. It at least clues you into the fact that I cheated a little bit to make my design work. If I were to rewrite it, I'd add a level of abstraction to the stimulus checking. Instead of relying solely on warrior.check(), that could be one step inside a getStimulus() function which also checks if the warrior is being attacked. 'under-attack' could then be returned, overriding the 'empty' value from the warrior.check() function. Who cares if you're in front of an empty cell? You're being attacked! Then I could add 'under-attack' as a key in the reactTo object and map that to some avoidance behavior.
You're right that code like this is not usually worth optimizing, but there is a huge difference in relative performance between the two methods, as shown by both the CodePen.io test and [this jsPerf](http://jsperf.com/clever-make-array). The simple and straightforward loop is 10-20 times faster, and it can be immediately understood by any JavaScript programmer. Interestingly, the simple loop is not an "optimized" version of the code. That is, it does not use any special tricks to be fast. It's just the most straightforward way to code it - it's what any JavaScript programmer would do if they weren't trying for any special tricks or fancy code. And it happens to be by far the fastest too. There is nothing good about the clever version. It is complicated, hard to understand, and very slow.
CodePen.io is great, but I think jsPerf is better for benchmarking. Here is [a jsPerf](http://jsperf.com/clever-make-array) comparing the two methods. This one creates arrays of length 50, 100, 150, ..., 1000 using each method.
I would not call that code beautiful in any way. It is a mind-boggling puzzle to understand it, as shown by the lengthy SO answer. By contrast, DonBiggles' straightforward loop is something that any JavaScript programmer can understand with no explanation required. It is clean, simple, elegant, and very fast. That is what I call beautiful code.
&gt; I'd add a level of abstraction to the stimulus checking I was thinking exactly the same thing. The problem would be that the stimulus check would then need a list of things to check for, some of which would override others, leading to the same design problem as the original - having to go through a branching list and assigning priority. A way I thought of solving this would be to create an object with stimulus checks as you did for actions, combined with a list of actions and priority scores. A loop would then go through the checks and each stimulus check could assign its stimulus if it was higher than the already assigned one. This would allow for more complex stimulus checks whilst maintaining a simple list and the early exits would be removed to the loop. var stimuli = [ [ 'check' : methodToCaluclateStimulus, 'action' : actionToCallIfStimulusIsAssigned, 'max' : maxStimusScoreThatCanBeAssigned, ], [ 'check' : methodToCaluclateStimulus, 'action' : actionToCallIfStimulusIsAssigned, 'max' : maxStimusScoreThatCanBeAssigned, ], ... ]; var stimulusScore = 0; var stimulusAction = function () {}; for (var i = 0; i &lt; stimuli.length; i++) { if (stimulusScore &gt; stimuli[i].max) { var newScore = stimuli[i].check(); if (newScore &gt; stimulusScore) { stimulusScore = newScore; stimulusAction = stimuli[i].action; } } } stimulusAction(); I'd better get back to work, I'm nearing the end of large project, with just nit picking bugs to solve and documentation to write, working out AI algorithms is a lot more fun...
I dunno what to say. If you honestly think that being unable to use the Array constructor to create a singleton number array is worth the marginal performance benefits that you get from pre-initializing array length, that's on you. But know that you have left countless javascript beginners confused in your pre-optimizing wake.
Lost me at "jQuery 1.3"
These 10 best of x posts are a plague on the internet.
jsPerf is good, but I just see the "add form" and lose all sense of desire to enter in fields. I don't know what it is about form fields, but I get so sick of seeing them. Especially when I see asterisks all over the place. With Codepen/jsFiddle I can just put some code on the page and have it run.
rAF all the things! Even though we're not writing games we should all get used to the idea of a "drawing loop", though I really wish things like reading values wouldn't cause layout reflow on the page (perhaps there is something in the way React works with an intermediate DOM like structure that is not in the page that could help). I made this a little while ago so that you can do things that respond to mouse movement as that is a big pain point even on latest browsers on desktop: https://github.com/rhysbrettbowen/MouseMover
I agree the straightforward way is better. I'm saying speed should not even be a consideration when the numbers are this small. "10-20 times faster" is the wrong way to compare them. Count the difference, not the ratio. It's easy to bring up the speed in this case, because it favors the one you want. But what would you say if the speeds were swapped?
Interesting, that's actually around 25% slower for me on Firefox. Still, either way of doing it blows the hack in the OP out of the water.
This is really cool. Thank you
https://github.com/maroslaw/rainyday.js
Yeah, given the downvotes, I probably won't post something like this again.
That is an excellent demo! Thanks for sharing :)
So fucking cool... Good job.
I stared at this for longer than I'd like to admit. Nice work.
For good, solid references I would suggest: * [MDN](https://developer.mozilla.org/en-US/) - Perfect for anything JS * [jQuery API Docs](http://api.jquery.com/) - It's very well written and easy to navigate * [StackOverflow](http://stackoverflow.com) - If you don't know StackOverflow then you're about to have your world rocked
jQuery is a cheat sheet. We're getting redundant when we have cheat sheets for cheat sheets. Like /u/Neurotrace said, their docs aren't terrible as is.
I don't think cheat sheets for jQuery are a bad idea (though I think writing jquery without understanding what is happening is).
That's actually kinda pretty. You need to make them go up like co2 in a beer glass. 
This is an interesting case study. Very cool. I'd be curious to see this written without the bacon dependency. It seems event listeners, an array to accumulate and a recursive raf to watch could handle this quite nicely.
Yes. V good tutorial. Not too long but very effective
Nice! Couples nicely with www.rainymood.com
Yeah. It wouldn't be too much work implementing this example without Bacon, but this isn't too advanced. I can imagine a more complex example getting a lot more hairy. If mixing both behaviours and events. E.g. animations or some sort of game.
I've updated the example to also use black keys.
I assume that since you just use a base64 encoded image you could easily incorporate any other image such as snow or someones head then?
I didn't write this. Just thought it was interesting and shared. 
Oh, ok. Sorry!
Very cool indeed. Would be cooler if the drops are in the shape of drops, and if they can join when one touches another.
I want this as a screensaver
That looks more or less like it's closing in on a naïve implementation of a behaviour. Cool example!
Looks awesome, thanks for improving module search.
This is really beautiful. Well done.
There may be a precedent, but from an API design point of view, doing one thing when the constructor function is called with a single number and doing another thing for all other cases is soo dumb. It's choose one or the other or stop designing APIs. I would've loved it if Array used Ruby's Array::new signature. If only, if only.
Excellent work, we would consider using this in our latest project!
It is not reasonable to assume jQuery would be included "by default".
The example code given is pretty inefficient. At least cache your jQuery selectors. Bonus points for detaching your DOM element while modifying it.
Is there anything out there that provides the page views /navigation structure of jquery mobile without the widgets? Something you could add on top of bootstrap?
Original post in question: www.reddit.com/r/perfectloops/comments/1mxlns/this_would_be_a_great_loading_symbol/ Props to /u/thatONEjustin and /u/pooerh for helping me out when I needed to get back to work! You can mess around with a few settings, specifically the number of elements on line 25 and the frame rate on line 10. Un-commenting lines 63 and 64 and reversing the direction the rings are drawn [leads to something like this!](http://jsfiddle.net/5yzMX/4/)
Cool I guess. I just don't see the point in forcing JavaScript to appear like a traditional OO language. Prototypal inheritance is super powerful. I'm aware that ECMA6 brings in the Class syntax, but have very mixed feelings about that. It doesn't make sense to hide (or lie about) one of the core aspects of a language. 
To each his own! I'm certainly not going to tell you you're *wrong* for using it, just personally would do without. :-)
I can't figure out what the benefits are for inlining such a large image! I suppose it is one less HTTP request, but it hardly seems worth it.
How many different fucking ways of doing classical OO in javascript do we need? Jesus christ.
that is fucking sexy.
Your suggested usage of private methods has a major flaw. Inside the private method 'this' will not resolve to the object, but instead to the global window object (or undefined in strict mode). To do it correctly you'll need to do privateMethod.call(this) Which adds performance and cognitive overhead. One of the many reasons why trying to achieve java-like classes in js is not worth it. Embrace the _private ;)
Argh, I knew there where something I had overlooked. I will see if I can find a clever way of covering that in version 1.1. The problem is as much that you need to use this. to self reference the Class as well. I did consider doing runtime rewriting of the Class and inject with(this){} around all class code. But it seemed to ugly. I shall never embrace the _ ;)
I am aware it's very late to the game. Luckily I wrote it mostly for myself, and I am perfectly happy to accept that it's the wrong thing to late for everybody else. I put a bit more thought into why in the Github readme https://github.com/Benjaminsen/extend.js
For now, it has been about one, on average, per developer who ever had to write a big project. This is my attempt at trying to do better ;)
At the end of the day, Extend.js is an attempt to solve my own inability to organize big projects in JavaScript without a strongly enforced OO abstraction. It was either write my own or adopt someone else's abstraction. At the end of the day I chose the first option.
The developer posted this 2 weeks ago and it got nowhere near enough love: http://www.reddit.com/r/javascript/comments/1m1xl2/rendering_raindrops_on_glass_with_javascript/
I'm trying to collect as many libraries as are open source and useful. Please hit me up if you have others that would be good to add.
This is really nice!
This is a terrible way to build an app and will lead to mountains of jQuery spaghetti mess down the road.
It's fixed now -- my apologies. I've used base64 to deal with CORS as the original demo was hosted on jsbin.com.
Working on it ;)
Well you could use a [closure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures) or by relation the [module pattern](http://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript) if your goal is to achieve encapsulation. It's easy enough to attach to a global module namespace, or use AMD loaders such as Require.JS for better file organization and modularity. You're shooting yourself in the foot by ignoring prototypal inheritance.
Sorry if it sounded like I was tearing a strip off ya! I was wondering if there was something extra cool going on that I didn't know about. :) (never apologise for your open-source work!)
@OP Link goes to the HN new submissions page. I don't see the actual link you intended to link to.
The only thing your library provides seem to be the super function to call the constructor of the inherited "class" otherwise its run of the mill prototype chain with some added overhead.
this is slow as hell and there are a shit ton of type errors in the log. cool idea, needs work.
Looks like the Polytron logo from Fez: http://youtu.be/avl6GJpwyR8?t=3m17s
Reminds me of this http://arcconstrukt.ocodo.info 
How do you actually sign up?
I just signed up with my Github account.
nice post
I did not see anything that was slow on my Chrome.
I get: `Uncaught TypeError: Cannot call method 'replace' of undefined` and this old chestnut `Uncaught SyntaxError: Unexpected token ILLEGAL`
http://imgur.com/8HQD1W7 All the "var test" spam is me.
Ok, now I see it. When I first got to the site, I only saw the "Sign In" link, could not find anything for "Sign Up." Clicked on the "Sign In" link, then tried connecting with GitHub, looked like it was a successful authentication, but nothing to let me know that I was actually logged in. Left the site, came back and now I get the "Enlist" section.
Really cool idea!
Strange. Like I was telling /u/alleycat5, you should [submit a bug report](http://www.codewars.com/topics/bug-reports). They seem pretty good about dealing with them.
I shall indeed.
Personal highlights: * [Serious discussion](https://github.com/rwaldron/tc39-notes/blob/master/es6/2013-09/sept-17.md#51-splice-cross-realm-arrays-and-subclassing) about breaking Array.prototype.slice.call. * "The dot operator is the root of all evil in JavaScript." - Alex Russell * "'then' is the wrong word." - Douglas Crockford on promises.
I feel like I could watch this infinitely. Thank you for posting this. 
This is fucking impressive as shit. Zooming in on the page really shows the attention to detail too in making this look organic. Bravo.
Very cool!! When I switch to full screen by hitting F11, the original height and width is maintained leaving a big white gutter at the bottom. Would it be possible to adjust for the window re-size and redraw the image accordingly? Hitting F5 solves the issue, but it would be nice if I didn't have to do that.
I personally like [this](http://jsfiddle.net/y4cju/) version a lot better. It still loops perfectly as well
Some people on github already picked this up :) Should be resolved soon!
It would have been helpful to know about warrior.pivot() on level 6 instead of laying down a fcukton of logic to deal with `walk()/collect()/check()` vs `walk("backward")/collect("backward")/check("backward")` only to find out it's all throwaway on the next level. Made me quit. Shitty level hints but cool concept and game design. 
Sorry, but every complete framework ever leaves a lot of users frustrated, because all frameworks are big, complicated and overloaded with unneccessary stuff by design. And that's not even bad, because that allows you to do many things rather easily. If you want small code and good performance, use vanilla JS with but a few helpers. Abusing JS to do the Job that HTML and CSS were meant to do is usually a bad idea implemented by most frameworks. This doesn't do on the desktop and mobile isn't going to change that.
Depends if you care about power consumption at all. A proper ARM SOC will probably draw at least 50mA, which gives you 2 days on a phone's LiPo. When waiting for input or a timer, Espruino draws 0.2mA - giving you almost 18 months!
Looks good. But why go to the trouble of converting rgb to hex? Also it seems like a lot of work to make rgb colors, when you have hsl :) Just my 10 cents. **Edit:** this is what i meant, from your generateColor method: var frequency = 360 / limit; var hue = ~~(frequency * elem); var color = 'hsl(' + hue + ', 70%, 50%)'; **Edit:** Sorry to keep going, but I do love a good code review. Personally, and also a de facto standard: app.color = new Array(); Is out, and app.color = []; Is in. You dont write new Object() either Also: var shortest_side = (app.canvas.width&gt;app.canvas.height) ? app.canvas.height: app.canvas.width; Can become: var shortest_side = Math.min(app.canvas.height, app.canvas.width); Why not use the methods already there :) **Edit:** requestAnimationFrame, and your requestAnimFrame, doesnt take a framerate as the second argument. My simple cleanup: http://jsfiddle.net/bobslaede/q93MK/
Interesting. I have done some backbone, back before it was v1.0. I havent ever done any Angular, but it does seem to be killing it. Why has Angular caught on so fast? Is there someone about it that makes it easier to use, or more versatile than the others?
Very very nice. However, I'm slightly bummed it's gnu licensed (was hoping for MIT), because I would love to play around with it on some commercial projects as a modal backdrop.
Because angular is rad , testable , databinding is rad , and you can write complex apps in minutes , if not seconds if your app is form centric (really. And because Java folks feel they are writing JSF with all these custom tags. Angular is not the holygrail but it is showing the way for new types of javascript frameworks. I do some Angular , it is powerfull but I prefere using jquery+backbone+ractive since i do a lot of "flash like html5 sites".
The impression I get is that it's easier to jump into than Ember, and Backbone is too incomplete of a solution, and people were jumping ship and needed somewhere to go. Angular's got a great testing story. Ember doesn't yet. Ember Data is also kind of buggy. It's not necessary, but the fact that it exists makes you want to use it, and it's kind of painful at the moment.
You've obviously never seen my open source work
I believe you can still use it in commercial projects as long as you make it's source available (so if you make changes so it works with a modal you just need to release the changes you made, not your whole project). 
What is the advantage of this to expect and should?
Hey, Must.js actually supports the expect flavor, too, but if you mean why should you use Must.js over Should.js and Chai.js, then one *major* reason is that those two assert on property access and that is flat out dangerous in tests. I wrote a critique on it here: https://github.com/moll/js-must#asserting-on-property-access Other than that major improvement Must.js is simpler (no interdependent matchers), better maintained and better tested. Plus it has the best recursive yet type-safe `eql` matcher of them all. ;) Let me know if you're curious for more. The README lists a few more points.
Awesome! You should think about leaving a raindrop trail that de-fogs the picture a little.
Nice. I don't see the note on promises though. Was it this discussion?
Because it caught on with the ruby community which is full of religious zealots...
Sweet. Where's the Rails plugin? :)
Thanks a bunch. I much prefer backbone to angular but was looking for something like ractive. I'll be sure to try it on my next project.
I like angular because the focus on testability. I don't even code ruby :(
My money is on my liver failing over the next year or two while I try to keep up with everything in the JS community.
Many thanks for including the code separate from the vid, and a transcript! I'm no longer bound to the speaking pace of the presenter (not to mention being able to hear &amp; understand them), or having to transpose code from the screen.
If I google each of them, the three terms I get from the first result of each search is "Backbone.js, Angularjs and Ember.js". So you're right, it seems to be the correct way to search for it.
Sweet example of designed-by-committee mediocrity.
Because Microsoft
Thanks for the compliments! I did briefly consider optional messages, but the thing with them is that most of our code or tests are *already* pretty descriptive, right? Your own assertion with expect(valueA) is a nice example. Now, you're right that reading line numbers off of the stacktrace is not helpful. But this should actually be the job of a test-runner — to show the failed line in addition to the assertion error message. That would save us from duplicating descriptions and help finding the offending line in all cases. I don't think, however, that Mocha does that. You wouldn't happen to know of a test-runner that did? I haven't yet tested Must.js with Phantom, like you found out, but will definitely offer a build for quick use in the browser in the future. Till then I'm pretty sure Browserify should do the trick — there isn't any Node-specific code (besides the require statements) in Must.js. Regarding Grunt — thanks. :-) I have given those alternative Make implementations a thought and so far I don't find them useful. I'm a Unix-guy at heart so I really prefer simple utilities that do one thing, are CLI friendly and can be composed. Grunt in particular is a wholly declarative layer of abstraction over things that are or should be simple pipe'able programs. It, and JavaScript, are not even a good fit for small scripts. Also, what I can see it also lacks automatic dependency building. Frankly, I don't know why people keep on reinventing Make in every language... :-) Make is mature, works everywhere, is language and project agnostic and is a small layer over the shell. Anyways, thanks again and let me know if I can help anyway or you have questions about the architecture of Must.js!
Could you help with that? :-) I've myself either moved on from Rails or structure apps in a way where the back-end web framework is independent from the front-end. What do you use today to test JavaScript in Rails?
Ember.js is a better match for the RoR mentality than Angular.js
The promises discussion is day 3.
I think you need to reconsider the (optional!) message parameter. They are *extremely* important for readable error messages in complex test cases. Whenever you have multiple assertions of the same type in the same test you need to be able to spot which one is throwing the error. Mocha does not support anything to help you here, it only gives a message and stack trace (and some diffs if lucky). How would you spot at a glance which one of the following is throwing an error? Sure you get a nice `'expected false to be true'` (or something like that) but it is useless in stating *which* of these is the culprit. (not this is just an abstract example) expect(obj.propertyA).to.be.true() expect(obj.propertyB).to.be.true() expect(obj.propertyC).to.be.true() expect(obj.propertyD).to.be.true() expect(obj.propertyE).to.be.true() And since you made the smart choice of always using methods (instead of getters) this should be very easy to implement. And again, if the message is used it should *not* replace the generated message but instead just prepend to it so you have benefit of both.
That would be nice, but I am not aware of a JavaScript test runner that does this (and is reliable on both node.js AND browser and has such nice eco-system as mocha (like the grunt plugins I mentioned and the various reporters and adapters). 
I hear you on the compatibility side and would absolutely like to treat Windows equally. Must.js should run on Windows already fluently, but I'm guessing we're talking about development. Would you mind elaborating why Make doesn't run on Windows? I do recall GNU Make having a Win32 build... http://gnuwin32.sourceforge.net/packages/make.htm It's been I think almost 8 years since I last developed on Windows, but don't most developers also use some sort of a Unix-like environment there? Surely they're still not primarily on cmd.exe. :-) Regardless of how we solve this, "make test" is just an alias to ./node_modules/.bin/mocha. That's why I like simplicity — more often than not Make tasks are just aliases to regular program invocations. I definitely agree various tools are helpful, but I'd say they should be used without the intermediary layer there. I find build tool agnostic utilities are better for everyone. Fortunately, currently there's nothing to build! :) The pre-compiled output for the browser would be the only one. Or am I missing something? 
I see you've built something for Mocha, you wouldn't want to take a crack at that? :) I personally am not too keen on building a test-runner as well. :-D The Node eco in my opinion is already such that you have to build most of the essential things yourself for them to be done well. There's quantity, but not necessarily quality.
How can you say this when literally every templating language has some notion of iteration/repetition? It's gotta happen.
Oh, never use knockout if its from MS. I have learned my lesson too many times about MS. I don't need another one.
It was created by an MS employee as a personal project. I think there is at least some level of sanctioned support by MS once they saw that the project was successful. Not sure how involved they are with it though. 
Testing counts as doing a build. How do you test on a platform if it cannot run your automated tests? :) From Git bash: $ npm test &gt; must@0.1.337 test d:\project\must\js-must &gt; make test Error on line 1: '=' is not a valid filename char npm ERR! weird error 1 npm ERR! not ok code 0 If I try to invoke it directly I get this $ node ./node_modules/.bin/mocha ./test/* d:\project\must\js-must\node_modules\.bin\mocha:2 basedir=`dirname "$0"` ^ SyntaxError: Unexpected token ILLEGAL at Module._compile (module.js:439:25) at Object.Module._extensions..js (module.js:474:10) at Module.load (module.js:356:32) at Function.Module._load (module.js:312:12) at Function.Module.runMain (module.js:497:10) at startup (node.js:119:16) at node.js:901:3 Also note how I now have to guess mocha's test arguments.
You don't need iterators, I found a new way to do it without a loop. I'll give an example below. You can just copy and paste it and change the variable/function names if you need to. if (people.length &gt; 0) printPerson(people[0]); if (people.length &gt; 1) printPerson(people[1]); if (people.length &gt; 2) printPerson(people[2]); if (people.length &gt; 3) printPerson(people[3]); if (people.length &gt; 4) printPerson(people[4]); if (people.length &gt; 5) printPerson(people[5]); if (people.length &gt; 6) printPerson(people[6]); if (people.length &gt; 7) printPerson(people[7]); if (people.length &gt; 8) printPerson(people[8]); if (people.length &gt; 9) printPerson(people[9]); if (people.length &gt; 10) printPerson(people[10]); if (people.length &gt; 11) printPerson(people[11]); if (people.length &gt; 12) printPerson(people[12]); if (people.length &gt; 13) printPerson(people[13]); if (people.length &gt; 14) printPerson(people[14]); if (people.length &gt; 15) printPerson(people[15]); if (people.length &gt; 16) printPerson(people[16]); if (people.length &gt; 17) printPerson(people[17]); if (people.length &gt; 18) printPerson(people[18]); if (people.length &gt; 19) printPerson(people[19]); if (people.length &gt; 20) printPerson(people[20]); if (people.length &gt; 21) printPerson(people[21]); if (people.length &gt; 22) printPerson(people[22]); if (people.length &gt; 23) printPerson(people[23]); if (people.length &gt; 24) printPerson(people[24]); if (people.length &gt; 25) printPerson(people[25]); if (people.length &gt; 26) printPerson(people[26]); if (people.length &gt; 27) printPerson(people[27]); if (people.length &gt; 28) printPerson(people[28]); if (people.length &gt; 29) printPerson(people[29]); if (people.length &gt; 30) printPerson(people[30]); 
I think Backbone.js is going the way of Prototype after jQuery was released. It was a good starting point, but largely incomplete. Its like providing you a screw to hang something on the wall...but you still need your own screwdriver to do anything useful with it.
Angular is built on the idea that "I don't need to know how this works, I just write this code and everything falls into place." It's not necessarily the iteration, but look at this - straight from their examples: &lt;div class="span2"&gt; &lt;!--Sidebar content--&gt; Search: &lt;input ng-model="query"&gt; &lt;/div&gt; &lt;div class="span10"&gt; &lt;!--Body content--&gt; &lt;ul class="phones"&gt; &lt;li ng-repeat="phone in phones | filter:query"&gt; {{phone.name}} &lt;p&gt;{{phone.snippet}}&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; How am I supposed to know how filter works? What if I want to customize it? What if I want to change it on the fly? I cannot figure out how to do this simply by looking at the HTML code. They're just spreading the work of JS into the HTML. In Backbone, we'd have a template for the list - nothing else. We'd have a reference to our list, and we can apply the filter to it, then render the list out using the template. More work? Perhaps, but I can change the behavior in a moments notice. I only have to edit a single file as opposed to multiple, and the logic stays in the "controller" so I don't have to think about where I have to apply it in the code at each stage. Backbone from what I've experienced is designed for larger, more complex applications and more experienced front-end developers. I understand the appeal of Angular because it's developed by Google, but I don't understand the benefit of using it - it seems to be for more for "designers" than full-fledged front-end engineers. Of course everybody has their preference, but IMO Angular is a step in the wrong direction.
This is actually an excellent point that you'll get downvoted for because of the overwhelming amount of fanboyism over angular. 
I stand corrected. 
When all said and done and with or without source we cannot use a main assertion library that does not let me add a simple string to append to the generated message. On the node eco: Everybody thinks that, and then they get discussions like this :) I've actually thought about doing my own assertion library for some time. Because Chai is good but imperfect and not a lot of fun to extend. Then there is Proclaim which should have been a perfect light TDD-style replacement but also dropped the ball, it will not glue the custom message to the generated one (and also it is not working correctly when used with node &lt;-&gt; PhantomJS like grunt-mocha). My mocha reporter has some voodoo-logic internally because all assertion libraries use slightly different AssertionErrors. It is a huge mess. I use it only with Chai, and incidentally Proclaim if I MUST have old IE's). So I was glad I saw your post. But now this (and the build :)
&gt; How am I supposed to know how filter works? What if I want to customize it? What if I want to change it on the fly? You've just played your hand as someone who hasn't actually used Angular and is just criticizing it from the outside. You can write your own custom filters easily (which are really just javascript functions) and place them into the html using the same pipe (|) notation. Angular exposes everything that it does at some level so that you could even create your own "ng-repeat" if you wanted to (not that you should). You can invoke "separation of concerns" all you want, but I like declarative html. Approaches that render html based on template functions are fine, but they're opaque insofar as you can't just look at the source html and figure out what it's going to turn into. &gt; I only have to edit a single file as opposed to multiple, The irony of this statement... Preferring templates over data-binding necessarily means you're (a) using javascript strings, (b) using script elements in html like you do in ember, or (c) writing templates in separate files and compiling them into javascript functions. (a) is horrible insofar as javascript doesn't have multiline strings/heredocs, (b) is better but if you're writing templates in the html you might as well be using databinding at that point, and (c) is performant but requires more tooling and it still defeats your whole "single file" approach. If your goal is to only edit a single file, why not edit the html itself using angular directives? You have no idea what you're talking about. Clearly, the only reason you care so much about this is because you're too lazy or incompetent to learn anything new, which will probably cause you to have an existential crisis somewhere down the line. The future of the web is declarative html and reusable components, check out polymer.js and the new html5 apis like shadow-doms. Once you try data-binding (try knockout.js if you really hate google so much), you'll realize how barbaric templating and string-concatatenation is.
Thanks. I'm just going through the official angularjs tutorial and I think I'm starting to see why my question makes little sense. Seems very interesting though for what it's meant to do.
It's the same concept that sold people on ASP.net webforms and other technologies that make things extremely easy at first (replacing the drag/drop of controls with the definition of ng tags), but ridiculously complicated when trying to scale the application's architecture. It makes for great demos, not so much when trying to actually build and maintain a large application.
I've never understood the benefits of this. Why is it not enough to just have a function that takes 1 parameter and tests for truthyness? I feel that is plenty readable. Instead of something like: foo.must.equal('expected'); just have: assert(foo === 'expected'); It's a simple interface, and I think it's actually more readable. You don't have to learn how the assertion framework works. It's just 1 function. I'm not trolling. I'm genuinely curious. I have never understood why people do this.
&gt; Everybody thinks that, and then they get discussions like this :) Oh, that's a common problem in a lot of languages. The promoters confuse popularity with quality. If only everyone who thought so, too, would learn some architecture and design skills and wrote better libraries, imagine what the world might be. :-) Anyways, back to the message topic. The only way it would make any *consistent* sense initially would be if the description were given in the `expect` flavor invocation — `expect(foo, "some type of foo").to...`. String passing to matchers themselves is inelegant as well as confusing — `foo.must.be.true("foo")`. That would also clash with matchers taking an optional argument, like `must.throw([expected])`. Allowing descriptions to some but not all matchers would be inconsistent. However, do you yourself think manually duplicating in a string what the code says already is a better solution than something extracting it out of the code? I understand there might indeed not be something out there that does it *now*, but in the end I'd say we should do the right and automatic thing. This way everyone would benefit, even those who don't bother writing custom description strings. Thanks also for caring!
Thanks for the clear error report! The Mocha thing is really weird. Could that actually be some sort of a bug in Node or NPM on Windows? Does Mocha work in any other project of yours when you invoke it directly? Must.js is definitely not doing anything that should interfere with that. Oh, and you don't need to pass ./test/* to Mocha. Just running mocha (if you have it installed globally) or ./node_modules/.bin/mocha will run everything under the ./test directory. PS. About make — mind doing `make --version` for me? Thanks! 
Would you care to link to any resource that describes the process of developing for mobile on Google Closure? I'd like to check it out.
Yes of course, an ideal solution would be better :) For my uses Chai's way is pretty good, I only wish is wasn't so hugely cumbersome to extend properly with (and the other issues). I use this message a lot in my mocha+chai test, although I do use it in TDD assert-style, but is same thing really. And can do some clever things with it: I like generating test cases and assertion statements iteratively. With the source-code base ideal solution the report would not be so usefull. With the low-tech parameter I can just append some ID's or whatever and still make sense of the report.
Exactly.
If you've got a blog entry or tutorial or something about the way you structure these apps, (particularly if they are Rails), then I'm interested. Normally I use jasmine-rails.
Because of more complex test expressions and more detailed and readable error reporting. Say you want to test is an object is an `arguments` array-like. It is a nasty Object.prototype.toString.call type of check. It is not very dry to have that all over the place. Instead make a nice expressive wrapper that dry-ies this up and makes a readable report string. And how do you do deep equality with your way? Comparing one JSON to another? Many test frameworks (mocha, jasmine etc) support equality or comparison assertions to pass the 2 values to the error object, and the reporter can print a diff to spot the exact error so you can solve the problem effectively.
I agree about having tests work everywhere. The `npm test` bit is easy to fix for you by just invoking Mocha in package.json without invoking make in between, but if Mocha doesn't run on your system, that wouldn't help. Did you have a chance to look into what's going on with Mocha's script? Mocha would run the same way how Grunt would anyways so if one doesn't, the shouldn't either. Oh, and thanks. The Make version just says you've got a different Make than the one I'm using. I'm using the standard GNU one. I'll look into that.
343 industries, USA Today, Rdio, Hulu, Quartz, Gawker Media, WordPress, Foursquare, Atlassian, Disqus, Khan Academy, Pitchfork, Walmart, Groupon, 37signals, Stripe, AirBnB, SoundCloud, and Pandora seem to agree that Backbone is the best framework for the job, but hey - it's all about what's newest and built by Google, right?
Looking good, to be honest I didn't write the colour section of it, but what you have makes complete sense. Love a good refactor too, so kudos :)
I always thought it was funny that people use the word `should` so much in their tests. it('should return 3'); Sounds like you aren't really certain about yourself. it('returns 3'); Must.js the assertion library for the more confident tester. If you are totally sure of yourself I would suggest using is.js.
I didn't really read why Sencha Touch sucks in this article. All javascript libraries pick and choose abstractions, then the naming becomes almost unintelligible from there. The only way to "learn" large js libraries is experience. Sencha Touch 2 specifically sucks because the example MVC code does not lend well to any development project scope beyond toy demos. The structure is not expandable or extensible, the architecture of the demos is a memory holocaust and there's no other guide as to what to do with Sencha Touch 2 keywords and idioms bandied about. Sencha Touch 1, on the other hand, a great framework. I've done many projects, successfully, with Sencha Touch 1 (previously ExtJs 3) and it is still my go-to, 1.5 years after I've last touched mobile web development.
Hmm, did you try running `./node_modules/.bin/mocha` just as is, without giving it an argument to `node`? Perhaps NPM creates a cmd.exe compatible batch script that's not a JavaScript file the way it is on Unix platforms. 
That's true, asserting simple equalities either which way is more of a preference question — whether you like the verb-noun-verb style or one where nouns come first. Beyond that, however, wrapper objects (which Must is internally, too) add a set of helper functions to test more complex assertions, including types, arrays, nested objects and so on — things which don't have built-in language operators and would be cumbersome otherwise. Learning only a few of those helpers/matchers takes you a long way. In Must.js case — `equal` for strict equality and `eql` for recursive strict equality and maybe `include` and `property` and you're more or less set.
You two are absolute faggots.
Seeing as Angular just reached 1.0 last year, I doubt these companies are interested in re-writing their entire apps every time a new framework comes out.
Nope. Just sat their being spammy, but nothing was actually broke per say.
Nope. But I can use the global `mocha` for now and leave these silly cross platform troubles (as was my original intent when I posted.. lol ;) I'm making a ticket for an issue I found. 
I'm a fan of node's built-in assert library and test libraries that heavily borrow from it: assert.equal(a, b) // same as a == b assert.deepEqual(a, b) // for deep comparisons assert.ok(a &amp;&amp; b) For each of these comparisons you can optionally prefix the function name with `not` to negate the comparison and you can put a description as the last argument for friendlier error messages.
Yes. :-P And as the long answer — you can add properties to global prototypes in a safe way — defining them non-enumerable. This way they're exactly like built-in Object.prototype properties such as `ownProperty`, `toString`, `propertyIsEnumerable` and others. When you iterate over your object, those won't show up.
Stupid name.
This is a case where reusability has trumped expressivity. Directives are nice when you want to reuse something widely, but there really should be a more succinct way to animate just one thing in one particular way. Writing reusable code that doesn't get reused isn't always good.
I've had that discussion with a friend once. :-) He followed the "it returns" style, while I argued that it's a false statement as the intention of a test is to actually find out *if* something is true, not to state that it already *is* true. *Should* is indeed also the wrong word as it's more of a suggestion that *allows* for the possibility of falsehood. I'd argue *must* is the exact word, hence Must.js. ;-)
Basically, the big idea is that if you fully annotate your code and if you use the Closure Compiler in its advanced mode, it will perform extensive dead code elimination and you'll only ship those parts of the libraries which you actually use. This helps with download/parsing/execution times and also with caching. This means that you can use massive kitchen sink libraries without having to pay the price. Dart's compilers (dart2js and dart2dart) also do this kind of optimization. Supposedly, TypeScript's compiler can output CC advanced mode compatible JavaScript. Well, I've never tried or looked into this, but if it works, it would be another good option. Now, the problem is that you need a framework and/or libraries which were created for one of these options. Some random run-of-the-mill JavaScript library won't do the trick.
This entry and the parent entry demonstrate a profound lack of understanding of object orientation. &gt; We could try solving the problem with traditionalinheritance leading to classes like Transaction , LoggedTransaction , AuthorizedTransaction ,etc. Wow. That is just... wow. How about Transaction class with properties IsLogged and IsAuthorized? You can go nuts with these. IsCompleted, IsFailed they are all the rage now. PS a mixin in "classical" languages (by which I presume you mean statically typed) is an abstract *class* which means it can only be implemented with inheritance, forcing the developer to strictly first extend it before an instance of a derived type can be created. 
Thank you
The very next statement was that you still end up repeating yourself if you have a non transaction that needs logging or auth or whatever. You *can* go nuts with those... And not in a good way! Each aspect you add 'classically' multiplies the number of potential units to test. Doesn't matter if it's one Transaction class with properties, or subclasses, you'd still need to test all the combinations. Instead, this way lets you test the part that you need. Auth, Logged, Future and Transaction. 4 unit tests or 8, which do you prefer to maintain?
&gt; No need for the personal attack, [...] asshat. Right.
&gt; They're just spreading the work of JS into the HTML. This actually decouples it a bit more and it also makes it easier to test. Now your code doesn't need to know how your markup looks like (because you won't do any traversal) and you also won't need any markup to test some function. So yea, while it may initially look a bit weird, it's actually a very sensible trade-off if testing is important to you.
That's called "putting the horse before the cart" in classical languages. Designing your system for ease of testing is analogical to designing a car for ease of testing. Technically, the Transaction class should have two enumerated properties indicating State (in progress, complete) and Status (success, failure) so that their cross join combinations represent all *use* cases (4 or 8 or 64 should be determined by requirements not class definition) which would and should be extendible to accommodate new and changing requirements and the unit tests should test individual use cases not the classes' efficacy for unit test writing. 
You have some interesting ideas here, especially with the passing of an array to specify valid origins, all in one go. I'm going to have a read through your code. I tackled nearly the same problem a few weeks ago: https://github.com/dwighthouse/PostComm.js My library's focus is both the security of postMessages and managing the routing of messages from potentially dozens of iframes or windows. It is more focused on the routing and doesn't help much on the setup, leaving it to the user (currently) to manage creation and loading detection of the iframe or child window. I'm interested to see what you think of it.
Who is setting the requirement for that transaction class?? You? Me? And how did the clearly hypothetical example turn into an instance that you can argue requirements for?? My question, which was not rhetorical, was 'which do you prefer to maintain?' It's suggesting that most programs spend most of their shelf life in maintenance, so make sure it's easy to maintain. Analogous to designing a car that can be easily opened up and fixed, instead of welding the hood closed, once you put the engine in. The hypothetical class was meant to suggest a little core class that you might want to extend later on, without blowing regression tests, and without causing exponential growth of the test cases. I don't think that reasoning is misguided.
knockout is included with ASP.NET MVC 4, so lots of developers are getting it by default. its purely a data binding library, unlike the others which do data binding as well as other features. If you have developed any WPF applications and used the MVVM pattern to do data binding to the UI, its very similar, so i think thats a big plus and reason why microsoft pushes it so much (also, the guy who wrote it works there, and i doubt ms would push angular)
&gt;This entry and the parent entry demonstrate a profound lack of understanding of object orientation. That could certainly be true. I studied applied math instead of CS, so like most people who self-studied a subject, parts of my knowledge resemble swiss cheese. &gt; Wow. That is just... wow. How about Transaction class with properties IsLogged and IsAuthorized? You can go nuts with these. IsCompleted, IsFailed they are all the rage now. If I understand you correctly (and I probably don't) you'd pass in properties on initialization of the Transaction class to determine whether to run say, authorization? Something like? ``` var trans = new Transaction({ isLogged: true, isAuthorized: true }); ``` But then don't you end up with a bunch of code hidden behind flags in your methods? function method() { if (flag1) { // do something } if (flag2) { // do other thing } // do the thing the function actually is supposed to do if (flag3) { // do other thing } } In the end you don't really want a lot of different types of Transaction. You want a transaction class that meets all your requirements. But many of those requirements are probably shared among many methods, or among other methods in other classes that might not share a common base class at all. For things like auth checks, which you're probably doing all over your application, you'll be repeating that code. Certainly there are other ways of solving that problem, but this approach seems like something that works particularly well with JavaScript. Given that (1) there is [an entire programming paradigm](http://en.wikipedia.org/wiki/Aspect-oriented_programming) dealing with this, and (2) the functional mixin approach is one of the building blocks of [Twitter's Flight framework](http://twitter.github.io/flight/) that there's probably value here that you're missing? Perhaps I failed in articulating it clearly, but I urge you to take another look. Or perhaps look at the articles / talks I linked.
I believe you are downvoted because you missed the point: Google's Closure Compiler won't save you from frustration with frameworks, only from some wasted bytes. Also, I dislike the idea of having different versions of Code for different devices. The web and its standards are about "one for all". This is usually bound to throw a cog somewhere you will be hard-pressed to debug. Still, I can respect that you didn't give up in frustration, even if your reasoning may be flawed from my POV. Have my remedial upvote.
Why, thank you. Same to you, random reddit bot.
Whatevs. You wanna wax lyrical 'bout maintainability? You win. I was coming from 10 years of professional experience with OO and JS and 20 years of experience and I can tell you that guessing what the requirements *will* be is a baaaad approach. Trust me - you're gonna paint yourself in a corner this way. Your unit tests are gonna be worthless cuz they cover fringe cases only and your 'maintainability' is gonna be the same because you'll find yourself making changes to the superclass sooner rather than later. 
no i did not miss the point. he said for the best go do some vanilla, frameworks are big because they do crap for you. Here you have the best of both, you have a complete framework availible to you, but only the bits you use are included, I know Lavaca uses arm, but compared to closures dead code analysis arm is a joke. So you have all of the advantage of writing plain ol javascript without actually writing plain ol javascript + you have all of the advantages of using a frameworks wihtout this these main disadvantages. 
As I already said, there may be different points of view for different developers. From mine, you missed it. &gt; frameworks are big because they do crap for you. You are right. Yet, most of the time, it is not crap I want to be done, that's why I'm frustrated with most frameworks. Don't misunderstand me, I'll gladly use tools and toolkits for some parts of bigger projects, but I usually try to keep it to a minimum - especially for mobile. &gt; So you have all of the advantage of writing plain ol javascript without actually writing plain ol javascript No, you don't. One of the main advantage of writing plain ol' JS is the lack of abstraction layers that keep you from concentrating on the neccessary and attaining an optimal performance.
but we build complex sports gambling mobile sites. Our whole application gzipped and downloaded is 64kb, if someone hits a page on one of our sites for the first time, we prerender the content on the server (so you immediately get your html- no load latency) so serving a complex page, full of content which then keeps itself in sync with data from a server (we use push and the occasional poll) is super dooper fast. Things we have developed to make or lives easier is code generators to remove most of the crud, we take a completly different path to binding than lets say angular, which has to parse the templates on the client side to be able to do binding, closure templates (apart from being able to be used client and server side) compile to javascript which you then compile into your app, so we tapped into this compile phase to generate our binding code, which then gets type checked as well, so no need to inspect the dom or parse templates, all binding (except listening to dom events) is late binding (thus only if a model invalidates would we deign to inspect the dom).
You, me, we or someone should really do the ideal solution! The thing with unideal solutions in libraries is that we'll be stuck with them for pretty much eternity. It pays to be conservative in APIs for that reason alone. I'm known to use generated tests too! The confusion arising from them should, however, be minimal: - First, a single test case should test a single thing. Usually that means a single assertion per case, but occasionally a few. The case's clear title would describe the assertion(s). - Second, generated single-thing-testing test cases are usually wrapped in a `describe` block would take its dynamic nature into account in the title. That would save duplicating that info in each individual test case title. Given the two best practices above and the line-extracting capability we talked about, I think this would be entirely solved!
Oh, but I do understand. Yet, since I don't include other libraries and hold my code concise, there are no 90% of dead code to be filtered. Until now, I build a mobile mail and a search app, the mail app being the biggest with about 5k LOC in the frontend (about 8kb JS). Also, it supported even feature phone browsers by graceful degradation. No frameworks or toolkits were used, no JS was abused to do stuff that should be done in HTML/CSS. Still, the functionality of both apps is on par with mobile apps from the competitors, with the added advantage of excellent performance and loading/rendering speed. &gt; I think we differ conceptually... I wholeheartedly agree here. What class of problems do you intend to solve (and why do you think you need to rely on a framework to do so)?
that is just plain worng, it may draw 0.2mA in deep sleep not while running (or mybe when it's running at 1Mhz. at full speed without IO the stm32 m3 consumes about 15-17mA
Ugh, while this is a good article it just reminds me of how terrible JavaScript is. There's nothing natural or idiomatic in a single one of these solutions. I've been writing JavaScript every day for several years now and I had to think a *lot* about WTF was going on with the examples. **Edit:** Now that I've had some caffeine I think I figured it why the article examples were so hard to follow... The insane use of whitespace in the code. It's everywhere! I'm sorry but it is never OK to write "console .log (whatever )". I'm hoping that it only shows up like that because I'm on my phone.
Best practices are nice, but I like to be able to be flexible and creative with my tests cases and not be overly limited by how the runner/assertion/reporter or community proscribe me to use it While some are indeed those neat few-assertions-per-case, but I also stack them deep for complex objects and/or add helper wrappers that can test recursively. Or I might use a test suite to bulk test data and use a JSON to generate 2 levels of describes() and it()'s with appended string titles and beefy chunks of asserts and some of those nested helpers. Mocha bothers me in creative usage in that you cannot have asyncronous describe's and it demands you make al it() calls up-front, which makes it harder to do certain things. I found this in my bookmarks (forgot about it yesterday): it is a decent attempt at doing RSpec in JavaScript: https://github.com/abe33/spectacular which does a lot right. You have to wave away the smells of translated Ruby concepts instead of sweet Vanilla JS (and all demos are in CoffeeScript.. ) but it might be very good. I'm a bit backed-up up with other projects so I cannot commit to pulling an https://xkcd.com/927/ on this :)
you could always do var me = this; and access `me` within the private functions. It's what you'd normally do in JavaScript in these situations.
I don't like the fact that you seem to be needing globally declared functions to be able to make them into this Class format. I think it would be much nicer if your extend method would accept anonymous functions as well, and return the actual function of which should be instantiated. So instead of this syntax: //Create MyClass by extending Class. Class.extend(function MyClass(){ //Classes can have constructors this.constructor = function(){ //... } }) console.log(MyClass) //=&gt; "[Class MyClass]" console.log(new MyClass()) //=&gt; "[Instance MyClass]" Make it so the syntax can be: //Create MyClass by extending a function. var MyClass = Class.extend(function (){ //Classes can have constructors this.constructor = function(){ //... } }) console.log(MyClass) //=&gt; "[Class MyClass]" console.log(new MyClass()) //=&gt; "[Instance MyClass]" As you're supposed to mess around with globals in javascript as less as possible.
Some amount of automation is surely useful, but I'd keep away from overly advanced tests. As you yourself saw with the pull request, even fixing a single line in a test could introduce a false negative. And once it looks like tests require tests, I think it's going too far. What was the particular case where you found creating tests based on an outside async source was the best solution? You could instead of large test-cases generate another nested describe with small test cases and generated test-case titles. I remember seeing Spectacular some time ago. I think it's absolutely awful. All of the bad things from RSpec incl. overly abstracted DSL and free-flowing global matchers. But, hehe, as you might've noticed, its author also thinks `it` blocks are the places for descriptions, not assertions themselves. :)
wow, that is not the best way. How can putting in placeholders for something that may come down the line ever be a good idea? And what happens when you want to put that functionality on other classes? That just shows why there is AOP now in Java - because it handles the situation where you want to add extra functionality easily where as classical inheritance just doesn't cut it. A flat inheritance structure with constructors that are composed out of several mixins is a great way. I transitioned Dataminr over to that and everything became easier. The modules are better defined, we have less debugging issues, there is less code, it's easier to prototype something from the beginning - usually I don't like to say something is "better" without some trade offs, but in this case it just is as long as you're consistent with your naming.
It bothers me that elements = 5 but only 4 rings are displayed. Two solutions to this below... With hole in center of rings ([jsfiddle](http://jsfiddle.net/sySRz/)): 29. app.config.lineWidth = (shortest_side / 2) / (app.config.elements + 1); 30. app.config.radius = app.config.lineWidth * (app.config.elements + 1); ... 128. var factor = (i + 1) / (app.config.elements + 1); Without hole in center of rings ([jsfiddle](http://jsfiddle.net/kNmWy/)): 129. var radius = app.config.radius * factor + 0.5 * app.config.lineWidth;
It's worth pointing out that in CoffeeScript, you don't have to do: ``` Calculator.arithmetic = (-&gt; # some code )() ``` Instead you can do this: ``` Calculator.arithmetic = do -&gt; # some code ```
yeah,ES6 spec was supposed to be finished by the end of 2012,now they are saying 2014. By 2020 we may be able to use ES6... Instead of creating all these spec, they should add 4/5 important features and ship the damn spec. ES4 failed because there was too much stuff in it.
It breaks scrolling when the cursor is hovering over the lists
I don't unfortunately. Not yet at least. If I do, it'll definitely show up in this empty-as-of-now feed: http://themoll.com/feed :)
Yeah, and definitely don't use AJAX at all, since it came from Microsoft. XMLHTTPRequest is the devil's work. 
Yet your code will not work with or "Klass" libraries because they all implement classes their own non compatible way. Until JS gets "real classes" , i would suggest people not to use these libraries like yours.
The more coffeescript I see, the more it turns me off. 