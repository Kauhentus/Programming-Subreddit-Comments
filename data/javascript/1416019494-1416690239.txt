Yes, this.
Eventually we'll all learn to live with the fact that it's pronounced both ways.
This is less of a plugin and more of a website. The cron.js file inside js would be more of a plugin. As its portable to other codebases.
I usually say "ess queue ell", but occasionally pronounce MySQL as "holy fuck you useless sack of shit".
Or we'll die in a bloody and merciless war, with the GIFS fighting the GIFS.
Thanks!
If this is a desktop app, forget about AJAX. AJAX is something you use in Javascript and Javascript is not Java, I think you were getting those two mixed up. AJAX can interact with the server yes, but within web pages only, it doesn't work with desktop applications. Now, this kind of application can be made in whatever language you want to as long as that language supports HTTP requests. I've recently made a desktop application like this and I used C#, but you can use Java if you'd like. I don't know what's your knowledge level on this area but before you advance into something like this you need to have a basic understanding of HTTP requests and concepts like headers, parameters, cookies, status codes, HTTP methods like POST, GET etc.. Some sites you can just send an HTTP Post request with the right parameters and they'll send you a response, what this response will contain is up to the website, it could contain the information you are looking for or maybe it won't. To know this type of things you'll have to analyze the request and see what is the response. You can use various programs to analyze HTTP requests like HTTP Analyzer, Fiddler, or even your browser's developer tools. If you want to interact with websites where you have to be authenticated, things are little bit more tricky, you'd have capture the session cookies and "save" them in the request. And once you're logged in, you'd probably have to use some sort of API provided by the website for you to be able to access what you want. If the website doesn't provide you with any API, I think the only way would be to get the contents of each page and parse all the HTML to find what you're looking for, but that would be a lot of heavy work. These kind of applications are very specific, because every website is different and they don't all respond the same way to the HTTP requests that you make. Your requests have to be made to pass the correct parameters, headers, cookies and HTTP methods for that specific website. But basically, you can find out what are the correct values by using a tool to monitor HTTP requests like I said above, just run the tool of your choice and access the website through your browser and analyze the requests made between each page that the tool shows you. Try to understand these requests and what's being passed between them, like headers, parameters, cookies etc... After you understand what's going on, try to implement that on the language of your choice. You can google alot of examples in Java/C#. It's alot of work but it's a fun project :)
Me llamo T Bone
Gross
You have no clue what you're talking about
Because you never actually got past the design phase
This is simple: The g is for graphic, not jraphic. Don't care what that dude says. 
I pronounce it "why aren't we using Postgres?"
Downvoted for speaking the truth. 
I recommend never picking it up in the first place.
I've never heard anyone pronounce it any way other than _jay-sawn_. 
ITT: 0 Consensus. Jason or Jay Son, Jif or Gif, Es que el or Sequel. Verdict? Fucking tomato, tomato!
Parents can name kids as they like, wont prevent them from adopting other names.
&gt; That was the joke, *json*.
As someone called Jason, my ears prick up whenever I hear my colleagues talk about JSON in the office. With my initials being JS, I know that I am JavaScript.
Here is the jQuery plugin: https://github.com/Marak/cron-editor/blob/master/js/jquery.croneditor.js Fully portable and ready to be re-used in other projects. The cron.js file is a browerified version of node-cron, it's a vendored dependency ( which is actually not even being used at the moment, read the source code )
YAML is the stuff of headaches...
Hey guys lets be totally insane and write a data format dependent on white space!
GOG, Virgin America, Udacity, the Guardian, and MSNBC are Angular sites. GM's in car interface is using Angular. Interestingly, Udacity tried Ember but went with Angular.
Yeah, I was just doing the "gi" ones.
Hey friend. One of the most important tenets of testing knockout code is to make sure **ALL DOM MANIPULATION IS OUTSIDE OF THE VIEWMODEL**. You should rely on the built in data-binds as well as any custom ones you make to handle actually manipulating the HTML on the page. This means you should never ever see a $(selector) in your viewmodel, because if you try to run a unit test on just your viewmodel file, it will not be able to find the nodes you're looking for. Now that that's cleared up, testing your viewmodels should be really easy. Functionality like ensuring that ko.computeds have the correct values after modifying ko.observables is a really great place to start testing. var Viewmodel = function(){ var self = this; self.firstName = ko.observable('Bill'); self.lastName = ko.observable('Clinton'); self.fullName = ko.computed(function(){ return self.firstName() + ' ' + self.lastName(); }); }; Now you can easily write a unit test that asserts that fullName looks right: QUnit.test( "Name Test", function() { var vm = new Viewmodel(); vm.lastName('Burr'); ok(vm.fullName() === 'Bill Burr'); });
XML is like violence. If it doesn't solve your problem, use more.
Gee, I couldn't tell.
http://jimmyjohns.com
JON... The S is silent. **J**avaScript **O**bject **N**otation
deruloooooo
Mine are JMS. I am elite 
How does it differ from postal?
Or being called other names by other people...
Language evolves, but generally proper nouns do not change too often.
finally some real examples, thank you. 
Please admit defeat.
je son
ITT: minor variations of the exact same comment
"Jotapegue"
First Red Ranger. Jason.
Thought I was the only one!
Interesting. I would like to see examples in the readme of how this impacts unit test code (mocking, etc). That is one major feature that I look for with IOC/DI.
I don't like modifying the fundamental object prototypes. I would prefer using a closure function: function grep(regex) { return function(el) { return regex.test(el) } } ['foo', 'bar', 'baz'].filter( grep(/b/) ); or just the native array-filter: ['foo', 'bar', 'baz'].filter( function(e) {return /b/.test(e)} );
I've pretty much switched to calling it "jay-sawn" too, but if I'm talking to someone I say it however they say it... just to not be douche-baggy.
&gt; jizz-on The debate is over, people. I am declaring a winner.
I think 'git' would be suitable in your list as well.
Like this https://www.youtube.com/watch?v=RbtPXFlZlHg
Yayson! 
i mean come on. this is fine and dandy, but in reality unless you have the option to start a new enterprise project with this, the rest of us are looking at this and thinking, "ok, love it. But how am I going to integrate this into my hand-me-down-dinosaur-legacy-bull-donkey code i had to adopt. other than this i think its pretty swell. :)
Not convinced this is more clear than vanilla maps etc. Are you using ES6 yield?
Thank you :) I will take this into consideration :) 
Some exist, like ext.js but you should really ask yourself if that's a road you want to go down. You're buying into ecosystems of pain
I don't think so, XML has its strengths just as JSON does.
Siobhan is an Irish name and in Irish "bh" gives a "v" sound, bh√≠ is pronounced vee so this isn't someone randomly choosing it, it's how the language is spoken 
No generators/yields as of yet. Those can be used for different purposes. Filter and reduce mechanisms, in conjunction with emitters, provide more features than their vanilla counterparts. For example, filters and reducers against sources of non-finite size. Mapping itself really isn't that interesting (aggregation of multiple invocations). 
I say Jay-San
Seems like an anti-pattern, frankly. If you need your state to be not-bound to your required objects, you should be wrapping those in a function to be executed later. If you really must, you should explicitly be deleting the cache here, as this will cause unexpected behaviors if elsewhere (e.g., other libraries in the app) these values are expected to be set already; this is hiding a global state modification.
npm version of what? node-cron? you should, as it's a separate project.
I wonder how many "regular" Guardian readers got as far as the phrase "a superset of ES6" and went "nope, this article is not for me"? 
Been using it since FF27 or something to get access to the ecma6 features like arrow functions, let, spread operator/rest parameters, promises etc. Whenever I have to use/write javascript for other browsers everything seems just so clunky and unwieldy. Chrome might be faster, but firefox is the one pushing ecmascript forwards. Btw, they have changed the ecmascript 6 compability table: http://kangax.github.io/compat-table/es6/ Before Aurora 35 had like 86% and were basically only failing on "Symbols", but now it fails a lot of tests due to "return" being used outside of functions for some reason. PS: If you use RES make a backup before switching to Aurora as it might reset it. The settings is located at: [profile]/jetpack/jid1-xUfzOsOFlzSOXg@jetpack/simple-storage/store.json
how to you install it on ubuntu, is theree a DEB or ppa? 
True, but it is on something called "Developer Blog" so I'm guessing it isn't normally shown in a spot that "regular" readers would see.
Dropping SOAP leaves you vulnerable to many backdoor attacks
Codeacademy won't get you anywhere near intermediate level in any language. It's built to help beginners with little to no experience at all. 
Telling the unique browser maker that is independent of corporate interest to run off and die quietly is a very naive thing to say. The web ecosystem needs variety to be healthy. It needs different engines and implementations. Without it you can't have the standard bodies working. Right now, to move something into standards consideration, you need two independent compatible implementations of a given feature. Without Mozilla, you have only Google, Microsoft and Apple playing on that field and none of these entities have the user values as their priority. You may prefer other browser than Firefox, no one cares about you personal preference. What people should care is that without Mozilla it is one less independent implementation and the only one that put users first. For example, Chrome implements tons of features that are not standard. When you pull such stunts, you're effectively breaking the web because the one thing the web has going for it is its interoperability between clients. Your phrase "run off and die quietly" means that you don't take interoperability, user values or standards seriously. You also don't have respect for the group of people that worked for free since the days of IE dominance to keep the web a healthy place. Instead of saying such stupid things, you should consider what you want the web to be in 5 or 10 years. Do you want your privacy protected? Do you want gaming? What do you want? And who will listen do you or care about your needs if Mozilla is no longer in play.
Please read my edit. You know as well as I that during the interview you "separate the wheat from the chaff"; if someone looks too good to be true on their resume and then doesn't follow the norm, then I'm going to look closer. I know there are some of us that are just different, people who were calling gif's the way they are "supposedly" be pronounced from day one and chooses vi over emacs. I get that. I didn't say that I wouldn't hire them, they just better know their shit. But I know no one has interviewed with you claiming to be more than they actually are, amirite?
There are many tools that Chrome has that Firefox doesn't but there are also tools that Firefox has that Chrome doesn't. Both browsers are great but only one is developed in the open and actively listening to you. If you have feedback on Firefox DevTools or need a tool that is not there you can use https://ffdevtools.uservoice.com/forums/246087-firefox-developer-tools-ideas to voice your wants. Many of the new tools were implemented according to user wishes. If you haven't looked at the current Aurora channel (aka developer edition) tools you may find some stuff that is not on Chrome that is very useful.
I've stayed with backbone through it all and have no regrets. Angular is pretty painful to work with.
Codecademy is a great resource to gain exposure to a new language, but yea, it's like a 101 course. You won't leave knowledgeable, just a little less dumb 
From what I've read on some programming subreddits and from my own experience, feeling dumb and imposter syndrome seems quite common in the field. I think the key here is trying to use this whole feeling as motivation rather than demotivation. Besides, the feeling of accomplishment you get after solving a particularly difficult problem is all worth the feeling dumb part :)
testing should ideally reset the environment for each step/group of steps. and you should test your code as it would in production...
Keep up the good fight my friend.
Good point. This library doesn't help directly with testing. By following a pattern of never using bare node require however and always injecting modules it sets you up for tests. I rewrote this library from a previous proprietary implementation. In that project we had hundreds of unit tests where all modules used this strategy. It works exactly as you would think - you write mocks and fill up the container with the dependencies that the module under test needs and then off you go with your favorite test runner. But you make a good point. The docs should highlight how to setup tests and could even be opinionated about how to load them and run them. It's the main benefit of having this kind of application structure of course, besides the obvious benefit of easily wiring together lots of small loosely coupled modules for better organization and code clarity. 
Looks like I can start telling my boss "well it works in IE"
Thats good then lol. Thanks for the upvote, I'll give you one in return ;)
 sudo add-apt-repository ppa:ubuntu-mozilla-daily/firefox-aurora sudo apt-get update sudo apt-get install firefox This is the daily (as opposed to nightly build) so it might be buggier. You could also get the pre-compiled .tar here: ftp://ftp.mozilla.org/pub/mozilla.org/firefox/nightly/latest-mozilla-aurora/
I don't think learning something new has ever not been worth it. Angular is a fantastic framework and has served me well for the past couple years. There's a lot of alarmist notions going around about the large changes Angular 2 will bring, but Angular 1.3 will be relevant for a long time to come, as so many large applications have already been built on that paradigm. Honestly, you should give yourself a project to do in each of a few frameworks to figure out their strengths and weaknesses. Then use the right tool for the job. I strongly suggest checking out React, and don't be afraid to also look into Backbone. Edit: I wanted to give you more info about my experience with Angular. Angular's main thing is that it really is a total framework. It gives you almost everything you can need for making basic applications: this makes it kinda heavy, but because it's so popular, if you use a CDN chances are higher than normal that the user might have Angular cached already. It is also opinionated, which is good because it'll act as a guide, but bad if you want to do something really out of the ordinary. One of my biggest gripes is that if I find a cool library or something and want to use it in my Angular app the "right way", then I'll have to find an Angular version that does the same thing, make a wrapper, or just port the functionality myself. The flip side is: Angular is so incredibly popular that most of the good things out there already have Angular versions. With most of these frameworks, if you're used to using jQuery, you'll have to get used to taking a hands-off approach to the DOM. Angular, Ember, and other frameworks want you to do everything through them, which can be a pain sometimes. Backbone is very light and acts more like a library. I've heard good things about people coupling that with React, and more recently I've heard of people shedding even Backbone in favor of a React + Flux mix. React is a fantastic view layer (the best you can have, IMO). I'm experimenting with it at work right now and have loved it so far. But that doesn't mean I'm divorcing Angular. React will just become another tool in my toolbox.
Well, yes and no. Maybe. It probably all depends in the *context of your framework/library/whatever*. I guess if your framework presents itself with a tone of "hey, blackbox me! You don't want to know what's going on inside me at all except for what I tell you", then probably you don't even care about getting a proper call stack trace. (Still, that doesn't mean you couldn't produce that same information in another way.) OTOH *I* (and the emphasis is there to remind that this is just my opinion - see note at the end) do like a proper call stack and I do like knowing what's going on inside the framework I use. *Specially* when something is not happening as I expected to. Maybe it's just a personal preference. What's more, while the original problem is "oh, dear, having `(anonymous function)` in the call stack trace doesn't tell me *which* function it is", the proposal is *not* a solution to that. The proposal is "let's do this other thing instead". `"Loaded data from /some/url"` still doesn't tell me which function is it. NOTE: Anyway, as I pointed out, don't take my opinion to mean that there isn't or there will never be a use for this where it can help someone. Just that... well, it's unnecessary, the original problem can be solved in other ways (naming functions) and it's actually abusing the call stack trace.
It might be useful for some of you,and I'd love to get constructive feedback.
This. There will never be one framework/library to rule them all. All will have pros and cons and be good for different things. So the more you have experience with the better. Plus practicing programming is always good.
Your code would be much more clear if you broke it out into a recursive function that navigated the object structure which accepted a callback that implements the functionality you want. Thus de-coupling the act of traversing the structure (generic) from the act of creating menus (specific). Why libraries like underscore or lodash do not already have a recursive navigation method is beyond me - I've wanted it more than once before. So you'll still have to hand roll one. However you should pull in and use one or the other (preferably lodash) since they make iterating arrays and objects trivial. 
Just took a quick look. So basically replace functions with evaled strings?
@deviousfrog314, "eval is evil", so no. there is a parser service that parse the expression and actually gives you to pass a safety expression instead a tedious callback. in addition to that, `agile.js` gives you basically things that `Underscore` don't, e.g: pass a nested properties as an arguments, and more..
__TL;DR__ - *Use it where it makes your job easier/faster/more enjoyable, but don't listen to people that want you to build the whole thing in Angular. Rails+Angular is awesome (see example below). For easier with less learning curve, use Rails with Twitter Bootstrap or ZURB Foundation, and ease into being `ng-awesome` at your leisure.* I'm a web developer who's been focused on front-end for a few years now. I can say that, as someone who was already senior-level when I first worked on a project using Angular (the startup where I currently work‚Äîit was already most built), that it is one of the trickiest to truly "get". It's almost as if the simplicity of the whole 'back to the declarative way' threw me off. If you want to just build stuff really quickly, I would suggest Rails. Even when I'm building something for which the main logic is going to be centered around JavaScript, I still find myself just doing `rails new` first. # Pro The main pro for Angular is that once you get it, it's pretty nice‚Äîin the kind of way that makes you happy-sigh. This app right here is an example of that, IMO: https://github.com/mkwiatkowski/todo-rails4-angularjs I'd direct your attention to two files that most effectively illustrate how well the two work together. Of those, the Angular one is the `'Task'` service: https://github.com/mkwiatkowski/todo-rails4-angularjs/blob/master/app/assets/javascripts/services/TaskService.js.coffee Then the Rails controller: https://github.com/mkwiatkowski/todo-rails4-angularjs/blob/master/app/controllers/api/tasks_controller.rb There are some details (see the blog post from the creator of the project here: https://shellycloud.com/blog/2013/10/how-to-integrate-angularjs-with-rails-4) but this is pretty much all you have to do in order to get the two to talk to each other. I'm currently building a whole new feature for our application (a tool for shippers to manage their service areas visually, rendering them dynamically on a map‚Äîfun, cool stuff), and I've actually started using this pattern (meaning the way Rails and Angular talk to each other in the above app). # Con My one main gripe about Angular was feeling that the other devs were forcing me to "drink the kool-aid"‚Äîthey wanted everything that was JavaScript to be done "the Angular way". Sometimes it just isn't worth it. Example: There was this one page‚Äîit was a print-only page, an invoice to go with shipments, meant to be on a clipboard, etc. Anyway, there's only one of these, and the requirement for this feature was that once you click the button to get this invoice, it prints automatically, so I just threw some plain ol' Vanilla JavaScript at the end of the document body to do just that: ``` document.addEventListener("DOMContentLoaded", function() { window.print(); }, false); ``` The lead developer at the time let the code ship, but only on the condition that I promise that I would go back and wrap it in an Angular directive. I agreed, and the code shipped, and it of course worked just fine. Fast-forward to the present: it still works just fine. I have indeed wrapped many (maybe even most) of the new reusable JavaScript logic into directives and I am absolutely smitten with services, but I don't like the whole "do it the Angular way" business. And that's coming from someone who now uses Ruby and Rails for pretty much anything where it's an option. The motto with Rails is "convention over configuration", meaning, just do everything "the Rails way" and it will be so easy/awesome that you won't mind having to do it exactly one way. That almost always works for the back end, and that's great, and I've been drinking that kool-aid for a while. But even there, sometimes you have to break with the convention. I have this ginormous database table of huge polygons (for that map stuff) that I needed to partition, because just the index for this table is *several gigabytes*‚Äîand we're just a few months in! Rails 4 doesn't have a gem for this yet, and I needed to get it done in two weeks, so I just got it done‚ÄîI wrote the partitioning triggers in SQL (you can just pretend this is Star Trek, and all the technical stuff is made up‚Äîit's about the *story*) and got it done in one week. The point is, if I'd just been like "Argh! But what about 'convention over configuration'?", I may not have actually built the thing I needed to build. And that's the whole point. 
This is good news, obviously, but it's going to take more -- *a lot more* -- before I'm convinced that Microsoft is interested in pushing the web forward. We know what happened when IE6 was the "best" browser available... it stopped. It stopped right there and the web stopped with it. We (collectively) can't let any browser gain that sort of dominance ever again. Still, this is good news in the sense that there are more viable options for browsers.
Developing a game will be more than the scope of this book. restaurant emulator, yes. your suggestion reminded me of another problem I was once asked to solve. 
Thanks a lot, this is exactly what I wanted. I've modified your script a little bit so it adds navigation menus on a TwitterBootstrap theme instead: http://jsfiddle.net/prahladyeri/cm8ffm4p/ (Of course, you can't test it with jsfiddle as there are no bootstrap dependencies there).
I don't think there is any worry that IE is going to stagnate again. MS has too much competition to worry about. If anything, I would worry more about Chrome given the uptick in "Works in Chrome" only sites/apps. 
no shit if i did why would i post this question? asshole
Coffeescript is not Javascript. This belongs in r/coffeescript. 
I dunno. I've used it for projects at work but not really a big fan. I'd say do some projects with it then move on. Angular only gives you one view to work with. Designing an app that has even moderate complexity quickly turns into a mess. I greatly dislike the use of using attributes in html for template logic. Our templates are confusing messes of layout and logic. It's kind of like old xml based templates you'd see in Java systems. Maybe it's because I got started with micro frameworks like Mustache and Backbone that makes me not like Angular. I like having my view logic in a controller, not mixed with the view template. Last thing I don't like is how $scope works. In small apps everything is fast enough. But complex apps can really get slow if the dev isn't extremely careful. I think the automatic updating of templates when values change is nifty, but I also don't mind writing code that does it explicitly when I tell it to. 
Actually, you can do bootstrap on jsfiddle (though I have not tested it before) :) No problem, good sir!
Yep. No need to get all religious about pronunciation. :)
From what I understand it's good mostly because it's popular? 
Sure but you get to choose between learning the version everyone is actually using right now but soon to be outdated, or the version nobody is using yet but is the future of the framework. Actually it's worse than that because you can't really learn the new one yet.
Microsoft was launching a variety of efforts to reduce IE6 usage as far back as 7.5 years ago. That is like ancient Roman times in web years. I can understand that IE6 has left an irremovable scare on your soul, but serously... This is like crying that you had to wait to buy gasoline back in the 70s.
It depends on what timescale you want a return on investment, and how much time you want to put behind that investment. Is your intention mostly to add a skill you might need in a future job hunt? Angular is at a bit of a watershed right now. A new version, 2.0, has been announced for release at some point in 2015, but it won't be backwards compatible. 1.3 will still be supported, but in twelve months you probably won't see anyone building new projects with it. So I'm not sure learning 1.3 purely for the sake of adding it to your CV is worth it right now. For writing small projects today, it really depends what you have in mind. Are you thinking about fully fledged SPAs? Angular might still be worth it, but then again Ember, React and Meteor are all options that have gained a lot of popularity these last few months. If you're thinking about fairly 'simple' applications, on the other hand - like JavaScript forms with persistence, or mostly static pages with some lightweight interactivity - perhaps Knockout would be a better to look at. It has quite a shallow learning curve and works well for producing JS-powered widgets and interactive forms. Really, though, it depends where you are in your career, and what other avenues you've exhausted in the technology. Have you really got to grips with JavaScript yet? Do you know much about unit testing? Dependency management? Test driven development? Design patterns? MVC principles? Functional programming (particularly with monads and immutables)? All of these things will give you a much more long-term payoff than learning the ins and outs of some particular web application framework, particularly when the tech is so immature and liable to change (remember how backbone seemed almost destined to conquer the web 18 months ago?). If you wanted an opinionated list of what to do first, I guess I would focus on core computer science knowledge first, then core JS knowledge (don't worry too much about ES6 at this point), then unit testing (and perhaps dependency injection), then try out Knockout (to show you what you gain from data binding), and then a full MVC framework.
Honestly, its worth learning, even if it gets replaced by 2,0 soon. You'll still encounter material written in angular. Jquery is similar. I don't write jquery often these days - but its important to understand as a JavaScript programmer. It goes into your lexicon of experience, and helps you digest new material.
&gt; My one main gripe about Angular was feeling that the other devs were forcing me to "drink the kool-aid"‚Äîthey wanted everything that was JavaScript to be done "the Angular way". Sometimes it just isn't worth it. I hear you on that. I ran into that a bit when asking questions online.
Screw backbone... I'm going back to geocities.
Found quite a good SO answer: http://stackoverflow.com/questions/5758363/how-does-event-handling-work-internally-with-javascript
Whoa, calm there lil buddy. Just statin them facts is all.
You can also [browse `dom/events` subfolder in `mozilla/gecko-dev` GitHub repository](https://github.com/mozilla/gecko-dev/tree/master/dom/events).
IIRC FF 35 changed let semantics to match the spec, so it should pass at least some of the let tests (the temporal dead zone test for sure).
The creator of Durandal works for angular now and I'm pretty sure Durandal is going away.
You are not worse but you are also not a pro. Just there's a plenty of water ahead and you're clapping your feet from the pier. With joining codewars you instantly jumped to the water. It will be hard not to drown but you'll live and swim eventually.
Parsing sounds kind of slow compared to function calling. 
Well, that is one of its strongest points, but it became popular because it's also just good on its own.
How did I miss the DOM folder?! That's just what I'm after, thanks.
Valid. I feel the same way. This is the only case I have modified the prototype. I actually like that first method you hacked up.
&gt;tedious callback Tedious how?
- author in CommonJS and make your files small, focused and modular - namespacing is an old-school practice that is obsolete with modules - "classes" and OOP might work well in languages like Java, but you have a lot more freedom with JS. Not everything needs to be a class; and don't force OOP/inheritance on your end-user. - use [tape](http://www.macwright.org/2014/03/11/tape-is-cool.html) to test in browser and node - use browserify or webpack to develop the code in a browser - publish to npm; if you want to support Bower you could also do that (although most people using bower expect a UMD build, which has its own set of considerations) - IMHO if you are building small and focused modules, having tons of comment blocks tend to clutter an otherwise small and easy to read file. But that's just me. - [many more suggestions](https://github.com/mattdesl/module-best-practices) This is just one approach of many. Others might suggest AMD, or DuoJS, or jspm, or whatever.
It's actually not, if you parse it once, make it a function and cache it.
From what I understand, it's became popular because google and not because is the best MV* framework out there, I really don't used so many MV* frameworks so I can't compare but Ember seems like a good competitor
take a look of this example and let me know what do you think https://github.com/a8m/agile/blob/master/example/compared-to-underscore.md
Can't agree more and I've been preaching this for years.
Ember does seem like a good competitor, but I have several of the same complaints about both frameworks. They are both very good solutions to a slew of problems.
I don't understand why that functionality would have to be built into each function. Taking your example of `uniq` I'd try to keep things as abstract as possible, and function composition will take care of the rest. So I'd prefer: uniqBy(key('customer.name'), orders) Where `uniqBy` might be something like: var uniqBy = curry((f, xs) =&gt; { var seen = [] return xs.filter(x =&gt; { var fx = f(x) if (fx == null) return true if (seen.indexOf(fx) &gt; -1) return seen.push(fx) return true }) }) And `key`: var key = curry((path, obj) =&gt; { return path.split('.').reduce(((a, k) =&gt; a &amp;&amp; a[k]), obj) }) Now, that's small, and reusable, and it can be further abstracted. So if you want `uniq` all you need is: var uniq = uniqBy(id) Where `id`: var id = x =&gt; x And now you can do: uniq([1,1,2,2,3,3]) //-&gt; [1,2,3] Functions are not tedious at all, but quite the opposite. 
Exactly as Crockford said. So: Sounds like a friend's name - Jason. Which sounds like JAY-sun. Where both have emphasis on first syllable. 
Same old browsers wars from 1994.
With the current version of Firefox, `let` works in the console or if you use a `&lt;script type="application/javascript;version=1.7"&gt;` tag. It doesn't work without the "version=1.7" (or 1.8) part. Just try it over at JSFiddle. You'll get a SyntaxError.
Anything that you need more than one of which needs to have its own state and functions which act on that state. Doesn't necessarily need to use constructors and prototypes, but that's one way to do it. A thought experiment using your own app - how would you display 2 independent calculators on the same page?
How big is the cache? 
combine your function into one for any target: function blinkEffect(id,color) { document.getElementById(id).style.background = color; } Then write a single update one which calls the first function with the correct attributes for each blinker. You can loop here or hard code it. Its still more manageable than one function that does exactly the same thing for each blinker. function updateBlinkers(){ blinkEffect(...) } Then use a setInterval rather than a set timeout: setInterval(updateBlinkers,2000);
What does a web browser have to do with Interop? Pretty much nothing. "User Values"? What does that even mean? "Standards"? There were standards before, but they keep getting changed. I like how you want to put words in my mouth. It's a web browser, 4% is not a social movement. Chrome doesn't get developed for free. Sorry, but businesses are born and die every day here in the real world. Maybe I should not use any of the 500k apps out there either. If you want to work for free for the great goodness of the human race, more power too you, but don't get all defensive when no one uses you crappy product. You know, I actually have a certain respect for idealism. Ideas are great. Instead of being a butt hurt basement dweller, and calling people stupid, next time try starting a conversation. Some people may be smarter than you, and have worked in the industry for 20+ years and actually know a thing or three. Or better yet, call me in 5-10 years, when this won't even matter anymore. 
Word of warning: This will replace the default (stable) firefox install.
@lokhura Thanks, like I said it might be useful and it might not be. If you feel like you could make things better feel free to PR. also, It's would be great to take a look of your repos and get an inspiration! for now, I'm working on kind of template engine, and this suite of filters really great for me especially because the strings interpolation. About your example... in retrospect, we always can improve our code and make things more "cleaner", elegant, faster, etc.. even this example. But I prefer to really thinking "agile". "make things work, make it fast, make it beautiful" and actually it's true in "real" life 
I can't imagine writing less code to accomplish more. The only criticism I have about angular is that it has a steep learning curve. If you could achieve all the benefits of angular with less conceptual complexity and similar or less code I would change in a heartbeat. 
I'm sure that many many folks in this sub know this, but (for those who may not know) [lodash](https://lodash.com/) is a great lib for similar things. Check out [this roadmap](https://github.com/lodash/lodash/wiki/Roadmap) for 3.0 of note: - lazy evaluation to chaining methods (yay!) - string methods Again, i know lots of us know about lodash already, but it is relevant to the post.
You can write badly performing app in any framework.
At least they support the let block which is the only good let anyway. 
Use CSS animations instead of JavaScript.
well i mean yes but this is just a shortcut to doing that. tbh i'm not using this and i didn't upvote it but it still looks quite handy for people stuck in a pinch testing code in a client's codebase for example.
This sounds great and I will definitely use it for some things (instead of highcharts). But let me say this: Saying it is lightweight (50kb is _somewhat_ lightweight) and having dependencies to D3 (obvious), jQuery and bootstrap just is a little funny
I played around with some Angular on top of Rails today - the front-end felt super snappy! Really nice.
I agree on the first part (Angular 1.3 will be relevant for a long time and hipsters are selling their shares for no reason). The "steep learning curve" thing is, I think, a fallacy. I (no humble brag, I'm just a dude who codes) came to Angular with 0... none... experience in web dev, javascript, nada and in about a week was able to create a 100% client-side app using nothing but directives and factories that took user input and manipulated (filter/search/etc) a d3js directive/graph that was populated from a database. And I didn't fall back on a single line of jquery even though it felt tempting to a few times. It was easy because Angular makes it easy. That's why people love Angular, plus it was probably the most fun I've had writing software. I feel like a lot of the people claiming it has a "steep learning curve" are trying to protect their territory and are disgruntled because Angular 2 is supposed to be even easier, but at a glance you really don't seem to be that kind of person. Just my $0.02. It did take one book, a hundred google searches, and one complete rewrite to do, but it was fast and I'd hardly call that a steep learning curve. The app wrote itself while I learned, that's a hard quality to find in a framework.
oh, yes. that makes sense. i thought you meant automated testing.
Although it would be a good item to add to my CV when I finish education and look for a job/apprenticeship but I also want to build a task manager application and thought something like angular might be a good idea for that sort of task. Although I think I would only really use it for the no refresh kind of features and data binding but looking at some articles online they are quite easy to reproduce in some modern browsers.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**General American**](https://en.wikipedia.org/wiki/General%20American): [](#sfw) --- &gt;__General American__ (commonly abbreviated as __GA__ or __GenAm__) is a major [accent](https://en.wikipedia.org/wiki/Accent_(sociolinguistics\)) of [American English](https://en.wikipedia.org/wiki/American_English), particularly considered the American accent that is the most neutral or lacking in distinctive regional, ethnic, or socioeconomic characteristics. General American is an [umbrella term](https://en.wikipedia.org/wiki/Umbrella_term) for American English pronunciation that is historically uninfluenced by, and so distinguishable from, the various dialects that developed out of the [American South](https://en.wikipedia.org/wiki/American_South), [New York City](https://en.wikipedia.org/wiki/New_York_City), and certain areas in [New England](https://en.wikipedia.org/wiki/New_England). The accent is not restricted to the [United States](https://en.wikipedia.org/wiki/United_States), as it can also be heard among some Canadian speakers of English. Furthermore, General American is a widely taught form of English in non-Anglophone nations. [*[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed)*] &gt;==== &gt;[**Image**](https://i.imgur.com/J1NILes.png) [^(i)](https://commons.wikimedia.org/wiki/File:Map_General_American.svg) --- ^Interesting: [^American ^International ^Group](https://en.wikipedia.org/wiki/American_International_Group) ^| [^Continental ^Army](https://en.wikipedia.org/wiki/Continental_Army) ^| [^American ^General ^Aviation ^Corporation](https://en.wikipedia.org/wiki/American_General_Aviation_Corporation) ^| [^List ^of ^United ^States ^Army ^four-star ^generals](https://en.wikipedia.org/wiki/List_of_United_States_Army_four-star_generals) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cm3lq45) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cm3lq45)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
How much experience do you have? If you're still quite junior, I wonder if you would learn more by trying to implement your own MVC application from scratch. I did this and I really got a lot from the exercise. If you want to implement a task manager, perhaps you should compare implementations of various Todo apps on MVCTodo.
I love angular but writing a custom form directive that works with both ngmodel and the form controller for validation is one of the hardest things i have ever worked with. Thankfully nearly everything else is pretty simple. 
Are you instantiating func1, or is it attached to an object? Otherwise `this` refers to the `window` object. works here. http://jsfiddle.net/wLobgo75/ `this` always depends on the call site, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)
You should check out ember too. There's a To Do MVP example that you can walk through in a few hours. It'll help you understand what embers all about.
When people talk about a 'steep learning curve', they don't mean getting up and running with a simple application. If an MVC framework made that difficult, it would obviously be broken and wouldn't even get adopted. No, most people here talk about the difficulty once they're a few weeks into a complex project and they need to start getting to grips with the way Angular's scoping *exactly* works, getting used to IOC containers for the first time (which will be unfamiliar if you have a purely front end background), or having to delve into the sometimes rather ambiguous API reference. Or so it sounds. I've never even used Angular.
it was implied :) I'll still argue embers are more impressive though 
It doesn't and shouldn't inject the script for you. There is a link right in the README that points you to the line you add to your markup.
To be honest a lot of the features in it are already in Chrome and I think Firebug on Firebox
When internet explorer drops the version numbers as part of its name and becomes an evergreen browser I will consider its other features. 
Yea but IEs 7,8,9 are all pretty bad. 
Remember, `this` depends on the call site. You're calling `func1` from the window, so any subsequent functions will be called from the window as well. http://jsfiddle.net/wLobgo75/1/ Here's a good book on this and object prototypes, it's free to read on github. https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch1.md
An example in a JavaScript webapp is a Backbone View. In the Backbone source code you can see that the view uses a constructor. It also has an extend method so that subclasses can be made from it using convenient syntax. Those subclasses can then be subclassed. You could have a look at the Backbone framework and example apps that use it and subclass some of the core Backbone functionality.
[IE trying to become developer friendly](http://devopsreactions.tumblr.com/post/101999332309/ie-trying-to-become-developer-friendly)
IE? most complete? does not compute
IE11 already defaults to automatically updating to newer versions and IE12 is moving to a Chrome/FF-like release cycle with smaller releases automatically updating every few weeks. So, consider away.
We used to wear this joke out on a project I worked on a few years ago... some would mention "JSON" in conversation and then there'd always be one person in the background would yell "derulooooo"! 
p.tagName = "H1";
"guise, guise! SHADOW DOM!" There's stuff that Google does that would be "cringeworthily microsoft-esque" if Google had a monopoly on desktops. Imagine if IE 4 had introduced NaCL; we'd all be screaming bloody murder for the past sixteen years. 
Not really. All these frameworks come and go. There's so many now. If you have a project to do then do whatever is best for the project. If you're just exploring, roll something completely on your own. Learn how and why people create these things then when a serious project comes up you'll be better prepared to choose, learn, and modify a framework to your exact needs, or use your custom framework.
Of course they're considered bad now. But when 7/8/9 were introduced they weren't "literally Hitler". I'll be the first to admit that ms dropped the ball on the browser market, but too many people forget that the innovation came to a halt because competition was nonexistent not because Microsoft wants the internet to die. When you have a team of 10 people brainstorming new ideas for the web, as opposed to the large groups that now comprise the aggregate browser makers at google/apple/w3c/mozilla/ms, you're going to see stagnation.
Ive used it but honestly imo its nice but nothing worth writing home about. Learn it if you want it definately won't hurt.
I wrote one of these, too. https://github.com/scottrabin/is-js I highly recommend looking at the tests; there are a lot of cases your code doesn't test and might return a wrong result. Particularly, using `new String...` and other native types doesn't behave as you hope it does.
The question is, did they implement it in such a way that creates the need for more cross-browser hacking? I for one am tired of having to create or look for plugins that use different prefixes. This affects CSS too, and it's damned annoying.
You mean... ActiveX?
you won't really learn how to build SPAs. You will learn how to build Angular apps. Much like learning jQuery is not the same thing as learning javascript.
Any chance you could add something like... is.duck({name:is.string, birthYear:is.number})
That's true. Didn't think of that. I'll update my test. Nice library btw! Test updated, and native types did actually behave as I wanted them to.
fuck domains i'm going to host my web 3.0 site on .edu/~utuxia/
Man, what a bunch of fuckin' newbs. Its "jay-sawn".
sudooo or pseudo?
I don't really want to conflate identifying types with POD schemas. There are other libraries out there that do what you want, and I'd like to keep mine as focused as necessary.
In all browsers? Its been almost two years since I wrote that, but I recall having some issues with IE9...
Let me do some "real life testing", and I'll let you know.
If you want to build todo-style app then angulra is best fit. Otherwise for largescale apps it suck ass. tl;dr no Release fagular downvoters..
exactly. it will change by the time the standard is released and MS will once again be using something none of the other browsers support.
But we are still required to support IE 8 and 9 for our project :-((((( 
You should use something like Karma with multi browser tests.
Not for me either, in Chromium on Linux.
Thanks. You're right. I do think the tests are a little unfair since let has been working out of the box in Firefox almost since day 1 (version 1.8.1), but you have to enable the "Experimental Javascript features" flag and use strict mode for let to work in chrome.
I use Vim for all the languages I program in, including JavaScript. Not using any JavaScript-specific plugins.
Chromium on Linux does work fine for me though. 
FF on Windows checking in. All capitals are gone. Please send glyphs.
I like your style: `removeBeforeOwnPropertyChangeListener(key, listener)`
Sublime Text
ABCDEFGHIJKLMNOPQRSTUVWXYZ here have some more just in case. ABCDEFGHIJKLMNOPQRSTUVWXYZ If you need more just let me know. 
Ok I feel slightly bad for posting my homework online for help but my class is online and I cannot get a hold of my professor. This is my first time attempting javascript for my HTML class and when I try to load the page it remains white. My question is how to get my randInt line to display. The prof's directions below. Thanks for help! The function randInt should generate and return a random integer between 1 and max including 1 and max. The directions are to Make a call to randInt to generate a random integer between 1 and 2 and assign the value in the variable r1. My variable or equation will not display in FireFox. 
No because nothing else works well in IE and IE12 won't be out for a while. IE will still rank last in HTML, CSS and the API support.
And don't forget that the W3C essentially stopped all progress on the HTML spec for almost 10 years. That alone is the biggest reason for the webs stagnation last decade.
JIT engines also like well structured class-like prototypes, even more so if they initialise all properties in the constructor. Makes it easy to find backing types.
IE lost half its market share over the last 10 years so it's had plenty of competition. While it did eventually move forward, it's only been baby steps and it still ranks behind the others in modern standards support.
Thanks for the catch but I still can't get either to show in a print line.
It's got the class spec implemented. I've waited years for this and now IE is the first to do it. I'm confused. Happy but confused. 
My thoughts exactly. Can someone explain?
The developers on this team took the C# approach and named EveryFunctionLikeThis regardless of where it is. I am slowly getting used to lower case names and find myself doing it in my c# apps too.
Yes, sure. Imagine you need to store keys and values on a dictionary and retrieve them in an efficient way. How can you do this with Javascript alone? The answer is not with a map/object because they only store strings as a key, and if you want to use a hash as a key they can't store repeated hashes inside. So, there are basic data structures like Dictionary that are not part of the Javascript native types and are included in the collections.js module.
Do you know if the implementation will use the ES6 Map and Set objects if available? 
 document.writeln() http://i.imgur.com/ihUUrfT.jpg
Actually, in the case of TypeScript that is not true. The annotations don't change the output JS code w.r.t. types. No extra type info or hints are given to the JIT engine. It is the same as taking the source TS code and ripping out the annotations. Type coercion and checking is a purely compile time thing. That said, and interesting experiment for TypeScript would be to emit asm.js style type coercions which could give hints to the JIT. 
No demo?
Wow...
A couple of ideas... 1. Learn about using developer tools. Simply opening and reading the browser console will give you a lot of information. Look in your browser's menu for "Developer tools" or "More tools" or something similar and then "Console" or "Web console" or something like that. 2. Learn about Javascript. Yes, that's what your online course is for. But what I mean is... the code in your image (more on this below) shows you probably don't know even the most basic stuff. As an example, your homework says "Make a call to radInt and assign the result to variable r1" and your code is `radInt = r1` which makes me think that you don't even know the most basic syntax. Don't take this wrong. I don't mean to insult you or anything. What I mean is you can't simply expect to write whatever and then ask around for the correct solution. You need at least to make a bit more effort. (I'm pretty sure before giving out an exercise like this you must have had at least some explanation where they told you that to call a function you use `radInt()` and to assign to a variable you write `r1 = whatever` (not `whatever = r1`). If this is not the case, maybe you should just look for a better course) 3. When asking for help about code **never** post a screen capture of your code. Code is text. You can just copy and paste it. People who may want to help you can then copy it from your post. If you simply put up a screen capture, no one will want to manually copy all that just to try your code. Even better: on the sidebar in this subreddit there's a link to [JSFiddle](http://jsfiddle.net/) which makes it trivial to share and try code online. There are other -a lot- similar tools around. Codepen, JSBin, etc. Use that to share code for people to try and you'll see people are much more willing to help you because you make it easy for them to do it.
Hugs. It gets better. Trust me. It gets better. 
Before you go any further, can I suggest you read [How to ask questions the smart way](http://www.catb.org/esr/faqs/smart-questions.html). Your "question" is a textbook example of how *not* to ask a question, not that you even actually ask a question, just post a screenshot of your code and expect us to work it out. 
true, but his may be a javascript learning project.
Nice. It would be great if some of these are pulled out to their own modules. The main benefit is versioning; e.g. if you make a breaking change in one collection, it may not represent a breaking change in another collection.
Well Chrome not even close to IE6 situation, Internet Explorer was 70% and maybe even more at is best but Chrome right now "only" have 42% of market share
I think there might be some truth to it. By using TypeScript, you're no longer using the dynamic features of Javascript which means that a JIT compiler will probably be able to optimize more. 
I took a stab at updating the library to support testing. I think it came out quite clean. The overall support is good, however, the mechanism to include the right mocks and components is a little immature and will likely need some improvement in the future.
Wow-- Thanks! I knew WebStorm had a powerful paste-type feature, but nothing like this...
Until some annoying and over-controlling IT department disables the automatic updating keeping enterprise users locked into older versions causing pain for web devs everywhere.
[This is for you.](https://i.imgur.com/sy9lVl4.jpg ) 
&gt; I'll be the first to admit that ms dropped the ball on the browser market Even Microsoft admits they dropped the ball in the browser market. Almost any tech talk / meetup I goto that has someone from MS on the speaker list, has the speaker apologizing for their crimes against browsers.
No you missed what I was saying. The hinting that a JS JIT catches is what types are going through a parameter list. In vanilla javascript, the gut instinct is to type coerce within the function. `x = +x | 0`. JITs have a problem with this because they'd have to produce several forms of the same function for each type you actually push through it, in whats known as [Polymorphic Inline Caching](http://en.wikipedia.org/wiki/Inline_caching#Polymorphic_inline_caching). When you use a Typescript annotation, it pushes the type cast to outside the function. `f(parseInt(x));` It's not TypeScript itself doing it, but the programmer who's obeying the compiler rules. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 4. [**Polymorphic inline caching**](https://en.wikipedia.org/wiki/Inline_caching#Polymorphic_inline_caching) of article [**Inline caching**](https://en.wikipedia.org/wiki/Inline%20caching): [](#sfw) --- &gt;To better deal with call sites that frequently see a limited number of different types, some language runtimes employ a technique called polymorphic inline caching. With polymorphic inline caching, once a call site that is in its "monomorphic" state sees its second type, rather than reverting to the "uninitialized" state it switches to a new state called "polymorphic". A "polymorphic" call site decides which of a limited set of known methods to invoke based on the type that it is currently presented with. In other words, with polymorphic inline caching, multiple method lookup results can be recorded at the same call site. Because every call site in a program can potentially see every type in the system, there usually is an upper bound to how many lookup results are recorded at each call site. Once that upper bound is reached, call sites become "megamorphic" and no more inline caching is performed. &gt; --- ^Interesting: [^V8 ^\(JavaScript ^engine)](https://en.wikipedia.org/wiki/V8_\(JavaScript_engine\)) ^| [^Von ^Neumann ^architecture](https://en.wikipedia.org/wiki/Von_Neumann_architecture) ^| [^ASP.NET](https://en.wikipedia.org/wiki/ASP.NET) ^| [^Cache ^IQ](https://en.wikipedia.org/wiki/Cache_IQ) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cm473vr) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cm473vr)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Hi!, Firstly, Code as in text goes on a text sharing site not an image sharing site. Pastebin.com or similar is fine. Ideally your code should go to jsfiddle.net though. Then us redditors can play with it without having to retype your code :( firstly you need to remove the .src from your button variables and name them 1,2 and 3. They shouldn't have a color to start with or they should be black/grey i guess? var button1 = document.getElementById('button1'); ... etc. Then you have a reference to the 3 buttons. Use the randomButton function to update their properties: function randomButton(button,number) { if(number === 1) { //change button's src attribute here } .... etc. } Then at the bottom of the javascript you can call your function with the apropriate parameters. I guess your teacher is trying to teach you parameters. You've done all the randomizing you need in the first 3 numbers for now. You won't need an array for now and you won't need a for loop. The code could be nicer with it but i think the exercise is not testing your knowledge of them. 
But how exactly do you change the buttons src attribute. That is the main part I am stuck on
when you say: var button1 = document.getElementById('button1'); You store a reference to the element from the left hand side of the line. It's an element exposed in JavaScript as an object. The object has a "src" variable inside it. Just change it.
I..I am sorry I still don't know what you mean. Could you give me an example? Like how exactly do you just "change it"
Thx \^__^
You need to do some research. On objects and variables in general. I'll give you a clue which is the Equals operator (=). Here's some reading: http://javascript.info/tutorial/objects http://javascript.info/tutorial/functions-declarations-and-expressions I apologise for the smiley faces on that site but they have simple examples. It is important that you learn whilst doing this. This is why I didnt give you the full code.
Boop! Nicely done Chris! 
Most modern browsers perform these optimizations automatically, at runtime. (Except reversing the loop, which could screw with functionality.). The only real savings is from shorter script for smaller transfers. I really would prefer to see readable code that conforms to universal standard forms of programming, rather than convolutions that rely on language specific quirks (like "while(i--)"). As Knuth said, don't prematurely optimize. Look for bigger issues, like O(n^2 ) operations that could be written as O(n).
To be more specific, this is implemented as a hack on top of jshint with proper static analysis, so it only adds/removes semicolons where it makes sense, and your code is guaranteed to work after the conversion.
I came here to say this. I stopped reading as soon as it said not to use Array.length in the loop definition. That's one of the easiest things for a JIT compiler to optimize. 
You don't need hangouts or inbox to run Chrome and still have all the functionality of any other browser.
the keyboard short cuts in WebStorm are the best around among other strong features. 
Webstorm is one of the most underrated IDEs for javascript in my opinion.
... So your argument is "don't use it if you don't like it"? You don't need ActiveX to run IE and still have all the functionality of any other browser. Microsoft wrote tons of IE-only ActiveX "web" apps. Ditto Silverlight. Everyone railed against Microsoft for this in throughout the 2000's ([EEE](http://en.wikipedia.org/wiki/Embrace,_extend_and_extinguish)). Now Google is following suit, making "web" products that only run on Chrome within the Google ecosystem. But that's okay? Why? A GP posted: &gt; We know what happened when IE6 was the "best" browser available... it stopped. It stopped right there and the web stopped with it. We (collectively) can't let any browser gain that sort of dominance ever again. Do you not agree Chrome is already in that position today? I'd say they're well into the 2nd E of EEE.
I don't think you'll ever need this besides when you're writing a physics engine, and even then you'll only need to use it only a few times... Let's just all switch to `forEach` please, it's so much more readable, and it's impossible to make any hard-to-catch typos, optimizations will come.
*HTML5 Game Development Insights* I don't know if it fits (have't tried it myself). You could take a peek into the course, however. https://www.udacity.com/course/cs255 (FYI the course itself is free by clicking on "view course materials". The fee concerns coaching and getting certified.) Here is the publishers book page. http://www.apress.com/9781430266976 
This should definitely be one of the last things you turn to. There is going to be other issues that slow down your code. I worked at a company for a couple years where we needed to render GPS data on a map at 60fps on any device (iPad was a pain in the ass). I optimised my loops but looking at that messy code everyday afterwards always annoyed me. It did very little to help in the long run and I was better off reducing operations on the dom and optimising access to my data stores.
I'm a Backbone fan boy but in general if become efficient with one people will want you to work for them. I like the fact Backbone is quite light weight and there isn't too much magic going on.
IIRC, there are group policies to disable auto updating in Chrome and Firefox too. That's not an IE problem. It's an enterprise IT problem.
I think it is better to ask the owners of the project about specific advantages.
The idea is that javascript needs to know which element of the webpage to change. This is usually done with ids. If you have &lt;img id="button1"&gt; in your HTML, then Javascript can "grab" that element and put it into a variable: var button1 = document.getElementById('button1'); Now the variable button1 is like a shortcut to the &lt;img id="button1"&gt; element on the webpage. Once you have that shortcut, you can access all kinds of properites of the element: button1.scr //changes the image source button1.className // allows you to change the CSS class button1.style // allows you to change CSS styles directly ahref's mentioning of objects is important because the html element you access here is an object. Objects are collections of keys and corrosponding values. var sampleObject = { someProperty1:'value1', someProperty2:'value2' }; The code above defines a new object in what is called *object literal notation*. You can get at the values via the keys: someObject.someProperty1 // accesses 'value1' someObject["someProperty1"] // also accesses 'value1' The first example uses *dot notation* to get the value; the second uses *bracket notation*. If you think about it, you'll see that the variable refering to the HTML element (button1) is indeed an object that "contains" all the attributes (and many more) of the original element. With button1.src, for example, we use dot notation to get at the property src. We can also change values with dot notation and bracket notation: button1.src = '*some new source*'; I would suggest delving further into this with some courses. It might be helpful to learn about the DOM (document object model) and how JavaScript accesses this. You can imagine the DOM as a hierarchical tree structure that represents the structure of the HTML document. The DOM is the bridge between your JavaScript and the web page. Your javascript interacts with the DOM and the browser then displays the changed page. http://code.tutsplus.com/tutorials/javascript-and-the-dom-series-lesson-1--net-3134
everyone wants to use vi. let 'em. i'll be 10x productive then those guys
nice. this is the future. js everywhere. games, microwaves. cars.
oh yeah. i know the thought process. i thought i was more of man using vi.
Again, I appreciate your idealism. 
You could add that except that the function template is 'fn'. 
What's the connection to JavaScript that makes this relevant for /r/javascript?
It was something new to me, the two I gave were examples and I gave a link to more. Just trying to share something I found, I guess others have seen templates but for those who have not it can be useful 
Thanks for the helpful reply!
It's probably the most recommended on reddit :/ 
Read in files.. so this is node.js? Wouldn't the number of diads just be `str.length - 1`? 
\&gt;:D&lt;
Object already is a hash table. Just store new digraphs as keys in an empty Object instance with value 1, and increment that value each subsequent time you see the digraph. To find the digraphs, simply scan through the strings you're processing (figure out how to get the strings you need from your files in a reasonable manner) one character position at a time, starting from char 0. Consider the current char and the one following it as a string of length two. There are two cases: First, it may not be a valid digraph (e.g. because one of the characters is non-alphabetic), in which case continue on to the next position. Second, it is a valid digraph, in which case look for it in your object's keys using hasOwnProperty. If it's already in there, get the corresponding value from the object and increment it. If not, add the new digraph as a key with value 1. Once you've processed all your input data, you'll have to loop across all the keys in the object, keeping track of the tents highest value and discarding/ignoring all keys with lower counts. 
you know array methods work on strings too. ;)
Or slice all the diads into an array and pass that to an incidence counter like this. &gt; http://stackoverflow.com/questions/5667888/counting-occurences-of-javascript-array-elements
Im lazy / about to goto the pub so I didn't read all the responces. I would say that optimization of loops ARE worth within JavaScript because in a business environment, you will run into very large datasets, and if you can pull some cool shit out on the spot to solve an issue, that earns you big cred points really easy. As an example - I am a SharePoint admin and do a good amount of small development work (stuff that doesn't require a dev team or a capital project) and within SharePoint, once you start working with datasets over 5,000, and especiall once you break the 100k barrier, the SharePoint OM interpretter starts having big issues dealing with these large arrays. when you need to apply a change to a large sharepoint array, the trick is to set your array size to the size of the dataset, which is a standard practice in C/C++. Not sure why it works so much better but I have taking jobs from 36 hour run times to 12 hour runs doing nothing more than defining the array size when instantiating (and disposing objects and reinstanciating every 10k items or so) *Edit : TL;DR - JavaScript may be client-side executed, but the processing of those large arrays (if they are objects at the server, not in memory arrays ofcorse) are going to happen on the server side - if you know its a large dataset, follow best practices of large datasets on the platform you are working in
"Optimization of loops worthy or not?" and no metrics? This article doesn't answer this question at all.
WTF. I cringe at the thought of being the type of person who actually gives a fuk about reddit 'karma'. Validation-starved much?
point taken. I'd say obliterate karma and just deal with upvotes and downvotes, but then I guess we'd lose the ability to judge credibility. It's just so sad. Human nature. ;)
Someone is a bitter butterfly lol jeez. I found it informative why didn't you post your 61 templates earlier and then maybe ppl would give you karma which honestly who the F cares about? And just to add you flame the guy for using a switch statement lol "please don't use switch in JS. It is much faster and nicer to use hashobjects instead." 
This question is incredibly vague. Do you mean something like: var x = 5; x = 'foo'; x = false; x = null; x = function () {}; x = void 0; JavaScript is a dynamic language. Variable references can be reassigned to anything. OR If you're asking, how can I `set` an Object's property to a value and it changes based on some other factors... You can use `Object.defineProperty`. var x = {'a': true}; Object.defineProperty(x, 'b', { get: function () { return this.b_; }, set: function (number) { if (this.a) { this.b_ = number; } else { this.b_ = 0; } } }); x.b = 5; // x.b == 5 x.a = false; x.b = 5; // x.b == 0 If a is false, when setting b, it will always become 0.
I wasn't trying to emphasize that typescript CAN'T be compiled to ES6. My point was that typescript developers aren't going to do this. Production JS targets are still going to be produced with a lower language level for the foreseeable future. You're not going to give up superior compatibility without having a good reason to do so. And so far, I haven't heard of any legitimate reason to compile a production target to ES6.
IntelliJ is the leading company when it comes to IDEs (Java, Python, JavaScript)... As far as I'm concerned, everything else JavaScript (with the exception of NetBeans) is just a text editor.
I meant the first one. Are you telling me that if I want to change a variable I would simply just redefine the var? Here is what I am interpreting `var x = "dank";` `var x = prompt("dankie wankie?");` `//now if I console.log will I have the user's input to the prompt?` `console.log(x);` 
Since an Object in JavaScript is basically a hash table, use the strings as keys and a number as the value. Iterate through the characters in the string, incrementing counts or setting newly found `diads` to 1. var diads = {}; var diadString = 'ab cd 12 34...' for (var i = 1; i &lt; diadString.length; i++) { // Start at 1, since 0 &amp; 1, would be our first diad var diad = diadString[i-1] + diadString[i]; // Ignore diad logic? diads[diad] = (diads[diad] || 0) + 1; // Increment existing diad or set to 1. } Then sort diads descending by it's values. We have to move to an Array object for sorting: var sortedDiads = []; for (var diad in diads) { sortedDiads.push([diad, diads[diad]]); // Retain diad at position 0, count of diad at 1. } sortedDiads.sort(function(a, b) { return b[1] - a[1]; // descending }); Top 10 would be at the beginning of the array: for (var i = 0; i &lt; Math.max(sortedDiads.length, 10); i++) { console.log(sortedDiads[i][0]); } If you can find a JavaScript implementation of a sorted hash map which sorts by value (tree map/bidi map), that would remove most of the redundancy between converting to a list and sorting. **Edit** Some of the other answers are valid. Why the downvotes?
There's a lack of terminology in your wording that is making your question very ambiguous. But, if I'm understanding you correctly, you're asking how to change the type of data (bool, number, string, etc) stored by a variable once it is declared. If so, all you need to do is assign the new value to the variable. You don't need to re-declare it. var x = true; x = 123; x = "Hello World"; The above is perfectly valid javascript. The example you gave above, where you declared the variable every time you wanted to change its value, is not strictly valid. Every modern browser will interpret it correctly, but it is still bad code/practice.
As /u/jordaanm said, this is perfectly fine. But don't use the keyword `var` again and re-declare the variable. var x = "dank"; x = prompt("dankie wankie?"); //now if I console.log will I have the user's input to the prompt? console.log(x);
thanks for the input guys
don't attempt to optimize any code until you have done ALL of the following: 1. identified that you have a performance problem that actually matters, i.e. that is negatively impacting your end users in some way. 2. identified that you have discovered the specific code that is the cause of the performance problem, and that you know that optimizing this specific code is feasible within your budget and timeframe. 3. put in place a system to measure performance improvements. 4. have a clear idea about HOW to optimize the code. this means you have a clear understanding of the behavior of your interpreter/compiler and know how the actual machine code generated by it will perform and how that performance will change when you start tweaking your code. 5. have behavioral tests in place to guarantee that your changes to the code in question do not break the correct functional behavior of the code being changed. you must maintain correctness while optimizing.
Dude, you're fine. He's just pissy that he didn't capitalize.
This is often repeated and is ~~somewhat untrue~~ edit: apparently this depends on who you ask. &gt;javascript is dynamically typed Javascript is *not a dynamically typed language*. Javascript does have types. Don't believe me? type `typeof {}` in your console. Its just not type enforced. **Values have types in javascript, variables do not** This means that values have types and they can not change, but variables can hold any value at any time. You can also get a values instanceof, and some of these, like Native Constructors you're familiar with. For example [] instanceof Array; //true You can certainly create your own constructors this way, and achieve many of the similar goals that run of the mill static typing affords. //Auto constructor function Auto(name, make, model, engine) { this.name = name; this.model = model; this.engine = engine; this.make = make; } //lets make an instance of that. var pickupTruck = new Auto('Toyota 4x4 Pickup Truck', 'Toyota', 'pickup', '4 cylinder'); //and to the point... pickupTruck.constructor === Auto; //true pickupTruck instanceof Auto; //true so while you can put anything in var.. var *certainly* has a type and instance. Its type is 'object' and its instanceof is 'Auto' Edit: did reasearch. learned things. Sweet jesus there is a lot of debate on these topics. Not in this thread, per se- but amongst the experts. Its totally fair for you to call Javascript dynamically typed. I am stills ticking to the point that "Values have types in javascript, variables do not", as I do believe that is the most accurate way to describe js, but I can see why one would say dynamically typed.
I'm pretty sure I said that variables are untyped. What's your actual point? 
Huh? Did you misread my post or mistype your post or something? I'm confused right now. I said Javascript is dynamically typed with respect to not needing to declare types of variables. I contrasted that to C++ where you do have to declare variable types. I made that distinction because OP seemed confused about lack of type declarations. nowhere was I talking about value types. 
I think [underscore](http://underscorejs.org/) would be a great fit for what you want to do
I love the idea! I could certainly see myself using this. Shameless feature request: variable interpolation using values in package.json or some other easy-to-modify-programmatically file. In the past I've used html comments to identify where these values should go, so that the template and rendered output could be the same file. &lt;!-- render {"template":"# Kibana &lt;%= pkg.version %&gt;"} --&gt; # Kibana 4.0.0-BETA2 &lt;!-- /render --&gt; From: https://github.com/elasticsearch/kibana/blob/master/README.md
Will be in before the end of the day. https://github.com/gajus/gitdown/issues/4
i don't understand. 
I see what you're saying... I'm wondering if there are any tricks or hacks I may not have stumbled across that might help simulate the effect I'm looking for.
Short of overriding String.prototype.toString or Number.prototype.valueOf... I can't, unless you can think of a way to override the primitive setters.
I'm told that since it's a variable assignment, when you "change" it's technically changing the pointer so it wouldn't be possible in almost any language. The only way this would work is if you made it a property.
 var a = ['I am the first array']; a = ['I am the second array']; This does not *change* the first array that was assigned to `a`. It changes the variable `a`. The original array is unmodified.
I see. what about objects though, those are passed by reference so if `var a = { foo: 'first' }` and `a = { foo: '2nd' }` it would fire a change event?
Primitives don't have methods. Whenever you use a primitive's "method", that primitive is actually auto-boxed. 5..toString()¬π is actually: (new Number(5)).toString() There also isn't something like a setter. When you say x = 5, you just make that variable refer to another primitive value. There is no object and you also didn't change one of its properties. [¬π "5..toString()" is the same as "(5).toString()" or "5.0.toString()".]
1. Make an object (O1). 2. Let the variable 'a' refer to it. 3. Make another object (O2). 4. Let the variable 'a' refer to it. O1 didn't change. There were no change events to observe.
Thanks man, early bird and all that :) 
In both of OP's examples you're not telling anything to observe `a`; you're telling it to observe what `a` refers to.
Might be a bit of a hack, but storing your string in an object should do the trick. 
Javascript is (arguably) strongly typed, but it most certainly still dynamically typed. The two are orthogonal concepts. The exact definitions are often fuzzy and debated, but Javascript unambiguously falls into the category of "dynamic" typing. (Strong/Weak, and Static/Dynamic are separate things). 
Yep, awesome :)
I think passing the element object is better idea as it's much more flexible.
Sure but it's doesn't mean that it should be used for something that is not supposed to handle. We should teach best practices even beginners.
This is a great library for more robust date manipulation (like for a calendar app or something), but for simpler stuff (writing dates as formatted strings, difference between two times, etc), I've been much happier with [XDate](http://arshaw.com/xdate/). It's way smaller and has a very intuitive API that is basically an extension of the native date functionality. It's no longer regularly updated, but...it's a date library, so that's totally fine.
The statement `var x = "dank";` does two things: * it declares a local variable called `x` * it assigns it the value `"dank"` (a string) You can actually split that into two statements: var x; // no explicit value, so it is initialized with `undefined` x = "dank"; You can only declare a variable once (successive declarations in the same scope have no effect, declarations in nested scopes create unrelated variables with the same name). You can assign values to it as many times as you want.
&gt;And just to add you flame the guy for using a switch statement lol &gt;"please don't use switch in JS. It is much faster and nicer to use hashobjects instead." Lol +1. I don't know where this came from, but I notice the "proof" is always something that you wouldn't do in the first place... 
I have a simple one in early release version. I am still adding content and revising stuff. Its free and open source, available at https://leanpub.com/buildinggamesforfirefoxos/
I would recommend creating an element instead of using document.write. As far as I can tell, document.write just appends to the existing document, whereas creating and appending an element will give a more exact control. I can't tell exactly what you're trying to do, but this is what I'm guesstimating would work for you. var link = document.createElement('a'); link.href = "javascript:void(0)"; link.onclick = function(){ //your onclick code -- you can actually format it reasonably like this }; Then you can use Element.appendChild or Element.insertBefore to insert it into the document. 
Instead of &amp;#39 and probably in the case of loadXMLDoc, you need to use escaped single quotes. But to be sure, better don't try to use document.write at all, because it will stop the whole rendering/JS engine until it is finished, which is a bad thing to do; rather use DOM operations like Asterne suggested.
Nice! I think the parts on the optimizer and grunt will be extremely helpful. I have been learning requirejs recently and thats what I spent most of my time stuck on.
Can you give an example of how to use Element.appendChild to call it please? I'm having trouble getting it to work. Thanks
[Can I Google that for you?](https://www.google.com/search?q=element.appendChild+example) Are any of those helpful, because we cannot know what is wrong without seeing how you are trying to use it.
Well, if you wanted to add it on to the end of the body, you'd do document.body.appendChild(link); document.body would be the 'Element' and link is the reference to the element you created
i feel stupid asking this but whats var 
You're probably going to get downvoted into oblivion, but are there any concepts you're having particular trouble with? I'm a professional full time developer working with a heavy JavaScript stack, I'd be happy to clarify things within reason.
You'd have to have two observers: one to watch the "parent" object: var ◊ê = { a: [] }; Object.observe(◊ê,function(changes) { &lt;etc...&gt;}) and one to watch a: Object.observe(◊ê.a,function(changes) { &lt;etc...&gt;}) The first will fire if a is accessed (assigned, deleted), and the other if a is changed (array access or methods). 
I was asked to pull this out of our codebase at work and open-source it. Since there isn't a lot of documentation on how to do this (Apple only recently reversed its policy on OTA updated hybrid apps), this project represents weeks of trial-and-error development. I hope others find it as useful as we have!
Unfourtunatley, my knowledge of Javascript is limited, and I am struggling to implement them, so Im ot sure if they will work, or if I just dont know how to implement them. Basically, Im making a css popup window, that is a &lt;div&gt; that is shown when the button is pressed. The code in the question works perfectly when done in straight html. But moving it into the script (it is in a for loop) stops it working.
I should probably point out, that it does show the &lt;div&gt; it just dosent seem to be passing on the loadXMLDoc value
Better safe than sorry: ABCDEFGHIJKLMNOPQRSTUVWXYZ
I've used require for over a year now and browserify just looks easier. Require is pretty easy to understand for me, but for explaining to other people it's a nightmare.
Genius
Yeah, much better syntax with commonJS module. Common argument against Browserify and commonJS modules is that you have to have a build step. That was true few years ago, thankfully we have [systemjs](https://github.com/systemjs/systemjs) loader to save us a hassle of buildstep when developing with commonJS modules.
So, If I use the following, It's not a link. How can I make it a link? var link = document.createElement('a'); link.href = "javascript:void(0)"; link.onclick = function(){ document.getElementById("light").style.display="block";document.getElementById("fade").style.display="block"; loadXMLDoc("LegWarmers") }; document.body.appendChild(link); Thanks for the help
Yeah RequireJS is not required any more. I like the Browserify approach better. Helps using node modules if you wish too. Also this allows for a build step using GruntJS /GulpJS
haters?
I had to ask even though I knew the answer. Anyways, here's a neat library I built that's tangentially relevant: [https://github.com/siriusastrebe/syc](https://github.com/siriusastrebe/syc)
Sorry! I forgot to add that to add the link text, you'd use this: link.textContent = "text"; That should make it display.
Also, please format your javascript. It makes it so much nicer. var link = document.createElement('a'); link.href = "javascript:void(0)"; link.textContent = "text"; link.onclick = function(){ document.getElementById("light").style.display="block"; document.getElementById("fade").style.display="block"; loadXMLDoc("LegWarmers"); }; document.body.appendChild(link); Is so much more readable.
Thanks, That seems to work with plain text, however I'm trying to produce HTML code with it, and it's not appearing. Should html be rendered correctly with this technique? 
You can either use link.innerHTML = '&lt;div&gt;&lt;/div&gt;' or something like that, or you can create more elements the way I said and append them (which is the proper way, but pretty obnoxious if you have a lot of elements).
Ok, So it seems to be working, Except it's taking it out of the &lt;div&gt; it's supposed to be in... Any way I can fix that? EDIT: Sorry, I meant to say that I'm using link.innerHTML 
Just to clarify: I have: &lt;div id="wrapper"&gt; &lt;script&gt; loop { &lt;div id="film"&gt; stuff &lt;/div&gt; }end loop; &lt;/script&gt; &lt;/div&gt;
Good to know.
`var` is short for "variable" statement. The variable statement declares a variable, optionally initializing it to a value. In Java, you declare variables with types: int i = 5; String s = "foo"; Object n; JavaScript variables are dynamically typed (or type-less), so we use the keyword `var`: var i = 5; var s = "foo"; var n;
The is no reason why you cannot have a Grunt or Gulp build step with RequireJS. I've used both with my build. 
This is a good start, but kind of antipattern to use `onclick` and `javascript:void(0)`. I'd recommend the following: var link = document.createElement('a'); link.href = '#'; link.addEventListener(function(e) { e.preventDefault(); // code here });
Fair enough. I was just doing it sort of the same way it was done already. I guess if it's not inline what I was doing was unnecessary.
Blast! I fixed the blog post title, but the URL and and reddit post title can't be saved. In any case, definitely don't use the non-existent `string.splice`! :)
Not yet, I will look into it. 
You want some sort of observable functions. Like knockout uses. ```var myval = ko.observable('a'); myval.subscribe(function (value) { doSomethingWith(value); }); myval(); // a myval('b'); // doSomethingWith 'b' ``` There are lighter implementations if your not using knockout its just what springs to mind. 
&lt;html&gt; &lt;head&gt; &lt;title&gt;JavaScript&lt;/title&gt; &lt;meta charset="utf-8" /&gt; &lt;/head&gt; &lt;body&gt; &lt;script type='text/javascript'&gt; function multiple(x){ for(i=1;i&lt;=100;i++) if(i%x==0) document.write("m "+x+" : "+i+"&lt;br&gt;"); } multiple(2); &lt;/script&gt; This is what I submitted, do you think this would work?
annnnnnnd its formated wrong
Looks like it should work, but there are a few issues with the code: - You forgot to declare `i`, you need to use `var i=1` - It is best practice to use `===` instead of `==` to compare to zero - `document.write` is not recommended; you should use the DOM, i.e. `document.createElement` and `element.appendChild`
This is a member of the core team leaving, not another framework bashing post.
Friends of mine have gone from Codecademy to Code School and found that there was quite a bit of material they hadn't seen before. As for setup you can write code in any text editor. A few that you can try out are Sublime Text, JEdit, Light Table, Vim, Emacs, WebStorm. Once you create a .html file you can open it with and browser and then keep coding. I recommend building some personal projects. Useful programs that you might want but are very specific to something you're doing in life. Also, simple video games are fun to make.
Just downloaded it and it's exactly what I wanted. Thanks!
&gt;Is This Allowed? &gt; &gt;Yes, Apple has changed its long-standing policy against this practice and now allows over-the-air updates of hybrid apps so long as the purpose of the app does not change. I have successfully gotten two apps using this technology accepted on the first try, explicity stating in my app review notes that over-the-air updates are performed. Cool!
Doh! Easily done, I do it all the time for arrays. You could do a cover up and talk about the totally simple String.prototype.split('').splice(index, howMany).join('') haha, rolls off the tongue! Edit: forgot to join back into a string at the end
I have nothing of value to say but jesus christ I hate scrolljacking
It's doing this on iOS on my iPad too. 
Slice indices I will never be able to forget: Object.prototype.toString.call(...).slice(8, -1).toLowerCase()
I haven't used either and never heard of C3. Just checked it out. One big upside for C3 is it looks like it handles events, which MetricsGraphics doesn't. That is a must have for me.
&gt;Would you feel comfortable refactoring anything or modifying any existing pieces? How do you know what you changed didn't affect 20 other features, do you have time to test 20 features every time you change something? Unit testing solved this to some extent. The trouble is that many mocking libraries allow to to define the expected API of an object, but this definition does not have to match the reality of how the object is implemented. An example. Lets say you're unit testing an object with the constructor Foo. Foo takes an instance of Bar in it's constructor, then uses this instance of Bar within various methods. You have unit tests for Foo setup that include expectations on a mock of Bar. You modify Bar to remove a method on it, lets say getInfo. You update the unit test for Bar and all is good. You then remove some calls to Bar.getInfo() in the code, but miss the calls to it within Foo's methods. Since Bar is mocked with expectations on getInfo within Foo's unit tests, the unit tests for Foo pass despite the production code failing. I doubt this is true for all mocking libraries (that you can mock getInfo even after it's been removed from the object), but I know this is true for at least some mocking libraries.
webpack
Angular is shit. I got caught on the hype and have used it extensivelly for years and only started to realize how shit it really is about a year ago. Durandal is also shit. ReactJS is the only framework I could recommend at this point. Haven't used EmberJS.
I think you mean the skills if your typical programmer. Period. I've seen a lot of shit code in a lot of different languages. 
I don't know what "scrolljacking" is, I just need it for a portfolio site for my intro to web design class
https://developers.google.com/maps/documentation/ Would be a good direction. Basically google has to support what you are doing for it to work. https://developers.google.com/maps/documentation/embed/guide might be the right approach but i don't know what you need the maps for.
One of the thing that I'm not sure still is if browserify can be used to leverage libraries written for browser in node. I know you can make your node code work on browser with browserify but can it do the opposite too?
You're right about Jasmine being for unit testing (e.g. functions or other units of work). You are looking for end-to-end (E2E) testing with something like [Protractor](https://github.com/angular/protractor) or Selenium. 
If you're successfully change the first button you are immediately retuning out of the function, effectively breaking the loop. 
I write my tests with [tape](https://github.com/substack/tape) and run them in browsers with [testling](https://github.com/substack/testling).
[Here you go](http://html5up.net/parallelism), just know you're going to incur the wrath of a lot of OSX users.
I can't be sure as I'm not familiar with Tumblr's HTML editor, but it sounds like the code is trying to reference DOM nodes before they've loaded. The reason it works in jsfiddle is likely because of the 'load' setting -- it is set to DomContentReady. You can do this by wrapping any code that intends to reference Dom nodes in an onload function. The easiest way to do this is with jQuery, passing a function to `$`. e.g., $(function(){ var $contentWrap = $(".content.wrap"); ...etc... }); 
can we get a decent candlestick chart library?
No. You can't run code targeting node's File or Net utilities in the browser in much the same way as you can't run code targeting a browser's window or XMLHttpRequest in node, browserify doesn't solve either of those, all browserify does is package code up in a nice bundle you can include client side (I'm sure you could use the bundle server side [require('./bundle.js')], by why?). Essentially, JavaScript is the same language and core features across any platform that can run it, the only exception comes when you target a specific platform feature (File, XMLHttpRequest).
OK, what do you mean by 'the tab crashes'? Are you getting any errors logged?
Yeah, but so what? Our society has become so narcissistic that we have to blog about our career decisions. This kind of vanity is not getting annoying: it's been that way since the beginning.
I believe he means that the window crashes. The tab in chrome. 
That... would be pretty fatal, especially considering the code in question. I was thinking there's some kind of 'tab' in the tublr editor that disappears or or raises some kind of error. I mean, even if you hit an endless loop or something the browser would likely stop the script execution or give the user a chance to stop it... firefox does that anyway, I would figure such a thing would be standard.
Scrolljacking (scroll hijacking) means that a site prevents default scrolling and forces its own. One good example of this is Google Inbox' front page (when you're not logged in there)
Angular 1.X will still be around for quite some time. There's already immense support for it, it's widely regarded as the most popular framework today, and there are literally thousands of applications based on it. So, it's not going to die tomorrow, or next year, or the year after. From the grapevine, AtScript is an extension of TypeScript with annotations for handling the binding and dependency injection, which Angular supports now. It's just a better re-imagined model, because it's more central to OOP concepts. Now, OOP seems to get a lot of flack in JavaScript because it's "too strict", but anyone who says that is just talking out of their ass. The beauty of a dynamic language, is you are able to encompass the concepts of a typed language fairly easily and intermingle the two. Behind the scenes though, it's just plain ol' JavaScript. You actually don't have to use AtScript or TypeScript. They have clearly stated it is not a strict dependency. And my guess is, once it's actually released, you'll see helper libraries for people who don't want to use AtScript. It's just the nature of the language. Why would they create Angular-Dart? Because people use it.
Probably not. This is intended for what are commonly called "single page apps", not WordPress.
I do get crashed on chrome sometimes when I've got an infinite loop going on or something that trigger way too often. Perhaps that's the problem here. 
&gt; some part of JavaScript developers are against strong typing in JavaScript because they are scared of complexity and things they don't fully understand. if they would have more experience they'd see how static typing is a boon to their productivity and quality. 
A single page angular app that interacts with the WP API (Wordpress API) should be fine though, right? Nice work by the way. :-)
If there is one thing that web development needs then it is sustainability. No surprise any notion of AtScript, TypeScript, Dart or the planned ahead redesign of AngularJS makes people more and more nervous. This fear is not taken seriously enough. You can't change fundamentals to this vast extend while still building on them right now and expect everybody to stay calm. Not technical merits or deficiencies cause these new undertakings to fail, no matter how reasonable they are. It is plain fear and the desperate need for sustainability in web development. Google said support for AngularJS-1.x will end one year after AngularJS-2.0 is out. I mean ... We are talking about a 10+ years, not one or two. Only one of AtScript, TypeScript, Dart or JavaScript will still be there in 10 years. My bet: it will be called JavaScript. However those side tracks - and as such I see AtScript, TypeScript and Dart - do heavily influence ES6, ES7, etc. I doubt ES6 or ES7 will end up being exactly AtScript, TypeScript or Dart. For AngularJS-2.0, I am less sure. Could very well be current plans are its neck breaker and we will see the masses follow an AngularJS-1.x compatible fork, at least for a while.
&gt; personal blog Now there's an oxymoron if ever there was one.
&gt; However, the vast majority of JavaScript developers are against strong typing in JavaScript because it is a dynamically typed language. Once you can embrace that, it is one of the most powerful parts of JavaScript. I think that the vast majority of JS developers have no experience with static type systems and non-trivial code bases, or if they do then it was with Java. Being able to combine static and dynamic typing as you desire using something like TypeScript, is a huge boost when building larger code bases. 
No.
This kind of posts are a bit annoying, but that's not your fault. First of all AtScript and Angular2.0 are two more or less separate projects. Sure the Angular team encourage you to use AtScript but it is totally valid to use ES5/6. It is also possible to develop using AtScript without adding Angular to your project. AtScript is an extension to ES6 and Typescript to make development more convenient, but it won't stop you and a lot of people to stay with the "language" you already know. Unless people are really stupid, AtScript won't kill Angular the same way CoffeeScript, TypeScript or any other trans-piled languages haven't killed Javascript. It's true syntactical and api wise there will be some major differences, but for the most part the concepts will stay the same. This will help developers to search more efficiently for answers and phrase the correct questions. Maybe take a look at some documents, talks or podcasts to see for yourself why they make certain changes and judge if this changes will be a good thing for the future. (e.g. [Angular Air (Podcast)](https://www.youtube.com/watch?v=LG9VkCDbte0) I won't deny that some people/companies will need to invest some time to migrate to Angular 2.0, but the Angular team has committed to a migration path and if the community gets involved I am sure there will be great tools to help. Having said that, I am convinced that most of the application can stay on Angular 1.x, there is no need for migrating every single app. Maybe it's because I am from europe and our industry seem to be a lot more conservative than the US, but I find this reluctance to change quite sad. 
I am disappointed. We still need the isset function that does crazy exception catching.
The very last paragraph of the [AtScript Primer on Google Docs](https://docs.google.com/document/d/11YUzC-1d0V1-Q3V0fQ7KSit97HnZoKVygDxpWzEYW0U/edit) says that AtScript is independent of Angular and that they hope to use AtScript to develop Angular with. Actually to quote exactly: &gt; Our plan is to use AtScript for building Angular and optionally let users of Angular leverage AtScript to build their own applications. AtScript is independent of Angular and as such we think it would be useful for other non-Angular projects. Have fun working with Angular!
Good job! I was looking for good tutorials when I first use RequireJS. It's true that it can be intimidating at first -- and that the complexity argument against it has merit. This concise tutorial would have made adoption easier for me. I like the part about Grunt. Personally, I became more at peace with it when I could concatenate and minify my build in a sane way. Also, RequireJS has plugins like this one: https://github.com/requirejs/text which could be useful and maybe worth noting.
Can you please elaborate why Angular "is shit"?
Nice work, pushing the updates this way will be very useful. 
In the browser there's an engine that takes your JavaScript and runs it. That engine can be pulled out of the browser and run on its own. When it's standalone like that, it'll run things like node.
Browsers are made of many parts, one of those parts is the [Javascript Engine](http://en.wikipedia.org/wiki/JavaScript_engine) which is a type of [virtual machine](http://en.wikipedia.org/wiki/Virtual_machine) used to interpret and execute JS code. All browsers contain a Javascript VM, Firefox has [spidermonkey](http://en.wikipedia.org/wiki/SpiderMonkey_\(software\)), IE currently uses [Chakra](http://en.wikipedia.org/wiki/Chakra_\(JScript_engine\)) and chrome uses [V8](http://en.wikipedia.org/wiki/V8_\(JavaScript_engine\)). Since these engines are built separately from the core browser they can be used to run Javascript outside of the browser environment but because they are built with the browser in mind they lack some key functionality to make them useful stand alone. This is where Node.js comes in, it uses Google's V8 engine to execute Javascript but also adds various functionality to the engine giving it the ability to interact with deeper systems than the browser would require such as writing files to the hard drive or running scripts from the command line. 
It is pretty easy to install Node.js on your system so that you can create your own server and play with it: http://nodejs.org/ 
angularjs is client side runs on browsers while nodejs is serverside its run on v8 javascript engine which chrome browser use for browsing when you install nodejs on server it actually installs this engine to execute your code. http://en.wikipedia.org/wiki/V8_%28JavaScript_engine%29
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**V8 (JavaScript engine)**](https://en.wikipedia.org/wiki/V8%20%28JavaScript%20engine%29): [](#sfw) --- &gt; &gt;The __V8 JavaScript Engine__ is an [open source](https://en.wikipedia.org/wiki/Open_source) [JavaScript engine](https://en.wikipedia.org/wiki/JavaScript_engine) developed by [Google](https://en.wikipedia.org/wiki/Google) for the [Google Chrome](https://en.wikipedia.org/wiki/Google_Chrome) web browser. It has since seen use in many other projects. As of 2012 [update], the head programmer is [Lars Bak](https://en.wikipedia.org/wiki/Lars_Bak_(computer_programmer\)). The first version of the V8 engine was released at the same time as the first version of Chrome, September 2, 2008. &gt;V8 compiles [JavaScript](https://en.wikipedia.org/wiki/JavaScript) to native [machine code](https://en.wikipedia.org/wiki/Machine_code) ([IA-32](https://en.wikipedia.org/wiki/IA-32), [x86-64](https://en.wikipedia.org/wiki/X86-64), [ARM](https://en.wikipedia.org/wiki/ARM_architecture), or [MIPS](https://en.wikipedia.org/wiki/MIPS_architecture) [ISAs](https://en.wikipedia.org/wiki/Instruction_set_architecture)) before executing it, instead of more traditional techniques such as [interpreting](https://en.wikipedia.org/wiki/Interpreter_(computing\)) bytecode or compiling the whole program to machine code and executing it from a filesystem. The compiled code is additionally optimized (and re-optimized) dynamically at runtime, based on heuristics of the code's execution profile. Optimization techniques used include [inlining](https://en.wikipedia.org/wiki/Inlining), [elision](https://en.wikipedia.org/wiki/Copy_elision) of expensive runtime properties, and [inline caching](https://en.wikipedia.org/wiki/Inline_caching), among many others. &gt; --- ^Interesting: [^Node.js](https://en.wikipedia.org/wiki/Node.js) ^| [^Google ^Chrome](https://en.wikipedia.org/wiki/Google_Chrome) ^| [^ECMAScript](https://en.wikipedia.org/wiki/ECMAScript) ^| [^JavaScript ^engine](https://en.wikipedia.org/wiki/JavaScript_engine) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cm5w0z1) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cm5w0z1)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I've heard people say that react is about immutable data types and bringing functional programming ideas to a JS framework. Maybe I'm dense, but I don't see the connection? Can anyone point me in the right direction? I've heard haskell folks going off on react and am trying to see what they're on about. I'm looking at things from an angular perspective most of the time if that matters.
How do other languages avoid this? 'By having types!' - but if you had an object in C# with a bunch of nullable types you can find yourself in a similar boat, and have similar solutions to be (if x.HasValue &amp;&amp; x.Value.SomeThing.HasValue &amp;&amp; x.Value.Something.Value) 
This is the issue every person flocking to frameworks is going to face. Their favorite go-to, gotta have or you're going to die, framework falls out of favor within three to five years of creation.
C# 6.0 added the ?. operator to remove the cumbersome null checks.
Figures, when I decide to leave the .NET platform, MS starts to get their shit together. Well, not just that - but I do like the direction they are taking with ASP.NET vNext, and their recent open sourcing of the .NET platform, and hell - IE Technical Preview having the best ES6 support. 
Awesome :D
Buggy as fuck, poor documentation, needlessly complex, bad performance, does not scale, shit design (unify stand-alone controllers and directives - simplifies routing, rendering, improves performance etc..), module system is pure useless garbage, development and bug fix time verrrrry slow, poor, bug-filled libraries, inconsistent and sporadic behaviour that can only be understood after miticilously reading documentation without being able to search it properly (postlink/prelink behaviour with template vs templateUrl), overall bad design leads to poor performance and lots of gotchas such as digest cycle problems. ReactJS is literally better in every single way. 
I added a command to my steam chat bot that allows you to enter and sentence and get back a url. Thanks for pointing this out :D. Someone should do this with a reddit bot hmm
Ok. I've used Angular about 6 months in a fairly large project but I don't think I can say that it's good or bad since I only scratched the surface but so far I like anyways. But it's good to know that there are other frameworks out there =)
True, although maybe it's just wishful thinking that an IT dept that allows people to install Chrome/FireFox would be of the mindset to not disable the auto-updating feature. A friend of mine used to work for a company where he had total control over his PC - they got bought out by a larger company, and part of the 'standardization process' had an image forced onto them that locked them into IE6 and couldn't install any other browsers. That larger company was also a client of where I worked - and was the main reason why I was forced to support IE6 for far too long ;( 
It makes sense to use immutable data stores *with* react, but there's nothing baked in. Put all of that to one side, learn react, then flux, then it should become clear how immutable data can be useful in this context.
This feels like a yucky hack. I would rather add a helper library like `l33teral`: https://github.com/nicholascloud/l33teral
Are there are demos? The canonical use-case is the "To Do" app: http://todomvc.com/
You can write your Angular 2.x application in JavaScript, AtScript, or Dart. You can also use any other language which seamlessly interacts with JavaScript like TypeScript or CoffeeScript. You only have to use AtScript if you want to contribute to Angular's 2.x itself.
This looks really cool. Will definitely investigate more later.
The documentation site itself is built using Taunus. http://taunus.bevacqua.io https://github.com/taunus/taunus.bevacqua.io My blog is also built using Taunus. http://ponyfoo.com/ https://github.com/ponyfoo/ponyfoo I'm considering both a yeoman generator and a TodoMVC example, but haven't gotten around to putting those together just yet.
How does that work? At the moment I'm only experimenting with react so my components will listen for a store change event and setState based on the incoming data (like in the refluxjs component example). But it looks like omniscientjs expects the data to be passed in from the parent. How does omniscientjs + react look?
&gt; sustainability Future browsers will be backwards compatible. Your existing stuff will continue to work fine. You'll be able to easily keep your existing Angular 1.x applications alive and kicking of the next 10 years if you want to. &gt; Only one of AtScript, TypeScript, Dart or JavaScript will still be there in 10 years. My bet: it will be called JavaScript. TS/AtS are *supposed* to disappear. The big idea is to get those features into ES7+. Dart will be probably still around. It's a nice language with excellent tools and a high-performance cross platform/architecture VM. You can use it as JS replacement, but you can also use it for all kinds of other things. It directly competes with all those other scripting languages like Python, Perl, PHP, Lua, or Ruby. It also competes with bulkier more verbose languages like C# or Java. It covers a very wide range of use cases. I use it for pretty much everything. It's a nice compact language with excellent tooling and pretty decent performance.
Are you familiar at all with angular? what do react components get me that I can't get with angular directives? Is it just a cleaner API?
What about it makes it feel like a hack? What makes l33teral different? l33teral introduces a huge processing overhead for something that can be done in under few lines of code.
I'm familiar with Angular but not in depth. Another way of looking at it is, what do you need from your framework or library? For me, angular is a mess of overcomplicated ideas, bad documentation and unnecessary terminology. If you use react, you will strip away all of this. You will only get a very simple API for working with UI component and it's one you can get to grips with in a couple of days. You do not get the whole architecture that angular provides, but for me this is an extra bonus. With Angular directives you have ng-bind and ng-model and all that. With react you have JavaScript and very little more.
Oh I just remembered, you could follow the Getting Started example: http://taunus.bevacqua.io/getting-started https://github.com/taunus/getting-started 
Funny; "Taunus" is the name of some group of mountains here in germany :)
I think we all want to work on the latest and greatest. That's just the way it is with web development. I have never started a project without wanting to try something new this time. Last project grunt, this one gulp. Things change when you are working on something And I don't want to build something in angular and five years down the line be this guy who codes in a zombie language that still works but isn't in active development. 
Well bootstrap / jquery are pretty standard. With JS we don't have that kind of stability. I am not even sure if I would build something that would last five years but I don't want to commit my time learning something that will die in a year or two. That just makes me sad but its just me being me
Here is a good intro by the author of omniscientjs: http://open.bekk.no/easier-reasoning-with-unidirectional-dataflow-and-immutable-data Your UI components will rely on `this.props.cursors`. But with JSX on react v0.12, you can do var Component = component(function ({ cursors}) { // stuff return ( &lt;div&gt;{something}&lt;/div&gt; ); }); Cursors passed from parent, should be passed to children. Otherwise, you need to do custom `shouldComponentUpdate` behaviour: https://github.com/omniscientjs/omniscient/issues/19#issuecomment-62299218 Now, to get refluxjs (or similar) into the equation, you move cursor modification logic (e.g. `cursor.update`) to the stores; in other words, away from the UI components. In this manner, omniscientjs will listen to cursor changes and update the react application accordingly: function render () { React.render( Welcome(structure.cursor()), document.querySelector('.app')); } render(); structure.on('swap', render); One advantage this gives is that you don't need to do wiring between UI components and the stores. Since UI components can just call `actions`, and cursor changes at the stores will be handled by omniscient. Your architecture will be like the following: Initial app state +-----&gt; Cursor +---&gt; UI Component ^ + | | | | + v Stores &lt;-----+ Actions 
[Here's the video of this presentation from Nodevember 2014](https://www.youtube.com/watch?v=5UuRj_1OG14) this last weekend.
&gt; who codes in a zombie language that still works but isn't in active development. http://www.reddit.com/r/javascript/comments/2mmyb4/will_angular_die_because_of_atscript/cm5y5yp
Great. Thanks!
That got me alot closer, thank you so much! Im in my first javascript class now and I got so confused on this project. 
I'm new to the whole coding community, so I was just wondering, would I be able to use the jquery i have for a smooth scroll vertical site and just make the site horizontal instead?
Everything that comes from this guy is gold
Someone answered this for me in /r/webdev: Try giving your .body-content a CSS transform that does nothing. Like so: .body-content { -webkit-transform: translate3d(0, 0, 0); } This will force the browser to use the GPU (instead of the CPU) to render your .body-content.
it's a good start, used it here. Look forward to some updates and will do a few pr's. don't let the jets-fool comment get you down. @cartalyst we have over a 100 repositories with different classifications. add on that multiple organizations and you can spend a good amount of time keeping it all organized. This took me about 5 minutes, job was done and I am back to developing. 
Dude, this was epic ^^ I mean : function identify (d) {return d;} made me actually lol.
I've really tried to make some good JavaScript games into cross platform apps. I'm very experienced with both phonegap, and JavaScript games, and it really is just a nightmare. Maybe sometime soon the operating systems stock browsers which phonegap apps depend on will provide a reasonable means to package JavaScript games as native mobile apps. I'm going to try Unity for my next game project. JavaScript is great, but it is really a poor for native mobile apps right now.
`class` is a reserved JavaScript word. The JSX is compiled straight to JS so your: &lt;div className="something" /&gt; Is converted into : React.DOM.div( { className: "something" } ); Since `class` is reserved and discouraged. It could potentially work as a key if used in string form, but I'm sure it was decided to just avoid the conflict and go with `className`. `for` (React: `htmlFor`) is also discouraged as you may guess. The only "big" issue is getting over `class` being `className` and on the rare occasion `htmlFor`. `action` is not restricted in such ways, AFAIK. Also, where I work, the dev does all the html/js/css and is given a PSD or a Reflow document to determine the final styles. We actually divide up back-end and front-end for this reason because the front-end works more closely with the design side to integrate their vision.
Oh, duh. That makes sense but it's still no good for designers. Too bad.
Good news for Durandal then. I find it much easier to understand the reasoning behind that framework.
Heh, designers aren't idiots. If you explain it, you could potentially get away with letting them use JSX. Just explain it as a templating engine like HTML with a few tweaks. I have no purpose or interest in testing this, but you could potentially break your code from the renderer by using liberal mixins. The React mixin is like an *also* where your methods can set private properties and modify state, but separating those could be messy for documentation and use. It would require that you tell your designers to use specific mixins for certain components and that could be worse.
Well for one it aims to be better documented. The Sails documentation seems to be sprawling with TODO bullet points, and their getting started guide doesn't go beyond "run `sails new project` and may god help you". I would say that is my primary concern about Sails. If you go to the documentation about writing a SPA, you'd have no idea how to build one using it. http://sailsjs.org/#/documentation/concepts/Views?q=what-about-singlepage-apps
I think its not so much the lack of documentation, has the excessive use of "magic". Everything just hangs together in a very unclear and non-standard way to someone coming from a previous technical background. The whole thing was made for designers though, so it makes sense.
Looking forward to future Durandal development. Hopefully embraces Typescript more, switches to knockout components for views and gets rid of JQuery as a dependency.
Here is a benchmark, http://jsperf.com/isset-try-throw-catch-vs-l33teral. Use of try catch is hurting the performance only when property does not exist. Otherwise, it is faster.
Looks interesting, but no windows version ?
You are right about the syntax.
Type checking? Windows? Uhm... TypeScript anyone?
Identity functions are actually quite useful for functional programming...
Just a recommendation to all: look into using http://gist.github.com/ or any other PasteBin to make your lives easier...
What do annotations and reflection have to do with object orientation?
I heard you'll only be able to write directives in AtS. Is that not true? Has anything I been said about the role of Dart in the 2.0 world?
OP probably forgot to include the link. I haven't read the book, but many O'Reilly books are open source/free these days. Here it is: http://speakingjs.com/es5/
The javascript engine used with native apps before ios8 was considerably worse than that used by safari, but I hear that the latest iOS native app js engine is really good. Games which played perfectly on mobile web would slow down hard in a phonegap app on the same phone. Things worked pretty well on some androids too, but most devices I tested either performed unacceptably or had unique bugs I could never have predicted. I tried making it work with every trick, hack, optimization, and reasonable sacrifices I could conceive of. The workarounds required for a cross platform phonegap is game are just too great. Developing a game app with any visual complexity with js is like swimming against the current in a storm. Canvas and js are meant for apps in web browsers. If you want a fun demo or prototype, a phonegap app is an option for cranking out a simplified version restricted to certain devices/operating systems. Trying to make a generally successful game app with this tech though is a madman's pursuit.
I think PhoneGap was the source of your problem, not JavaScript. The problem with PhoneGap was that the webview component that it uses was not hardware accelerated. I think iOS 8 and Android 5 might have fixed this.
&gt; Did we really need a new transpiled language just for annotations and reflection? Couldn't a comment syntax do it? That wouldn't actually change anything, would it? You'd still write not-JS and you'd still need a compiler. &gt;In fact, I'm pretty sure that's how the original Java annotation implementations did work. Metadata stuff was introduced with 5.0. It still looks the same. http://www.oracle.com/technetwork/articles/hunter-meta-096020.html &gt;ES6 adds classes and this is being celebrated, even though prototypes are regaining popularity and composition has pretty much 'won' the battle with inheritance. I "celebrate" it, too. http://www.reddit.com/r/programming/comments/2mm2pv/if_you_were_teaching_a_programming_course_what/cm5xoap
If targeting ecmascript 5+, reserved words are valid identifiers.
Why is this not self-hosted but written in OCaml? And why doesn't this work on windows? It's like we're back in 2005.
Kind of disappointing that it requires type annotations, and therefore a transform step in the build.
Eventually they'll add so many layers on top of JavaScript to fix all that is broken in it and/or lacking from it that they'll just turn it into Java. Native Java, in the browser!
I think that the supposed need for Windows support is a bit much. Yes, Windows does have a lot of market share, and yes, obviously web developers use Windows, but no, I don't think that Windows support is required.
&gt; That wouldn't actually change anything, would it? You'd still write not-JS and you'd still need a compiler. Errr.... actually, yeah. OK, I didn't really think about that. I suppose that if all you were using were the type annotations - for testing that things will work well before runtime - you wouldn't even need the transpiler; your IDE could do this. You can sorta achieve some of this already with JSDoc comments IIRC. &gt; Metadata stuff was introduced with 5.0. It still looks the same. I was thinking pre-JSR175. I'll have to look into it. &gt; I "celebrate" it, too. The class syntax is neater than using the prototypes, but that doesn't make it work better than using, say, parasitic composition, necessarily. Actually, you could even say it's worse, because now it *looks* like classical inheritance, but strictly speaking, it *isn't* - it's just a sugar for the prototypes (What happens when you 'extend' a 'public' array on an abstract, and push and pop from two different concrete instances? Not what you'd expect if you came from Java). 
typescript is cross platform though. So if this wants to compete with it youd think theyd do the same
Purely in terms of code cleanliness, when concatenating a series of strings (more than 2), I find this pattern to be the cleanest var finalString = [ 'String 1', 'String 2', 'String 3', ... ].join('');
I thought maybe you could write a JS library to load an HTML page and translate the DOM into React objects. The problem is the bindings, e.g., `&lt;span&gt;({isCompleted})&lt;/span&gt;`. That code is essentially a macro, so `isCompleted` is gotten from the surrounding scope. The library might still be possible, but it would have to be passed an explicit context (which may actually be a good thing). It should also only load the template file once and store the React objects, otherwise all the virtual-dom optimization is lost.
Seriously? Windows is still huge, many serious devs and companies have workstations running it. For example look at NuGet statistics for popular packages, it is pretty sick.
No, they aren't idiots and that wasn't my point. We are in the middle of a transition between templating tools, and it's no good if they can't write actual HTML in one of them. You don't have to be an idiot to hate the idea of constantly switching between attribute names (and who knows what else). Classes are a huge part of what our designers work with (by agreement, JS devs don't touch classes, we use other attributes.) And what happens when they screw up and put the wrong language in the wrong kind of template, etc. I just think it's not designed in a way we could use without all of us hating it.
Why does it have to be written in JavaScript? I do agree about the lack of Windows support. It's a bit odd. Even the Rubyists have stopped treating Windows like a second-class platform.
On the one hand this has some very cool features not yet in TypeScript, but on the other hand the overlap is huge. I'd rather see Facebook contribute to TS than develop a separate thing. It feels a bit like not-invented-here syndrome. Hopefully the two projects will feed off of each other and we won't get two slightly-incompatible statically-typed JS variants competing for mindshare. Of course if one was to go in a radically different direction that would be great but since both are committed to staying close to "raw" JS I doubt they will diverge much.
I don't even think you can get that far. Just compiling a react template (with reactify) results in "React.template = ... &lt;the template contents&gt;". So boom, right there you have to have a reference to React somehow. The best you can do is export it as global, yuck. It's just obvious that they really, really do not want to have templates separate from code. Again I understand their points for why that is, but if you need that, it makes React a complete non-starter. 
In no way am I trying to belittle Windows or say that it is not a good platform, but I really think that the continued disapproval a product launch that doesn't include Windows support is invalid.
In no way am I trying to belittle Windows or say that it is not a good platform, but I really think that the continued disapproval a product launch that doesn't include Windows support is invalid.
Should be written in Flow itself. A self-hosting compiler shows confidence in the language and the platform and it will run on all target platforms. Eg node, browsers, devices, whatever.
Invalid how so? There are plenty of devs that use windows. Just read what /u/brtt3000 said: &gt;Windows is still huge, many serious devs and companies have workstations running it. Look, a product launch can support whatever the fuck it wants to. But to say that asking for windows support is a bit much, *I think* is invalid. Windows still has huge market share, period. By excluding it, you exclude part of the community that actively develops with it.
No worries. I should also mention that I'm not a professional JS dev or tutor or anything, I've just been working with it for a while. Google (or really, Stackoverflow) is your God. Otherwise just PM me and I'll take a look if I can. 
It depends on what your goals are. I wanted to learn the underlying JavaScript to familiarize myself with all the new HTML5 stuff. If you'd rather just focus on making a game, you should probably use an existing framework.
* nodeJS is just a program (Not some javaScript code). The program runs JavaScript code instead of your browser. * Your browser is another program that runs JavaScript code. Angular JS is some JavaScript code that your browser runs if it's part of a web page. Therefor angularJS is limited to whatever your browser is capable of. * When nodeJS runs some code, there is no concept of a page by default. Instead there is the concept of the computer you are on and it's files, processes and network connections. * When your browser runs some code, there is a current page (document), the browser (navigator) and the current window (window).
Buzzwords, buzzwords everywhere.
Last time I checked Ruby on Windows still worked like crap. When did it improve?
OK. You've convinced me. Next to atScript's Golang-like method signatures, the other approaches do suck. What's the next step? Can we already start using it and prototyping with it?
Okay, I'll concede, it's not a *first* class citizen, but at least Windows isn't treated with *active, specific* hostility anymore. Some gems even compile under Cygwin.
looks pretty cool! i wrote this because i was forced to use plain backbone at work and backbone by itself doesnt offer as much as ember and angular after having worked with those for so long. unfortunately i dont think i can use ampersandjs but it does look awesome and good to keep in mind for the next project!
Namespacing will stop styles leaking out but it won't stop styles leaking in, and by eschewing OOCSS classes that segregate out particular presentational concerns, you're missing an opportunity for code reuse unless you repurpose OOCSS classes as SASS mixins. But this also makes the visual behaviour of a piece of markup less transparent (because a "semantic" class just tells me how some markup relates to a domain concept, not how it acts), which is probably a bad idea in a templates environment where your markup holds little content and just describes how a view works.
So basically TypeScript, but not made by Microsoft, so it will be probably be way more popular :\
Good think vagrant exists.
http://rubyinstaller.org/
And the weird thing is there *are* programs (Closure compiler, Webstorm (which probably uses CC)) that check JSDoc annotation accuracy, so you don't even need to transform your code. Just properly document your code. There is a nifty tool to insert jsdoc template comments into existing code, but I can't find it, my google-fu is weak right now. I keep running into stuff that generates documentation pages.
So you mean that huge group of developers who work on Windows using one of the most popular programming languages and platforms (C#, .NET) should just be ignored? Ignoring a huge platform like Windows is mind-numbingly stupid. Is it better? As a programmer who has worked for over 20 years mostly on the Windows platform I can tell you that it pretty much sucks balls in a lot of ways. But that is subjective opinion. Unless they have a version that runs on Windows, they will be ignoring around half their potential developer base. And adoption is the key to success. 
Yeah, the Sails docs suck! I was excited about the project but very disappointed about the lack of documentation. Also, i am fairly new to using Node+Express. My understanding after reading over the Taunus getting started is that Taunus in a way provides what Angular would, but more tightly integrate with Express?
Well, Taunus aims to be more modular and progressive so it's not very similar to Angular. It does provide you with MVC and allow you to use databinding modules, but it doesn't dictate anything besides MVC and giving you shared rendering capabilities.
Just finished the yeoman generator! https://github.com/taunus/generator-taunus
How the view 'works' is a non issue in React since the functional parts are in the Component logic (or should be). If you are using a library that relies on finding specific class modifiers to perform some action you are sidestepping what React can do for you. I've had zero need to specify a class for my projects done in React that do anything more than display changes. Styles leaking in can happen with any scheme. All it takes is someone else deciding that they want their widget named the same as your Component and all bets are off. The only way that would even work reliably is if your CSS identifier was generated with the Component and in-lined. We have a standard of namespacing all CSS on a widget level and it's been working perfectly fine for every project kicked out. If someone violates that rule and their CSS breaks another part of the page they owe everyone else donuts... because it's important enough to enforce the standard, but rarely is it ever hard to track down or worth the hassle of OOCSS. I've actually found it beneficial to not add modifiers to CSS definitions.
DocBlockr? I use the Sublime plugin.
there is another js library called 'zepto' does this, its api is 100% jQuery-compatible. http://zeptojs.com my objective was a bit different: covering the same functionalities, keeping it lightweight and performing better (especially on mobile devices) at the same time. I think jQuery API brings some complexity with itself, it basically hits the client performance. Benchmarks are available on https://larukedi.github.io/laroux.js/benchmarks.html
Image processor makes these URLS available to me a la 2004 style spectacular with generosity I might add. I did this: (GRIEF_KEY|GRIEF_KEY_X|GRIEF_KEY_Y) in the end, but I feel dirty.
&gt;about a **local** repository /** * @return {String} Username of the repository author. */ gitinfo.username = function () { return gitinfo._remoteOriginURL().split(':')[1].split('/')[0]; }; This returns the username of the **remote** repository and only works for when SSH is used as the connection medium. I have some https repos. A better method would scan the index for contributors and list them I guess. Some of the methods are good and operate on the local repo so :) What i'm particularly looking for is a nodey way of getting a list of files that are due to be commited. Which could form a part of a git hook I need to write :).
Yes thank you I did not notice xD However the code resulted in the same problem unfortunately. 
It's the same as CSS selectors: $('selector1, selector2, selector3').on('keypress', handler); You can also use .add jQueryObject1.add(jQueryObject2).on('keypres', handler);
I haven't watched the video yet, but I looked through the slides and see that you found Cordova to be unsuitable for making games. What would it take to make it suitable? Is it mainly about accelerated canvas? Regarding Android, have you looked at Crosswalk? 
 /(\/GRIEF_KEY)(_[AB])?(?=\/)/ Yes, I see and I like! 
there's plenty of discussions on the web about static vs dynamic typing. even on the page linked in this post. being able to spot bugs immediately after saving your code is a huge advantage. coming from a statically typed background it really annoys me that sometimes i simply switch two arguments to a function around and end up spending ages trying to figure out why some feature that can be completely unrelated to this error isn't working. it all depends on the complexity of your project. for simple web-based event stuff it may seem unnecessary but since i've been working on a large node based project i really suffer from the lack of type checking. in the worst case it will save you time tracking bugs and prevent you from creating them in the first place. for details and examples i suggest doing a simple google search or checking the linked article. if you haven't asked for a static type checker and feel you don't need it no one is forcing you to use one. your comment seems a little pointless.
Gives a 404.. Moved? Or private?
mistyped when linking, thanks.
What does your comment even mean?
You didn't even read Node's Wikipedia article, did you?
Are they obliged to provide support though? It's a free tool, they can support what they want.
http://en.wikipedia.org/wiki/Linear_interpolation If moving 100 units takes 1 second and 0.5 seconds have passed, you've moved 50 units so far. That's it, really.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Linear interpolation**](https://en.wikipedia.org/wiki/Linear%20interpolation): [](#sfw) --- &gt; &gt;In mathematics, __linear interpolation__ is a method of [curve fitting](https://en.wikipedia.org/wiki/Curve_fitting) using [linear polynomials](https://en.wikipedia.org/wiki/Linear_polynomial). &gt;==== &gt;[**Image**](https://i.imgur.com/27QFYdo.png) [^(i)](https://commons.wikimedia.org/wiki/File:LinearInterpolation.svg) - *Given the two red points, the blue line is the linear interpolant between the points, and the value y at x may be found by linear interpolation.* --- ^Interesting: [^Interpolation](https://en.wikipedia.org/wiki/Interpolation) ^| [^Bilinear ^interpolation](https://en.wikipedia.org/wiki/Bilinear_interpolation) ^| [^Slerp](https://en.wikipedia.org/wiki/Slerp) ^| [^Trilinear ^interpolation](https://en.wikipedia.org/wiki/Trilinear_interpolation) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cm6m9dv) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cm6m9dv)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Haha yes, it definitively improved with Vagrant. 
This is interesting. I do like plain HTML templates. 
Because Javascript is on what seems like an inevitable trend towards being *the* ubiquitous "web language" from which other languages will attempt to compile down into.
They are supersets, not subsets.
Nuget stats are your proof that windows is huge? isn't that a bit of a tautology?
He means MS haters gonna hate.
In many cases, dynamic typing is *not* a benefit in the language. I shouldn't have to write a test case for my "add" function that should only take numbers, and throws on non-number types being passed to it. Indeed, this is an effort to make javascript behave differently, or rather, to move more errors into compile time than runtime. Testing is important, but it's a waste of time to test that type contracts are being enforced when we've got perfectly capable tools to statically ensure that never happens. Edit: Because you deleted your reply to this comment, let me post my reply to what you'd written with regards to dynamic typing being a feature of the language: &gt; Indeed it is a feature of the language, I'm not disputing that. But, as often happens in languages, features can be double edged swords. In my opinion (and with quite a bit of experience writing javascript), large applications make it hard to reason about the type of an object without also having to reason about an unnecessarily large scope of the project. As far as I can tell, our disagreement is "is it better to be statically/strongly or dynamically/weakly typed". Tools like Coffeescript (and many of the sugary tools out there) don't aim to add typing to the language, so I don't have much of an opinion on them (other than that they're not particularly useful to me vs writing plain old JS). I wouldn't consider Flow a crutch. I feel that implies that the unskilled developer needs to rely on it, while skilled developers can manage large codebases without any form of static typechecking at all. Testing is important to make sure that functions are behaving correctly (is my "add" function summing two variables or multiplying them?), but I'm still of the opinion that a type system can save a lot of headache waiting for a rare codepath to be run with an unexpected type if the mistake can be caught statically. 
Did you read the part where they said: "This is fundamentally different than TypeScript because..."
This is not a web app though. It runs on a server and is the type of task much more suited to a language like OCaml. Why use a language whose native semantics are not as amenable to the problem at hand?
I suspect you're thinking what I am, but just not phrasing it very clearly: Windows support *is* important, but we shouldn't shame people for letting us see their work before they've made it fully cross-platform. It has to start with one platform anyway, and getting people involved early will only increase the quality of the final result.
React has a virtual DOM, a tree structure like the DOM but in JavaScript (so it's fast). You describe what the real DOM looks like using the virtual dom, and React uses heuristics to efficiently update the DOM by looking at the differences between successive states.
You start at one place, say x1, y1. You want to go to a new position, x2,y2 in 20 steps. First you calculate the "deltas": dx = (x2-x1) / 20 dy = (y2-y1) / 20 Start at x1,y1: x = x1 y = y1 Then 20 times: x = x + dx y = y + dy &lt;redraw&gt; That's it. You've probably heard of it before as "tweening." 
I'm not against static typing. I'm against pre-compiling javascript to attain static typing. As long as we're testing our code, it shouldn't matter what kinds of typing we use, but Flow requires that we write our code in a modified DSL in order to gain its full benefits, which is what I don't see value in.
Lack of Windows support is a major bummer. TypeScript works just fine for me!
The documentation has almost everything you need. the reason why it sucks is because you don't have prerequisites. Diving straight into sails with 0 knowledge of node, js, express, is absolute killer. It's like reading meanjs's document without having knowledge of angular, moongoos, and express.
Ugh. They're just blatantly copying [this](http://en.wikipedia.org/wiki/Chatroulette) framework. It's like they're not even trying any more.
Im sure there will be win support, its just released and still in development so, unfortunately win users often get left last. The be honest i dont know many devs who agree/want to develop anything on a win box.
Actually, you *can* assign more than one event listener and nothing gets overwritten. What you can't do is assign exactly the same function as handler more than once. i.e. this ( http://jsfiddle.net/m598hfxa/1/ ) executes both `foo` and `bar`: elem.addEventlistener('click', foo, false); elem.addEventlistener('click', bar, false); but if you ( http://jsfiddle.net/m598hfxa/2/ ): elem.addEventlistener('click', foo, false); elem.addEventlistener('click', foo, false); `foo` will only be executed once. And generally it makes sense and I don't think I've ever found the need to set the *same* handler twice. But you could... almost. You can create a copy of the function ( http://jsfiddle.net/m598hfxa/3/ ) and then... elem.addEventlistener('click', foo, false); elem.addEventlistener('click', foo.bind(null), false); both will be executed.
This is one of many beautifull things about the closure compiler. OCaml however is a language which tends to produce incredibly fast compilers.
I'm too lazy to link it, but there are tools to transform html into jsx / react classes, you know.
Good point! I have added a plug-ins section.
Until you can POST dicks, this isn't complete
Nice one. There is a memory leak tho: you should cancel the previous requestAnimFrame in start() (so when you click generate they won't pile up)
As the name suggests, functional programming revolves a lot around functions. The majority of the code you write is going to be based around composing functions together, which can often mean that you can't easily pass around primitive values. For example, let's say we want to take an array and log out all the values. We might do something like: var arr = [0, 1, 2]; var id = function(d) { return d; } var log = function(v) { console.log(v); }; var mix = function(f1, f2) { return function(e) { f1(f2(e)); } }; var logEachElement = mix(log, id); arr.forEach(logEachElement); Which seems a lot more complicated, right? The trick is that the way we're getting the result (logging each element) is composed of smaller functions that don't know about anything else. So if we wanted to multiply each element in the array by 2 before we logged, we could do: var mulByTwo = function(d) { return d * 2; } var multiplyByTwoAndLog = mix(log, mulByTwo); arr.forEach(multiplyByTwoAndLog); We're using the exact same log function, but now we have it logging all the multiplied values. Now, sure. This seems like way more typing than you need. But think about it - we've declared a standard set of functions to do generic operations. "mulByTwo" doesn't know that it's operating on an array; it just cares about a single value. So you could re-use the exact same function for walking over maps, or other data structures, without having to change anything. If it looks rather trivial, that's because it is. But you can imagine a scenario where you have lots of complex behaviour that you need to do. Breaking it up into functions that can then be put together is really, really powerful. Hope that helps. 
Thank you for taking the time to explain all of this. I'm gonna take a look at functional programming now. This looks like some pretty cool stuff and i've ignored this paradigm for too long now. :) 
Sure can
Awesome! It's a very different way of thinking about things compared to how you might be used to, but it can change the way you look at code. Have fun! 
Why couldn't web designers edit the JSX files? Where I work they change the react components files without any problem. A web designer shouldn't skip a basic JavaScript knowledge.
Like with the swift programming language. I't just matter of time before someone release a framework called Taylor ;)
&gt; counter is set as a global function, you must add var infront of it Doh! Didn't notice that! &gt; currently i++ is actually updating a global i not the i inside the check function How did the i became global?
Are you going to update it when the video comes? Not to be rude but i always feel slides are less then half the story. But it looks interesting 
No. There is no global i to update. You said it half right: the problem is that, since `counter` is an implied global, each invocation of `check` will rewrite it, capturing the local `i` in its closure. The previously set setTimeout will invoke this rewritten `counter` function the next time it is scheduled to run. The result is that both setTimeouts invoke the same global function that in turns increments the same local `i` (the last one) created by `check.
I am a beginner as well. I really liked the Codeacademy series about Javascript. I've read on other posts on this forum that more or less bashed it. I see it as a good stepping stone. I would be interested in knowing what others disliked about it and some good recommendations on what is better.
sorry, the URL didn't make it for some reason. http://lokijs.org/
That's awesome to know, thanks! :D From what I can read on [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) bind creates a new function. But do you have any explanation why this function is not overwritten? Because it still has to point somewhere, so why isnt that null pointer errased? Am I understanding this correctly? Reading about the bind I found some other interesting behaviors and "edge use cases" function ConstructorConstructor (x, y) { this.x = x; this.y = y; }; var Constructor = ConstructorConstructor.bind(null); var object = new Constructor(5, 5); console.log( object ); // ConstructorConstructor {x: 5, y: 5} var Constructor = ConstructorConstructor.bind(null, 10, 10); var object = new Constructor(5, 5); console.log( object ); // ConstructorConstructor {x: 10, y: 10} 
Cool. Have you checked our MongoDB before? Seems pretty much the same. Love using that with Node.
Absolutely! I'm all about the MEAN stack. If you haven't already, check out Yeoman, it's a cool little scaffolding tool. Automates a lot of tasks with Grunt too. yeoman.io 
I've never actually taken any Javascript courses, personally, but I feel like there are a lot of little nuances to Javascript that could end up not being covered properly. I could be entirely wrong, though.
Sweet, I'll check it out. Their website seems to be down atm. You done much with AngularJS before? I've used it a fair bit but from the news I've heard they're completely changing it for v2.0 - Recommend any alternatives? React I think is one?
I noticed that too. I've worked Angular a bit and I really like it. But ya, seems to be changing for v2.0. I've heard a lot about React, but haven't used it before. Same with Ember and Knockout. Those seem to be the other big players people are turning to.
I'm not sure I understand what you expect to be overwritten, but if you try an [example with arrays](http://i.imgur.com/DrydZ5l.png) you'll se some methods modify the original array and some return a new array but don't modify the original one. With functions, `bind` works that second way: it *returns* a new function, but it doesn't modify the original one. Now, I don't understand what exactly you mean by the "function not getting overwritten" and I don't know what "null pointer" you are referring to. Please, explain that and I¬°ll try to answer better. Meanwhile, hoping it helps, I'll leave you this other question: var f = function(a) { return a+1; }; var g = f; var h = f.bind(null); var l = h; f.bind(null); There are 3 functions there, and 4 variables. Are you ok with that?
You need to have something in your backend that prevents them from upvoting several times. Otherwise they could just refresh the page and vote again. (Or write a script that upvotes a million times)
From the article: &gt;Flow infers those types automatically wherever possible, which means that it can find type errors without needing any changes to the code at all. So it attempts to "figure out" what types of variables you are using based on the context. From their simple example: function onlyWorksOnNumbers(x) { return x * 10; } onlyWorksOnNumbers('Hello, world!'); Flow would recognize that multiplying a string by a number is invalid and throw an error. I don't know much about TypeScript, but I take that you have to explicitly annotate a function/variable for it to catch an error like that. I'm sure there are some other key differences, but the barrier of entry seems lower with Flow. **Edit:** You can explicitly annotate things in Flow as well. You just don't always *have to*.
Yeah a video would be in place. Looks really interesting but just slides makes it feel like it's only half the content.
I agree completely with you. My last ditch effort of hope is that the people at Google have a good reason for making the changes, but so far, I can't find any. Solid article though, thanks. Sheds some light on the matter.
Yeah, let's hope they know better than us mere mortals and create something better. Let me know how you get on if you try any of the Angular alternatives!
Reminds me of my JS1k entry last year http://js1k.com/2013-spring/demo/1390 (Bonus: Cut down the trees with the mouse cursor)
*f* is a function. *g* is just a reference to *f*. *h* is a new function that "copies" *f*. *l* is a reference to *h* aaand... the last line creates an anonymous function of *f* ? I try to explain it later. I will reply here. But first I need a coffee to wake up haha :)
Don't keep track of how many up votes something has. Keep track of who has up voted it. 
Almost correct. Ok, I'll wait :)
Wouldn't one way to be to give them a cookie that tracks if they voted? Once they revisit the site, get the cookie check their vote status. If they've already voted disable onclick for them.
I'm not completely sure I agree with this being called point free style. I'm on the fence. On one hand yes we are not explicitly calling functions with the arguments provided by the high order function. On the other hand we are still explicitly listing where these arguments should be bound. This is trading explicit argument binding with a somewhat less explicit form of argument binding. The point being we are mentioning arguments in this style. I'd title this article, "currying by proxy is super sweet". The question remains what am I saving with this method? How is this superior to the terseness of arrow functions? Presumably I'm introducing more than a single function's overhead with spots vs using a proper transpiler and wielding arrow functions. This example is nice: ``` [1, 2, 3].map(function (x) { return parseInt(x, 10); }) ``` vs ``` [1, 2, 3].map(S(parseInt, S, 10)) ``` But arrow functions get us mostly there: ``` [1, 2, 3].map(x =&gt; parseInt(x, 10)) ``` Don't get me wrong, this is a very nice concept, I'm just not sure it is necessary. 
Thanks for posting, I eventually would like to see the actual presentation from those slides, seems very interesting.
I think this suffers from the "anything simple enough to explain in a blob post to a newcomer, is simple enough to work around" problem :-)
OP is not author AFAIK
Do you want to disallow "click to unupvote" like HackerNews does?
I use **MDN** quite often. But what I am looking for is something less kitchen sink, and more just a fridge. I have heard good things about *classie.js* but am not sure. I know **Node** is not the same as **jQuery** but what syntax does Node actually use? Is it Vanilla JavaScript or is its own syntax? Basically I have mastered simpler JavaScript/jQuery and want to move on and up to the more difficult/advanced practices
jQuery is a **library**, NodeJS is a **runtime environnement** (browser too). You can use jQuery in Node context. If you want to learn more advanced Javascript, you first have to understand JS basics, so my advice is : read this book http://speakingjs.com/es5/ (Not so hard as it looks)
jQuery is mostly used in a browser. Node.js allows you to run javascript without a browser. Node.js allows you to do things with javascript that you would otherwise use a language like Java, Python or Ruby to accomplish. You would use node.js to accomplish different goals than jQuery/Browser javascript. Since jQuery is nearly always used in a browser, I think you are talking about wanting to learn the native browser API's. The API that is most often abstracted by jQuery is the browser DOM API however jQuery also handles AJAX requests and other functionality. If you are curious about how to eliminate jQuery from your code I would research browser DOM tutorials. Learning never hurts but there are very few cases where you cannot use jQuery in your code. It has been a very long time since I have had to care about working directly with the browser DOM API. Good Luck 
Codecademy is excellent as an extremely basic introduction to a language you've never touched in your life. That's it. You won't walk away feeling like you learned anything. You most certainly won't be able to build anything of consequence. The fundamental problem with codecademy is that it holds your hand to such a high degree that you don't have to do any critical thinking at all. I find this is also true of Code School, and the majority of online tutorials as well. Unfortunately, programming is a lot like math - if you're not in the trenches actively wrestling with problems and figuring things out, you're not going to be able to apply abstract concepts to real world problems. Sure, go through codecademy's JavaScript course - you can probably blast through it in under a week. If it helps you be less intimidated by the language, then it basically did its job. Then go read a book like Eloquent Javascript and dig your heels in.
`i` isn't global.
Thanks for a **decent** reply. I knew I would get one eventually! I have used a few things that are more aimed at the **DOM API** other than through jQuery - however using AJAX without jQuery is an absolute nightmare! What I want to do is learn to use things such as : * Node.js * React framework * Various other npm packages that are used in more advanced JavaScript applications. So the long and short of it is : *learn more advanced JavaScript whether it be jQuery or Vanilla*
for OP this is whats called a microservice.
Yeah, it would be if he put his own name in front of the title. Everyone knows that's bad SEO. 
Then after being sued they can change it to 'Becky'
You can use npm modules (which tend to work in NodeJS and the browser) through a tool like browserify or webpack. This gives you a wide range of front-end tools at your disposal, without resorting to the bloat of jQuery. Along the way you will probably also start to pick up bits of NodeJS, like it's event system, module patterns, testing, etc. Examples: https://github.com/npm-dom http://mattdesl.github.io/frontend-npm-goodies/dist/ https://github.com/mattdesl/module-best-practices https://gist.github.com/mattdesl/73e3b9f902f9c834b721 
_The browser has everything you need built in._ That's absolutely true, but I think jQuery is more about unification, than about extending native APIs, especially if you're targeting old browsers. http://youmightnotneedjquery.com/ -- didn't know about this one, that's quite useful.
From what I understand so far, the differences are not too great. Flow seems to be a lot more aggressive with its type inference than what TS currently aims at. This means Flow can figure things out with less "hand holding" or type annotations than TS. This most likely comes at a cost, and is why it sounds like Flow is best left continuously running the background and not just run during some compile step. Both support explicit type annotations and code which has this would need to be compiled down to ES5 before use (for example). I also get the impression that Flow is bit stricter than TS with respect to null and undefined (a good thing I suspect). 
Indeed. I know it was getting fixed for iOS 8. Various android devices worked well too.
No, I don't mean that. I may have meant one is a language which extends JS and has a tool to process it, and the other is a tool which processes JS code, though. But no, I probably mean what I said. It's all in the intention, you see. TypeScript was born a language, a language which compiles to JS, sure, but the intention was that of building a language. Flow is born a tool, more specifically a tool for type checking. Not even "a type system to extend JS", no, "a tool to type check JS code". A tool that may use some optional annotations over JS source code (something which is far from being "a language which extends JS"). You may, of course, disagree with my point of view. I may even like discussing it. But, please, don't say I mean things I don't. It serves no purpose.
She does not explicitly need to use a database, a text file will do. However, she needs some server-side code to do the file writing. She could use server side javascript (node.js) for that, but it is more likely PHP or Perl will be supported by the free hosting. The flow would then go like - you visit herdomain.com/form.html, fill in the form, hit submit. Her script will listen for click on the submit button, collect the data from the form by accessing each input and reading its .value and then send it as JSON in an xhr POST request to herdomain.com/save.php which will receive the request and write its content to the file. 
Yahoo has killed YUI. No new development: http://yahooeng.tumblr.com/post/96098168666/important-announcement-regarding-yui
Then you sir are braver than I am lol
This makes me sad :(
Thank you :) I was looking at these earlier today!
http://pastebin.com/v8WBAC0Q 
This style works a lot better when you can curry in a more effective way - cough cough [Ramdajs](ramda.github.io/ramdocs/docs/)
Oh ok. I was not aware of that. Thanks :D
it's very unassuming, deals with deltas - perfect implementation. recently replaced all of our jquery-ui stuff or this. ++
So in a nutshell Node is more like PHP ? 
Cheers man, I was looking for the source of the bug which caused the wind angle to go mad after you click generate. In fact it was changing twice faster. Thanks again !
 [`flow port`](https://github.com/facebook/flow/issues/3), perhaps?
I was thinking about stuff like that, or the mouse applying a force to the branches but I chose to keep it simple.
From looking at the Flow examples, it looks like they're both languages, although Flow is coy about it: /* @flow */ function foo(x: string, y: number): string { return x.length * y; } foo('Hello', 42); Flow is JS + some type annotations. It won't run without transpiling. That's my impression from the docs, anyway. I haven't tried it. Have I misunderstood?
Take a look at twitter bootstrap. It provides many quality components that are "easy" &lt;--(always relative) to use. If you master its css framework using less css, you will can accomplish any css task. I am sure there are other competing frameworks like bootstrap. I found that bootstrap was the best and best documented as of a year ago.
Yup. Node can do more than PHP but most people use node like they use PHP.
&gt; ramda.github.io/ramdocs/docs/ At first glance, this looks much like underscore.js.
amazing results guys. Congrats! 
Saving the world, one browser at a time. Keep up the good work.
Why do you need two-way data-binding? I ask because I've never had a project where the time it saved me up front wasn't outweighed by the debugging costs in the end. I've always used something akin to the one-way data flow made recently popular by React -- though I mostly used it on thick clients. Are you trying to make something that needs SEO? Browser requirements? 
Those annotations are optional. And in any case, that doesn't make "a language". 
YUI isn't a CSS framework 
&gt;PS: You shouldn't down vote someone for asking a question in this sub. If you disagree in some way, you should respond. Maybe they only read the first sentence? &gt; I've never asked for a static type checker 
Why do they put node.js in the title if it is a specific express problem? also, did this get fixed in express?
YUI provides components. Bootstrap provides components. YUI components require CSS. Bootstrap components require CSS. The difference is that bootstrap claims that their approach to CSS is reasonable for other projects. I learned a whole lot about responsive design (mobile web development) from the bootstrap project.
Probably because this is about using flame graphs to troubleshoot a Node.js performance problem. (The issue was in Express--actually, in their own code's interaction with Express--but they didn't know that when they started, so they were troubleshooting Node.)
"Node.js in Flames" is the title of the blog post.
It's nice for user input, fill textbox with values then update values when the user changes them. 
Does Flow support ECMA6 like TS? If it does, then it's a superset of current JS. 
So... is Traceur a language?
I tend to agree, but getting people to put the annotations is hard; getting them to put the correct annotations is near impossible.
I would have found it preferable if you'd just worded it differently. Whatever; this is the internets, after all. Anyway, I've looked at the docs and I've seen the same things you've seen. Yes, I've even seen that the only place where they say "language" is there, in that "Language Reference" title. But that, still, doesn't make it "a language". Flow, per se, is still a tool. Not even "a tool that defines a language". It's a tool that runs on JS code or "annotated JS code". It does include some optional "extra syntax", true, but it's no "Flow language compiler" to me.
tl;dr Dudes at Netflix doing some hacky shit with Express.js and route handlers (throwing KISS out the window entirely), then wrote a blog post about how they fixed their bug while giving it a flame-baiting title. 
Exactly right... Netflix wasn't bashing Node. They were being punny.
/r/LearnJavascript please
/u/surgioclemento is right, I am not Addy! FWIW, Addy usually uploads his slides, and then the video follows a week or so later. If I am not beaten to it, sure, I'll post the video too! Edit: `@` --&gt; `/u/` because Reddit
Awesomesauce. Now my *brain* hurts.
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding. Also, the linked article has absolutely zero to do with JavaScript as far as I can tell.
Eran Hammer's response basically sums up why this is entirely Netflix's own fault, and not actually a bug in either node.js or express.js: &gt; Here was a developer blaming the framework he chose for poor architecture when they never bothered to actually learn how the framework works in the first place. Everything that followed originated from this basic lack of understanding. &gt; &gt; [...] &gt; &gt; The Netflix post does take responsibility for failing to understand how the framework they chose works. But that admission does not excuse criticizing the framework as inept. \- [Response to Netflix's "Node.js in Flames" Blog Post](https://gist.github.com/hueniverse/a3109f716bf25718ba0e)
I might publish an article this week explaining the code further in details at http://codetheory.in/
Thanks for the question! Parse is a cloud database for applications. Servant is cloud database for people. Instead of applications having the database, end-users have their own. When users have their own database: * They can bring their data to applications * Always retain control of their data * And use the same data across multiple applications. The benefits of this for developers are just as great. The full benefits list is [here](https://developers.servant.co).
Hi kenman Thanks for your comment. This was about a scientist who used distributed javascript for non-profit research. Whereas the technology is built by us, I thought it appropriate to speak about what he did on the forum. Having said that I am the first to admit that my posts have all been related to the technology we developed. If you prefer that I remove the post, I will do so. 
we install firebug first. 
It's already been removed, we just need you to submit from multiple sources. And if you're a for-profit product or service, then you should use http://www.reddit.com/advertising.
&gt; did this get fixed in express It's not a bug, it's an intended feature. You can have multiple routes to the same path because route handlers can be middleware that call next() and allow the second handler to continue operating. It's the same as calling .use() with a path as the first argument, you're just defining a middleware that is also method specific. The Netflix dev's just didn't understand this core component of the Express API. The more important question is why the hell they're reloading route handlers after initial setup. Any code those routes map to would be unchanged.
I would disagree on that one. The research side is non-profit, so these guys are using distributed js for free, and researchers always will. Either way, difference in opinions, and it is your website, so your rules. Cheers.
Yeah, Netflix said it was their fault too. But they also raised the point that the framework could handle error states better -- specifically the thing about multiple handlers for the same route. Humans use software, they fuck up, frameworks should partially be about pointing out those errors so the humans can find and fix their fuckups.
I find Addy Osmani's slides hold up quite well on their own (though a full video is of course always better). 
on the firefox developer edition you can inspect the object perfectly fine.. not sure about the version of ff you're on though.
This. Whatever you do client side can just be overridden.
I don't think you misunderstood it, but people are saying that criticism was misguided. The bug was ultimately theirs. But the real point of the article is how they troubleshooted a performance problem, and I think that was the most useful part. I'd ignore the Express criticism.
You are mistaken about the basic terms. A Relational database is built on relations. This has nothing to do with relationships between data as in joins. A table represents a relation. It seems to be an urban myth that "relational" in rdbms is about entity relationships. But it's true that noSQL datastores usually don't support joins. Mongo is certainly not idiot-proof, but the mongo monks usually recommend all sorts of sharding redundancy for production setups, and that article writer possibly had been running with scissors. Never gonna use scissors again for anything!
Can someone explain why they were reloading route handlers ~~every ten hours~~ ten times an hour (Or at all)?
Even if it is an intended feature to support multiple handlers for each route, there are better data structures that don't require O(n) search time to find them. The simplest way would be to create an object indexed by the routes with an array of handlers for each.
That Spots function he wrote is already covered by underscore/lodash's _.partial method. for example: var logAlso = _.partial(console.log, _, ' and also ', _); logAlso('This', 'That'); will output 'This and also That'
I don't think a video is available https://twitter.com/addyosmani/status/531848745550626816
That's why I precisely why I posted them!
That's too bad, I just replied to that tweet, asking him to record everything in future. He should spread the awesomeness of his talks beyond a narrow geographic confine! Edit: Looks like [we have a winner](https://twitter.com/addyosmani/status/535225303455772673)!
Everybody got really sensitive about this and I think that's too bad. 
Truth. Further attention will note the reordering of parameters within Ramda's API - allowing for more functional styles to be used... currying and composition specifically.
Express routes are regular expressions. You can't use RegExps as object keys, and even if you could you would still have to evaluate them sequentially. This is why Express supports tree structures through the use of nested express.router instances. If you've got a bunch of routes with a common base path, you put them in a router that gets mounted on that path. Each tier only has a few individual routes to check against. Additionally, supporting multiple handlers is useless without a sequential evaluation. The entire point of Express's middleware pattern is that the request gets evaluated in the order that you define it in the code. It's the core design principle of Express. If that isn't conducive with the way you want to build the application, that's fine, but then you shouldn't use Express.
Express shouldn't use a different data structure. The only way to resolve paths is to iterate through the list of regexs and test them. What is the author suggesting they do? Regex for map keys? How would that work? (It wouldn't.) Seems to me like for all the expertise Netflix engineers must have, this just boils down to someone not RTFM. Edit: To be clear, I think there's definitely some responsibility on the Express team to make their API a little more intuitive - they could easily have a check to make sure the same exact regex isn't used on another route. This definitely isn't a node.js problem though. That's like blaming the engine for your steering wheel not working. Edit: yup guys I get it, compiled regex.
While I see why how they came up with the title, it still seems like click bait.
There are other ways to find a matching route than an array of regexes. Other commenters on hn go into more detail, but it is possible to build a state machine which can match routes much faster without having to iterate through all the possible ones.
Cool article but I agree with some of the other posters that the title reads like there was an issue with node
Not every ten hours, ten times per hour!
There are lots of tiny libraries for that: var observable = require('observable'); var input = document.querySelector('#text'); var label = document.querySelector('#label'); var obs = observable.input(input); obs(function (value) { label.textContent = value; }); or you can just listen for the change and keyup events: var input = document.querySelector('#text'); var label = document.querySelector('#label'); input.addEventListener('keyup', onchange); input.addEventListener('change', onchange); function onchange () { label.textContent = input.value; } It's hardly the sort of feature you'd need a big framework for. I wonder if people just have never heard of these DOM APIs directly? Or perhaps the browser wars scared people off of them. Anyways the DOM isn't too bad nowadays and you can always sprinkle in a single-purpose library or two to pave over the unpleasant parts (like the xhr package on npm to do xhr).
This is not a production code. This is just an interesting piece of code that my coworker shared with me. I want to find why it works that way.
As /u/frambot points out, this is a consciously designed feature of express.js - it is in no way a 'gotcha' or anything similar since they simply didn't understand at all how the routes work. I [commented about this](https://gist.github.com/hueniverse/a3109f716bf25718ba0e#comment-1340831) on Eran's post. Here is the example I gave: // handlers/logged-in.js module.exports = function(app) { app.get('/account/*', function (req, res, next) { var loggedIn = /* Some logic to ensure user is logged in */ loggedIn ? next() : /* redirect to /login */ }); } // handlers/account-menu.js module.exports = function(app) { app.get('/account/*', function (req, res, next) { /* Some logic to display the My Account pull-down menu */ next(); }); } // main.js var express = require('express'); var requireLogin = require('./handlers/logged-in'); var showAccountMenu = require('./handlers/account-menu'); var app = express(); requireLogin(app); showAccountMenu(app); app.listen(3000); 
Can you link to those explanations / copy+pasta them here? I don't know how to do that when you could have wildly different regex's, and order is important.
https://www.youtube.com/watch?v=8aGhZQkoFbQ This presentation should explain what's going on. It's on the JavaScript event loop and call stack. 
You can try using d3.nest's `map` function instead of the `entries` function. It has a pitfall that if the key is not a string, it will coerced to one. And it only returns associative arrays. For example: var x = [ {a: 'i', b: 'j', c: 1}, {a: 'i', b: 'j', c: 1}, {a: 'i', b: 'k', c: 4} ]; Using d3.nest with entries: d3.nest() .key(function (d) { return d.a; }) .key(function (d) { return d.b; }) .rollup(function (leaves) { return d3.sum(leaves, function (d) { return d.c; }); }) .entries(x); /** An array of Objects with key &amp; value properties [{ key: 'i', values: [ { key: 'j', values: 2 }, { key: 'k', values: 4 } ] }] **/ d3.nest with map: d3.nest() .key(function (d) { return d.a; }) .key(function (d) { return d.b; }) .rollup(function (leaves) { return d3.sum(leaves, function (d) { return d.c; }); }) .map(x); /** A nested object { i: { j: 2 k: 4 } } **/ **Edit** Also with d3.v3, you can call `.map(x, d3.map)` and it will return a `d3.map` object with nested `d3.maps`. You could supplement your own function there to build a different type of object if that's not what you are looking for. Either way, d3 should be able to handle any of these formats because you provide the selection method. Also, none of this prevents you from creating your own aggregator. And there is also this article: http://www.delimited.io/blog/2013/11/2/creating-nested-json-for-d3 bl.ocks.org seems to be down, so I can't see the json...
did not work for me.
Node.js is all about drama these days. I guess Netflix didn't want to get left out.
That sums it up perfectly. Couldn't have said it better myself!
Sorry for the long wait.. Almost correct? What did I get wrong? What I meant is that I thought a regular event listener (without the *.bind* hack) is behaving like a variable; In the sense that I can overwrite it very easily. var not_a_constant = "foo"; console.log( not_a_constant ); // foo not_a_constant = "bar"; console.log( not_a_constant ); // bar So I thought eventListeners do the same thing when I try to add a second one of the same type. However with the *foo.bind(null)* *(Idk why I was blabbing about pointers)* There isn't any reference. So why wouldn't GC just grab it. Seems very dangerous to have a listener that I can't destroy. And I can't destroy it without a reference, right?
thank you very much :)
I'm not that kind of programmer. I am a Computer Science student and I feel challenging only on game programming...
cool...but sounds dangerous. I suspect this will hide a lot of problems.
Not bad. I'd like to see a full blown app that uses routing and a backend...but its a good start.
It comes down to personal preference. Designing your module's interface is like UX design for whomever will be consuming your code. Personally I like my methods being explicit so I have separate getters and setters but as long as you are consistent then it doesn't really matter. If you're writing a plugin/extension then try to be consistent with how the framework is designed. For example if I download your jQuery plugin I will expect to use a single getter/setter method. Be sure to consider boundary cases like setting falsy values e.g. if I call Foo.logger(0) in your example will it get or set? (Your example is back to front by the way -- `if (_logger)` is setter not getter)
It's a standard pattern called dynamic dispatch: http://en.wikipedia.org/wiki/Dynamic_dispatch You can see it used a lot in jQuery. I'd argue against using setters and getters for attaching props to an object though (unless something special is happening inside that function, like Backbone.Model.set
Go could actually make good use of something like Flow. It's a lot more powerful as a typechecker than the built in one.
Why is it so offensive to Javascript developers that languages *other* than Javascript exist and that people prefer them? Regardless, the point of Flow is that you get type inference on bog standard Javascript without having to add annotations. Sure, you *can*, but in many cases you don't need to. 
Clarity would be the big drawback in a large application. Its much better to be outright explicit about what your functions are doing than to have some hidden functionality within them. If someone else was maintaining your code, or even your future self, and you had a bug in an area that was doing a lot of getting and setting different values using this type of single function to do the both... and then for good measure say you had calls out to functions that take no parameters but also don't return anything... you'd want to jump in a time machine and punch yourself in the face with a very large boxing glove because it'd be a total nightmare to figure out what's going on by reading the code, you'd have to tediously step though it breakpoint by breakpoint to figure it out. 
Did you even read the fracking article?
Writing a compiler in ML is a substantially easier process than writing one in Javascript.
&gt; The only way to resolve paths is to iterate through the list of regexs and test them. [That's a pretty bold statement.][radix] [radix]: https://en.wikipedia.org/wiki/Radix_tree
I agree that being explicit is more important here. The best solution is probably to just use the setter and getter (AKA properties) support built into JS itself. That way your properties look like normal properties for the users, but you can still handle setting and getting with your own code. http://javascriptplayground.com/blog/2013/12/es5-getters-setters/ 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Set (abstract data type)**](https://en.wikipedia.org/wiki/Set%20(abstract%20data%20type\)\)): [](#sfw) --- &gt; &gt;See https://en.wikipedia.org/w/api.php for API usage &gt; --- ^Interesting: [^Abstract ^type](https://en.wikipedia.org/wiki/Abstract_type) ^| [^Graph ^\(abstract ^data ^type)](https://en.wikipedia.org/wiki/Graph_\(abstract_data_type\)) ^| [^List ^\(abstract ^data ^type)](https://en.wikipedia.org/wiki/List_\(abstract_data_type\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cm7vnvi) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cm7vnvi)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Angular might die because of other developments. Namely other frameworks (and browsers) catching up until there is very little of angular left that people will actually use. What bothers me about AtScript is that very few of things they use their `@` annotations for actually require an annotation. `@Directive() class X {}` could just as well be `class X extends Directive {}`. Dependency Injection will also be obsolete with ES6 modules. And they're certainly getting distracted by the language: Angular 2.0 will do very little that either current day Polymer or Angular 1.3 do not already do. Angular 1.3 is pretty stable and there is no harm in learning it now. Just know that you're working with something that will become obsolete in the future‚Äîmuch the same way people use RequireJS in Node today even though ES6 modules are already around the corner.
jQuery is already pretty much obsolete and Flex Box is going to make Bootstrap much less interesting going forth. You're out of luck. 
Hear hear. [The obligatory Todo](http://githubnews.com/repositories/14#comment-5) looks similar to Backbonejs. 
I do like it a lot, though it feels a bit unnatural.
its great to see the power of distributed computing helping medical research
[I guess it is because they A/B test consistently.](http://youtu.be/gtjzjiTI96c?t=1m54s) Not sure though.
Works in Firefox 33 for me but in Chrome 38 it's epilepsy inducing...
Sorry about that. I updated the readme. You probably needed to run npm install.
Is there a way to allow mouse dragging as a backup to rotate/zoom actions when touch is not available?
Because OCaml is a far better language for this application. It will produce a faster and more accurate compiler. Right tool for the right problem.
Co-worker has been looking into using backbone and react together I'm curious to test this out
Call me old fashioned but I think it's still good practice to have an obvious link back to your homepage from any other page on your site. We someone links directly to the blog post it's less-than-obvious that the third link on the left name is how you find out what any of this is talking about.
My thoughts exactly. Touch events are not so different from mouse events, with the exception of pinch to zoom which could be replaced by a mousewheel event handler. Rotating could also be done with a mouse. 
I find intuitive the "Light Table" link placed below the blog's logo.. Dont' you?
You will not meet one developer that uses windows in nyc. I only saw it once at JPMORGAN but it was because of the high security and encryption on drives. Plus most big corporates tend to use windows. I feel like any real developer has to use some sort of unix kernel though to be effective. Windows cli is weak to say the least
I think marionette/backbone has much more to offer. We have a very active community on gitter.im and we're releasing a new marionette.inspector tool so you can see ui, data, and event changes within your application and narrow down problems or see how things work. We're also working on warning users for things like a view being rendered too many times, too many dependencies within the app and other cool stuff :)
Sorry but this 'real developers use *nix' is outright bullshit. Get your shit straight boy.
Not JavaScript, but Flow. Typed and analysed. TypeScript team seems to do fine writing their compiler in TypeScript.
Not supporting Angular but React is only a view layer, it doesnt handle architecture to well a good combo is backbone/react or marionette/react
So where's the game that should have been launched today? "Launch on November 20"
I'm guessing something like : for (var i=1; i &lt; 10001; i++; document.write(i) and then an if/else something? i know how i would do to find a specific number, but to find a gap in a series of numbers i have no idea 
If you don't mind making a very inefficient solution, and assuming every number can occur at most once, you could sort the original list, and then walk through it until you find a number that does not match its index + 1...
Hmm alright i might try that, thanks for the help
Looks like the restify site has gone down under the interest this article must have generated. I really want to look into it.
I still think it's good publicity for node / express. I was expecting there to be some inherent issue with node's runtime (based on the title), but what I got out of it most was that a heavily, heavily trafficked company can successfully use nodejs. Edit: I did not mean to reply to your comment I was using the phone app and thought I was replying to the main article.
If you need a list with (semi) random placed numbers from 1 till 10000 minus 1 number, try: var list = []; for (var i = 1; i &lt; 10001; i++) list.push(i); delete list[Math.floor(Math.random()*10000)]; list.sort(function() {return .5 - Math.random();});
Best explanation I could find with a quick googling was [these](www.cs.virginia.edu/kim/courses/cs471/lec/cs471-03-lex.pdf) sets of slides from an university Compiler course. The techinique /u/a_m0d was talking about is the same one they use in compilers to tokenize the input stream. The order of things is not a big deal. When building the state machine you know, for every state, what regexes are accepting if you stop at that state. This means that you can choose how to order things. For example, in most lexers for programming languages, they use a " longest parse wins" disambiguation rule so that things like "form" are parsed as a single identifier instead of as a "for" keyword followed by " m" --- Inother interesting read might be [this page](http://swtch.com/~rsc/regexp/regexp1.html) from the author of the re2 regex engine. It explains in detail how to convert the regular expression into a state machine.
In my experience, the biggest drawback of the second version is that it can swallow type errors var mylog = obj.loger; //A typo! "mylog" is actually undefined! Foo.logger(log); //Acts as a getter and discards the return value, silently hiding our error. One alternative I like that helps a bit in this direction is testing against `arguments.length` instead of checking the truthyness of the optional parameter. That said I'm not a big fan of overloading my functions, even in statically typed programming languages so I would more likely go with different names for the different operations.
I think " overloading" might be a better name here. The most common use for "dynamic dispatch" is for things like method calls, where the caller doesn't know at compile time what function will end up being called (it depends on the concrete class of the object at runtime). On the other hand, in this case, we know when we write the program if we want to run the getter or the setter - it just happens that we made it so that both operations have the same name with only the number of arguments serving as disambiguation. In a way, its similar to how " +" in C is overloaded to act as both integer and floating point addition.
You keep saying this to everyone that talks about React / Backbone. I've seen it in like 4-5 different posts. You should probably write a post that explains how they are similar and why React is backbone with a virtual dom which is definitely an over simplification. Just saying stuff without actually referencing a way to compare is not helpful at all. For people that have not used both library/architectures you are kind of misleading people with your statements. Just saying...
There are lots of guides for Grunt and Gulp out there, and these tools let you do all of the above, but I don't think they've advanced to the state where they've established best practices. Grunt/Gulp can run jshint, run code coverage tests, run tests, and push code to servers, but you need to wire the stages and procedures up yourself--which does make sense as devops tends to be project specific, but they don't give you out-of-the-box beta/production stages or anything. It probably doesn't help that front-end builds tend to revolve around compacting a project into images and a few files for S3 or similar. I imagine few start a dev database with Grunt, though with grunt-exec there's not any reason you couldn't. Grunt/Gulp or similar _is_ perfect for running the enforcement tests, though. 
i did all that. was there some missing css?
Are you sure react is built on backbone? Regardless we already have a structure built using backbone were just interested in using the virtual Dom to improve rendering
I was actually looking for a reference to *polymorphic* dispatch, a term I read in Reggie B's (great) book, Javascript Spessore, which he used to describe some of the jQuery API
Or you could not have to do that so you could focus on what you're actually debugging.
not really. it doesn't stand out that much. ~~besides, the link's broken.~~
Removed, /r/javascript is not a job board.
Hmm, interesting! So you'd construct an NFA from the regex/strings passed in, then covert that to a DFA which allows you to reason about all the possible states all the route combinations could possibly be in, then finally associate the route handlers with their respective states? There would then need to be a second data structure (the existing array?) Which determines the order of route execution. I'm not clear on how exactly to construct that DFA to get the states, but if it's possible given the inputs we have, then it would be an interesting solution. I wonder what the time/space costs are? Thanks for the links!
Do you work for a larger company? If so, yes - it's normal.
That's not what this is. 
React is not built on backbone, it is built by someone who used backbone and wanted to render html better. It seems so, because it uses the same useless pseudoclassical hierarchical model that backbone has. All UIs I have ever built can't really gain anything from parent-child relationships between classes. It gives you absolute freedom when to render your html, but doesn't give you any guidance when you actually should do it. I don't know nothing-I haven't built no big apps with either, but from the perspective of Angular developer, these two might as well be one.
If you don't need to support old IEs, I would highly suggest looking at polymer. Something like in [this SO answer](http://stackoverflow.com/questions/26382156/replacing-angular-with-standard-web-technologies/26797121#26797121). ES6 modules are not yet ready, so I would recommend [systemjs](https://github.com/systemjs/systemjs)/[jspm](https://github.com/jspm/jspm-cli). Should be much more future proof than Angular.
Yes, thats the basic idea of it. You can work directly on the NFA if you want though - the conversino for a DFA is only made for efficiency. Basically, what you can do is " interpret" the NFA dynamically: you keep a list of active states and after reading each character you update the list of active states (the difference in a DFA is that there is always a single active state). In this construction you spend linear space for the automaton, but simulation will take O(n*m) where n is the length of the URL and m is the average number of route regexes which are "active". When you keep a list of active states then its easy to see how to handle the order problem: when you finish running the automaton you look at the list of accepting states and see which of them are " accepting states" . Each accepting state corresponds to one of the input regexes and if there is more then one you can choose one according to your priority rules. As for converting things to a DFA, the basic algorithm uses the powerset construction: The basic idea is that you create 2^n states, one for each possible subset of active states for the NFA. Running the DFA is always O(n) but you might need exponential state to keep the automaton table in the worst case. However, for the kind of routs people use in websites I would expect the DFA to only need linear space, since most of the 2^n states will be unreachable and can be pruned.
&gt;besides, the link's broken. It works on mine...
It said it was from an external source. I'm assuming it was a system to let them add, remove, or change urls without restarting the whole server.
Notepad++
That title though. It was a bug in Netflix's code, made harder to catch by an arguably poor design decision in Express. Node is no more to blame than Intel. (Not to say it was necessarily meant to be misleading. Maybe the author thinks of Node as a term for their whole new stack, and meant that the new stack was in flames, not realizing that he was applying a personal definition of Node.)
It didn't sound hacky or overly complex to me, assuming there is no sanctioned way to update route handlers. A website with netflix's traffic can't just go offline every time they want to add a new page.
I do, I think what has me confused is the project is already built, I'm just updating things. If it was a new project from scratch I can understand passing off the html/css/javascript, but for a project that's already integrated and I'm making changes for, I don't know how to separate static html from the backend system because it's all connected together. I suspect a lot of the previous developers on this project ran into the same issue, because half of the html is being inserted onto the page through javascript, which seems like a really bad practice to me.
Not sure if you are trying to write a pano viewer yourself, or if you are satisfied using an existing viewer. If the latter, then google for "js panorama viewer" and you will find several ones. Here is a demo of one that uses webgl acceleration: http://mrdoob.github.io/three.js/examples/webgl_panorama_equirectangular.html
&gt; This turned out be caused by a periodic (10/hour) function in our code. The main purpose of this was to refresh our route handlers from an external source. This was implemented by deleting old handlers and adding new ones to the array. They were dynamically flushing and reloading all their routes 10 times an hour without really checking for duplicates. How is that not hacky?
I'm looking for an existing solution if possible. I saw that one, but it isn't very mobile friendly (on my Android, there is no interactivity at all).
The first version of Typescript wasn't written in Typescript. You can't write a self hosting compiler until you've got a stable base to begin with. Regardless, OCaml is still a much nicer language to write a compiler in. Pattern matching alone makes a massive difference.
Ok, so when using just the NFA, the running time would be worse than the current O(n) where n is the number of regex's to match? The DFA is quicker than the NFA with a O(m) solution where m is the number of possible states of the DFA, but that's still much slower than the O(n) solution already implemented. Also, if we're having to create 2^n states to get any speed benefit, it somewhat defeats the purpose since the performance problems are only noticeable when you have large numbers of routes, which is also the worst case for memory performance when using DFA, and worst case for running performance when using the NFA. Please correct me if I got anything wrong there - still only on the edge of wrapping my head around using the structures we're talking about :)
&gt; Yet if I want to take full advantage of the system, I must write my source code in their proprietary dialect which will not run on standard javascript runtimes. All just for static typing? "Proprietary" is a bit of a stretch. Syntax wise it's just Javascript with optional AS2 style type annotations. If you decide to stop using it, a simple `awk` script could remove them. &gt; It's over-engineering an unnecessary problem, that can already be adequately solved with a simple library. No, it's not over engineering, and it cannot be solved with any library. Libraries cannot perform static type checking. Only runtime type checking. Regardless, how is a random "proprietary" type checking library any better than well supported open source project that uses a very common conventional syntax (that spans many languages) for type checking? &gt; Why not just use a static typing library? Do you really find it valuable to write your code in a non-standard format in order to receive one single benefit which is a nice-to-have, but not a necessity? I suppose it depends on how much you value static typing. In my mind it's not even a debate - Personally I cannot understand why somebody would not want to use static typing - especially when it's an optional tool that adds value to a language without taking anything away. It's effectively a powerful Lint tool that catches 90% of bugs - why wouldn't I want to use it? I regularly work with 100,000+ LOC projects, and static typing is a massive productivity boost. You are by no means obligated to use static typing if you don't like it. But it's an important feature for those that do. Typescript and Flow give a nice middle-ground for developers that prefer Javascript, but want to add some static analysis to their codebase. (If you think of "Java" when you think of static typing, I can understand why you don't like it. Java is a horrible language that does static typing very badly. Give something in the ML-family of languages a try).
I'm thinking in the case of developing a full stack application with Meteor.js. Do grunt and gulp work with this? What goes into setting up a server? I feel like there are many concepts including the ones I've mentioned that are important to implement for a full-fledged webapp project, however I can't find the resources that detail setting up servers, protecting the servers, automatically pushing code, etc.
Please share your code on Github, I went there for help playing the game and it was empty. Also you should answer your SO questions.
Real-world answer: both approaches are used in very popular libraries, so either will work. Opinionated answer: Combining the two is a very bad idea, it puts an whimsical sense of style above a long list of practical benefits. The combined style: - Has you write logic to choose which function gets executed, which is re-implementing something the interpreter was happy to do for you. - Forces two unrelated functions (get and set) to share a namespace, at least until ES6. - Makes code less readable. - Makes type checking more difficult and error-prone. - Makes documentation harder to navigate. For example, `setLogger` is obviously what you want if you want to set the logger; `logger` is less clear, and you would probably only read it once you observe that there is no `setLogger` method. - Makes unit testing more difficult and the results less informative. - Turns invocations that would be invalid into valid invocations that do the wrong thing. - Makes it take longer for a human to tell if an invocation is a get or set (which you will want to know pretty much 100% of the time you read it), or even impossible before runtime if you end up `.apply`-ing the function. - Is slower. Before anybody jumps down my throat about micro-optimizations, remember that using this as a style means running it on every invocation of a significant portion of your API (which, as far as I know, could be used for a performance-critical aspect of the application). - Prevents the browser's compiler from choosing to optimize one function but not the other (which is the fastest approach if one is used frequently and the other is not). - Makes it harder to introduce operations besides get or set. You can either add another function (now you're following conflicting patterns) or keep adding more invocation types, making it harder to remember which implicit operation is being triggered. - More logic = more potential for bugs. Even your barebones example breaks for all of the 6 falsey values. Maybe those shouldn't be passed to the function you had in mind, but it'll still become a problem if you use the pattern elsewhere or if you change that function's signature. - Less separation = harder to catch bugs. For all that, the only benefit you get is "it looks pretty (to some people (right now))". You mentioned in another comment that the language's property getters/setters feel unnatural, and I think that's a valid concern. The getters/setters make usage look like property access, while in fact what you're doing is an operation of arbitrary complexity and effect. The incongruity is not just masking details, it's implying things that aren't true (that the operation is vanishingly fast and won't have side-effects). The key to making it both feel right and not mislead, I think, is to use getters/setters only when the only possible result is to proxy the operation to another value or to throw an error, and functions when the get/set has additional complexity. Also, you don't need to use the same approach for both get and set. A lot of the time you will only need one or the other. Or you can use a readonly value and a setter, like React does with `state`. Notice that in that case React is using the same principles I just talked about: getting just does property access, so using it looks like property access; setting is hiding an algorithm from you, so setting looks like something that could be complex and/or expensive. I don't know if React did that on principle or just because it was easier, but I would point out both that React is a very principled library, and that, all else being equal, easier is better.
Those ugly big-Os are only the theoretical worst case. Website routes usually are structured following a tree-like directory structure, with lots of " shared prefixes" that can be collapsed into a single DFA state so you are most likely only going to need polynomial space for the DFA.
This could not be further from the truth. 
Well they were obviously fucking something up or t wouldn't have had such a bug :|
Single player mode is kinda neat http://screeps.com/g/#!/sim
Sadly, I' m not sure this all would work with native JS regexes (they have backreferences and other features that are incompatible with the DFA generation) so this all might not be very applicable to Express.js :/
+1 the console can do a bunch of cool stuff. You should also check out object.observe() http://www.html5rocks.com/en/tutorials/es7/observe/
Why do people title stuff like this? It's useful information, but the arrogance isn't needed.
Yeah, I agree that they messed up, I just don't think that what they were doing was so crazy it was bound to end up broken.
Haha, alright, but I'm sure there is someone who would know that might comment on the Github Issue :)
Meteor is just doing what Grunt and Gulp are doing, but providing you with their version of a complete solution. It's a field of active development. What you're asking for just doesn't exist, because we're not sure what a Javascript project actually _is_. A web app doesn't exist outside of a backend database of some sort. Deploying that backend is also, necessarily, independent of the Javascript project. If you're interested in Meteor, [this post](https://www.digitalocean.com/community/tutorials/how-to-deploy-a-meteor-js-application-on-ubuntu-14-04-with-nginx) seems noteworthy. At some point, though, you'll have to take responsibility for what goes into setting up a server. 
Don't forget about [console.assert()](https://developer.mozilla.org/en-US/docs/Web/API/console.assert) which writes an error message if and only if the assertion is false. Great to do basic tests. [console.time()](https://developer.mozilla.org/en-US/docs/Web/API/Console.time) and [console.timeEnd()](https://developer.mozilla.org/en-US/docs/Web/API/Console.timeEnd) are great to do some simple timing checks.
Very useful. Thanks for sharing!
BuzzFeed's influence. "What OP did next you'll never believe!"
Safari supports all of these except console.table(). IE11 supports all of these except console.table() and CSS in the console.
Seen this a thousand of times. Enough.
Hi, can you make one for angular? Thanks.
Wow, thank you!
I laughed. It's true, I was just being silly. Sorry about that.
At it's core, a REST API is just a standard way of defining JSON responses from your servers' backend. These are simply loaded over HTTP using AJAX. BackboneJS provides some nice utilities and abstractions to make REST APIs easier to use, but under the hood it's just using basic AJAX calls. The best way to learn about RESTful APIs is to try using some. There are many public APIs available, including Reddit. Here are some simple ones: - Twitter: https://dev.twitter.com/rest/reference/get/statuses/retweets/%3Aid - Reddit: https://www.reddit.com/dev/api The most important thing about understanding REST APIs is learning the terminology. This includes "verbs" (POST, GET, PATCH, DELETE) also referred to as CRUD (Create, Read, Update, Delete) methods, CORS (Cross-Origin Resource Sharing), "Resources", and "endpoints" (urls). There are pretty well defined patterns and conventions that are important to learn, but aren't absolutely necessary to follow. In my experience, creating the spec for an API requires more thought and consideration than actually implementing it. And yet really a REST API is incredibly simple. Read more here: http://www.restapitutorial.com/ Hope that helps.
good post about it here: http://stackoverflow.com/questions/4663927/what-is-rest-slightly-confused
One thing that I always thought big MVC frameworks could have done better is modularization. It bothers me to see things like Collections and Lists as framework-specific features, when they have so much utility standing alone.
These titles drive me nuts. 
XOR summation would be faster. Instead of O(2N), it's O(N): var xorMissing = function (array) { // XOR summation of missing array var x = array[0]; for (var i = 1, length = array.length; i &lt; length; i++) { x = x ^ array[i]; } // XOR summation of full length consecutive array // Uses the size + 1 and O(1) calculation // If odd (1/0), if even (n/n+1) var y = array.length + 1; if (y % 2 === 1) { y = (y % 4 == 1) ? 1 : 0; } else { y = (y % 4 == 0) ? n : n + 1; } // XOR missing ^ full return x ^ y; } xorMissing([1,2,3,5,6,7]); // 4 xorMissing([1,2,4,5,6,7]); // 3 xorMissing([7,2,3,1,5,6]); // 4
Me too.
Why do you think this is bad practice? Sometimes a single page app may have several containers for different pages that are shown and hidden by a menu. It seems reasonable for the app to load the main page and present it to the user, and then lazy load the remaining html. 
Timer: console.time('fart'); /// some stuff happens console.timeEnd('fart') /// prints fart 23.45ms PROFILERS HATE IT
It's underrating to call D3 as a SVG library. It's a masterpiece of art. 
Still underrated
It's nerd bravado more than anything else.
It's on the list, thanks! I recommend subscribing to the low-volume newsletter (in the blog sidebar) to not miss it. :)
But not only written originally in 10 days but the use case was far different than how JavaScript is being used today. So I would say that is pretty impressive. I would also bet that JS is growing in market share faster than anything else. 
Profilers: console.profile('test') /// Some stuff happens console.profileEnd('test') /// Adds a profiling record to the profiling tab TIMERS HATE IT (?)
&gt; I know there's MutationObserver but you also have to consider that comments are inside an iFrame. So inject your code such that it runs in the iframe as well. Or better, set it up so that it *only* runs in the iframe, not in the enclosing page, since that's where it's actually needed. I wrote a greasemonkey script that uses mutation observers to load all the comments on any Disqus thread and it works just fine, because I configured it to run on the URL of the iframe and not the URL of the enclosing page, which has the side effect of making it work on any page that has Disqus comments. 
Yehuda has done incredible work on OSS, but usually his ember talks are a bit too intense for me, this one was a bit more down to earth haha. nice video though, the stuff about ember's release cycles and how other projects inspire it were quite nice. the react talk from teh same conf. was worth watching too
Choosing an opinionated framework has really paid off, since we can easily move developers between projects; they immediately know how to start contributing and the proper patterns to follow. DING DING DING angular has found its niche with me as a replacement for jquery when adding interactivity to server-rendered pages, but if I'm building a full-on js frontend, it's gonna be ember mostly for the structure + CLI tools. 
At least its not php.
If you're that lazy then get a new fucking job. 
&gt; set it up so that it only runs in the iframe What do you mean by that? That you select only elements inside that iFrame?
No. I mean the code is injected only into the iframe, not into the enclosing web site. When you write a content script, you specify a list of URLs that it's to be injected into. That list should contain the URL of the iframe, not the URL of the enclosing page. The script can then interact with the DOM of the iframe, because it's running in that window. After all, an iframe is, conceptually, one web page embedded in another completely different web page. They have different URLs, different toplevel `window` objects, etc. If the elements you care about are in the iframe, then that's where your script should be running.
I feel stupid now, but what is this good for?
Too lazy to click. What's on the images?
He usually seems more prepared. Live coding is treacherous. I wish people doing presentations just used git and a good diff viewer. This seemed more informative to me, and lots of credit thrown around: http://thechangelog.com/131/
this is great!
What if I told you I've seen these features posted on reddit before?
https://github.com/Constellation/escodegen Could be useful for writing compilers that compile to JS.
I think that its okay. People are too butt-hurt about silly shit now a days. 
Most excellent!
Oh yea, of course. Thanks a bunch for answering. Appreciate it.
Solutions that use a base other 10 are typically esoteric, but man can they be time and performance savers. XOR in particular has a pretty long list of uses. My favorite is the temp swap without using a 3rd variable named `tmp` (has a pretty long history in coding): var x = 5, y = 6; x = x ^ y; // x = 3 y = x ^ y; // y = 5 x = x ^ y; // x = 6, y = 5 A few others: http://c2.com/cgi/wiki?FunWithExclusiveOr
Is that with websockets? It only displays it as a table if there is an array/object containing arrays/objects. So for example, if your object was `{x: 490, y: 2397, width: 320, height: 100}`, you couldn't console.table that, but if you simply wrapped it into an array: `[{x: 490, y: 2397, width: 320, height: 100}]`, you can console.table that.
Websockets yes, sorry I should have mentioned that. jsonobj = [JSON.parse(e.data)]; It works! Thanks!
The worst part is these features are not hidden and are quite common. Especially considering variations of this have been posted to this subreddit at least 3 times this week already. 
I have some issues with some of the points he made about co. The highlights were as follows: ‚àö Works with control flow primitives ‚àö Handles errors X Can't do parallel operations X Can't share and cache async operations Co can certainly do parallel operations it's in the projects readme https://github.com/tj/co#examples In the examples that he gives he only yields thunks, yet co supports yielding promises, which can be shared and cached
So this is essentially IFTTT on steroids?
what i wouldn't give for client-side unit testing that is independent of angular. i lack the knowledge and experience and sorely want to learn.
Yes and no. From a developer stand-point, hook.io outclasses IFTTT by several factors. What IFTTT has that I admire, is a really great user experience that bridges the gap between microservices and non-developers. Non-technical people can easily use IFTTT. I would love to see hook.io reach this level of user-experience and become a serious competitor to IFTTT.
This talk was from about a year ago, so devs may have caught up to some of these things by now.
I have a problem logging in, after I authorize the access on the github page I am redirected to an empty page (http://hook.io/login/callback?code=3454a2139aa118a1897d) ed if i try to refresh I got this error Error at /home/ubuntu/hook.io/node_modules/passport-github/lib/passport-github/strategy.js:90:28 at passBackControl (/home/ubuntu/hook.io/node_modules/passport-github/node_modules/passport-oauth/node_modules/oauth/lib/oauth2.js:124:9) at IncomingMessage.&lt;anonymous&gt; (/home/ubuntu/hook.io/node_modules/passport-github/node_modules/passport-oauth/node_modules/oauth/lib/oauth2.js:143:7) at IncomingMessage.EventEmitter.emit (events.js:129:20) at _stream_readable.js:898:16 at process._tickCallback (node.js:343:11) After the first time the github step is skipped so i went directly from hook.io to the empty page
Check out the [Karma test runner](http://karma-runner.github.io/0.12/index.html). My goto setup for client side tests is to have Karma run Jasmine tests in PhantomJS. I have also never written a line of Angular.
that's really impressive.
 &lt;!-- Bestillings form bynner her --&gt; &lt;form name="bestilling" id="bestilling" class="white-popup mfp-hide" action="#" method="post"&gt; &lt;h1&gt;Bestilling!&lt;/h1&gt; &lt;fieldset style="border:0;"&gt; &lt;p&gt;Vennligst fyll ut informasjonen nedan.&lt;/p&gt; &lt;ol&gt; &lt;li&gt; &lt;label for="navn"&gt;F√∏rnavn&lt;/label&gt; &lt;input name="navn" type="text" placeholder="Ole" required&gt; &lt;/li&gt; &lt;li&gt; &lt;label for="etternavn"&gt;Etternavn&lt;/label&gt; &lt;input name="etternavn" type="text" placeholder="Nordmann" required&gt; &lt;/li&gt; &lt;li&gt; &lt;label for="email"&gt;Email&lt;/label&gt; &lt;input name="epost" type="text" placeholder="eksempel@domene.no" required&gt; &lt;/li&gt; &lt;li&gt; &lt;label for="telefon"&gt;Telefon nummer&lt;/label&gt; &lt;input name="telefon" type="tel" placeholder="Eg. 12345678" required&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Hvilken hytte √∏nsker du og leie?&lt;/p&gt; &lt;select id="hytteleie" name="hytte_pris_per_dag" onchange="regnPris();"&gt; &lt;option value="640"&gt;Hyttebu&lt;/option&gt; &lt;option value="1520"&gt;Storbu&lt;/option&gt; &lt;option value="850"&gt;Bubu&lt;/option&gt; &lt;option value="570"&gt;Kosehytta&lt;/option&gt; &lt;option value="1510"&gt;Sj√∏lukta&lt;/option&gt; &lt;option value="1230"&gt;√Öpentoppen&lt;/option&gt; &lt;option value="740"&gt;Kj√¶rlighetsredet&lt;/option&gt; &lt;/select&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;N√•r √∏nsker du og leie hytta?&lt;/p&gt; &lt;label for="fra_dato"&gt;Fra&lt;/label&gt; &lt;input id="fra_dato" type="date" name="fra_dato"&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;√ònsker du √• leie hytta timesvis eller d√∏gnsvis?&lt;/p&gt; &lt;label for="leie_periode"&gt;&lt;input type="radio" name="leie_periode" value="timesvis" checked="checked" onchange="leieType();"&gt; Timesvis &lt;input type="radio" name="leie_periode" value="d√∏gn" onchange="leieType();"&gt; D√∏gnsvis&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Antal &lt;label id="leie_tekst"&gt;dager&lt;/label&gt;&lt;/p&gt; &lt;select name="antal" onchange="regnPris();"&gt; &lt;option value="1"&gt;1&lt;/option&gt; &lt;option value="2"&gt;2&lt;/option&gt; &lt;option value="3"&gt;3&lt;/option&gt; &lt;option value="4"&gt;4&lt;/option&gt; &lt;option value="5"&gt;5&lt;/option&gt; &lt;option value="6"&gt;6&lt;/option&gt; &lt;option value="7"&gt;7&lt;/option&gt; &lt;option value="8"&gt;8&lt;/option&gt; &lt;option value="9"&gt;9&lt;/option&gt; &lt;option value="10"&gt;10&lt;/option&gt; &lt;option value="11"&gt;11&lt;/option&gt; &lt;option value="12"&gt;12&lt;/option&gt; &lt;option value="12"&gt;13&lt;/option&gt; &lt;option value="12"&gt;14&lt;/option&gt; &lt;/select&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;√ònsker du noe ekstra tjenester?&lt;/p&gt; &lt;input type="checkbox" name="internett" value="300" onchange="regnPris();"&gt; &lt;label for="internett"&gt;Internett&lt;/label&gt;&lt;br&gt; &lt;input type="checkbox" name="tv" value="200" onchange="regnPris();"&gt; &lt;label for="tv"&gt;TV&lt;/label&gt;&lt;br&gt; &lt;input type="checkbox" name="vask" value="400" onchange="regnPris();"&gt; &lt;label for="vask"&gt;Vask&lt;/label&gt;&lt;br&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;label for="ekstra_informasjon"&gt;Ekstra informasjon&lt;/label&gt;&lt;/p&gt; &lt;textarea name="ekstra_informasjon" rows="4" cols="50" placeholder="Fyll inn ekstra informasjon gjelende din bestilling."&gt;&lt;/textarea&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="checkbox" name="turistforeningen" onchange="regnPris();"&gt; &lt;label for="turistforeningen"&gt;Medlem av turistforeningen&lt;/label&gt;&lt;br&gt; &lt;/li&gt; &lt;p&gt;Total pris for denne bestilling: &lt;font id="pris" color="red"&gt;0kr&lt;/font&gt;&lt;/p&gt; &lt;!-- Vi bruker en hidden input for √• presentere pris p√• "bekreftelse" siden --&gt; &lt;input type="hidden" name="total_pris" value="0kr"&gt; &lt;input class="knapp" type="submit"&gt;&lt;/input&gt; &lt;/ol&gt; &lt;/fieldset&gt; &lt;/form&gt;
This is the best video explaining callbacks, promises and generators I've seen. Hopefully this kills all the garbage that has collected up to deal with callback challenges (promises, async, co, etc.). With generators, we need none of it. We get back to regular old control flow without blocking the application.
For those like me who had no idea what it actually does: it takes an [AST](http://en.wikipedia.org/wiki/Abstract_syntax_tree) and generates JavaScript code.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Abstract syntax tree**](https://en.wikipedia.org/wiki/Abstract%20syntax%20tree): [](#sfw) --- &gt; &gt;&gt;__while__ b ‚â† 0 &gt;&gt;__if__ a &gt; b &gt;&gt;a := a ‚àí b &gt;==== &gt;[**Image**](https://i.imgur.com/TKpVqfC.png) [^(i)](https://commons.wikimedia.org/wiki/File:Abstract_syntax_tree_for_Euclidean_algorithm.svg) - *An abstract syntax tree for the following code for the Euclidean algorithm: &gt;__while__ b ‚â† 0 &gt;__if__ a &gt; b &gt;a := a ‚àí b &gt;__else__ &gt;b := b ‚àí a &gt;__return__ a* --- ^Interesting: [^GNU ^Compiler ^Collection](https://en.wikipedia.org/wiki/GNU_Compiler_Collection) ^| [^Attribute ^grammar](https://en.wikipedia.org/wiki/Attribute_grammar) ^| [^Abstract ^semantic ^graph](https://en.wikipedia.org/wiki/Abstract_semantic_graph) ^| [^Interpreter ^\(computing)](https://en.wikipedia.org/wiki/Interpreter_\(computing\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cm92d1u) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cm92d1u)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Could you add a bit more to the help page? I can't seem to get it to do anything worthwhile. Any examples, instead of jsut "// Do more stuff with the elevators and floors" would be much more helpful.
Sorry about that. Could you try again? It looks like there was a typo in the guard which checks if github returns a null email address. It should be resolved now. Let me know if it's still not working.
So this could be used by traceur or typescript compilers then?
Ok, it works
yes a square pop ups and says that i have to enter something,but then the page refreshes for some reason and the other information in the form is lost
The jQuery plugins are all not nearly as refined as I had hoped. I guess WebGL is required to make this effect look good. krpano is potentially very useful though. Thanks!
You have to poll because the DOM is external to JavaScript. A promise is probably the most efficient way to go, because all the polling is executed behind the scenes as a native feature. If a promise is not acceptable then use a recursive setTimeout, which is still far more efficient for watching the DOM than setInterval.
Tror kanskje spaceghost er inne p√• noe. Du kan ikke bruke en html form submit knapp til √• sende inn formen hvis du f√∏rst vill at javascript skal sjekke den f√∏rst. Du m√• heller ha en knapp / link som kj√∏rer javascriptet ogs√• f√•r du javascriptet til √• sende form dataen til serveren. Kan forh√•pentligvis hjelpe deg mer i morgen eller du kan Google javascript valedate form on submition.
&gt; I would also bet that JS is growing in market share faster than anything else. Well, on the client side, its share can only go down, because it started at 100% and there are more alternatives each year. On the server side, it's alright for smaller services and things like that. However, the very same niche is also filled with a plethora of other options. Some people also use Node in conjunction with TS or CS. They don't actually write JS even though they use Node. For other kinds of scripting it isn't that popular either. SimCity (2013) is a somewhat well-known example, but they actually used CC-annotated JS, not regular JS.
How does this compare to Traceur? I see that there's no runtime, which is a great improvement over Traceur's 29 KB (minified not gzipped) runtime. Did 6to5 have to drop features to achieve that?
The reddit user that posted this is not the same person that wrote the article. Eran Hammer is quite the distinguished developer (creator of Hapi, revamped Walmart to handle Black Friday traffic last year). I think it was a great response to an otherwise shitty article from a few Netflix devs.
I'm not sure I follow the claim of 'no runtime'. Surely you're going to want polyfills to provide Array.from, Map etc in addition to the new ES6 syntax. [EDIT: looking at https://6to5.github.io/differences.html clarifies the traceur runtime, which is in fact different to just needing a polyfill.]
"Silly shit" is how children get killed. Do you want that on your conscience? Huh? I think you need to grow up and take things more serious. People have feelings and saying they are "butt-hurt" is not helping! edit: forgot my sarcasm tags...
I'd have to call you a liar! The title clearly says you've never seen them.
The `big` and `resource` libraries are used in a few applications I've built. hook.io is one of those applications. Another open-source application built with big and resource is https://github.com/bigcompany/safewallet There are also a few other closed-source apps which have been built with resource dependency tree.
&gt; So not sure where you get 100%. I was talking about browsers. I.e. the thing JS was invented for.
So if you want to look at where getters and setters are useful we can consider how they protect data. When traditional variables are assigned there's really no way to ensure the data values are correct. A great use case for getters and setters is to validate data prior to actually storing it (and subsequently ignoring or throwing an error when the value is incorrect. This is more useful for business level objects that need data validation (e.g, is this actually an email address?) and not really as effective if you are simply making sure something is a string vs. integer. You're correct that many developers do not understand that values can be getters and setters, where setting a value can actually cause other state change, events or something else. But this I'm unsure is a strong enough argument to deter its use. However I would say you're correct as anything, it can be abused. Another other use case that I can see for getters and setters is serialization. Functions don't allow for this type of behavior, however getters and setters open up the possibilities of allowing behavior and data to be more easily (and naturally) separated. If you intended to try and do this with setWhatever, getWhatever you'd need to keep internal state, add a new method for serialization, and would find your conventions incompatible with other libraries and approaches. With getters and setters an object can be serialized and deserialized with your standard JSON.stringify and JSON.parse. Finally a good argument for getters and setters is more of a philosophical one than anything. If you look at design philosophy of class, object, methods, properties, etc, is they allow you to more easily talk about OO design in english terms. Classes are abstract nouns (pro nouns perhaps?), Objects are more proper nouns, methods are verbs, properties are adjectives. Methods in some OO circles are described as only being useful to take purely destructive (e.g., you cannot flip the state of the object back to its original state), while properties are thought of as state holding state but the state can be flipped back and forth. A great example is "save()", this would make a terrible property, its irreversible in some regards as the previous value in the file is overwritten. It helps developers to immediately identify destructive (or irreversible) operations vs. reversible operations. Those are some thoughts, you can do potentially dangerous things with anything (objects, protos, gets/sets, arrays, functions) but at the end of the day its whether it just makes more sense to do it one way or the other based on your use case. 
Firefox 33, black box. Chrome 38, black box. IE11, nothing (I miss the black box). Safari Windows: No webgl suporta So... 
Every tool has uses and misuses; basic programming principles (such as readable code, sufficient documentation, meaningful names, and so forth) are your friends. &gt; Are there any essential benefits to them that I'm missing? For example, I like to use a getter for a 'length' property on custom data structures- note that doing so does rely on state, but does not have side effects. Setters can also follow that rule. I can imagine scenarios where side effects in getters and setters are also useful, but they're very narrow and specific cases. Break rules when you know what you're doing (and more importantly, when other people can readily expect / understand it). Magic getters and setters aren't unique to JavaScript; they're just much less common due to the fact that for a long time many people who run JS code (i.e. website visitors) are doing so with a runtime that doesn't support getters and setters (i.e. old IE / ES3 browsers). No tool is safe in the wrong hands, and some are more dangerous to use than others. The same arguments have been used with other JS constructs, sometimes for good reasons: - `with` - `eval` - `new Function(string)` and for other language features that are more hotly debated, such as - the `new` keyword in general - the new `Class` keyword in ES6 - bitwise operators for type coersion Throwing "considered harmful" after any particular feature that *could* go wrong isn't very helpful; I would prefer to reserve that for when it *will* go wrong (i.e. forgetting to specify a radix for parseFloat when supporting browsers that don't default to 10). ===== EDIT I glossed over a big detail. Setters and getters are fairly integral to ES5's [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) . Setters and getters aren't the only way to define custom properties, and it can be important to further specify enumerability, writability and extensibility.
Or have the devs that use it settle on some type of basic UI and module conventions, and essentially make an open, extensible version of IFTTT on of hook.io. That would be swell.
Thanks for the link. I find the concepts of big and resource very intriguing but couldn't quite figure it out how it fits together into a full app; having a full project to browse helps a lot.
you should have a daily column called Programmer Police. I bet you even code in Starbucks - JUST LIKE US!
It has very similar features, however some features (new native functions, generators) do require either a polyfill or a runtime. Personally I'd much rather use trusted polyfills like es6-shim than rely on the tracuer runtime for these features however. As for generators it works well with facebooks regenerator runtime.
Thanks for the link, it looks like it answers this question. (The lack of a runtime I assume means the lack of a baseline runtime, ie something that is required no matter what you use.)
I think the spirit of the response was really acknowledging that Netflix did this to themselves, and not the framework. "One isn't superior to the other without the context of your use case and requirements. There is no 'best'." So Netflix criticizing the framework seemed out of turn. This is reminiscent of Mark Zuckerberg blaming HTML5 for the failing Facebook app. Rather, it was how FB devs handled the code and lack of experience that caused the problem. I think Netflix chose a great architecture, they're just flailing some now and looking to point fingers.
Used MutationObserver and works nicely.
Here is my attempt to address this question: http://sitr.us/2014/11/21/flow-is-the-javascript-type-checker-i-have-been-waiting-for.html
The amount of dependents is pretty amazing for something as specific as code generation. Javascript is so meta, it is crazy what people do.
Everyone has seen these, it's the most posted thing on /r/javascript of all time. Also: shit title
Thanks for writing this. I felt the same way reading it. I didn't have the context to evaluate the array usage. When reading it, alarm bells went off in my head saying "wow, that was a rude thing to say, an array could be exactly correct for this situation." Take this part, "What did we learn from this harrowing experience? First, we need to fully understand our dependencies before putting them into production." When I read that, I felt like it was a really backhanded and disrespectful comment, saying "hey, we're big scale pros, we need to do a line-by-line review to fix other people's work before we use it." Of course every framework has bugs. That's normal. I'm sure their code has plenty as well. What he should have said is, "regardless of origin, our devs need to understand the APIs they're using. It's completely unacceptable for there to be such fundamentally incorrect usage in such important core code. There should have been a design doc and design review for our router usage. Following that, this also should have been caught in CR, where the reviewer took the time to understand the code and the API/framework it was using." Now, I really love the flame graph stuff and really do appreciate the post. They just really missed the ball on that point. The author should have completely removed that criticism. It's just unprofessional to call anyone out like that. Maybe they just didn't expect anyone to read it.. I don't know. But yea, it bugged me. And I'm sure the original author is a good guy and didn't realize his mistake at the time. I'm sure he won't make the same mistake again. Us devs like to be positive and supportive :)
Doesn't Scala have an intermediate form of type, like a decoration? I'd prefer that in a transpiler.
The full es6-shim/6to5 runtime is 52KB minified (looking at browser-polyfill.js). 6to5 has the benefit of being able to generate on an as-required basis rather than the constant overhead of the Traceur runtime, but I'm not sure if that as-required compilation can be used in a multiple file context. Overall it's not going to be a massive filesize saving in comparison to Traceur, unless you're only using a few lightweight es6 features. (Their marketing of 'no runtime' is nice, but I find it completely disingenuous).
This is how I read it as well. But I think the misleading clickbait title set a really negative tone for the entire post, so I could understand how it could be read as blaming Express. 
I really appreciate this. Not having dove into all of these yet, I hadn't picked one. The only one I'd looked at was Reflux but I wanted something closer to a 'pure' flux pattern. Based on your article, I think I'll look at Delorean next. I also don't think Stores need to be singletons. I think they're more unique in a given context. But you could still have two sets of Stores for two apps both running on the same page IF you wanted that. Thanks!
A lot of stuff that javascript is used for today used to be done in Flash or Java Applets
This is great work!
Look around codeplex, nuget and whatever related forum. Plenty of mad stuff going on.
Woot!
Yes, Flash and Java applets gained some popularity and lost it again. Java applets have virtually disappeared. However, there is a bunch of other stuff now like TypeScript, CoffeeScript, Dart, GTW, Emscripten, Ceylon, and so forth. Whatever share they gain is taken from JavaScript's.
&gt; For example, I like to use a getter for a 'length' property on custom data structures- note that doing so does rely on state, but does not have side effects. Setters can also follow that rule. I can imagine scenarios where side effects in getters and setters are also useful, but they're very narrow and specific cases. My point is that you can do the same exact thing with methods. Getters/setters are purely syntactic sugar and they add no new functionality, but they also can potentially cause additional maintenance problems. So why not just use methods instead?
One could make the same argument for JS? 
This dude really should have chosen languages other than ruby and js...
So maybe I am misunderstanding what this is for and how it is used, but I can't seem to use Express in my Hook
How could I use this to POST JSON data to a URL? I can easily do it with curl on the command line, but what could be the Hook.io way?
I don't see a way to delete Hooks, either
Very awesome. I can see how this could even be leveraged for independently run contracts since your code is open source there could be many separate decentralized networks.
Since you are inside a node.js script with full access to NPM, you can do this several ways. The easiest method would be using the [request](http://npmjs.org/package/request) module. see: http://stackoverflow.com/questions/8675688/send-content-type-application-json-post-with-node-js You could also use the built-in `Hook.open` method as it's an alias to the [hyperquest](http://npmjs.org/package/hyperquest) module. see: http://hook.io/docs#hook Here's is an example of making an outgoing HTTP request using node's built in `http` module: http://hook.io/Marak/isTheWebsiteDown The important point is that there is no specific way you have to send data out. Since NPM modules are fully supported, you can choose the best way for you. Any existing solution should already work. 
&gt; So why not just use methods instead? In this case, there's an established convention for .length to be a property- strings and arrays, for example. The data structures I'm referring to encapsulated arrays and added semantic behavior (even though some variations didn't actually use an array under the hood). Getters and Setters (both the explicit and magic kind) hide complexity. The magic kind (that masquerades as a property) are just another extension of hiding the complexity of the operation. Yes, this can be dangerous. It's worth pointing out, though, that a number of DOM APIs all do the same thing (or more!). See, for example, [window.location](https://developer.mozilla.org/en-US/docs/Web/API/Window.location): &gt; Though Window.location is a read-only Location object, you can also assign a DOMString to it. Could window simply have had getLocation() and setLocation()? Sure. As I was typing up this response, it occured to me that I glossed over a detail. Please see the edit to my first post, as it probably would have answered your question.
Personally, I prefer to avoid getters and setters at all costs. They're not explicit. As developers, we know that code isn't magic. So code shouldn't *seem* like magic. A line of code is not your girlfriend texting you, "yeah, have fun at that party without me," and it should not read like it has a plethora of interpretations. It should be immediately obvious what's happening. Setters and getters obscure intention. They're not clever, they inhibit a developer's ability to interpret a line of code and what it's doing. A lot of issues in JavaScript (with, eval, new, | 0 for type coercion, etc.) do not actually completely inhibit the ability to read a line of code --- as long as you understand what "| 0" does, for example (force to 32-bit int), you know what it's doing everywhere. And it's not hidden from view - the code is in plain sight. myObject.value = 'hello'; Is immediately readable. myObject.value should now be "hello." Nothing else should have happened in the script. myObject.set('value', 'hello'); Whereas here, my intuition as a developer is going to tell me that there's more than meets the eye - there's definitely a method being invoked here, there's a good chance it's doing something specific (validation, etc.). I know to go back to either myObject or somewhere in myObject's prototype chain to trace what's happening. When in doubt, always try to write code that feeds into a developer's natural intuition. Getters and setters are nightmares as far as readability is concerned. Be explicit nearly to the point of being verbose.
Flash came a year later. And like Flash, the Java plugin had to be installed separately. Well, in the olden "DHTML" days (before xhr), JavaScript wasn't very useful. People used it to preload images, expand/collapse menus, and for changing more than one frame when a link was clicked. And for doing some pseudo marquee shizzle in the title and status bar, because that was kinda cool, apparently. Anyhow, the main point was that JS is losing share to those various to-JS options.
Cool, thanks a lot!
Removed, please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Removed, please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
I think you didn't actually read the whole original article very well. Or maybe we just got that wildly different interpretations of what they said.
`bestilling.onsubmit = function() { return validereSkjema() }`
but it's also gaining share from flash. so how are you so sure that it's losing share overall? Also I think it's weird to assert that CS or typescript is taking share *away* from JS, since they are just layers on top of JS, and JS is still included in the stack.
What's the problem? This doesn't look like spam. It's not against reddit rules to post to your own content. Looking at their history there is a wide range sources. From http://www.reddit.com/rules: &gt; Don't spam. &gt; [‚Äì] What is spam? &gt; OK: **Submitting links from your own site**, talking with redditors in the comments, and also submitting cool stuff from other sites.
Completely agree. They destroy the very useful distinction between properties and methods. DOM API already does this, and I think it sucks. Every property of a DOM element you want to read (for example element.offsetHeight), you can never really know if it is just a cached value or if it's a getter that triggers a layout cycle of the rendering engine. And I think that's pretty terrible.
From the [reddit FAQ: What constitutes spam?](http://www.reddit.com/wiki/faq#wiki_what_constitutes_spam.3F) &gt; If over 10% of your submissions are your own site/content/affiliate links, you're almost certainly a spammer. And from the [reddit wiki for Self-Promotion](http://www.reddit.com/wiki/selfpromotion): &gt; You should submit from a variety of sources (a general rule of thumb is 10% or less of your links should be your own site), talk to people in the comments (and not just on your own links), and generally be a good member of the community. Given that, let's look at /u/krasimirtsonev's history: Recent Submission history for krasimirtsonev: domain submitted from|count|% :-|-:|-: [krasimirtsonev.com](/search?q=%28and+site%3A%27krasimirtsonev.com%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|42|67% [absurdjs.com](/search?q=%28and+site%3A%27absurdjs.com%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|3|5% [code.tutsplus.com](/search?q=%28and+site%3A%27code.tutsplus.com%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|3|5% [github.com](/search?q=%28and+site%3A%27github.com%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|2|3% [krasimir.github.io](/search?q=%28and+site%3A%27krasimir.github.io%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|2|3% [drewbarontini.com](/search?q=%28and+site%3A%27drewbarontini.com%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|1|2% [binpress.com](/search?q=%28and+site%3A%27binpress.com%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|1|2% [bastianallgeier.com](/search?q=%28and+site%3A%27bastianallgeier.com%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|1|2% [hacks.mozilla.org](/search?q=%28and+site%3A%27hacks.mozilla.org%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|1|2% [blog.webbox.io](/search?q=%28and+site%3A%27blog.webbox.io%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|1|2% [vimeo.com](/search?q=%28and+site%3A%27vimeo.com%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|1|2% [justdesignthings.com](/search?q=%28and+site%3A%27justdesignthings.com%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|1|2% [youtube.com](/search?q=%28and+site%3A%27youtube.com%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|1|2% [nodejs.krasimirtsonev.com](/search?q=%28and+site%3A%27nodejs.krasimirtsonev.com%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|1|2% [sitepoint.com](/search?q=%28and+site%3A%27sitepoint.com%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|1|2% [gabrielecirulli.github.io](/search?q=%28and+site%3A%27gabrielecirulli.github.io%27+author%3A%27krasimirtsonev%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new)|1|2% The 67% (which would be even higher if nodejs.krasimirtsonev.com was included) is _well_ above the 10% guideline.
Sure, but those are just guidelines. I'm not going to start some long debate. I just wanted to say that as a long time redditor, this content looks appropriate and a ban seems like it would be really heavy handed.
It's not a ban, just a warning, and no action has been taken aside from this post being removed. I appreciate the feedback, and this is probably the hardest part of modding ([I wrote a lot more about it awhile back](http://www.reddit.com/r/videos/comments/2idhxn/lets_talk_about_reddit_and_selfpromotion/cl1eq3k)), but I have to apply our guidelines consistently. For instance, /u/ZaheerAhmed was submitting a lot of his own stuff, but after the warning, he started submitting from a variety of sources. So even though his percentage is above 10% (it's at roughly 30% as of right now), the fact that he respected the warning has allowed him to stay. There are many stories like his, and unfortunately, many where the user doesn't heed the advice and must be banned. This is a crossroads for /u/krasimirtsonev, and we'll just have to wait &amp; see where it goes from here.
&gt; I think it's weird to assert that CS or typescript is taking share away from JS TypeScript is a superset, not a subset. CS is a different language. **Edit:** By the way, AS3 is also a superset of ES3. Do you count that as JS, too?
so your argument for .length getters is that you want to trick people into thinking your custom data object is actually a native array? Doesnt that seem kinda... deceptive?
Exactly how I read it too. Title was just over the top. Not even "Express.js in Flames".."**Node.js** in flames". Jesus Christ man.
So what. They are just facades for JS. It's not like they cut JS out of the equation. I mean, this point isnt really worth arguing. I just think you have a weird perspective on it.
&gt; It's not like they cut JS out of the equation. Is that how that works? If you compile a million lines of C/C++ to JS, it becomes a JS project? Someone who knows JS can join the team and contribute to that codebase? Look, it's simple. It's either JS or it isn't. TS/AtS, CS, Dart, Ceylon, [and so forth](https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js) aren't JavaScript.
&gt; What if another pre-compiler comes along that supports something else that Javascript doesn't do on it's own? &gt; Will Flow compile into that dialect, from which you will further compile down to native Javascript? &gt; How can multiple pre-compilers be handled? Flow is specifically for Javascript. It's not really a "compiler". It's a type checker. It adds optional type annotations - the same concept as what Googles Closure Compiler does, however it adds them as syntactic sugar rather then as part of comments (Since it's much easier to work with). Having multiple similar dialects of languages is a very common concept, and most certainly not without precedent. Almost all languages that exist today in some way started out as a "fork" of one of more other languages. People originally make the same arguments about C over Assembly. And then C++ over C. (Early C++ compilers simply transpiled to C source code). C# was originally considered a clone of Java. How many variations on Lisp exist today? ML turned into SML and Caml which turned into OCaml, and then there's Haskell, which inspired Idris etc. Javascript itself originally started as a dialect of scheme, and was only turned into the mess it is today because Netscape wanted something that looked more like Java. &gt; Again, I am not arguing against static typing. I'm arguing against pre-compilation as it seems to currently stand because: &gt; My team also manages to write rock-solid, 95%+ test covered code on huge codebases without the need of them, which goes to show that pre- &gt; compilation from a DSL is an unnecessary feature to write top-quality code. It's nice-to-have, but not a necessity, regardless of your codebase's size. What's your definition of "huge" codebase? My definition starts at about a million LOC. If you can tell me you're managing a million LOC codebase in Javascript without having a single type-error in your code with a completely straight face, then I have a six-figure job offer for you. (really!). Keep in mind by "No type errors" I mean - It has never crashed or misbehaved - Thrown a stack trace - Hit any kind of null-reference exception, "undefined is not a function", or such - Rarely if ever need to perform runtime debugging. Most of the time when I'm talking to people working on dynamic languages claiming that static languages are useless, they a) Are working on a project of at most a few thousand lines b) Fundamentally misunderstand what static typing is and how well a good statically typed languages can eliminate the vast majority of bugs with very little effort. c) Equate "Static Typing" with "Java", possibly the most cumbersome language in existence, and therefore assume all statically typed languages are painful to use. At which point I usually try and convince people to try languages inspired by ML. I highly recommend giving one of these languages a go, they might change your opinion on static typing. (Pick something like OCaml, F#, SML, Haskell, Scala, or Rust). These languages feel very fluid and easy to use, require very few actual type annotations, and have uncanny ability for your code to work correctly the first time you run it. &gt; aThe current implementation of pre-compilers forces my team to "choose one": &gt; I cannot mix Spider.js, Coffeescript, and Flow together. I must choose one. &gt; What happens if there's a new pre-compiler that has an irresistible feature, and I can't take advantage of it because I've already invested my codebase into a different precompiler? So because you can't have every single language feature crammed into one magical super language, you should only ever use the lowest common denominator? The same problem exists today with any language and platform. All languages have pros and cons, and you need to weight up what works best for the task at hand. I like both SML and OCaml, they are very similar and both have things I like and dislike. But I realistically have to pick one. In many cases you can work with multiple languages on a single project. I.e. the JVM you could use Scala, Groovy, Jython, JRuby, and Java all on the same project with minimal effort. In Javascript, you can mix and match as many AltJS languages as you wish. Use Javascript, Coffeescript, and whatever else tickles your fancy wherever it's appropriate. Flow is really just Javascript, so I don't see there being major incompatibilities with other tools. If you don't see the benefit of a type checker, nobody is forcing you to use one. But if you did decide to use Flow, it comes at very little cost because - again - it's just Javascript with optional annotations (That you rarely if ever have to actually apply). It's not a separate language. 
All I want to say is wow. You should teach.
?
This post is so much worse than the one it calls out. &gt; As it turns out, the complexity tradeoff between iterating over an array (which tends to be short given most application routing requirements) and walking a tree makes arrays a much better choice. Walking a tree is not a complex algorithm by anybody's standards. &gt; The only router I know that uses a fancy tree is director and that design significantly handicapped it‚Äôs feature set and usefulness. In a post about trashing a framework without backing it up, you're trashing a framework without backing it up. What features, exactly, did Director fail to implement as a result of its hash-based design? &gt; Matching routes to requests is tricky because developers like to use everything for defining their routes. And a library's job is to implement everything that developers like to use? If that's what express.js is trying to do (which I seriously doubt), then that's a big problem by itself. &gt; you cannot look up a regular expression match based on a string. Stop with the "cannot"s. It's absolutely possible to write a regex engine that matches against multiple expressions at once, the reason that's not going to happen is because it's more complex than you or I have time for (and maybe are capable of), not because it's fundamentally impossible. &gt; A hash will only work if you limit routes to static string values You can also use it for string patterns. You know this, because you know about Director and you know about globs. Funny that you didn't mention it. &gt; (and if that‚Äôs the case, why use a router at all) Uh, to route urls? How are you suggesting we serve pages without a router? Do you not count it as a router if it sometimes maps to a filesystem? &gt; The middleware architecture requires repeating the same path multiple times in the array because that‚Äôs how the matching works. Yes, that is the case for middleware, and it raises the question of whether that approach is appropriate for all handlers, seeing as they do not all share the same restrictions. &gt; You cannot compare two regular expressions to decide if and how much they overlap, and in which order they should be compared. Again with the cannot. "Have no sane reason to" is accurate; "cannot" is almost never. &gt; But that admission does not excuse criticizing the framework as inept. Criticism doesn't need to be excused, and "inept" is your word, not theirs. (I realize that OP didn't write the linked gist, this comment is directed at the author.)
Understood, thanks and sorry for the mix up :)
Except if you read the guy's comment, he was clearly talking about which language is executed by the client, not the language being written in the dev interface. &gt; I honestly believe that within 10 years a majority of client code will be executing in the JavaScript engine. That JavaScript will grow faster than any other language on the client... Pretty much all other new client side, that I am aware of, run on the JavaScript engine such as things like Dart and Coffeescript. And then you object with "yeah but you're wrong because developers wont be coding directly in Javascript!" Well, settle down there bucko, you can both be right. Basically you derailed the discussion with an apples to oranges comparison/strawman. But then the question becomes, why did you do this? Are you just bored?
The important thing here is: generators are not doing any of the async or parallelism stuff. That's all done via promises or callbacks. So yes, generators can't do parallel operations and generators can't do anything asynchronous. That's the reason why regenerator can compile them to ES5 without (m)any issues. For example: function *x(n) { while(n &gt; 5) { yield n--; } } Is nothing more than "syntactic sugar" for something like: function x(n) { return { next: function() { if (n &gt; 5) { return { value: n--, done: false }; } else { return { done: true }; } } } } That's obviously ignoring a lot of details but I hope it removes any notion of generators having any connection to asynchronous execution *at all*. They are 100% and without any discussion synchronous. In combination with promises they allow for very nice code, and that's also where ES7 async function come in: // takes, id, returns Promise&lt;Boolean&gt; async function allowEverything(id) { // users.get returns promise, rejection gets turned into exception let user = await users.get(id); return user.name === 'admin'; } `co` unfortunately actively hides a lot of the awesomeness that is theoretically possible. I'd recommend checking out `bluebird` or `6to5` which make async functions available today. With `bluebird`: var async = require('bluebird').coroutine; var x = async(function *x(id) { // users.get returns promise, rejection gets turned into exception let user = yield users.get(id); return user.name === 'admin'; }); With `6to5` the async function example above works without any changes.
I find it pretty hilarious that you hate those comments so much that you're writing a plugin to hide them. Personally I get a kick out of em but yeah I can see why they are annoying to some people.
There is an important advantage in encoding more instructions in one statement, and that is the reduction in amount of file size. When I started JavaScript I was using far fewer abstractions, but then noticed various patterns got repeated a lot, and I considered them 'boilerplate' code. I also found ways to remove the parts of the code that were very repetitive (which I did not have as much capability to do in C# and ASP.NET), and by doing so, considerably have reduced the total amount of code I've used to do some things, but in doing so have made it more complex. 
Thanks for explaining!
Isnt it amazing? SVG is just a tiny part of what it can do.
It's actually ES4. Adobe split from the standards body and implemented their notion of it themselves.
I liked the simplicity of refluxjs. But I shared the same sentiments on the hotwiring maintenance concerns. This seems to suggest that something else was missing. I settled on refluxjs + omniscientjs/immstruct combo. I made a brief comment on this on another thread: http://www.reddit.com/r/javascript/comments/2mndc3/on_react/cm5znll Essentially, your app state is kept in a cursor (or if you want, more than one cursor). You pass the cursor from the root react component, and components would render based on that cursor. omniscientjs would let you know when your cursors changed, and you may choose to re-render. I chose the convention to keep any updates on cursors away from UI components, and put them into refluxjs (stores). Any user events originating from react component would call a refluxjs action (fire-and-forget). Then your stores which listen to these actions would modify the cursors appropriately. I believe this enforces stronger unidirection data flow, and an added advantage is that you don't need to wire refluxjs stores to the react components; since omniscientjs takes care of that. Your architecture will be like the following: Initial app state +-----&gt; Cursor +---&gt; UI Component ^ + | | | | + v Stores &lt;-----+ Actions 
Sort of. It's an implementation of the ES4 draft. ES4 never came to be. So, as far as JS timeline is concerned, AS3 is a superset of ES3. There is no ES4 and ES5 isn't a superset thereof.
An argument for using getters and setters came up at work today: we have a few hundred small applications sharing the same library for retrieving user information from a database. When the library was written, only a few of the properties required getters, so the rest were just marked public and have been accessed accordingly. Now it's come up, because of a policy change, that we need to log any user information that's being retrieved. If we'd used getters for all the properties in the first place, we could simply add a logging function to each, but since we didn't, and the applications using the library are all accessing the properties directly, we now have to create getters and manually update those applications to use them. Where I'm going with this anecdote is that getters and setters aren't always necessary and often will needlessly lengthen your code, but it never hurts to think ahead.
This is really well done..you should consider posting this to /r/node they would appreciate this.
I think this is a good reason to never access properties directly in client code, but instead use methods. That's the typical OOP way of doing things.
Very very cool! I've had several people ask is we would build something like this as a complement to [Netlify](https://www.netlify.com), but we have to stay focused on what we're doing. Love the idea of having a quick place to trigger some node functions through a webhook. Sounds like the new lambda service from Amazon night be a tough competitor, but I'm if you can make something really focused and keep it simple, you'll still have an advantage against one party of a huge and complex toolset :)
How would you handle control-flow with just generators? Did you mean [ES7 async/await](http://jakearchibald.com/2014/es7-async-functions/)? At the moment, I think [suspend](https://github.com/jmar777/suspend) is the sweet spot for handling and integrating different kinds of flow (callbacks, thunks, and promises) together.
Nothing to be said about security? 
Not at all; they're not intended to *be* arrays; the length getter was simply following convention. Some of these data structures are actually nested (something of a composite implementation, if you will). Consider [Backbone's Collection](http://backbonejs.org/#Collection-length) : Each collection has a `length` property that is manually updated whenever `add` or `remove` are called. If someone were to extend the base Collection class and override add or remove, and forgot to update length, then length is broken. If someone were to write to the length property, then length is broken. This is different behavior than the standard array (you can set the length of an array to 0 and it will empty the array). In my case, I have yet to implement a setter for length to mimic that behavior, but setters do afford that opportunity, much the same way getLength and setLength would do. To my mind, having a `length` property that is a mere side effect- instead of a computed property- is more deceptive.
sounds similar to [Node-Red](http://nodered.org/)
welcome to react.
[Vanilla javascript example](http://jsfiddle.net/8t1swnd0/1/). 
Honestly I never made any chrome extension before and thought this would be a nice chance to learn how to do it.
Tell me this because I never got that far with Snap, is there a way of achieving the same thing as Raphael's [paper.customAttributes](http://raphaeljs.com/reference.html#Paper.customAttributes)? That was a really useful thing I liked in Raphael that seemed to be missing from Snap.
node.js embraces `service locator` pattern. Dependency injection, while [possible](https://www.npmjs.org/search?q=dependency%20injection), is much less popular within community. The difference between the two is that with service locator your module is responsible for creating its dependencies (via call to `require()`). With dependency injection the code is given its dependencies. I would recommend to stick with regular commonjs's `require`, since you will get better interop with existing ecosystem: Testing support, code reuse, crossplatform (client/server) code generation. If you want to substitute some dependencies for tests, just use [proxyquire](https://github.com/thlorenz/proxyquire)
Can i use this to compress an image with tinypng/tinyjpg and then send the link to firebase if i don't have a backend for my app? Here's the tinypng api https://tinypng.com/developers/reference Can i use the node.js code as a hook so i can call it from my angular app?
python? yuck
...a library do to what? [parsing svg paths](https://www.npmjs.org/package/parse-svg-path)? [linearizing curves](https://www.npmjs.org/package/svg-linearize)? [creating an element with the correct NS](https://www.npmjs.org/package/svg-create-element)? [loading an svg over xhr](https://www.npmjs.org/package/load-svg)? There are plenty of small libraries to solve specific problems involving svgs. I don't see the why there are so many libraries that try to do everything and predictably run up against limits.
Usually this is done by allowing an override inside of your function (or via a method). One common example is grunt: // Basic Gruntfile template module.exports = function (grunt) { grunt.initConfig(...); }; // Then, you can pass in any grunt variant you want: require('./Gruntfile.js')(require('grunt')); require('./Gruntfile.js')({my: 'customGrunt'});
How do you count the watches? I have an inspector plugin for chrome but that just shows a lot of cool graphics that are useless when you have a lot of scopes or watches - my chrome just freezes trying to scroll through all the scopes/watches. What's a better way? I'm using bluebird on the backend mostly. With angular I do use $q but I've done a lot more complicated stuff with bluebird, so I feel I can recommend it.
I take it you're not a fan of reactjs? Do you use it anyways?
Thanks for the write-up. I'm not familiar with omniscientjs or cursors (only heard about them so far), but the library's site makes it sound like you don't need refluxjs at all. Can you explain how refluxjs fits into this and why I would use it together with omniscientjs?
Yes and Yes.
I missed it the first time round, I'm interested in seeing it.
Does anyone know: What version of JavaScript/ECMAScript this compiles to How efficient it is and what tooling it uses (eg compile to LLVM, use emscripten) ?
[**@kuizinas**](https://twitter.com/kuizinas): &gt;[2014-11-22 11:56:09 UTC](https://twitter.com/kuizinas/status/536125980528889856) &gt;I say people! \(W?\) GitDown is out ‚Äì [#GitHub](https://twitter.com/search?q=%23GitHub) markdown preprocessor. Come on and [#GetDownOnIt](https://twitter.com/search?q=%23GetDownOnIt)! [*github.com*](https://github.com/gajus/gitdown) [*youtube.com*](https://www.youtube.com/watch?v=qchPLaiKocI&amp;t=20s) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2n2p4i%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Looks like ES5 since I see Object.create [in its output](https://github.com/alongubkin/spider/blob/682fafff69d7f17cbc5904bfee410a54b39c0846/lib/ast/expressions/UnaryExpression.js#L12). This appears to be a basic transpiler in the spirit of CoffeeScript. Since the transpilation process for this kind of languages is straightforward I would expect a similar performance profile to CoffeeScript. Haven't tested it myself though or seen any tests. Emscripten: this is usually used when you want to pull in stuff that already (or easily) targets LLVM into JavaScript land. It's not used here and would be an unusual choice for this kind of transpiler. I suppose one thing in favor for passing a given transpiler through Emscripten is that you would have LLVM output, which means you could target non-JavaScript platforms. A big argument against doing so is that transpilation potentially becomes harder to reason about: * The difference between original source and final JavaScript could potentially be greater as you pass through LLVM. * Emscripten-produced code can potentially be a little harder to read. * Reasoning about performance might be be harder since code changes you make might not make it through two layers of compilations the way you'd expect. * Additionally, you'd potentially lose the ability to do inline JavaScript when necessary (CoffeeScript has this feature - not sure if Spider does). (Edit: formatting) 
`$q` is bullshit compared to bluebird. It's a strapped down version of `Q`, except they had to re-implement it from scratch so it triggers `$scope` automatically. It provides none of the helpers bluebird or `Q` provide and its Angular-specific behaviour makes it incompatible with other promise implementations. `$q`'s existence is an artefact of Angular's `$scope` magic. It's a stupid hack to support async behaviour in Angular in the absence of `Object.observe`. Angular has its heart in the right place, but what it tries to do is simply too far ahead of its time. There's a reason AngularJS 2.0 is built around ES6 and HTTP/2. Seriously, give React a try. It provides less affordances than ng, but most of them only come back to bite you anyway (like your unnecessary watches).
You're being downvoted because this is a question about Node, not Angular.
Do you really *need* dependency injection? If you just want to substitute dependencies for testing, check out [rewire](https://npmjs.org/package/rewire). You may be overengineering things if dependency injection is the best solution to your problem.
+1 for the Dr Who / Back to the Future themed "Hello World". -1 for spiders.
Not that I'm aware of. I was thinking about putting together a reference for the various JavaScript related conference talks and screencasts, but I just don't have the time. A lot of the JSConf (and related conferences like JSConf.EU) talks are on YouTube: https://www.youtube.com/user/jsconfeu
Or with ES6-style promises: return new Promise(function (resolve, reject) { doSomeProcessingAndRunCallback(someData, function (err, result) { if (err) reject(err); else resolve(result); }); }); Most standalone promise implementations have some utility method for that (try searching for "promisify" in their API docs), e.g.: return Promise.promisify(doSomeProcessingAndRunCallback)(someData); 
In my opinion, getters and setters are fine, but they need to adhere to two simple rules: 1. They must not have any unexpected side-effects (okay: change a related property on the object, not okay: make an HTTP request). 2. They must not be computationally expensive (okay: push an item to an array, not okay: calculate the Fibonacci sequence). The exact degree to which they should adhere to these rules is difficult to generalize, but I think these rules are a good start. Two obvious use cases I can think of for getters/setters: 1. Expose a value as read-only but allow privileged code to modify it. 2. (Cheaply!) compute values that are dependent on other data (this is likely more appropriate in setters than in getters, counter-intuitively); e.g. a running average. But in my opinion getters/setters live in the same space as inheritance: they are great in a handful of situations, but you should not use them unless you are in those exact situations. Most of the time, using them is a bad idea. If you are wondering whether you should be using them, the answer is probably "no".
Interesting, but doesn't seem well designed. E.g. both `for of` and `for in`, doing the opposites of what they do in JS. It's hard to see what it gives over ES6.
could probably just throw up a repo and outsource the work via pull requests? 
For Node.js projects: [Bluebird](https://github.com/petkaantonov/bluebird), [gnode](https://github.com/TooTallNate/gnode), [Lo-Dash](https://lodash.com/). Gnode will become unnecessary with Node 0.12. Also, built-in language features can often be used instead of Lo-Dash.
how did you take this screencap?
It's on my todo list for a while now to give react a lookover. I was under the impression that the whole virtual DOM architecture is aimed at supporting interactive interfaces rather then simple binding (as angular does) so i havent got to it yet. I defientily agree with your statement regarding angular - One of the first thing i had to do when comming to optimize the app was to limit the scope of angular (move more towards server side rendering, Dropped ng routing and used ng only on pages where I needed app behavior). The app was leaking like a sinking ship because of some weird router bug (which is solved now in 1.3).
Oh, I dont use node for backend. I'm guessing you are using batarang... The easiest way to count watches is to recursivly iterate the child scopes from the root scope and sum the length of $$watches. See [this SO question](http://stackoverflow.com/questions/18499909/how-to-count-total-number-of-watches-on-a-page) for some of the implementations.
In that case here is the link to the last time we discussed all of this: https://www.reddit.com/r/javascript/comments/2lsc6r/introducing_spider_the_nextgen_programming/ 
If you are using ES5 then you could just have used the getter/setter support in the language itself to make the change and it would not have been necessary to change any code which uses your API. Spamming your code with getXXX() and setXXX() methods is the Java style of doing things. JS has better support for it. 
Thanks @sigwhite. Some usefull things here. interesting what you wrote about ramda. I know that the new lodash (edge) is buit with lazy evaluation and more attention to curring. The [benchmarks](http://jsperf.com/lodash-lazy#chart=bar) are usually against underscore and native implementation and they look promising. I'm wondering if being consistent in the usage of libraries like lodash/underscore/ramda for data manipulation can save the use of some of the shims you mentioned....
Really liking the look of this from what I read. I feel it attempts to just provide some thin layering of JS without tossing out everything, making some of the stuff thats needlessly hard to do in JS much easier. Probably my favorite candidate that I've read about yet for JS development There are a few things I don't like, though: &gt; In Spider, logical operators always result in a boolean value regardless of the types passed to it. &gt; x = false or 5; // x == true; That's kind of unexpected for me, since I use this a lot. &gt; var multiplier = 3; var message = "\(multiplier) times 2.5 is \(multiplier * 2.5)"; Really don't like this model for string interpolation, not to mention the ugly syntax. I'd much prefer a python style with an explicit operator, and not the PHP / Perl style.
The point is that ES6 will include a `for of` without the gotchas. This means Spider's `for in` is ES6's `for of` and viceversa. Confusing as fuck.
Gitdown v1 has been released with all of your feedback taken into account. Thanks everyone. http://www.reddit.com/r/javascript/comments/2n3222/gitdown_github_markdown_preprocessor/
I would probably use AngularJS with ui-router to provide nested states. But that's a beast to learn if you haven't touched it.
This is a public web site. ajax is just used as an "enhancer". It's not using a full front-end framework.
You lost me at "func" Seriously. Either make it an arrow like ES6 or coffee or call it "function". 
The problem with using lodash/underscore *instead* of shims is that third-party libraries will either have to be using the same utility library or bring their own implementation. Neither is great (creating redundancy and possibly subtle bugs). I only use ramda for composition, really. Unless you're doing massive amounts of processing with underscore/lodash/ramda/etc, the performance differences are practically irrelevant.
So if I hit the page initially and hit link 7, what's "div2" supposed to look like? This seems like it is a bit over organized. You can't just independently content load and show "div3" ?
Bookmarklet? javascript: (function(){ EvalForm.gept0[0].click(); })()
QuickTime player on a mac has the option to record a screencast 
Like this: http://davidwalsh.name/async-generators
If you're thinking what /u/dashed mentions below, maybe you're not aware of how you can invert the yield/next call to handle async calls? Great example: http://davidwalsh.name/async-generators
I mean, if you think of it that way sure, if view 2 absolutely has to be rendered, just make it render its own content as empty but still provide it content for its "subview".
As someone who uses a lot of varied JS stuff (typescript, coffeescript, vanilla js)... this looks interesting, but probably not usable. `::` immediately looks out of place, as it's attached to nothing. I scrolled down and say "access the global scope" which is nice, but in any language I've seen `::` as an accessor, there was always something on the left. I don't like that `==` compiles to `===`. That's just confusing. Do what coffeescript does and use `is`. String interpolation looks weird, but I think every language does it differently, so whatever. The `if` syntax looks pretty bad. No parens and uses braces. It's basically just vanilla JS, because when you have to have complicated expressions that you don't want curried, you'll have to put them in parens anyway. Much like in coffeescript, I'm bothered by the lack of `do while`. It's rare that I have to use it, but when I do, I get annoyed that I have to do: do function() do function() until condition() It doesn't look like I can do deconstruction like I can in coffeescript, which is probably the best feature ever. Seriously, I can deconstruct complex objects with one line of code. So nice. The switch syntax just looks opaque. Why are there braces and commas? I do like that you can say to explicitly fallthrough. That's nice. I'm not seeing a way to escape javascript into this. I've hit a few situations in coffeescript where I need to escape JS for some reason (because the coffeescript compiler has some bugs). That's kindof a problem. But much like coffeescript, I don't see this being super useful when ES6 is a thing. I'll still use coffeescript, because it will still have some features ES6 won't, but this doesn't seem to have anything that would compel me to use it.
[fn](http://en.wikipedia.org/wiki/Rust_%28programming_language%29)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Rust (programming language)**](https://en.wikipedia.org/wiki/Rust%20%28programming%20language%29): [](#sfw) --- &gt; &gt;__Rust__ is a general purpose, [multi-paradigm](https://en.wikipedia.org/wiki/Multi-paradigm_programming_language), [compiled programming language](https://en.wikipedia.org/wiki/Compiled_programming_language) developed by Mozilla Research. It is designed to be a "safe, [concurrent](https://en.wikipedia.org/wiki/Concurrent_programming_language), practical language", supporting [pure-functional](https://en.wikipedia.org/wiki/Purely_functional), [concurrent-actor](https://en.wikipedia.org/wiki/Actor_model), [imperative-procedural](https://en.wikipedia.org/wiki/Procedural_programming), and [object-oriented](https://en.wikipedia.org/wiki/Object-oriented_programming) styles. &gt;The language grew out of a personal project by [Mozilla](https://en.wikipedia.org/wiki/Mozilla) employee Graydon Hoare. Mozilla began sponsoring the project in 2009 and announced it for the first time in 2010. The same year, work shifted from the initial compiler (written in [OCaml](https://en.wikipedia.org/wiki/OCaml)) to the [self-hosted](https://en.wikipedia.org/wiki/Self-hosting) compiler written in Rust itself. Known as *rustc*, it successfully [compiled itself](https://en.wikipedia.org/wiki/Bootstrapping_(compilers\)) in 2011. The self-hosted compiler uses [LLVM](https://en.wikipedia.org/wiki/LLVM) as its [backend](https://en.wikipedia.org/wiki/Backend). &gt;The first numbered [pre-alpha release](https://en.wikipedia.org/wiki/Software_release_life_cycle#Pre-alpha) of the Rust compiler occurred in January 2012. Development moves quickly enough that using the stable releases is discouraged. &gt;==== &gt;[**Image**](https://i.imgur.com/6zzC3UO.png) [^(i)](https://en.wikipedia.org/wiki/File:Rust_programming_language_black_logo.svg) --- ^Interesting: [^Servo ^\(layout ^engine)](https://en.wikipedia.org/wiki/Servo_\(layout_engine\)) ^| [^Brendan ^Eich](https://en.wikipedia.org/wiki/Brendan_Eich) ^| [^List ^of ^Mozilla ^products](https://en.wikipedia.org/wiki/List_of_Mozilla_products) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cm9wdm4) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cm9wdm4)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Don't know why you were down voted. Any layer of transparency between the developer and the main language is just something more to maintain. Here is the [list for your moratorium](https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js). Looks like Spider and Flow need to be added.
+1 for $q being bullshit. The lack of done() alone drive me nuts. While React is amazing you can't really suggest React as an alternative to Angular. If you want to gain some of the slick things that React does without losing the full stack from Angular there is a React directive for Angular ([ngReact](https://github.com/davidchang/ngReact)). This is good for those Angular apps that show large data grids or tables of items. Or if you've already moved up to Angular 1.3 check out the the documentation for [One-Time Binding](https://docs.angularjs.org/guide/expression) which would greatly reduce the number of implicit watches.
Without optional types, I don't really see why anyone would use this over JS. &gt;Additionally, loose typing can be one of JavaScript's best features if used correctly. That argument is kinda weird. *Optional* types are obviously not mandatory. If the type system doesn't let you express something, you can just skip it. In the vast majority of cases, however, your function takes some specific arguments and returns a specific kind of value. You probably want to document that and make the tools aware of that kind of that "contract", too. Optional types are really great for that.
But the divs are not known beforehand. Parent div initializes it's immediate children. I need to automate this things someway.
Thanks for posting that link. That list is... overwhelming and a little disturbing too. But it looks like there may be some useful diamonds in the rough there.
I'll say it again. This is fine, but I will never use a language developed and maintained by a single developer. There is absolutely no guarantee that you will complete or maintain this project in the long run. Get some more support and come back when you aren't in alpha with something that you're claiming is better than everything else out there. edit: This is not backed by a company or a community, so what guarantee is there that you won't lose interest? 
Well hot damn am I ever excited about this. Was waiting to use a lot of the new features in ES6 for a while now and I guess this will make it possible.
Probably similarly to that: &gt; `reduce` does what it says on the tin, reducing an array to a single value by running a function on each item in the array, and having that function build a cumulative representation of the values.
`::` is used to access to the global scope in C++ (for example if you're in a nested namespace that for some god forsaken reason is named `std` you can access global `std` using `::std`)
The reduce function reduces a collection of values down to a single value For example, the sum of an array of numbers (using the lodash syntax as that's what I'm familiar with) _.reduce([1,2,3,4], function (accumulator, value) { return accumulator + value; }, 0) would result in the value of 10 returned.
Oh, you can? Shows what I know. I take back what I said, but it still looks weird not having anything on the left side.
&gt; sometimes I have to coerce data You don't have to rely on implicit type coercion. You can of course just use explicit type conversions instead. &gt; typeof +'5' "number" &gt; typeof 5..toString() "string" &gt; typeof (''+5) "string" &gt; typeof !!'foo' "boolean"
You are basically describing ECMAScript 6 (which borrowed quite a bit from Python and CoffeeScript). `for-in` has always been quirky, it is completely replaced by the much saner `for-of` in ECMAScript 6 (as @allthediamonds mentioned).
You don't need a full framework to use some kind of smart routing, have a look at http://visionmedia.github.io/page.js/ for something lightweight.
The reduce function calls an iterator function on each element of an array, whatever the function returns is either passed into the next call of the iterator, or is returned as the result of the reduce call itself.
You can do for loops in the console as well, for( var x=0, y=99; x&lt;y; x++){ EvalForm["gept" + x][0].click(); }
Cool. Ya I wasn't trying to be a jerk about someone's work. I have just been reading tons of articles recently about new languages that either compile down to javascript or offer some amazing new feature but are otherwise just half-baked. Personally I've just been in a mood recently of diving deep into the tools I already know rather than taking on more stuff. If I happen to miss the next big thing thats OK with me cause I'll catch onto it once the community is been developed.
I liked the title. I'll stop my review right there.
Mutation isn't evil when talking about concurrency. Code that is not thread safe is evil when running concurrently. If you require a tool that gives you immutability by default, maybe you shouldn't use Javascript. Note that most issues that occur in concurrency related to mutated shared state are side effects, not intentions. By "just trusting" the developer to give some promise that everything is thread safe by not marking variables as possibly mutable is effectively saying that all developers never write bugs.
&gt; optional types I've been considering this sort of thing for our codebase. Do you have any language suggestions? Twitter's recent (?) move to Scala has me thinking adding a loose type system to js would be helpful. 
That's pretty interesting, thanks. But the main point is to avoid having to open the console since I go through dozens and dozens of these windows a day that close themselves, then having to reopen the developers tools and then the console again is just extra work, which I'm trying to avoid in the first place. I have to click 40 of these buttons per page, and the answer is the same for each question 99% of the time. I just want to set them all at once without having to click them, and then go back and change one if I need to. It's really an exercise in avoiding needless work/carpal tunnel syndrome 
If you just want something like ES6 with optional types, try TypeScript. If you want metadata annotations on top of that, go with AtScript. (AtScript is a superset of TypeScript and TypeScript is a superset of ES6.) If you want all of that but also get rid of all of JS' quirks, go with Dart. Anyhow, with either option you just have to add some types at the boundaries (fields, arguments, return values) to get all the tooling benefits. Inside your functions, you can generally omit the types, because there is enough type information floating around to make sense of everything. So, when you stick the return value from some function which returns a number into a `var`, your IDE will remember that this thing is actually a number. It will show the corresponding call-tip when prompted and it will also notify you if you use that variable incorrectly. E.g. when you pass it to a function which expects a string.
A Greasemonkey script could be an option. Greasemonkey is a Firefox addon which lets you run custom scripts on specific websites.
In a single sentence of pseudocode: [a, b, c].reduce(+) == (((a) + b) + c)
Not an option. System is locked down to a specific version of IE, and whitelisted. 
I have quite a few examples using Angular's $q service [here](https://github.com/jimschubert/NewTab-Redirect/blob/master/js/services.js).
Well, then your only option is a bookmarklet. Wikipedia has a basic introduction: http://en.wikipedia.org/wiki/Bookmarklet
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Bookmarklet**](https://en.wikipedia.org/wiki/Bookmarklet): [](#sfw) --- &gt; &gt;A __bookmarklet__ is a [bookmark](https://en.wikipedia.org/wiki/Internet_bookmark) stored in a [web browser](https://en.wikipedia.org/wiki/Web_browser) that contains [JavaScript](https://en.wikipedia.org/wiki/JavaScript) commands to extend the browser's functionality. &gt;Bookmarklets are [unobtrusive scripts](https://en.wikipedia.org/wiki/Unobtrusive_JavaScript) stored as the [URL](https://en.wikipedia.org/wiki/Uniform_Resource_Locator) of a [bookmark](https://en.wikipedia.org/wiki/Internet_bookmark) in a [web browser](https://en.wikipedia.org/wiki/Web_browser) or as a [hyperlink](https://en.wikipedia.org/wiki/Hyperlink) on a [web page](https://en.wikipedia.org/wiki/Web_page). The term is a [portmanteau](https://en.wikipedia.org/wiki/Portmanteau) of the terms *bookmark* and *applet*, however, an [applet](https://en.wikipedia.org/wiki/Applet) is not to be confused with a bookmarklet, just as script written in [JavaScript](https://en.wikipedia.org/wiki/JavaScript) is not to be confused with a script written in [Java](https://en.wikipedia.org/wiki/Java_(programming_language\)). Whether bookmarklet [utilities](https://en.wikipedia.org/wiki/Utility_software) are stored as bookmarks or hyperlinks, they are designed to add [one-click functionality](https://en.wikipedia.org/wiki/Bookmarklet#Usage) to a browser or web page. When clicked, a bookmarklet performs some function, one of a wide variety such as a search query or data extraction. Bookmarklets are usually [JavaScript](https://en.wikipedia.org/wiki/JavaScript) [programs](https://en.wikipedia.org/wiki/Computer_program). &gt;For instance, clicking on a bookmarklet after a [selection](https://en.wikipedia.org/wiki/Selection_(user_interface\)), might allow the user to be presented with a [search engine results page](https://en.wikipedia.org/wiki/Search_engine_results_page) for the search term. &gt;==== &gt;[**Image**](https://i.imgur.com/qhZyT6Y.png) [^(i)](https://commons.wikimedia.org/wiki/File:Word_count_bookmarklet.png) - *Demonstration of a bookmarklet that counts the number of words on the page. The browser shown is Firefox 3.0 with generic "abrowser" branding on Ubuntu.* --- ^Interesting: [^Google ^Bookmarks](https://en.wikipedia.org/wiki/Google_Bookmarks) ^| [^WebCite](https://en.wikipedia.org/wiki/WebCite) ^| [^Bookmark ^\(World ^Wide ^Web)](https://en.wikipedia.org/wiki/Bookmark_\(World_Wide_Web\)) ^| [^Firebug ^\(software)](https://en.wikipedia.org/wiki/Firebug_\(software\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cma118h) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cma118h)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I was going to reply with this comment but clearly you're already aware. I totally could be a *technical developer* but I like to be lazy because I end up working with technology that becomes a mainstream standard (like github/digitalocean). I like things to be spelled out to me in simple and attractive terms. I love the idea of this service, but as it stands, it's not attractive to me. Please don't stop doing what you're doing. 
why the hell was this down voted?
Is it an option to talk to whoever has put you into a position that seems mind-numbingly stupid, and tell them this system is not the right one?
This has been done multiple times over the past couple of years, and is always met with denial. I work with 100+ people who do this all day long for not much more than minimum wage. 
I believe I have enough information to implement this solution now. Thanks.
I agree, I was actually looking for a single sentence that describes what reduce does. Not how it does that, how you should use it, why you should use it, or anything else.
The `reduce` method reduces the contents of this array to a single value. (This explanation isn't very helpful though.)
reduce is foldl a recursive implementation would be [a,b,c,...,z].reduce(f) = f([a,b,c,...,y].reduce(f), z) at a high level, reduce replaces commas in arrays with function calls, this could be your 1 sentence description. [a,b,c,d,...].reduce(f) = f(f(f(a,b),c),d) which for things like binary operators looks like a+b+c+d+...
If that would happen I would uninstall the browse and use it again, even at work
/* @final */
TypeScript is pretty good and easy to covert a codebase to of you currently use commonJS modules or something similar. It exists a while longer the Flow and AtScript so tooling support is better and the communitu large and active.
There are a million reasons that's pretty much a non-starter. For one thing, a browser implementer doesn't want to get mired down in worrying about a million different versions of a million different libraries, and having to figure out how to keep them all constantly updated, or deciding which ones get to be included and which ones don't. You'd have very little traction trying to get this adopted, as the browser's cache already fulfills this role in a much more general purpose and hands-off manner. But even if you did somehow manage to convince a browser implementer to follow along, you'd only be affecting a fraction of your overall traffic, which means this is just yet another permutation that you have to add to your testing matrix, and now you have to do twice the testing you were doing before. And it's practically begging for bugs, for example if someone edits the remotely hosted version of something but forgets to edit the fictional markup that tells the browser to use a known version of that thing, then now you have the page failing for some people and not others because they're using different code. You get 99% of the benefit of what you're suggesting without any of the myriad downsides by just using a public CDN. 
Seems kind of needlessly complex.
The goal is *not* to build on top of ES6. The goal is to build a cool new language that fixes the bad parts of JavaScript. The design decision behind `for in` and `for of` was: for apple in apples for property of file For what Spider gives over ES6, take a look at: http://spiderlang.org/#code-safety http://spiderlang.org/#functions-inheritance http://spiderlang.org/#operators-existential-operator http://spiderlang.org/#operators-null-coalescing-operator http://spiderlang.org/#operators-in-operator http://spiderlang.org/#operators-chained-comparisons http://spiderlang.org/#ranges http://spiderlang.org/#switch https://github.com/alongubkin/spider/issues/45 (proposal) https://github.com/alongubkin/spider/issues/46 (proposal)
I'm a fan of the pattern of assuming shared-nothing. For instance, if you take the common settings object pattern, where you'd use `$.extend` or `_.defaults` to copy the properties out, but not actually share the settings object, then you've gone halfway towards mutability not being a problem. The other half is having the object fed in to also not be shared. What I mean by this is the settings object itself should probably be a clone, just to be safe. Here's an example var settings = { magic_number: 27 }; var object_one = SomeClass.create(settings); // right here, settings could have been mutated. var object_two = SomeClass.create(Object.create(settings)); // kinda messy, but safe. var object_three = SomeClass.create({ magic_number: settings.magic_number }); // could get messy when there's more things to configure. 
This is unnecessarily complex. 1. There is no reason to use a callback here, all of this code is synchronous. 2. This limits the number of unique IDs to 1000, for seemingly no reason 3. Because you are using recursion, every time you generate a new number you increase the chance of blowing out the stack. And once you have generated 1000 IDs, you are guaranteed to! 4. This code is extremely dense and difficult to understand. This seems like it would be better implemented as an auto-incrementing integer. If what you *really* want is a generator for random unique numbers between 0 and 1000, this is much more simple and easy to read: [jsfiddle](http://jsfiddle.net/pes8xd7w/)
It's overwhelming, but it's not disturbing. The opposite is true. It means that developers are unhappy with JavaScript and they are trying to improve it. I don't see how this is bad.
What would be a practical use case for this?