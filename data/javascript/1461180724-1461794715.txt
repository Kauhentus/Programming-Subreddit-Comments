I didn't know NASA had an api. Definitely going to look into that.
Definitely mention apprenticeship projects. Source: former apprentice, now frontend developer.
In addition, the company can then train the junior dev to an intermediate level "their way" (ideally).
&gt; I would suggest, instead, linking to samples of your own code or projects you have built using these technologies. Yeah that sound a lot more reasonable. &gt; Keep anything else (the rationale for your applying) relatively brief. I'll definitely try that in my next application, thanks. 
I get your point. You're totally right. :)
hahah! I meant "flash" as in fancy animations. Sorry, English isn't my primary language.
This may be a trivial point, but you should always have someone check your grammar. While the company is based in Berlin, if your resume is going to be in English, your grammar and spelling should be perfect. You have "Shatner" commas all over the place that make the readability of your content difficult. I also agree with the comments above. When a company first encounters a candidate, you shouldn't expect them to spend more than about 20 seconds looking at something. So you need to wow them right away and then keep them interested. The images take away from *You*. You are the story, so make it about you, not the page. You could fit all of this content on 2 pages. It doesn't have to be static, but it also shouldn't take a hiring manager as much work as it does with your current site to know your story. That said, it's a cool concept, but needs editing, revision, and restraint. Those are things that senior devs have because of experience. Keep on going, just edit, edit, edit, and always ask for feedback. EDIT: I see that you have a German version as well - if I could read German, I'm sure it would be great grammar. Just work on your English if you're going to have it. :)
Thanks, this is really helps me. In my next application I'll definitely keep those two target audiences in mind. I understand them much better now. I'll focus on my biggest projects and the technologies and techniques i used in these. I really appreciate that you took the time to write this. Thanks a lot!
Done it.. check it out: https://github.com/mevdschee/w3component.js/blob/master/vanilla/w3component.js
jQuery UI sortable doesn't work because I didn't add support for window.getComputedStyle(lazyNode); but here's an accordion plugin example: http://jsbin.com/pezesu/edit?js,output
uBlock Origin has prevented the following page from loading: https://app.simpli.fi/login Because of the following filter ||simpli.fi^
Thanks, feels good to hear that. :)
Well, first off, some general pointers: * There is no need to write an Id that simply numbers each of your elements. For example, you can select your first &lt;div&gt; element by simply using div:first-of-type {} or div:nth-child(1) {}, etc. I recommend reading w3's selectors chapter here for some further examples http://www.w3schools.com/cssref/css_selectors.asp. Also, you can specify multiple properties by simply comma delimiting your stylesheet; e.g. div:nth-child(1), div:nth-child(2) { /* some CSS */}. * &lt;table&gt; elements are an old school methodology that really isn't used anymore in modern web-development. Read up on HTML5 and look into stripping CSS from your elements/etc. * Pick a different project to start with, the methodology you're electing to use here makes me think you have a lot more basics to get a grasp of before venturing in to attempting to design and develop this. Try something like creating a random number generator that displays the result in a mapped-color scheme based on a range input by a user - that will give you some more basic concepts to work from. * Put your scripts after your body (unless you're checking ready state/etc before executing your scripts). * Look into getting a good editor (like sublime text editor) and also read up on project management/structuring basics for programming. Mozilla has some good material to read over regarding learning HTML/JS: https://developer.mozilla.org/en-US/Learn/Getting_started_with_the_web/JavaScript_basics. Regarding your specific problems with recovering the last component, you're using 'appendChild', which is simply taking the item you dragged's data and adding it on to the data in the destination, which if you keep repeating essentially replicates itself exponentially. This, plus the fact your CSS is set to fixed widths, makes me think why you are unable to recover laid-over images and/or see the results accordingly. You need to develop a system that tracks a stack of objects (e.g. layers) and just pulls off each layer as you move it around, etc if you want to make 'stackable' images. Good luck!
Incognito doesn't know about last night.
Good point and no the app (at least originally) was not mobile friendly.
That's what you think! It's all too easy to fingerprint your browser, especially when you're moving the mouse with your offhand. 
Nice, thanks!
It's [Brian Lonsdorf](https://github.com/DrBoolean) he knows a [thing](https://github.com/MostlyAdequate/mostly-adequate-guide) or two. 
I'd love for MS to bring Clippy back with some AI. https://www.youtube.com/watch?v=dP98Pb50T-U
This is great, I am really considering using it :)
I use it to uglify and minimize but for example I had this issue, which prevent me for compiling the project so I had to use it as a loader instead of a plugin, and so on https://github.com/webpack/webpack/issues/1079 I think combining gulp/grunt with webpack is the best, but I don't have that much experience
I've been using hapi in my projects over the last year or so, and it's been a generally enjoyable experience so far. So +1 for looking into hapi as well
Evil idea, pair clippy.js with electron and make a multiplatform clippy I'm not sure microsoft's lawyers would be too happy about it though, unless you got some engineers to go along with the prank. (Microsoft, clippy for windows 10, do it for an april fools day prank)
Clippy the raging racist would be fun. 
Used by 100s of millions of people for more than a decade: we can all hope for that kind of "failure". https://en.m.wikipedia.org/wiki/Office_Assistant
That's MEAN
Yeah, I don't know what their definition of "failed" is.
Gulp vs Grunt vs Brunch vs....
vs NPM scripts
VS Code vs. Brackets vs. Atom vs. Sublime vs. Notepad++ vs. Vim vs. Emacs vs. Nano
&gt;And now any potential hires have to deal with your shitpool that is probably less reviewed, documented, and maintained over any popular framework Isn't that purely speculative?
With all due respect, you didn't really contribute anything to this discussion. 
sure, but you'd be extending the ast model so much that you'd basically be rewriting the entire module, at which point you're better off making your own stand-alone package though one has to ask why; the reason javascript has to be transpiled is because of legacy browsers being unable to run newer parts of the ecmascript spec. it's a very unique use-case that isn't found anywhere else in programming.
Thanks. After reading more of the Babel Plugin Handbook (https://github.com/thejameskyle/babel-handbook/blob/master/translations/en/plugin-handbook.md) I can see that much of it is very specific to Javascript). Transpilation on other platforms still seems useful to me. Any target platform where you would like to have expanded language features while maintaining backwards compatibility. For example, I am thinking about Solidity, the smart contract language for Ethereum. Solidity is very low-level. One might wish to code at a higher level, and transpiling into Solidity is easier than transpiling into assembly. 
IntelliJ master race here.
Try to find something you actually want to build, or a problem you want to solve. In my experience, the most common operations for a (front-end) javascript dev are to grab data from an API, manipulate it and display it in a way that makes sense, then let the user manipulate the data, and finally post it back to a server.
I used [PeerJS](http://peerjs.com/) for a closed source project(which I will open source soon) about scalable video streaming. I can say that this is a rock solid WebRTC library. The best part is their server which can be embedded in your Node.js app listening to any port. This saves a lot of work since all handshakes and all that stuff id done automatically. I would use it again for sure, but this time using an RPC layer.
Where is "deal" for Solitaire?
I've heard great things about Twilio: https://www.twilio.com/webrtc
well, at that point you're not transpiling, you're straight-up compiling. transpiling is shorthand for source-to-source compiling.
Yes, that's true but can you update that minified specific CSS. The benefit that you get including a library that you can modify it at runtime.
@grayrest pointed the solution below but I'll put a link to https://github.com/krasimir/react-cssx where this is implemented.
+1 for seeing the use case. CSSX could be use for shipping React components without linking external .css file.
We unfortunately have the same issue with JSX. You can't simply migrate to another framework and keep your templates. You have to extract them. The use case of CSSX is (a) if you have dynamic CSS styles that change to wide range of values and (b) if you have to ship a JavaScript component as a single file (and of course if you like placing your styles in JavaScript).
Not a joke at all :)
CSSX is working with plain CSS at the end so it definitely leads to cascading styles.
There's linqjs https://linqjs.codeplex.com Oddly enough it never really caught on. 
I feel like you're misunderstanding Redux, reducers are combined to create a Redux store. Your code outside of creating a Redux store should have no idea that reducers exist. Redux only tells you when the entire store's state has changed, if you want to react to a specific subset of state changes then that's outside of Redux's domain. You need to either write your own code or use a library like [reselect](https://github.com/reactjs/reselect).
Check this out too https://github.com/MicheleBertoli/css-in-js
You can destructure this as: const App = ({queryParams: {item1, item2}}, context) =&gt; { ... } But there is no way to do that without knowing the key of the inner object. Destructuring isn't magic.
Awesome! For sure, that's what I was stuck on was how to let it know which object you were looking for within the the props object. Thank you! Just curious if you know if this would also return queryParams as a whole, so you end up with all three being available in the body, or does it just drill down to the item1 and item2?
JavaScript won't be going away anytime soon, but in the future, it will become what PHP is today. An existing language that old technology is built with.
&gt; Code seems hipster and over engineered. That's what I was aiming for hahah. I wanted to show, that I could write properly designed JS code without needing a restrictive framework. But I guess it's the same as with the semicolons, I'll try to find out what tech and style their using at the firm I'll apply to next. I'm not quite sure yet though. Otherwise I'll just use React, god damn JSX and AirBnBs' style. &gt; That seems kinda like a tall glass to fill. I guess I'll need to put my ideologies on the back burner for my next application. Thanks :)
I shall put it on my blog too. This is too fucking awesome.
Thanks :)
should have paid attention in class
I believe that you do need to refer to the button's name somehow, and also the names for the checkboxes and the fields to be modified; also, I believe (from guessing at it while helping someone else here about six weeks ago) that if you retrieve a value from a text box, it will be a string, even if you had set the value to a non-string. Also, a while ago, I dug up the basic documentation for JS in Acrobat for every version from DC back to 6; if you don't have it yet, download and read it: https://www.reddit.com/r/javascript/comments/4dj82h/using_javascript_to_create_automations_in_adobe/d1rhepu I don't have Acrobat myself, so I've been grasping at straws here; I've never needed to add scripts to a PDF, and I've rarely even *seen* PDFs with scripts in them.
Is this server, and it's backend, your? Have you written any code on a backend side? What kind of service do you use. There are two cases: 1) If it's yours server: just write the code that will get the request, process received data (like writing to the database) and according to situation response properly. 2) If you use some external API to communicate with server, check if there is any method to download data from database. You should propably do it also with using AJAX request.
I believe "superagent" refers to this library: https://github.com/visionmedia/superagent
If we could only make a time machine, and turn this concept into a VBScript transpiler for different versions of the One True Browser&amp;trade;, the world would be a ~~better~~ worse place. I guess if Dart ever catches on as a language that isn't just compiled to JS, we'll end up with a need for a Dart transpiler.
Runnable example: https://jsfiddle.net/j69wrp65/ (works in Chrome 50 beta) If you need access to the entire queryParams object this way doesn't work, as you can see. There is a proposal out there to allow const App = ({queryParams: {item1, item2, ...otherItems}}) =&gt; {...} so then `otherItems` would contain all the fields of `queryParams` (except `item1` and `item2`, but you already have those). But I don't believe that is in the official spec.
I recommend you checking out Douglas Crockford's books and videos. This man is a genius :)
Babel's just a set of tools, but babylon (code-&gt;ast) and babel-generate (ast-&gt;code) only understand JavaScript. In theory, you'd be able to write your own parser and generator which understood compatible ASTs for another language, then you could use babel-traverse to actually apply the modifications. However, by the time you've got to that point, you might as well just have written your own traversal package too.
What is more performant? Loops or Folds?
I would get heart palpitations if I saw Bonzi unexpectedly.
&gt; attach and detach classes at runtime That's the thing. You have to have classes defined for every state of your UI. If it's a dynamically generated CSS you may avoid having state related classes and only keep the basic styling static. In some applications you need to move elements or apply user selected colors. In those cases the CSS values could vary a lot.
[Nodent](https://github.com/MatAtBread/nodent) brings async/await and doesn't have a dependency on Babel (unless you want to use it as a plugin), so there are avenues other than Babel.
&gt; Based on what you watched the previous 4 sessions earlier today, why not try . . . FTFY. Added comma before "why".
I see it's stage 3. Sounds good but I see from the comments in this thread it's not enough. Is it common for stage 3 proposals to get dropped?
If you mean that purple gorilla, it's already included as one of the 10 agents in the library.
vs. cat + needle + steady hand.
We use it in production currently. In a library that relies on async incoming packets through websockets that need to be dealt with in order to request further packets building on the prior, etc. Promise chains and Generator boilerplate have made it a pain to use and above all read and understand. Async/await is comically simple to construct and was a perfect fit. If they drop it, which would be terrible, but nonetheless if they do, going back to generators will cost a day or two but it won't be impossible. And then there are things like Nodent and Kneden, though we haven't tried yet, but i'm sure many other solutions will sping up to transform code into Promise chains. If Babel throws it out tomorrow, it will crash at the compile stage: solutions will be found, customers are unaffected.
Might still be a non-issue but I would suggest filing this on the webpack repo if it only happened after the upgrade
&gt;The proposal for Object.observe (O.o in short) was dropped in the past. Not only was it dropped, but if I remember correctly it was dropped extremely late in the process?
That's not true is it? I thought only item1 and item2 will be available. When I've needed the entire queryParams object I've been destructuring inside the function: const App = (queryParams, context) =&gt; { const {item1, item2} = queryParams; } 
More like highly probable. Consider the level of effort going into something like angular - it needs lots of documentation, testing, and support. Think of any corporate business (or medium sized team). I've never been in one where the priority was to spend a lot of time doing things well, because that isn't what pays the bills. All of those things I mentioned above, 99% of the time, very pushed off or simply never happen. Even if it is all of those things above, it's still not a popular framework that anyone could have any experience with if they didn't work at this company, which is bad because you will always have to train people to use it. 
Replace "eval" with "source-map", I had the same problem, with 1.12.x though. Don't know if it'll help with 2.x
How about ImmutableJS List? It has a fluent interface and you can call toJS() at the end of the chain to turn it into a native JS array. http://facebook.github.io/immutable-js/docs/#/List 
Peerjs is fantastic and the best API but its not supported anymore and firefox as a bug. I made a fork to fix this specific bug only but i would not say its the most reliable API. 
This would be the normal inline styling. No pseudo selectors, no media queries, and no cascade selectors. I was talking about dynamic local CSS within the component, controlled from JS.
Which is absolutely correct in this case.
Thanks for the kind feedback! I'd love to see that ad once it's complete. Feel free to email me morgan@polarnotion.com 
Ah good call - looks like it would work
[ES2016 was already released](http://www.2ality.com/2016/01/ecmascript-2016.html)
Seems there are use-cases for something similar with Java ([example](https://github.com/orfjackal/retrolambda)) when you're stuck with an old JVM.
It doesn't handle the alarm clock either
Careful! A couple of years ago we had a security audit run on some apps I had developed over a decade ago and they flagged some "suspicious" code... turns out, I had put some (completely innocuous) Easter eggs in these apps... apps I hadn't thought about for years and Easter eggs I barely even remembered. Well, let me just say it's no fun having to explain that to senior management and have to do "emergency" elevations to "correct". I could argue that my company over-reacted, and I definitely think it's only because of my tenure that I was spared the axe because we take "security" VERY seriously and most others probably would have been fired, but that's ultimately up to the company, both the mindset and the firing. I just know I don't ever want to be in that situation again so, fun though it is and as much as I personally love Easter eggs, I'll never put one in an app again. Not worth the potential hassle.
But would that be able to handle what OP is trying to do? IE hiding multiple boxes and then loading that large content area? The target selector is just for a single element isn't it? By handle I mean without having a script to add and remove the classes. 
Hello, Redditors! -- Disclaimer: If you suffer from JS framework fatigue, HALT IMMEDIATELY and learn React, Angular or Vue. By reading further you waive your right to complain. -- domvm exists because (and may appeal to you if, like me): - You care about payload size, performance and try to avoid kitchen-sink frameworks. - You like JSONML (or Hyperscript) syntax for HTML construction or have used and liked Mithril or domchanger (both were inspirations). - You want to write plain Javascript and CSS rather than framework-specific, stringy template DSLs that must be compiled. - You don't like auto-magic behavior and prefer to write straight-forward, obvious code rather than fighting your framework or poring over docs. - You prefer client-side frameworks that are usable without huge dependencies: Node, NPM, Babel, Gulp, Webpack/Browserify/Bower/SystemJS and dozens of micro libs. -- domvm's distinguishing feature is its uniform composition for both declarative and imperative views. I'll leave the other selling points to the repo's README. Documentation is sufficent to get you pretty far, but is WIP. Numerous not-yet-documented features can be found in TODO issue #36, some are used in the demos. -- Repo/Docs: https://github.com/leeoniya/domvm Perf: http://leeoniya.github.io/domvm/test/bench/dbmonster/ Demos: https://github.com/leeoniya/domvm#demos -- Q: Why *another* framework? A: Because no others afforded me all of: size, performance, terse syntax and flexibility to structure code how *I* wanted, plus a healthy dose of NIH Syndrome. Q: Is it production ready? A: Yes, it's suitable for writing both complex SPAs and/or simple in-page widgets. Q: Test coverage? A: Currently the tests extensively cover the `view` core and `html` modules, but not `watch` and `route` - these are tested manually via the demos (for now). Q: Browser support? A: IE9+ with 9.4k of shims (in repo). Q: Node? A: Yep, for isomorphism/SSR/pre-render.
Thanks, if you prefer hyperscript, here's a wrapper for you ;) ``` function h() { return Array.prototype.slice.call(arguments); } ``` More seriously though, JSONML's tersness, ability to be easily manipulated by middlware and serialized via json from server -&gt; client was a good perk to prefer it over hyperscript that generates heavier (and more proprietary) vnodes directly.
Please please please deliver bob.js
Isn't babel used for typescript and flow type as well? 
Sorry, will publish the source soon. 
It's only "potential" or "future" as a standard, but it can be used today. Just like Typescript will likely never become part of the standard, that doesn't mean it shouldn't be used.
On my Firefox browser, the address in the URL bar changes before the content is updated, doing such transition requires some JavaScript, at least to observe the animation and trigger the address change when it is complete. 
Nice, concise article. However, it looks like the last code sample is improperly formatted.
Any plans to offer JSX support via a function compatible with Babel's `pragma` config for dev/a plugin which transforms JSX to JSONML for production? I moved away from JSONML-style/hyperscript function construction because it became painful to write and maintain. I ended up creating MSX for Mithril solely because it was just too painful to go back when I was trying Mithril out.
Thanks! I'll fix this.
they will always come last (likely) so you can try Object.keys(test).slice(test.length) it's fragile though
This looks promising, but what would cause them not to come last?
&gt; I suppose I could use var i in test and remove the numbers That'd be the way to go. Make sure you test for positive integers up to 4294967294 only. Anything else would not be an array index. The alternative would be to separate your data (as /u/docMedB2E suggested)
Well if it has to stay in that format, then you can just check if it is actually a property (as opposed to the value of the object itself) &amp; then just test if the property can be converted to a number. This site explains how to return only properties of an object: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty
If the array is sparce, `length` will take off too many keys.
`Object.keys(test).filter(isNaN)` seems to work. In my case I think I can assume that there won't be any legit keys of 4294967294+
This happens all the time with sourcemapping, because the code you're seeing in the debugger is not the actual code being run and the lines don't necessarily correspond 1:1. In my anecdotal observation, it started occurring a lot more after Babel v6. If you want to avoid it, open up the dev tools settings and uncheck "Enable JavaScript source maps."
Thanks for the article, it was an interesting read
Excellent!
I just read the myPeeps example, and a question arose: Why not pass myPeeps when you mount, and then again pass the modified myPeeps when you redraw?
I believe originally the spec never specified an order for iteration like this so it was considered "arbitrary", though most browsers seemed to have stuck to creation order. If you look at ActionScript, for example, it had a specific order that was consistent given whatever heuristic they used (I think creation), but eventually had to change it to something more random to help mitigate a security concern. Now each iteration can be different even if the object in question was never mutated between (or within) iterations. With JS and with Object.keys, I think the order is now well defined in the spec (about to look it up, will link): http://www.ecma-international.org/ecma-262/6.0/#sec-object.keys using http://www.ecma-international.org/ecma-262/6.0/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys This includes specifying array indices first followed by other keys. The order of those are ascending for array indices and creation for other object keys.
How many startups have you never heard about? That's failure. Making fun of Microsoft's failure is like saying someone who's perfectly healthy sneezed.
you can do this if you opt the view into a non-persistent model (via a `false` key/handle), which makes it externally replaceable. var vm = domvm.view(PeopleView, myPeeps, false); vm.mount(document.body); vm.update(myPeeps); you can also initialize the view without any model, and update it later: https://jsfiddle.net/oom2ecLq/1/ function MyView() { return function(vm, model) { return ["div", model ? model.text : "No model..."]; } } var vm = domvm.view(MyView).mount(document.body); vm.update({text: "Model text!"});
The oStudent variable is returning whatever is pulled from the function, which again appears to be an array - it is no longer technically 'JSON' (remember, JSON is just a string formatted in a common/universal pattern, which is typically used to create objects that have properties/relate-able data). At the point oStudent is set to the return value of the function, that now is technically an object. In JavaScript, arrays can store all types of values/objects/etc in them, so for your second question - yes you could technically wrap an array around all your objects if you wanted like your above example and then just access each object via student[someIndex]. Really though, if you're going to query a batch of users, then realistically you should be going back to the original query and getting all the data you need in one swoop. If you're attempting to use this method multiple times in a row, then there is no reason to repeatedly query the server for pieces of data; it's better to derive a method that returns all the data you need in one swoop and then sort it.
for flow type, yes. typescript, no; if you're using typescript you're using their compiler (though you can output to es6 then feed it through babel if you need to).
Full stack JS you say? You could build an online application with the MEAN stack simulating a music network where you have 2 kinds of users - listeners and bands. The users could listen/comment/buy songs and albums. The bands could create a profile, upload their songs and sell albums or/and songs. They could have a backoffice to select some albums for sale with discount. The front page of your application could show the most listened music with some filters (daily, weekly, monthly) and display the albums for sale with discount and other stuff you will think when you start building it.
Great stuff, thanks!
fyi, you must have a fast machine, my best time was 80ms... what are the specs? from my 1.8ghz lenovo quad core (not much use without threads I recon) g50-45, chrome 50, ubuntu 14.4, 16g ram. console.time("tst1"); var c = document.createDocumentFragment(); for (var i=0; i&lt;10000; i++) { var e = document.createElement("div"); e.className = "test-div"; c.appendChild(e); } document.body.appendChild(c); console.timeEnd("tst1"); --&gt;80ms console.time("tst2"); var a = []; for (var i=0; i&lt;10000; i++) { a.push("&lt;div class=\"test-div\"&gt;&lt;/div&gt;"); } document.body.innerHTML = a.join(""); console.timeEnd("tst2"); --&gt;150ms console.time("tst3"); for (var i=0; i&lt;10000; i++) { $("BODY").append($("&lt;div /&gt;").addClass("test-div")); } console.timeEnd("tst3"); --&gt;4780ms
yeah pretty much. like others have said, people don't have that much time. you skim through for red flags or things you expect and create a short list. only before an interview you may spend more time googling somebody and looking at their work. for the record it is because I know all the packages you used and you didn't say this was for things other than your cv... by offering something concrete, minimal, elegant and unambiguous you offer less rope to be hang you with. 
I see, I'll have to investigate what that all means in practice, but it seems promising. Thank you for the detailed explanation.
I attended Hack Reactor ~2 years ago. I become interested in coding while working in accounting/finance and decided to take one of the online CS courses offered through Stanford. After that, I played around with Ruby and Python, but didn't start learning JS until I decided to apply to Hack Reactor. I was a little worried about how I would handle the schedule and the long days, but it ended up being, well, kind of a breeze. Not that it wasn't difficult, or that I didn't have some really frustrating days, or that I wasn't pretty much always tired, but I never felt like I was getting burnt out. I woke up every morning looking forward to the day ahead, and the days went by unbelievably fast. I learned more in 3 months than I would have in 18 months of studying on my own. IMO, the job search is the most difficult, grueling, and stressful part of the program. It also didn't help that I was plagued by imposter syndrome and was struggling to come across well in interviews. But, I landed a contract gig ~3 months after graduating and have since moved on to a mid-level engineering role where I'm really happy. 
I never understood the reasoning behind dropping the syntactic sugar for awaiting an array of promises. It was super handy.
thanks for the rave reviews :) and also thanks for helping polish the final API and reporting lib ergonomics issues and bugs.
I haven't had to add 10k, but I'm working on something right now where I'll potentially be adding 1500+ with many other things happening on the page so performance is a concern.
I found a very _HACKY_ way to do this, and I know there's a simplier way to do this, but I don't know the method. Anyways, here's my current soulution: https://gyazo.com/4387eefb230ceda3fed191e724d45f5d I wont call this a solved case, hit me up if you have something better, peace.
If you need to support IE9, you still want the .addClass/removeClass functionality, and if you want to support any IE, you might also like the .toggleClass functionality. Same for dataset. Also, you might still prefer the abstraction that $.AJAX provides, unless you're directly using something like SuperAgent. Also, the event delegation pattern is useful for dynamically added content. 
Appearantly this does NOT work.. I can just do "&lt;br&gt;".. Fock sake
Ah ok, so you already handle the tons of browser incompatibilities there are with IE7-9, which people still, against all odds, still use. Cool. you're the best.
I stopped supporting IE7-9 when Microsoft did.
Since javascript still runs on the UI thread, which is stupid to begin with, performance is always a concern IMO
Yeah, okay. I could see that being a good use case. 
Yes, that's true, but those sorts of frameworks aren't always a good option. 
Too bad they did it purely to try and drive people to by their new OS, rather than because their OS and its terrible locked-in browsers were actually out of common use.
if statements are fine, but try to eliminate using else. Most of the time i find you can reverse your conditional it can help.
That's precisely when you *need* jQuery. A random wordpress site that spits out the html doesn't justify any complex libraries, but it still might use a mobile menu, some sliders, lightboxes, stuff like that. Just random minor scripts. And those are more convenient to do with jQuery. I mean I do agree that you can accomplish everything without jQuery nowadays, and I wouldn't consider it unreasonable to just make a little helper file that polyfills stuff like toggleClass, but at the same time for a lot of people it's gonna be more convenient to just link up jQuery and use that. 
&gt;ran from page source I'm not sure what that means. Can you explain a bit more? fwiw when I load this file with dev console closed it is still ~80ms, firefox ~100ms &lt;html&gt; &lt;head&gt; &lt;script&gt; window.onload=function(){ var t=Date.now(); var c = document.createDocumentFragment(); for (var i=0; i&lt;10000; i++) { var e = document.createElement("div"); e.className = "test-div"; c.appendChild(e); } document.body.appendChild(c); t=Date.now()-t; document.getElementById("out").innerHTML=t; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="out"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;
Yes, i considered many and each lacked some important part that by its nature must by integrated into the diffing/patching process. One of these things is lifecycle hooks (i dont think incremental-dom has these), or in-place redraw and state retention. Some were too slow, others too cumbersome to use or too large and had too many features. At the time i evaluated citojs (fast but lacked hooks i think and is largely unmaintained), snabbdom (nice but slower than domvm), kivi (very fast but requires tooling and is very verbose to write), Inferno (fast but couldn't support numerous use cases elegantly), virtual-dom (huge and not very fast). basically i needed control over my own destiny instead of adapting to or hacking around other libs. i did not really plan to create my own diffing lib from the outset, let's put it that way. -- &gt; it seems like incremental-dom is the only lib that really sticks to rendering and leaves the rest to me. -- you haven't been looking hard enough ;) -- http://mathieuancelin.github.io/js-repaint-perfs/ -- domvm does not aim to be a raw vdom patching lib, there are plenty of those. it aims to provide a minimal set of the "the rest" that is common to build as the next layer on top of raw vdom to make it pleasant to use in real apps, similar to Mithril.
Also that most performance issues in web apps (that actually affect user experience) usually come from more macro/architectural issues around event binding and asset loading than from micro code level decisions. Maybe you are talking about the Node side but still, if your bottleneck is coming from one of these observations, maybe you should be using a compiled language on the server anyway. This stuff is nice to know but I'd love to see benchmarks that show these optimizations making a difference in an actual codebase. 
I know some people treat _abstraction_ like a dirty word, but an over-reliance on conditionals is a code smell to me that a higher-level abstraction may be needed. In classical OOP systems, it's [often suggested that most (if not all) conditionals should be abstracted out into their own classes](https://sourcemaking.com/refactoring/replace-conditional-with-polymorphism), but an over-adherence to such advice often creates new problems that may be worse than your original problem. Quick example of how you might leverage an abstraction here: if you have a lot of `if (isWindows) { ... }` in your code, then you may consider creating a specialized object specifically for the 'windows' code. You can re-use code either by standard prototypal inheritance, or horizontally via mixins, but the idea is that you abstract that conditional out into a parent code path such that the `if (isWindows)` condition is only required once. Brief example of how a parent code path might handle this (prime example of the _Factory_ pattern): function getAdapter(isWindows) { let client; if (isWindows) { client = new WindowsClient(); } else { client = new Client(); } return client; } Here, `Client` would be the standard code, and `WindowsClient` should ideally only contain the code that's different than the `Client` code. More info: * [SO: If-less programming (basically without conditionals)](http://stackoverflow.com/questions/7264145/if-less-programming-basically-without-conditionals) * [SO: avoiding if statements](http://stackoverflow.com/questions/1337565/avoiding-if-statements) With that said, you may want to pause and think what the complexity analysis is actually trying to tell you, instead of just trying to think of a way to shape your code in a way to make it happy -- in a nutshell, your code is too complex. Following paradigms like SOLID, the Single Responsibility Principle, etc. will likely lead you to the conclusion that your methods aren't just doing one thing (despite what you name them). And despite what your gut tells you, your code will probably be better off broken into smaller, more meaningful methods as opposed to large, monolithic methods.
You will probably want to repost it, since this one is almost a day old it will probably not even be on the frontpage.
You don't want a class that does too much. If your class is getting too large, you might want to break it up. If you can't separate state, or have independent state in those pieces, then you can give them a reference back into the owner object and have them access state there. This is effectively you're #1. The overhead of this in your code isn't that much more than what you're doing now. You just need to save off that reference and define methods that access data through that reference. function Obj() { this.box = "foo"; this.drag = new ObjDrag(this); } Obj.prototype.start = function() {}; function ObjDrag(obj) { this.obj = obj; } ObjDrag.prototype.start = function() { console.log(this.obj.box); //-&gt; foo }; 
Async/await also allows you to use normal try/catch blocks to catch async errors, thus making the language more consistent in those cases. To me that validates its existence. If that wasn't true I wouldn't particularly support its use. 
I see a number of problems with your reply... First of all, *myObjectClass* is not a constructor therefore you can't use *new* command with it. Second of all, if it was a constructor, then I still don't understand how you'd access *box* property from within *drag.start()* function because *this* in that function would refer to *drag* object and not to the root object that has the *box* property.
I just tweaked the code above to show how you could make it a constructor should you choose. You can reference each property from any portion of the scope by simply traversing the parent (e.g. myObjectClass.start() can be executed within the drag.start() function and likewise myObjectClass.foo). Either way, all this comes down to simply how you want to manage your app, which is dependent on the scope of your project and (at large scale) performance preferences.
&gt; If you can eliminate the step of generating the string (eg. generate it server-side) Sorry, no. Generating 10000 div elements "server side" and transferring them to the browser to then append them to the DOM is *never* going to be faster than generating the DOM elements in the browser.
&gt; I am not a CSS3 expert Clearly.
Yea, sorry - I put it into code and actually tested it this time. You're right, you have to do something like this (basically just adding a reference to it globally): $(document).ready(function() { var myObjectClass = function() { var _this = this; this.box = 'foo'; this.start = function() { console.log('start functionA'); }; this.drag = { start: function() { console.log(_this.box); } } } var test = new myObjectClass(); test.drag.start(); });
Here's how I usually generally structure an APP. I don't write classes too often that need access to the parent, so I think that's where I've been getting hung up on my suggestions for ya: $(document).ready(function() { var APP = { DUMMY_PARSED_JSON_DATA: { team: [ {name: 'nick', age: 28, reports_due: 20, manager: 'jake'}, {name: 'mike', age: 25, reports_due: 15, manager: 'dan'} ] }, init: function() { // usually add listeners and/or checks here that eventually trigger the app to run APP.run(); }, run: function() { console.log('the app ran &amp; received some JSON data:'); console.log(APP.DUMMY_PARSED_JSON_DATA); } }; APP.init(); });
Here I was thinking there might be something faster than Document Fragments... Lol
eck, yeah, you don't want to be trying to attempt to grab an instance by name from window. Well, if you really want something that will be easy with which to muck around and change up and do whirly-woos with, you can do something like this: function Obj() { this.box = "foo"; instancifyNamespaces(this); } Obj.prototype.drag = { start: function() { console.log('drag.start', this.box); }, deeper: { stop: function() { console.log('drag.deeper.stop', this.box); } } }; Obj.prototype.start = function() { console.log('start', this.box); }; // the magical helper function of magic that makes magic happen magically function instancifyNamespaces(inst, defs, ns) { if (!defs) { defs = Object.getPrototypeOf(inst); } for (var prop in defs) { var def = defs[prop]; if (typeof def !== 'function') { var namespace = Object.create(inst); inst[prop] = namespace; instancifyNamespaces(inst, def, namespace); } else if (ns) { ns[prop] = def; } } } var someObj = new Obj(); someObj.start(); //-&gt; start foo someObj.drag.start(); //-&gt; drag.start foo someObj.drag.deeper.stop(); //-&gt; drag.deeper.stop foo someObj.drag.deeper.start(); //-&gt; start foo someObj.stop(); //-&gt; TypeError: someObj.stop is not a function This `instancifyNamespaces` function is called once in the constructor and takes any objects in the prototype and converts it into a namespace. It also takes objects in that namespace and makes it into _another_ namespace (see `deeper`). Each namespace is uniquely tailored to the constructed instance allowing `this` in the namespace methods to continue to reference the instance itself. This way you can move things around and this is always the same without any additional rejiggering. Its unconventional, but it seems like its doing what you're looking for ;) Note that because the namespaces have a this referencing the instance, they inherit all the instance methods (see `start`), but the instance does not get the namespace methods (see final `stop`)
Is there a demo?
The only advantages really for prototype definitions is just to globally update all classes, which still can definitely be done. Also, it's only 'bad' if you're calling the prototype definitions repeatedly, which doesn't really make any sense to do, e.g. I would only change/update the prototype when necessary based on some top-down state logic: $(document).ready(function() { var APP = { DUMMY_PARSED_JSON_DATA: { team: [ {name: 'nick', age: 28, reports_due: 20, manager: 'jake'}, {name: 'mike', age: 25, reports_due: 15, manager: 'dan'} ] }, init: function() { // usually add listeners and/or additional setup checks here/etc that eventually trigger the app to run APP.run(); }, run: function() { console.log('the app ran &amp; received JSON data: ' + APP.DUMMY_PARSED_JSON_DATA); var testClass1 = new aClass(); // this will add function 2 to any created class aClass.prototype.function2 = function() { return 'function2'; } var testClass2 = new aClass(); // this will only add function 3 to the specific class itself; e.g. if you tried testClass1.function3() you'd encounter an error testClass2.function3 = function() { return 'function3'; } console.log(testClass1.function1()); // available to both via general class definition console.log(testClass1.function2()); // available to both via prototype console.log(testClass2.function2()); // available to both via prototype console.log(testClass2.function3()); // only available to testClass2 } }; var aClass = function() { this.function1 = function() { return 'function1'; } } APP.init(); });
Another generators article that completely skips over iteration.
Thanks you've been most helpful. The documentation is fantastic. thank you!
Here's a good read for you on the topic http://stackoverflow.com/questions/4508313/advantages-of-using-prototype-vs-defining-methods-straight-in-the-constructor. Basically, it just comes down to performance like I was mentioning before (although definite methods directly in the constructor does allow for local access to data easily), but unless you're doing some rather large calcs/processes, it doesn't really matter. Good luck!
Downvoted for click-bait, misleading title.
Your users will never know the cyclomatic complexity of your software, so as long as your code is readable, testable, and doesn't have unacceptably poor performance, I don't think you should bother worrying about it. And without seeing the code it's not easy to give a straight answer.
That would be good :)
Unless you are implementing an algorithm from a book that uses LinkedList, there is no point in using a LinkedList in JavaScript. Given people have a hard time [justify using LinkedList in C++](https://www.youtube.com/watch?v=YQs6IC-vgmo), there's almost no reason in using it in JavaScript. By the time where a LinkedList can outperform Array, you should probably think of other things, like: * could I use a B-tree, et al. which attempt to preserve contiguous memory? * could split the data between immutable and mutable to help GC? * could I just dump this into a database and do a query? * could I write it in C++, so I can do use `mallac` and `structs`? 
How so?
I have never worked with node or react, but your app idea sounds and it could be cool you could even at a later iteration make it such as it recommends movies for you. 
&gt; ran from page source Assuming he meant that the javascript was in the HTML document when it was loaded as opposed to dumping it into the Chrome devtools console which may add some overhead.
Real programmers use Butterflies
Not accurate. For it to be truly accurate, the red cap would be on the cup for the blue Play-Doh, and the white red and yellow Play-Doh would be mixed together using a blender. And the logo would just be *Doh*.
To add on what /u/leptons said, even if you really needed server data for those 10,000 divs, remember that a JSON payload is a lot lighter than formatted HTML code. If you're sending 10,000 pre-generated DIVs from the server, you also need attributes like classes and IDs and other attributes what you see fit. Even sending HTML without attributes would be heavier than a simple JSON payload.
X-Post referenced from /r/aureliajs by /u/Davismj [Run GitHub Gists inline with the GistRun Chrome Extension](https://www.reddit.com/r/aureliajs/comments/4fwa9d/run_github_gists_inline_with_the_gistrun_chrome/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^my ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
I would definitely recommend this book. It's probably my favorite JavaScript book. But I would wait for the Second edition to come out soon.
#1. [Use early returns / guard clauses](http://programmers.stackexchange.com/questions/18454/should-i-return-from-a-function-early-or-use-an-if-statement) #2. Name your conditionals if (response.data.length &gt; 0 &amp;&amp; account.status == 'ACTIVE') { ... } becomes var responseHasItems = response.data.length &gt; 1; var accountIsActive = account.status == 'ACTIVE'; if (responseHasItems &amp;&amp; accountIsActive) { ... } It's more lines of code, but it usually helps communicate intent behind the condition, which is better than using a comment. Even though this doesn't change cyclomatic complexity, it will still help a human being understand the intent. #3. Use fallbacks / defaults using `||`. Instead of function setErrorMessage(message, response) { if (!message) { message = response.error.customMessage; } if (!message) { message = 'Something went wrong'; } } Do var errorMessage = message || response.error.customMessage || "Something went wrong"; #4. Provide consistent data structures where possible Related to the above, if you were giving that function a response that may or may not have an `error` property, you'd have to do a property existence check. Same is true of `customMessage`, or you'd have to use something like `_.get()` from Lodash. Instead, always try to keep data structure consistent even if many of its values are null. This way you can reliably query that structure without having to worry about checking if its valid first. But for any data structures you don't control, you want to be paranoid and check them. #5. Normalize your data before giving it to a function This is similar to #3 and #5. The below code is problematic because now whatever consumes those reports has to do conversion. See the problem illustrated below. var temperatureReports = [ { city: "Boston", temperature: 84, unit: "F" }, { city: "London", temperature: 24, unit: "C", } ]; function averageTemperature(temperatureReports) { var sum = temperatureReports.reduce(function(previous, current) { var temp = current.temperature; if (current.unit == "C") { temp = // convert to F } return previous + temp; }, 0); return sum / temperatureReports.length; } Instead of doing the conversion inside of the function, requiring the conditional, normalize the report list to be all one unit type. This may still mean using a conditional somewhere else, but it keeps it out of a function whose job it is to merely get the average temperature, not also do conversions. E.g: var temperatureReports = [ { city: "Boston", temperature: 84, unit: "F" }, { city: "London", temperature: 75, unit: "F", } ]; function averageTemperature(temperatureReports) { var sum = temperatureReports.reduce(function(previous, current) { return previous + current.temperature; }, 0); return sum / temperatureReports.length; } #6. Alternative to #5, use value object encapsulation: var temperatureReports = [ { city: "Boston", temperature: new Temperature(84, "F") }, { city: "London", temperature: new Temperature(24, "C") } ]; function averageTemperature(temperatureReports) { var sum = temperatureReports.reduce(function(previous, current) { return previous + current.temperature.toFahrenheit(); // conditional + conversion lives in this method. }, 0); return sum / temperatureReports.length; } #7. Or get really fancy and use polymorphism var temperatureReports = [ { city: "Boston", temperature: new Fahrenheit(84) }, { city: "London", temperature: new Celsius(24) } ]; function averageTemperature(temperatureReports) { var sum = temperatureReports.reduce(function(previous, current) { return previous + current.temperature.toFahrenheit(); }, 0); return sum / temperatureReports.length; } Where each of those temperature objects implements a `toFahrenheit()` method. The `Fahrenheit` object just returns its value. The `Celsius` object does the conversion. No conditionals are needed. Be warned though. Polymorphism in JavaScript is not quite as good/clear as it is in other languages with proper interfaces.
JavaScript is probably one of the most frustrating dynamic languages I've learned. But once I got settled with a tiny build configuration and flipped the bird to the notion of using more than a handful of libraries, it's really not bad! Python is probably the easiest language I've learned and it's strongly typed. Maybe they meant static type languages? 
I really don't mind be talked to like I am a newb provided the substance is valid, like yours is (and I didn't take it that way). I would rather be treated like a newb and have my question answered than continue to ponder in ignorance. Thanks for the time and effort here.
they have a decent polyfill for fetch
There are always edge cases. If you know the audience for your application is running on legacy systems, that's obviously a different story. If you're developing for the general public though, I don't think it makes sense to make architecture decisions based on &lt; 5% of the market share (most of which are work machines like the ones you mentioned).
Where is `package.json`? This could be that your paths are incorrect here. When you run an npm script with `package.json`, the `__dirname` variable will be the directory where that `package.json` is. Therefore `path.join(__dirname, '../src')` will be one level above your `package.json`. Try removing that `..`
I thought about this as well (at least I thought so?), originally had tried './src', assuming the ./ would leave me in the working directory where npm was run from. in any case, my code is on [github](https://github.com/Travmatth/sensible-react-starter/tree/build-crash) on the build-crash branch if anyone would be so kind as to take a look
oh didnt realize they show u how to test too, when I came across that I thought it was just a basic redux introduction. Thanks!!
This is perfect!! thanks, now I have a proper starting point, this will keep me busy for a while. btw you and a lot of ppl in that react link r mentioning mocha and chai. Are those also good for other frameworks? or do u usually use them for react only
If you're coming from a different language, the idea of "references" or "passing by reference" in javascript may be confusing you. Javascript doesn't have variable references - not in the sense that changing the value of a variable can change the value of another variable. Any any time you're doing `&lt;variable identifier&gt; = &lt;anything&gt;`, you are changing the value of that variable, and only that variable. There's nothing like var a = 1 var b = &amp;a; b = 2; // a now = 2! ... NOPE, not here Same applies to functions. For your function d(a){ a = 'bar'; } `a` is a variable that initially has the value of `42` - a value given to it because its the value of `f` that was passed in. `a` has no connection with `f` at this point other than it points to the same value that `f` had when it was passed in. The value is simply copied over. Once you assign `a` to the value `'bar'`, the value of `42` is forgotten by `a` and `a` now captures the value of `'bar'`. `f`, as was the case when we got to the function body, is unaffected. Its not much different than if you were to do the same thing out of the function: var f = 42; var a; a = f; a = 'bar'; Assigning `a` to `f` just means `a` points to the same value as `f`. Assigning `a` to `'bar'` means now `a` points to the value of `'bar'` rather than whatever value it had before. The variables themselves have no connection with each other. Its more like pointers. Pointer values are addresses in memory. When you dereference them, they give you the value to which they point. If you assign one variable to another variable, you're assigning the address from one to the other. When you access the variable for its value, you're getting its dereferenced value (a number or string, or object, etc). One variable having the same address of another variable does not mean changing its value to a different address also changes the other variable's address. _But_ once you dereference a variable to get its value - the value of an object - and you change something in that object, another variable with the same address will derference to that object value and see that change. The variables themselves did not change. What changed was the value of the thing they both point to. var a = {one:1}; // a is the address of the object {one:1} var b = {two: 2}; // b is the address of the object {two: 2} a = b; // a is assigned the value of b, which is the address of {two: 2} a = {three:3}; // a is assigned the address of the object {three:3}, b is still the address of {two: 2} a = b; // a is back to {two: 2} b.two = 22; a.two; //-&gt; 22 // a didn't change, the object it pointed to did. a (and b) are still the address of {two: 2}, err now {two: 22} ... all this might be over complicating things, going beyond your question, so feel free to forget it :P 
thank you! i'm incorporating your changes right now and refactoring some, so i may be back here with another question. i created the remote branch before i pushed the changes, so sorry if that caused confusion (its up there now). i had no idea i wasn't calling webpack correctly, i need to look into the ways that webpack is run in some more detail i really appreciate the thoughtful response
This is true-ish, although doesn't really address the question; I know about returning from a function, but what I'm asking about is what is actually being passed, what object, and why it's not changing. The answer above yours seems to answer that pretty well though :)
&gt;For me the best thing about Angular is that it has a flat learning curve So you can get the most of it. there are some valid points in the article but this is pure bullshit
You may enjoy [mercury](https://github.com/Raynos/mercury).
It looks like using [t7](https://github.com/trueadm/t7) to write templates in HTML would work. I'm thinking of going that way with Mercury, and maybe even adding a t7 loader to webpack so I can have the templates in separate files.
I disagree that you need a solid feeling for JavaScript first. Most of what I know about programming I learned through using frameworks like SproutCore, including MVC, observer patterns, mixins. As this is written in JS, there is no way that you won't pick up JavaScript as well.
Everything is passed as reference, but certain references are static pointers, for things such as primitives. You cannot change the pointer to 42 for example. As soon as you pass anything else, you pass a pointer which allows you to change anything on the parameter passed in. Due to garbage collection the only thing you cannot do is delete the reference itself. Any change will persist across anything carrying around the same reference/pointer.
++ Here here! Lazy FTW... :)
must be.
Agreed. For most cases. But what you have to consider in a multi-threaded server environment running Node (or otherwise) every cycle can count. Sure, it's an anti-pattern to over think optimization up front, but the advice here is simple enough.
I would seriously disagree that there is no point. But I'm very ready to be wrong. Not only have I seen many examples of when to use a LinkedList, but a great example is with a HashSet or classic Dictionary. JavaScript has some advantages and disadvantages, and some of these are solved through the use of a LinkedList. The key here is, if you are modifying the collection near the front, an array will lose in a race with a linked list because it has to do a n = length-index copy operation just to move one value. A linked list does none of that, regardless of language you are applying it to.
thank you very much so far and please continue the discussion on this its important for me. so I won't be wasting my time at all learning Javascript and there is nothing wrong in choosing the open source (Js,Ang,Node etc) path from a career point of view compared to C# ? What interest me from .Net was the ability to target billions of devices with Xamarin you can do mobile database desktop etc Why peoples complains that the javascript framework change often ? Which is better between React or Angular ?
Maximum object size is ~600KB because the heap is paged and maximum heap page size is 1MB. If bigger arrays would be preallocated, they would have to be allocated in the special Large Object Space which is not GCd as often as New Space where all freshly allocated objects typically end up. 
Kind of funny that the people who work at this company piled onto this thread and downvoted people who disagreed with them.
I had lots of functions which needed to be run with promises and repeating the declaration for the promise was just creating too much code in every function. This utility is just a promise wrapper and it made my code much more readable and easier to follow but other than that yup you're right promises alone already are composable in javascript and there in no magic here.
That was my first thought : care for performance and code quality ? Why not ditching jQuery in the first place ? Now, with all that legacy code around ...
It runs on UI thread because it works with the UI. It's not stupid, it's logic. If you need to do a lot of non ui calculation on your JS, there is worker for that even though they are not ready for full scale use.
I thought this was [garbage](https://www.youtube.com/watch?v=Pmd3UiNfNkA).
Any time you need to support IE9 and below. 
yeah, I, myself, have not learned angular but I have read from various credible sources that angular is easy to get started and very hard for any non-trivial stuff.
To be fair, IE9 does pretty well with a classList polyfill which is peanuts. The jQuery selector engine Sizzle is also available stand-alone.
Put one framework on top of another to make it simpler ... Yeah ...
Yes, it is 100% compatible with both jQuery 1 and 2.
Well, it's the fact that they're very small frameworks, and it's easy to remove (or add) bits and pieces. I like it over going all in with a larger framework like angular. For example, I use ampersand js for fetching models/collections, etc. If that fails me in the future for whatever reason, I can always throw that part of my app out and replace it with something else... without having to rewrite the whole app, anyway.
Just because you are working with the UI doesn't mean that you have to run your code on the UI thread. Take an android app for example. You can easily create threads and put all your heavy work there. Putting it on the main thread will create a bad user experience and is and will always be bad practice and, yes, stupid. 
And every action to the UI in android needs to be done in the UI thread to avoid changing stuff while UI is rendered...
Now that you mentioned it… that's true. I'm sorry if you found it misleading.
This! These books are amazing.
Are you sure JSC won't crash? Javascript VMs are really complex beasts nowadays and may have assumptions about single threading in place. Violating these assumptions may not cause immediate crash, but I woudn't be surprised about bugs when thread safety cannot be guaranteed.
Great. I really agree with this article. If we need to develop considering mobile web browser, core library like jQuery don't need to use. In desktop case, If we need support IE9 and below, should use selectively jQuery's function.
I would suggest SproutCore, even though it is not necessarily very lightweight. Main reason is that it makes maintenance and extending rather easy. Also a small reminder that Moodle does have a REST API which you can use for an easier front end. Edit: Posted too soon.
What i need in a post like that are clear examples on how this compares to React + vanilla or React + Popular Controller (Redux probably). Because the JavaScript community has a bit of a reputation for rapid churn of libraries that go nowhere fast, you have to really sell your idea. Otherwise, regardless of its actual usefulness, just becomes part of the noise.
I love pure JS
Wow I really like the minimalistic look here. The loading chaos leads right into a clean slate. Nice job.
No, it doesn't. It is fully self-contained HTML+JS+CSS. It has build-tools (two sets of it to be exact), one in Ruby, one running under NodeJS.
Aha, I may have looked too briefly at it then :) Thanks for the tip!
You don't need to understand it 100% to write good code to solve problems. The life is about learning what you need right now and then applying it. This iterative process never ends, but you get more proficient/knowledgeable with time. Code reviews and colleagues help protect against mistakes, but everyone makes some mistakes so don't let it get you down. If you don't like the work, look for something else. 
&gt; Hahahahahahahaha Why Do You Write Javascript Hahahaha Nigga Just Walk Away From The Screen Like Nigga Close Your Eyes Haha ^Continue ^reading ^- ^*20 ^cool ^tricks ^to ^be ^blunt ^as ^fuck!* Another bait title and non-informative rambling from a special snowflake. 
Hmm, this is relatively simple var a = { foo : 25 }; var b = {bar : 10}; var con = JSON.stringify([a,b]); You mentioned sending this on to the server, well that depends if you are using a framework. If you want plain vanilla AJAX then use the XMLHttpRequest object
I'm not even sure.. I'm not even sure if that's stupid or kinda cool..
Pretty neat :) 
Just continue and you will eventually become a good developer, that is how everyone learns, no one gets to sit and spend time learning stuff carefully, while still making money. The only way it to learn it as you struggle with it. So, just work harder and you will be all good :)
Yep, that's what I'd say. The AJAX would look something like this, OP: var xhr = new XMLHttpRequest(); xhr.open("post", "sever url", true or false here); xhr.send(con);
Didn't know there would be a stream, thanks for sharing!
Does anyone know where the Yavascript pronunciation joke came from?
This was a fun read, but I'm not sure what your point is, exactly. Are you saying that React is just a bunch of abstractions around relatively straightforward JS code? Yeah, it is. Most libs are though, right?
This is true. Someone mentioned needing to support hospitals, in which case, sure, you're dealing with older browsers. For a general audience though, I don't think we need to be supporting 10-15 year old operating systems at the expense of moving forward though. Plenty of software requires Windows 7 or higher -- why should web applications be any different, especially now that they're increasingly replacing standalone clients?
Read up on [coercion](https://github.com/getify/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch4.md), the values are being converted before comparison - you normally want to use triple equals in javascript. 0==="" //false 0=="" //true or the other way round as in your example - 0!=="" //true 0!="" //false 
Sure, but when you've abstracted it to its core, what's left is just a mutable tree data structure and there are plenty of depth-first traversal implementations out there.
There are so many languages and no-one knows them all .. its not unusual for a person to specialize in a few, and have an acceptable level of knowledge in the others. Nothing wrong with looking at JavaScript/node, etc... Nothing wrong with looking at JavaScript and C# as its not unusual for the backend to be written in C# and front-end code in JavaScript. Why do people complain about the JavaScript frameworks changing often? Those who try to stay with the current latest-and-greatest frameworks find themselves worn out from chasing a moving target. There is always a new framework, always a new library. Learn something and have to relearn a year later. As for react vs Angular? I have no opinion as I don't know either. Personally, I tend to dislike frameworks and would rather roll-my-own code, but I know I'm in the minority there. I"m fluent, however, using Knockout and KendoUI -- each has pros and cons, and they are better at *different things*. There is no, all-encompassing "better." 
No, it doesn't. Source: I'm the author :)
That's not what is happening at all. When you perform a coercing comparison (i.e. == or !=) between a number and a string, the string operand is converted to a number and the two are compared as numbers. And the empty string coerces to the number zero, so this is really `0 != 0`. This is why `2 == '2'` is true, which is why this feature was originally added (so that webmasters without a programming background would be able to write simple JS that didn't have to do lots of explicit type conversion.) [Always read the standard to get the details](https://es5.github.io/#x11.9.3). 
The prerender function could be adapted to deal with attribute configs. Or just don't use camelCasing. The idea is that you code to hyperscript without thinking about JSX, frameworks or any other strap-ons until you need to.
There are things not considered as part of your benchmark: * alternative use of the existing data structures * alternative competing data structures * performance of an ideal Turing machine vs ideal Von Neumann vs real metal For example, one way to solve the insertion in the beginning problem with existing data structure is to reverse the Array and append to it (you can even split in the middle). For competing data structures, there are B-tree, Circular Buffer, or Heap, all of which perform better with GC &amp; memory allocation. Also LinkedList's usage in a Hashtable is not universal. There are [other collision resolution strategies](https://en.wikipedia.org/wiki/Hash_table#Collision_resolution), some of which are better for low memory environment (e.g. Open addressing).
Cool! It is an empty string, but it's truthy/falsey value is false. Conversely, all non-empty strings are truthy.
Free online too! I loved them so much I actual bought the series to support the guy.
How is this a query "language"? It's a JS api for querying mix panel.
It wasn't for me - I immediately suspected something like that. IMHO the title is fine.
Your path / action API is overly verbose. That's the last thing I want in a router.
no way to rotate the pieces? Other than that, clever twist on a classic game.
May i present you http://cycle.js.org/ ?
&gt; Once the state management part of my framework set, I'll swing back through and do a more detailed domvm/inferno comparison. If you get around to this and have questions, open issues early and often. The docs are not yet exhaustive and if you ever feel like you're fighting domvm to get something done, it's very likely there's an idiomatic way to get there with no hacking.
I've no idea either, sorry.
Seems so. Still it's kinda interesting idea, while it's also stupid and useless. 
js was built to work with HTML; html uses strings only, attributes for example `size=45`; 45 is a string... so js was built to assume empty values and **falsey values** are all 0. ex: `"" == 0 == null` use `!==` and `===` for comparisons that are empty/falsey 
To be fair, I wouldn't be surprised that an utterly new feature wasn't as performant as another feature that's just syntax sugar for function.bind.
Check out FRZR if you like really clean and simple syntax.. https://frzr.js.org 😉
They are both "falsy" values. Here's a list of values that evaluate to false in a boolean context: https://developer.mozilla.org/en-US/docs/Glossary/Falsy
 typeof null // object
NaN == NaN &gt; false That's a fun one!
it's not a boolean context, it's a number context. '' is coerced to number because it's compared to 0. Good reason to stop relying on double-equals for equality comparison unless you really consider all the cases where type coercion happens.
Yes, you are right, I was mistaken
R to reverse the patterns 
I like where you're going with that. Reminds me of [Reagent]( https://github.com/reagent-project/reagent) (clojurescript interface to react). Maybe you could make React code easier to read in some complex cases by creating helper functions in this style and then using them in `createClass`.
Hospitals, government software (some of which was written to only work with old-school brower-specific extensions), China, and all sorts of other things. Point is, who you have to support is usually dictated by the job/client/region, not by the developer. MS made a business decision to make developers lives worse. They've really really improved since then, but they never took back that decision.
We had a [post yesterday](https://www.reddit.com/r/javascript/comments/4ft52t/domvm_v11_a_fast_isomorphic_view_layer_router_in/) about a library ([domvm](https://github.com/leeoniya/domvm/)) that basically implements this.
Here I thought "Over-engineering" referred to adding every known fallback for injecting external JS, like (document.body||document.getElementsByTagName('body')[0]||document.getElementsByTagName('frameset')[0]).appendChild(script);
Why you dislike framework like angular or react they are bad compared if you write your own code or ? A few programmers told me there is a lot of dislike about javascript idiosyncrasies compared to others language like C#, C++, Java etc why they think its a badly designed language who doesn't follow rules ?
Reversing the pattern != Rotate the piece
I think the concept is similar to Rx.js, only it's commercial and has something to do with Mixpanel (I don't know what it is).
The best JS feature ever
Yeah - but that's the only other option. =/
Hey /u/simonsarris, I work at a consulting company and we're thinking about recommending Go.JS to our biggest client. One functionality they'd need though would be to go from GoJS's JSON to Neo4j and back. In particular, I'm looking at the JSON generated by your Flowchart example. Any suggestions/advice?
Right, in this case, the results are compelling. It's important to know what you don't know, though.
God bless polyfills!
I hate that too. "Save 10% by using our app!". Here's my thoughts - It's selling information about to you advertisers, like your location and such.
I don't understand why this is any better than an if/else if chain, personally. Saves a few characters for each condition at the cost of requiring more indent and saying "break;" (or accidentally forgetting "break;").
Hey, go easy on the DOM... DOM games are really common! I like that you get the benefit of event handling baked in. For some games it's even going to be more performant than canvas: I'd imagine this game would be one of them - because things do not get updated very often. With canvas you're (usually) pushing a whole screen of pixels every frame. And there's tonnes of DOM-based games. Before canvas it was the only option... Here's a [platformer I made](http://www.mrspeaker.net/dev/platform/) in 2006 ;)
Yea I don't mind that, i just don't like having things like "the Amtrak App" on my phone. There are only TWO essential apps Tinder and Uber/Lyft 
Consider Math.sin("hello") !== Math.pow("foo", "bar") // NaN !== NaN NaN is not an actual value, rather it is a placeholder for all situations where a value cannot be calculated. Thus it would be strange to treat all NaN values as equal.
You shouldn't care because you shouldn't use != or ==
Things in software development are only ever "super simple" in retrospect. Don't ever feel bad about missing the "obvious" in this field!
why not just this? var layout = null if (liCount &lt;= 10) layout = "upload2Rows" if (liCount &lt;= 5) layout = "upload1Row" if (liCount == 0) layout = "start" if (layout) setLayoutState(layout) $('#UploadList').data('jsp').reinitialise() 
Serialize your object using JSON.stringify, then in the client wrap the string in JSON.parse to get the object back.
Ah... an interesting way to look at it. NaN is a number though... which is somewhat ironic.
The fact that `0` and `""` are both falsy has nothing to do with the reason that `0 == ""`. The truthiness/falsiness of `""` is irrelevent when considering how it's converted to a number, or at least only obliquely relevant.
The fact that they are both "falsy" has nothing at all to do with it. The abstract equality comparison algorithm doesn't have anything to do with that. What matters is how `""` behaves when it's coerced to a numeric value.
I thought my answer was fairly sufficient. I completely agree that rendering only what you see is optimal, but this wasn't part of the question. It may have been a requirement to show all 50k elements, I don't know what the OP was building.
Good to know, thanks /u/ApkalFR ! 
This is correct, but to elaborate a little. If you call .toString() on an object you get "[object Object]", not the string representation of the object. It's similar for an array. Knowing that, it becomes easy to guess what the right solution might be.
Hmmm.. that's pretty nice too. Probably it's slower though for each condition having to be tested, rather than the possibility of subsequent 'else if's not getting run if a previous condition is already satisfied. In that way, switch has got a leg up on this.
One possible reason - if your conditions are computationally expensive, you don't want to do any subsequent ones once you've a satisfied an earlier condition. Case and if/else if/else handle this.
Ha! You know I've discovered that JavaScripters are really really extreme. [Perfect example with recursion](https://www.youtube.com/watch?v=k7-N8R0-KY4&amp;feature=youtu.be&amp;t=1m8s). I wonder what it is about JS.
I've read the same article about every single library or framework, ever. I've read it about Angular, Django, RoR, Boost. I've seen it about Laravel, hell I've even seen the same arguments being made with the STL and **even** with C++. It's almost like, after people use a framework for too long, they forget why they used it in the first place. But when it comes to actually getting rid of those "evil frameworks", what I've observed is that people just end up replicating, usually in a half-assed, under-compatible, under tested and under optimized way, the same features those frameworks provided them in the first place. I understand that overrelying on a framework's tools might be bad from a pure performance/purity/whatever perspective (it's no secret that we are all solving different problems), but I believe this is a terrible approach from a business perspective. We are mostly here to get things done, and we are lucky enough that people smarter than us have given us the tools to build our actual product on top of their smart foundation. This craziness of always reinventing the wheel is what gets me in this industry: it's been solved, use it. A superior solution has been found? Use it. You will never see Mercedes suddenly shipping a 7-wheeled car, why would a development team ship another in-house "reactive DOM-binding library" unless it's **absolutely** needed for their product?
That makes sense. Basically the prerenderer is a bridge between your code and the actual library that you're using for view. What's interesting about that idea is that Angular 2 uses the idea of "drivers" which are basically custom renderers.
because it's too overengineered (judging by its source) and doesn't make anything more than every smart programmer could do in circa 10 lines of code, or every stupid programmer after reading Redux docs: http://redux.js.org/docs/recipes/ReducingBoilerplate.html (". If you don’t like switch, you can solve this with a single function, as we show below.")
I'm talking from the point of view of someone working as the founder and CTO of a mid-sized startup, and I guess my point of view resonates with 99% of programmers, who aren't decision makers at powerhouses who can and have a reason to dedicate a whole team to rewriting a core library. When it comes to getting your product out there, "taste in syntax" is, sorry for my words, bullshit. Performance is usually also not an issue, but it's very domain-specific. To be a bit cheeky, I will also assert that a framework's performance is never the bottleneck of 99.9% of front-end programmers. 
[MDN has docs](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Security_concerns).
If the conditions are expensive, then as per my other comment, you may want to always do 3 expensive comparisons than potentially 6 (especially since worst case here happens for the vast majority of possible liCount values), or refactor the code to memoize potentially repetitive clauses in conditional expressions (as the OP code has already done).
It's not just about getting rid of switch, but it also improves the performance by introducing groups. It is focused on big Redux application with lot of reducers to prevent some unnecessary comparisons to be made for each dispatched action.
&gt; Proposals work their way through a committee process and eventually either get rejected or get accepted in to the language and standardized. That's the part I'm curious about. Is this common? 
I'm afraid I'm not familiar enough with Neo4j to give any pointers, but I should point out that GoJS has two common ways of creating JSON models: GraphLinksModel and TreeModel. With GraphLinksModel there's separate data for nodes and links, and with TreeModel there are only Nodes, and the links are implicit. I wrote about that recently [here](http://programmers.stackexchange.com/questions/300483/how-can-i-represent-a-flowchart-complete-with-conditional-logic-using-json-or-x/316089#316089). (The Flowchart example is a GraphLinksModel.) I should also note that the name we use in our JSON are not fixed. Nodes all have "key"s and links specify "to" and "from", but these are all properties that you can change on the Model class if you want to use other values, which might make conversion a tad simpler, or more intuitive when looking at both data sets. For example: [Model.nodeKeyProperty](http://gojs.net/latest/api/symbols/Model.html#nodeKeyProperty) Let me know if you have any other questions. If you want to start an in depth discussion you can always email gojs (at) nwoods.com
I had an hour and thirty-seven minutes. That is lovely, thank you. :)
do you have benchmark somewhere to proof that your implementation is faster than other approaches?
Not yet. I am too busy with other stuff, but next week I should have something to show. I think that my implementation might be little bit slower for smaller applications, but it should be faster for large application with more reducers and groups. We will see.
Btw. It's still kind of quickly implemented prototype, but next week I should have more time for improving it.
It has to do with ES implementation of abstract equality comparison algorithm. [Here's a similar example with some additional detail](http://www.metaltoad.com/blog/javascript-wat-diving-ecmascript-abstract-equality-comparison-algorithm).
Thanks so much for the response! I'm glad that it's worked out well for you. How did you get over the imposter syndrome stuff? Also, what were your initial challenges at your first job? It seems like that is pretty prevalent among coders. It's a relief to hear that the bootcamp was breezelike, and that totally makes sense. I think knowing that I've made the choice to be there and feeling confident that it's the right choice has gone along way towards getting me excited going into the program. I hope that feeling will continue throughout my time there. 
&gt; To be a bit cheeky, I will also assert that a framework's performance is never the bottleneck of 99.9% of front-end programmers. Perhaps in your experience this is true, which is great. However, regardless of your CTO/startup cred there are *many* situations [apparently out of your scope] where performance of the framework is absolutely essential. I'm not speaking theoretically here. Want to render an excel-like dynamic spreadsheet? A slow framework will absolutely fuck you. You can also bet there's a *massive* difference in battery life and mobile performance between slow and fast frameworks. These are just two of many frequent requirements in SPAs. Not everything in this world is a 300 DOM node bootstrap site or largely-static facebook feed.
That trick is completely normal. And finding it strange is also normal. ;-) JavaScript recently added a new kind of function syntax, called [arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), that take their "this" value from the surrounding environment just like you would have expected.
It's edging ever closer to a stable release, which means in js land that it's obviously time to jump ship. 
If you are certain of the cat objects props ahead of time you could do something like this: const combinedCats = [ obj1, obj2, obj3 ].reduce((current, next) =&gt; { current.cat.meow = next.cat.meow || current.cat.meow; current.cat.claws = next.cat.claws || current.cat.claws; return current; }, {cat: {} }); This should work in any order as well as if there are no `meow` or `claws` props present. I'm sure there is a way to do this even better but if anything its fun to use `reduce`.
I can't wait to start writing 'null' fucking everywhere
Lol. Wow, you don't handle being wrong very well do you?
It's an honest question. How do you think anything gets documented? I don't see a right / wrong here. I mean literally if you read the code examples in the article they are documented explicitly by function.
Uummm, React is just a view library. If your app grows beyond something trivial then you will need something to manage state, http requests, etc, eventually. You can either roll your own or use someone else's hard work to accomplish your needs. Working with a team I tend to shy away from rolling my own due to time constraints, documentation, and such. I commend /u/NervosaX for using their own valuable time to put a tool out there to possibly make others lives easier. You have been using libraries all of your career and probably never thought of the hard work people put into them. If you don't like learning about new libraries being produced then browsing /r/javascript probably isn't going to make you happy. Maybe we need a /r/trueJavascript were you all can just talk about javascript without any discussion on libraries/frameworks. /rant
Thank you for sticking up for me, but I can understand where people are coming from. I didn't create cerebral, but I have been contributing for months because I feel that cerebral removes some of the "javascript fatigue" for me and my team. This won't appeal to everyone, but it's magical in its simplicity... Especially when you come back to maintain a cerebral application. I've so far has no problems refactoring or fixing bugs from months ago thanks to its readability
No worries. I think with ES6 becoming mainstream and the awesome growth of the javascript community it's easy to feel like you are being bombarded with a million new JS things every day. I think it's rad but others seem to "not see the forest through the trees". I have been enjoying playing around with [mobX](https://github.com/mobxjs/mobx), though not in production yet. Do you think that Cerebal is close to what mobX is doing? Major differences?
[mercury.js](https://github.com/Raynos/mercury/blob/master/dist/mercury.js) compiled with dependencies but not minified is 4k LoC, 107kB. I wasn't aware of issues with virtual-dom, is there something I should read to get a better idea?
I read it as more about not trying to do everything in the context of React.
It wouldn't take much more in the prerender to conditionally replace the second parameter with a child. ["div", "some text"] is possible. But I agree, markup is easier to read, especially for designers.
Amazing work ! I can finally remove all those bash scripts I hacked together
&gt; only support Chrome browser Why?
Ah, ok. I get 43.3k min and 14.3k gzipped - 2.5x domvm. Not horrible, though still without a router, but domvm's can easily be used here. Isomorphism is absent...though maybe possible via hacks [1]? &gt; I wasn't aware of issues with virtual-dom, is there something I should read to get a better idea? You can read through the open issues, but one that stands out which was a big red flag for me (and a central part of domvm) is isolated sub-tree redraw [2]. Mercury seems to promote immutability and discourages local state [3], nothing wrong with that but I did not want to enforce this in domvm, I leave it up to the user. I could never find a Mercury/virtual-dom dbmonster benchmark, so it's hard to say how it compares to domvm. Building mercury and virtual-dom requires tooling, which I wanted to avoid in domvm (and succeeded). Mercury's hook implementation is somewhat limited [4]. I could go on, but I'll stop here. At the end of the day, there are no use-cases that domvm is unable to solve in 16k and there is no compelling reason to have doubled the size of the lib for fewer features. I'm not knocking Mercury, but it wasn't my cup of tea, so to speak. You may be more familiar with Mercury and some of these may not be issues, but I had limited time to spend analyzing the viability of a dozen different vdom frameworks and if anything smelled funny WRT where I wanted to go, I did not have time to learn everything in depth only to be disappointed after sinking a bunch of time into a failed commitment. [1] https://github.com/Raynos/mercury/issues/55 [2] https://github.com/Matt-Esch/virtual-dom/issues/343 [3] https://github.com/Raynos/mercury#mercury-vs-react [4] https://github.com/Raynos/mercury/blob/master/docs/faq.md#how-do-i-get-life-cycle-hooks-for-vnodes
This goes back a long way. Javascript's `Number` type is based on IEEE754 double precision floating point. NaN is pretty fascinating. I suggest learning about floating point if you do anything involving numbers (which is everyone.) http://floating-point-gui.de/
Knowing the reason not to do something is always valuable. 
Nah' just come join us on React Native, we're still moving at rocket speed!
Ah well what I meant was that `{path: '/blah', action: a_function}` Could be simplified to `{"/blah": a_function }` Or if they preferred to use a function call use: `route('/blah', a_function)` 
Oh, ok. Yeah, I'm not sure why he did that. This guy is a code genius though. I've never seen anything like it. I feel like he probably had a reason for that.
When I say running directly from the file system I mean the browser is loading the file directly from the file system which uses the "file://l" protocol (I put it in quotes because it's not really a protocol its a browser thing). The alternative is to use "http://" which means a server sits in between the browser and code grabs the code and transfers it via the HTTP protocol. Browsers are designed to use http, it's a bit of a hack to load html directly from the file system. That being said...I think you are on the right path. Node will handle your AJAX requests listening on port 80 but you should also host your static HTML files in node and hosted on port 80. I would recommend hosting them from something like /API/endpoint.
Fair enough!
Maybe I missed something but I didn't see any mention of "evil frameworks" or any kind of criticism towards the use of frameworks. He even says it's a "brain dump", which I understand as just exploring ideas and what is possible. About the reinventing the wheel, Mercedes doesn't ship wooden wheeled cars either. And the fact React exists means some people are looking for ways to do things differently and hopefully better.
Remember, always use "===" and "!=="
My recommendation for you my friend is to start off from the base language and move up later on. Fundamentals are crucial, even if you decide to work with a framework. A good place to start is to try to make your app with vanilla JavaScript, checking through the [Web API of MDN](https://developer.mozilla.org/en-US/docs/Web/API) and have a tab open of [vanilla-js](https://github.com/Haeresis/vanilla-js). After that you can start worrying about async stuff, ES6 and frameworks. EDIT: I want to add that when choosing frameworks, you might want to look towards something that aligns more with what you currently have a strong knowledge of; classes. I recommend [Aurelia](http://aurelia.io/) over Angular, but you should definitely make your own opinion of what you feel comfortable with. But for starters, don't choose any framework and go for vanilla JS. Off-topic: If you like Ruby, check out [Crystal](http://crystal-lang.org/). It has the syntax of Ruby, the speed of C and is awesome. It's not production-ready though!
How many rows do you need to see that performance impact? 10000? And how many of them your user can see? 10? Then you "solve" your performance problem by rendering only 10, not by changing your framework. 
Being forced to use the `key` prop when iterating over array? I understand the technical reasons but it does not add to my productivity. 
Nope, react is [stable now](https://facebook.github.io/react/blog/2016/04/07/react-v15.html)
Glad to lighten someones mental load. SSL certs and renewals can be annoying!
That's pretty minimal effort to gain what you do with that prop. Seems sloppy. 
Indeed. I rage every time I watch people get accused of NIH Syndrome. Everything ever invented in history started with someone saying, "I can do this better" and iterating or re-inventing. If everyone only used existing solutions or accepted all problems as "solved", there would be zero progress made. &gt; Inferno being an outlier in needing light speed performance for its real-time financial applications I know he uses this as an excuse to pursue perf but TBH I find this hard to believe. Even if a single refresh takes 100ms for a full dbmonster table (and it's *well* below this), no human will be able to consume the info this fast. It cannot possibly be beneficial to show the same data even 70% faster - a human will not be able to tell or act differently on that data. I realize that there are micro and nanosecond timescales at the ASIC/FPGA levels in the financial industry, but the DOM is very far from that place. There is a mobile perf argument to be made here, but even there you're better off using canvas to show massive amounts of data instead of the DOM.
Yes it does. You can see that with `console.log(Number(""))`
Tangentially, I hate it when I already have the app, but tapping "open in app" takes me to the app store. And then once I finally get in the app, my progress/state is lost. Ugh!
If you're really concerned about making it shorter, why not do something like this? liCount === 0 ? setLayoutState('start') : liCount &lt;= 5 ? setLayoutState('upload1Row') : liCount &lt;= 10 ? setLayoutState('upload2Rows') : null; $('#UploadList') .data('jsp') .reinitialise(); And maybe snake case is easier to read (marginally), but camel case is easier to type (marginally).
I really like the idea to write a single component function that I can simply drop into Angular, React and what not ;) **The real question is -- what should this function return?** Both Angular and React components return JS objects with their own native templating (augmenting) engines. Angular 1.5 component is represented by: function (friends) { return { template: "&lt;ul&gt; &lt;li ng-repeat='friend in $ctrl.friends'&gt;{{friend.name}}&lt;/li&gt; &lt;/ul&gt;", controller: function () { this.friends = friends } } } React/JSX requires function (friends) { return (&lt;ul&gt; {friends.map(friend =&gt; &lt;li key={friend.id}&gt;{friend.name}&lt;/li&gt;)} &lt;/ul&gt;) } But what is the cleanest minimal object representation that can be mapped into both frameworks? 
Website here: http://staltz.com/xstream/
&gt; people just end up replicating, usually in a half-assed, under-compatible, under tested and under optimized way, the same features those frameworks provided them in the first place. And I've read that a hundred times. And every time, it's just an assertion, never a conclusion alongside supporting arguments, and certainly never referencing real code. edit: yes, downvote me for requesting people back up their arguments. That's sure to make this a more rational discussion.
&gt; Why should I clutter my code with framework-specific attributes? You know that's a good point, and while we're at it, let's get rid of `componentDidMount`, there's no reason we should clutter our code with framework-specific functions.
Srsly, MS has been releasing and open-sourcing some pretty awesome shit lately: https://github.com/Microsoft/TypeScript https://github.com/Microsoft/ChakraCore https://github.com/Microsoft/vscode https://www.linux.com/news/bash-windows-what-does-it-mean http://blogs.microsoft.com/blog/2016/03/07/announcing-sql-server-on-linux/ https://blogs.windows.com/msedgedev/ I mean, look at their profile: https://github.com/Microsoft
Hey, I wrote and maintain a library similar to this. You're right, it's easy to implement, but there are four big problems with it: ambiguity, performance, readability, and flexibility. Ambiguity: consider `['div', someVar]`. You actually don't know until runtime whether you're setting properties or children. That's a sign that you've screwed up badly, for all the reasons ambiguity is always bad, including completely preventing the JIT compiler from working with your code. Performance: it's faster to use native argument parsing, plain and simple. Work you do figuring out which argument is which is 100% unnecessary, and adds up for code that you want to be able to call thousands or tens of thousands of times without a user-perceptible delay. Readability: when everything is always in the same place, reading and scanning around is faster. Work with both styles for a few weeks and you'll quickly see that this more than makes up for six extra characters. Flexibility: every time you try to be more clever about guessing the caller's intent, you deprive yourself of the opportunity to give the caller more actual control. In this case, refusing to support this allows my library to support passing in a string as the second argument to set `className`. This might seem like a little win, but it's actually a huge one - one that improved my entire test app's performance by 30%. The thing to notice is, there are a heck of a lot of elements that need only a class and nothing else, and for each of those elements you're avoiding an extra object allocation.
Some good points there. What is the library you maintain?
[The draft and discussion of his strawman proposal](https://gist.github.com/bterlson/da8f02b95b484cd4f8d9). Cool stuff bterlson.
I would rather stick to using ES6/ES7 for now with Babel.
mmmm tortillas well I was finally forced to find the most basic example possible, plug my stuff into it (took a few hours - an hour of googling and searching github and others for a TRULY BASIC example) and fully understand how it worked so now I feel like I grasp callbacks enough to regularly work with them. You can't do anything complicated or keep-alive in node.js without them. Thanks for the link!
its kind of clever to include a better standard lib with javascript and static types. linq was also so good and theres [linq for typescript](https://www.npmjs.com/package/linq-ts) i would avoid ms web tech though; asp, silverlight, xaml are all terrible imo, and silverlight was abandoned after billions of dollars of manpower spent creating projects with them. windows.js is way more complicated then jquery and a lot more keystrokes imo
Angular went for the `ng-*` prefixing because their attributes exist inside the DOM. React's `key` prop only exists inside React code, it doesn't render a `key` attribute on DOM nodes. It's not really a comparable situation.
Also for debugging purposes stick with console.log instead of alert which formats data you pass there.
I'll be the first to call it out: https://xkcd.com/927/
[Image](http://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2793 times, representing 2.5818% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d2e54x2)
That looks good.
&gt; I'd suggest heading to the repo and downloading a zip That's exactly what I did before asking this question. The problem is I don't see any .js files compiled for the supported browsers. Normally when I read the documentation for .js libs suitable for use in the browser, I see a brief instruction on this, such as "If you want to use it in the browser, just include `&lt;script src="[URL]"` in your web page". But I don't see such instructions for this project, does this mean that there is no compiled version of this library?
Well I don't know the specifics but from what I remember, he said that in his domain, getting information (from server to screen) that was stale by more than some 100ms was a critical bug. So I can definitely see inferno fitting in a bigger picture where they might already have fiber optics networks and things like that
Not this week, but I made a color swatch generator. You add and store colors as swatches and copy the color (hex, rgb or CSS color) to clipboard by clicking the swatch. http://codepen.io/eddyerburgh/full/adMqEO/ What do you think the best design pattern would be? I used object literal, but looking at the code now it seems like I went overboard. 
It is still a bad idea to create a custom tag named `key`. People work hard on creating standards and minimising confusions by meaningful conventions. One of them is to use dash for any custom tag. React is breaking this convention for no apparent reason/benefit. Something like `r-key` would be much easy to read and scan for, it would instantly alert the reader that tag is React-specific. Without dash, it looks generic and easy to confuse. What if HTML will decide to introduce its own tag `key`??? Also attempts to create separate languages for DOM, virtual DOM, HTML, whatever, lead to more confusion, more bugs and hurt anyone's productivity. How many different models do we need to represent the same basic thing - a tree with nodes and attributes? A big part of its ease and popularity React owes to our familiarity with the DOM. If it used some crazy transformation of DOM instead, how many people would use it? So why not being more respectful to the DOM standards?
True, that's is basically omitting a break; from a switch statement.
I can't wait to run through this line by line.
So you already have a bot in place? You need a database to track user scores and some functions for betting via a chat command. E.g. !betwin 100. After the game you just type a command like !won or !lost and assign the new scores to the users.
Could even be more then one JSON message if the client is buffering. What you need is a proper streaming parser that reads messages one by one. The easiest way to do it is by sending newline separated JSON (eg: one object per line, so no indenting). You can rig this with a line splitting stream, (or) just check npm.
Made this webgl [grass demo](http://www.spacejack.ca/projects/poaceae/).
 Not exactly photoshop but it was a good exercise to get accustomed with canvas api and touch events Poor cross-device compatibility, the code is messy, best used on chrome on a desktop http://codepen.io/Makart/full/mPjGjV/
Very helpful! I enjoyed reading that. Unrelated: every time I see a blog that talks about one thing but has like 20 devDependencies, I die a little bit more inside. =(
Why, it has no relationship to your bundle size? The whole idea is that you only use what you need, so most of the dev dependencies are babel, karma and a bunch if their plugins.
E2E testing shouldn't have anything to do with what framework you use. React, a simple jquery script or even a dumb site with post requests. Click the link, see what happens, fail or pass the tests. Whatever happens under the hood is for unit tests.
I think you're taking my comment out of context. Im in no way implying that e2e should care about what framework. I'm more talking about tools for making it easier to e2e test React. For example there is protractor for angular. 
[orly-cover-bot](https://github.com/hemanth/orly-cover-bot) a twitter bot that tweets orly cover pages.
Oh, certainly. But that's more of an extended e2e testing, if you know what I mean. Or maybe specialized e2e testing...? In any case, I haven't seen anything like that for react. 
This is cool, is the code on Github or something? I'd love to see how you did it.
You can use Array.reduce()! See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce Something like: let result = input.reduce((accum, item) =&gt; { /* set up accum here */ return accum; }, {}); 
Nice work! I tried this a while back too using absolute-positioned DOM-tetrominos.
&gt;The JavaScript support is probably the best I've seen in any editor. If you declare a JavaScript object, VSCode will know exactly what's inside of it and what type it is (unless you modify the object). It seems to be attempting to generating TypeScript types for JavaScript objects and then using those to provide intellisense. I'm a big fan of their intellisense and I'd consider it one of the best (if not the best) in JavaScript editors. VSCode actually uses [Salsa](https://github.com/Microsoft/TypeScript/issues/4789) underneath, which is in essence, typescript parsing normal javascript. It's pretty neat. VSCode has slowly worked its way to being my favorite editor for a lot of front-end code. It even works for editing C# or F# if I don't want to wait for visual studio to load up before hand.
Yeah, that's unfortunate but I just stumbled upon this really good Google blog post on the balancing what type of tests add the most value. So I'll probably be spending less time e2e testing and more time doing the type of tests described in this article. I agree with a lot of the points brought up but of course it varies from project to project. Here's the article: http://googletesting.blogspot.com/2015/04/just-say-no-to-more-end-to-end-tests.html?m=1
Selenium has several ways for you to select the element to test with, only one of which is by ID. Hell, you can even execute arbitrary javascript to test things with. E2E, particularly with things like selenium, is never done with a framework in mind. A good chunk of the time they're not even written by developers, but rather QA. Protactor in this sense is highly unusual. 
Interesting... Thanks for that :)
&gt; Im in no way implying that e2e should care about what framework. Do you not see how this is in direct conflict with your very next sentence? &gt;I'm more talking about tools for making it easier to e2e test React. If you have tools that make it easier to test react e2e specifically, your e2e cares about what framework you're using. Think of e2e as what the user will do. You user won't be thinking of "well this is a nice react site, let me click this react component and wait for the redux store to apply its reducer to see changes". Your user will think "let me click this shiny button and hope the page doesn't error out", so that's exactly what your e2e tests should be doing.
Anyone make the move from Atom yet?
PM sent ;)
I moved from Atom because its so fast. But I miss file tabs. I read on twitter that this is a feature they working on soon. And the search could be better, its in a small sidebar. edit: typo
Yeah, not every team has QA. Our team is required to write our own e2e tests. The need for some extra utility aids in the development cycle when we need to do all of these things. It doesn't necessarily feel good to write a locator just for an e2e test and without locators it's also extra time to write a test that can reliably select elements.
I think E2E tests being verbose are the least of worries if you're shipping stuff without QA! What do you mean by "reliably select elements"? Do you often get e.g ID selections failing with your selenium tests ... ?
Yeah. Atom crashed frequently and ran like a pig for me, whereas I only very rarely get crashes with VSCode. Once a week or so compared to twice or more a day. It has less plugins and extensions, for sure. That's probably going to dog code for a while, but I wouldn't go back to atom for that. Code just simply works better.
I have a pretty noob question: how to run my HTML in the browser? Brackets has the live-preview feature and Atom has some run-in-browser plugins that support running the HTML in the browser, but I cannot figure out how to do this in VSCode. 
I have couple of apps, and whenever I have to update the appstore screenshots (http://imgur.com/a/Nwgfg), its very boring, tedious process. So I created this to easily take high resolution screenshots with text. https://premii.com/play/appstore/ 1. Move you mouse to top right corner. 2. Popup will open, enter your site, width, height and background color. 3. Add title and subttile 4. Resize window to smaller than height and width 5. Take a fullscreen screenshot. If you want to take a high resolution screenshot, use CTRL/CMD +plus to zoom in and you can take really high resolution screenshots (http://i.imgur.com/x8ygoL7.png) without high res display. My app is HTML5 app, so its easier for me to load here, and take screenshots for different resolution.
Definitely agree, and it can be used for accessibility which we are doing to leverage the use of IDs so it's not all bad.
accessibility is a whole different beast that's ignored by 99% of software shops, but thinking about it is a great step towards a better world. Any suggestions on how spread the gospel and not getting push back on "i'm not making changes just for tests"? Obviously I've stated the above, but a single dev usually doesn't care about readability &amp; maintainability.
In case you're actually wondering, AirBNB maintains a pretty popular JS style guide, so presumably that preset transforms JS to comply with the style guide. https://github.com/airbnb/javascript
I actually had a question about array iteration performance on an interview this week. They usually want you to do it like this: for(var i = 0, len = myArr.length; i &lt; len; i++){ //do something } I remember hearing a while ago not to use foreach but I don't remember why.
THANKS!
I recently moved to Code after using Atom for a year and I love it. Atom performance has been getting worse with each release and I just couldn't stand it anymore.
I like the line of thought here. Some thoughts: Returning an Array of arguments for a function, rather than calling the function, doesn't decouple you from that function. The Array is still written against the function's API. Anything you can swap into that function's place is also written against the original function's API - or more likely, is not exactly 1:1 with the first function, and the subtle differences will bite you later. I think you've just moved from an explicit dependency on `React.createElement` to an implicit one. Creating all these Arrays is slow. We tend to think of them as cheap, because they are in high-level code, but we're writing basic rendering code here - we're talking a *lot* of Arrays, in code very intolerant of latency. I've done a lot of work on code that is basically `React.createElement` that returns real `HTMLElement`s, and the #1 performance win is minimizing data structures, both internally and with an API that doesn't request them. Arguments lists are the perfect lightweight data structure for this purpose, Arrays are larger and heavier than what we need here. `extend` is pointless, we have `Object.assign` natively. `Object.assign` is also better in that it allows you to override styles on the base, which I can't really imagine using this without.
Where I work, developers are responsible for writing tests for features they implement. We don't hear from QA department to tell us to make changes. At previous jobs I've dealt with this and have seen this sort of push back. There are extreme cases where a QA person might ask to add locators to everything he/she wants to click or interact with. However, I think there can be balance by adding locators to larger modules/sections and then finding what you need through that. That eventually is what we settled on and is working nicely.
Hi! Really big fan of the show! I've listened to all of them. Ive been meaning to comment about something for a while, which is the loudness of the clanking when you drink. Don't get me wrong, I love that aspect of the show, but when I'm listening to it in my car, it just destroys my ears. Not sure what the best solution would be, but maybe move the mic away or have an audio decibel cap? 
async.series (http://npm.im/async) is nice too!
Interesting, thanks for the link! I'll definitely read up on it.
I moved from Atom to VS Code from December to February, then back to Atom. As it is right now, I don't see it will become very popular. There are too many limitations, like there is no way to add tabs, and Microsoft refuse to add it, even though most users want it. There is also multiple limitations when making plugins, making them less superior to Atom and Sublime Text. 
Yeah, sadly their VIM extension isn't quite up to my standards either. I'm sure it will get better in the future though.
Same here, but I use VS Code as a debugger. 
I think that's the point: change the mechanics of the game.
I moved from Atom to Sublime two weeks ago. It took me all of 2 hours to fall in love with Subl over Atom.
It blows vscode away.
My grandfather refuses to drive a car. Some people never adjust
That's what's been said about a lot of new ecosystems. When the first android phones came out and people were complaining about "oh the store is soooo small relative to the apple store." THAT didn't last long. . . of course, it . . . it ... sheeit. that was almost a decade ago? WTF kind of comparison did I just make. Nevermind. 
In my opinion it doesn't need tabs. Hitting ctrl-p brings up a list of recently opened files (and you can search for others). Without tabs it is more keyboard centric, which makes it faster. And you can always split the window to have multiple files open (ctrl-2/3/etc). When I first started using VSCode (coming drom sublime) I would use the mouse for everything. But after watching a few videos and learning the keystrokes, I don't use the mouse often and have sped up my work considerably. 
Everyone these says seems to want to put named wrappers on async patterns that already exist in more direct form. Promises already chain, they are already immutable, and they already compose. You can create reducing constructs in just a single line of code. You can create liftAX constructs to sequence them into a curried function. They don't need curious idiomatic cruft to do what needs to be done.
In /r/javascript ? No, I don't usually mention visual studio here. I did once or twice in an /r/programming thread about VScode though.
yeah 'around here' i guess pretty much means 'any of the programming subs I frequent' which is probably that. Still . . . speaks volumes about the hoggy nature of vs.
I disagree with you saying that using the recently opened files feature is more keyboard centric than tabs. I can switch between tabs instantly with Ctrl+Tab and Ctrl+Shift+Tab, which if you're just switching between two files is faster than using Ctrl+p then arrow keys and enter.
Haha I manage a very specific package too. I just open source it. I'm case I get hit by a bus at least the code will live on. My shitty shitty python will live on. 
&gt; Also, VSCode is falling into the typical Microsoft Visual Studio pit of trying to take over your project. Care to elaborate? VSCode is currently [MIT License](https://github.com/Microsoft/vscode/blob/master/LICENSE.txt). Or are you talking about VSCode's workspace configurations (which might be different per OS)? Though you didn't mention it, I fail to see how this can also be an instance of ['Embrace,extend and extinguish'](https://en.wikipedia.org/wiki/Embrace,_extend_and_extinguish) done by MS in the past, given that VSCode is OSS. If you can't answer, what you're saying might just be [FUD (Fear,uncertainty and doubt)](https://en.wikipedia.org/wiki/Fear,_uncertainty_and_doubt). I hear ya though on Sublime being good. But please elaborate on your statements concerning VSCode.
Use webstorm once for a complete project and you'll uninstall sublime 
You be careful now, son. You in Javascript sub. Over yonder is r/webdev. So you in frontend town. Don't go talking about using Vim or 'bout reading documentation or god forbid; mentioning uses of debuggers running otside of IDE's. These good people. But, these people get mighty mad and be coming to your front door with their hate and their downvotes, if they be hearing you talking about things they might find complicated. Just say: "Wow, that's some fast editor you have there, friend! It sure is the most custimizable and keyboard-centric one I've ever seen! And golly! It has tens and tens of plugins to make it even more customizable?!? I bet you can't chsnge the colorscheme with a few clicks with your mouse! Oh you can?!?" See what we did there? Especially if the bar/thread you be entering has a sign that talks about a Microsoft product being an underdog. You just say that you happy for lil' old Microsoft and they good. Then the people be all happy and give you free upvotes and be friendly to you.
 function dostuff(){ ... random quote code here... } setInterval(dostuff, 90000)
Used it and uninstalled Webstorm after couple of hours. It's ordinary in front of Sublime and gets in a way of coding
Pretty neat! You should look into beginPath() to connect the points, it would make it easier to draw solid lines fast
Thanks, but that doesn't work. What happens when I do that is the whole page refreshes, but then only the quote generator shows up after the refresh. Then it just starts adding new quotes below the first every 90 seconds rather than replacing the first one. 
not sure why the page would refresh you might want to use document.body.innerHTML += 'text' instead of document.write ? if you want to replace it wrap the quote in a div, `&lt;div id=mydiv&gt;&lt;/div&gt;` then to add your quote var elem = document.getElementById('mydiv') elem.innerHTML = "&lt;dt&gt;" elem.innerHTML += "&lt;dd&gt;foo&lt;/dd&gt;" ... if you do that in a func and use the getElementById and innerHTML; it should allow you to replace just the old quote not rewrite the whole page! then put it all in the interval like above setInterval(function(){ //can use named function like above var elem = document.getElementById('mydiv') elem.innerHTML = ['foo','bar','baz'][Math.random()*3|0] }, 90000) (this shouldnt refresh the page) 
I'm building out a personal framework that will always be using an immutable datastructure. Is there some hook I can use to generate an `onComponentShouldUpdate` for all components? Edit: The perf has been great in my tests. Looking forward to using it for reals going forward.
I'm at a crossroads. Upvote for accuracy, or downvote for douchiness?
You may be exaggerating the difference. VSCode is free and open source, and is improving at rapid pace
You can't say for certain whether that will result in different copies of the bar function. That's entirely an implementation detail. An implementation could keep a single copy of bar and just call it with a different execution environment each time. Avoid premature optimization. 
I have! It's much better! Thank you
Seems to be just a plug for his half-thought out rewrite of Javascript. In my experience the reason there's more Java jobs is that you need several times the number of people to maintain the mess.
Ctrl+Tab also works with VS Code, jumping between... Recently opened, I think? Or working filed; for me those are usually the same lists, so I'm not really sure and I can't check now, being on the phone. ;)
Still expecting a better vim emulator integrated to it. The existing ones are still very rough and incomplete.
I'm confident vim will still be around and in wide use long after sublime, vc and webstorm bite the dust
We've found that the best way of handling this is to completely separate your data from your functions into structs and modules, like so (using immutable.js): const foo = function(a = 0, b = 0, c = 0){ // use reasonable defaults return Map({ a, b, c, }); }; const Foo = (function(){ const bar = function(foo){ return foo.update('c', (c) =&gt; foo.get('a') + foo.get('b')); }; return { bar, }; })(); Then, you can declare as many structs as you want and use the same module for all of them, e.g. let struct1 = foo(1, 2, 3); let struct2 = foo(4, 5, 6); struct1 = Foo.bar(struct1); struct2 = Foo.bar(struct2); It's a little funky at first, but we've had a lot of success with this pattern. What's nice is that you can compose the structs really easily using `Immutable.Map.merge`. The only problem we've encountered is that you lose the ability to have private data, but that's less of a problem than you would think. Private methods are still possible obviously, since we're still using the revealing module pattern.
Big yes vote from me. I'm building a medium and large scale application with it. I've already created dozens of components, attribute directives, and structural directives, as well as pipes (pure and impure), 30+ services, etc. I have it working with websockets. It's lightning fast and easy to add on as I go. Huge fan. 
Angular 2 wins.
It looks nice. I'm gonna give it a try, thanks! But still doesn't save accessing the scope in functions... is it possible to make the struct "local"?
You would pass the struct to each function, traditionally as the first argument. 
You can destructure it if you want, but then you'll have to use native objects. You could also pass in the properties you need instead of the whole struct, but at that point I'd rather just type struct.a
&gt; Skip this article, it's just a Java guy's rant. He's the "Campaign Director for Smalltalk Renaissance". It sounds like he just dislikes most modern languages. It's like listening to the people who rip on Scala because they want to be writing Haskell. 
Ok, thank you.
Thanks leeoniya. If you could raise an issue on Github, that would be awesome :) would love to get this issues sorted ASAP.
The for-loops are basically the same. The first one is said to be slightly faster as you are also storing the length in a variable. But these are hyper-optimisations, and in my opinion not really worth to think about in a normal application. You can find out a bit more on that in this [StackOverflow](http://stackoverflow.com/questions/5349425/whats-the-fastest-way-to-loop-through-an-array-in-javascript) discussion (unfortunately JSPerf is currently down due to maintenance). [Array.prototype.forEach()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) has been introduced with ECMAScript 5 and is still fairly new for some developer. I would say the major difference to a for-loop is it's own scope. There might also be some performance differences compared to a for-loop, but again, I don't think it's worth to think about. For a basic use case (looping over an Array), it is similar to a for-loop. Personally I tend to use .forEach(), as it looks a bit cleaner to me. Edit: I've corrected my statement on .forEach(), as it was misleading.
 Have to use importKey('raw', ... ) for each of the keys. 
Caching the array length is faster in older browsers, but it [prevents compiler optimizations](http://mrale.ph/blog/2014/12/24/array-length-caching.html) in recent browsers.
You can stop a for loop prematurely. Not so with forEach. But forEach is very expressive imo.
What would I be importing exactly? I also don't see any options to specify length. Apologies if I'm just not seeing something obvious..
You could try this hack: function foo(_a, _b) { /* some code */ if (typeof foo.prototype.bar !== 'function') { foo.prototype.bar = function bar() { /* inside scope object of first usage of constructor */ }; } /* more code */ } As the inner comment says, however, only the variables from the *first* invocation of `foo` would be in the scope of `foo#bar`, so this pattern is only useful in singletons, in which case you might as well define that function as `this.bar` instead (as an instance method). --- BTW, that line in the OP with just `this.c;` does not create a property `c` on the instance; only an assignment or the use of `Object.defineProperty` *et al.* does; it is also not necessary in order for the instance property to be added later.
To stop prematurely you can use `[].find(fn)`. It returns the first element where `fn ` returns true, but you can of course do other things than just returning a value in the function. 
Great read, thanks!
Yea kind of making it now as i said i am using the tmi.js
There's also no guarantee that length will remain constant during iteration. Using a cached value vs `.length` directly could also result in a different number of iterations in the loop.
Loving the show, keep it up!
Fantastic read!
[removed]
I moved from sublime to vs code and don't think I'll go back. The lack of tabs threw me for a loop at first, but functionally, working files _are_ tabs. Just Sideways. I get that they don't look the same, but after a little bit of use the interface actually feels cleaner. I've yet to run into a user of tabs that isn't accomplished by the working files in the sidebar.
What's the problem using 'this'? You're just making problems where there are none.
First question I'm asking myself is why you include lodash if all you need is forEach, reduce and extend. All of these are available natively
https://crypto.stanford.edu/sjcl/ perhaps
```[].some(fn)``` can also be used to break the loop as soon as we find an element for which ```fn``` returns true. The difference between ```some``` and ```find``` is that ```some``` would simply return a boolean (which is basically the answer to the question: is there any element of the array that satisfies ```fn```?) while ```find``` returns the first 'successful' element itself.
You can pass in the same function used for `onComponentShouldUpdate`. It depends on what flavour you are using to construct your vNodes. Are you using JSX, Hyperscript, `createElement` or simple object literals?
No idea, haven't ever used it... You could set up a simple test though 
its ported from node version...
Just letting you know that you don't have to reinvent the wheel.
&gt; The truth is, most Fortune 500 shops aren’t basing their businesses on JavaScript and never will. I'm not sure what to believe here Granted... #1 Fortune 500 ... Walmart was convinced by formidable labs to transition Walmart.com to React. The rest of the top 50 in the fortune 500 are companies like Exxon Mobil, who don't open source or give any details about the software that they use. Are they mandating Javascript to develop all their internal apps? Who knows. Maybe they're all using Coldfusion, Flash and ActiveX. 
Yes, I must admit PyCharms "View Local Changes" list has helped save me more times that Git history has.
&gt; It is a syntactical sugared for-loop. No it's not, it has vastly different behavior and saying it's just syntactical sugar over a for loop is misleading (and wrong).
Instead of just saying it's very different, please do elaborate. It's different, but I wouldn't consider the functionality to be *vastly* different besides the no-breaking limitation. I'm looking at the polyfill for it right now and it is just a while loop with a callback that is bound to a `thisArg` with element, index, and array. Do let us all know how amazingly different that is from a for-loop.
True, but I've found that junior devs are actually more expensive than senior devs, not in absolute cost terms but in terms of cost:output ratio. Where I work junior devs earn about half as much as senior devs, but deliver less than half the value.
A junior could become senior in 1 - 3 years? Unlikely.
It has its own scope, can't return early, doesn't iterate over array "holes", doesn't iterate over added items. Although it's only implemented for arrays, the uses of forEach is much more general than a for loop and works for other data structures like trees, observables, etc. Other than the difference in behavior, it's not syntactical sugar because there's no special syntax for forEach, it's just a function.
Yes, you're right. I phrased it wrong.
Because some people want to use Bootstrap 4 now, and not in a year, and react-bootstrap won't even start migrating until bootstrap is out of beta.
There's no built in way to break out of a `forEach` that makes it obvious that you're breaking out of it (you have to throw an exception or do something else wonky). Use`forEach` to iterate over every element. Use `for (;;)` to iterate over some elements.
I've been using Sublime for years now, but just installed Webstorm to try out. It's kind of nice having a similar environment for all my dev work (Android Studio, IDEA, PyCharm, now Webstorm), and it's great having an IDE for when you're learning a new library or framework. It used to be Visual Studio (which was an amazing environment back when I used it, but I don't do any .NET any more and I don't know what it's become since 2005) and Eclipse, but I'm a lot less Java focused now and Eclipse seems so clunky to me now. I think it's very important to understand how to do things without an IDE, but I find it increases my productivity immensely, but like using yeoman or Roo. Let the IDE handle the bookkeeping, let me focus on the logic and code. I just wish it's Vi mode was better, but Sublime has that problem as well, none of them are really Vim. Bonus is Webstorm's support for code formatting of Typescript, which Sublime's Codeformatter plugin doesn't yet support. And none of them seem to handle copy/cut/paste buffer integration with the underlying OS correctly or consistently, which is an eternal source of annoyance. 
Not Microsoft themselves, but VSCode. It was released in competition with other editors like Sublime and Atom. Atom was open sourced and had a huge extension API. Sublime had a ton of ton of plugins and was very fast. VSCode originally released without any of those things, but now has caught up.
I agree with pretty much everything you've said, except I didn't really like Spacemacs. 
That would be really cool, but I can't find any source for that. Do you have one?
Just different tools for a different job. Usually I'll have visual studio open for quite a while, maybe even days at a time, for one project I know I'll be working on. Code, sublime, and others are much better at editing singular files or non-project files, or when working with languages that visual studio doesn't really support (like stylus).
&gt; native-crypto This looks amazing! The number of dependencies is a bit crazy imho, though I understand that you're performing encryption as well. Nice work!
Not right now by obvious Google searches "sublime history gvim" etc. 
Good to hear! Thanks for letting us know. We've also gone back on all the previous episodes and cleaned them up to not kill everyone's eyes.
Here's a stab at a nice "literate" solution: original = [ {id:1, tags:['alpha','bravo']}, {id:2, tags:['bravo','charlie']}, {id:3, tags:['charlie','delta']} ]; function asOccurrences(obj) { return obj.tags.map(function(tag) { return {tag:tag, id:obj.id}; }); } function addOccurrence(allOccurrences, nextOccurrence) { allOccurrences[nextOccurrence.tag] = allOccurrences[nextOccurrence.tag] || []; allOccurrences[nextOccurrence.tag].push(nextOccurrence.id); return allOccurrences; } _.flatMap(original, asOccurrences).reduce(addOccurrence, {}) As others have said, this doesn't lean on lodash that much, except for flatMap. You could dress it up further by following /u/jellatin's advice and use lodash/fp: reduce = require('lodash/fp/reduce'); flatMap = require('lodash/fp/flatMap'); compose = require('lodash/fp/compose'); // asOccurrences and addOccurrence functions are same as above var collectOccurrences = reduce(addOccurrence, {}); var allOccurrencesAsList = flatMap(asOccurrences); var allOccurrencesAsObject = compose(collectOccurrences, allOccurrences); allOccurrencesAsObject(original); 
Every evaluation of a function(){} expression must create a new function object. This is not an "implementation detail", it's in the ECMAScript specification and is easily observable using the === operator: function foo() { this.bar = function(){}; } var x = new foo(), y = new foo(); console.log(x.bar === y.bar); // false You can also set properties on one of these function objects, and they will not be visible on the other.
I don't think there is a completely satisfactory alternative. You can use closures to get rid of `this`, but typically you end up with multiple copies of functions. You can hoist those functions to a higher namespace and add additional parameters, but you eventually end up having to replicate something similar to prototypes to have the equivalent semantics as prototypes. I don't ever want to use `this` in my code either. It sucks. You could add a com/trans-piler step that adds in `this.` for you though.
With destructuring (longer, but less in-code dereferencing): &gt; input.reduce((o, {id, tags}) =&gt; tags.map(t =&gt; o[t] = (o[t] || []).concat(id)) &amp;&amp; o, {}) To lodash, for OP: &gt; _.transform(input, (o, {id, tags}) =&gt; _.map(tags, t =&gt; o[t] = (o[t] || []).concat(id)) &amp;&amp; o) If you can count on `tags` being an Array (and are running with JS 1.6 or newer), you can use the built-in `map`. &gt; _.transform(input, (o, {id, tags}) =&gt; tags.map(t =&gt; o[t] = (o[t] || []).concat(id)) &amp;&amp; o) _.transform is like reduce, but will implicitly create your accumulator as a new `{}`, if you don't specify it. 
That still doesn't rule out sharing. An implementation could have a lightweight "function object" that includes a reference to the execution context (closure variables) and any per-instance attributes, if any, and a pointer to a single copy of the heavyweight function body, which is shared between all instances. 
Just be aware that you have to deal with the this context inside the forEach loop. Either by providing an argument for the context as the second argument or through a closure. In general I'd stick with the standard for loop since it's more flexible and readable - and use forEach when it makes sense (chaining etc).
Unless you modify the array inside your loop it will be since it's single threaded. And modifying an arrays length inside the loop is a big no no since time immemorial - especially with a forEach loop. Perhaps the only legitimate reason to do this is deleting elements from an array - in which case you should always for a standard for loop (and decrements the index on splice) since forEach will fail with consecutive identical elements (only removing the first).
Looks similar to my [task-runner](https://github.com/bvaughn/task-runner) library.
&gt;differently to the classical var keyword which has a global scope. really?
Pale in comparison to Emacs and Vim.
I'm super open to any ideas or new features you guys think would be useful. Please suggest them as I would appreciate the extra mindshare.
This kind of stuff makes JavaScript an unmaintainable mess. Anyone coming into a project built with this kind of stuff is going to have a hard time knowing what code is there to solve the actual problem and whats there to implement functionality in Java, C++ etc. ES5 is not the language to use if you want to implement a OO system. You're just seriously overcomplicating things to force OO on ES5.
This looks really awesome! I love the examples you've given for querying, it's a really nice approach overall.
First off: yes AES-GCM is the best cipher mode available with the SubtleCrypto API, but that would require the API to be fully implemented which is still not the case. On the splitting hash output issue: SHA-512/256 is a 256bit hash made from simply discarding half of SHA-512 output, in general you can assume that every bit of a *correct* hashing function is as good as the others. But there is a problem with buttercup's case, a pass-phrase contain far less entropy than the 512bits required. This issue could be solved by either using two PKDF with different parameters or encrypting 512bits of random data with only one PKDF output.
how did you learn all this javascript/es6 and design patterns.
To answer your question directly, go here https://github.com/DrkSephy/es6-cheatsheet, look at your own projects, and see if what you see there is applicable. As you integrate more and more new features, it'll start to get more natural. Then, since that resource isn't super complete, go here http://exploringjs.com/es6/, which is the best es6 resource by far, and see what you can apply to your code again. Now to ramble for a bit. Really it boils down to the fact that I've been coding very frequently in JS for a year. If I tried to learn everything I know now, all at once, I would probably get flustered and quit. The thing to keep in mind is having a mentality of always wanting to improve and learn more. I really try to dig into the "why" of everything. In the past year I've asked [90 questions on Stack Overflow](http://stackoverflow.com/users/3772221/ar7?tab=questions), I constantly make issue threads like [this one about understanding MobX](https://github.com/mobxjs/mobx/issues/199), and [this one about understanding redux](https://github.com/reactjs/redux/issues/1385), and I try to really understand the problems I'm trying to solve. This mobx-store that I made isn't just a random experiment, it's something I really needed. Also it didn't start out looking so hot either if you go back through the commit history. The point I'm trying to make is that if you just say "I'm going to learn design patterns," and you don't have a strong reason for doing what you're doing, then, unless you have built up a lot of discipline, you'll probably end up giving up on it. Make something, take a step back and look at it, have others look at it, and then ask questions about what you can improve. 
Appreciate it!
I think forcing an array structure isn't a good idea. In many usecases you actually want a Map or Record or Set or any other type of data structure.
How about this? MobX exposes it's own observable map type, meaning all I would have to do is extend it to add undo/redo. Additionally, the declarative querying is actually decoupled from the store itself (it's also exposed as a top level export). Meaning we could have something like this be observable as well import { storeMap, chain } from 'mobx-store' const UI = storeMap({ loggedIn: false, visibleElements: [1, 2, 3] }) chain(UI.get('visibleElements'), filter((x) =&gt; x &gt; 1)) What do you think? We can discuss here https://github.com/AriaFallah/mobx-store/issues/17
Yeah of course. There's a lot more detail here if you want it http://exploringjs.com/es6/ch_first-steps.html#_from-var-to-letconst. The gist is that `const` in es6 doesn't mean that the value is immutable, but rather that you're never going to reassign that variable using `=`. Thus, almost everywhere I've seen, people recommend that you prefer const when you don't reassign your variables to make that clear.
I just tried the demo and whenever I would jump everything else would jump (including trees and buildings). Would jump again.
That's numberwang!
Yes there is no Record in JS other than just using Object literals, but there are many libraries that provide it. Immutable.js being my favorite: http://facebook.github.io/immutable-js/ In JavaScript Map's you should almost never use non-uniformly typed keys and values. That isn't the purpose of a Map. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
Seems like an abuse of the switch statement that would be better suited to an if / else set of statements. It's no shorter or cleaner using switch when you'll have to keep typing 'case' and 'break' all the time anyway. In any case, pay it forward and try to make the life of the next developer who picks this up a little easier. In my opinion, sometimes the quest for simplicity and elegance is actually a trade for vague obscurity. There's no harm in typing something more basic and straightforward if it means you can get the flow across more explicitly. 
I think it's a bit poor reasoning. Apache should check whether the file or location requested exists and if not then always direct to app entry point. It shouldn't be that difficult to do.
One of the Chart.js contributors here. Version 2.0 is a massive overhaul of the underlying library focused on ease of use and extensibility. Hundreds of issues from the 1.x branch have been resolved, making Chart.js even more stable and user friendly than ever! Here are a few of the core changes: - Github Organization: Moved from github.com/nnnick/Chart.js to our own org, github.com/chartjs/Chart.js, where we hope to continue to grow the awesome community - Scales: New time axis, log axis and multiple axis support - Animations galore: Just about everything animates now, from adding/removing datasets, updating data or even changing colors. Based on canvas, animations run at 60fps even with tens of thousands of data points - Dynamic config: It used to be difficult to interact with a chart after creating it, but now it is as simple as changing the object and calling the update function - Mixed charts: It is now trivial to put a line on a bar chart or whatever combination floats your boat - Legends: Now supported for all chart types, they can be placed anywhere on the canvas and support toggling data visibility by default - Chart types: More charts supported out of the box, including stacked area/bar and bubble charts - Labels: Built-in chart titles and axis labels make it easy to understand your data - Responsive and mobile ready: Charts, labels and legends all scale down to accommodate any screen size out of the box, with touch event support - too much awesomeness to list here Moving forward, the core team is committed to a faster release cycle. Version 2.1 is slated to come out in the next week with: - Plugin support: Add optional support for features like zoom/pan (forthcoming) without adding bulk to the core library - Shared data between charts We'd love your help, so please join and contribute! We have a very active Slack community that you can join at https://chartjs-slack-automation.herokuapp.com. We'd love to add new chart types and to get the documentation translated, so if you think you can help, we'd love to have you!
What you're looking for is `with` It is confusing and results in buggy code, so it was removed in strict mode ES5 and later. You can read about it, and some reasons why you don't really want it, here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with The safest alternative to do what you want, as another commenter observes, is object destructuring. You might begin your method like this: ```` Foo.prototype.bar = function() { const {a, b, c} = this // do stuff here with a, b, c. } ```` or if you follow natziel's suggestion (which I would strongly recommend) ```` Foo.bar = function(foo) { const {a, b, c} = foo } ```` This doesn't help with setting. I hope you never want to set anything tho; mutation is a grave sin. Also, assignment with `with` probably doesn't do what you want (insofar as it's weird) so you haven't really lost anything by losing it. Otherwise, perhaps write/find a compile-to-js Java-like language... :)
It's hard to make recommendations without knowing more specifics. - How many LOC is the app now? How heavy is the UI? How many requests to load it up? What size it? - "This is getting cumbersome"...in what sense? Slow perf? Large payload? Difficult to maintain? - Are you using Ember currently? If not, what? - What browser support do you need? Generally, a single js file is best since it will be cached. In the age of multi-megabyte pages, even large SPAs can comfortably load in their entirety without much trouble. But again it really depends. I can recommend a fast 16k framework, though being its author makes me biased. -- https://github.com/leeoniya/domvm
&gt; you can't even use it in browsers yet without a transpiler Not entirely accurate... You can use let, const arrow functions, classes, object destructuring, rest parameters -- most of the syntactical changes in the language -- with modern evergreen browsers. Only old-IE, mobile browsers and safari has minimal/spooty/non-existent support. https://kangax.github.io/compat-table/es6/ Depending on your target audience - you can definitely get by without a transpiler. And actually, many of them have better support than babel - although, most of that extra support comes from things in the engine that can't be replicated with a transpiler (like subclassing globals) 
This is true, but I don't know who's target audience is evergreen non-mobile browsers lol. That's setting yourself up for failure. Even if you're only targeting a highly technical audience, broken mobile should prevent you from launching anything. So, while you can *test* your raw code in browsers, and I do, I would expect only amateurs to release that code without transpiling and you should expect drastic failure, as the current environment stands. 
Very impressive! Nintendo reps avert your eyes, nothing to see here. Just wondering: is there a particular reason you didn't use something like [Pixi](http://www.pixijs.com/)? Optimization and control, I assume? Or just for fun?
The answer to the first question is time and experience. There's no way around it. As for the second question, I was handed a big feature for my first project and my first thought was, "Fuck, I don't know if I can do this." The biggest challenge was just staying level-headed and not letting myself feel overwhelmed. The feeling never really goes away. What happens is that you start to understand that not only is it normal, but it's also healthy, because it keeps you on your toes and it keeps you humble.
Will modules be required to be put into a specific directory like npm_modules or would it just import directory? 
Because unlike arrays, iterators may not iterate over finite data
You are not learning anything outdated unless they are teaching you to garbage collect your own variables. It is good to be able to use the basics. You may need to use the basics later because some game engine converts JavaScript to C, and the developers of said game engine did not implement ES6+ because that's wayyy too much work. 
Check out the side bar over in /r/learnjavascript - should have plenty of resources for you.
I thought the same thing. And then it hit me, 'this' is very important when you don't have the luxury of using it.
I'm literally just here for the MVC frameworks that can build my steam bot for me
`for of` still allows for a `break`. `filter`, `map`, and `reduce` operate over all contents in a given `Array`.
i suggest you to ask at /r/reactjs as well. yo ucan get more quality answers there.
&gt; That's entirely an implementation detail. That's flat-out wrong. It is explicitly specified that multiple copies must be created in this case. Now, sure, a very clever implementation might notice that it can disobey the spec in this case without your code noticing. But it would be absurd to depend on an implementation deviating from the spec, and as a result of static analysis of your code no less. Just imagine the debugging session where performance dropped 800% because of a change that literally does not interact with the code it slowed down, only to find out that the problem is how that line interacts with the extremely complex and entirely undocumented system the implementation uses to decide when it can cheat. Write code that works, not code that hopes the implementation is smart enough to make it work.
Why do other languages implement this? Like c# with linq? 
Awesome job guys! Can't wait to use it.
Amaze! I will be digging through the source when I get off work this evening. So smooth, well done. As a side note, very keen to dig through that interpreter. It's one area I always get stuck on in the gamedev world. 
Amazing job! Can't wait to have an excuse to use this.
&gt;[**Anchorman Jogging [0:16]**](http://youtu.be/B6nFhcI4tgI) &gt;&gt;I do not own any of the material used in this video and will remove it on notification &gt; [*^PatrickRundle*](https://www.youtube.com/channel/UCPKheRTL8LbSuUdRstrGCxg) ^in ^Comedy &gt;*^52,890 ^views ^since ^Sep ^2013* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
Very exciting. Great job guys!
That doesn't matter. Iterator#map() would return another Iterator, lazily computed so that it works on infinite sequences.
chart.js vs d3.js? whats the difference? ease of use? Seasoned d3.js user here.
This is not unique to JavaScript, though other languages handle it better by implicitly passing on the context to the first argument of the method, Python for example: class Foo: def bar(self): return 100 def baz(self): return self.bar() This makes it clearer that if I take `bar` or `baz` out of the object, I now have to explicitly provide the `self`. That said, methods, by definition, describe behavior of an object they are called upon. Decoupling the method from the object doesn't make a whole lot sense semantically, e.g.: // This describes behavior duck.quack(); let quack = duck.quack; // This is semantical nonsense quack(); In perfect world we would never have to decouple methods from objects, but since JS is also heavy on using callbacks, events and such it's sometimes unavoidable. In many cases those mechanisms come with a way to explicitly pass on the context without much friction (such as the `forEach` method). As long as you are aware what are the gotchas where you have to explicitly bind context to a method (basically any time you pass on `duck.quack` without parentheses), there is no reason not to use `this`.
&gt; 5.1 has a preliminary support for WASM. You can enable it via the flag --expose_wasm in d8. Alternatively you can try out the WASM demos with Chrome 51 (Beta Channel). Woot
Irrelevant. You could do for (const e of infiniteIter.map(f).filter(g)) { if (test(e)) break ... } Also `some` and `any` break early. And you still have exceptions.
That, rust, anything functional really.
It is currently being considered as [Observable](https://github.com/tc39/ecma262). It was probably left out to keep the Scope of that reasonable. If the proposal becomes bloated, there's less likely that it would be speedily adopted/implemented by the major party/engines. 
Look into how C# and Java do it. They have terminating operations that use up the iterator.
The last line in my example does precisely that, it creates a new iterator and maps it. But at that point you're not mapping the iterator. You're mapping the iterable. It doesn't make sense to put map on an iterator. It's loop state. You put map on an Iterable, or Enumerable, or Collection. You can map a tuple, or a dictionary, or a vector. You know what none of those are? An iterator.
a node is simply an element in the DOM
you can also `for (const e of iterator) {}` twice and it will behave exactly the same. you’re missing the point. none of what you’re saying hints at &gt; It doesn't make sense to put map on an iterator many languages work exactly the other way round: let new_vec: Vec&lt;_&gt; = old_iterable.iter().map(|e| e*2).collect(); this is rust. it *only* defines `map` and friends on iterators (returned by `.iter()`), which means that it’s trivial to create your own data structure that has support for `map` and friends, *and* to create it via `Iterator::collect()`. much more elegant and makes more sense. in JS it would look like this (as you couldn’t implement a generic `.collect()`): let newArr = Array.from(oldIterable[Symbol.iterator]().map(e =&gt; e*2)) obviously if they went that road they’d have used something prettier than `[Symbol.iterator]` 
Thank you!
Shameless self-promotion: The library `nitter`does just this using the experimental `::` syntax in babel. It can also be called using functional syntax. https://github.com/YoloDev/nitter/blob/master/test/map.js#L12 This test shows only arrays unfortunately (I should amend that), but it works on anything that implements the `System.iterator` protocol. You can call the functions (like `map` and `reduce`) in 2 ways: [1, 2, 3]::map(x =&gt; x * 2) // if you support the :: syntax map(x =&gt; x * 2)([1, 2, 3]) // functional syntax, usable in ES5 The second way is intended if the pipe operator `|&gt;` ever get's added to JS (coming from F# land in my case). It allows to do some nifty stuff like the following [1, 2, 3] |&gt; map(x =&gt; x * 2) |&gt; toArray(); For now though, the `::` operator allows for easy chaining.
Quite pretty.
I just wrote this... let me know if there's anything I should add as I would love to have all this info on one page for my own benefit.
yeah I may be wrong there
How would this work? How does clojurescript know what nodes need the wrapper and what ones don't? Maybe you should try this https://github.com/trueadm/cerebral-view-inferno as a starting point. I use similar with Redux.
Do you have any examples of what sort of situations I could use this in? What advantages does it have over just using underscore on a JavaScript array/object?
&gt; there is no reason not to use this Disagreed. `this` exposes data on the public scope of an object, making encapsulation impossible. var User = function (age) { this.age = age; } User1 = new User(23); User.age = -99 // shouldn't be allowed to do this. Meanwhile factory functions allow inherently private scoping, and therefore encapsulation. &gt; As long as you are aware what are the gotchas That's not an argument. There shouldn't be gotchas. That's how bugs are introduced into software, even by experienced developers. So I would say there's no reason *ever* to use `this` (unless you need thousands of instances of an object). You get more reliable behavior AND inherent privacy when using factory functions.
I have zero experience with Unity, but it seems like generators replace my interpreter and should perform much better, too. I had the same idea as you, but tested the async|await feature, instead of yield. The first problem was the browser compatibility - the next, that babel adds about 60kb to the output file to support it. If there are no problems as above in Unity, you are absolutely on the right path and the generator thing should definitely work and spare **much** time. Thanks for this neat tip!
Sorry I confused the situation - I'm using JS too (used to use Unity, but have moved to Phaser). Browser compatibility is probably the biggest issue here, and you are right about the babel extra size - but for now I think I might wear the size, as it will get smaller as browser support gets better. There are just way too many es2015 goodies at this stage to ignore babel in my opinion. What's the next step with this project?
Thanks for all your hard work! Looks fantastic!
I'm really starting to like vue. Hopefully it will get the credit it deserves in 2016.
I've picked a charting library over D3 or another custom solution and got burned. For complex, non-standard charts, it's often best to roll your own.
I subscribed to laracasts for the laravel stuff and didn't realize there was all the other subjects. He talked about how vue would get big in 2016 so I checked it out. It seems pretty good and now my boss wants me to do a site that seems right up that alley. I love finding a cool tool and then actually needing it.
View is like Angular 1 but with human-understandable documentation. 
I wanted to share my latest course on skillshare. Its free for the first people to click the link
I agree. I used NVD3 (which uses D3) in a project and was disappointed in how buggy it is and how slowly new releases come. 
It only gets better from here on out. * Components are basically a russian doll of nested Vue instances, with equally nice syntax. * custom events for communication between components is equally easy: HTML: &lt;child-component @custom-event="handler"&gt;&lt;/child-component&gt; in JS: // from the child component: this.$dispatch('custom-event', someItem) // handler in parent component methods: { handler: function(someItem) { ... } } // or (no need for the above HTML markup in this case): events: { 'custom-event': function(someItem) { ... } } * custom filters and directives * it has it's own official router plugin * it has its own official redux-inspired store plugin "vuex" * and beautiful dev-tools to access all of this properly in the console. 
Is there a web based version? 
When I first started using Vue, pretty much anything I did, my thoughts were "Wait... It can't be that easy. I must be doing something wrong..."
&gt; How would this work? How does clojurescript know what nodes need the wrapper and what ones don't? All data structures in Clojure are immutable. You just have to have a `shouldComponentUpdate` that tests if the current props map is not identical to the previous one and everything works. You put the sCU on all components that take props.
VueJS passes the 90yr old highschool dropout grandmother test. ReactJS and Angular2 don't. 
Vue and React are quite comparable as they both are viewlayer libraries and advocates of separation by concerns instead of technology. Their major differences are of community and philosophy. React prefers all in js route. Meaning you write HTML and CSS in js. Not many lime this approach. Most of the dev still prefer less/sass over inline jss. Vue, on other hand, allow devs to write HTML as html/Jade. And CSS as CSS/less/sass/stylus etc. React, undoubtedly, has bigger community and hence react's ecosystem is growing faster than Vue. Whether fast-growing-ecosystem is good or bad, is debatable. This is, of course, very simplified answer. You will have to make a trivial app in both of them to truly appreciate their differences.
Hmm, seems to be buggy. I get screens like this (in Chrome) quite frequently: http://imgur.com/CqtRsdh
You don't need to use inline styles in React. My project uses less with separate stylesheets which works well for us because it's an application with minimal graphic design flashiness and it doesn't have to share individual components with other projects.
Looks very cool. Does this support relational databases?
I am using inline styles in Angular with `ng-style`. Isn't it possible in Vue?
Yes, it's possible.
why can't you encode your jpeg out of canvas element ? https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL javascript will not be very performant at encoding jpeg. There are tons of bit operations on integers. This is a perfect example of something that should be farmed to C code and which, ideally, uses SIMD type operations as well.
does anyone have any opinions of this vs. Aurelia? 
Of course you're mapping the iterator. E.g. const arr = [1,2,3,4,5,6] const it = arr[Symbol.iterator] it.take(3).forEach(console.log) it.map(e =&gt; e**2).forEach(console.log) will log 1 2 3 16 25 36 All languages you mentioned (except for F# which I know nothing about) operate on streams/iterators. Except for JS. JS exhausted iterators don't work further? Thats also different from other languages and makes no sense IMO. The object marking the end could simply be returned each time an exhausted iterator is queried. Like in Python, where more StopIterations are raised. Or Rust, where it will return None again and again.
"I built a framework that solves the problems I presented, and now I am trying to convince you why it isn't just more noise" You are making up problems to justify business capital. "Rest easy while we take care of managing infrastructure. Focus on the now, and pay only based on what you use." Lol.
The first paragraph just explains the term “iterable”
The advantages are purely preferential. I think of Vue and React as solving the same problems in different ways; if you prefer to work with templates over JSX, and like a very clean, easy to read and easy to write syntax, Vue is a great alternative to React. I think Vue and React basically coexist peacefully and there's not much benefit of one over the other. But as far as template-based frameworks go, Vue beats everything else I've tried.
What I don't understand about using inline styles in react is how to use pseudoselectors and pseudoelements? I'm not sure it's possible to do inline so that's a dealbreaker for me.
With the added bonus you now can create other visualizations without relying on libraries, I wouldn't say using D3 is amatuer. 
well yea, I agree with this
[like these people](http://clientsfromhell.net/) /s
They're both great and have their use cases. Here are the key differentiators for me. 1. Canvas vs SVG: For my use case, using svg with d3.js for lots of data points really slowed down the DOM. Canvas doesn't have that limitation and is easier to export to images if necessary. SVG is nice because you can use CSS to style things. 2. Chart types: d3.js has more chart types currently supported, but we've added more with this release and made extending / creating new chart types 100x easier. Previously custom work was much easier with d3, but the gap is now significantly reduced. 3. Turnkey: Like other users have said, Chart.js is opinionated and looks great out of the box. d3.js can definitely provide great looking charts, but typically takes a lot more work.
You'd have to `v-bind` a style object to it but yes, it' possible: http://vuejs.org/api/#v-bind There's actually _a lot_ of Angular in Vue. It's sort of like a Reactified, simpler version of Angular
Vue : Backbone :: Aurelia : Angular/Ember Aurelia aims to be a full-fledged framework whereas with Vue it's more widet-based. There are awesome things like vue-router, which adds routing, and Vuex, which makes state-management simpler, which make making an SPA with Vue better, but they're optional. Aurelia is like Angular/Ember where they try to have an all-included solution for all your SPA needs.
As someone who really loves vue, vue-router can be very frustrating. And just like any other framework, validation can be a pain. 
Not "natively" but you can have a webpack setup where you require the necessary less/sass/etc file for the component so it's still in a separate file and gets processed on build.
Is ng-style a standard thing? I can certainly see it being useful, but I thought the whole point was that you can't write CSS in your templates.
That destroys the single file component. One of the things where vue really [shines](http://vuejs.org/guide/application.html#Single-File-Components).
What is it with vue-router that is frustrating? I haven't had any issues yet. 
What makes Vue better suited for canvas work?
To make it clear : I don't know if Vue is better or worse for working with a canvas, but since the main focus of react is for working with the (virtual) dom, I feel that reacts strength lies in the dom handling.
React has never recommended any of the css-in-js variants. The general idea for inline styles comes from the React Native team when they adopted the Flexbox model as the preferred layout system. They thought it might be more generally useful and the React community has pretty much run with it. I've never found it compelling.
var rjavascript = document.getElementById("our-subreddit"); rjavascript.classList.add("cool"); There ya go.
http://www.wonder-tonic.com/geocitiesizer/content.php?theme=1&amp;music=11&amp;url=www.reddit.com/r/javascript/comments/4gezou/meta_why_is_our_surbreddit_so_plain/ What about this?
I work on contract for an agency. Clients vary a lot. Work ranges from projects for content creators in the Film/TV industry to projects for companies in the auto industry (both startups and more well established players). Prior to that, I also did freelance work for clients in the medical space (e.g. large destistry and podiatrist companies), ranging from marketing Wordpress sites to iPad applications. Investor-backed projects have the most interesting projects. There's a ton of people who want Wordpress work, but those types of clients are usually cheap.
It makes sense now, thanks. Last time I saw `const` was Pascal.
IMO people are too critical on /r/JavaScript. Though I think that's an internet problem as a whole. Someone posts something, 1 person likes it, 20 people find a way to argue about it. One small thing that would be neat is a popup over the downvote button to remind people the button is for keeping content that doesn't contribute down, instead of a "I don't like this" button.
&gt; I guess it's because they're just to just including a few scripts like jQuery in their HTML and their done with setup. I'm not sure those are the setups that are a pain (people still use jQuery?). Actually setting up a project with React, Redux, Webpack (or other module loader), Karma, Mocha, Gulp, Babel then configuring it all to have build / release tasks, unit testing tasks, hot reloading, transpiling for tests / mocking etc. 
Developers, not designers. Clean, efficient, standardized.
Neither have I. I just can't bring myself to write CSS in JS. 
In my team we have a pretty complex rest api, and I feel like we ran into all the problems of REST possible. 1) complex get operations with so many params we had to make a custom verb with a body. 2) parsing field lists, to provide a way to get only required params. Etc. Graphql looks like a good solution to enforce the interface between the server and clients, but I am not really sure if it is possible to fine tune it. In our rest api(in Python) we do pretty complex eager joins conditionally, and other sql techniques in order to group everything in a single sql query. What I've seen so far, it looks like graphql backend will make separate sql queries for every additional parameter I specify... Am I wrong?
Someone will eventually make a [freestyle](https://github.com/blakeembrey/react-free-style) loader that you can pipe css strings into. 
Theoretically (with 0 input time), /u/regular_reddits is the fastest (leaving /u/Meshiest's solution out, because that's cheating) at ~1.2 seconds. /u/rebane2001's clocks in at ~4.2 seconds. Since Infinity is rather special in its comparison, and also can't be created from bitwise operations, I doubt we'll see anything faster than /u/regular_reddits solution that is also practically possible.
Thank you so much! What do you think about the javascript and jquery book by John duckett? If you have seen it or read it.
Do I still have to specify all my colors manually, or is there a default palette?
Agreed, this subreddit deserves a dancing monkey that follows the cursor.
Looks like a decent tutorial, but it would be more helpful if it explained stuff like "2-Way Data Binding" before banding the terms around.
I'm a freelancer who has left the "Wordpress installs for clients from hell space". Instead I do contract work for tech companies/startups. The client can be anything but its always a company in need of some more manpower for a few months. I don't have to sell or deal with clients or do any of that shit anymore. Just solid full-time work with no long-term commitments. Really recommend it. Edit: May be worth noting I still have to sell myself to the client, but I don't have to sell the concept of a website anymore.
you could add your `` loadPage(); `` function to an event listener like so `` document.addEventListener("DOMContentLoaded",loadPage); ``
https://github.com/jquery/jquery/blob/master/src/core/ready.js
 function ready() { // do your stuff } // this is required for the (not so) edge case where your script is loaded after the document has loaded // https://developer.mozilla.org/en/docs/Web/API/Document/readyState if (document.readyState !== 'loading') { ready() } else { // the document hasn't finished loading/parsing yet so let's add an event handler document.addEventListener('DOMContentLoaded', ready) } Don't use load event, it fires when all sub-resources (CSS, scripts, ...) have been downloaded/parsed which can take significant amount of time; except if that's what you want of course but probably not.
One additional case that jQuery.ready handles is if the page has already loaded. The following uses DOMContentLoaded in addition to handling the already loaded case in IE 9+ function ready(fn) { if (document.readyState != 'loading'){ fn(); } else { document.addEventListener('DOMContentLoaded', fn); } } Source: [You Might Not Need jQuery](http://youmightnotneedjquery.com/#ready)
@leeoniy and @name_was_taken You both raise good points. TDD isn't for everyone, and doesn't suit every project either. My intention with these first thee posts was just to get people started with the basics of TDD. Something to help people give it a go. Regarding API/interface design, I mostly agree. TDD is a development tool, not an architecture design tool. I was trying to emphasise that in the article by repeating that you can't start writing tests without first *thinking ahead* and planning out an API design. Perhaps I could have been a bit clearer on that point though. I'm planning a follow-up post soon that will address things like when TDD isn't so useful, and how to use TDD in a way that doesn't end up bogging you down.
Sorry my point was that I wouldn't have imaged the compiler was 53k loc let alone 53k files.
The usecase for graphql is totally different here than what op mentions. [ui] &lt;--&gt; [model] &lt;--&gt; [web services] &lt;--&gt; [db] Over the course of the lifetime of an app, the rate of code-change is the highest in the UI and decreases as you go from left to right with the least in the DB. The model, in REST is contractual. With graphQL you move to a query model. The UI is free to pick and choose fields, query, complexity etc. ie once the schema is define, multiple clients (from watches to browser) can talk to the model with zero code-changes on the server side. On another note... does anyone know if there there any public graphql schemas out there ?
This popped up on here a few days back: https://github.com/sorrycc/awesome-javascript Its a pretty good list, but I'm not sure if it has all the information it sounds like you're looking for, like maybe a comparison table or something? It can take some research to find what you're really looking for.
It is great ! Thank you a lot ! The "Test" section fulfills my expectations :)
Christ, that's so true though. Every boilerplate has extra crap I don't need. So I made my own boilerplate! 
I don't know why `forEach` is even mentioned in this context. It had nothing to do with iterators. `for...of` is what really takes advantage of Iterators.
Hey! Thanks for the feedback. In my environment (tested on Chrome and FF) I can't see any blocks. Would you please take a screenshot? And specify your environment? Thanks!
Thanks for the link to that thread. The breakpoint video on that thread, actually helped out.
I hear ya. Partly to avoid the insanity and partly out of spite, I've been deliberately avoiding dependencies for [my OSS project](https://github.com/lhorie/mithril.js/tree/rewrite). If you look at this as an experiment, things have been... interesting. I did end up w/ a bit of reinventing the wheel, having written a custom test harness and a module bundler, but with this dev support code clocking at less than 300 LOC combined, it's not that bad (plus they were fun to put together). I don't even miss ES6 features, to be honest, and being able to run modular code without even touching the command line is nice.
You should check out http://angularcourse.com (disclaimer: I'm the author). It is very easy to follow and shows you how to build a full application even if you have zero knowledge of Angular to start with. The main differentiator from other courses is that it's focused on teaching you how to build things in Angular rather than explaining concepts in isolation. This is always the biggest problem I see with nearly all programming tutorials.
I like to version everything my project so that everything you need is right there for you. Surely Babel does the same that's why the project is so big? I think the number of files is just indicative of how complicated the project is, how _big_ it is. I guess I'm just questioning why it needs to be so big, so complicated? 
&gt; my OSS project Mithril looks great!
:) Thank you
Am I wrong in saying that responding with "That's cute" is being a condescending dick? For what reason was my post pointed out over the original comment?
https://www.reddit.com/r/javascript/comments/4fyivt/less_react_more_js_braindump/d2dxc35
Oh right of course. thats how npm works. 
What kind of business mode is it? Does it require a membership after a certain point. Or pay x amount of money? 
http://youmightnotneedjquery.com/
'x+=$' produces an interesting defect. `x = NaN` breaks the counter and allows you to cheat and buy characters without limitation. To fix the counter just reassign x to 0.
Haha GCC is huge. According to this site V8 itself is only 1657K https://www.openhub.net/p/v8-js I didn't count the actual loc in Babel, but I bet its getting close to V8 itself. Thanks for the heads up on Typescript. The reason I got excited about the whole es2015 thing was that most of it has landed now in Chrome and I don't want a compile step in my workflow. Right now I do all my development using uncompressed scripts, then "build" the project for release using uglify. I was thinking it would not be all that much more to add a babel step in there as well. I think I decided it was all a little too much work / complication for what amounts to some nicer syntax in my project. 
[removed]
GraphQL is still very new, I think it's early to form opinions about the potential of the technology. To put it a different way, the Rails of GraphQL is still to come, and there's a ton of potential to improve everything about the system.
can you explain to me the relationship between Asp.Net framework for web development in C# compared the open source stack (js,ang, node etc) I mean how they differ and can they do things the other one can't do ? What I don't understand is peoples seem to separate them in different roles like backend and the other frontend... why if node can do backend and c# and asp.net mvc can do everything the open source stack does ?
Thanks for the compliments, it was rather hard and took much more time then what I originally thought. Most of the time I work offline as I don't have internet access at home, so I never really committed learning codepen/github, not only that it's distracting anyway(internet that is, and expensive for someone who make 0$ :D), there is so much stuff to learn, very hard to stay consistent. I have working version of codepen. [cat clicker](http://codepen.io/noconnection/pen/dMqzPg)
In Django, you change tag. Sorry I forgot exact tag. I found it by googling.
Lol just got obsessed with working on it. The more it took shape, the more I wanted to work. After about 20 hours it was ~30 lines, and yet I was so proud.
x=$ does the same thing as x=NaN
This one is still faster, since you can insta-buy x=$ (can buy instantly) x="" x+=4
ahh, I bet it was something like that. I just checked and I'm on 2.7.4 
Unfortunately the Vue CLI embraces the bad practice of putting tests away from the source. Totally unnecessary.
As standard as the style prop in React world ;)
All the core content is free. There will be some optional content in the future that you can purchase. It's explained in the "Making free work" video.
Yeah, that'd do it. Since that is the case, I will also point out that requiring so many copies of the same code makes babel slooooooooow. I'm talking a difference of many seconds instead of milliseconds. When I encountered the same issue, my choices were a) update npm to v3+ or b) install babel 5.* I opted for the latter, simply because it seemed easier/less chance of breaking anything. `npm i babel@5.8.29` I haven't had any desire/motivation to update it since. An added bonus - it's "only" 5,159 files! Note that you'll have to find the corresponding versions of `babel-loader` (for webpack) and any other associated modules, if you're using them and decide to be lazy like me.
Why not simply `v-style`? I'd be tired constantly typing `v-bind:style` again and again.
So what?
There's some behavior around adding properties to objects where you need to use vue.set. 
wouldn't you need an extra set of parens so the &amp;&amp; and the !== happen in the right order?
[removed]
My point was the opposite, post everything, if it's not good it will not get upvoted and will not make FP. Though it would need to tweak what makes FP, instead of having the newest posts hit FP right away. You don't need to downvote stuff to keep it off your front page, just upvote the constructive stuff.
There really is no recommendation. People have their own preferences. I've seen CSS Modules with "Object" like CSS declaration that are inlined in components, Regular Sass structure ran through Webpack and loaded into the root, and then a hybrid of Regular Sass, but broken down and imported into the corresponding component. tools like PostCSS, Sass, Webpack, and more have made CSS fairly "do it however best fits your needs". 
Wat even is tilde?
well, actually, modern practices recommend to add "defer" or "async" attribute to the script tag (which allows to leave 'em in the &lt;head&gt;).
`this.` (or equivalent convention, like `m_` prefix) is absolutely necessary for readability, otherwise you can't tell whether something is supposed to be a member field of an object or a closed over variable from upper scopes.
This is terrible advice which will cause race conditions. 
For GraphQL, it's mainly the thing where you ask for exactly what you get. With REST APIs, you often have to make a series of requests and you can easily get back more information than you really needed. A GraphQL client can query for exactly the fields and types that it wants. I'll also put [graphiql](https://github.com/graphql/graphiql) out as a way to play with GraphQL APIs which works better than anything I know of for a REST API. As for Relay, There are some really nice benefits in that it will effectively diff your queries and only request the data that it doesn't already have. Implementing pagination, for example, is also easier with Relay than it is with a REST API, since Relay is often used with [Connections](https://facebook.github.io/relay/graphql/connections.htm) which use cursors. One feature of Relay that may not seem useful at first is that it masks the data from the GraphQL endpoint to each component. This means that any React Component can only access the data it specifically requested, making refactoring and debugging easier.
I took a bit of time and implemented your cat clicker in a virtual-dom view layer instead of jQuery: demo [1] source [2]. You can play live in this jsFiddle: https://jsfiddle.net/7ab662ff/2/ -- It uses JSONML [3] templates rather than HTML, but should be pretty easy to understand since it is just plain Javascript. You can see that it does not take very much code to keep everything in sync this way. If you notice, editing the admin automatically reflects everywhere else in the html (nav, click counter, name) simply by a redraw() call because the entire template is regenerated, compared against the old version and updated for you behind the scenes. A lot of manual DOM manipulation code disappears! -- Take a look, feel free to ask questions here or by opening issues in that Github repo if this is something that strikes your fancy. DOM and jQuery is still a must-know in general because it is used everywhere, but virtual-dom frameworks are both faster and more pleasant to develop with. -- [1] http://leeoniya.github.io/cat-clicker/ [2] https://github.com/leeoniya/cat-clicker [3] http://www.jsonml.org/
[removed]
This is great.
Find me boilerplate that does what I want, and I'll use it :(
One step deeper: http://youmightnotneedyoumightnotneedjquery.com/ ^^^istilldontgetthejoke
That results in unprofilable global slowdown http://c2.com/cgi/wiki?UniformlySlowCode
That's already done by any decent implementation, the function object allocation per method per object is crazy expensive regardless.
If you concat all your scripts into one file then it'll work fine. I don't use setTimeout myself but requestAnimationFrame instead. requestIdleCallback is probably better though (if supported).
Well, I am not so sure I fully understand your question but I'll try and gather some elements of answser. I suggest we somehow unstack "*the stack*". [Here is a simple example of a HTTP transaction](https://www.d.umn.edu/~gshute/net/http-example.xhtml) : do run it and think of what's happening at each of the 6 steps. In this simple example, the server responds with a static, ready-made HTML file that the browser is expected to render as-is. That's the www Berner-Lee envisionned in 1991. Now, as you already know, in most real-life contemporaty cases, the HTTP response is built on-the-fly server-side, amalgamating user input, database queries and other parameters. Once said HTTP is fully loaded in the browser, it's not ready to be rendered yet : here be JavaScript shenanigans, and don't get me started about CSS. In what follows, we'll limit ourselves to the HTML part of the response, although a complete answer would of course consider the full extant of [the HTTP lifecycle](http://blog.catchpoint.com/2010/09/17/anatomyhttp/). A lot happens server-side, so you need softwares that runs there. Said softwares include what you, the developer, write, and what's already there. The later includes obviously a web server, probably a DBMS, some identity management system, and some [length of ropes](https://en.wikipedia.org/wiki/Application_server) to tie it all together and *to deal with one fundamental aspect of HTTP*, that is its *stateless* nature. OK, so for now we're server-side. I'm not that familiar with ASP and C# but it's easy to see that they are strongly tied to the Microsoft world. It is also easy to see that not a lot of web servers run on Microsoft stuff. So there is that. Let's move to the other end of the tubes. We've arrived in the browser. It used to be that the phrase 'front-end' meant "everything that happends in the browser" and that meant mostly cosmetics and other rendering options. Nowadays, the average web page got fat, we came to expect and demand rich and swift user interactions, so a lot of things happen client-side before the user gets a chance to get a gimpse of the result, if at all. I dare you : peek a look at the JavaScript living in this very reddit page and tell me what it is doing exactly. Kind of a "back-end-in-the-browser". And oh, a lot of mumbo-jumbo lives here too actually, and quite a share of the grandiose terminology you can read here and there seems to be bloated and short-sighted. Nonwithstanding, "designing a web page" has become a software engineering endeavour, hence the growing emphasis on the toolchain. I'd say it's safe to overlook the later, unless you are suddenly tasked with reengineering Facebook or Amazon from scratch. Finally, to (hopefully) get back to your question : ASP, C# and consorts : good if you want pretty results quick, are willing to limit yourself to MS-World, and don't really care about what's really happening in there. All of which *might* be legitimate. Rest of the field : good if you want to build a durable and portable expertise, are able and willing to separate hot air from sanity, and eager to leverage the tremendous output of the open source world.
I agree. What resources can you recommend which help to prevent being such a developer?
Love the link! Really helpful, thanks :)
One day: https://github.com/whatwg/html/issues/127 ;)
&gt;written with an MVC framework which one?
I would never say to stay away from Babel - just to think ahead, which babel features are absolutely necessary and get a huge use in the project. The next step is fixing various bugs here and there, finish stuff like following pokemon and notifications. The final and hardest step is the editor, things like background tile map drawing, built-in code editor, entity add&amp;edit options etc.
[Image](http://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2807 times, representing 2.5874% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d2hr66m)
I recommend [EloquentJS](http://eloquentjavascript.net/). It's slow to start but gets pretty difficult. The first half focuses on plain JS, then the second half of the book is dedicated to the JS DOM API. I would definitely look at React after you've understood vanilla JS. Although you don't directly influence the DOM, you don't have the high level of inbuilt abstraction and comprehensive feature set you get with Angular either, so you end up learning how things work. [Kurt Weiburth's React/Redux series](https://www.youtube.com/watch?list=PLQDnxXqV213JJFtDaG0aE9vqvp6Wm7nBg&amp;v=fZKaq623y38) is awesome for a beginner.
Sure :) I took a look at spot.js and I just have one suggestion; I think it would benefit from a combination of throttling and using requestAnimationFrame. The FPS of the spot demo varies with usage, I think that using those two techniques would make the FPS more consistent. Throttling will reduce the amount of recalculations being processed, and requestAnimationFrame will give the library more time each cycle to do the recalculation. What did you do for your docs? I am at the point where I need to write up docs, but I am not sure what to use. 
"You don't know JS" book series is awesome, and is available for free on GitHub.
The author is a Java guy who doesn't like JavaScript... beyond which there isn't much substance. This is a behavioral problem and nothing related to technology. I see this (only a little tiny bit though) in my current office where the Java developers are forced to learn Scala. You can also see the exact same problem (the behavioral problem) in JavaScript developers when their favorite framework is taken away (or when you take away JQuery). The problem is reliance upon a set of tried and true conventions. Unfortunately the world is a constantly changing place. Your favorite bag of tricks aren't going to last forever. Whining about the emerging replacement (like the article) is roughly the equivalent of saying bad words and then putting your head in the sand. The reason why this behavior exists in the first place, and is extremely prevalent, and is so deeply rooted occurs for a couple of reasons. Solving problems in new and unfamiliar ways is hard. For some people it exposes that they are frauds who aren't really good at programming but were really good with a favorite set of conventions. For some people this impacts their ability to get or retain jobs and validate their existence. For some people they are immediately defensive without even realizing it due to a phenomenon called cognitive conservatism. At any rate shit people are always going to whine when change forces their hand, and there will always be shit developers. **EDIT:** The author does make one valid point (though the numbers are off). There are roughly 11 times more Java jobs in the marketplace than JavaScript jobs, but the demand for Java developers might only be 2-3 times greater than the demand for JavaScript developers. In some markets the demand is almost at parity. This scares the shit out of Java developers. I saw this fear when I was consulting to a major airline last year. **EDITEDIT:** duplicate - https://www.reddit.com/r/javascript/comments/4g5wsk/the_lie_that_has_beguiled_a_generation_of/
Then what do we do if we want to execute after the DOM is loaded ?
If you are building out dashboards with common charts, and even some uncommon charts, then it is. If you are creating cool visualizations for the NYT, or new visualizations for data analysis then it is not. 
Just found this: https://patrickhlauke.github.io/touch/touch-limit/ it could be great! For the docs, well I just went ahead and wrote markdown in README.md? What do you mean? I am re-writing the entire plugin now, using a modular pattern and constructing an object for every element I want to use spot.js on, that way I can have different effects on the same page. I'll also implement throttling, that was a great suggestion mate. I'll look into requestAnimationFrame too.
I read the article and I don't get it. What's the point the author is trying to make?
Don't ever listen to someone who says that a tool has no possible good purpose. All that says is that the author doesn't know how to use the tool. 
Also, very soon we well have a &lt;script type="module"&gt; tag, which is in ES6 spec and will allow us to completely forget about wrapping our code in iifes, along with other cool features. I recommend everyone to take a look at this article: http://exploringjs.com/es6/ch_modules.html
No, the minimum timeout is 4ms. https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout#Notes
[Image](http://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2809 times, representing 2.5890% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d2hteb8)
You can learn a lot from this tutorial also if you would like to know more about Ember.js: http://yoember.com
&gt; it's one thing less that needs to be maintained. _Ding ding ding!_
 function ready() { //do someting } addEventListener("DOMContentLoaded", ready, false);
"TypeScript helps prevent the simplest of mistakes as soon as they’re made:" My IDE catches typos, too. "TypeScript performs a very important function in our engineering process: it automatically runs an entire test suite every time a file is saved." TypeScript does that? Not your IDE or test runner? ... Weird. Oh, they mean it checks things that they didn't specifically write tests for. Yeah, my IDE does that, too. Put a docblock there with the types, and it'll hint them just like TypeScript. I'm not a big fan of things that try to *force* developers to do the right thing. In my experience, it leads to less-skilled developers being forced to get really creative, and you end up with some truly horrible code. If hinting them in the right direction doesn't do the job, then it's better to catch it in the code review than force them to spend long hours on odd workarounds and *then* catch it in the code review. Sure, they should *ask* someone for help instead, but if they were great developers, we wouldn't be in this situation in the first place, would we? Novice developers make all kinds of mistakes, and it's better not to compound the mistakes by trying to tie their hands.
Looks good! I guess the obvious question is, what has this got to offer compared to more established libraries such as GSAP, velocity.js etc?
Currently, there are 11 times more employees who primarily write Java versus employees who primarily write JavaScript. By *demand*, I mean what the marketplace wants. The marketplace is generally (and this does vary by geography and industry) wanting to hire Java developers 2 to 3 times more than they are wanting to hire JavaScript developers. The impact is none if you aren't looking for a job. The perception is that if you need to look for a job in the future your Java skills will no longer be valued meaning either no job, a job for less money, or a job with 3 times more competition among candidates. The primary fear there is the last one about increased competition. Just like with JavaScript the Java developers who are rockstars will probably always be able to find a job. The people who suck will be left without a chair when the music stops.
&gt; What small improvements could he make to his existing code and learn from? I would probably use some existing templating lib like Mustache or similar rather than inventing your own with regex replacements. Also check out the `&lt;template&gt;` element. Also there's a bug when clicking Save and the nav menu not updating to reflect the new name. &gt; Hey there, I mess around with this for like 5 days or so, you wrote it in like 10min, props to you man, hopefully I'll be able to do speed myself up in feature. To make you feel better it was more like 30min, and I had your code to work from :) Don't get discouraged, what you've done is very impressive and already using a lot of non-trivial features. If you had to rewrite this again you could do it in 3 days. &gt; I will definitely check jsonml in the future but I'll keep hammering vanila js Certainly. JSONML is not everyone's cup of tea, it's just what I chose for domvm.
No, of course *I haven't ever tried to create anything*. /s You're bragging about the framework you've created and that's ok. But claiming to have fixed the web is a little over the top, isn't it? You're just fixing *some* problems of *some* technology stacks. That's why your framework is still a framework, adding to the pool of other frameworks. That's why I found the linked xkcd relevant. Even though you aren't proposing one-to-rule-them-all framework, you're claiming to *fix the web*. That said, developing your own framework is still a good thing. Congratulations on that part.
Would be great if the documentation had a playground like c3js example: http://c3js.org/samples/simple_multiple.html
I'll (probably) get downvoted, but I'd suggest that in the interests of self-improvement you should avoid frameworks, preferring libraries that you can understand instead. This advice chimes with your distaste for magic. As far as vanilla vs React, if you can spare the time I'd suggest writing a small single page application either completely vanilla or using jQuery, and then rewriting it in React to understand what benefits there are. Your application should be small enough that this is achievable but big enough that it becomes messy ;) Everyone likes TODO lists, so maybe make one of them, with your own twist to keep it interesting.
For some reason your comment read so sarcastically. It made me laugh when I finished it. Thank you for the resources. 
For angular-specific patterns, the [John Papa](https://github.com/johnpapa/angular-styleguide) and [Todd Motto](https://github.com/toddmotto/angular-styleguide) style guides are pretty good too.
I gave this talk at the first ever [CycleConf](http://cycleconf.com/), that happened in Copenhagen last weekend. If you have any questions just comment in here :)
I'm not bragging, it's called "telling a story". So, you think I must shut up and keep silence, that's you're suggesting, right? About fixing the web – I really think so and it's my personal opinion that the WEB is broken (behind the WEB stands the majority of web-applications nowadays), and instead of complaining about it anywhere, like the most people do, I just tried to fix that creating maintainable, well-documented and well-tested production-ready solution which is used by several companies already. BTW, the framework was created a long time ago, even before people heard about React but as far as I don't have enough resources for pushing my solution in the community it's not that popular and has only ~500 stars on Github. Therefore, I decided to write that post, to attract people building a community around the framework. I'm not sure if you've read the post at all (it does seem so), but there is a part which is exactly about people like you who is mad about someone creating a new framework/solution/library/etc. Anyway, thanks for actual comment with your opinion, it's much better than a comics which says smth like "your solution is shit just because you have Not Invented Here syndrom".
This is the first video I've ever made so I would appreciate any feedback on it. There's discussion that inspired this is here: https://github.com/mobxjs/mobx/issues/199 Also two things that I need to clarify for MobX: * It is not exactly that one mutation mutates other values, but it updates the derivations based on the observable values. * In MobX you can still use actions, and even dispatchers if you want. It's not needed from a technical perspective, but you can still use them for readability. 
It enforces discipline that too many JavaScript developers seem to lack. I dunno. My solution isn't more tools, it's more education and skill development. I don't have a software engineering background so glass houses and all that. But I wonder if the lack of software engineering fundamentals is a source of why things seem so undisciplined in the JS community. 
Yeah, I see both sides of it. Something is better than nothing, and this sub isn't so bad at the end of the day.
&gt; force developers to do the right thing ... it leads to less-skilled developers being forced to get really creative What is "right" and "creative" is subjective. Programming languages themselves are tools created by humans for other humans to use. Whose Kool-aid are you drinking? Whose Kool-aid are you feeding to junior developers? 
&gt; [I]if they were great developers, we wouldn't be in this situation in the first place, would we? I've seen large code bases with excellent JavaScript developers find a fair amount of mistakes just by lighting up TypeScript. Don't assume that seniority makes you immune to simple mistakes, or suddenly imparts on one the ability to keep track of ever interconnection of code within your application. &gt;I'm not a big fan of things that try to force developers to do the right thing. In my experience, it leads to less-skilled developers being forced to get really creative, and you end up with some truly horrible code. If hinting them in the right direction doesn't do the job, then it's better to catch it in the code review than force them to spend long hours on odd workarounds and then catch it in the code review. TypeScript doesn't force you to do anything. It actually has more than one escape hatch for completely falling back on good old fashion JavaScript. No complex hacks here. &gt; My IDE catches typos, too. Then you loose static verification, comprehensive intellisense, intelligent automated refactoring, and a number of other powerful tools that even the best JavaScript IDE couldn't properly emulate even if it wanted to. &gt;TypeScript does that? Not your IDE or test runner? ... Weird. Oh, they mean it checks things that they didn't specifically write tests for. Yeah, my IDE does that, too. Put a docblock there with the types, and it'll hint them just like TypeScript. He does specifically call out unit tests right after that sentence I'd note. Adding doctypes can only provide so much information too and (correct me if I'm wrong) wont break build if you do something wrong. A great IDE plus something like ESLint can only do so much. Also Type systems like TypeScript and Flux (especially Flux) can express not only extremely complex types, but complex operations over those types. 
For jQuery I would test whatever methods it has available and get a grip on what they do using[jsfiddle](https://jsfiddle.net/). Also have some knowledge of how to do the methods jQuery without using jQuery [You might not need jQuery](http://youmightnotneedjquery.com/) As for angular I would recommend you start doing something like [Code camp](https://www.freecodecamp.com/) or your own simple website just to get past the "angular learning curve"
Thanks!
I was really excited when I first starting using mobx. It worked as advertised. I eventually switched back to redux though as I found the verbosity to a unique advantage. I just felt more confident about what my app was doing or what it could do, for that matter. Interested to see what kind of plugins will be made around the mobx family of stuff. Btw, clear video. +1. I like the fact that you didn't have any pomp and circumstance, just right into the meat.
It also has issues in ie9, which many people still have to support
Part of most software engineering disciplines involves the use of a type-safe language specifically *because* humans are prone to the simplest of mistakes (spelling, for example). Let alone more nefarious mistakes like passing data in one format to another part of the application that was expecting a different format. Simply assigning a named type to a data structure or function makes it not only easier for a human being to reason about the code, it makes it easier for automated tooling to catch errors you've overlooked. But really, the biggest advantage to something like Typescript is that intermediary static analysis that happens during compile, before code execution. It's just a massive safety net that catches issues even before you commit anything into source control.
Now I just have to wait till 2021 before I can use it in production 
I've always considered linting a kind of poor-man's replacement for static type checking. The idea being: &gt; Okay, JS is dynamically typed, so you can't analyze your source code and know whether you're using your variables in the way you meant to. Fine. Is there anything you *can* know from a static analysis? Well, here's a small pile of hints and warnings a static analysis could give you. Hence linting. Which turns out to be useful, but still leaves plenty of room for error. In that sense TypeScript takes linting to its next logical step: &gt; If we add a small set of constraints and annotations to the language syntax, can we begin to close the gap between mere linting and true static type checking? That's how I see TypeScript: like linting on steroids.
I see. I thought the "use of moved value" error was specific to an iterator, not a memory management error. I have not used Rust. I still maintain that map, does not belong on the iterator. Mapping infinite sequences are handled by creating different structures, like Stream or Observable. As for the Numbers generator, the implementation you have here is reenrant. Under the hood, the ```yield return``` statement get's converted to a class that will basically call ```Numbers()``` again if ```GetEnumerator()``` is called in a different thread. The implementation below is not, however: static int i = 0; static IEnumerable&lt;int&gt; Numbers() { while(true) { yield return unchecked(i++); } } A non-terminating generator is basically an abuse of IEnumerable, IMO. It was never intended for infinite sequences and is why things like Observable were created. The word "enumerable" means "able to be counted." My overall position remains the same. Methods that operate on sequences, infinite or not, belong on those structures. An iterator is an implementation detail of the structure and should not be exposed. Rust is a low level systems programming language, and aren't comparable to higher level languages like C# and JavaScript. Maybe at a low level you would have the need to change the output mid iteration, but not in UI code for a web page. Having to dive down into the iterator to perform a reduction seems unnecessarily complex for that use case. I do agree that JS may benefit from a generic collection type that contains all the mutation methods. But they don't belong on an iterator.
Which has been said for like ... 20 years. Somehow this fad is older than many of the people writing it. 
It does work fine with Babel too, so there is potentially that option.
&gt; It is quite evident that JavaScript job postings are nowhere near as plentiful as Java postings Or the technical recruiter who posted the position doesn't know the difference in Java and JavaScript and just posted it under Java. I don't know how many times I've witnessed this.
The scope of Typescript was perhaps needed once but it might just be mismatched nowadays since ES6 and modular Javascript are already present. If Typescript would only worry about type-checking and annotation, like Flowtype does, it would have a clear-cut purpose, but right now it just stands in the way of progress by messing around with C# traits for no apparant reason, thereby blocking a unified Javascript experience. We're deploying standard Javascript components to clients which use TS, and it's troubling teamwork with fragmentation. We can't just share code, classes, interfaces or gists because TS has its own syntax; helping out or debugging their code is harder; TS interfaces dependent on our component sometimes need additional effort to adapt on the clients side making them tired of updates; we deploy ES6 modules as well, can't use 'em so we have to drag two versions along. Basically we barely know what they do, they barely know what we do.
and not in /r/javascript 
That's incorrect, It is supported by MS until 2017 when vista loses extended support. Supporting ie9 isn't really that difficult, it hardly costs anything in terms of extra dev hours so of course an e-commerce company doing half a billion in revenue would want to support over 4% of their traffic.
For those annoyed by the background, the [Zap Colors bookmarklet from this site](https://www.squarefree.com/bookmarklets/zap.html#zap_colors) has been a godsend for my ocular ghosting woes.
That could be an optimization whatever runtime you're using does or doesn't do. As far as JavaScript is concerned, they're different values. If you compare `fn == fnFromBind` they'll never equal. But that doesn't mean deep in the internals of the runtime, you're only looking at wrapper objects that each point to the same function block but have different values for context. Strings are like this (pretty much everywhere, but could also be implementation specific). You may think they're primitives that are always passed around as copies. But if you copy a string 1000000 times, internally there will only be one string in memory, and each "primitive" in JS will ultimately reference the same character array. Optimizations can also be made with concatenation. A string `c` made from strings `a`, and `b` from `a + b` can be stored in memory as the combination of `a` and `b` (two pointers to each) rather than a brand new string copying the values of both `a` and `b`. I do know Chrome's V8 has a [SharedFunctionInfo](http://thlorenz.com/v8-dox/build/v8-3.25.30/html/db/dc5/classv8_1_1internal_1_1_shared_function_info.html) for sharing common function properties of what could be multiple instances in JavaScript. I don't know enough about the internals of V8 to know how this works with bind, but I can only assume bound functions would use this to prevent redundancy. I did a simple test of making function duplicates with new Function vs bind, and new Function-created functions took up substantially more memory than bound functions. So there's definitely some savings happening. I don't know what other overhead new Function might incur, but I'm guessing its more about its more about what bind doesn't (edit: actually, I don't know, heh, could be anything. More testing can be done to see what's happening, but there are also a lot of weird circumstantial optimizations done with functions that can cause differences).
4ms by spec, but old (Chrome/Firefox) browsers used 10ms and old IE would use a minimum of 16ms. I haven't looked into it in a while (because it never really mattered to me more than a passing knowledge) but I believe those IE values can be changed at the system level in Windows.
Protip: if you're getting bitten by NaN comparisons, validate your inputs so your program doesn't generate NaNs in the first place, or unit test your functions for them if NaN is actually a possible real-life value in your domain logic.
The method in question is not one that "only a dying browser can handle." It works universally.
caniuse.com says [form validation is supported on IE11] (http://caniuse.com/#feat=form-validation) and the jsbin on the following page seems to work for me on IE11, so it seems like the event is probably supported: http://blog.revathskumar.com/2014/12/html5-custom-validation-messages.html Can you create a jsbin, etc that is an example of the problem you see?
"Efficient code" is not what I was referring to, not sure why you are bringing it up. Also, do you know what duck typing actually is? Duck typing is "if it quacks like a duck, it is a duck", while in a typed system, just because it does quack like a duck doesn't mean it is a duck. Example: var person = { getName: function () { return "Bob"; } } var car = { getName: function () { return "M5"; } } function greeter(thing) { console.log("Hello, " + thing.getName()); } // Duck typing allows this greeter(car); That is duck typing. As long as an object has `getName()`, as far as `greeter()` is concerned, it's a valid object. And while strictly speaking that might be true, it *might* not be true as far as the software requirements are concerned. A typed system would not allow this. Take PHP for example: class Person { public function getName() { return $this-&gt;name; // "Bob" for example } } class Car { public function getName() { return $this-&gt;name; // "M5" for example } } function greeter(Person $person) { echo "Hello, {$person-&gt;getName()}"; } $car = new Car("M5"); // This would throw an exception, since $car is not of type Person, even though it has the `getName()` method. greeter($car); So when you say you want a type system so you can do duck typing, I'm not exactly sure what you're getting at, since duck typing is what you can *already do* in JS, and a type system would prohibit such a thing...
It's hard to tell where the CSS is being manipulated without having 100% access to all of your code; that being said - you can always use the !important operator to override anything messing with your element's CSS. e.g.: &lt;canvas id="canvas" style="height:300px !important; width:600px !important"&gt;&lt;/canvas&gt; It's also important to note that you're just specifying arbitrary values in your current HTML example (e.g. those are unitless values).
Ah that's interesting because I had the opposite experience. The first time I used Redux, I was giggling because it really blew my mind. The way actions fell through middleware to reducers to your store, and then automatically to your subscribed components was so elegant. It worked exactly how I wrote it, and I got to watch it all happen in real time in the extremely cool Redux DevTool. Yet every time I made a pet project using Redux it discouraging and really eating into my time to keep writing the boilerplate again and again. If I was writing some kind of project where mistakes were just not allowed or even could cause catastrophic results, I would definitely opt for Redux, but most of the time that's not the case. I feel more free with MobX. It just works, and even though it encourages side effects, I feel like it's not so bad if you're only triggering those for the things that are normally side effects anyways like updating your UI or writing to an external store.
&gt; since duck typing is what you can already do in JS, and a type system would prohibit such a thing... This is what interfaces are for. Being ~~nominally~~ structurally typed, TS actually makes this kind of code very easy and safe to write. edit: fixed dumb mistake
Here is where i got the browser support status: https://html5test.com/compare/feature/form-events-oninvalid.html Here is a bin: http://jsbin.com/bikipip/2/edit?html,js,output I verified it doesn't work in IE11 but does in chrome, firefox, &amp; edge. 
I did come across this but have no idea how to implement it. I'm using a free hosting service and cpanel. 
I just shared this video with my co-workers. We're currently in a state of weirdness with React, with one of us on Flux, one of us on React, and I'm pushing for Mobx.
If you have a domain name, throw the site behind CloudFlare. They offer SSL for free. Otherwise, you'll have to look into getting Let's Encrypt to work on your host.
There's so many easy free options for HTTPS hosting these days. If your code is frontend only https://pages.github.com/ or http://surge.sh/ https://zeit.co/now/ is a great platform if you need a backend.
Its free for the first 100 people
99.9995672%
TS isn't nominally typed. It's structurally typed. Ironically (given the above discussion), this is sort of like "duck typing at compile time". var possiblyADuck = { // We don't tell TS it's a Duck quack() { console.log("Quack!") } }; interface Duck { quack(); } var d: Duck = possiblyADuck; // TS allows this 
Thanks, we don't support those types of posts. We have over 80k subscribers here, and content must be freely available for all 80k.
&gt; TypeScript is happy to allow you to leave off type annotations which result in an “any” type unless direct inferencing can be done But the TS compiler has a `-noImplicitAny` flag that disallows it, and I always switch this flag on. A bunch more such “strictness” flags are being added in successive versions, best of all is strict null checking coming soon. (NB. you can still get an implicit any by using `this` outside of a class method, though that will possibly be addressed in TS 2.0).
&gt; Full type safety ... ensures that when someone changes an action they can immediately know about all of the consumers and where additional changes need to be made. I think this benefit should be emphasized more. 
Working in large enterprise, I've got zero chance of getting babel approved for use - and just as much chance of evergreen (or even vaguely recent) browsers coming in any time soon. Typescript however is an easy win, very simple to get past management and a great improvement on what we were using before.
First off, IDEs are not compilers. &gt; Sure, they should ask someone for help instead, but if they were great developers, we wouldn't be in this situation in the first place, would we? Novice developers make all kinds of mistakes, and it's better not to compound the mistakes by trying to tie their hands. Secondly, this statement makes very little sense whatsoever. Novice developers who are trying to get creative to work around what they think is a flawed limitation in a language, are doing things wrong, period. And they were still going to do those things wrong anyways if the language was more forgiving because the language designers are almost certainly more experienced than the novice you speak of.
Looks like I can't use it with a subdomain :( know of any decent sites to get a free domain? 
&gt; Note that I couldn’t use Node’s .pipe because it can’t be used in this scenario ... [Why not?](https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options) `Iconv` [clearly](https://github.com/bnoordhuis/node-iconv#usage) has the ability to work as a stream. I must be missing something.
&gt; Download version 6 (**Coming soon**) 
I want es6 module support :(
The version numbering scheme and especially the high speed by which the version number increases, is getting increasingly ridiculous. What's this, a new major version for a few bug fixes, a speedup and some experimental features?
The release build was taking a while, it's up for download now.
Considering its 4 months into the year AFTER the standard was finalized, I wouldn't call them "experimental".
Is anyone else pumped about destructuring? And default parameters? 
Correct me if I'm wrong, but Koa required a flag until this was released. I've been planning to start my first node.js project, and I've been bouncing between Koa and Hapi. Does this push Koa a little ahead?
notable changes: https://github.com/nodejs/node/pull/6383
I believe Koa required a `--harmony` flag until Node v4.0.0. I think Koa is really going to gain in popularity once Node supports [`async/await`](http://tc39.github.io/ecmascript-asyncawait/) which is what Koa v2 uses instead of generators.
For the most part, they are on par with each other. The one exception is default parameters, where Babel is 18% faster. But that translates to running 3 million function calls in 700~900ms.
`require`, that is CommonJS, is not part of ECMAScript. `import` and `export` are.
`require` and `module.exports` are commonjs, which isn't es6. Here's a good article on the usage: https://ponyfoo.com/articles/es6-modules-in-depth One of the advantages offhand is better static analysis which means for stuff like tree-shaking.
I was gonna say this. Basically try to write your app without any frameworks but **don't repeat yourself**. And secondarily, try to separate concerns as much as possible (but I remember from when I was starting that this can be really difficult at first. just keep it in mind) I think following DRY alone, you will start to notice patterns and see why people use frameworks. Bottom line - if you're writing an app for a capstone or something and you need it to work as soon as possible and avoid unknowns, definitely use a framework. If you're writing it for learning, you will learn sooo much by doing everything as vanilla as possible. Edit: also I would recommend setting up a linter because it can warn you before you make mistakes sometimes and help you keep your code readable. Check out [airbnb style](https://github.com/airbnb/javascript) - easy to set up with eslint - I can help you set this up if you need. That specific guide is oriented towards ES6 but there's an ES5 version on there too.
Makes sense. Hopefully, I can transition to that when it finally is supported. 
I wholeheartedly agree. However, don't necessarily punt on webpack. webpack-dev-server is awesome and works out of the box for basic stuff with almost no config. Your app doesn't have to depend on it, it can just be a convenience for development. (Sry for nitpicking)
It's really weird to see `.pipe(foo).then(bar)`. I like it though. I kinda wish node streams had this syntax.
Why all this? Because I could. :-) And it was fun. I am incredibly lazy programmer. I am that lazy that I don't mind going extra mile to build tools that let me stay being lazy. The other tools seemed to be too much work. So I scarified much much more time and work doing my own thing. Does it make sense? No it does not. :-D Regarding your size concerns. I understand where you are coming from. But I target huge applications. I wrote it as future drop-in replacement for an existing framework that comprises of close to 1 mil lines of js code and that uses older dependency system - say ancestor to DNA. When you deal with javascript on a scale of hundreds of files and literally megabytes of javascripts on the page then you don't really mind 33kB of extra code. You have a whole new level of problems to deal with. And then even having "ton of configuration" in external easily parse-able JSON scripts will feel like a great advantage (it allows you to do a bunch of cool things if you can do easy static analysis of dependencies... just think about it). With DNA you can express dependencies without going through and modifying thousands of files. You can automatically determine dependencies and candidates for bundles. You can move subprojects around to different folders without touching the code, you can... lot of things you can't with other solutions. Yes, bundles are nothing else then HTML. I am surprised that I am the first one (that I know of) to come up with HTML as a natural resource-bundling format / external web archive. It is as good as ZIP or even better. Standardized, can contain any other format be it images, CSS, javascript, metadata, references to other resources, compressed during transfer, cache-able, lot of tools, support for meta data, extensible, well understood, ... :-) That proved to be invaluable. Occam's razor. And eval()? eval() isn’t evil, just misunderstood. In this use case it is a great thing. Consider this, I might create evaluation plugin to DNA that extracts "import THIS from THAT" statements, run sub-DNA query to simulate imports, remove that statements and result evaluate with ECMA5 engine. What I am saying - using eval() may enable a lot of tricks including ECMA6 shims with DNA. :-) Eval is like a gun. You can get shot but if used properly you can gun down many problems. Depends on your skills what will happen to you. And if you really resist then simple few lines extension to DNA can change that. Plugin system is newly [described on GitHub](https://github.com/webdevelopers-eu/javascript-dna#core-plugin-system). ;-) I published that because I know it can be a savior (saved already app with 807.000 lines of PHP code in 2.800 files + 929.000 lines of JS in 3.000 files that was about to implode). So believe me I know why I designed it the way I designed it. I've seen a few fallen projects already because of bad design choices. Even though static external description of dependencies may be unusual (to people used to old ways of require.js or commonJS) it makes sense in many scenarios. I simply thought that somebody may find this approach useful. It is not for everybody. It was not meant for tiny apps that need to consider if 30k extra is too much and if external JSON configuration is over the edge. DNA is not fit for that. And it may never be. It is here to crack bigger problems. Thanks for your feedback. I appreciate your honesty and even your cautious skepticism (irritation). I would be irritated as well. Honestly I was irritated when I had to go and learn all the main existing solutions to make the qualified choice. So overly self-confident smarty pants doing tools that do not quite fit your problems. (Yeah, yet another one here.) :-D 
I presume you haven't been burned by a package introducing breaking changes on a minor or patch version rather than major? Once you have, you appreciate semver more
TypeScript is a superset of JavaScript with types. TypeScript's syntax additions, outside of type support, follows the current stable JavaScript spec. TypeScript's purpose has been and remains to add types to JavaScript. Transitioning between the two languages should be simple. If you know JavaScript, you know TypeScript. It shouldn't be any harder or different to debug unless you've decided to use different architectural patterns from your client's code. Because I suspect neither you(r team) or your clients are going to change your positions, you(r team) could likely alleviate many problems by either producing `.d.ts` files for your clients, or writing TypeScript. The TypeScript compiler will even produce these for you automatically if you take the first step toward refactoring to TypeScript: renaming your JavaScript files with the `.ts` extension.
Yes! Those two features alone (especially when combined) will make the first few lines of functions so much simpler/cleaner.
No. Enumerable (infinity) is an existing mathematical term and means there's always a definite previous and/or next element. I.e. you can count elements as you iterate, not that there is a finite number of elements. About your opinion: I disagree. How is this not the most elegant way to do it? let squares: HashSet&lt;_&gt; = vec![1,2,-1,3,-2].iter().map(|x| x*x).collect() // {1,4,9}
Have you looked into styling an img element? There are plenty of properties you can use here to size the image accordingly. Here's a fiddle: https://jsfiddle.net/jr58xfms/ and here's w3schools resources: http://www.w3schools.com/tags/tag_img.asp
&gt;93% of ES6 features What info is that supposed to convey? Is it loading? Is it getting there? Are features listed somewhere in a way that I could use the number 93 to find out what all has been implemented and what's left? Just fucking tell me what actually remains to be supported. Are Proxies in? How about import/export?
[freenom](http://freenom.com) offers several. Be aware, free domains may be placed lower/ not at all because they are commonly used for spam. [namecheap](http://namecheap.com) offers many domains for .88$ for your first year (many are only 10$ a year after)
Why typescript over Babel? Same browser support* and Babel has a larger community.
That and the Reflect API are going to make for some awesome abstractions.
https://nodejs.org/en/blog/release/v6.0.0/
How do you differ from robotjs 
Tree shaking doesn't really matter all that much for server side things running node though.
robotjs only supports keyboard and mouse automation along with screen capturing. robot-js, on the other hand can take control of windows, processes and the system clipboard. It lets you read and write the memory of processes on the system. It lets you enumerate screens and even has basic key logging capabilities. It also ships with precompiled binaries that are installed automatically, so there is no native compile step.
Some things left to implement: - `Symbol.species` - Iterator closing - Lots of prototype methods and prototype behaviors - ES6 Modules
Lot more likely that we'll see this in Node sooner than in browsers: not happening any there time soon. They built the spec, then nixed the loader implementation. Node at least doesn't have the same worries as browsers in coming up with a spec/implementation.
That made it. https://github.com/v8/v8/commit/6131ab1edd6e78be01ac90b8f0b0f4f27f308071
Mmm delicious destructuring. An overview for those who are unfamiliar: **Old:** var result = getSeveralValuesInAnArray(); var a = result[0]; var b = result[1]; **New:** var [a, b] = getSeveralValuesInAnArray(); ###For example: **Setup:** function min_max (arr) { let min = Infinity; // Let keyword. ES6 feature (not new in Node 6.0.0) let max = -Infinity; for (let x of arr) { // For...of loop. ES6 feature (not new in Node 6.0.0) if (x &lt; min) { min = x; } if (x &gt; max) { max = x; } } return [min, max]; } **Old style usage:** var results = min_max([1,2,3,4,5]); var min = results[0]; var max = results[1]; console.log('Min: ' + min + '\nMax: ' + max); **New style usage:** let [min, max] = min_max([1,2,3,4,5]); // Array destructuring. New feature! console.log(`Min: ${min} \nMax: ${max}`); // String templating. ES6 feature (not new in Node 6.0.0) Aside: You can't run the new style code example alongside the old style code example as `let` will complain about redeclaring `min` and `max` Edit: If anyone has any questions/feedback about any of the code in my post please let me know! 
Watched your talk. Very informative! Quick question... Is there any difference affecting the garbage collector when setting a value to void(0)/undefined versus null?
Just started to use TypeScript instead of gcc type annotated js, spend several days to figure out how to build a library and distribute it through npm ecosystem. After using gcc for a long time, I've had a high expectations for a final production build, so distributing it just as commonjs/system modules is a no go for me, because I couldn't find tools that can rewrite it in a similar way like rollup does for es6 modules. Right now I am building library as es5 commonjs, because it is the standard way to distribute modules on npm, I am also building es6 modules and using "jsnext:main" in package.json, so tools like rollup could find es6 modules instead of commonjs, and using "typings" in package.json to help typescript find declarations.
&gt; I want critiques on the JavaScript, not the animation's color scheme or anything similar to that. No, i'll just tell you what i think anyway. It looks good, but it's a bit slow. And the motion feels very linear which doesn't feel right. It should feel more cartoony wobble, to fit with the 'solid lines and blocks of color' cartoon aesthetic. more physics based and wobbly
Far more than I should be. It's going to eliminate a lot of boilerplate. I'm curious what practices will emerge around parameter destructuring, I haven't seen much beyond simple examples so far.
Aren't you just passing an unnamed object, not an actual named parameter?
But how would you pipe multiple streams?
Aaand, it's updated. 3.8 seconds vs 1.8 seconds. Still faster. :)
Just stay on LTS versions and ignore the rest and it won't really affect you
I haven't used Preact before - why can't you use mobx+Preact?
I don't believe it did, according to [this](http://node.green/) at least.
Each stream instance has both a `.pipe()` and a `.then()` method.
Why can't they just use .js as the extension?
&gt;I feel like there must be some basic Math operations with decimals that are safe, and for which you can safely assume that you won't need hacks or an external library. No, not in Javascript nor in any language that uses floats (which is almost all modern languages). Floating point arithmatic is not decimal arithmatic and it is dangerous to make that assumption.
It might be that the bindings for `mobx-react` do not exist in Preact. I'm generally wary of using Preact to be honest because I'm curious how they managed to cut ~140kb of stuff without creating a lot of potential bugs.
Glad to hear it, let me know what you think!
Precautions for GC type memory leaks :-)
I'm curious to see the answer to this too. 
Sorry, this was the most readable version of my code, I'm now working on a more readable version with comments but I don't much time to work on it so it might take me around two days. Also, how would you recommend breaking it up? It's already broken up into each phase of the animation: growth, combination, and transformation.
Are you having memory leak issues in your own code or is there potential it's coming from library code? Not using `delete` is the correct thing to do. From MDN: &gt; Unlike what common belief suggests, the delete operator has nothing to do with directly freeing memory (it only does indirectly via breaking references. See the memory management page for more details).
Nothing is stopping a developer in Go from making the same kind of application mistake I pointed out in my JS example: http://ideone.com/cRzurH It's 100% possible to pass what a *human* would consider an invalid object to the `greet()` function that *doesn't actually belong there*, because by mere coincidence it implements the same interface that function was expecting. The contract is *implicit* rather than *explicit*, and it's that implicitness that makes it more prone to bugs than the explicitness of a nominal type system.
You should read this page: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management More or less your second solution should be sufficient.
Thank you very much :)
I think that's also the safest solution, in case the keys in that object were pointing at the same objects as the keys in some other object that wasn't intended to be modified.
&gt; What's the number one reason you would give for trying out cycle over the more popular alternatives? Does your answer change if your application does not have state that varies over time? My number one reason would be that Cycle.js apps are extremely readable, and it's very easy to see how the data flows through your application. If your application doesn't have state that varies over time, than I don't think you need a Javascript frontend, you can probably just use static HTML. (I'm unsure if I understood your meaning here). &gt; xstream, RxJS, or most.js? I haven't used xstream or most.js in a real world application yet. I would say RxJS for now, and xstream once the next major version of Cycle lands (which allows interop between stream libraries, so it's less of a concern anyway). The big benefit of xstream is that there's less surface area in the API, so it's less intimidating and you can feel a higher degree of surety that you know about all the useful operators. The downside is that it hasn't yet been battle tested, so there will inevitably be issues to be found. Does that answer your questions?
i think its best to pick a precision for your app (2 digits for money, 3 or 4 for whatever else) and then multiply everything by 100 (or 1000 or 10000) before you store it (from user input), and remember that whenever you print it you have to divide it by the same number before you display it. this keeps the spots in your code you have to do hacky things to two spots: input and display, which is usually where theres other formatting stuff anyway.
http://www.forbes.com/sites/quora/2013/08/09/what-is-the-worst-mistake-ever-made-in-computer-programming-that-proved-to-be-painful-for-programmers-for-years/#1daeee7f6d46
Yeah but the argument is still invalid. There are a lot of software development jobs that require Java and almost all web development jobs require JS. It is a different tool for a different job. If you want a job developing software then consider learning Java because there is high demand. If you want a web dev job then learn JS because you are forced to use it for front end.
Serious question: Why ? For compatibility/consistency with (babelified) browser code or do you see a notable advantage in es6 modules over require ?
Great tutorial! Thanks for sharing. :)
Awesome, will check it out! 
I think it looks great but it needs to be a tad faster and the transitions need to be a bit less linear.
Foreach is functional programming style and for loop is imperative style. For me the fp style is better. No classes, only functions of functions!!
Be wary of performance though. Since it's just been newly released, it most like will be slow for a while until they optimize it. Edit: I'm excited about Proxies too though.
This is a good note, thanks!
Thanks man for literally giving me 30 min of time, I definitely learned a lot from your example just by knowing there is other solution for templating system, and dom manipulation. I learned grate deal from that tutorial, I'm confident I could do this type of app in 3-4(5max) hours now, figuring out the logic of this was problem, not coding it.
P.S. data array is kept in memory.
When I decided to use D3 I didn't had that much experience with it and my friend was using some chart library that had lots of lots of things inside that you could do anything even theming. While he was reading their documentation for days to find how to do simplest thing (It had so many options that he got lost inside) I have completed 3 times more charts than him and all he said was to the design team that this not possible that not possible. Hows that professional ? 
They covered that in the linked document.
Ok, so your verdict is? Setting a property to undefined will release that property/object as easily as null? I have some classes where setting it to null might be inappropriate because null is a valid value. Where setting it to undefined is great. BTW, I always use void(0) for undefined to ensure environment compat.
How complex are these filters? Libraries like lodash (v3+) support lazy evaluation, and may be worth looking into. http://filimanjaro.com/blog/2014/introducing-lazy-evaluation/ 
The simplest thing to try first would be to combine all of the filter functions into a single function. This obviously still has the drawback of having to reiterate over the entire array each time something changes, but at least then you're only doing it once rather than 6 times.
&gt; Yeah but the argument is still invalid. There are a lot of software development jobs that require Java and almost all web development jobs require JS. It is a different tool for a different job. Possibly now, but a couple of years ago that was not the case in most companies. Complex commercial web sites would almost entirely be written in Java with help from things like JSP and Spring while JavaScript would be used from minor interaction on the front end. Things have changed a lot in the past 4+ years.
That's true. I actually touched upon stuff like OO in the discussion here https://github.com/mobxjs/mobx/issues/199, but forget to mention it in the video.
Thanks. I've got quite a few tricks similar to that depending on the operation I want to do. My question was more along the lines of "for which values of x and y can I just safely do x + y, x * y, x / y or x - y?". I was just providing an example to see if any guidelines out there could address it.
&gt; If your application doesn't have state that varies over time, than I don't think you need a Javascript frontend, you can probably just use static HTML. Good point haha. I guess I've always thought about modeling things with streams only if they take some amount of time to execute, but I guess that that's not true now that I think about it more. Alright thank you for your answers. I'll look into trying cycle for something soon.
Thanks for the information, any news when node will support? 
I think perhaps you took &gt; Query your data declaratively like it is SQL A little too literally. I think I get your point though. No currently it is not possible to treat the data like a relational database because everything is stored in denormalized form in an array. Once I add support for normalized data, which currently doesn't exist, it would be possible do operations similar to a `JOIN`, but you wouldn't literally be using the word `JOIN`.
Don't do it unless you optimize for IE8. You can nullify object that is referenced somewhere, by accident. If it isn't referenced, GC should collect it anyway. And need for such behaviour is usually code smell - when function returns, all objects should be returned or be garbage collected. 
Are you actually seeing a memory leak that you're trying to fix, or just trying to preempt one? Explicitly setting a variable to `null` is a performance myth that is almost always entirely incorrect on modern GCs. At best it will do absolutely nothing, at worst it will prevent the JIT from properly optimising the type and confuse the GC into doing a full mark and sweep instead of a scavenge. There are certainly cases where you may see memory leaks that can be "Fixed" with a bandaid solution of setting something to null, however this is almost universally just hiding a more serious underlying problem with your code that should be fixed instead. The GC will clean an object up when it's good and ready to, and you're almost always better to let it do so on its own pace. Trying to do manual memory management will almost always result in substantially worse performance than if you'd let the GC do its thing. tl;dr Unless you're writing extraordinarily bad code, you will not have any memory leaks in Javascript that can be fixed by nulling variables in the first place, so doing this is pointless and likely to hurt performance.
Hi /u/var_ya, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I like // each function in the array until one returns false // this shortcircuits the evaluation so that we don't run Unfortunately I don't think memoization in this case as I would have way too much data in there. That is pretty much how I do it know without actually wrapping them in a compose function.
One of the coolest things learning Cycle taught me was that you can view any value that changes as a stream, including the state of your application or the DOM the user sees. If you want to have a play with Cycle in your browser, you can check out [Tricycle](http://widdersh.in/tricycle/), an online scratchpad for Cycle.
Leftpad was added for hilarity. Sorry you didn't appreciate the joke.
I could have sworn this was called mobxdb last time I looked haha. What're you using the proxies for that's so useful?
Try r/node?
Yeah, it was. But I tried to reimplement a chunk of mobxdb with ES6 proxies and I liked how it worked out and decided to ditch mobx in favour of https://github.com/capaj/proxevable Hence the rename.
Awesome overview thanks!
Hi /u/b-lotus, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
That's the most significant complaint about ES6 code -- it is currently much slower than ES5.
How much would you recommend I speed it up? Speeding it up would actually be relatively easy.
After a little bit of experience I have found interviewing to be least painful part of getting a new job.
I'm glad es6 module support is lower priority. I think it's overrated and offers very little advantage over the clean and simple CommonJS syntax. It looks like a pain in the ass to implement too. So many different ways to do the same thing.
What is more painful in getting a new job? In my experience, interviewing is quite painful.
Look into [Redux](https://github.com/reactjs/redux).
jesus i haven't been job searching in a short while. are the interviews that arduous these days? should i be learning all these algorithms? i'm a mostly self-taught front-end developer
Victim blaming won't help. Let's review this situation. 1. Large companies are laying off employees in the ranges of [tens of thousands](http://www.oregonlive.com/silicon-forest/index.ssf/2016/04/intel_layoffs_questions_and_an.html). 2. These same companies are using 3rd party software in a corporate environment. 3. However, they refuse to acknowledge that the author of that software has programming skills enough to develop software for their company. They use these grueling and arcane interviews to weed out viable candidates. 4. That's confusing for any company that wants to succeed, until you realize why. They will then [lobby for H1Bs](https://www.revealnews.org/article-legacy/visa-fraud-in-us-tech-industry-relies-on-falsified-job-letters/) of qualified or barely qualified candidates that they can train up. Candidates that they can treat like slaves, pay even worse, and then throw away when they're done. Hiring is broken. It's a reason many (not all) experienced professionals in IT and programming are leaving the field in record numbers. This guy is bringing attention to at least part of the problem. That's something. 
No, if an interview requires a thorough understanding of algorithms then they should give you homework to solve a novel problem in a novel way so that you present how you came to a resolution in a comfortable manner. Interviews that demand you write a super duper algorithm in the next 30 minutes are completely disconnected from reality. Gracefully fail out of the interview and thank them for their time so that you can focus on looking for a realistic position elsewhere.
 &gt; You provide simple answers. Sometimes interviewers who are less experienced at interviewing might ask something really convoluted. Ask them to rephrase and then provide the most direct answer possible. As someone who interviews frequently, I'd say this isn't always the case. It can be true, but interviews are about personality as much as experience. If the person seems disconnected or uninterested then that will ding them. Provide simple, direct, and concise answers, but just make sure that's not all you're saying. On the convoluted part, if an interviewee has shown that they have the basic skills we're looking for then I tend to scrap the rest of my prepared questions and delve into convoluted problems, some we haven't answered yet. Think of it as extra credit. In my mind, they're already qualified, so it doesn't hurt them. The right answers, though, can greatly help. There was one guy I was hiring who was grossly overqualified for a dead-end position and knew his stuff in ways that the other interviewees didn't. He was completely self-taught. I could tell that he could do the job immediately, and I went to the HR head for a one on one after the interview. He ended up getting an offer for another position making a *lot* more money. He makes more than me now, but he deserved it. 
Serious question, are interviewees surprised when they are asked to implement BFS? That seems like a really common interview question. 
You can try different speeds. 3 seconds is a pretty standard target for things like transitions etc. Anything past that can seem excessively long, though it also depends on what you're doing and its purpose. 
[Here](https://docs.google.com/document/d/16t1um6sXBlFZT2aCLqnlwumcEcM2K-_xeEFnnsA_rBQ/edit) are the minutes from the last CTC meeting. Decision was 11-1 in favor of a new file extension.
I think the library abstracts away some of the router/store/loader setup rather than webpack/npm etc - so it's an actual library rather than another skeleton. As you mention, you still have all your own actions, reducers and other code to write. I've yet to try it out, so let's see.
I'm not a huge fan of algorithm-bingo either, but BFS is very easy to reason about and implement with minimal coding skills. 
I'm not a Java guy. I'm a C guy...I was Project Team Leader of the Windows NT Driver Group at ATI Technologies (now AMD) and C was the primary language throughout my career (I'm retired now). I'm also a Smalltalk guy just 'cuz I love that language. I like learning new technologies. I recently got into Smalltalk/Seaside and Go/Beego and Python/web2py. Now, I'm tackling Elixir. I choose technologies that are good and interesting. JavaScript has too much baggage. Things like Angular and React are over-engineered complexities for web development problems that can be solved more simply with transpiled languages, [which I highly recommend](https://medium.com/javascript-non-grata/the-super-surrogates-of-javascript-862460199915). Many companies and developers use transpiled languages to great success.
Something other than the developer tools in all major browsers?
Yes, because as someone in the industry for 10+, I've literally never written one, and I guarantee 90% of developers out there haven't either. If you're asking me algorithm questions for a front-end developer job, then you obviously don't understand what front-end developers really do.
The speech synthesis api has both "rate" and "pitch" parameters you can set. There are some emscripten ports of libraries like "festival" and "espeak". One of the better ones is called mespeak.js: http://www.masswerk.at/mespeak/ I'm really hoping for a pure javascript based speech synthesis API with better voice presets (think OSX's `say` command voices).
7 days work that they'll review for 10 minutes before making a decision.
This hits pretty close to home. I'm a web developer and many companies will bass interviews off algorithms such that someone who just graduated but has no idea how to build a web app would perform better than me. Rather than the blog poster, I've accepted this and just started to study algorithms which one year from now I will certainly forget again, but the author gets at a very big problem with web developer interviews
I already know this is a type of person I don't want to hire. So I'd say the interview process is working well. 
I think that while his tone is not overly professional, it makes sense given the level of frustration he has. He makes a lot of excellent points - I mean "It’s like testing your dentist’s skills based on their ability to balance a redox equation using the oxidation number method from their undergraduate chemistry studies." is dead on. When was the last time you used BFS in front-end development? It's truly bizarre that he was being asked the SAME question by MULTIPLE interviewers, that had nothing to do with front end development!
I recently did a phone screen for a large company that started with "Sorry, you may have trouble understanding me because I just came back from the dentist and half my mouth is numb." ?!? 
The problem isn't the particular algorithm, it's that there is practically unlimited algorithms that could be asked to you and even if you got great grades in you CS-algorithms classes, you can't reasonably be expected to remember the details of them all. Just because you have to "Google" the details of something, doesn't mean that you're a bad programmer.
I have to agree, I wouldnt want to work with a guy that seemingly is getting hostile from interview fatigue. Lots of times interviewing is as much a personality match as it is technical skills.
At 33 and on a career change, this frightens me more than ever...
&gt;but that is a skill that general separates good vs excellent developers No, it's not.
If this is the current standard for interviews, an interviewee should be on top of it. An annoyed medium post seems desperate and, ironically, the current standard for unemployed coders. As to *why* BFS is used: coding is about pattern recognition and piecing building blocks together. Choosing which algorithm to implement can demonstrate the persons talent for pattern recognition. It's as simple as that. Complaining about "luck" being a factor is like a student complaining about their midterm essay being about knowing one topic really well on test day when they're supposed to know five really well. The lesson is simple: Be prepared. 
The only point he seems to miss is that interviews of this flavor often are not concerned with you knowing how to do the task --- but rather to see how you work, especially under pressure. He failed, but not for the reasons he thinks he did. The problems they assign often don't matter to them at all - they are just complex enough to make you work in front of them.
It seems highly unlikely that crawling the DOM tree yourself is ever a good idea. Browsers do a lot of optimizations under the hood, none of which will be available to you if you try to roll your own traversal code. The DOM API itself is also pretty nasty, and not especially performant. 
2) Is really key. Bank it while you can still take it.
&gt; he was being asked the SAME question by MULTIPLE interviewers And yet still didn't know how to answer after that many times?
Saying "...then you don't want to work there" is a huge copout though. I've interviewed at many great companies with great salary ranges where the technical aspect of the interview have been brutal and draining. Lots of interviews at great companies end up being heavy algorithm focused (Google, amazon, etc). I've even had some particularly brutal interviews where nobody on the core team had any formal education, but I have a masters degree, so it was open season.
I applied to a few startups in Chicago, I had to design a restful api, find all similar factors of an array of numbers, design and code a simulated bank account, and code some stuff in javascript. Salaries ranged from 80-90k. I ended up taking a new job on the east coast for a lot more. I get to build their systems from the ground up and modernize everything. The only question they asked me was fizzbuzz lol. The startups had that hipstery feel, beers on tap, work 10-12 hours a day. The new job is more 9-5. I'm a self-taught front end guy, but I am wrapping up my M.S. in CS.
&gt; All of what you said is true, but it absolutely describes 90% of the interviews I encountered when I was last looking a job. To be clear I do see a massive distinction between being asked to write a small function to navigate a collection, the DOM, or some other minor task; for instance. The problem is common enough that a candidate with mild experience would have some way of going about it in a couple of lines. The goal there is not the code solution, but to watch the candidate's approach and examine their code style. This is miles apart from being asked to write a path finding algorithm during the interview period. Something like this takes trial and error and some amount of research. All you are really learning is if the candidate has already solved exactly that problem several times in the past. This is completely disconnected from reality unless the job is primarily about writing path finding algorithms and there is nobody there to provide mentoring. If I encountered this problem twice while interviewing I would ask the recruiter at the next position if something like were coming so that I wouldn't both with the silliness. It is in the recruiter's interest that you get hired, so choosing to abandon the opportunity before the interview is where the recruiter could intervene or wish you well.
This isn't necessarily true. Your years of experience still count, and not all interviewing is like this: many companies outside of the valley and located in most major cities have reasonable hiring practices. 
Naw, it's fine. It just clicks the see older button every half second. Seems pretty useful.
&gt; They're are looking to see if you are someone they want to come to work and interact with everyday. If you freeze up or get defensive you aren't. This. Always a good thing to keep in mind. It was definitely something I got better at through my last stint of interviews. If your solution is pretty bad, behaving like a good coworker can still be more important to team than having the most optimized answer.
I see a distinction between long and hard interviews versus poorly conducted interviews. In the job prior to my recent one I was interviewed continuous for 6 hours where I had explain my approaches to resolving conflict at a remote client, seeking support, explaining technical mastery on a whiteboard, decision making, and almost anything you can think of. I was completely drained as this was a really hard interview, but it was a great experience. I got to meet a bunch of people and it made me determined to want to really work there. I could see the passion in the people who interviewed me and kind of get a taste of the corporate culture. My worst interview lasted less than 30 minutes and I barely said anything. It made me really determined to not want to work at that place. As a potential candidate the interview is almost as much mine as it is the companies. If, as a candidate, I am not allowed to ask them hard questions then I don't want to work there. If I get the feeling the hiring team is extremely under-qualified then I don't want to work there. If I get the feeling they cannot interview then I don't want to work there (perhaps they have really weak team building skills or they simply don't know which candidates are greater value).
That absolutely could be.
This guy also did the [pipes screensaver](http://isaiahodhner.ml/pipes/). Wow this makes me feel old.
While this guy may be right, the candidate is not the person who gets to judge whether a hiring process is broken. The company decides that. A company thinks the hiring process is good if it yields good employees. Google seems to have a good batch of workers, so they must be doing something right. Does their process annoy the applicant? Maybe, but I doubt Google cares. As applicants, we can say hiring is broken if it's exploitative: pay-to-play, spec work, 40-hour "application projects", etc. Asking someone to talk on the phone for an hour and come in for a day is not exploitative, even if we think the questions are stupid. 
It is dangerous and may attack at any time. We must deal with it. https://i.imgur.com/ThUkrRG.gif But in all seriousness looks fine. Though invoking the click event programmatically, faking user actions has always seemed hacky to me.
I think the push back is that there are now two extra, theoretical populations A) People who test poorly on algorithms and should have been hired (i.e. are good engineers) B) People who test well on algorithms but are presumably not great hires How big is pool B, I wonder?
Me too. "How would you traverse a sorted binary tree?" "Firstly, I came in for javascript/html/css. And then I certainly wouldn't rely on something I cobbled together by myself in 15 minutes. (If I'm lucky. And I've been practicing.) In fact I would rely on the tried and true tools that are already written into the system." I went into one interview and one of the business dudes showed up and started grilling me. I swear he gave me a marketing question. My answer was "I don't know? Track the deltas like in git?" He was like WTF?
The mobx-react package that gives you the observer function requires React. I've tried to use preact-compat, which is a specific compatibility library to no avail. I even tried changing any require("react") statements to require("preact") with webpack.
&gt; When was the last time you wrote code in front-end development? What does this mean? 5 minutes ago? Every day?
Just out of curiosity, why do you say that?
I would hope that coding tests are given so that you (the interviewee) get to demonstrate your problem solving skills. In particular, I think it's pretty useless to ask for an algorithm you already know / already studied for. With that in mind, I think BFS / DFS might be too textbook (either you know it or you don't) but, more importantly, too specific. Maze solving is a step in the right direction in that they don't specify how you should solve the problem, whether you should use BFS or DFS or if you have a different idea. The interviewer can then have a good discussion with you about not only algorithms but also the pros and cons of each approach, because that's how you should probably approach real world problems. The requirements for front end developers are becoming more and more like those for general software developers as technologies like React try to do everything in JS. E.g. you are no longer writing HTML, but JS that generates HTML. You might also be writing JS that generates the CSS instead of actual CSS. Algorithms drive all this things, some of which is established by the framework and some of which you develop alongside the framework. The front end developer should understand both. Today more than ever front end developers need to write sound, performant JavaScript. I am expecting technical interviews to be the norm for front end developers if they aren't already (many people seem surprised).
I get it, the work is so simple and easy that the interview process is just a way to find and reward the "smart ones" with an easy ride and a fat paycheck. Any trained monkey can work front end, it's paint by number work. Companies just want people that they can talk around the water-cooler with. These interviews have NOTHING to do with any of the actual work you might have to do, and EVERYTHING with the kind of person you are. You can know dick all about programming, as long as the interviewer likes you, you get a job. Sucking dick might actually be a better strategy for a google job interview than learning how to code or solve problems. You don't have to be smart or competent, you just have to be cute and interesting, tits will no doubt help. Next time deflect the programming challenges and work the people behind the desk instead of the whiteboard, eat up as much time with jokes and funny anecdotes about your life as a homeless person or something. ANYONE can google the answers, but not everyone can tell a funny joke.
Thanks for writing this. IMHO, if something as fundamental as BFS isn't internalized such that you couldn't demonstrate the gist of it on the fly, you're *probably* not a strong programmer. This algorithm shows up everywhere even if you usually don't implement your own from scratch. It's not something to be ashamed about, but it is something that needs to be accepted.
I did the same thing. It didn't pay off for me - hopefully it will for you. I wish you luck!
Yeah, Jesus. Look it up at some point. 
Integration testing.
That sounds like a practical interview technique - the job likely has a lot of AJAX and request handling. If you can't do it, no job. I think the author of this would prefer that, while you would actually prefer general algorithms because you had less practical skills at the time. 
I'm a self-taught frontend too. Do you feel the CS work is really helping you? Is it helping you in ways you didn't expect? Is it mostly to evolve into more full-stack work?
1980 was all about abstractions. (Sigh, yes, I was there.)
Instead of saying "implement this algorithm, but no googling!" a better interview is: "google this algorithm, now implement it".
It's a spec by a bunch of community people: http://www.commonjs.org/contributors/ 
Using an abstraction for everything because you can't handle doing anything in vanilla code is the reason so many applications have gotten hugely bloated. There doesn't need to be a whole library pulled in for every small and largely constrained problem. 
The entire purpose of picking BFS for an interview question is because it is not commonly used, so the interviewee will not likely have it memorized. This allows you to watch how they solve problems as they work out how to do the search. It is also not very complicated so it doesn't take very long for a competent coder to come up with a solution on a white board.
Front end developers don't write code to solve problems? BFS is just a problem to solve, and a simple one at that. No interviewer wants someone to spit out an algorithm from memory, they want to see the interviewee solve a problem with code.
I'm also interviewing for front-end dev jobs in NYC. Have not gotten a single algorithm problem in my interviews. 
/r/TheRedPill is leaking
Vue is great. Evan has great technical writing skills. The documentation is a pleasure to read, as is this update. Very nice that he was able to rewrite Vue while maintaining the same API with only intentional deprecations. Looking forward to upgrading a 1.0 project to 2.0
 ReactDOM.render(&lt;div&gt;{'&lt;code&gt; snippets &lt;/code&gt;'}&lt;/div&gt;, document.body);
With my interviewer hat on, the point of a technical interview is to probe where your "I know this off the top of my head" knowledge ends and the "I need to improvise" knowledge starts. Why? Because that's when we start to see your skill as a developer: combining existing knowledge to solve a novel problem. There's no point a) probing you on stuff which can be Googled or b) asking about stuff you know backwards. The initial phone interviews are there to weed out the people who can't code. The face-to-face is to weed out the people who can't *think*.
yeah, interviewing is it's own skillset- but it's usually just thrown on a random engineer on the team. then it practically becomes boredom-induced hazing. 'i had to go through it'
If you're interested in thinking, maybe try giving them problems that don't involve code then. If its not about the algorithm, then don't use an algorithm—that could lead to false positives.
Of all the algorithms they could ask me, I would be relieved if it's BFS. Thank god it's something I can somewhat figure out, given a reasonable amount of time.
I have to agree, I don't have a CS degree or any degree. I have 17 years professional experience and 27 years programming. I don't know these algorithms by heart ether I just study a few weeks before interviewing. I could suck as a programmer though I think I am a ok one but you would never know because I almost always ace the tech interview. So I would like to thank all the programmers that think that you are pulling a trick to find the best programmer in 1 hour by asking an algorithm test. It also shows me what type a company you are and why I might want to turn down the offer you give me. I know you think your startup is the next Facebook but you have plenty of time to refactor your code. 5000 requests a minute even the most poorly written PHP code could handle. When I interview people, on the phone, I talk to them about there experience. Ask questions to find out how they best work. I want to know if they will fit in on the team and be a team player. Do they have issues with the languages we use? What would they change about their favorite library? etc... If that goes well then I ask them to submit a pull request to any open source project. It needs to be code and needs to be a big enough piece to talk about for 20 minutes. Oh it also has to not be their project. This filters out the people that can't read other peoples code, 75% of our job is reading code not writing it. As well as is a good indicator on coding style. We all build software different and there is know one write way but I also want someone on the team that works with the existing team and will adopt the exiting standards of the project even if it isn't how they would build it. If the code review interview goes well then one last interview where we invite them to a team lunch. This is a very relaxed get to know the person and will we all work good together. That is all that is needed to find awesome great people and not turn them away with 7 technical interviews.
Yes, I believe it has made a difference. Small things at first. I know people say that algorithm interview questions are stupid for front-end developer positions, but after taking a course in algorithms, you really begin to understand how the code you write affects performance. Iterating over arrays to find a value versus using a search method makes a difference when we talk about scale. It most certainly helped with evolving into full-stack work. The real benefit to the degree isn't just learning the material, it was the experience, the trial and error in doing assignments, projects and exams that give you a leg up. You being to recognize problems, and even if you don't know the answer, you know where to look for them. I've also gotten to experience a number of different fields and techniques, from functional programming in Scala, distributed systems using Java, to writing Artificial Intelligence in C# and Social Network Analysis in R. 
I bombed an interview with Google 5 years ago, and I was left with a terribly damaged self-image. So when I finally worked up the nerve to start looking again, I just took the first offer, without doing any other phone screens. Rejections are really going overboard and the lack of feedback is brutal.
I was once asked to complete Trello like Kanban board with drag and drop features in AngularJS (only) in 3 days. And in another interview I was asked to create money manager app in less than 24 hours, with all UI done correctly. They wanted solution in plain JavaScript and AngularJS, so 2 project (even if logic is same) in under 24 hours, that includes sleeping, eating, etc. Some interviews are just weird. But honestly I did face interviews which were precise, and well organized. Like I had to create an image slider which zooms the image in another pane, on mouse hover. This was for a retailer company totally made sense. I then had to prove logically the approach of online retail design with API consumption. The second type of interview I totally love, and no matter how many times I'm rejected in process, I'll always be ready to take another. It's great learning resource, if nothing else.
What do you mean by false positives? I have run few interviews and looking at someone working out a problem gives a lot of insight on a lot of things: how does the person tackles the problem? How does he divide the problem? When does he ask questions (does he try to work it out for 5-10 min or does he ask questions straight away)? What is his attitude (does he give up fast, does he keep his cool). As an interviewer i don't think it s always about the perfect answer.
How did you bomb? Curious because I have an upcoming interview with them. 
That's what I thought - I got about 2 paragraphs into his rant where he describes the Google interview process: he thinks it's "idiotic", and doesn't understand or solve the phone screen problem but has decided it's "not interesting or memorable". Translated, I'm reading "you idiots don't know how to hire, and solving your little problem is beneath me". Frankly, this guy has a terrible attitude: &gt; was followed by a question on how would I implement a tree-shaking algorithm. How the hell would I know? If, and when, I need to know how tree-shaking is implemented, I will go look it up. As an interviewer, how do I know what you're talking about and not just spouting off buzzwords? Even if you don't know how to implement a tree-shaking algorithm in actual code, you can at least describe in general terms how one works (probably what the interviewer wanted). Yes, I know you don't need to know anything about how tree-shaking technically works to use it, but the interviewer is looking for some kind of intellectual curiosity. He's describing, what, half a dozen no-offer interviews and his reaction is: &gt; It honestly feels as if I am a complete failure and an unhirable candidate. How is this possible? I'll tell you how - "if everyone around you seems like an asshole, you're the asshole".
My last interview i didn't know what prototype was in JS. I told them that when they asked. I got another interview and knew a little bit more when we got together, and they gave me the job. A lot of hirers are burned out on over exaggerated resumes
Overall I agree that there is no perfect answer, and hiring is complicated, and simply asking a question is not the same as requiring a perfect answer for a question. As programmers I think we can't help but explore logic. In this case, the poster said boldly &gt; it's not about knowing the algorithm But the obvious problem when choosing one of X known algorithm-based questions, is that you run the risk of that person having recently studied that algo, or just had an interview yesterday with that algo. So its possible that they ace this algo question today, impressing you wildly, but if you had asked them yesterday, they would have failed. That would be the false positive. So a question about ping pong balls in a 747, or sandwiches in a the empire state building, or whatever you want has some of the same benefits while being maybe more fun, spontaneous, interesting, and unexpected.
&gt; Network. It's a million times easier to get a job if you're introduced through someone you know. This has helped me multiple times in the job hunt.
I don't live in California and I don't want to. For Google, I thought it was worth it to relocate my whole family and life. The stress of the whole thing overwhelmed me and I got *stupid* in the interview. Unlike the OP, I do remember algorithms, but I forgot simple things, like how to print a line of text in Java. I also have a phobia of cafeterias. (If it made sense, it wouldn't be a phobia.) Google is very big on cafeterias. I should have caught that in advance. So I was bad enough in the morning after the stress of California traffic, but after lunch I was completely destroyed and barely thinking at all. It was ugly.
The best example of this is when they ask you to implement a sort algorithm and you just use the builtin array sort. If you do this you should be ready for the follow up about sort stability though.
Right, but you're using that question correctly. Most interviewers I've interviewed with _don't_, and that's the problem.
Sounds arrogant and entitled
This article read like 17 mins of "me me me me me me me me... ad infinitum"
&gt; if everyone around you seems like an asshole, you're the asshole Gold. Is this from a famous book/movie?
Don't be. I'm same age, and trust me - if you're up front that you might not be the smartest tool in the shed, but you've got experience and worked in the field for years it changes the tone of the interview and people look at you differently. You're not some hotshot straight-outa school guy that will jump onto the newest JS framework. Also, you can shift your focus - with your experience you can be a team lead and focus more on managing the team than coding.
I've been using Vue.js 1.0 and love it. The main reason I like it is because it doesn't require Node.js like every other framework.
I'll do my best with what you've posted... You'll have to create the tr#tableRow in React, and add a click handler (onChange) to that component. Whatever table row that is, when it is clicked on, the function must do something to affect state or props, so that your other Badge component can be notified of the change, and re render. Just based on my own interpretation of what you've explained, I would have a field in my global state object (Redux or local state, doesn't matter) called 'numSelectedTracks' or something, and that is passed down to my badge component. That way the badge component can be dumb, and just spit out the badge with whatever number (prop) was passed to it. The real challenge for you (i think) will be to hook up a onChange listener to the checkboxes in the table rows, each checkbox click will have to manipulate state in same way to know how many checkboxes are currently clicked. (this is the same variable that the badge component will depend on) Hope this helps
Part of what they are looking for is how you work when you don't know the solution. If you don't know algorithm, will you ask for hints or will you just stand silent? When we interviewed at my previous job what candidate wrote was just hint on how much will they have to learn. Much more important was how they were working, if they admitted to not knowing something, how many hints would they need, could they read specs. properly. 
I wish I got interviewers like you. As someone with 16 years of front-end experience, I find most interviews these days don't touch much on skills that I use everyday, and mostly test whether or not I have a CS degree and heavy algorithm knowledge (I don't, which I usually tell them right away, but they put me through the wringer anyway). 
I actually keep a bunch of Github projects, and it makes zero difference in getting hired. There's a lot of waffle that you should do Github projects, keep a blog on Medium etc. As the OP found it's a waste of time. Not to say these things are a waste of time in themselves - do them if they give you personal fulfillment. But they won't lead to you getting a job. 
Yeah, that's a pretty spot on breakdown. Thanks for explaining.
IMHO No, it's got different rules for how to structure your javascript but the core syntax is the same. Where I would start considering it a different language is if there were new reserved words, ways to assign variables, closure changes, etc
onload = function() { ... }
I suppose, though I wonder if part of it is that it's hard to get a feeling for how the interviewer is judging performance. I try and be clear that I don't care about if they have the best answer I've seen, I just want to see how they break down and discuss a problem, but I know it's hard to get a read on how the employer feels in-interview. I wonder if a lot of people aren't just looking at problem solving ability but the interviewee walks away feeling like a failure for not "solving the problem" and when the company rejects them for unrelated reasons they blame their inability to win over puzzles. The usual things that disqualify people for us have often just been people who would clash with our culture or people who are looking for something out of a job that we can't give them. Just as we care about getting someone experienced and qualified enough, we've also had to say no to people who we knew were too qualified. They'd have been great but with nothing to learn from us those types tend to be the most likely to jump ship after a little bit to work somewhere that can challenge them. We're just way too small a team to lose people every 6 months - 1 year when the whole hiring process eats into team member productivity interviewing people etc. 
I don't think so, just a colloquialism I've heard. Applies alarmingly often in dating and the workplace.
If you use BFS (or whatever algorithm or data structure or design pattern) at work on a regular basis - and for all I know, that may be the case at Google - then yes, by all means it should be an interview question. As long as you signpost to candidates before the interview you'll be asking these kinds of questions so they're not ambushed coming through the door that's perfectly OK. If you're just building a derpy CRUD app that wires together a bunch of tables in the backend to a PHP framework and pushes JSON back and forth to a JS framework on the front end and your daily problem is getting a div to render correctly or making sure the tables are properly indexed, then ask questions about those kinds of problems. If you ask a BFS question and you, personally, haven't touched BFS in a professional setting since college, then that's just dishonest and you're just hazing. "We want to see how you think under pressure" is also BS. Typical day is more like your PM or dev lead says "we need to do X" and you ask a bunch of questions, go away and research the issue, have a meeting, ask some more questions and put together an estimate and maybe write some test code drinking your morning latte or whatever your development process does. You're not in a courtroom or Congressional hearing or the final round of Jeopardy where every second counts and every word is going to be pounced on and dissected. You're not a heart surgeon welding a scapel over a dying patient. Yet the interview process seems to assume that's the normal case. And yes there are scary moments when it's 3 am and you get a phone call because the database is down and you can't SSH in. Ask the candidate about the worst moments about their career and how they coped with them and what they learned from the experience. Show common courtesy - be polite throughout, be open about the hiring process, give feedback when possible, take the time to look over someone's resume before you invite them to spend precious vacation time travelling out to see you. Make it more of a conversation and less of an interrogation. tl;dr; look at the job that's being interviewed for and what its **real** requirements are, and build your interview around that. And be nice. It's not rocket science.
Agreed that it can be improved, but no one here provides a practical solution. It should be a mix of practical experience and algorithms, but that's a problem with the fact that's there's no established way to interview. The current system catches too much flack because people think their industry experience, which is hard to quantify and prove, matters more than a quantifiable test of their problem solving skills, handling of pressure, and examination of their willingness to prep themselves. I know people who have 10+ years of experience that aren't good programmers, but have managed to get jobs and function in a work environment.
That's nice that someone can invert a binary tree without googling it but I'd still hire the Homebrew guy, call me irresponsible.
Most frameworks don't require Node.JS... which ones are you referring to?
You're missing a huge thing you have that younger devs don't: a network. I know for a fact I would fail one of those style interviews with buzzwords and pop quiz questions, but I also know that I could leave my job right now and there are 5 people I could call by the end of the day to get jobs at the companies they work for. This is why networking is so important. My last 4 jobs have all come from someone I worked with somewhere else.
I wouldn't want to work with the BFED...
&gt; There's not much to memorize here, you visit all the nodes connecting and then you recurse into those connecting nodes. Well, you need to keep a list of nodes. It's not hard, but not trivial, and if you don't know the problem space at all you will stumble inventing something like that under pressure.
It is a bit bullshit some of tests they give out these days. I had an interview with a test that gave me logic questions instead of questions about coding. Asking me what shapes go where and what number comes next and things like that. Apparently that's how they screen their candidates before even getting to any technical bits.
You got declined by one of the notoriously toughest companies to get hired to, and that completely destroyed your self-image? So your self-image was that you could never fail at anything?
If the author has proven themselves worthy through their open-source projects, and is applying for a job in front-end development, then why are they being asked questions like this? And you can say, "Ah, but implementing BFS is foundational in computer science!"-- yes, well even more foundational are grammars and Deterministic Finite Automata and Turing Machines and propositional symbolic logic. Just because you can convert a CFG to CNF on the spot doesn't mean you're a quality front-end web developer. The author has been out of college for a while. They got a degree in CS, so we can assume that they have the *capacity* to implement these algorithms. Being able to write algorithms **on the spot** is not indicative of your abilities as a developer-- it's indicative of your ability to regurgitate algorithms.
Depending on how confident the interviewer is with his technical knowledge, if an interviewee aces a question you just go ask for more questions on the same topic In the case of the BFS, what are the limitations of the BFS and ask questions about the limitations that he knows about (e.g. how would you solve this problem if the graph was an infinite graph)
As someone that's soon to be hiring programmers, the last thing I'll be looking for is algorithm competence. Algorithms are a great task for a consultant. Pay a premium for specialized thought process. But what I want from full time hires is code quality, not theoretical complexity. Does the candidate fully understand TDD, stubs vs mocks? What about onion architecture? Can they explain to me why the Law of Demeter is a good thing? How long should a function be? Do they have code samples that demonstrate all of this? Is the discipline in those code samples consistent? Why does functional programming have an advantage in async code? Etc. TL;DR: Algorithm quizzes are great for people interviewing that don't fully understand the requirements of the roles they are hiring to fill. But a complete waste for trying to build a true programming team with consistent ideals in how to ship quality code.
I had the same thoughts about the BFS part and agree with much of what you said. I'd expect a more experienced front-end developer to understand the basics of tree traversal as it applies to the DOM. In every case where I've been asked coding or technical questions, I've always asked if the interviewer had any feedback before the end of the interview. Never depend on the recruiter or hiring manager to provide feedback, they'd got other things to do. Most interviews have also started out with asking if I had any questions about the company or the position. If they haven't, I've never been so shy as to not ask. 
I just want to point out that not everywhere is like this. When I was hiring developers, here was my general process: 1. 15-30 minute phone screen to describe company and position, and get to know what candidate is looking for. 2. If there is mutual interest, I'll send over a 30 minute work example test to do at their leisure. 3. If the work example isn't garbage, we'll set up an in person interview 1-2 hours that mostly encompasses talking about experiences, the work example, and any other public code examples the candidate wants to show off. No whiteboarding. No random computer science problems you haven't had to implement since college 10 years ago (or never, in some cases).
Or why it sorts [1,5,10,15,20] as [1,10,15,20,5], and how to avoid that.
I'm an Android developer, and when I interview people, I walk them through the creation of a basic sticky notes app with sync. I let them actually define the programming problems as we move through the interview. For example, if they say they want to use a database, I'll ask them to give me the information they plan to store and to normalize the data. When we get to adding features, that's where things get fun. Some people want to add search and sort methods, and they get to describe how that works. Others want to add note sharing and versioning. To me, the interview is not just about confirming technical knowledge, it's about how you solve new problems. Can you use the resources you have to make something work? 
What comes down to is the fact that this whole "fuck the system" rebel attitude in tech has led to a crippling lack of basic management ability.
The bigger companies usually send their employees for "interview training". At Microsoft, we called it "Smart Hiring". There are some things about it that are useful, but the drones that follow that process only hire more drones. It is why bigger companies have a much lower percentage of "creative types" compared to the majority. They hire people that fit a mold. And that creates an environment of mediocrity ends up in a very bland environment. What I learned, however, is that diversity is very important. Not just diversity in culture/race etc, but diversity in how people think. Algorithms are simple. They are formulaic and easy to teach. Most anyone can learn an algorithm. When I'm looking for talent, I look for people who aren't great at interviewing, but are great at being a real person who solves problems. Like I said before, people solve problems. You can't teach passion or determination, or even the simple matter of caring. They either have it or they don't. To demean someone by reducing them to a number and making them perform at a whiteboard is missing the 90% of a person that makes them meaningful. To answer your question, I would say, "yes". Being at a smaller company allows me to not worry about the "policy" of hiring. I try my best to connect with a person on a human level. I work with humans, not formulas or people who identify a pattern that can be solved with something memorized from college. I look for people who realize that solving a problem involves much more. For example, I look for good habits. People who understand the value of things like continuity, continuous integration, best practices and such. Most interview puzzles are designed to identify something that plays a very small role in successful projects, and it rules out the most creative candidates. I'm no expert. I'm only saying that from my experience, puzzle solvers solve puzzles because that is what they are trained to do. And solving puzzles is mostly useless in the real world.
Ah damn I was thinking DFS. Guess I'm not getting hired.
Thanks for the perspective! What do you think are the first steps to fixing the "algorithms" problem especially at the larger companies?
Could anyone tell me how to deal with particular problem? Where should I store some global variables that are reactive and could be used in whole project? For example even just storing simple authentication data like is current user logged in, current user data, access hash etc? I need some global state in some real time applications that are updated by socket.io and used in different parts of whole layout. For example I have a navbar component, a footer component and a few vue-router pages that are inserted in between of navbar and footer. One of this page is login screen that posts user data and returns access token that is used to authorize further requests. I'd also want my footer to display "You are logged in as: {{ username }}" and my navbar to v-if include logout and profile button with current user name. Where can I hold this state to make it reactive on whole project? If anyone could ELI5, thanks
It would be an interesting prank to do a github streak of all doc fixes (spelling, spaces after periods, etc) and see which interviews don't notice and take it as real activity.
A lot of companies have something called the "as appropriate" interview. It's usually with the top dog and they have it at the end to see if they match a certain personality. If someone is able to jump through the technical hurdles, they get this interview. It's bullshit. It really means that the top dog is too busy to do the work to screen a candidate and they aren't invested in a person to learn about abilities from the start. In my opinion, the top dog should interview first. They should screen the candidates before any technical assessment is done. The most important facet of successful software development is having the right people. It's the number one priority. Everything else depends on it. I always make the first call to a potential candidate. Then I prep my team to learn things about a candidate that are useful to their job. And I always tell them to find someone who knows something they don't. Diversity is critical. Hiring "people like me" just creates mediocrity. And one other thing that I look for that most don't consider is a sense of humor. Never underestimate a good sense of humor. If you can make me laugh it means a lot. That may seem strange, but humor is perhaps the most intelligent thing a person can exhibit. And it makes the job worth doing. 
It gives you insight into how they work in an interview context.
I'm in the same boat, although I think that this can be achieved with Vuex: http://vuex.vuejs.org/en/intro.html
Thank you for the reply I appreciate it! So I definitely need to improve my programming but for this I didn't want to re-invent the wheel. I actually found a python script called trelloscribe that will connect with an API key and export the JSON to a markdown format. It will do what I need I just need to figure out a few additions to the script for it to fit. So unfortunately JavaScript was not the easiest way to solve this problem for me. I do appreciate the info though
&gt; Put as much money as you can now into retirement (and make as much money as you can now) You can't do that when you're unemployed, unfortunately.
Yup, it's a contrived bit of example code that can definitely break on corner cases. It's nothing to do with ES6 actually, but rather the particular use of split().
The internet is for porn.
Given the OP's task description and the fact that the scope was wide enough to include picking a database, framework, web server, etc, it means the surface area for scrutiny was enormous. This isn't about people slinging something basic together. Even Visual Studio has an asp.net project template that does almost all of the boiler plate for this kind of project. It's that they can go looking for reasons to not like you and confirm their initial judgement. Oh, she used jquery instead of zepto, huh, she picked postgres instead of maria, is that an .htaccess file, and so on and so forth. Hell, they could even dig around in the .ssh folder to see if you used a key for pushing the website. It's my experience from both sides of that table is if they aren't happy with you after the first in-person interview, then everything from that point on can only deduct from the score.
this.$root, or vuex, or redux