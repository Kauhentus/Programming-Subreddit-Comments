maybe i should have called it `The World`!
&gt; main selling point of jQuery Uh, no. I understand perfectly what jQuery is and what it does, I've been working with javascript every day for 21 years. I also understand quite well what transpilers are and what they do. Since he's deleted his comments, it seems he may have realized his error and been embarrassed by it. 
I've been very happy with [mock-require](https://www.npmjs.com/package/mock-require). it works very well with import syntax, with one small caveat: ------ if you only have a default export, you can just write mock('./original.module', DefaultExportMock); ------ but if you're mocking this file: export default class SomeClass {} export function doSomething () {} you have to tell babel to treat it like a module that uses export syntax mock('./original-module', { doSomething (req) {}, default: class SomeClassMock {}, __esModule: true, // &lt;--- babel uses this flag }); 
Second this. Excellent podcast.
Very interesting that you made that initial point. Webpack will transpile his first example, but rollup wont work. It's really been a pain in the ass to get to this point and realise that you can't simply mock import/exports without adding proxies. I hate adding code just so you can expose things to tests.
Informative and well written. Thanks for posting. 
What is specific about it ?
How is this more useful than just setting attributes on document.body.style? Doesn't this trigger a redraw twice? Once to do the HTML and again to update the CSS parsing? 
When I asked for people to tell me what they thought I didn't think I would get this. This was an amazing break down and solid advice thank you.
First-class integration with [scoped css](https://github.com/thysultan/dio.js#stylesheet) client and server, [render to cache](https://github.com/thysultan/dio.js#rendertocache), fragments.
Thanks for the advice. Im not married to the idea of listening to podcasts specifically. Anything that i can learn from by listening to when im driving or on dinner is mainly what I'm looking for, just something with an emphasis on audio rather than visual. I'll check out some of the conferences. Do you have any suggestions you think are a great place to start?
Jazoon in Bern
Jsconf EU
It probably wouldn't. I don't think extra files merely for the point of code organization is a good idea over the wire. We have learned from NPM the number of file dependencies that goes into the mix the greater risks that things come up missing for your users and then failures occur. I see this as only being handy for applications running locally. Perhaps applications transferred as a ZIP or compiled through a build task.
Too bad that it's opinionated. They should at least offer to use tabs instead of spaces and to omit semicolons if preferred.
Stupid Question: It supports Flow, does it support partially or fully Typescript?
Ugh why do people want to write JS as XML.
The former implies the latter. We all know what he meant. I'm correcting his use of "opinionated" in this context. You yourself immediately resorted to a more fitting word like "option". He should as well.
Well the ones you mentioned also exist on react native as well. It has grown a lot lately and there are lots of third party components created by the community. We could keep discussing the whole day, in the end we can agree both are great frameworks.
Lots of drugs. Heh. It depends on the patience level of who I'm working for. If no documentation exists (or is spotty) try to fix the documentation while learning about the code. On one occasion, I had been whacking away at a PHP application and I decided to count lines of code and lines of comments. 48k lines of code, 800 lines of comments, most of which I added. Start with the gross functions, eg, what are the major top level / top down components and how do they function. Add lower level stuff as you go along.
I think he's just talking about current HTML formatters out there.
Hello there person from the recent past, this thing exists now - https://codemix.github.io/flow-runtime/#/docs/pattern-matching
hi dan :-) this looks neat, will give it a try.
Strong opinion there bud, lets just walk it back a little.
I would be willing to help you if you drop jQuery from your code. I am not going to waste time guessing at jQuery's failing magic tricks.
I'll have to look into it, that does look pretty pleasant. I will admit that Promises aren't the prettiest thing to look at
&gt; There is no such thing as an unopinionated formatter. &gt; &gt; You just want them to add your opinion. Not to mention that the author likely sees the opinionatedness as a feature rather than a bug. For many people, the whole point of the [massive time investment](http://journal.stuffwithstuff.com/2015/09/08/the-hardest-program-ive-ever-written/) that goes into making a really good code formatter is to do away with all questions about code styling by making a tool that enforces a single universal code style. That's how [golang's fmt](https://blog.golang.org/go-fmt-your-code) works. Correctly formatted Go code is *by definition* whatever the output of Go's built-in formatter is. Adding a bunch of options would go against the grain for *go fmt* because the whole point is for everyone to format their code in exactly the same way.
Being opinionated is an advantage. See `gofmt`, or [this issue](https://github.com/jlongster/prettier/issues/40). The whole point here is to remove the choices and bikeshedding, and to enforce a unified style. It doesn't need to be the "best" style, and it certainly doesn't need to be *your* personal style; it just needs to be *a* style.
Nevermind, as small as that one-line props are I would've probably not noticed them as well. Thanks for helping man! :)
I agree. OP might have more luck on /r/webdev 
Easiest way might be a `Promise.race([&lt;promises&gt;]).then(updateDOM)` and a separate `Promise.all([&lt;promises&gt;]).then(handleData)` 
Thanks, I'll look into it :)
I'd argue that a more appropriate term in this case is "standard" rather than "opinion." A standard is an agreed-upon set of rules applicable to the problem at hand. While multiple opinions went into developing the standard, the standard itself came from deliberate thought, "best-practices," industry knowledge, etc. While this certainly isn't always the case, it's probably an important distinction.
document.querySelectorAll('.class') should be enough to cure the jQuery addiction. 
&gt; By calling Object.getOwnPropertySymbols, we can get access to the symbol keys. Therefore, *private fields are not truly private* I hate this statement, because it's so generic and it's misleading - almost no language have _truly private fields_. * Java have reflection, so private fields are not truly private. * C# have reflection, so private fields are not truly private. * PHP have reflection, so private fields are not truly private. * C++ allow pointer voodoo, so private fields are not truly private. * Python doesn't care anyway
Thanks for the suggestion! :)
I think you're looking for: http://momentjs.com/timezone/docs/
I don't know of a way to do what you're looking to do. Pretty much all of the collection operations simply create a wrapper promise that resolves/rejects based on certain conditions. Honestly it sounds like returning a promise in your then would be your best bet. But that code can get ugly kinda fast. It would allow you to resolve the top-level values more immediately and then fire the dependent promises. I guess it may help to know a little more about what the end goals. Ignore this I misunderstood your original question. 
You can turn it off if you enable Strict Dependency Injection
So first of all it's getElementsByClassName (notice elements is plural) which returns an array of elements. So you will need to iterate over that array with a for loop to hide them one by one. If you're trying to hide them all that is.
Probably, you should post it on the Upwork, or similar sites ;)
But it's not consistent 
Why don't you loop through your promise collection and add an update function to their promise chain? `promises.forEach((promise) =&gt; promise.then(update));`
So there's this test floating around motivated by [this blog post](https://dzone.com/articles/animating-2048-svg-nodes-in-react-preact-inferno-v), which compares react, vue, cycle-js, inferno, angular 2. All started from [this react-fractal repo](https://github.com/Swizec/react-fractals), they use the same math calc function and adapt the render logic to the library in question. This is my attempt at implementing it using [incremental-dom](https://github.com/google/incremental-dom). inc-dom is Google's API that exposes a patch function, and some methods that describe the dom (elementOpen/Close, elementVoid, and text) as opposed to the v-dom.
[removed]
Thank you for your respond! I just realized for my objArray parameter, it duplicates the value. Does it contribute to the problem as well? How can I solve the duplication? Edit: Already solved the problem! It was the duplication issue that caused all the problem. Anyway, thank you very much for your help. I really love the community in here. :)
Only the subset of the two that overlap. You can break the demo pretty easily with this line: ``` const a = (b as any); ```
Ah right! Saw that and i thought they were different arrays. That clarification makes sense! 
But i wouldn't be able to know in a nice way when all are done without having to store states. Someone gave a good suggestion: create the list of promises then run the same list on two list resolvers race and all. 
Angular 2.2. That's what it is. 
Not enough examples.
People are replying that opinionated is a feature, but a funny thing is that JSLint faded into obscurity because JSHint allowed you to configure your own rules, which was in turn largely displaced by ESLint which even allowed for plugins to define your own formatting rules. That said, it _is_ a bit odd that they do not use an AST for formatting.
Bold move Popmotion. No link called "demo" or "example", let's see how it plays out
that's literally what the "async" in async/await is for, [see the example](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function). async marked functions return promises
wait... what? Can you prove a syntax example of how you can use the async marker to return a promise?
[removed]
Ewww
All functions marked "async" will return a promise, no matter what happens on the inside. If you return inside the function, it will become the value inside the resolved callback function. If you throw inside the function, it will become the value inside the reject callback function.
&gt; Standards are a big deal and important to the future of the web. While libraries like React tout features like the Virtual DOM, they also come with the added baggage of promoting alternative non-standard abstractions like JSX syntax. "Standards" `&lt;template repeat.for="friend of friends"&gt;`, `show.bind="countTodosLeft &lt; items.length"`, `&lt;h1&gt;${arriving ? 'Hello' : 'Goodbye'}, ${name}!&lt;/h1&gt;`, `click.delegate="clearCompletedTodos()"`, `value.two-way="lastName"`, `model.bind="{ target : 'World' }"`, `&lt;tr as-element="hello-row"&gt;` Isn't it a bit much to talk about standards and then Aurelia takes a template and routes it through a runtime parser? The web-components spec doesn't even begin to address dynamic layout, lists, inline code-execution, bindings, etc. Which is why Aurelia relies on a superset, "AureliaXHTML." Functional components and transpilation solve issues that the W3C isn't going to solve. All vdom libs have recognized this. And while the comittee tries to figure out how to make creating a web-page *less* painful, vdom hovers over the dom without getting bitten. I see this as a major accomplishment of the web and i couldn't care less if it's conform (which it actually is) because the standard is inherently flawed and all we've done over the last decade is find ways to patch it, from jQuery, to Aurelia and others. It has led us to where we are today, thank goodness.
This is correct, as well as /u/bvx89's comment. To really drive it home though, here's your original proposal using async functions, with a few changes to make it realistic: async function foobar () { if (something) throw new Error('that') return 'this' } So, yeah, it's literally the same. Just takes a deeper understanding of Promises and what JS async functions do, since they use Promises under the hood. 
That's the world we live in.
Having standards compliance as a goal, and falling short is far better than just doing whatever is convenient. I personally think that the component abstraction (view.jsx) in react is the better abstraction over the explicit file standards (view.html &amp; view.js). But fundamentally, the issue is not the file standard, it is the lack of an official templating syntax in javascript. And lets be real. Just like import statements and a miriad other features in javascript. If the standards commitee got around to making an official templating engine spec, they would mess it up and we would be stuck with it. So having competing ideas in their areas in actual practice will inform eventual standards. I don't think aurelia quites hits the mark on how we would idealy want to do that, but I think it is fair to say that the semantics of it more compliant than react. Kinda like how webpack is more popular, but if we really take a wider view, jspm is probably closer to the ideal workflow that we want to achieve. If you step back and look at Aurelia as a whole from the vantage point of standards and workflow, I think it makes a strong case. And I've quite liked working with it. The separate html and js files is probably not a very useful separation of concerns, and as a result adds and unnecessary extra step in workflow, but other than that, I do believe the framework to be a step in the right direction. edit: Also, aurelia is full client framework, not just a view engine. Probably fairer to say that it competes with angular, and not so much react. And I think it "beats" angular quite handily.
How about making a real survey ? (Typeform, Gform, etc...) with public report. This could be interesting.
The Angular team has said: &gt; As you might have already guessed, the term “Angular 2” is also kind of deprecated once we get to version 4, 5 etc. That said, we should start naming it simply “Angular” without the version suffix. &gt; &gt; “It’s just #angular” &gt; &gt; Also, we should start avoiding GitHub/NPM libraries prefixed with ng2- or angular2-. http://angularjs.blogspot.no/2016/12/ok-let-me-explain-its-going-to-be.html 
To be clear, when I speak of templating, I'm speaking of the component level templates and dynamic rendering attribute syntax like repeat.for, value.bind and {variable} syntaxes interspersed within html and css on a specific component with limited scope. Not page level or razor view level templating, though that is certainly a clear use case from mvc that would ideally be supported by standards.
the name is just crappy...
It really sucks that Microsoft intentionally blocks modern web technologies.
Sure. We all can :-) Just out of curiosity (not trying to be a douchebag or anything; I'm genuinely interested), do you care at all about *how* people talk in addition to *what* they talk about? Just as a thought experiment, given the same content, would you prefer listening to people with, say, London accent rather than people with Chinese accent? Or you wouldn't care one way or the other?
Maybe use the IP address?
Angular ME ... SE
LOL!
I think people need to stop looking at JSX in React as HTML. It is not HTML. Instead, I see a React component as having no HTML at all. JSX is simply a pre-compiled API wrapper over a more verbose JavaScript API. You can use React with no JSX at all and the output is the same. JSX just allows you to write your virtual DOM in a way that seems familiar and friendly to you. Am I wrong in all this? I only started using React a few months ago, but this is the way I see it anyway.
Maybe some jsfiddles/jsbins that shows it in action, while at the same time showing the source, while being able to mess with it. 
How about using template literals directly? const tmpl = addrs =&gt; ` &lt;table&gt; ${addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt; `).join('')} &lt;/table&gt; `; const data = [ { first: '&lt;Jane&gt;', last: 'Bond' }, { first: 'Lars', last: '&lt;Croft&gt;' }, ]; console.log(tmpl(data)); // Output: // &lt;table&gt; // // &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt; // &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt; // // &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt; // &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt; // // &lt;/table&gt; 
Already presented on Stack Overflow [here](http://stackoverflow.com/questions/41071779/template-literal-trapped-in-a-string-variable/41073463#41073463). function eval_template(s, params) { return Function(...Object.keys(params), "return " + s) (...Object.values(params)); } const template = "`Welcome, ${user.name}`"; console.log(eval_template(template, {user: {name: "James"}})); By assuming the backticks are present in the input, also supports tagged template strings: eval_template("tag`${boo}`", {tag, boo});
Because this approach does not allow the template to be stored as a string, such as in a multi-language dictionary.
... which is supported by all relevant modern web browsers: http://caniuse.com/#search=css%20variables
It isnt an assignment operator. I believe you are probably looking at an es6 arrow function. const myFunc = someArgument =&gt; someArgument is roughly the same as function myFunc(someargument) { return someArguement } 
Are you referring to an [arrow function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)?
Yeah that is annoying. JSX is pretty sweet.
Tired of the pony or the stack exists because of pony? 
It's not exactly the same, but considering the question the answer is good enough.
Hi /u/analourenco, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `jscrambler.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.jscrambler.com](/search?q=%28and+site%3A%27blog.jscrambler.com%27+author%3A%27analourenco%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|7|100%
Really don't like Svelte -- it's the same concept as jQuery. It's just helper methods around the standard DOM manipulations. If that's your jam, that's fine, but it feels like a really bad dependency to bring in with minimal value past writing your own helper functions. Vue is cool, don't know if it'll really stick around, but I like some of their ideas. It's a nice alternative to Angular. Conditioner is interesting -- haven't seen that one before. Don't know how I feel about AMD being required. I wonder why they didn't choose SystemJS.
Small correction, "= is **right** associative", your example is correctly suggesting this.
That's true, but for example in Chrome it was actually removed for performance reasons and just recently added back 😊 But yeah, IE/Edge sucks – I agree 😄
It's used in arrow functions. function add(a, b){ return a+b; } and const add = (a, b) =&gt; a+b; are same.
let's go in parts. let {a, b, c} = o Is the destructuring part. this means: If `a` exists inside o, create an `a` variable in the local scope, and assign it the value of `o.a`. The same goes for `b` and `c`. But... {a, b, c} = o Is not a valid statement. Destructuring **don't work on existing variables**, you have to be creating new ones. However... When you do this: p = {a,b,c} = o; JavaScript will do the implicit `let` for a, b and c, if they don't exist, or, it will just assign if they exist. Which is completely odd. As others have said, the statement is the equivalent of p = ({a, b, c} = o) And {a, b, c} = o ...return o; That's why `p === o`. 
You can host a SPA if it only needs a single page and you have another server running the backend. You can take advantage of hash-based routing to imitate multiple pages too. Check out [Now](https://zeit.co/now) if you want more power. That or AWS or Digital Ocean are going to give you much more freedom.
Okay, so if I have an on click event that calls a function in react, it will call the function immediately on pageload, but if I make the event: onClick={(e)=&gt;myfunc()} It works as intended How does the (e)=&gt; actually change what's happening?
cool thanks, arrow function is what I was looking for
GSAP TweenMax It's in the script tags and it appears to require a license. I'd try http://www.createjs.com/tweenjs instead.
Move `add` into the prototype of `Point`, use `this` instead of returning `Point` and you'll be golden. 
If you're writing something like foo.onclick = myfunc(); That means call `myfunc()` now, and assign its return value to `foo.onclick`. foo.onclick = function() { myfunc(); } // or equivalently foo.onclick = () =&gt; myfunc(); These are both assigning a function to `foo.onclick`, and that function, when called, will call `myfunc()`. The expression `myfunc()` in both cases is in the body of an inline, anonymous function. It's not being called immediately, which is what `myfunc()` means outside of a function body. [ Edit: the two aren't technically equivalent, since the latter returns whatever `myfunc()` returns, but that probably doesn't matter since the return value of the event handler is discarded. Unless this is one of those DOM0 cases where `return false` does the equivalent of `e.preventDefault()`. Ugh. DOM0 rots minds, don't use it. ] 
Vue is pretty good. I'm currently building a large app for work with it. I'm not allowed to use React, and wanted flux. With Vue there is vuex for that. I've built many very large Angular apps, and am totally turned off by angular 2. I think their team made a major mistake with it. 
People stop learning frameworks... I agree with many posters below... - Principles and ideas - Javascript skills - design patterns - Testing - basics of Algorithm and data structures etc.. React builds on top where Angular. Not really a incremental approach but rather a sideways introducing a new way of doing things. However, the basic programming principles listed above still apply. from a practical stand point, given you have so much time in your day. If there are more jobs in ReactJS, I think your local job market has spoken. People in your local tech community believe in the ideas and principles. You already know what you need to do. LEARN REACT... and beef up on your fundamentals above while in your journey. 
How does it compare to Vue?
Hands down the best library for this: [parallax.js](http://matthew.wagerfield.com/parallax/) 
X-Post referenced from [/r/slack](http://np.reddit.com/r/slack) by /u/Nimsical [Setting up analytics for our bot with Botkit and Keen IO](http://np.reddit.com/r/Slack/comments/5ndgbp/setting_up_analytics_for_our_bot_with_botkit_and/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Just use a class. class Point { constructor(x, y) { this.x = x; this.y = y; } add(other) { return new Point(this.x + other.x, this.y + other.y); } } Simple enough, right? If immutability is desired, add `Object.freeze(this)` at the end of the constructor.
Dogfooding is great, but the site was created before Angular 2 was production-ready.
&gt; Are there any differences between them? Yes. Can you be more specific with your question? It's pretty nonsensical as-is. I'm removing this post for now, if you can edit in an actual question (and reply to me to let me know you've done so), I'll make it public again. Thanks!
Hi /u/aramkoukia, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `koukia.ca`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [koukia.ca](/search?q=%28and+site%3A%27koukia.ca%27+author%3A%27aramkoukia%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|8|89%
Hi /u/Nimsical, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `medium.com/@ngardideh`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [medium.com/@ngardideh](/search?q=%28and+site%3A%27medium.com%27+author%3A%27Nimsical%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|17|89%
now can someone explain this: `var o = {a: 1}` `o.x = o = {a: 2}` o.x is `undefined` but shouldn't it be o.x = (o = {a:2}) which is {a:2}?? 
Hi kenman, Oh, I didn't know that, will consider that in the future Thanks Aram
This is cool (if it's automated) haha Thanks, will do more diverse posting :)
My main question whenever I see these is, if you're already willing to eval a random snippet from a file, why not just have your template be a JS file with "export default addrs =&gt; ``" like the example? You get the benefit of linting, it's only a few extra characters, and it means you're not inventing more custom stuff from scratch.
You could use a tag to automate the joining
You could use a function and call it again when needed (I did it with a timeout so that the DOM could render before asking again): http://codepen.io/kLabz/pen/mRPyLM
[removed]
Use Array.prototype.filter to generate a new array which only contains those elements which match some criteria. things.filter(thing =&gt; thing.name === 'gary')
Use Array.prototype.filter to generate a new array which only contains those elements which match some criteria. things.filter(thing =&gt; thing.name === 'gary')
Of course, but the fact that they haven't updated it to Angular 2 kind of says something, doesn't it?
To add to this you could do something like `const thing = things.find(thing =&gt; thing.name === 'name')` to immediately get the filtered element seeing as in the example you're always just getting one result. Edit: http://codepen.io/Traverse/pen/RKaPLY code style probably won't be to everyone's liking but w/e.
Most teams/companies won't rewrite things without a pressing reason. If there isn't one, rewriting it just isn't very important. For example, if the documentation isn't up to snuff, you probably should focus on that first. Or performance. Or failing tests. Or any of those zillion issues in the tracker. They'll probably use a newer version of Angular for the next makeover. It probably won't be the bleeding edge version, though.
For what is basically a static page with pretty simple functionality? Probably not. 
You can use Array.prototype.find if you just want the first item which fits some criteria.
Ah yes of course silly me x) updated my answer to reflect this!
I would argue that this is a good case for it. If for no other reason than they can demonstrate "good" angular 2 in action.
He's obviously been writing those for a long time, by now he's most definitely a master baiter.
angular 2 is not good. commence operation downvote opusagogo
You're link to the "Github repo" is a link to the website rather than the repository. If we had the link to your GitHub we could critique the code (which is probably just as, if not more, useful to you).
&gt; including google They use the Dart version quite a bit.
Code is at https://github.com/mfDK/reddit_aggregator You have some indentation issues: e.g. https://github.com/mfDK/reddit_aggregator/blob/master/js/script.js#L11 https://github.com/mfDK/reddit_aggregator/blob/master/js/script.js#L45-L61 CSS indentation style is also fairly unconventional: https://github.com/mfDK/reddit_aggregator/blob/master/css/main.css The comments don't add anything, so they might as well not be there. Installation instructions are wrong. Code is fairly readable, and shows you can use vanilla JS, but yeah it's basic and there's not much to talk about.
they're using Angular 2 for AdWords...which is probably the highest-grossing web app in the world
I assume each website rolls their own version where they detect if the video is playing and in view. If it's not in view it moves it to a fixed position in the bottom left.
&gt; i'm sure the google closure developers are laughing their asses off at this post. Why?
 http://i.imgur.com/3lZfKEe.jpg http://i.imgur.com/kf7jvwF.jpg 
The problem here appears to come from the combination of these two operations into a single statement. As in, you're reassigning `o` to an entirely new value, but in the same line also assigning a property of this reassigned `o` to point to itself. These operations don't seem to like working together. These variations on line 2 all 'work' fine: o = {a: 2}, o.x = o // o = {a: 2, x: o} var p; o.x = p = {a: 2} // o = {a: 1, x: p} o.x = o.y = {a: 2} // o = {a: 1, y: {a: 2}, x: o.y} This all leads me to think that your example is evaluated something like this: var o = {a: 1} var oldO = o var ret = o = {a: 2} oldO.x = ret So because we're still evaluating left-to-right as usual, the parser will first recognise that we're looking to add a property `.x` onto the object `o`, and it stores these away because it first has to parse the value of this new property. However, inside the value there's a complete reassignment of `o`, meaning it no longer matches the reference that was initially stored away, on which to add the new property `.x`. So it's almost like it'll try adding the property onto the old value of `o`. --- Finally, have a look at this code sample which illustrates the above, and shows what actually happens: var o = {a: 1} var p = o o.x = o = {a: 2} // o = {a: 2} // p = {a: 1, x: o} So as you can see, a perfect example of why you might want to avoid using such constructs as `... = ... = ...`.
There's a site feedback link in the footer. Probably more constructive to use that than publicly bashing on Reddit.
You just keep on with your bad self.
A yearly calendar as in all the monthly calendars side-by-side? I think with this much information on screen it might be better to do a data table type thing -- make it filterable etc. 
I should just take out the Installation, theres nothing to install actually, I put it there to follow some README guideline. Also, I'm not sure how I can make it more than it is now, I would like to make it more advanced but I'm not sure where to start?
 async function foo(){ window.setTimeout(()=&gt;{ if (true) { return "what" } else { throw new Error('nah') } }, 100) } async function bar(){ let foobar = await foo() console.log(foobar) } bar() foo().then((res)=&gt;{ console.log(res) }) This throws undefined on both console.logs. I am using Chrome 55 nativity. 
Just linking to my comment below in case you have any suggestions https://www.reddit.com/r/javascript/comments/5naajp/suggestion_asyncawait_level_syntax_for_promises/dcaxpzg/
First thing I saw, "// Wrapped in IIFE to make more modular and not to pollute global namespace" This is self explanatory for anyone beyond basic competence with JS. I recommend taking that comment out. 
Ouch two lines down you pollute the global anyway. var popularSubs = ["AskReddit", "funny", "todayilearned", "science", "pics", "worldnews", "IAmA", "gaming", "videos", "movies"]; subs = document.getElementById("subs"); subs is global. I recommend using the convention of having var before each variable to reduce the chance of adding unintentional globals.
You could drill into threads to demonstrate recursion. That should also give you some room to think about how to handle navigation between different screens
You've spelled "visibility" wrong.
could you explain what you mean by drilling into threads?
Where does a come from in your example? 
Thank you. I'm not exactly sure how it ended up being spelled that way since I typed "vis" and hit tab to get that to appear. I would have never in a million years realized that was spelled wrong. 
Oooh I see what it does now. Had to look up indexOf . Did you cook it up on the spot, or is it a pretty common solution for this type of problem? No offense, but it looks very much like congrats for figuring out how to drill a hole with a carrot, but we have tools for that. 
The difference in performance is negligible, unless you are instantiating tens of thousands of objects.
A ToDo list is a great idea, thank you!! I've heard to stay away from frameworks until you've got the basic language down. 
But two wrongs don't make a right.
That would be wise. Most framework kind of "help" you by abstracting a lot of stuff that you should already know before using them (except maybe React, but still). Try to build a TodoList with plain JavaScript first. Then add modularity (export, imports, etc...) which will cut your application in a bunch of files dedicated to one tasks (search for architectural patterns!). Then add asynchronous code (I let you check on that, but basically, check what Promises are and how to use them). Use the latest versions of JavaScript (ES2015-ES6 minimum) by transpiling new JavaScript to browser readable versions with Babel. Finally, check what functional programming is, and try implement it in your code (hint: map, reduce, filter functions for arrays instead of for loops are a good start). Once you got that, you should try one of the current frameworks: React, Vue, Angular 2, Aurelia, Cycle, Ember. Pick one and have fun with it. Also try to understand their philosophy and what problems each of them solves, so that you don't stay stuck with one, when you could learn another and solve a particular matter in half the time. I'd recommend React because it requires to know JavaScript well to dev with it (and makes you learn some good JS stuff in the process!), but I'm biased since I love it^^ Ask any questions if that's unclear, or if you wanna know something else :)
Interestingly, I did a microbench on the two and nesting the function was actually faster with 100 objects (~2x faster). 
if you're struggling for ideas after a todo list / freecodecamp's ideas - I've been working my way through javascript30 and think it is solid. The idea is thirty mini lessons in vanilla JS by coding something real. You could certainly take most of those videos and expand them into something more than the tutorial covers as well.
Hopefully this doesn't come off as snarky, and I realize it's a bit tangential, but I can't think of any scenarios in which doing that seems like a good idea. If I saw it in a PR from a teammate, I'd suggest updating the code so each declaration is in its own statement. I generally treat all identifiers as constants, with some handfuls of exceptions sprinkled in occasionally. I've found that in many cases you can reduce mutability by re-organizing logic into smaller functions, which I'd argue helps improve readability. Picking up a few functional languages had a big impact in how I approach problems and the resulting code organization. I'd totally suggest trying out a language like [Elixir](http://elixir-lang.org)! It's really fun. 
Thank SPbot! Can always count on you.
You should set up JSHint to catch these kinds of problems. Also look into using an editor that fixes your indentation so that it's consistent.
`{a, b, c} = o` isn't necessarily the return value of `o` It's a new object with only the `a, b, c` properties of `o` Edit: this is totally wrong as pointed out below and I felll victim to why this is such a good question (and I've been writing JS for many many years) I literally read the setup, fell victim to the flawed thought this question preys upon and then went full speed into the blaze of glory. Thanks for those who politely and factually, correctly, attacked my comment. 
 if ( ~['yes', 'Yes', 'si'].indexOf(a)) { // you can look up tilde now }
Create a sudoku solver
That's a _lot_ of script.
Not sure if you're using React, but I just used this calendar component from airBnB that is pretty awesome. You can mark days that have data etc (I had similar use case to yours). Layout for an entire year is possible. It's got a nice API. It's the same one they use on the airBnB site. https://github.com/airbnb/react-dates
since your goal es2017, what made you choose express instead of koa?
It's the stack I'm mostly accustomed to honestly; I'm using this personally. I haven't really delved into Koa as much as I'd like, although I had lots of fun trying it out.
Async functions do return a promise, but you're mixing two different kinds of async here. `setTimeout` is based on callbacks. There's nothing telling the async function that you need to wait for that timeout / callback, so it returns before the timeout callback is called. In cases like that (converting "legacy" async or sync functions) you do want to return a new Promise and resolve or reject explicitly.
Ughh, I hate this kind of thinking. Functional programming, and immutability can be good things, but for ducks sake I wish people would stop thinking they should be used in every scenario. Both of them have a performance cost. It's encouraging people to be lazy, side effects and mutability can be good things, and not impossible to wrap your head around. Also a much more efficient (while still being functional) way to get kitten names would be this: function rBabyPetNames (names, animal) { return animal.months &lt; 7 ? (names.push(animal.name), names) : names; } const kittenNames = cats.reduce(rBabyPetNames, []); This also allows to do cool stuff like this: const babyAnimalNames = []; cats.reduce(rBabyPetNames, babyAnimalNames); dogs.reduce(rBabyPetNames, babyAnimalNames);
Sure, that's the range and selection APIs: https://developer.mozilla.org/en-US/docs/Web/API/Range
A great website for html, css, and js practice would be a mock e-commerce website. You can make a * registration page * login page * shop page where products are listed * edit your cart * checkout and you can use local storage and some stringified JSON to store shopping cart info. It's a pretty basic idea that there are plenty of examples of, and you can go a long way with and practice tweaking and adding functionality such as adjusting the quantity of an item when it's in the cart, add a sale price, tax calculation etc. 
The for-loop still has use cases, and I've read some perf comparisons that said that the for-loop actually outperformed forEach or other array iterators in some scenarios. For instance, what if I just need to loop over something 7 times and I actually need a side effect to happen (like the example - pushing a value into an empty array I just created)? Sometimes that's just easier, simpler, and more readable. Going out of my way to be clever and insisting to use functional / immutable patterns when they don't suit the scenario seems a bit unwise. Proclaiming that the for-loop is 'dead' unnecessarily rules out a tool that has benefited many programmers for decades. Why limit ourselves and give up some of our flexibility?
Curious to hear more about the choice of Jest instead of, say, Mocha. 
Just mock the methods on console, using sinon or https://www.npmjs.com/package/console-mock
hm. That's an interesting approach I hadn't considered. 
repost-a-rino https://www.reddit.com/r/learnjavascript/comments/5maeuk/speed_coding_the_game_snake/
&gt; Code that uses const (over var and let) is sexy as hell Heh, okay Can't break an iteration, might be valuable to point out 
Add this to your favorite page you've already created in HTML/CSS: ``` &lt;script&gt; document.querySelector('body').style.display('none'); &lt;/script&gt; ``` Now you have javascript implemented in your page. It's stupid, it just hides the page, but it's a starting off point. Change it to add different styles, or loop through elements with a delay doing animation tricks to them. Whatever you do, just get dirty with it :) Good luck!
that's crazy! In 30 minutes no less. this guy is fantastic. edit: what? am i the only one who likes no frills condensed coding demos?
You might not need a complex mocking system. const output = []; console.log = (...args) =&gt; output.push(util.format.apply(util, args)); console.log("foo %s bar", 23, {}, 'a'); // output is now [ 'foo 23 bar {} a' ]
This has the added benefit for large arrays of only iterating until it finds a truthy value. Granted, you won't see that benefit for small arrays, but it's a useful snippet to know.
6 days apart? &gt;&lt;
Might I recommend watchandcode.com for that? I'd highly recommend it for anyone learning JS.
With object destructuring, you don't care about the order of the properties within the object. In your example, the underscore is unnecessary, and will be undefined. {_, b, c} = { a:1, b:2, c:3 } // No "spacer" needed {b, c} = { a:1, b:2, c:3 } It's equally valid to put them in any order you like, as below. {d, a} = { a:1, b:2, c:3, d:4, e:5 } // a = 1, d = 4
For being Front end dev, I recommand you to move into the dev api : https://www.reddit.com/dev/api/ Web scraping is not good for this purpose.
Node.js is less hyped these days, but it has become essential for the JavaScript ecosystem: Don’t forget that most tools (gulp, webpack, Babel, ESLint, TypeScript, etc.) are all built on it.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/createjs] [Not able to make createjs animation play on Mouse Click • \/r\/javascript](https://np.reddit.com/r/createjs/comments/5nidr3/not_able_to_make_createjs_animation_play_on_mouse/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
That is false. The result of the expression `{a, b, c} = o` is, in fact, exactly `o`.
&gt;If a exists inside o, create an a variable in the local scope, and assign it the value of o.a. The same goes for b and c. `b` and `c` are declared in scope regardless of whether `o` has those properties. If it doesn't, they'll be assigned to `undefined`, but they will still be declared. &gt; Destructuring don't work on existing variables, you have to be creating new ones. That's just false. I think it used to be true outside of strict mode in older versions of node. But you can totally destructure into existing variables. [MDN's](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) documentation even includes examples of that. However, because of a quirk in how JS is parsed, the spec says that in the bare assignment case, you need parentheses around the assignment, like: `({a, b, c} = o);` Otherwise, the spec says that the `{...}` will be treated as a block. I believe, but I'm not positive, that the spec only adds that requirement so that the language can be handled by an LALR(1) parser. In any case, v8 does not appear to enforce this. &gt; JavaScript will do the implicit let for a, b and c, if they don't exist, or, it will just assign if they exist. Also untrue. If they are not declared, they will be set as globals (e: or it will error in strict mode), like any other undeclared assignment. There's nothing bizarre here. The parentheses aren't required in this case, so it's acting exactly as you'd expect based on existing rules.
In fact, in general the order of object keys is not defined. It's sort of become de facto standard for key enumeration to go in order of first assignment (except for keys that parse as non-negative integers), but that's not required by the spec. A lot of real world code assumes as much, though, so engines will probably continue to do it that way. But as far as language features go, you never have to assume any kind of ordering to object keys.
Any tests? How do you know it works? You are calling this a "hashbang router" (hashbang is "#!") but only seem to parse hash-based fragments (hash is "#") so I don't know if your thing is working as you intended or not.
I skipped through the video and saw him using xspeed and yspeed instead of storing the snake's direction inside the game matrix.
Prefer !! 
Backbone that's gonna be fun /s Seriously I'd do this: 1. Cover happy paths with e2e tests(selenium/cypress/whatever), add tests to CI 2. enforce strict linting in your CI- I prefer [standard.js](https://github.com/feross/standard) 2. Use [jsinspect](https://github.com/danielstjules/jsinspect) to find duplicated code, if any is found remove the dupes and add jsinspect to your CI 3. refactor component by component to react.js + MobX. Why this combo? https://swizec.com/blog/backbone-%E2%86%92-react-handling-state-with-mobx/swizec/7051 
I'd use [Sinon](http://sinonjs.org/) for this: 'use strict'; describe('a method that does something', function () { it('should not output to the console', function () { const mockConsole = sinon.mock(window.console); mockConsole.expects('log') .never(); methodUnderTest(); mockConsole.verify(); mockConsole.restore(); }); }); `mockConsole.verify()` will cause the test to fail if `console.log` is invoked.
#9 seems like bikeshedding.
Set the body's overflow to hidden.
Doesn't work on mobile Safari.
It's pretty much impossible on mobile Safari. You can get close (with ridiculous hacks) but it will always be a bit buggy. Welcome to the horror that is iPhone's web browser. Google "overlay overflow hidden safari" and be prepared to spend quite a bit of time on this. Consider giving up web development and becoming a carpenter or something instead.
Find something interesting on Codepen and tweak it.
This looks so damn promising.
Im not familiar with jquery and was wondering if this was possible with js and how. 
I started to learn by building a simple little incremental game. Dead simple but taught me quite a bit. Still an amateur, but I can create and recognise a bit of code. Timers, updating dynamic text etc etc.
You suck at Tetris too! Joking aside, that's really cool. You should make it so the lit pads are playable. Play Tetris with your left hand and a beat or melody on moving pads with your right!
&gt;why are you shuffling pixels back and forth to the canvas with a color scaling/clamping pass even if not dithering? Inefficiency of the code. I should return early. The shuffling is to grey-scale them. &gt;and as a followup, what's the point of dithering when you're only using solid colors? They're off/full R/G/B , so red, green, blue, white, magenta, cyan, yellow, black... so like a primitive silkscreen printing process where there's CMYK but in RGB format instead. It makes no sense, but just for fun because it looks very similar to the original image if you squint - showing dithering bright strong colors works well to reproduce true color. The way I'd do it for real is shuffle the RGB's into a greyscale buffer, and then run the dither code on that, then shuffle them back into the imagedata to re-display. Have you got a faster way? 
This article works better as a history leading up to async/await than it does for any argument against it (which isn't a bad thing).
Hi /u/techracers300, this post was removed. Please don't use ALL CAPS in your titles. Thanks!
&gt; This video stands out as a possible way to write Snake and nothing more. I feel like that's what it is. 
What do you want to happen when it is clicked? You'll need to store the number of likes, somewhere, right? Should this show all likes or just remember if a user has liked a particular thing?
Forgive me for my dumb question, but...What do you mean exactly?
That's exactly what I needed thanks! :)
Agreed. Await has been a treat to use in the C# world. Glad to see it in JavaScript now
Baby steps For a return value, yes, but for inline compare, keep it short and simple
I don't get what you want. Something like this? http://codepen.io/anon/pen/LxNJpP?editors=0010
In polynomial time. Easy peasy.
Yes! For example: function html(templateObject, ...substs) { // Use raw template strings: we don’t want // backslashes (\n etc.) to be interpreted const raw = templateObject.raw; let result = ''; substs.forEach((subst, i) =&gt; { // Retrieve the template string preceding // the current substitution let lit = raw[i]; // In the example, map() returns an Array: // If `subst` is an Array (and not a string), // we turn it into a string if (Array.isArray(subst)) { subst = subst.join(''); } // If the substitution is preceded by an exclamation // mark, we escape special characters in it if (lit.endsWith('!')) { subst = htmlEscape(subst); lit = lit.slice(0, -1); } result += lit; result += subst; }); // Take care of last template string result += raw[raw.length-1]; return result; } 
nice idea, I know lot of people around me looking for this :)
Breaking from iteration is the biggest reason I disagree with this article. I totally agree with immutability and FP but being able to say 'If this condition is true, stop iterating' is far too helpful to throw away.
You're not allowed to use the History API? That doesn't make any sense. 
Basic thing I'd go for as well is make some small project using some public API. Every frontend dev needs to know how this work and working against some API (fb, tw, gmaps, foursquare, spotify, etc.) will help you to face interesting problems to solve.
Generally speaking. The Pseudo code would look like. var start; startTimer() { start = now; } stopTimer(){ var elapsed = now - start; return elapsed; }
Hehe! That wasn't me playing :-P However, I know you can turn this into a crazy musical tetris game. Unfortunately you still need 2 hands on the keyboard, on to move, one to rotate. But that doesn't stop from making it more challenging :)
Still, even if that was the intention and you adhere to good quality code in your day to day then it wouldn't be second nature to initialise things in the constructor.
[ Redacted for professional reasons ]
Getting asked for credentials. I can still view the article but... check that out.
I would say you'd want ~30 minutes per video on average. The actual video lengths vary, they can be between ~6-20 minutes. There are some videos that encourage more of a "here's the problem, try it yourself, then watch the rest" type of approach, and you can either choose to do all the videos in that way or none of them, it's totally up to how you like to learn. For me, I always spend more than the actual video time because I go back and mess around with the code a little, try some other stuff, and really get a feel for what the lesson is all about. 
Hi /u/sqreen, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `sqreen.io`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.sqreen.io](/search?q=%28and+site%3A%27blog.sqreen.io%27+author%3A%27sqreen%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|12|92% [cto-security-checklist.sqreen.io](/search?q=%28and+site%3A%27cto-security-checklist.sqreen.io%27+author%3A%27sqreen%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|1|8%
Does it make sense to do both? Something like... observable .flatMap(item =&gt; Rx.Observable.fromPromise(async () =&gt; { await something(item); var x = await somethingElse(); await somethingOther(); return Promise.resolve(x); })) 
Originally I had the example listed as `getKittens`, but I wanted to force `map` into the example. This is one of the problems with contrived examples. It might have made more sense if it was converting a response from an api to a list of objects, but i wanted the example to be small. so it doesn't make a lot of sense because the example was forced. Cheers!
&gt; Unfortunately you still need 2 hands on the keyboard, on to move, one to rotate If you use the key A to move left, D to move right, S to rotate and space to drop then you only need one hand on the keyboard. Alternatively you could even use some of the buttons on the LaunchPad itself to control the piece and not use the keyboard at all, like for example have the bottom left four or bottom right four buttons on the LaunchPad control the piece (left or right depending on whether you are left-handed or right-handed).
Never thought I'd see "magic" and "WebSockets" used together. I guess it IS like pulling a rabbit from a code hat. The IoT reference seems a little out there. Otherwise, very interesting tricks.
Makes sense, although I'd then atleast rename your final variable to `kittenNames`.
&gt; simple I think more people knows what `!!` means than `~`. It's just obscure
&gt; Yeah, we've got to support IE9. Hmm still not sure I understand. It doesn't matter what browsers support it, do a feature check and incompatible browsers get regular links. 
Thank for telling me about Now. I set it up and now have a demo running at https://mwmaker-jzdoxxrwpy.now.sh/
Thats going to depend on if your action is synchronous or if you're using an async action. The use case you're describing is a little confusing and it seems like you might be going against the idea of react a little. If the console log needs to happen before the component re-renders, call it before this.setSomething(), if you are going to do something with the new props, call your console log in componentWillRecieveProps or in the render function. Once you call dispatch, the action will do it's thing. If it is synchronous, then it would look like this action -&gt; reducer -&gt; console.log -&gt; re-render If you have a thunk or another async action it would do this action -&gt; console.log -&gt; back to action (when ready) -&gt; reducer -&gt; re-render
You're conflating a couple different questions there. If no middleware interfere with the dispatched action, then the dispatch itself is 100% synchronous. "here" will be printed immediately after the store is updated. The process of updating the component itself will almost always be asynchronous, because React will likely queue up a re-render without executing it immediately. This means that when "here" is printed, the component will still have its previously existing props and DOM output. Definitely **do not** assume that the DOM has been updated immediately after the dispatch is complete, as that will almost never be true.
You can add any JS or CSS to Twitter feed in various ways, but only in your browser. For example, Chrome extensions [Stylish](https://chrome.google.com/webstore/detail/stylish/fjnbnpbmkenffdnngjfgmeleoegfcffe?hl=en) for loading custom CSS, [Tampermonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=en) for loading JS. There are plenty others for browser of your choice.
in your browser you can do whatever you want, by using something like customjs (chrome extension) for example, but yeah as the other guy said you can change how it looks for others
Built as a little experiment with Vue, instead of doing the usual to-do app. Only really works on desktop. You can checkout the repo: [here](https://github.com/hparton/terminal.reddit)
Not bad. Here's some things to improve: - variadic routes (e.g. `/a/:somepath...` that matches `/a/path/to/foo` - do something on route not found - support different prefixes, e.g. `#!` - support querystring and hash (so you can support stuff like `#!/things?order=name&amp;dir=asc&amp;page=1`) You really should consider using HTML5 history.pushState first and only fall back to onhashchange in older browsers. Otherwise you're ignoring 95% of your audience to cater to 5%. pushState gives you a bunch of important features: - ability to reload the same path - ability to remember last state when pressing back button on the browser If it helps have a reference, here's [the router module I wrote](https://github.com/lhorie/mithril.js/blob/rewrite/router/router.js) for the Mithril.js framework. It's just over 100 lines of code excluding querystring parsing code and it's [documented](https://github.com/lhorie/mithril.js/blob/rewrite/docs/route.md) and [tested](https://github.com/lhorie/mithril.js/tree/rewrite/router/tests) so hopefully it's a good reference. It supports all that stuff I mentioned above.
First, it's not an issue at all. The answer is you'll always google. And if you're not googling, you're thinking "how did I solve this last time" and reading your old code to see what you did before. Knowing what to google, knowing what problem you need to solve, and having old code that you can reference, those are the steps beyond beginner. Based on what people generally say, it stays that way for a long time. 
Who looks down upon ES6? Where is this happening?
if I were doing this i suppose I would set each grid of settled top to bottom would each be a series of kick, snare, melody top to bottom. as the you go up bottom to top the beats become more rapid (being two half 1/2 beats or 4 1/4 beats). whenever a row is completed that portion would play a reverse cymbal(the ringing you hear in along of electronic music). on loss you could also do a bass drop for funzies.
I think you may be misunderstanding caution on using some features of ES6 as "looking down" on it. ES6 is absolutely the state-of-the-art standard in Javascript and you should learn and use it. That being said, if you're working with older versions of Node or in a browser, you can't just use ES6 out of the box (mostly...newer versions of Chrome support much of ES6 and some features are implemented in other browsers, but overall, support is still spotty in browsers). Instead, you need to compile the ES6 code to the older version of Javascript using Babel. You should use Babel in this instance since ES6 is becoming standard and you might as well be writing it.
Thank you I got it now.
Oh you're totally right! I was combining some weird form of destructure+shorthand at the same time for some reason. the p = {a,b,c} assignment must've thrown me off. 
Thanks for pointing that out, you're totally right. I confused the two together at the time for some reason, probably due reading the p assignment and then just going with where my brain was. Makes me like this question more now.
Ha ha. This was cool. web sockets are fun. 
To add some context to the other answers here: one really big reason most sites won't let you insert Javascript into your posts is because of the possibility of XSS. If you put Javascript into a twitter post, and another person viewed it, your code would be run in the context of their open tab. This means that a malicious third party can all of the sudden do things like insert trackers, change links to point to malicious content, change information that you're viewing, make requests on your behalf, etc... I'm about a million miles away from being a security expert, so I'm assuming other people who know more than me could expand more. But in general XSS attacks can be really nasty. Twitter actually at one point a few years back did have a workaround to get Javascript into tweets, and it ended up going [predictably poorly](https://twitter.com/derGeruhn/status/476764918763749376).
Search for "cartesian coordinates library javascript."
The problem is the presumption people can make about JavaScript using classical inheritance rather than using what it really uses, prototypal inheritance, when they see the `class` syntax. People don't like that JavaScript is trying to pretend to be something its not. But if you look at what a "class" is at a high level, the class syntax, even though its using prototypal inheritance under the hood, still works fine for what it does.
Fucking cool. Scraping will be easy as hell with this!
Might wanna cross post this on r/GIS
hmm, can you link your webpack file? One potential suspect can be what you set devtool to. Try `devtool: "source-map"`.
The problem I have with Ember is that Ember can't decide what it is. Over the past few years new frameworks have changed the way we develop web applications and Ember has spent the same amount of time trying to chase them and never succeeding. At the end of the day a framework is just a tool. But the web has changed from a nail, to a brad, to a screw and Ember is still a hammer. While it's core users, like Backbones, will always stick around, I'm guessing Embers fate will likely mirror Backbones. There's a whole lot of screw drivers these days.
Create a Javascript monkey
paper.js proj4.js
Hack the Gibson.
If (C1==C2==0) In comparisons you have to use double equal sign
It's also a type of nail.
Thanks for the response. I do think your example does do a good job of introducing map and filter. And I agree with some aspects of your code like pulling out and defining passable map and filter functions, however I would personally not using arrow functions in this case as they cannot be named so you'll get less readable stack traces. I would use arrow functions, if I need the context not to change, or if I'm writing one directly in a function call, where the passed function doesn't need is own context. Also I don't agree that "Functions should do one thing", and i have read the "clean-code" rules before, I don't fully agree. Function calls have a significant cost, so to me it seems unwise to go that far. I'm well aware how to do functional programming, I just choose not to use it all the time. In JavaScript it's not one of those things where everything you write has to use it. Sadly this seems to be the trend people are trying to spread lately, and I'm actually quite pissed about it. The performance implications are often left unmentioned. You get people coming up with the "Functions should do one thing" rule, which actually if you take it for what it says, could simple mean it should have one consiquence. That could be the return value, or concise mutation of some state, that to me is actually an okay rule.
Thank you for the correction!
its speed snake. but yeah he doesn't know modern js very well. but still fun to watch none the less.
My comment isn't about JS specifically, but solid coding across all languages.
Was expecting something profound. I failed my self. 
programming = coffee + google + magic
There's a lot of information in this video so it's well worth the time. Should you want to by-pass all of the development and build process then create-react-app is for you. That said, having a solid understanding of Webpack is a great tool to have under your belt. Also, if time's an issue, YouTube allows you to watch it at 1.5x speed.
he's speed coding dude.
Hi, some typography choices are really awkward and make your text unreadable. Gists for examples is the best thing to do, but you need to choose the right filetype for great syntax highlight. And to lint your code to avoid it to look like a mess. Take a look at an article I wrote, the way are less formal but the goal is the same. https://medium.com/@Swizz/the-most-beautiful-javascript-functional-programming-syntax-f0698208da07
Yeah that is possible. But does not it look weird to have all promise, async-await and Observables all in one? I would prefer to have one or the other if possible. But @adregan does make a good point for Observables to be cancellable.
This is the easiest I could come up with. http://codepen.io/Linuxdirk/pen/XpKdmJ?editors=1010 It's documented in the code. Maybe check /r/DoMyHomework :)
Thank you very much!! This is great, thanks! Is it possible to have the price show in two places? So like price for adult, and then the price shown again that I would put in like a "total" section? I tried simply copying &lt;div id="result"&gt;&lt;/div&gt; where I wanted the total price, which is the same - but it doesn't show.
There is no way to play directly on the Lpad ?
You will need jquery as a dependency but you can do it like this. https://jsfiddle.net/wpkjqjbL/
well, you would need to link to the jquery library in the head of your doc. depending on what you need this should work: https://jsfiddle.net/ss7sdr8z/
I'm not too familiar with jquery. It also doesn't seem to work when I add it to my code.
The most pretty way to go about this would be to use [Angular](https://angularjs.org/) in my opinion. Angular is a javascript framework that allows for easy one way and two way [binding](https://docs.angularjs.org/guide/databinding). Think of it like an extension to html, while keeping the logic separate from the presentation. A simple way to implement the example in your question would be to have the [ngModel](https://docs.angularjs.org/api/ng/directive/ngModel) directive linked to the select element. You may also want to take a quick (1 hour tops) tutorial on angular before diving in. [^(link to codecademy)](https://www.codecademy.com/learn/learn-angularjs) ~~Will post full example and references soon. Hang tight!~~ **Update:** [Here](https://jsfiddle.net/05zte7h5/)'s a jsfiddle that shows you how it's done with Angular.
Your build should always be as small as possible. How large depends upon what you're including and how large your actual codebase is. Do remember, uncompressed size is just as important as the compressed size, if not more. Compression affects only the network later. The script still needs to be parsed and executed client side. On ARM based mobile devices with low thermal design, every extra amount can create a slower experience for your users.
You can simply add more places to display the result, sure. Just add more fields, give them an ID, get the node and set innerHTML in JavaScript. [I just updated the pen](http://codepen.io/Linuxdirk/pen/XpKdmJ?editors=1010) to show the price twice in different locations so you can see how it works. Again: There is no shopping cart logic behind it, its simple dumb displaying of values only.
The link leads to an empty workspace. But have you checked this exact same question? http://stackoverflow.com/questions/17684201/create-html-table-from-javascript-object
&gt; In 2013 when Single Page App was a very immature concept I beg to differ, I've been doing single page apps in GWT since 2006 !
I wouldn't worry about anyone "looking down on" ES6. Using the language according to recent specification is a good choice. If your environment doesn't support all the features you want (often the case with web browsers), you can also introduce a transpile step with a tool like Babel, that automatically transforms your ES6 code to more compatible format in line with previous specifications. If you do this, just ensure there's source maps so debugging points you to the actual source code instead of the transpiled code. If you want to use ES6 modules (e.g. import/export), you can use a module bundling tool like Webpack or Rollup to automatically generate bundles. This is necessary, because even though the module spec itself is there, there's no runtime module loader implementations yet. (If you just stick to Node and use the supported ES6 features with the node module system, none of this is necessary) If using some ES6 feature ends up being costly for performance, worry about it when you actually have the issue. Keep in mind the JS engines are also evolving and a lot of ES6 code is at least theoretically faster when the engine/JIT compiler can optimise it. Some new features like WeakMaps and WeakSets are made specifically for improving performance.
How was that a slight? 
We're using AWS Aurora under the hood. See [this FAQ](https://www.graph.cool/docs/faq/graphcool-technology-ul6ue9gait) for more details. Yes, advanced queries including joins are one of the biggest strengths of Graphcool and GraphQL in general. 
um..where do we see this?
&gt; I wanted to make sure that the first thing I wrote could be used at work Yep, totally reasonable thing to do. Shipping it is the best feature :)
Yeoman is kind of this if you get a proper template and don't mind spending time in the console.
Thank you for suggestion :)
No, but I just wanted to stress that you should temper this sentence. Most SPA issues, like the ones described in stilkov article, have been fixed a long time ago. Only early GWT versions suffered from not being able to do deep links or requiring to load all the code on the first page. So I definitely don't agree with "SPA was immature in 2013". "Javascript SPA frameworks were immature" would be better.
Yes, you are right. Thank you for the feedback :-)
There is a library shelljs (I think) for node, which re-implemented standard shell UNIX tools, it works on Windows too - google it. 
The spec defines value to also include `undefined`: &gt; “value” is any legal JavaScript value (including undefined, a thenable, or a promise). I definitely understand your confusion though, since the definition I think most people have in their head of `undefined` is "the absence of a value". So saying that the function returns a value x, is just another way of saying the it does not throw.
I'm referring to the production version. The dev version main.js is 9mb uncompressed
I'm not saying Ember.js is the best choice for the next 4 years - I do not know that :-) As of the day of speaking, I happy with Ember.js and sometimes use Vue.js (depend on context). The point in this article is more about, how to judge technology today, so you would be happy with your decision looking backwards in 2, 3 years. And it's very hard imho, that's why track my decision from the past to learn something from it. Would be very happy to hear this kind of stories of anyone else.
&gt; https://beta.etherpad.org/p/webpack Doesn't seem to work, I just see a blank document.
I haven't stopped using it, and I'm currently animating interactive elements for web and mobile. I use it to create the assets then make tilesets out of them or SVGs but that not as much. It's great as an asset creator
For those wondering what's the difference with React: https://github.com/alibaba/rax/blob/master/docs/difference-with-react.md It appears to be an Alibaba project, for compatibility with Weex
Cool, do you use it in conjunction with say Dreamweaver then? 
Yes, "returns a value x" means "does not throw". `x` could be `undefined` and a function without a `return` statement implicitly returns undefined.
Wow now lets not go and lie to OP. Plain old simple javascript is easy enough to do with with by just using the onchange attribute and innerHTML and getElementById.
Whoops...try this shareable link https://drive.google.com/drive/folders/0B0FOQKVNfN3ERnBKSUJKbUtsbzA?usp=sharing
Whoops...try this shareable link https://drive.google.com/drive/folders/0B0FOQKVNfN3ERnBKSUJKbUtsbzA?usp=sharing
erm no one uses dreamweaver hahah. I dont think ive seen someone having it open in a job in a few years. Yeah I use it with GSAP for example and swap sprites with TweenMax.set('#sprite',{backgroundPosition:"-1000px 0px"}); or similar. As for editors sublime or atom work for me, dreamweaver is really really show imo and its live preview isn't exactly live.
Are you familiar with https://github.com/gajus/react-css-modules/ ?
 &lt;div id="time"&gt;&lt;/div&gt; &lt;script&gt; var fnGetTime = function () { var d = new Date() , h = d.getHours() , m = d.getMinutes() , elTime = document.querySelector('#time') ; if (h &lt; 10) { h = '0' + h; } if (m &lt; 10) { m = '0' + m; } elTime.innerHTML = '(' + h + ':' + m + ')'; }; fnGetTime(); &lt;/script&gt;
Relative to the DB problems, couldn't you solve it the same way you would in a relational DB? I.E., rather than storing the name, store a primary key, then look up the user with that key whenever you need the name?
Thanks a lot!
Speaking of which, has anyone here used [Horizon.io](https://horizon.io/)? Seems like a free, open-source, alternative to Firebase. I'm curious if you feel it's worth using.
a =&gt; b is not logically equivalent to !a =&gt; !b, so you can't infer that if you don't get a return value then you shouldn't run the procedure. As other answers said, it makes the most sense to count undefined as a return value, and treat not returning as only when you catch an error.
&gt; One thing Ember doesn't do is blindly adopt shitty ideas, which IMO are: jsx, virtual dom/diffing, and reliance on imuttability. Because computed properties and template compiling are just amazing? And Ember Data is absolutely the shittiest idea I've ever come across. They didn't blindly adopt it, they blindly followed a horrible model because they came up with it.
typically you avoid remote execution, make a nodejs service to profile the things you want and return data. that way people cant exploit it. 
&gt; Relative to the DB problems, couldn't you solve it the same way you would in a relational DB? I.E., rather than storing the name, store a primary key, then look up the user with that key whenever you need the name? Firebase doesn't have joins, so this would be an extra query per relation. So if you had an object with three IDs to other objects it quickly becomes a mess. That's why they recommend denormalization. 
It's great, I helped friend of mine to bootstrap it for his startup and after more than 6 months of development, he is still very excited about it. He has some minimal backend, but most of the queries he can do from frontend directly. It's the easiest realtime stack (also in terms of easy understanding) I have used.
"open source" . Remember what they did with react recently?
Looks cool but that is one dumb name 
Good point but the difference here is that React is an actual software implementation whereas GraphQL is an **open** standard. The majority of GraphQL implementations and projects are actually not developed by Facebook.
I can not fathom what would happen if someone tried to approach our CTO and bother him with questions about React vs ng2 vs Vue etc. I am assuming that they would immediately be removed from their position. I am also assuming that the CTO's secretary would also be removed from her position, simply for letting that person through. Hell, the front-end web dev side of things doesn't even fall into the same food chain as our CTO. We're operating somewhere under the CMO, since the client-side of our site is about as important as our brochures or events.
To answer your question in a strict sense, no it's not SQL, so I guess it's NoSQL. But often NoSQL is associated with joinless key-value stores which is not the case here, because GraphQL supports relations which take the place of joins.
(Firebase Employee for the last 3+ years) Honestly I'd love to see "real" offline data in the JS SDK, you're definitely right, we've been talking about this for years and honestly it just turns out to be something really, really hard to do and we've never been satisfied enough to ship a solution. We all know the JS ecosystem is fragmented, but with Cordova and other hybrid solutions in place it's even worse especially when you're talking about storing data on the device (which is just generally subtly inconsistent). I don't want you to think we have given up on JS or aren't taking it seriously. For years we wanted to be mobile focused but we weren't quite there. Once we joined Google we finally had the knowledge and resources to do what we always wanted in mobile, so we did. JS definitely took a little bit of a back seat but only because we were making up for years of back seating mobile. Now that some time has passed since IO we finally can revisit many of these long standing concerns. Honestly offline for JS just came up in a meeting this morning. We know it's an issue, we know you want it, but we are not willing to compromise and ship something that isn't good enough. So it's consistently been pushed back. That being said, lots of exciting JS things are coming. We love JS just as much as ever and it'll show more soon! All the best, Abe 
No worries! Here's an example of a sprite sheet put into work with minimal lines of code http://codepen.io/MAW/pen/MYdwRP
It's probably all the libs. Freaking lodash adds 1mb right off the bat. 
What is this NoSQL? I remember when graph and columnar databases were popular in the 80s and 90s, and it wasn't called NoSQL. Firebase is just tightly limited, its not a matter of it being 'different because its better than the big bad SQL'.
What's the difference between jquery-ui and jquery-ui-bundle?
React is merely the view layer of your application. The most common way to use React is by creating a JSON API with any backend language and DB you desire, and just use Ajax requests with React for the front end. You can really decouple the client side application from the server api this way. An advantage of doing thing this way is that your API will be available for any device that wants to present your stored information in whichever platform you desire
Well, first of all React is not an all round web app framework like Rails or similar. It's a library for building UIs in a form of reusable components using JavaScript and a syntax extension called JSX. Every components has properties (its input parameters, so to say) and state. You define a render function that is a representation of a component for the given properties and state. When props or state changes, the components renders again and under the hood React mutates the DOM in a optimized and performant way. This has advantages compared to some existing JavaScript MVC solutions whose bidirectional data flow and state management can introduce many difficulties and bugs on a large scale. So, React itself doesn't have anything to do with the database and other web stuff except the UI. You are free to choose whatever technology you want for that and combine it with React to make a web app. Check out these links for start https://facebook.github.io/react/blog/2013/06/05/why-react.html, https://facebook.github.io/react/docs/thinking-in-react.html
I would do this through [MutationObservers](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) personally. And you probably need to track the tweets by status_id as I think a tweet can get deleted in a new load, so tracking by index would be unreliable.
Thanks man. What if I only wanted to change the color of select tweets (included dynamically-loaded ones)?
I thought so too at first, but if you say GraphCool out loud, it sounds a lot like GraphQL, which I thought was relatively clever. 
Depends on what makes them "select." Is the user choosing them, or is there something different about them?
As usual I'm around for ChakraCore questions (or, you know, whatever other questions you have). Also just want to say thanks to this community in particular - you may not know it but we love you :-P
The idea is that eventually the extension will flag certain tweet posts based on their text content and do something to them (i.e., change their color) - but not every post. The flagged posts might be on the initial twitter load when a user visits a page, or they might show up after the user scrolls down and loads new tweets several times. The initial code I posted above will examine the initially-loaded tweets when a user visits a page, but not the ones that dynamically-load later on after the user has scrolled way down.
Not with breaking changes every 6 months!
Webpack and Vue surprise me, given the volume of sponsors/backers they have.
Prism.js looks pretty good. However, I think in terms of actual output quality, jQuery.Syntax has better line wrapping behaviour, better tab handling and you can embed HTML (e.g. `&lt;span&gt;`, `&lt;a&gt;`) into jQuery.Syntax code and it's preserved on the output. Also, I worked pretty hard to make jQuery.Syntax efficient and fast. You don't need to include any CSS by default, it's all dynamically loaded. Additionally, the actual parser/renderer is pretty damn fast, it would be interesting to compare it but I'd personally put my money on jQuery.Syntax being faster :)
That's good to hear. Just to be clear, I'm still a huge fan of Firebase and think it's an amazing product. But yeah, the JavaScript SDK has been taking a back seat lately. After reading your comment I'm looking forward to what the future will bring for it. Keep up the good work!
Wrap it in a function, include a counter, increase that counter by the number of loaded tweets, re-run that function when the dynamic loading happens only on the tweets with an index above the counter, increase the counter to the number of loaded tweets, rinse, repeat.
It's pretty awesome!
Thanks Abe, you guys do some great work.
That's not too surprising. The StockFish source is pretty obtuse and lightly commented, so you would want to modify it as little as possible.
Checkout https://scaphold.io/ if you want to experiment with GraphQL quickly, they also cover more difficult features like subscriptions.
Angular is a large payload if we only need data binding. (sorry to be /that guy/)
what did they do? out of the loop
It's just a CSS file you can change if you like, it's just not loaded unless it's needed.
If a CTO is *directly hiring* devs, you're at a tiny company.
In no particular order: * cache busting * live reload * karma integration * Integrates with CircleCI * webpack/npm (or systemjs/jspm, or nothing) * ES2015 transpiler support * supports React / Vue / Angular * Options to have a full-stack ToDoMVC demo, a single homepage, or a simple hello world landing page * The full-stack ToDoMVC includes tests and Redux -- great if you want to learn about either of those. * I don't have to setup my own projects, I just write code
Given the question, OP sounds like a lot of data binding and collection is necessary. That being said. I'm all for pure Ecma! Nothing better and lighter, but writing a personal library for data binding also seems like overkill. OP is better of with Angular if OP needs binding in more places than one. If not, I agree, a simple listener is right.
FYI: Meteor works with React. You might want to start there since you already know Meteor.
This may not be the right place to ask it, but I have a question about implementing WebAssembly. How are browsers/engines expected to implement memory accesses in a reasonably performant way? Will every attempted memory access result in a function call and a lookup, or are implementations expected to somehow set up a page table? I have no experience with any of this stuff, but it really feels like adding a function call to every memory access would seriously degrade performance.
For me it had to do with unfamiliarity of core concepts in the browser world. Webpack doesn't fill in holes in your knowledge and can get confusing, especially if you've only written static CSS/JS.
[removed]
Memory access in wasm is very fast. There are no function calls - a wasm assembly has direct access to memory and can manipulate it like any native assembly can. There are [docs](http://webassembly.org/docs/semantics/) on what kinds of things wasm code can do, but it's a pretty tough read if you don't have experience in this area.
Surely the code generated by the JIT compiler must convert from the index in linear memory to the actual memory address. Wouldn't that require a function call? (Or am I wrong that the linear memory might have to be stored noncontiguously?)
[removed]
[removed]
They did it because many people want to write code in an object oriented way and they got tired of every other framework and tool coming up with their own way of defining classes. Whether you use it or not, and how, is up to you. The recent JS mantra is leaning towards a more functional approach, but classes are there for people accustomed to OOP or coming from different languages. 
Most of what classes do can be replicated without using classes, but you're still overly simplifying things here. Try theorising for yourself about how you were to replicate certain parts of the class functionality. Sure, everyone can probably manage to replicate at least some parts, but other functionalities are very tricky to actually implement without using classes. I think the main reason for adding classes is because class-based code is still very common to see in the average script. Such code generally looks awful though, and becomes annoying or even difficult to maintain very quickly. So classes are useful in those cases where you actually find yourself writing class-like code. They can help make your code shorter, cleaner, and easier to maintain.
does it change the way you structure your code, or is it all syntax? 
It doesn't provide any kind of different functionality or structure than what you could do before (for now), just a nicer syntax of doing it. 
I'm so lost right now
Solved by Cloudant. Native libraries for android/iOS. JavaScript library pouchdb. Offline first implementation. 
This is a good primer. I enjoy when authors give some real(er) world examples when explaining functional programming.
pardon my ignorance, when does using a class syntax become more beneficial?
Javascript added classes because it enables familiar syntax that expresses semantics common to many programming languages. Yes, one can use functions and prototypes Instead to achieve the same results. This question is like asking: why add `Array.map` when js already has loops and functions. It's convenience mostly -- you could easily write your own map function. Classes are useful for encapsulating state and organizing functions. Classes do not have to contain an internal state, and `static methods` can be used to access the functions without relying on the `new` operator.
Did anyone look at Deepstream. This looks like the most promising open source firebase competitor. Any thoughts? I really liked how they wrote this blog post. https://deepstream.io/blog/realtime-framework-overview/
That depends on how you currently structure some of your code. Working directly with prototypal inheritance gives a bit more syntactical freedom, literally because it enforces a lot less strict syntax. This can be both a pro and a con.
When it's using abstraction and inheritance beyond what prototypical inheritance can offer. Here's what I would consider a decent article on the difference in Javascript's implementation of classes for beginners. https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9#.puj0rxw11
When you have (or plan to have) lots of code that adds methods and properties to prototypes, for implicit this scope.
Classes are beneficial in a couple of areas: 1. When you have several chunks of related data. Let's use Python's `namedtuple` as an example. When you call `namedtuple`, it returns a `tuple` (read: `Array`) subclass, where each element has a name binding as well. This allows you to keep track of what each item is supposed to be. In Python, that's great, but in Javascript, it's essentially the same thing as creating an `Object`, so there's no nead. 2. When your related data have *rules* to them (this is where it's useful in Javascript). Let's say you wanted to have a complex number. Think `a + b * i`. While you can do this easily in functional terms, it can be very easy to self-document if you write this as a class. For instance: class complex { constructor(a, b) { this.a = a; this.b = b; } negate() { return new complex(-this.a, -this.b); } add(c) { return new complex(this.a + c.a, this.b + c.b); } sub(c) { return this.add(c.negate()); } mul(f) { let a = this.a * f.a - this.b * f.b; let b = this.a * f.b + this.b * f.a; return new complex(a, b); } div(f) { let a = (this.a * f.a + this.b * f.b) / (f.a * f.a + f.b * f.b); let b = (this.b * f.a - this.a * f.b) / (f.a * f.a + f.b * f.b); return new complex(a, b); } } 3. When you have common properties between data types. For instance, numbers are just complex numbers with a `b` of 0. So: class number extends complex { constructor(a, _) { super(a, 0); } valueOf() { return this.a; } }
Yeah I think it does. A `super()` call does initialization from the parent down in classes, so you can extend exotic types (e.g. Array). I don't think you can do that through standard prototype chaining.
Some interesting background: Some of the earliest official discussions of `class` in TC39 are [summarized here](https://github.com/tc39/tc39-notes/blob/master/es6/2012-07/july-26.md). I find it most interesting that the subject of Ember got the ball rolling and that Doug Crockford wanted class expressions (similar to named function expressions -- implying the same hoisting cognitive overhead) rather than class declarations. And they were aware from the start of the mutation problem modules spec has now. In the end we got a declarative class syntax that is completely familiar to any Java/C++ developer (minus multiple inheritance) and no hoisting at all. I'm not sure where we netted out on mutability.
yep :) https://jsfiddle.net/5b27qt65/1/ i had a similar question long ago: http://stackoverflow.com/questions/16679158/javascript-imagedata-typed-array-read-whole-pixel also you don't need buff8, you just need to grab the underlying `ArrayBuffer` and make a `Uint32Array` view into it. that's how it works anyways when you pass views rather than buffers into other view constructors. ~~I don't think there's a way to get around the fact that getImageData returns an a view into an ArrayBuffer that appears to be copy-on-write. Which is why you're forced to call `.set` to copy it back.~~
I've just discovered something LOTS of sites get wrong online, they make an array buffer needlessly: Old SLOW way, making an empty array buffer: var imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight); var buff = new ArrayBuffer(imageData.data.length); var buff8 = new Uint8ClampedArray(buff); var buff32 = new Uint32Array(buff); ........Manipulate arrays here....... imageData.data.set(buff8); ctx.putImageData(imageData, 0, 0); Faster, and contains what's in the canvas already: var imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight); var buff8 = new Uint8ClampedArray(imageData.data.buffer); var buff32 = new Uint32Array(imageData.data.buffer); ........Manipulate arrays here....... ctx.putImageData(imageData, 0, 0); 
Well sure, that is totally unnecessary. But the class keyword doesn't change that - you could do the same thing with prototypes and it wouldn't make any more or less sense. The class keyword was added because JS didn't have a straightforward way of writing code OOP-style, but people were trying to anyway, hence the million or so implementations of class-like functions in JS frameworks.
have you tested it? I'm pretty sure that any manipulation of the underlying ArrayBuffer you get back from getImageData (through any view into it) causes a silent copy-on-write to happen behind the scenes. Which is why you have to call `.set` in both cases. In the first case you're doing the same thing just explicitly. It might make a big difference though if you're not modifying/overwriting every pixel.... I said the same thing here: https://www.reddit.com/r/javascript/comments/5nvy7g/my_array_views_for_my_canvas_arent_working_please/
&gt;causes a silent copy-on-write to happen behind the scenes. Ok. &gt;Which is why you have to call .set in both cases. But I don't in the second case...no copy back at all.
This line can be deleted! Does that mean it's not being copied? imageData.data.set(buff); I'd love to know the performance difference with and without that line... I like your SO post - questions about reading existing data in 32 bits leads the way to quicker writing too!
huh, i guess you're right. the manip is in fact direct then and the `.set` is redundant. but there is no perf difference at all. the browser is prolly is smart enough to know you're setting a buffer to itself. same as `a = a`.
How does Firebase handle API changes? Did you experience any "breaking" changes which you had to update on your side prior to some critical date or it supports legacy API versions? Or it never does any breaking changes at all?
People are saying familiar syntax, but I think it's more so about creating a syntax that allows you to do stuff like extending prototypes. Sure they could add a global function that extended prototypes, but a class syntax made that cleaner.
Extending `Array` doesn't work in Babel. It's not possible to shim that in es5. In [this conversion](https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015&amp;experimental=false&amp;loose=false&amp;spec=false&amp;code=class%20Foo%20extends%20Array%20%7B%0A%20%20constructor(\)%20%7B%0A%20%20%20%20super(\)%0A%20%20%7D%0A%7D%0A%0Aconsole.log(new%20Foo(\)%20instanceof%20Foo\)&amp;playground=false), the left side outputs `true` and the right side outputs `false`. edit: fixed broken link
Why on earth do you use the react Symbol inside CSS??? A simple R prefix would be easier to type and understand. Most people write CSS in lowercase as well so it shouldnt clash with other CSS frameworks etc. 
700kB is big, no doubt. Our production bundle is ~450 kB gzipped, and frankly, we aren't too happy about it, but that's just how things are at the moment. We threw out so many libraries over time, lodash, moment and many more. Eventually we got to a point where sacrificing more libraries meant trading in an awful lot of grunt work in JS. So we settled at the 450kB mark. I would have liked to have it around ~250 to 300kB, but that's very difficult.
One thing people leave out with async is that it's so easy to use resolved values later without the need of passing it down the whole chain. That's worth so much 
Yap. Syntactic sugar. 
Nice, cheers. I just need to study how to compile a whole site correctly with just an editor like Sublime. I'm coming from a web builder front end design point of view unfortunately. 
Very interesting. Had no idea this existed for node. Wish it had more methods available but this is a great start.
Because apparently it's very important to JavaScript users that there are at least half a dozen ways of accomplishing any given simple task.
Hello. I'm not sure that I correctly understand your question. Could you show the error? I think what you're missing to send the requests yourself is a Steam API key. When making the request to the website, it then makes its own request to the steam API, using your tradeId that was saved in their database, along with an API key generated from Steam. I've been running a small CS:GO Gambling website in the past, so feel free to DM me if you have any other questions related to the steam API, but this subreddit might help you more than /r/javascript: http://reddit.com/r/steambot Edit: Oh, I think I get it now: you are trying to use the "website"'s API, without being logged on it? You aren't trying to use the Steam API directly, right? What is different from using the console on the website VS doing your POST request from NodeJS is that the server has no way to know WHO you are in their database, in order to retrieve your trade token (trade URL) and the other guy's trade token/steamID. Except if they use the SteamId passed in the data... But then it should work... Check your cookies and/or localStorage on the website: maybe it is storing a token there to authenticate you, passing it along using a request header or directly in the POST data. And maybe it works when you use the console because the website has some JS that intercepts all XHR requests, adding your authentification "credentials" to all requests. You can inspect the POST request directly in the chrome developer tools, if that helps.
The answers to those questions can all be found here :) Except for the size constraint. MobX is 40kb gzipped, half of it probably error messages and internal assertions. https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.8681ckk1l
Nice
You can probably log in using rest requests. Just log out in your browser and then open the chrome dev tools. Then log in while watching the network tab. There is a setting you might need to turn on that preserves the calls from one page to another. Just find the one that is logging in. 
Thanks for this, can you expand a bit on how example 1 would become messier than example 2 if you fledged it out? Right now I don't really see a difference in readability, but I'm sure I'm missing something. 
Yeah if you have two factor you are kind of hosed there. You probably want to look into the steam API. Do they have oauth?
Yes, you can use [image-webpack-loader](https://www.npmjs.com/package/image-webpack-loader) and/or inline images below a certain size. This will inline images below 10kB: loaders: [ { test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url', query: { limit: 10000 } } ] See [this](http://survivejs.com/webpack/understanding-loaders/loading-images/) for more information.
That doesn't really answer the question of how to do it in Webpack though. Do you use https://github.com/boopathi/gm-loader ?
No, node_modules will work fine :)
I see. Under what circumstances would it not be needed?
Hi /u/jonathanmh, last [warning](https://www.reddit.com/r/javascript/comments/5cd640/).
Ahhh! Perfecto! That looks like code without any ignorant overhead. I'll use it from now on.
Hello Kingromes, I have a small follow up doubt. When the animation runs, the circle is first displayed and then the animation is played. There is actually a flicker of the circle. Any way I can avoid this flicker? Avoid the circle first getting shown and then the animation starting. 
Hi, how is this NOT JavaScript related? Just because I have ads on my blog?
I could probably clean this up more, but here's a radial menu with just CSS: https://jsfiddle.net/rytqovLw/ &lt;div id="menu"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#" title="#"&gt;1&lt;/a&gt;&lt;/li&gt;&lt;!-- --&gt;&lt;li&gt;&lt;a href="#" title="#"&gt;2&lt;/a&gt;&lt;/li&gt;&lt;!-- --&gt;&lt;li&gt;&lt;a href="#" title="#"&gt;3&lt;/a&gt;&lt;/li&gt;&lt;!-- --&gt;&lt;li&gt;&lt;a href="#" title="#"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; - #menu { width: 150px; height: 150px; outline: 1px solid red; } ul { list-style: none; position: relative; visibility: hidden; width: inherit; height: inherit; background-color: #1F1F1F; border-radius: 50%; box-sizing: border-box; } li { position: absolute; width: 32px; height: 32px; text-align: center; outline: 1px solid green; } a { text-decoration: none; font-size: 16px; line-height: 2; color: #FFF; font-weight: 700; display: block; background-color: #000; } ul &gt; li:nth-child(1) { top: 0; left: 50%; margin-left: -16px; } ul &gt; li:nth-child(2) { top: 50%; right: 0; margin-top: -16px; } ul &gt; li:nth-child(3) { top: 50%; left: 0; margin-top: -16px; } ul &gt; li:nth-child(4) { bottom: 0; left: 50%; margin-left: -16px; } #menu::before { position: relative; content: "HOVER"; width: inherit; height: inherit; display: block; text-align: center; top: 50%; margin-top: -.5em; outline: 1px solid blue; } #menu:hover &gt; ul, ul:hover { visibility: visible; } #menu:hover::before { display: none; }
* I don't post enough to spam * It's about the JavaScript build toolchain * It's content that's not really elsewhere (I looked, mostly webpack 1 or no style file entry) I get if you don't like posts likethe previous one about atom themes, but I have no idea why you warn me on this. I read your guidelines again and all you say is "read the links".
Quantity != quality, most of those packages are very low quality or in embryonic state. 
Held up a sign that said `Hello` in perfectly legible writing. It returned: "h «.2" Might want to work on it a little more before putting it on mobile.
That's why you use tools that help you 
You are conveniently overlooking the crucial sentence: &gt; In short, you should post from a variety of sources, and not just `jonathanmh.com`.
So basically you prohibit information, no matter if relevant and liked by readers, because I don't dump my bucket of other JavaScript links in here?
Most of the overhead is done ahead of time during the compilation, so the actual runtime performance is not affected much. The OS does these same kinda of things to keep memory used in applications away from the kernel, but the overhead is very minimal. Modern CPUs even optimize for certain instruction combinations.
The guidelines are from reddit, not me.
If you don't know what constructor functions are, you probably have no need for classes. A really great, often overlooked, feature of javascript is the ability to create objects _without first creating a class_. Most of the times you only create one object of a specific "type", then a class is totally unnecessary. It's only useful if you want to create many similar objects, each with similar functions and attributes. 
npm already changed the rules after left-pad so that it can't happen again. No "distributed version" needed.
You don't need Babel, just a polyfill.
You can't return anything in constructors (e.g. putting "return 5;" at the end will do nothing). Anyhow, Object.freeze freezes the object itself. It doesn't create a frozen copy. It only returns that very same object.
Read the article. 
But like what?
You can override the function like so: var old = x; var x = function () { spy(arguments); old.apply(this, arguments): }; Edit: without more information about your setup, code, etc, it's difficult to help you.
Great explanation! Thank you for this!
So what do you use, fucker? You make everything from scratch?
We're using blitline at work to do something similar. Their service isn't free though, so it might not be the best choice.
This is definitely the case. There are countless packages on npm that are unmaintained or only used by their creator. I don't think there's anything wrong with that though. I just wish npm had a namespace system to avoid module name squatting.
Sure, no problem. Really, the theory is basic enough that it will apply to JavaScript and any other language, but let's assume I'm talking only about JavaScript. Good practice states to use the constructor only to build, or construct, the object, and only from the parameters provided; code like this is fine. class Game { constructor(width, height, size, fps) { this.width = width; this.height - height; this.size = size; this.fps = fps; } } The problems with the constructor in the video are that of accessing `document` and looking for elements in the DOM, and creating a timer, which is a side effect. There are higher level problems as well, but they're beyond this explanation. ------ Why are these wrong? By accessing `document` from the constructor, the Game class is assuming two things: * That `document` exists * That `document`'s state is such that it can be queried for elements These assumptions are problematic for a number of reasons, but a couple important ones come to mind immediately: * `document` might not exist in a testing environment, and it doesn't exist in node.js. * The elements might not exist on the DOM, or `document` might not be a DOM. The constructor should not have the responsibility of figuring these out, because Game only knows how to construct itself from the parameters it's given. By creating a side effect, we've ensured that creating a Game will affect the runtime state of the entire application. This may sound innocent enough, but it's important to consider the "purity" of each operation. In this case, when we create a Game and expect only to get a Game back, there's now something else happening that could possibly affect what we actually want the application to do, and it makes debugging harder. I'm having a difficult time trying to figure out how to make this concept simple, so for now, I'd ask that you trust me regarding side effects. There is plenty of literature out there on side effects too, if you want to research further.
Totes agree. It's like the android play store. They used to boast that they have more apps than their competitors. But that's because it's flooded with spam and useless apps. 
A lot of people still use billion incorrectly, where it used to mean what is now called trillion.
Huh. I wasn't aware of this feature. I'd like to see this become required so all packages are scoped.
Try $("#nav").css("backgroundColor", "transparent");
A better implementation would be to apply or remove a class from the element using $('#nav').addClass and removeClass. That way your styled are contained in CSS files. 
Yeah, I understand how prototypes work. But prototype chaining doesn't allow you to extend exotic types in pure JS due to the order and nature of object initialization. ES6 classes reverse it. From _[Classes in ECMAScript 6 (final semantics)](http://www.2ality.com/2015/02/es6-classes-final.html#subclassing-built-in-constructors)_ by Axel Rauschmayer: &gt; In ECMAScript 6, you can finally subclass all built-in constructors (there are work-arounds for ES5, but these have significant limitations). &gt; For example, you can now create your own exception classes (that will inherit the feature of having a stack trace in most engines). &gt; You can also create subclasses of Array whose instances properly handle length. &gt; Note that subclassing built-in constructors is something that engines have to support natively, you won’t get this feature via transpilers.
Then why not add classtrophobic (or some of its ideas) as a runtime for babel's class transformation?
Wow. Genuinely, thanks for that! As for class expressions.... Just so disappointing. I guess I can see now how it simplifies `export default MyClass;` But I can already tell that in three years, this will be the standard and anything I am writing now will be 100% smell. Don't forget the semicolons. And as you point out, watch out for class coercion. ("Class coercion." Can't we have just one nice thing?) 
Not sure what you're asking
I'm ok with npm. Sure there is garbage but that's what happens when you're the first popular package manager for the front end and people are experimenting. As far as finding stuff, I've never had trouble since generally I find it things via github and only then do I go to npm.im/packagename Scope packages have helped with some stuff and yarn is speeding up install times and gives you a proper lock file. Things are slowly improving. Still an impressive number, even if you have quality concerns.
Try this : https://github.com/HaNdTriX/generator-chrome-extension-kickstart
&gt; Why do you even want to use some pattern like MVC or any other at frontend and make frontend more complicated then it could be?? I dont... that's why react / vueJS are so appealing as they only address the V in a typical MVC model however react is build to with the intention of catering for server side rendering at some point. The monstrosities that are angular / meteor are the full MV* type frameworks and i don't / would never use them. Also underscore and/or lodash are great helper libraries. My advice would be to go and start from scratch learning OOP for javascript, keeping in mind that even though it is called OOP it's vastly different from other languages with prototypal inheritence. As you've discovered a class in JS is not a class in Java so i would suggest ditching ES6 and learning ES5 syntax. Also some design patterns : https://addyosmani.com/resources/essentialjsdesignpatterns/book/
It's not entirely impossible to create a commons/shared resource that can be injected in to just about any framework, the question is more about how reasonable it is as it creates a dependency chain that can end up affecting multiple applications when it doesn't need to. For example, say you produce an application that is branded for your customer - often the only change is the styling, so you can pull out the core styling in to its own module and have the application either override the template or store major variations of the core styling in the module. In either case if you make a change in the core module you risk affecting other themes/branding. There are solutions, but unless you're aware of all the pitfalls (including how the company may change themes/branding), you're mostly wasting your time. In short, it's entirely dependant on the business model of the company and how often the product you make changes. Yeoman templates can help you to spin up a project folder, but it's still not a solution. It sounds like you need them to clarify their intents.
Ok. A couple people have mentioned yeoman already and I've used it so I see how it would fit. I'll go with that.
Hey guys... I think i'm still a bit lost in this to some degree. I've added in the loader below to my webpack config but my background images are still 2.7mb and are not compressing. Any ideas on how to make that happen? It would be great is someone could post an optimal image config for maximum optimization so we can see how to integrate it into our projects { test: /.*\.(gif|png|jpe?g|svg)$/i, loaders: [ 'file-loader', { loader: 'image-webpack', query: { optimizationLevel: 7, pngquant: { quality: '65-90', speed: 4 }, imozjpeg: { quality: 65 }, svgo:{ plugins: [ { removeViewBox: false }, { removeEmptyAttrs: false } ] } } } ] } 
&gt; I am still not able to write any functional code on my own. I really do not like concept of functional programming where everything can be parameter for anything and where source codes for me are very complicated. When I compare java class and some js file, java class seems like self-explicable instead of javascript file which is usually bunch of brackets,arrows and other symbols and almost everything is function.. You can not say at first look what this file is used for. I know it doesn't help, but that's strictly a question of experience. Spend six months working on a project with modern idiomatic ES6/React/Redux code, and it'll look super familiar and obvious. Then when you open up one of your old Java files, you'll find it just as confusing as the Redux code seems now. :) You may also want to look into more "conventional" frameworks like Ember or possibly Angular; you'll probably find it less of a jump than Redux. &gt; almost everything I try to achieve in framework can be simply done in jquerry with few lines of code , like calling rest service with Ajax and then outputting result... Good, then do that. Frameworks are there to help you solve *hard* problems. If you can solve it in a few like of jquery, it's not a hard problem. &gt; Why do you even want to use some pattern like MVC or any other at frontend and make frontend more complicated then it could be?? Easy, you don't. Only use frameworks and patterns where they make your life easier. They're no more a magic bullet than the Java frameworks you're familiar with.
&gt; In the preceding four weeks, users installed 18 billion packages. Turns out, it was one programmer and that was just the dependency tree.
and chrome should stop incrementing version numbers like they're counting hillary clintonemails. face it, peoplelike numbers. 
I got a billion problems and they all bitches
&gt; which is faaaar away from OOP and also exactness.. Try coding in an imperative functional approach. You can achieve superior precision and at the same time reduce the size of your code (often substantially).
I agree. That's why it'll need a combination of metrics to determine. 
Can you define what you mean by "optimize images"? 
was dealt with so it can't happen again
This is not really js specific. You can't really expect to be able to write applications by yourself after taking a single course -- the author implies he has prior programming experience -- or a course and other limited experience. Writing applications is difficult especially when you're just starting out.
I would recommend looking into Angular -- versions 2+. They have a productive [CLI](https://github.com/angular/angular-cli), so you don't have to analyze the various build systems. They typescript syntax can look very similar to Java/C#, and the components themselves are, or can be, OOP paradigm. The framework gets alot of flack on this forum, but if you don't like react, then I recommend checking it out.
Cool stuff, thanks for sharing! It would be interesting to read about training OpenCV further.
JavaScript really suffers in that there are so many ways of doing even the most basic things, and there's not really any solid guidelines on which way to do it: then you have to account for the fact that you have the whole language at your disposal but half a dozen different browsers over a dozens of versions all support different subsets of it. So when a useful, unifying feature is added to ECMAscript, like the most recent syntax for class definitions, it's months or years before you can use it and at the end of the day some fucker will still be using IE and spoil it. Yes, I know about Babel, but still. And that's not even going into the whole framework malarkey. People complain about the schism in python thanks to v2 and v3, but js is much worse for a learner in this regard.
To be fair there is a ton of shut in maven too. Is there a registry that doesn't have a bunch of worthless crap hanging out in it?
Would you rather want closed-garden style package registry? 2 weeks to submit NPM package, 1 week to update it and of course rejections with random rules. No thanks, I'd rather have it as it is. It **would** be nice to have some sort of star ratings in NPM though.
After more digging, it looks like [webpack-spritesmith](https://github.com/mixtur/webpack-spritesmith) is what I want. I was thrown of the trail because it emphasized its use in CSS.
Is not about frameworks, is about paradigms and language, Javascript is very different than Java and C#, I came myself from C# and for me, Javascript makes a lot of more sense for these days, try to read first https://github.com/getify/You-Dont-Know-JS then some framework, you will need them when your apps gets bigger and bigger.
It's 2017
Sounds fun! :)
Yes, decentralization is better than censorship.
Within a dozen frameworks, transpilers and style guides, a lot of beginners are losing their way. Many of other languages does not deal with browser &amp; version compatibility issues of the scale that JS does. 
The author starts with "A lot has been written about JavaScript Fatigue in the last few months", then follows up with two links that were both published a year ago. In fact, I haven't seen that phrase at all in the last few months. Maybe I've just learned to ignore those articles. 
The problem is that he tried to learn from like 99% of the categories of things that webdevs use today, and he tried to do it all at once, for a single project. That's not javascript's fault, that's his fault. You don't try to learn typescript, webpack, linters, and test driven development before starting a project. You pick those things up over a year, while working with random sideprojects, before introducing them into anything you build for production.
Come on now, quantity !== quality. Better to be strict with those comparisons! ^^^^^^this ^^^^^^is ^^^^^^a ^^^^^^joke ^^^^^^btw...
Reduce the number of http requests and compress my huge images like background images etc to reduce the overall load of the page and increase page speed performance. That's my goal
You shouldn't be touching any of that as a beginner. The 'problem' is that there's so much written about JavaScript geared towards people writing complex applications that a beginner will come across that stuff and think that's where they need to start. It would be like if a beginner guitarist only read articles geared towards touring musicians that detail the companies they'll need to hire, the equipment they'll need to buy, etc and decide it's all too complicated and give up on learning the instrument. 
I'm guessing you've seen Phaser.io? It's Pixi with (a lot of) helpers layered on top.
That is the common misconception. For people who program using specific stylistic definitions or design patterns then yes, function programming is absolutely declarative. When you get away from much of that cookie-cutter bullshit functional programming can absolutely be imperative.
Spritesmith is wickedly powerful and I love that it's fairly extensible too (pick your own engine and write your own packing functions if you want). Paired with a templater it managed to speed up and reduce the size of a sprite sheet we had in production until recently.
You mean you don't already know these? I'm sorry, its too late for you. You must hand in your hipster 'developer' card at the door, and immediately dispose of any flannel or bespoke items in your home. Tomorrow a car from Microsoft will pick you up, to take you to your new place of employment--a grey factory where no doubt they work with languages like COBOL and C-SHARP.
The biggest problem is beginners trying to learn frameworks before they've learned the language. "Learning Node" without learning Javascript should sound as ridiculous as "Learning Spring" without learning Java.
NPM has too many packages of this sort: - ES6 looping made easy tutorial - A starter kit for XYZ framework + ABC library - A updated starter kit for the above frameworks - A starter kit for those frameworks except now in ES6 - Here's how we write a for loop, now as an importable library! - Here's something I wrote while sitting on the toilet at work. It's awesome. - Here's a bit of code I found scribbled on the latrine door at work. It's mine now. I'm sure was open source. Rely on it in your business! - Plugin for ABC framework, because ABC framework cannot be bothered to host their own plugins.
But, thanks to things like Typescript, it's getting less scary for pros.
By template i hope he/she means boilerplate/starter kit. Try get them to be specific in the "templates" purpose or uses. If they cant answer that they shouldnt be demanding it. If you know a couple of libraries/tech stacks you tend to use at work, search for it in google/github and itll be very likely one has already created a starter kit with them with some basic readme file. And dont bother with yeomen. Just use npm
But I took an online tutorial over a week and can print "Hello world." Why is JavaScript so bad that I can't easily produce a high quality application???
I have the book and a bit of experience with express. If you make a group to learn express I'd like to tag along.
In the long run they make your code more flawless and let you spend more time on implementing features instead of fixing bugs in pure JS. So it actually speeds the development up.
Yup. I get the sales pitch and I support the decision by my team to work in typescript. I'm asking for myself. How can I improve so that types make sense to me? I guess I'm looking for katas or other ways to practice so that I can up my game with types. 
&gt; Fuck Medium. Can people just stop whining about Javascript already? Sounds like a good title for a Medium article...
Keep removing elements from the array till the function evaluates to false on the elements. Stop when it's true. 
It is absolutely fine and honestly encouraged to use ES6+ syntax. I am a front end engineer and use Aurelia framework and TypeScript. I think it is vital to understand the ES5 inner workings that TypeScript or ES6/ES7 etc transpiles down to, but overall, the new features make development 1000% better in many ways. I have HUGE web applications that would be a complete disaster and impossible to maintain without classes, dependency injection, static typing, etc. As someone who knows OOP through Java, Python, C#, TypeScript makes my life a LOT easier
Start at the bottom. Find the functions in your lowest-level utility modules, and add type decorations their parameters. For example, change export function reverseString(input) {} to export function reverseString(input : string) {} That should get you 90% type checked for that file. To get to 100%, go to your TS compiler settings and turn on the "noImplicitAny" flag. When you return to those functions, you should see errors where the compiler couldn't infer types. Fix those by adding type annotations, for example change let flag; to let flag : boolean; Once your utility functions are all done, then move on to the modules that use them, and repeat. It should get easier as you go, since the compiler can infer more and more types based on types it already knows.
I can't agree with the author here. It sounds like what he wants is for JavaScript to regress and go back to being a "toy language" with very limited features. He is also conflating amount to learn with ease of use, I'd argue JavaScript has gotten easier to use *correctly* and harder to abuse. The more loose a language is the easier it is to write bad code that will fail even on moderates loads, with JavaScript it's not too uncommon to get people rising past junior level while still having bad practises. In most languages you don't have to simply hope and pray that the developers using your application are aware of common convention (`_` meaning private, for example), because you can enforce types, private, static, etc. Just because JavaScript developers will have to learn more features now that doesn't mean the language has gotten harder, quite the opposite. I highly doubt the author would prefer wrapping his head around a myriad of callbacks rather than tracing a pseudo-synchronous data flow using promises or generators.
so does any package registry, its the natural life of packages, whats your point?
There's good information here but I was expecting also some mention of code splitting into modules by URL. You don't need to load the bundle the entire app if your user will only visit one or two pages. Webpack makes this very easy to do and should be encouraged. 
I think the article makes a decent point. The rate of change and evolution of Javascript tooling, ecosystem, etc is quite fast right now. There is a lot of change and a lot of different tools. That results in a lot of diverse ways that people are actually doing things, talking about them, and options to use. And everyone's writing blog posts :D If you are simultaneously learning programming, web development, and javascript ecosystem/tooling/standards at the same time right now... there is a lot to take in and it's big and scary for sure. But having a great, big, evolving ecosystem will mean a lot of ways to do things, and that is fine. Like a big ol' rainforest or something. Just pick one or two related things at a time and learn them. Ideally, like the author mentioned find a thing that gives a prescriptive path for beginners and just go with that until you've gotten to a decent level. That worked well for me a lot more than picking and choosing trying to cobble something together.
Do katas: https://www.codewars.com/
Check out: http://moduscreate.com/code-splitting-for-react-router-with-es6-imports/ https://brotzky.co/blog/code-splitting-react-router-webpack-2/ https://webpack.github.io/docs/code-splitting.html
I dont get the value of system.js. isnt that the one where the modules are loaded dynamically? Seems like that would punish you for modularizing as your application grew larger in size.
One approach would be to have the button disabled by default and then whatever code is responsible for populating the list could also be responsible for enabling the button so long as the appropriate criteria is met (e.g. list has at least one element).
If you don't understand typing you're likely not at the point where TS will be of any use to you yet. If you really want to understand types properly I'd strongly suggest you get away from JavaScript for a while and try something like Java or C. Most JavaScript types are already abstractions over actual data types, for instance the `Number` type is actually a 64-bit double. What's a 64-bit double? That's a floating point number that takes up 8 bytes of memory on your machine. I think if you want to do anything more with JS than superficial UI animations then you need a proper grounding in these kinds of things. I came into JS after having done C, C#, C++ and Java and I thank my lucky stars that was the case because having that underlying knowledge makes a world of difference; you can learn new features much faster because you'll have an idea of what's going on under the hood and performance will be much less of a mystery to you once you learn about things like big O notation, too.
Its an inheritance mechanism. Any time you want to create an object that inherits from another, Object.create is how you can make that happen. Constructors (JavaScript classes) do something very similar except they have they have a function called inherently as part of object creation (the constructor) and you don't have invocation control over what object the new object is inheriting from; with constructors its always &lt;constructor&gt;.prototype. var newA = Object.create(someObject); // no function called; you determine inheritance (i.e. someObject) var newB = new MyConstructor(); // function called; always inheriting from MyConstructor.prototype; Of course nothing's stopping you from creating an init() function and calling that from Object.create. Its just extra boilerplate that you have to set up, but possibly worth it if you need control of that inherited object. Pre-ES6 Object.create was often used to set up inheritance between prototypes when one class extended another. It allowed the subclass's prototype to be an object that directly inherited from the superclass's prototype without having the even older-style inheritances side effects of the constructor call. // ES5 Subclass.prototype = Object.create(Superclass.prototype); // early days Subclass.prototype = new Superclass(); // includes constructor side effects I personally don't use Object.create much, especially given ES6's class syntax which handles inheritance for you (or other frameworks which also do that for you behind the scenes). Though I think on the rare occasions I have used it lately, it was to effectively mock another object without directly using that object, but still pulling from that object the things I didn't want to implement myself. 
Yeah that's the route I was trying, but I want to try to avoid editing the code responsible for populating the list because it is used elsewhere throughout the site for similar tasks but not exactly the same, so I didn't want to add too much to it that was specific to my particular issue. Is there a way that I can detect when an actual HTML element changes? maybe detect a change in size or something? I was looking into MutationObservers, but it looks like it can have an adverse effect on browser performance.
Seems like a fair reason. However, what if the change was something as subtle as firing a custom event that you could listen for only when necessary? While you'd be changing re-usable code, it would be a change that is also adding a feature that can be re-used (or ignored). Might have to be careful if IE support is important, as IE11 is the first to support them it seems and has some quirks (though IE11+ is required for Mutation Observer as well): https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events Mutation Observers would be a nice way to monitor the list without touching that section of code but I can't speak to their performance. This SO answer is recent and seems to have good tips on using them responsibly: https://stackoverflow.com/a/39332340 Perhaps someone more experience than I may have suggesions, but aside from those two routes the only other option I can think of is polling to detect changes (e.g. list length) and a best case scenario for that would require finding a good performance / UX medium of polling times between detecting it quickly and not checking too often.
I've looked at it in the past. I'm not looking for an engine right now, just a graphics framework.
If your `&lt;li&gt;` items are wrapped in a parent `&lt;ul&gt;`, you can use that `&lt;ul&gt;` element to see how many 'children' nodes are contained in it - aka how many things are in your list.
If `element.innerHTML` returns anything or if `element.children.length` &gt; 0 then your element is populated.
For every item in the array it calls the function `func` with that item as an argument. If the function returns `false` (or a falsy value like `0` or `undefined`) the item is removed from the list and the loop repeats. Otherwise (truthy return value) it stops.
I have links to several overviews of the new ES6 language features and some ES6-focused online books in the [ES6 Features](https://github.com/markerikson/react-redux-links/blob/master/es6-features.md) category of my [React/Redux links list](https://github.com/markerikson/react-redux-links). Should be enough there to help you.
If you are looking to make copies check out Object.assign instead.
Can we stop being little cry babies already? Being a good developer is an actual profession (and programming is one of the vital skills). Ofcourse we should make API's simple, languages nice to use. But it's not some kind of consumer product we need to sell to non-technical people. Learning to program well is not easy, so get over it or programming might not be your thing..
[removed]
I personally would not go the route where you listen for actual HTML changes. A pretty fragile solution. It would be better to use some kind of simple event/pubsub system where the code populating the list triggers an event and the code for the button enabling it listens for it. Pubsub: https://www.npmjs.com/package/pubsub-js Code would look something like this: // list code pubsub.publish('listPopulated'); // button code (can be a separate file). pubsub.subscribe('listPopulated', enableButton); function enableButton() { buttonElement.removeAttribute('disabled'); } This is way better because your inter-javascript communication does not rely on HTML. The list is completely decoupled from the button because it just listens to the event. The button and list can actually exist seperately. Also use separate classnames to actually grab the elements (like: js-button), so that they are independent of CSS.
Does your paragraph have a child? 
I don't really get it too, in the end you want to bundle for production anyway. Which you can do with tools like webpack too, which in my opinion are simpler to use.
When using Javascript you're adding inline styles to a specific element. A jQuery selector is NOT the same as a CSS selector. JQuery just provides you with :first-element to give you the first element from the list with convenience (making it more confusing). Also when the list would re-order, the element with the added css would move also (making it not the first one anymore). You should make sure that the first letter is a separate span element and then add the style to THAT element. Even better just style it using a CSS stylesheet and then activating it with a parent class for instance. I would advice you to check out to step away from jQuery first and learn vanilla Javascript better to understand what's going on.
This. You know what gives me JavaScript fatigue? A bunch of "programmers" that put more effort into writing articles about how confusing JavaScript is than actually writing (and learning) JavaScript.
This is what Babel is for (as you alluded to).
Wes Bos' [ES6 for Everyone](https://es6.io/) course is top notch
Check out Wes Bos.
I don't think javascript is the problem. The problem is the DOM. And CSS. And all the browser APIs. And understanding HTTP. And/or understanding native app platforms. And... Javascript is just the tool that interacts with all those things. And that ecosystem is incredibly complex.
So basically he's not complaining about JavaScript the language, but by the fact that he had to learn a framework to use a framework?
Yeah on second thoughts Angular or Express would be a better comparison.
Where can I read about this?
That should be *web development* is getting scarier for Beginners. And kids these days think they have it sooo rough. Boy back in my day, you wanted your code to work in two browsers you wrote it **twice**
Is there anything in particular you're stuck on? If you understand types it should just be a matter of learning the syntax and interfaces. If it's general advice you want I would recommend [this egghead.io course.](https://egghead.io/courses/use-types-effectively-in-typescript)
I think part of the issue is a mismatch in expectations. A few years ago (and not even that many!) JS was this thing you used to make image rollovers, and it wasn't too hard for a beginner to get started making rollovers. Now it's also a thing you can also use to make mobile apps, SPAs, and backend applications. And it's *not* that easy for a beginner to get started with that. But that's less to do with JS and more to do with the fact that these are not easy tasks. If all you want to do is make an image rollover, it's as easy today as it ever has been. And if you want to make a mobile app, JS isn't significantly harder (I'd argue it's actually easier) than other options; if you think Ionic is confusing, try learning Swift. (Not that Swift isn't great! But...not newbie friendly in my view.) The "problem" is when people try to compare "image rollovers 10 years ago" with "making a mobile app now". Yes, the second one is a lot harder. The key there isn't the passage of time though, it's the fact those are radically different tasks.
Did they happen to say how many of these installs were from CI servers or automatic deployment systems? These numbers are hugely inflated by frivolity of installs. I don't know of a good way to exclude those, but I think the download metric is absolutely meaningless for this company. You know how many times I've had to run `npm install` for the same projects on different computers? Also, now that they're the largest maybe one day they'll have the budget to fix their broken stats API (which has been broken for at least a year).
Yes.
&gt; Every month there is something new we are told we should be using, even though it's just another micro-optimization. Told by whom? It's your fault for using new and shiny every month. 
It's more like I want to go from, this is a pain and is just documentation to this is natural and pays off. So, I'm trying to bridge the gap from achedemic to working knowledge. 
ah good, someone with common sense, I though I was going insane 
You don't need an explicit *public* or *private* when you have native lexical scope. You have it already... dynamically. Access is dictated by where in the scope chain a reference is declared. But... you would actually have to accept that this language isn't Java and doesn't have to work that way.
&gt;I'm just not efficient with them in typescript i don't understand, they are pretty much the same. What exactly do you mean by not efficient 
If you want something to feel natural there's no substitute for lots of repetition. The pay off comes from catching errors at compile time and having peace of mind.
Javascript doesn't have a solid standard library. That's one point against learning it easily. Secondly there's bugs caused by the fact you can pull undefined variables from objects. In other dynamic languages, that's an error. Javascript also is forced to be backwards compatible with all its inferior versions. There's never been a wart removal phase where they killed off parts of the language that weren't well thought out.
You are really getting off track. &gt; If this were true then JavaScript would never have prototypes JS even does that poorly. There should be a clone method. &gt; or lexical scope Mh? It didn't have a lexically scoped `this` or block-scoped variables.
How would Babel go with transpiling this one? Is it a modern-browser-only (and, yes, Node/V8) type of thing?
Thanks for the links! This would have been very handy last year when I was optimizing a build that took minutes to finish. 
You don't need a lexical *this*, because *this* is only there for inheritance.
What else could they mean?
Not really. Most people write their function internals in an imperative fashion, but structure their external calls in a functional way. 
Billion with b.... what was billion supposed to start with if not a b?
NPM doesn't even delete packages when their source on github is removed or goes private.
you know it, you own the data, you handle the DOM changes, you know when the list is populated. Just change the disabled attribute on the element when needed
I agree somewhat. But most of the time those things are packaged together (no pun intended). Just a simple tutorial on Angular2 usually expects you know not just JavaScript but: NPM, TypeScript, Modules, task runners. I can definitely understand why people get overwhelmed. 
I never said otherwise. &gt;That's a typical case where you can't really point to any real advantages for using var over let, so let is hands down best. I said there's no advantages for using *`var` over `let`*, not the other way around. It's obvious that `let` has its advantages, but there's no advantages the other way around, which is what I was saying.
Http://es6katas.org works for me
If you want private methods you can already use the factory pattern instead of classes. https://www.youtube.com/watch?v=ImwrezYhw4w
Luddite's Guide to JavaScript
 $('*') .contents() .filter( (i, node) =&gt; node.nodeType === 3 ) .toArray()
I think the other commenter replied to the wrong comment. I would say the difference is blurry, but far from nonexistent. I'd perhaps define web sites as mostly classic layout (header, navigation, hero image perhaps, content, maybe a sidebar, footer) sites. They can be dynamic and have user authentication, and use AJAX and client-side routing. I'd start to call something a web app, though, when it starts to extensively use newer APIs like Bluetooth, camera, microphone, and battery status access. From a JavaScript perspective, I think Service Workers are a good indicator of a web app. They allow a user to go offline and still make use of a web app. Service Workers are also somewhat difficult to develop with (I believe) as they're cached quite thoroughly by the browser. To get around this, they're strictly versioned, which is reminiscent of desktop software. With cache busting on a website, you never need to worry about which version your clients are using, as they'll always be up to date. With Service Workers meaning people aren't necessarily connected to use the app, this isn't always the case. I think one could almost make the point that a website should be able to function, at least to a degree, without JavaScript. A web app, however, should not be expected to manage anything. Overall I'm rambling vague ideas, but I just find myself concerned that simple, static sites with basic HTML and CSS are often placed in the same boat or box as complex, hugely-dynamic apps. It adds to confusion for people, and I think raises some questions about the power to access information (i.e., battery status) about or on a device that web apps and sites possess.
It's sort of a hard time for Javascript books. I wouldn't recommend avoiding books simply because they are es5. Understanding ES5 is essential to understand some of the problems ES6 is solving. For instance, Arrow functions allow 'this' to be inherited from the parent scope. You will see non arrow functions when you are working with ES6 code and you need to understand why it is different. Seeing the `that = this` hack from just about every ES5 book will make understanding ES6.
Thank you for your answer. What book would you recommend for beginner (I would prefer if it was written in 2016 or 2015) ?
I definitely agree with /u/bel9708 . ES5 is the foundation - a lot of what's in ES6 is just nicer ways to write stuff you could already do in ES5. FWIW, my React/Redux links list has a category for [Javascript Learning Resources](https://github.com/markerikson/react-redux-links/blob/master/javascript-resources.md) and a category for [ES6 Features](https://github.com/markerikson/react-redux-links/blob/master/es6-features.md). Plenty of books, tutorials, and info available from those two sections of the list.
&gt; JavaScript really suffers in that there are so many ways of doing even the most basic things This is a feature, not a bug. I know that people worry about the burden of choice, but having language flexibility is a good thing. There is no single right way to code Javascript because Javascript runs *everywhere*, and different applications and different libraries require different coding strategies. Enforcing style or structure at a language level is a crutch. &gt; but half a dozen different browsers over a dozens of versions all support different subsets of it. Agreed, and it's amazing that support is as consistent as it is. The point of the web is that it works in a lot of different environments. It's a deliberate rejection of the principle that everyone should always have the same experience everywhere. If someone comes from a background like Java that's going to be frustrating, but it's also probably the biggest reason why the web is what it is today. For better or worse, to be successful on the web you *must* abandon any idea that you know where and how your code is going to be run. That's what makes Javascript different than the Python schism - Python's solution is to be incompatible unless you meet the prerequisites. Javascript's solution is progressive enhancement. The problem is never going to go away unless you homogenize the platforms where the web can run, which IMO is a mistake.
[yes](https://pastebin.com/api)
I might be blind but I don't see how to do it from this link... it appears to require server-side scripting (like PHP)
The API is accessed with POST requests, and although the examples use server-side scripting, you should be able to use client-side scripting (Ajax or Fetch).
[Fetch ain't happening until you can cancel.](https://github.com/whatwg/fetch/issues/447)
yes, must support es6
Then don't learn them. Really, seriously. I started learning them when I started developing apps that needed them, and it was such a huge relief to use frameworks that can handle x y and z for me. The need for frameworks is so blindingly obvious once you have a problem that required them. If you don't feel that you probably don't need them. Quite possibly frameworks only add unnecessary complexity to your projects. &gt; When given the freedom, the simple Jquery/Handlebars powered by some webservices seems to get out the door faster and cleaner. I agree with this.
Seconded -- this is the best guide I've seen. 
That's your company's fault for thinking you could handle it, or yours if you claimed you knew JS and didn't. 
Ah yes that's right. It won't execute another function at the same time. Thank you. 
Those bundle sizes still seem atrocious to me... Getting basically anything down under 200k should be possible.
Surprised that tree shaking wasn't mentioned. I'd be curious to see metrics comparing Uglify and Closure Compiler, esp. using Webpack 2 with tree shaking.
Oh come on. It's the largest package registry in the world measured by number of hosted packages. A number that is famously inflated on npm thanks to its policy of retaining low-quality, unfinished, abandoned, single-line, and even deprecated packages. It's nowhere near the largest by any reasonable measure - number of users, number of direct installs, instances of running software updated using it.
You should definitely try es6 or typescript. It'll look more familiar from java developer point of view. React is very simple really and currently I don't know faster way for building ui's in any language. You can do everything in plain js/jquery but frameworks are solving problems for bigger apps, not simple ones. React is only V, but you can easily make it MVC with proper app structure. 
Found this: https://github.com/samccone/The-cost-of-transpiling-es2015-in-2016
As usual, untested on Firefox
New venture? 
[Learn Pure React](http://daveceddia.com/learn-pure-react) is really good. It works up from small static components to fully dynamic in nice gradual steps
If what you have now works why change it? Those shiny new tools should be used on personal projects and you should personally evaluate their usefulness before declaring that you "need" to know it. 
&gt; and self-enforced convention This. To the max. &gt; The benefit of any framework is abstraction. So is it's main down side. You hide complexity behind a layer. You use this layer to create (more or less) complex applications. This basically makes the abstraction layer a complexity layer.
Because it is bloat for a single-page application.
It has garbage packages no doubt, but so does any other repository in the world for any other language. Convenient to forget the sheer number of high quality packages on there. I come from C++/#/.Net and Java, finding code was often the hardest thing in the world. I was amazed that npm had support for literally everything i ever needed from the get go. For front-end, back-end, intermediary and low-level, npm has never let me hang. No other repo i have worked with comes even close, including maven and nuget.
It may be that you're not measuring the correct element. What does ReactDOM.findDOMNode return? Try printing the element to the console and checking it in the inspector. When you say 300 and 650, which value is that? Top? Also, there's no need to use ReactDOM. findDOMNode. Instead of using "ref" on a component, you can pass the ref function to the component using a different prop name, then that component should pass that function to "ref" on the exact element you want to measure.
Hah you fucking asshole. Happy Monday :)
Activism? I didn't even mention Chrome, lol. The vast majority of things on Codepen are tests &amp; demos. Nobody cares about browser coverage there, and rightfully so. Pointing out, in a snarky way, that it doesn't work on one browser is just pointless noise. It's roughly equivalent to asking why a startup hasn't translated their site into German yet.
Does the "us FF users" implicitely includes the "us pragmatic responsible web developers" that should test their work against all major browsers?
While I agree that yes, all work you release **professionally** should support the largest percentage of **your target audience**, the same rigor can't be expected of some hobby project done on codepen and posted on reddit. And in regards to, &gt; against all major browsers Unfortunately in practice you have to draw a line. At work our user base is largely split amongst: - iOS Safari - Google Chrome - IE9+ (until recently IE8+). FF is a meager 1-2% of our audience. Due to this, I'm told to not waste time optimizing for FF (even though that is my main browser and the one I use whilst developing - not testing ). Which I agree with. Business constraints mean that if the task will be extended by adding support for a browser that covers a meager 1-2% of our user base, it's not done. Being a "pragmatic, responsible web developer" means that you focus your time on producing work that is compatible for your **user base**, not all major browsers. Doesn't stop me from wishing IE users would die out and everybody used FF. Damn chrome has quite a few bugs on Linux and annoying edge cases that render significantly different. 
Comparing browser support to translation work isn't the best metaphor IMHO. Since Firefox is still strong on the dekstop market, It's more equivalent to asking why a startup hasn't provided yet and Android version of their iOS only app. Also I'm being snarky in order to hint OP into checking her code so it also works on one of the major browsers. Even if it's not the best way to provide feedback, I feel it's more constructive than letting an excellent web developer getting captive of browser monoculture by keeping my mouth shut. 
I also back Vue, though I realize that with any framework there are strong / weak points. It's nice to read the very fair Vue framework comparison write-up that includes input from developers of other popular frameworks.
Link is not loading. Potato hosting? :P
Absolutely. I think the main issue I've dealt with concerning VueJS is the reactivity. I find that at times I have to use this.$set or this.$delete. I understand that these are due to limitations of JS itself in detecting property addition/deletion, but still, it is something I wish I could do without. Nevertheless, aside from that issue it's been great working with it. It takes almost no time to get up and running and scales really well! 
You could assign variables depending on a [ternary result](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator) `var = (condition) ? expr1 : expr2` var available = (device &amp;&amp; device.c8y_Availability &amp;&amp; device.c8y_Availability.status === 'AVAILABLE') ? true : false, connected = (device &amp;&amp; device.c8y_Connection &amp;&amp; device.c8y_Connection.status === 'CONNECTED') ? true : false; if (available || connected) { // Do something }
You could use something like this. I think there's others that will return the actual property if it. You could just write your own function to do. Another alternative to if/else is switch statement https://www.npmjs.com/package/property-exists
oops wrong part of the thread
No need to use ternary, as the result of your declarations are already booleans. Thats like saying true ? true : false;
I want it permanently removed from the array though so I can put it in another array. The expense is ok I believe as it only happens twice every user action.
Just import a library like `rxjs` and go to town... * assuming you're using a js -&gt; mobile framework like react native, native script, ionic etc
Thanks! Is this the preferred way to assign variables if the statement is long? Also if you could remind me why I need to put the || statement in parenthesis?
Logical and (`&amp;&amp;`) has higher precedence than logical or (`||`). See table of [Operator Precedence in JavaScript](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table). If you make the two statements into a truth table, you can see the difference is quite significant R A &amp;&amp; B || C 0 1 0 0 1 1 1 0 1 1 0 1 1 1 1 1 0 0 0 0 0 0 1 0 1 0 0 1 1 0 1 1 R A &amp;&amp; (B || C) 0 1 0 0 1 1 1 0 1 1 0 1 1 1 1 1 0 0 0 0 0 0 1 0 0 0 0 1 0 0 1 1
The Magic eye rendering does't appear smooth. When I look in detail I can see that the ring is comprised of thick slices. I'm not sure if this is a limitation in technique or a bug but it's definitely noticeable. The whole ring is somewhat deformed because of this.
&gt; How would that even be possible with a lock file and npms new policies regarding deletion? Irrelevant and misses the point. Dependencies fail to download all the time. It even happens on websites in the browser. Its the risk of HTTP. You don't notice this so much in the browser due to caching and most assets that fail to download won't break the page. If the page does break you simply refresh, so when it does happen it is almost never critical. On NPM, however, when dependencies fail to download the application will likely fail. The risk of failure increases in probability with: * total application size * number of dependencies * number of users * geographic distribution of users * third party security, privacy, restrictions placed upon those users I am not simply inventing things to whine about. It is a horrid failure in practice. Here are some recent examples: * https://github.com/Glavin001/atom-beautify/issues/1472 * https://github.com/Glavin001/atom-beautify/issues/1443 * https://github.com/Glavin001/atom-beautify/issues/1467#issuecomment-272782546 * https://github.com/Glavin001/atom-beautify/issues/1462 NPM/APM's fragility is a noticeable percentage of our reported failures. It fails all the damn time. I have also gotten reports that the problem is far more horrendous for our Chinese users behind the great firewall. This is stupid weak shit that exists as a convenience for developers who cannot be bothered to manage their dependencies and thus ultimately don't care about their users... and now we are all stuck with this stupidity. 
Good idea!
It is, but I guess it's a good thing since we're starting to use if for everything.
 class Widget{ constructor(){ this._foo = 0; } }; class MyWidget extendds Base{ bar(){ this._foo++; } } MyNamespace._myWidget = new MyWidget(); Now, in developer console I can type: MyNamespace._myWidget.bar(); MyNamespace._myWidget._foo; 
And is this fixed with yarn? 
You're a fucking wizard. Love this! :D
I don't think you're asking the right question. The assignment to innerHtml is a value assignment, not a reference assignment. This means that the value is copied from the global variable into the inner HTML, so clearing the variable doesn't effect the HTML. Instead, you'll have to find the element after the fact and manually clear its innerHtml. 
What you define at the top as "var globalSomething=..." is not actually global. To have global variables, you shouldn't add the 'var' keyword, or attach it to the window, like "window.globalSomething=...". Then in your function you can access that variable that's on your window.
By implementing selectors that solely target `ReactElement` instances, you're losing the portability of your CSS. What's the benefit of this?
Of course not. You can emulate privacy via weakmaps. You should know that.
I don't see how that as easier to debug than this: let a = function () { let b = 1; //b is private to a let c = function () { let d = 2; //d is private to c return b + d; }; return c(); }; In this code example you can see reference privacy by reading the code. There is no magic. I don't have to know what is calling what. I don't have to set a million break points in some super cool debugging tool. I don't have to guess at what inherits from what. I don't have to tap dance around a bunch of circular inheritance insanity. I just read the code and privacy is immediately clear.
If you have the resources to go to one, I would suggest something like coding dojo, or another similar program. 
If you can afford using lodash you may use something like this: https://lodash.com/docs/4.17.4#get `_.get(object, path, [defaultValue])`
You could also follow: - /r/gamedev - /r/gamedevscreens - /r/indiegames - /r/playmygame - /r/WebGames You will find a lot of tips/ideas about the game development. 
You've got a few options: Trust the shape of the object and just test the status. This depends on how well you control the `device` object and your tolerance for errors. Maybe you can assert the shape of an object at a single point, and trust it from there onwards. Something like TypeScript or Flow can help you to gain more confidence in the data you're moving around inside your app. You're also testing for the existence of `device` twice here, which is unnecessary. Or Put it in a function: // Put together very quickly, so probably doesn't cover edge cases (use at your own risk) const pathEq = (obj, path, expected) =&gt; obj &amp;&amp; path.reduce((result, next) =&gt; result[next] || result, obj) === expected; if (pathEq(device, ['c8y_Availability', 'status'], 'AVAILABLE') { ... Or Use something like [Ramda](http://ramdajs.com/docs/#pathEq) const isAvailable = R.pathEq(['c8y_Availability', 'status'], 'AVAILABLE'); if (isAvailable(device)) { ... edit: formatting
Or maybe the article is really just crappy. (e.g. weird cut-off copy-paste job, talks about $rootScope that doesn't exist in ng2, etc).
Your conversation style reminds me of why I loathe working with a certain subset of other programmers. Pedantic-confrontational doesn't look good on non-fiction personalities one must actually interact with. Maybe try to develop some tact when disagreeing with people.
Can't you just `require("ramda/compose")` to include a single function in your app to keep the size small?
If we want to avoid it that bad, you could just do the following and also get a pretty function out of it: const checkDevice = device =&gt; { if (!device) return false; const {c8y_Availability: available, c8y_Connection: connected} = device; return available &amp;&amp; available.status === 'AVAILABLE' || connected &amp;&amp; connected.status === 'CONNECTED'; } if (checkDevice(device)) { // Do something } One level of if-statements and a nice function that could be refactored to implement multiple checks in the future.
You need to calculate the current time every second (setInterval) and then change the DOM-Content to this current time.
I use a hand of Ramda's methods through my application so it is about the size of the complete set. My custom Ramda build minified is 25 kB, which works in the most cases, but not in mine. I load the whole application is in the initial load so I try to squeeze the size anyway possible.
I know you said Pastebin, and maybe you're using it to paste text that isn't code, but if that isn't the case then GitHub has a really great API for creating new Gists. You can do all of this client-side without the use of a server. They also support anonymous creation so you wouldn't need to worry about using OAuth. https://developer.github.com/v3/gists/#create-a-gist
I hope that you are not making votes through that system. Tom Scott made a great video about the dangers https://youtu.be/w3_0x6oaDmI. If you only need to find the person do I think that it is no problem to create a prototype in JavaScript and react. Maybe something that you have to look at is how you are going to manage all the stored candidates. Are you going to store it on a external server, where you can pull the data from for local usage. If so keep in mind that you have to develop a way where you can be sure that the data that you are receiving is really your data.
Hey thanks! (I'm the author). Happy to answer any questions. My goal with that book was to help people learn React without getting overwhelmed by all the "other stuff" - Webpack, Redux, routing, and so on - so it focuses purely on React, hence the title :)
Mind to explain the code to a beginner 😅
I responded to the wrong message, sorry. 
If the abstraction is airtight, or mostly airtight, you can get away with not fully understanding the lower level, thus preventing then need to know both, and therefore reducing the effective complexity to less than the first level alone. That's why most programmers don't write their apps in assembly.
Ah great! Do you think this is a good option for a large array of objects?
Pretty basic stuff actually: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
Yeah, apperantly it is. Ty
Check out /r/learnprogramming or /r/learnjavascript, and good luck with the career, I started out in much the same way, though it was BASIC and an Apple ][, and it worked out pretty well for me.
Personally I feel like this could be one of those times where trying to follow "convention" religiously just isn't going to do what you want to do. I know convention says the nesting is bad but that's a general rule because in general it *could* lead to some funky stuff. But if you REALLY know what you're doing. Sometimes you have to do it. The problem with other suggestions so far here is you're basically forcing all statements to execute always, regardless of how the app flows just to satisfy an overtly general style guide... Doesn't make a lot of sense to me.
Are we talking digital clock (ie: just the numbers), or an actual animating clock with moving seconds/minutes/hours hands? For the latter, I'd recommend taking a look at https://javascript30.com. One of the first lessons is a clock.
No problem. Let me know if you have any questions about how to do it!
Go for it.
There's no need to use `setTimeout` to enqueue the individual frequency changes throughout the song; `OscillatorNode`'s `frequency` property is an `AudioParam`, so you can call [`setValueAtTime`](https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setValueAtTime) in conjunction with [`AudioContext.currentTime`](https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/currentTime). That said, it's impossible to use the above method to infinitely loop a song as one will blow the call stack ;) [Example code](https://github.com/jamesseanwright/nanotunes/blob/master/nanotunes.js#L94) Nice demo by the way!
Are you suggesting that you will be storing the data *after* "sanitizing" it? The secure way to sanitize data is to do so when you're using it. Before then, you can't be 100% sure that you'll want to output it in the same way. You can also end up accidentally storing non-santized data due to newly-found security holes or badly written sanitization code. As such, it doesn't really matter what backend you're using, it only matters what you're using to output or use the data.
&gt; We have failed as a community to provide an obvious path for someone new to get started without being overwhelmed. I wonder if this is actually true, or if we're getting a skewed perception by hearing about the minority of people who had a bad experience. Because of course the people who used their common sense, and took things slow, worked on the fundamentals, allowed themselves to ignore certain things - they didn't need to write Medium posts about the state of javascript fatigue, so we don't hear about their side of the argument. I started off by being annoyed that I had to make separate html pages for different sections of my first little random website, so I put them all on the same page and hid them with CSS. Then I looked into how to activate them with JavaScript. Probably heard about jQuery from there. Then it felt weird to load all of the pages at once, looked into AJAX. After a some time I heard about React, but figured I should probably wait a few more months before diving into that, because I felt like I had plenty more to learn in more basic areas. Then, like 6 months later, I finally got into React by downloading a boilerplate, ignoring all of the gulp and babel and stuff that was underneath, and just dived straight into writing some React code. I would type `gulp serve` into the terminal, with no idea how it worked - I didn't even know how to use the terminal at the time (I would use the file explorer to navigate to the project, then right click and press "open in command line"), despite articles saying that it's really essential to learn that stuff. Of course I am comfortable with the terminal by now, but it wasn't important in that moment. It was important to get some divs to respond to this.setState. Over the past few years I've gradually looked more and more deeply into how Babel and Webpack works, as the need has arisen, while also introducing libraries like Redux as they've seemed interesting and they've resonated with problems I've had myself. None of this was contrived, none of this was confusing. And I'm guessing a lot of other people have similar experiences. 
Basically there are two forms in my webpage. One of them writes directly to a file.txt, and the other is a contact form. I want to sanitize both user data. This is the code for the form data that writes to the file.txt $scope.data = { 'company': $sanitize($scope.company), 'glassdoor': $sanitize($scope.glassdoor), 'international': $sanitize($scope.international), 'location': $sanitize($scope.location), 'secondary': $sanitize($scope.secondary), 'third': $sanitize($scope.third), 'url': $sanitize($scope.url), 'logo': $sanitize($scope.logo) };
You definitely start to notice the holes in angular and react when you switch to using observables. That's why https://cycle.js.org/ is so nice.
So digging through [this example](https://github.com/mobxjs/mobx-react-todomvc). It looks like you have to pass the store all the way down to each component from the root component (or wherever you initialize the store)? Is there something similar to ReactRedux where you can simply define when to map state to props / dispatch to update state? (e.g. `ReactRedux.connect(stateToProps, dispatchToProps)(ReactComponent);`) &gt; bullshit state reducer (lol), How are state reducers bullshit? They literally are there to respond to an action and modify the state as needed... That is what is happening in mobx except they seem to use direct calls instead (e.g. `this.props.todoStore.addTodoItem(item);`). &gt; Don't even get me started on sagas I haven't used sagas but I have used thunk (which they look similar?) and I agree on that point. I think doing asynchronous calls in a data store is not the best idea and should be avoided when possible.
I'm sorry but that statement is ridiculous. Redux is hardly a complicated library to use and doesn't require 1/100th of the boilerplate a lot of complex apps take advantage of. (more actions == more metadata in your app) While I think MobX is a cool library, to say that it's far less complex than Redux is a totally overblown--they're both simple. One favors immutability the other doesn't. One has a middleware hooks the other has specific "reactions".
You cite one anecdotal source as evidence that an entire claim is false? Just cause you found one bad codebase using Redux doesn't invalidate the entire library. Also Redux really isn't that complicated. It can be explained in one paragraph (in fact, it is in the docs). It's kind of shitty to be spreading misinformation like that when some inexperienced dev might read it and take it as fact. While I agree that Redux isn't necessary for a lot of smaller apps (the docs point this out early on as well), any app that will feasibly grow in scale and have a large amount of state would do well to use something like Redux. Maybe mobx works as an alternative but complexity really shouldn't be a reason to avoid Redux.
Why?
There are many introduction to programming books available. Choose one you think would be the best -- I have no strong opinions -- and do the work in the book. Do not be overly concerned about language, because most of the concepts involved in programming transcend language. However, I know python is used extensively in universities, so maybe start there. Also, Its good to be interested in something (game programming), but don't brush off concepts or tools because "they don't use that to make games". You're not at that stage yet.
Don't do it. You can use yarn. It generates a [yarn.lock](https://yarnpkg.com/en/docs/yarn-lock) with all the specific versions installed. Just check in that instead. There's also npm shrinkwrap, but I've no experience with that, so can't recommend it. 
It's really really simple. const ready = new Promise(resolve =&gt; document.addEventListener('DOMContentLoaded', resolve)); ready.then(() =&gt; /*whatever your event is */);
Check this out: https://github.com/getify/You-Dont-Know-JS It starts at your level and will build you into a skilled JS developer.
I prefer to print to console when I need to inspect things.
I might be predictable, but at least I can read. There already is privacy in this language. I demonstrated it here: https://www.reddit.com/r/javascript/comments/5o2gc4/javascript_is_getting_scarier_for_beginners/dchunfs/
Thats right if you refer to numbers in benchmarks. But, almost all Inferno benchamark I've seen has advanced tricks, such as `createVNode(34, ...)`, `Inferno.NO_OP`. That optimizations are reserved for specific cases, but for simple and mantainable code manual optimization is not part of the solution. Here is when some few libs beats Inferno, beeing fast without manual tweaking. Anyways Inferno is very fast lib. React compatibility is a highlight.
Another vote for `_.get` / `_.has` from `lodash`.
For everything that begins to get complex, starting from todo lists to heavy applications. You'd probably use it for most of what you do, unless you're building a static webpage with text and images. MobX is of course another alternative, but immutable and explicit state has upsides as well. 
 match = str.match(/&lt;(.*?)&gt;/)
The Redux FAQ has plenty of info on this topic : http://redux.js.org/docs/faq/General.html#general-when-to-use . (I've also got a lot more links I still need to add to the FAQ at https://github.com/reactjs/redux/issues/1785 , including several for this specific question.)
Inferno's `createVNode` is the native method to create VNodes. JSX gets compiled to it too, it's not a trick – it's a monomorphic function call and it's the only way to make VNodes with Inferno (createElement etc all use createVNode). Usage of `NO_OP` doesn't actually make any difference in any of the benchmarks too. I believe there are a few uibench implementations that have it in still. We need to update those when we get a chance. The real optimization trick for Inferno is around `noNormalize` and how that works, please check this issue for more info: https://github.com/infernojs/inferno/issues/565. Can you point to the research/apps/benchmarks where other libraries are faster? I'm sure the Inferno team would like to know so they can better improve Inferno. To date, there's not been anything out there that does anything drastically different to Inferno – in fact, most recent libraries seem to be taking ideas from Inferno rather than the other way around (which is awesome to see).
Yep. I think it's great to publish this stuff as a demonstration of How-To. I also think it's not a thing I would take a dependency on.
Redux is not necessary for any properly written app. If you need to use it you've probably did something wrong. I can agree with him that any app I've seen could be simpler without redux. 
Damn... It's is freaking awesome, haha. I'm looking and still can't believe how great is your build flow.
I might get some flack for the pedantry here, but rollup, along with webpack, serve and entirely different purpose than gulp/grunt. The first two are bundlers while the latter are task runners. Now yes, there is a large area of cross over that blurs these lines with a lot of the plugins written for our bundling libraries. Depending on your project you might decide, "man, why am I going to write all these gulp tasks when it is way simpler to use webpack," or you might say, "webpack is a bit much since I'm really only concerned with transpiling some code, and some minification." I tend to use both for complicated projects because it gives me a large amount of control flow, especially with gulp 4. If you haven't looked at gulp 4, check it out. It really let's you model your flow like a circuit diagram with gulp.series and gulp.parallel and combinations of those two. As a quick example build task you might see me doing something like this, starting a task that creates if it doesn't exists and caches a config options, populates it with infomation from my package.json and then calls an update function to look for changes, this then will create html templates that it injects meta information into from the config object. After this is built it will split into parallel tasks, one will hook into webpack, look at my scripts and use a preloader to use isparta and js lint, then will bundle and optimize my scripts and write source maps, while my other task will look at my styles, convert them from sass to css, auto prefix them, combine media queries, and then use purifycss to eliminate uneeded code, and minify, then another task in parallel with optimize my images, generate sprites and fonts, when each of these are completed they with move on to the next task which might use webpack to inline certain things or to bundle specific vendor scripts, while I use gulp to minify vendors I don't want bundled etc...and then finally my task will clean up my directories. That sounds complicated, and it can be. For me, I enjoy having that amount of control. Now, could I do all of that with webpack alone? Yeah, I could. If I was writing an application that depending heavily on code splitting then I would rely mostly on webpack. It comes down to what works best for you. Task runners still have their place and it is up to you for when to use them. For me, it is simpler to set up gulp and hook into webpack where I want rather than try to use webpack (or rollup) for everything. ** used webpack profusely throughout this because that is what I use. If it is confusing replace every instance of it with rollup. 
You said it all bud. Great for knowledge wouldn't dare put it in anything I care about. 
Yep. But it’s being talked about again, ATM.
Man I always sucked at these things
What is a "properly written app"? There's a lot of different apps for a lot of different needs and most of them change at some point. Is there every a one size fit all solution? A "one true way" to write a properly written app? It seems like we'd all be following it if that was the case. That all being said, having written several React apps varying from small scale to quite large, I've found Redux to serve a great purpose in consolidating state across a great many views. Without Redux, this state can become unwieldy to maintain and propagate through the tree of views. In small scale apps this really isn't an issue because there usually isn't enough state to run into the issues Redux mitigates. In that case it doesn't warrant adding the extra non-trivial complexity and boilerplate of something like Redux. So if we assume most apps are very small with not much state, then yes most of the time Redux is unnecessary. What Redux does could certainly be done by someone on their own, perhaps this is what you meant by a "properly written app", but I think it provides a good structure for organizing the state of large apps. So to my eyes, Redux *does* offer a way to produce a "properly written app"-- just maybe not always. And in those cases, I imagine it might still be nice to have but with the caveat that the app ends up bloated with Redux's (in this case) unnecessary boilerplate.
Hey, thanks for commenting. I didn't have any ambition while putting this together. I just wanted to have fun with typescript and rxjs. SystemJS wasn't really a well thought choice. I just used it, period.
Reducers are not complicated in the least. One action = one state modification. It makes your application predictable, easy to test, scale, and maintain. With redux you can inject the state where ever you need it. You obviously don't have to use it everywhere but if you find yourself passing your state as props to components five layers down or somewhere else entirely then redux is a nice solution. It can be a little annoying to write a reducer then write action types then write action creators for every piece of state you want to manage. I get that. But if you design the app properly you'll find yourself in a really nice workflow where when you need functionality for some new component you just add the piece of state you need, the action type to change that state, and the action creator. I tried getting into mobx and idk man, there's something about it I didn't quite like. I like to have control over all my state rather than have magic take care of it. It's not terrible though and I do probably need more time with it to get used to it.
Haha, nice. You weren't kidding when you said random. There's some pretty low contrast ones, but the idea is cool.
I'll definitely be using webpack for serious projects if not browserify or even new kids on the block like rollup. I'm still experimenting with all this. Thanks for making your point anyway, I appreciate it.
As a fun programming exercise try to not use if statements at all!
Awesome! Definitely want to refactor the run function. I went very high level with this demo, looking forward to exploring more of the API at a deeper level.
Looks good IMO. Two things jump out at me: 1) The Stream constructor takes too many arguments and just returns a plain object. I would remedy this either by using deconstruction of a single parameter with default values, or by inlining object construction as object literals 2) Your template string is hard to read. If you can use backtick template strings, do that and indent your HTML. Otherwise, put a line-break and start a new string wherever you would normally put a line-break in the HTML.
Offline mirrors wouldn't increase http resolution security. Yarn halfway solves this problem by using hashes for integrity checking. I had the same idea: https://github.com/prettydiff/biddle &gt;The biggest flaw of this community is people speaking out of their asses with phenomenal authority for things they have little knowledge about, not NPM. Speaking of that what software packages do you manage? Besides the one I linked to mine reached nearly a million NPM (external from the NPM system) downloads in a single month... before I pulled out of this stupidity. http://www.npm-stats.com/~packages/prettydiff How many packages do you manage that have gone through that? I have mostly finished my attempt at package management? Have you created a package manager? I am probably not the biggest authority on this subject, but I suspect you aren't either. Perhaps you remember that the next time you troll somebody. By the way Yarn is a fork of the NPM ecosystem as they pull in from NPM's registry while also having an independent registry of their own: http://blog.npmjs.org/post/151660845210/hello-yarn
it's a shorthand way of writing if (i !== -1) ... This is because in two's complement systems the bitwise inverse of -1 is all zeros; falsy. Every other number evaluates to true (allowing it to be a fast check with indexOf to see if a string/array contains something) https://stackoverflow.com/questions/1789945/how-to-check-if-one-string-contains-another-substring-in-javascript#comment8972847_1789952 EDIT: changed wording from 'fast' to 'shorthand' as /u/fruitdev pointed out that the bitwise not method is actually slower than a standard `i !== -1`. 
There's a big difference between `document.addEventListener('DOMContentLoaded', () =&gt; {})` and `window.addEventListener('load', () =&gt; {})`. `DOMContentLoaded` fires as soon as the DOM is ready, `load` waits until *everything* has finished loading, including images.
got it to work with this code (and jQuery): var gist = { "description": "check...test", "public": true, "files": { "check.txt": { "content": "that, 0" } } }; $.ajax({ url: 'https://api.github.com/gists', type: 'POST', dataType: 'json', data: JSON.stringify(gist), success: function(e) { console.log(e); }, error: function(e) { console.warn("gist save error", e); } });
Nobody is saying "this is entirely new!", They are saying "this works great and lets us build great things!". Stop building strawmans
It's not a strawman. Everyone ACTS like it's something new because there's an ignorance at play (ignorance not meant in the pejorative). And if that wasn't the case then there wouldn't be a new ra-ra article every 10 minutes. By the way, calling something a fallacy doesn't make it a fallacy. That's a weak argument. 
^Hi! ^Here's ^a ^summary ^of ^the ^term ^"Strawman": ---- ^^A [^^straw ^^man](http://rationalwiki.org/wiki/Straw_man) ^^is ^^logical ^^fallacy ^^that ^^occurs ^^when ^^a ^^debater [^^intentionally ^^misrepresents](http://rationalwiki.org/wiki/Red_herring) ^^their ^^opponent's ^^argument ^^as ^^a ^^weaker ^^version ^^and ^^rebuts ^^that ^^weak ^^&amp; ^^fake ^^version ^^rather ^^than ^^their ^^opponent's ^^genuine ^^argument. ^^Intentional ^^strawmanning ^^usually ^^has ^^the ^^goal ^^of ^^[1] ^^avoiding ^^real ^^debate ^^against ^^their ^^opponent's ^^real ^^argument, ^^because ^^the ^^misrepresenter ^^risks ^^losing ^^in ^^a ^^fair ^^debate, ^^or ^^[2] ^^making ^^the ^^opponent's ^^position ^^appear ^^ridiculous ^^and ^^thus ^^win ^^over ^^bystanders. ^^Unintentional ^^misrepresentations ^^are ^^also ^^possible, ^^but ^^in ^^this ^^case, ^^the ^^misrepresenter ^^would ^^only ^^be ^^guilty ^^of ^^simple ^^ignorance. ^^While ^^their ^^argument ^^would ^^still ^^be ^^fallacious, ^^they ^^can ^^be ^^at ^^least [^^excused ^^of ^^malice.](http://rationalwiki.org/wiki/Hanlon%27s_Razor)
yo dawd.. i heard you like sines in your sines... [sinetoy.com](http://sinetoy.com)
Well at the end of the day it is something new. React isn't ExtJS. But no part of it is new, be it the "all JS" parts, the unidirectional data flow, the functional paradigms, nothing. But it being all put together with a name and documentation and it becomes something new. No need to act like it's identical because many of the concepts are the same. Also, react itself isn't really all that new any more either. And at the same time, react is new to some people, every single day. And if someone finds it and thinks it's new and likes it's ideas, it doesn't impact it's merit at all. Just because it's someones first time learning how to fly a plane doesn't mean flying a plane isn't useful, or fun, or a very useful skill.
So how can we get this thing banned from this subreddit? It's annoying as hell.
Yes! Here are a few articles on using npm scripts as your workflow. https://medium.freecodecamp.com/why-i-left-gulp-and-grunt-for-npm-scripts-3d6853dd22b8#.c7aa3bm4e https://css-tricks.com/why-npm-scripts/ https://www.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/ And finally you might be very interested in Package Script Manager: https://corysimmons.com/writings/2016/node/introducing-package-script-manager
Like acbabis said, definitely have the Stream constructor take an object. Way too many arguments. Also, strictly for readability, break up your long lines. const channels = ["ESL_SC2", "cretetion", "freecodecamp", "habathcx", "RobotCaleb", "noobs2ninjas", "brunofin", "comster404", "gronkh", "sacriel"]; Should be something like: const channels = [ "ESL_SC2", "cretetion", "freecodecamp", "habathcx", "RobotCaleb", "noobs2ninjas", "brunofin", "comster404", "gronkh", "sacriel" ]; It's generally recommended to keep your lines under 80 to 120 characters, although usually closer to 80.
Yes, and I'm saying the fact that all of those "not new" things thrown together in one package with one name and documentation and an ecosystem makes it new. Just like how peanut butter isn't new, and steak isn't new, but if I started selling peanut-butter flavored steaks they would be new.
Sounds right - .emit() only takes 2 parameters, as you've passed, and only passes the 2nd into the handler, which is {a: 'b'}. Your handler takes 2 parameters - only 1 is given value by .emit() internally when your handler is called
Seriously though, I honestly find it a bit depressing how this package has 443 stars. Do any of them realize how trivial the mechanics of an event emitter are? idk
Contrary to what some replies say here, it is perfectly acceptable to commit node_modules to source control in some situations. In an enterprise environment that relies on a stable application for revenue generation, you want to remove as many possible failure points. One being the NPM package manager. Why force yourself to have a WAN connection to do a build? Some possible solutions are to keep it in a separate branch called deployment or production then just merge the project in there whenever you need to do a fresh build. I've also seen some projects that keep the project dependencies in a separate repo. Then you never really need to pull them down more than once. 
Fixed new event type :D Nice catch You say to "no reliance on Array#filter", yet you rely on shorthand object notation? I think that is a silly self imposed limitation :) My filter off? is not smaller than mitt's off? Huh, I could've sworn it was. I'll go count the characters (I will substitute the longer names for 1 variable names to make it fair and no semi-colons) Mine: 31 Mitt's: 48
https://www.npmjs.com/package/left-pad was downloaded 12k times today. It has 114 dependents. the git repo is very popular: https://github.com/stevemao/left-pad
Grunt/gulp are not obsolete. They do not have the same goals as Webpack/Rollup. They have features that overlap, but Webpack cannot generate documentation for you, lint non-bundled files, benchmark code, run tests, etc... And nor should it, that's not it's purpose. Actually, you can use the two types of tools in tandem. If you do not wish to use Grunt/gulp, `npm scripts` is the alternative.
Look at Python's [boto](https://github.com/boto/boto3/tree/develop/boto3), [boto-s3transfer](https://github.com/boto/s3transfer), and the main dependent package, [aws-cli](https://github.com/aws/aws-cli) for features. Those tools are a godsend for working with EC2/S3.
Ah okay. Thanks, nice explanation. I think I'd just write it by hand though, not much of a need for the entire library for this. :) 
"for the 21st century" I don't know how to interprete that differently, maybe I misunderstood ?
As do I. There's a big hate-on for ExtJS around here (which isn't completely unjustified honestly given what they've done with licensing and cost) and a lack of knowledge and appreciation for architecture and what's been available for a long time, so everything is seen as being some sort of incredible new invention even though nine times out of ten it's really just old ideas repackaged. Plus, as a generality, the JS community spends more time patting itself on the back for its ingenuity than it does actually learning and doing things sanely and it very much does not appreciate anyone who points it out. Combine those two things and you get the mess we have today, all wrapped in a thick coating of hubris and conceit. 
It's saying literally the opposite - that jQuery *isn't* mandatory. 
I have my final gzipped size. 128 bytes :) Again, it is missing the emit to all events feature, but someone could just iterate over the properties/handlers variable they passed in. a = { a: [ () =&gt; {}, () =&gt; {}, () =&gt; {}], b: [ you get the point ]} e = emitter(a) e.on('thing', () =&gt; {}) e.on('thing', () =&gt; { 2nd handler }) for(key in a) { a[key].forEach((f) =&gt; f(your data goes here)) }
Add support for [transactions in DynamoDB](https://github.com/awslabs/dynamodb-transactions/blob/master/DESIGN.md) (it's already been done in Java).
Then I misunderstood, mb.
It's 152b (have to transpile to plain old js, try using the existing build system from that repo if you want to compare). Size savings are from skipping type case normalization and wildcard events. Totally open to mild codegolf PRs though, I didn't spend an eternity finding the absolute smallest implementation. Heck, I gratuitously left a named function in there haha
Like /u/coiscir mentions, your example won't work with scripts that are loaded with `&lt;script async&gt;`, or functions that run multiple times both before and after DOM load. That was the reason I wrote this, I needed something to work in both scenarios. It also won't work with callbacks, I still think callbacks are neater if you're just kicking off an init function: whenDomReady(init); Regarding your second comment to /u/coiscir: &gt; Yep. I think it's great to publish this stuff as a demonstration of How-To. I also think it's not a thing I would take a dependency on. If you don't want to depend on this that's fine, but I'd like to offer another perspective. I actually think tiny JavaScript modules like this are one of the great strengths of the npm ecosystem. For example, in another project I needed to run a few callbacks on DOM load, so I wrote a simple wrapper function. Then some of them needed to be async, so I looked into what document readyStates should be classed as already loaded. Hey, Promise support would be a bit neater, lets add that. Then I had something that could be useful in loads of other projects so I extracted it into this module. Now if I'm starting a new project and I wan't to do the same thing, I don't have to remember which readyStates mean the DOM is already loaded or any other details. Past me already did the research, I know this module works and I know I can just use it. It's also [heavily tested](https://github.com/lukechilds/when-dom-ready/blob/master/test/unit.js) with 100% code coverage so I can go back in the future and quickly remind myself exactly how it's supposed to function. Also if I discover a more performant way to do this I can just update my module and as long as the tests pass all my projects will automatically get the speed up without breakage. Sorry for the essay but this is a workflow I'm really passionate about and I've found to be extremely productive. Write code however you want to write code, but I often see people confused about why anyone would publish/use a module that's only a few lines. This is why I think it's a good idea :) Further reading if you're interested: https://github.com/sindresorhus/ama/issues/10#issuecomment-117766328 https://medium.freecodecamp.com/in-defense-of-hyper-modular-javascript-33934c79e113#.yhu37h32l
Serious question. Unless you are using some sort of scoping rules, how are pub/subs not an anti-pattern in the sense of debugging madness.
I know, I'm just having some fun X)
Out of interest, why not?
Fair enough, an alternative viewpoint: https://www.reddit.com/r/javascript/comments/5oc630/whendomready_documentready_for_the_21st_century/dciv8lo/
You might need to check if the document has already loaded, but yeah no need for an additional dependency.
I just checked out shrinkpack and tried it out, and this looks to be the solution to be my problem. Thank you so much! I didn't even know this existed. Extremely useful!
My argument is that there's no point in committing tens of thousands of individual files and hundreds of megabytes of `node_modules` contents with platform-specific contents, when you can commit a few hundred tarball files that are only going to be in the 10-30MB-ish range, and be able to check out that repo on multiple platforms because the packages will be `npm install`ed as appropriate for that platform. Less churn, less waste, more flexibility, and _more_ stability over committing `node_modules` in its entirety. And yes, the point of committing the package tarballs _is_ to eliminate the need to go out to the web to download them every time (as well as guaranteeing that you have the exact same package versions you need).
Yes, I admit I read too quickly. Your solution does seem to be better; I have never done it that way, i'll be sure to try it out. Thanks for posting that. 
So as an alternative, you could possibly use Nexus to store a mirror of your dependencies. Then set your registry to it when you install. 
&gt; Angular 1 is fucking terrible Why?
Nearly everything about it is just hacked together. There's a reason why google almost immediately started rewriting it as angular 2 once it got popular. 
oh wow thank you!
not really. especially if your back end is just a static server.
jQuery _is_ javascript, a library to be precise. And your code [works for me](https://jsfiddle.net/tqyoLn63/).
Aw, I'm sorry. =( I wonder what went wrong.... I'll have a look this weekend.
He's got a point - I should be in the habit of testing between browsers. I missed a visitor that wanted to see the animation because of my laziness! =(
Thank you! It's a big functionality hole that I'll get working on.
Wow - good to know!
Your comment means a lot to me! Thanks! More coding to be done still: https://www.reddit.com/r/javascript/comments/5o9dnh/ive_made_a_realtime_magiceyetm_lord_of_the_rings/dcj3kcf/
This is very good, but does suffer from the synchronous emit function, which would be as simple as wrapping the forEach in a setTimeout - that's probably beyond the ultra simple scope here though. Well done!
http://codepen.io/ConnorBryan/pen/GrNoBo You can't use let/const/var outside of a method in an ES6 class.
Me too! It's hard to test!
where are people finding openings?
God damn it, we just migrated to Mitt, I guess Litt is the future.
Ideally, you shouldn't have to do those intermediate checks at all - it would be nice is JS just handled that for you. I was curious to see if you could use ES6 proxies to handle things in the background this seems to work okay - purely academic, I probably wouldn't actually use this but... This is how it would look in use: // use safe function defined below to make object/subjects permanently "safe" from returning the "not defined" error let device = safe({ c8y_Availability: { status: 'AVAILABLE' }, c8y_Connection: { status: 'CONNECTED' } }) // !!! no intermediate check on props, but still have to check if object exists if (device &amp;&amp; (device.c8y_Availability.status === 'AVAILABLE' || device.c8y_Connection.status === 'CONNECTED') console.log('woo') // logs // the typo would normally break everything if (device &amp;&amp; device.c8y_Avaity.status === 'AVAILABLE') console.log('woo2') // NO ERROR! (also it doesn't log) This is what makes it work: const safe = function(obj = {}) { Object.keys(obj).forEach(key =&gt; { if (typeof obj[key] === 'object') obj[key] = safe(obj[key]) }) let handler = { set: function(target, prop, value) { if (typeof value === 'object') { let p = new Proxy(value, handler) return target[prop] = p } else { return target[prop] = value } }, get: function(target, prop) { return prop in target ? target[prop] : new Proxy(Object.freeze({ valueOf: function() { return undefined } }), handler) } } return new Proxy(obj, handler) } 
Love it.
I noticed the strips of depth too, possibly an artefact of the bit shifting? At any rate keep at it - very cool idea :D
Webpack can lint non bundled code and run tests. It can do many more. Furthermore it can do those tasks more efficiently — for example when it lints code it can share cache with the bundle process — that's much faster than running eslint on its own.
Ignore the haters, I found the tagline to catch my attention and help explain the usage right way, nice job!
I've been an Angular developer for some time now. I would like to think that I'm an expert at some of the intricacies of Angular 1.x. When Angular 2 came out I thought "ok, just a few syntax changes, no big deal." But looking at this code, it looks like Angular 2+ took such a drastic departure that it would take a considerable effort to understand again. Why they decided to use *ng and #template instead of ng-if="" and &lt;ng-template id=""&gt; I still have yet to understand. It seems like they could have just created an ng-else instead of overloading the ng-if with an else syntax. Even creating many ng-ifs on one element, each with its own template ID could have solved the problem.
I'm always surprised by people being surprised by this. I'm also extremely surprised that people want this. Webpack and Babel are not so tricky to set up. I learned enough to get them working to my needs in less than a day and haven't needed to look back since. Every new project is just copy + paste and start coding. You can even find pre-made starters, but I find those can have too much built-in. Regardless, as a result I have hot reloading, transpiling, compression and a handful of optimizations for free. The time I spent setting this up I've probably already regained just in having to alt + tab over to my browser and hit cmd + r so many times. TL;DR: People attack things that suggest they change, then are surprised when they don't really have to change, even when a tiny change would be drastically better for them. People should just embrace change and move to better things.
It's awesome how small this is, but O(n) can be really expensive for listener removal in some applications.
Sure ! let's build a voting system in 3 month with javascript and some random dev ! what could go wrong ? --- wait ? what's all those russian IP in my logs voting for Fillon ? :) Don't worry, I'm no fool and not in a position to do so. I only need to find the person. To answer your question : data would only be available on a private network during installation. After that tablets won't have internet access. So I guess it reduces the risk of data corruption.
I'm doing just that so it's not so weird anymore :)
Interesting, I'll be sure to check this out.
It's not too bad. One style tip: your `var streamer = new Stream(...` calls will be a lot more readable if you break it up so each argument is on its own line. 200+ characters is generally too long for a single line. In a case like that, I'd take a single object as a parameter in that constructor, which lets you do essentially have keyword arguments. Positional arguments are great for when you have two or three, but when there are eight, it starts to get cumbersome. On a lesser note, I'd recommend learning about promises if you haven't already. Since you don't have a whole lot of requests, the callback pyramid isn't super deep here, but promises would probably still help with readability. And lastly, error handling. It's easy to just drop all your errors on the floor, but it will make it a lot easier to debug if you catch things and log the specifics, _especially_ when the errors come from an async callback.
&gt; At first, it can be a little confusion, but you can read it like normal javascript In React, you wouldn't have to imagine it was normal JS, it would literally be normal JS to accomplish this. That "super ngIf" seems like a terrible example to start with since the syntax just looks awful. Also the article starts off with a pretty negative tone and the many spelling mistakes stopped me from finishing it. 
Thanks for the demo! It seems to work, but I can't get the div to load the clock when I load the page. It works with onClick, but not with onload? Anyways, thank you for your help :D
Sorry, was thinking of declarations in Typescript. sub in 'this.*' in the constructor and problem solved.
[HN Who is hiring monthly threads](https://news.ycombinator.com/item?id=13301832) [StackOverflow jobs](http://stackoverflow.com/jobs?med=site-ui&amp;ref=jobs-tab) https://www.reddit.com/r/forhire etc 
Agree
What is API juggling and why isn't it a good thing? 
Hey everyone, I'm one of the founders of Graphcool. Feel free to AMA or [join or Slack](https://slack.graph.cool).
Isn't it slower though, since it's now performing *two* operations - bitshift and the actual comparison?
Why are you so mean?
I don't think so. In pre-module era Javascript task runners were needed because building was complex. The build is made *completely* by Webpack now and starting the doc engine or a testing framework is done with a single command, for which npm and node are perfectly fine. And as bsdemon mentioned, Webpack lints and tests as well and it has obvious benefits to do it this way. Webpack also has watchers to detect invalidations, changes, etc., at which point you could run your scripts.
I noticed you've got some great tutorials on your blog, it would be great to see one that addresses subscriptions + graphcool. Also the landing page isn't loading for me on mobile at the moment.
&gt; make hybrid applications built with HTML, CSS and JavaScript React = Javascript So yes.
&gt; npm installed as appropriate for that platform Is it common to have platform (e.g. Windows/OSX/Linux) specific things going on within Javascript build scripts? Obviously if you're in node, there might be a bunch of cross-platform implementations, but I had hoped the standard library would take care of that leaving any library implementations free to be pure Javascript with runtime toggles. 
&gt; JavaScript isn’t the hard part. Web development is hard. Empathy is hard. Thinking ahead, planning, and asking the right questions is hard. Very nicely said :)
Support is a lot better, but I still don't advise using ES6 or Typescript unless you're already planning on transpiling your code. I don't think the style benefits (while they are there) are enough on their own to justify setting up an extra toolkit. If you are already transpiling though, by all means take advantage of the new syntax.
Possibly, but I have found that when the flow control of code is discernible and predictable I have to set inspection points far more rarely to understand what is happening. Also, most code now is in git so I can mutilate the hell out of it and then check it back out from the repo when done.
&gt; 200+ characters is generally too long for a single line. \&gt;75 is a reason for refactoring.
It'd be great if we could pay a set price, then self-host on our own infrastructure rather than pay 100% to 300% more per infrastructure just to use the service (going by the rate of other cloud-hosted database packages atop open source frameworks).
I think people who use Angular don't want normal JS, they want to write a DSL and extend it. You don't get that with regular Javascript because JS (while an okay language in other respects), isn't very conducive to writing code that looks like it's part of the language. Other languages are better at this---Elixir for one---Lisp being the canonical example. Smalltalk for instance has such a small syntax that *every* function you write looks like it could've come from the standard lib, and you can re-implement and extend language control structures.
Hey Sarah, thanks for taking the time to reply and still being positive about my naive but snarky comment :-) After further testing on few different configurations (Ubuntu, Kubuntu, Win10), using FF main release, dev and nightly, I've found out that it's something about the video encoding combined with some platforms with incomplete codec setup. Using [this video](http://clips.vorwaerts-gmbh.de/VfE_html5.mp4) right into your codepen had it working in most cases. I'm still trying to figure out why it's broken on a fresh Kubuntu though; [this thread](https://support.mozilla.org/en/questions/1108866) hints at re-encoding the video using handbrake. 
And it is a pretty tiny hit :) definitely worth the tradeoff for smaller filesize! 
~~Better~~ Alternative Version. --- /* Returns a promise that resolves only when the document is ready */ const onDomReady = (document = window.document) =&gt; { if ( document.readyState === 'loading' ) { return new Promise(resolve =&gt; { document.addEventListener('DOMContentLoaded', resolve, false); }); } return Promise.resolve(); }; Usage --- onDomReady() .then(() =&gt; { .... do your stuff .... } ) or fetch('your-api') .then(parseYourStuff) .then((response) =&gt; onDomReady().then(() =&gt; response)) .then(injectIntoDom) Why is it 'better'? --- 1. Relies 100% on promises. There's only one way to do it. ™ 2. Because of #1, code is vastly simplified. 3. Because of #1, we can resolve promises immediately via Promise.resolve(). Waiting on setTimeout is slower. [See Testing](http://jsfiddle.net/wPCN4/7/) 4. Because of #1, we don't need a separate onDomReady.resume function 5. It's not another 10-line package contributing to the 18 million available on NPM 6. @KingNothing42 has another version, but if doesn't handle the case of missing an the DomContentLoaded event. Covering that case added 2 lines to this file. If you love callbacks ---- Just write: onDomReadyCallbackVersion = (callback, document) =&gt; onDomReady(document).then(callback) Then ~~submit a pull request to me on Github after signing my copyright assignment papers~~.... wait, just use it. Addendum ----- All code is MIT/BSD licensed. Copy and paste as you please.
Yeah. It's kind of even more galling because it's not really a database---its a database connector that sits in-front of your real database. So you pay per query for this thing that only does authentication and decoding. Just charge us $1200 per copy and be done with it please. Don't sell a 'per seat licence' for something where each seat doesn't cost additional resources, those are the most annoying in the world. Please... please don't go and sell us a per-core model either. Don't become Oracle.
tl;dr - basically everything you can think of, and all with vanilla JS. I understand the point of this article...but it feels a little too exhaustive and broad to be helpful. And there's very little in the way of distinguishing levels of knowledge within each topic by candidate level (i.e. "for junior candidates, what you'll want to focus on in this area is..."). It would be more productive if these articles just picked a few key topic areas and really talked about specific examples and what good and not-so-good candidates did...and to clearly state what you would expect out of certain candidates at certain levels. 
Might be! I found a more clever way though (also possibly slower, but smaller): https://github.com/developit/mitt/commit/3a675c7e5a5f7a9a629b59a9dd6e753c6393b36d#diff-1fdf421c05c1140f6d71444ea2b27638R27
I most often optimize for readability first. Performance issues are seldom caused by using hof's instead of loops.
Check this : http://www.skillspire.net/courses/front-end-web-development/
Same deal here in Alabama, USA.
Actually there is prototype already built and css also defined and react native have different scheme for css . Which I think I will need time to learn 
The issue for me switching would be losing the Firebase ecosystem. They have authentication, static hosting, storage as well as the database itself. Any plans to do all that too? 
I get a 403 when I try to access this site
My initial priorities are usually: 1. It works 2. It works properly... 3. It is readable (future maintainability is a significant concern, we've all been bitten by our own code from the past!) 4. It works fast *enough* 5. It works as fast as possible After prototyping and proof-of-concept work, 4 (fast enough) becomes part of 2 (works properly) so will trump readability, but "as fast as possible" never will. If something can be made faster than "enough" without sacrificing legibility then knock yourself out, though be careful to only spend lots of time on it if your users have some chance of noticing the difference (or you expect the definition of "enough" to change over time). A key point to remember is that the difference between for-something-to-something and for-each is usually a "scale up" matter, so if the loop is massively significant your project will probably hit a point where you need to consider "scaling out" in either case. If you are scaling out anyway, I woudl suggest scaling out a bit further (more cores or whole nodes) if doing so avoids ruining legibility in an effort to scale up (by doing more per CPU core) without costing too much extra for the resources to scale out. Of course this is something, IMO, to consider separately for each project rather than having a hard rule on.
1 . There's no Integer type in JS 6 . Never compare with == nor != In that second example swap it with !== and you're all good. Also testing window.something isn't good example. Storing variables in window is never a good example. 10 . This one I didn't knew about. Gotta remember it :) Cheers. 
Thank you! Yeah still working out better ways to determine a good text color.
heyPerseus, neither GraphQL nor Graphcool is a graph database. Could you elaborate a bit more about your concerns?
Hello, I haven't seen this video, so i don't know anything about it's quality. Just thought that i've post it here, maybe someone would be interested and would like to check it.
Thanks a lot gajus0! Glad you Graphcool. :)
Hey turkish_gold, thanks a lot for your feedback. We're still evaluating the best pricing strategies going forward, so we're happy to hear your thoughts. More specifically, we're also thinking about "self-hosting" scenarios (but it's not on the close horizon). I'd love to hear more about this. Please feel free to [reach out via Slack](https://slack.graph.cool).
There is also the contingent, such as myself, who avoid the concepts of class, new, this, and prototype entirely, if possible, because they usually aren't required and by doing so, avoid some footguns of that style.
Thanks for your feedback! We'll soon publish some in-depth tutorials around GraphQL subscriptions and how to use it with Graphcool. About the mobile page: That's fixed now.
Wow that is clever! Took me a while staring at it to even work out what it was doing haha. By the way - was the motivation for this library to eventually use it (or something similar) in preact?
I think I misunderstood what the product was. I thought you were offering a hosting solution for a graph database. My mistake. Thanks.
What browser are you using? It's probably because I didn't transpile to ES5, although I probably should have.
Anything in particular which caused this misconception?
They open to remote workers in Canada? 
nope, remote work is frowned upon. banking stuff.. 
I saw QL and graph. Figured it was a query language for a graph DB.
Yep, I glanced at source to see what all was handled because I was genuinely curious what value could be added. I wrote the simple case. Like many things programming-related, I think there are many concerns. I think we all have our own set, with many varying degrees within the set. I probably sway pretty far to the "I'd rather not depend on someone else" end. That can be a fault some days, but it has saved me from other disasters. If you're comfortable depending on many micro-modules, that's completely ok with me. I get that perspective. It's a hard call to make some days because it comes down to risk, right? Would I rather risk the product on a dependency or my own code (assuming I can implement both ways in a similar amount of time)? There are modules that I'm very good at writing and others that people do far better than me. If I can throw a one-liner in that will satisfy my use case forevermore, then I'm absolutely going to do that rather than add something to package.json. There are downsides to having a large package.json and I imagine we've all done adequate reading (and had experience with) those (including "author is not great at sem-ver"). Clearly, there are also problems with "I reinvent everything and throw it in a giant pile" :). I'd definitely not advocate for that as a design tenant. The strategy I use also definitely comes down to what kind of project it is, where a small project that doesn't require long-term maintenance is much more likely to use small dependencies for everything.
It's quite common to have most of your app bundled into a single file and loaded with `&lt;script src="/bundle.js" async&gt;`. You have no idea if the DOM will be ready when `bundle.js` is executed.
lol, of course it is. Should have trusted my Swiss stereotypes :P
`readyState` has only 3 possible values, just check if it's the other one. The `else` isn't needed if you return in the `if`. The `false` argument isn't even needed for IE, which was the last browser to support `addEventListener`. function ready () { if (document.readyState === 'loading' ) { return new Promise(resolve =&gt; doc.addEventListener('DOMContentLoaded', resolve) ); } return Promise.resolve(); }
Oh boy, I'm literally working on an article about exactly that. Short version: it's code that transforms unusable arguments into usable arguments; the opposite of code that requires usable arguments. It's a bad thing because it's extra code, extra complexity, extra bugs, slower. You can say it's not a big deal here, but it's still half of the code.
I've fixed it :D I just put the onload in a &lt;script&gt; tag inside my HTML file, and it works perfectly now :) Thank you for your help man! I'm sure my site will have a good mark because of you!
&gt; Personally I think forEach, map, reduce, find, filter, etc. Are much more readable and compact than their imperative counterparts. forEach doesn't change anything. It's just a slightly obfuscated imperative loop. Also, it isn't more compact either: for (let thing of things) { ... } vs things.forEach(thing =&gt; { ... });
&gt; Article itself is ok, but what actually sucks is title of the article for being click-bait bullshit. It is? But setTimeout does suck and it goes over why and all the alternatives? Sorry wasn't trying to be click-baiting I thought it explained what the content of the article contained pretty well. It's hard to summarize the article in a single title ¯\\\_(ツ)_/¯ &gt; Article content doesn't say anything about setTimeout sucking or having any issues, only thing it says about setTimeout is I'm not sure I follow. It says: &gt;&gt; That code works but is it the fastest way to make a function asynchronous? Turns out it's not. In the HTML 5 specification if the nesting level gets too deep the delay for setTimeout() increases to at least 4ms [1]. Browsers will even raise the timeout if it's happening in a background tab or if it has more work queued ahead of your setTimeout call [2]. And &gt;&gt; There are also security issues with setTimeout() and setInterval() in that they can work like eval() 😮 I thought those two passages explained why it sucks pretty succinctly. &gt; but is not a SECURITY ISSUE since it can be exploited only if the app is already hacked. Just like eval is a security issue and the majority of developers I know had no idea setTimeout or setInternval can execute code like eval.
I agree `forEach` is basically the same except you have a closure on each loop. Depending on what you need to do, that can be very convenient.
lawl @ "Final". you must be new here :)
More of a big picture question, I guess: Is this a start-up or a business? EG, do you have VC, are you looking for an exit, etc, or are you trying to start a sustainable business without outside investment?
Native foreach is super slow in older versions of IE for some reason. Not in modern browsers though.
Ok that's all fair. I agree with most of that. "Hype driven development" is a real negative force in the industry.
Do people really think that and stop using classes? Fairly sure most people don't use classes because of browser support, hence why transpilers are so popular. Most Devs I know prefer classes over prototypes. Prototypes may have more power but it is much more verbose and a lot more complex for people used to other languages. Personally I can use either but at my work we settled on Typescript for the type safety and got classes for free. I still dabble in the prototypes in legacy and when debugging the output (curse you intern for breaking our sourcemaps). So I can understand why people would avoid classes for compatibility but don't really get why day to day any of the other stuff is relevant in the slightest. Most of it smells of an unfounded hatred of class based inheritance, classes work fine in 90% of use cases, sure sometimes you want something more functional but generally classes are fine if not used incorrectly.
Thank you Lord.
This is a fairly unnecessary module, it's just a complicated wrapper for an event listener. This has value as a learning tool for newer developers for sure though.
Mmmmmm the downvotes taste like $$$. 
Possibly because classes in JS are a syntactic sugar over prototypes and they won't behave like you would except in any other class-oriented language. JS is an object oriented language (everything is an object) but it's not class oriented at all. ES6 classes also forces you to use stuff like super() and manual this binding. You can find some info here: https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/apA.md
How do you avoid using `this`?
You can borrow some patterns from functional programming which composes functions together to creates tiny bits of re-usable code instead of holding shared code into objects. Another hint is to use factory functions, which are functions that create a new object each time you invoke them. And these can be composed together to create other objects.
&gt; [classes in JS] won't behave like you would except in any other class-oriented language. Except classes in JS behave like I would expect from Python or Ruby or Smalltalk. ;-) &gt; ES6 classes also forces you to use stuff like super() Forces? I think it's a nice convenience. It saves us from manually re-typing the name of an inherited parent over and over.
&gt; We will leave the final release on npm published under the beta tag for the first week. So it's a release candidate.
So what are the reasons to upgrade from 1.x?
I'm disappointed when https://github.com/webpack/webpack/issues/2867 is still sitting unresolved and is even listed on https://github.com/webpack/webpack/projects/1 I'm hopeful that it will get resolved, but it has already been almost 6 months with minimal conversation around it.
&gt; Except classes in JS behave like I would expect from Python or Ruby or Smalltalk. ;-) I don't have much knowledges in Ruby or Python so I can't really speak for them. Although, in JS, even though you *extend* a parent class, there isn't any copy-behaviour (methods, properties), both objects are linked through the prototype chain. The "child" object does not *own* the parent's methods/props.
Tree shaking is the only reason to upgrade lol
&gt; Although, in JS, even though you extend a parent class, there isn't any copy-behaviour (methods, properties), both objects are linked through the prototype chain. The "child" object does not own the parent's methods/props. Yup, it's the same way in Python, Ruby, and Smalltalk. Ruby calls it the "ancestor chain", for example, rather than prototype chain.
&gt; horizonjs/deepstreem Great, something else I have to google. I was beginning to think I had caught up.
Cool!
https://gist.github.com/sokra/27b24881210b56bbaff7
It is also quite common to put that bundle at the bottom of your markup where you absolutely know if the DOM is ready (at least the head, body, and nested children). This has been common web professional advice for over a decade as it works well for performance and for logistics (like DOM ready).
I've been using horizonJs lately, its a reactive backendless server. All theses words means it use RxJs interface to let you store, retrieve and watch documents. Its magic comes from the dev mode where it auto-creates indexes and collection while you just ask for them. Then solidify your scheme with permission and you have a fully secure, realtime if using watch noSql backend using rxJs one very standard interface you can find being using everywhere. It allows for great functionnal paradigm. Its just awesome overall. Too bad about the rethinkDb company thing. 
**Separation of Concerns** should trump everything. Keep your code well organized. **Governance** Make some decisions early about code style, validation, acceptable tools, dependencies, so forth. Enforce this with the iron hand of dictatorship death and kindly train your developers to ensure willing compliance. I recommend standardizing on a beautifier with standard option settings. Your developers can format code however they want when they are working on it, but when the code is committed or checked-in it is beautified to the standard style so as to keep things uniform. **Functional over OOP** I recommend steering clear of OOP code and inheritance. It is easier to work on for large groups as the code is easily composable from disparate and unrelated pieces, but reading and maintaining the code will feel like a mistake. **1000 Tiny Islands** Write your code with some kind of defining structure or architecture in mind. I call the tiny bits that area written here or there called when convenient the 1000 tiny islands. The island paradise makes code really easy to jump into and write a testable piece in isolation and then jump back out, but then you have all these damn pieces to maintain each probably with no concept of separation of concerns or code reuse. I use nested functions to form the foundation of my code structure. **Imperative vs Declarative** I personally prefer imperative code because to me knowing the flow control is more important than what the actual code is doing. I am definitely in the minority on this one. Which ever way stick to your guns and document your decisions. Your decisions for doing something are more important than how its done in the code and this is the stuff that cannot be reverse engineered and is rarely known years later. **Crying** When you make hard decisions people will cry. Sometimes they might even try to fight you on it. Do all that you can to explain the situation and persuade them to your predicament or decision. If they remain combative then they are probably not meant to work at your organization. Never tolerate crying or whining. **Identify User Concerns** Code to the wishes of your users opposed to the wishes of your developers. This includes things like clearer content, increased responsiveness, simplified interfaces, less code, accessibility, privacy, security, stability, scalability, and so forth. These things are a pain in the ass for the developers, but are good for your users. Dropping frameworks is a good start in this direction. Once you put your weight into this it doesn't hurt to remind your users (with a bit of marketing) that you are working harder to be their champion. **Automation** Switching to Vanilla JS is great for your users, but you will still need some internal automation. This can be vanilla JS too, but it doesn't have to be. You will want to test code frequently in an inescapable automated way to minimize regression and keep some know bugs out of production. --- **Code Specific Pitfalls** * The DOM is pretty well standard now across all the browsers, so don't worry about that. The vanilla DOM methods are about 2800x faster than querySelector or querySelectorAll. You can write simple abstractions to ease this burden without sacrifice to performance. * When writing array sort functions you must return 1, 0, or -1 from the function to determine the sort direction when comparing two inputs. Never return 0 as this results in unpredictable behavior cross browser. * When using large sets of data nothing is faster than pushing and popping from an array. Something more convenient for the coder is array notation of object literals, but each value must be unique or is overwritten when assigned. * Avoid global and writing to the browser's window object.
In JavaScript especially, I will avoid libraries that try to bring FP to the language. There's a huge different between being a FP language and having a library with a bunch of mocked FP functions. While I'm not after performance gains from pushing and popping memory compared to allocating stack space and moving the stack pointer, not using JavaScript's constructs or, more specifically, using a library of purpose-built functions to gain the "feel" of FP, can cause your application to lose out on branch prediction advantages, cpu cache gains, and JIT optimizations. These do cause noticeable delays in even "warm" paths, likely because of how much work browsers are doing, and how much interaction users have with a page. And likely it's just my experience with languages, but traditional constructs like for, while, etc are instantly recognizable to me, and it's hard to fathom how anyone can argue that they are unreadable. Lastly, just to be clear, I'm not eschewing the use of the FP-esque methods JavaScript provides. The JIT, et al, can handle a lot of them just fine, and when not abused, they are also perfectly readable.
Very interesting product and I think its filling a real niche. Could you answer a few questions - - how do you implement realtime subscriptions? Do you have a layer on top of GraphQL, do you use Lambda for this or is it all in the GQL server? - how does your offering compare with Apollo (which is more of a framework so not a direct competitor and which you use in examples) and Scaphold.io ? - It'd be nice if the docs and Tutorials mentioned realtime, subscriptions etc as this is a major feature IMO. esp if you are going to compare with Firebase for which its a USP - is there any client side caching/persistance or is this totally up to the client? 
&gt; people who will install your library but intend to install Ramda This seems as corner case to me
It's almost like you're laying the groundwork for a framework.
If you haven't searched for new JS libraries in the past ten minutes, you're not caught up.
yeah, self hosted firebase would be like it. I guess its backendless in the sense you don't code the backend, its auto creates collections and indexes, request are build client side and permissions are managed at the database document level. 
Oh I see now thanks again, I resorted to add the CSS given that, while I did manage to add a class to an element, the CSS of that class wasn't being applied.
Maybe you're looking for [TodoMVC](http://todomvc.com/)? Doesn't compare build tools, nor is there much description/discussion beyond the example apps, but worth mentioning if you've never seen it.
too bad you can't also edit gists "anonymously"...
You piqued my curiosity so I checked out Stack Share. Their little message they give when you click "Sign Up" is some real /r/gatekeeping material: &gt; StackShare is a **developer-only** community of engineers, CTOs, VPEs, and developers from some of the world's top startups and companies. Um... I think I'll do my research elsewhere.
a purpose-built framework is often more optimal and more concise than a general one you need to fight. nothing wrong with building your own without overbuilding it. not every site is best run on Wordpress with 100 plugins; not every site should to be structured with JSX and immutability. There are trade-offs in every case.
Frameworks don't do most of what I listed. They want to, but no, frameworks aren't management or decision makers no matter much people wish they could hide from such things.
Your "The (R)Evolution of Web Development" slide deck is awesome as is the collection of links in "Basic Concepts and Overviews"! Thanks very much for sharing these.
It works, just not in all cases. Read the issue, it's actually pretty reasonable IMO. 
Thanks! Yeah, there's some good material out there to help people understand the current JS landscape, I'm just trying to pull together some of it in one place.
That's a sub!? AWESOME! Off I go! Thanks!
I see! Hm..... I think that bunny demo is H.264. I'll have a look on the weekend to see what I can do about encoding.
Those are both fine for a SPA without server side rendering 
I thought the babel standalone was gone? 
Definitely learn Vim too, beacuse you'll need a way for other programmers to see how much more advanced you are than them. /s
This is wildly excellent advice. Your personal projects don't need to be the next Snapchat (or any other next big thing) either. Pick something you're excited about with the right amount of complexity, and really own it and polish it.
Any way we can help? Please don't hesitate to reach out on twitter to me @thelarkinn. Also if we need to clarify anything on our docs (webpack.js.org/guides/migrating) we will totally be willing to do so. 
Since this is a pretty big change from stable 1 we wanted to take an elegant migration path. So no, its def final :-D 1. Release and announce, get the awareness out and flowing. Have people who consciously want to upgrade, to do so. This allows us and the active community to get ahead of the curve so that when unsuspecting v1 users end up with a v2 from their latest install, they can already have a better support ecosystem around them. 2. Also have the opportunity to fine tune, or have a nice list of FAQ's that we can be ready to answer. 
Sarcastic or not, we appreciate the kind words. And we truly do believe that we are in a JavaScript Renaissance. The ever changing ecosystem is allowing to most advanced and crazy awesome new performance and UX and Developer Experience features in what feels like realtime. It's really a beautiful thing.
Nah don't sweat it. If you read the full post (or even the top 1/3 we post a link to a EZPZ migration guide &lt;3) webpack.js.org/guides/migrating
Ooo lots of reasons. Our migration guide showcases a lot of awesome changes and api improvements. http://webpack.js.org/guides/migrating
Get back to your jquery and ie6
[removed]
i mentioned wordpress because i've seen what a cms originally designed for blogs has been repourposed for, because it could. &gt; Honestly, I'm not even sure calling a framework an anti-pattern is a coherent statement. i agree, it's the equivalent of saying they want no structure or organization. however i gave the op the benefit of the doubt that they mean they dont want a foreign framework's conventions imposed on them, not that they never intend to build their own..which is of course inevitable in any app that grows to &gt; 1k LOC.
&gt; i mentioned wordpress because i've seen what a cms originally designed for blogs has been repourposed for, because it could. Touché :)
I'll try to clear as much up here as possible, but you definitely have a few misconceptions right out of the gate. Firstly, `const` does not freeze a variable. It makes it a little more obvious what is going on (ie: this reference will not be reassigned) and encourages good coding practices (eg: not abusing hoisting, not defining without assignment, etc) Secondly, an arrow function is not being assigned here to your const. That is the callback of the event listener function. Finally, nothing would 'change' per se, but you wouldn't be doing yourself any favors. Const is nice because it tells you something about your code, makes it easier to read/parse (for humans), and at some point in the future, will likely also be more performant. tldr; use `const` always because if you're reassigning things frequently and for no reason, you're more likely to introduce bugs and other weird unpredictable behavior unnecessarily.
Given that it's still labelled beta - if you're wondering, then it's not. Just wait until `npm outdated` says there's a new version available - and even then, it can't harm to wait a little bit. The ecosystem still has to get up to speed.
How would you relate to this article? https://medium.com/@u_glow/the-numbers-on-webpack-1-vs-2-7f457bb4658c#.vjioayj0w According to those measurements webpack 2 gives the same or worse build times and bundle sizes. Were those just a bugs which don't exist in the final release or that's how it is now?
I don't think it is that reasonable honestly. From my use, when most of the ecosystem is ES5 the notion that you can hand wave it as something that won't be a problem in the future is a poor argument. How about I take my time to use a bundling system in future projects that actually does what it claims with an arguably even simpler configuration that has been doing this and other things successfully for I believe many more months now?
Why are you trying to automate that? It seems sketchy to me. If you can justify why, people might want to help you.
[removed]
The ones who work in serious teams do.
That is good news, thanks to everyone involved in this, I am not smart enough to help with development so I am always grateful to the people who are. While on the subject of webpack 2, a week ago I stumbled upon [this video by Emil Oberg](https://www.youtube.com/watch?v=eWmkBNBTbMM) and I though it was an AMAZING tutorial on webpack 2, well worth the watch.
I'm forced to Chrome 49.0.2623.75 and Internet Explorer 11.0.9600.18537.
I think it's important to think out loud and if you don't know the answer to a question explain how you would figure it out and how long it might take. ie, "oh, I know `this` will behave strangely in this context, but I'm not quite sure how... I would try this and if it didn't work I'd have to research a bit with google. It would probably take me less than half an hour to clear it all up". Confidence is important. No one likes to hire someone that is afraid of messing up a relatively simple thing -- it should be ok to make a mistake here and there. And if it's not ok to make a easily correctable mistake, then do you really want to work there anyways? Don't be desperate.
You're probably referring to Rollup? To be fair, Rollup can't handle ES5 tree-shaking. It's just not possible without risking breaking code. Rollup can be tough to configure as well, i find it way harder than Webpack because by default it can *only* handle ES6. If you attempt to make it work for npm and commonJS, prepare yourself for configs that make Webpacks look like a joke. And even then, you'll run into dozens of issues. See this: https://github.com/rollup/rollup/issues/385
Thanks everyone for your answers so far, they are very much appreciated :)
&gt; we totally want to fix this because it will bring the last piece of feature parody we lack with rollup Heh, great typo. p.s. great work!!!
&gt; it could actually be quite a bit simpler than your example I maintained the check for the document object being passed in. Presumably you can grab the document object of an iframe and pass it into the same function, instead of only using the window.global. I'm not sure---I haven't actually done anything like that but I assumed it was there for a good reason. &gt; You're passing in a reference to the function, not the Promise returned by the function. You're right about that. I think this might work, though it's a bit ugly looking for my tastes. fetch('your-api') .then(parseYourStuff) .then((response) =&gt; onDomReady().then(() =&gt; response)) .then(injectIntoDom) 
That's a good code review :) It's much simpler this way. @dylexiccoder has another example.
[Alert debugging in JavaScript](https://www.reddit.com/r/orlybooks/comments/4x2hme/alert_debugging_in_javascript/) is the new standard
iirc it's pretty much ready but they're trying to update the docs before they take it out of beta.
Thank you guys for this amazing tool. It's made front end development workflows very enjoyable. One question though, what's the status of hot module reloading? Is it still being changed a ton or would you say it's OK to use right now ?
As well as the draft specification it might be worth linking to some browser support information (such as http://caniuse.com/#search=audio%20api or https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API#Browser_compatibility) It does seem to be widely supported, only to be avoided if legacy Internet Explorer is something you need to worry about.
Is there a Newsletter for that blog? I would subscribe immediately!
Nice, what happened to Material Design Lite ?
Thanks for the help, any idea how I could "reverse engineer" it just by inspecting the network tab?
It would be easier to use something like [Fiddler2](https://www.telerik.com/download/fiddler/fiddler2) to monitor all requests and then find the correct one(s).
yea it would seem that is actually the most confusing thing one can come up with but its really a separate topic just on Function's.
Yes, so that the _really_ early adopters can started taking it for a drive, figure things out by themselves, and confirm that it's working as expected. If someone's asking whether it's time to migrate, that person's probably not looking to be an early adopter :)
I appear to have it now. I seem to have had a lot of &gt; It's no longer allowed to omit the '-loader' suffix when using loaders. Fine, but it's difficult to determine where I am not specifying it. In my most egrediuous case, it was because of font-awesome and the ridiculous way I required it: require('style-loader!css-loader!less-loader!font-awesome-webpack/font-awesome-styles.loader!font-awesome-webpack/font-awesome.config.js'); I had to change all those `!css` to `!css-loader`. The error did not provide a line number or even a file name. Just the dir name, so it was a hunt ModuleNotFoundError: Module not found: Error: Can't resolve 'css' in '/Users/mark/Sites/tg4/app' BREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders. You need to specify 'css-loader' instead of 'css'. Edit: also, my bundle size apparently is twice as big now. Don't know if that's because of webpack@2.2 or because i moved a bunch of stuff from "devDependencies" to "dependencies" or whatever the heck I was working on last night while drinking PBR.
looks cool, I guess? Can you explain the usecase / repository boxes of the diagram?
Thanks. I need to learn more about this. What about let then? You said use const always, but doesn't let also have a purpose? Just no more var, right?
Awesome, thanks :) 
What's the difference between == and ===? How many different data types for numbers are there in JavaScript? Are JavaScript objects passed by value or reference? If I have object B that is the child of object A, and I change the prototype of object B, what are the effects? What are some of the new features of ES6?
Hi /u/ensrsjahu, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your homework for you.
If you have a serious aversion towards for-loops, you can always summon the power of recursion. const range = (a, b) =&gt; { if (!b) return range(0, a); if (a === b) { return []; } else { return [a].concat(range(a + 1, b)); } }; 
Surprisingly for my interview they didn't ask me many JS questions, I had an coding exercise they had me do before the interview and I had to explain my reasoning. They asked me more general questions about how the internet works, like why sites use image sprites, how dns works, https etc. They also asked me about some of my github projects. Overall it was really relaxed, more like a conversation than an interview. Good luck!
I got inspired by [Firebase](https://firebase.google.com/). For the past 6 or so years, I've had data collectors writing to a MySQL database, which gets replicated to a public-facing server. On numerous occasions, replication would break, or get out of sync and generally was only like 95% reliable. Plus, I had to poll the main server for new data constantly, when viewing the client page. In my current version, I've decided that those little data-collectors should write directly to the public database, with a new ability to also write to all active clients via sockets, so the lag to see new data is down to ~100ms vs 5 seconds. Doing this kind of socket type work seemed to work best with MongoDB, and we basically make a module to do to backbone and mongo what Firebase was doing. Meanwhile, [my app](http://demo.telegauge.com/) (a dashboard, with lots of different kinds of widgets) often had different "column" requirements between different widgets. MySQL's static column requirement meant that I had to have a common column list among all records, and in many cases, was dumping a lot of the unique data in a "json" string in some column. Or, boolean data would have to carry around "average" and "min value" columns, which didn't make sense. Etc...etc.. With Mongo/NoSQL, each record is it's own document. There are common values, such as position on screen, but also values unique to the record, such as the range of a gauge. To say all this another way, if my database was a big excel table, I had a lot of columns, and many of those cells were always empty, because they were not applicable to the record type. Now it's an (indexed) folder of JSON documents. Plus, no replication lag or errors. Downsides? Probably. On-disk size is larger. RAM requirements are larger. I don't know yet how it will scale for large collections of timestamped values. I have to rely on the client to do all the processing now (so computing a stddev means downloading the entire dataset, rather than asking the server to give me a stddev)
Great point. So in terms of build speed we changed our graph traversal strategy for the dependency graph from recursuve to iterative in 2.2.0-RC.3 this yielded some pretty noteworthy gains in performance. In terms of bundle size, it is really relative and hard to compare however we'd urge ya to update and then measure. If it turns out there's a regression, we'd really love to tackle it. 
So first thing I'd ask is to take a look at one of the webpack "bundle-analyzers" that are on npm (you have a few to choose from). Then see if there is any noticeable lib bloat. Besides that, please put in an issue and tag me @thelarkinn so I can follow up with it. Even better a reproducible example is even more bad ass. (PBR Optional 😏)
Well I can definitely take the blame for that and I apologize. In fact I will do update the issue right now. Really sorry for your frustration! 
In the last line of your loop you're not passing a function but an expression, so it happens right away, so x is reset to true and the loop is running again. So you've made an infinite loop. Additionally, it might be easier to just use setInterval with one function and pass that function a number which you increment each time, then clear the interval once you hit 6. Also if you're using the same jquery element several times, just grab it once and set it to a global variable and reference that variable, then you don't need to go dig in the DOM each time. Edit: sorry if any of my answer is unclear, I'm on my phone to difficult to type example code. 
&gt; horizonjs I read this as "deepwaterhorizon.js" which I assumed was a modern javascript framework for drilling oil in the atlantic ocean. 
It's telling you to use the spread operator because of the `.apply` function, which the spread operator has almost completely replaced. If you want to conform to ESLint while using the same strategy, you could use this instead: `[...Array(10)].map((_, i) =&gt; i)`, or `Array(...Array(10)).map((_, i) =&gt; i)`.
I'm working through all of that now, but my [replacement](https://www.reddit.com/r/apple/comments/5kjtxd/well_my_new_macbook_pro_died/) Macbook Pro just arrived. Here's what I have so far: https://dev.telegauge.com/report.html You can see large things like "bn.js" which appears to be only used by webpack@2.2.0. └─┬ webpack@2.2.0 └─┬ node-libs-browser@2.0.0 └─┬ crypto-browserify@3.11.0 └─┬ browserify-sign@4.0.0 └── bn.js@4.11.6 I would not expect that to be in my "vendor" bundle, so I can bet I have some configuration options to mess with. 
Answer provided in the lovely Discord reactiflux channel: const a = Array(...new Array(10)) .map((_, i) =&gt; i); console.log(a); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
Okay so btw thanks for being candid I agree that the communication here totally needed improvement. I will take this as a future improvement. I have updated the issue and added to our milestone soi you see it is tracked. Let me know if there is anything else we can do https://github.com/webpack/webpack/issues/2867#issuecomment-273516751
Cool yeah I'd already got the answer but I hadn't considered you could do `[...Array(10)]` as well. Cheers!
Oh that's really nice, thanks - I haven't had a need for `Array.from` until now :-)
Was looking at the DOM but my eyes burned out. So many damn classes, christ!
 function* counter(limit) { var index = 0; while(index &lt; limit) yield index++; }; var a = [...counter(10)]; Maybe?
Good step-by-step guide to implement a performant mobile menu. Nice!
# A Halfway Measure **Try and group elements with related events under some container where you can add the listener to.** Suppose you have some list of items, such as a leaderboard or some other list-like structure where you can perform certain actions by clicking on one of the elements. If you attached the event listener to the body, that'd be too wide in scope. Instead, you can attach it to the list container itself and listen from there. If the event is triggered then there's a high chance that it came (bubbled up) from some element you need to handle. # Things to consider - Debouncing/Throttling If you have an event with a chance of triggering a lot, such as a scroll, look into debouncing/throttling. You can either stop listening to the event after it fires once and reattach it after a while OR you can poll at intervals. [Link](https://css-tricks.com/the-difference-between-throttling-and-debouncing/)
well... 2nd to be honest the 8 in between were carbon copies of each other with just design changes and its not 100% complete.....alot of placeholders hopefully your viewing mobile and not desktop....more placeholders on desktop stuff
That was just my impression. And i've seen it reflected in what others went through, exactly like the guy that opened the issue. Moving along with Rollup, with a real world project, that wasn't easy by any means. I fought days to have something running, and then still i had countless of unresolved issues. I gave up eventually. Webpack configs are mostly fine, because it does lots of work by its own. I don't have to worry about npm, node_modules, commonJS, System.imports, requires, etc. It doesn't mean Rollup doesn't serve a purpose. I like the way Rich Harris treats his projects. Rollup and Buble fulfil specific needs, and if you don't go out of that frame too much, these are the best tools in the Javascript landscape. What he did with three.js for instance was amazing.
Just stumbled across this today while preparing a presentation, looks really useful. Upon trying it out my class diagram attempts turned into weird deformed blobs but we will see.
On mobile, the little I tested seems to work fine. It's on desktop that it has issues. You shouldn't release something that isn't ready, at least on a URL that directly ties it to the client.
The problem is the implementation literally stops you from running your webpack. Rather than warning you that either an option is obsolete/deprecated or never existed it, it completely bombs your build.
This one pretty good, too: new Array(10).fill(1).map((x, i) =&gt; i)
Deep copies are an antipattern. Regardless of implementation, a deep copy is always an expensive operation. Edit: I didn't mean to imply that they are an antipattern because they are an expensive operation.
Write a utility function. All suggestions here are clever tricks, but do little to make your code more readable. Just write a small utility function that does this for you, that is much, much clearer. 
I'm looking for something that does it the other way. I want all the `console.log`, `console.time`, `console.table` etc... to be redirected to a DOM element on the page.
The config is literally not broken. Is this code broken? function test(opts) { console.log(opts.something); } test({something: 'Hello', extra: true}); The code still works. This is exactly what webpack would bomb on in because you didn't meet the schema. They could have instead chosen to warn you that the property serves no purpose and to remove it. If this wasn't dynamically typed it would clearly be a problem. These wrong properties in configs could have been a deprecation with warnings about the wrong properties and come v3 making it a requirement that it is strict.
RemindMe! 13 hours "to try or not to try"
Just curious but how would you summarize prototypal inheritance? It's an honest question. Everyone talks about it but the subject seems so much deeper than most people give it credit for, and it seems like everyone has different definitions for all of: classical, pseudoclassical, prototypal, prototypical, and functional inheritance, and then there are factory functions, patterns for composition, more specific ideas like parasitic inheritance, and small libraries implementing concepts like stamps. 
Here's a list I put together a little while ago that may help you prepare: https://github.com/h5bp/Front-end-Developer-Interview-Questions https://www.frontendhandbook.com/practice/interview-q.html http://davidshariff.com/blog/preparing-for-a-front-end-web-development-interview-in-2017/ https://www.toptal.com/javascript/interview-questions http://www.thatjsdude.com/interview/js2.html https://medium.com/@mrdaniel/3-questions-to-watch-out-for-in-a-javascript-interview-725012834ccb#.a2v19rt9e
Any way to create that object using a literal? 
One that I like to use is [nomnoml](http://www.nomnoml.com/).
No, not that I'm aware of. 
write an asynchronous function that will retry a set number of requests before executing a callback (either an error or completed response). function request(cb) { setTimeout(function(){ return Math.random() &gt; 0.5 ? cb(null, 'OK') : cb('FAIL'); },0) } function retry(argument1, [...argument2]) { // fill in arguments above and code here... } just wrote this quickly above and don't know if it makes sense. I know it's not es6 either but it's supposed to measure if you're comfortable with async callbacks.
The inheritance question was definitely phrased badly but basically you should know that if a child shares its parent's prototype, changing the child proto will change the parent's as well. 
I think I'll have to disagree here. One of the most confusing processes for users is the fact that regardless of us publishing great docs, that many people will also copy-pasta information from configs. This leads to unknowingly adding invalid, or incorrect configuration values (especially from previous versions). We don't ever plan on allowing people to get away with providing wrong values in our configuration and this schema is laying the foundation for a better more consistent user experience. 
No offense taken. We've been pretty damn busy and dropped the ball on keeping this visibly tracked for the community. Being limited on time and focus resources sometimes leads to things like this, but with support, etc. and more contributors we believe this should help. 
 const wrapper = (...args) =&gt; new Promise((resolve, reject) =&gt; somefunc(resolve, reject)) 
Why?
It is still considered a good practice to deprecate before complete removal to give people a heads up and time to change over to ease migration.
I really don't see how creating a separate named function just to initialise an array with some values, probably defined far away from where it's used, is easier to read than the snappy and idiomatic solutions already given. I think that would make the code far more difficult to parse. 
Nice reply :) Could you expand on the point about super? The only language I have a really strong foundation with so far is JS 5.1, and while I've experimented with ES6 classes as well as other languages like Java or C++ I haven't done a deep dive yet, so I'm curious what version of super you mean and what it does/provides in the context of your reply. 
Can't say; I found this reading http://mutanatum.com/posts/2017-01-12-Browser-FP-Head-to-Head.html Maybe this author have seen it in the field.
Maybe you need a more complex example for the contrast to really shine? Honestly the for-loop seems so much cleaner. I think for me it's because they are so widespread, and it essentially means I only need to parse one line in my head. To me it reads "from i to n, square i and add to the array" while the second requires me to shortly consider the parameters and syntax of the two functions (which are simple but still more than a for-loop) and which are much newer (ES5/6) than the for-loop (probably 2000BC).
 myAPIFunction = function (properties) { // ... let deferred, promise = new Promise((resolve, reject) =&gt; deferred = {resolve, reject}); if (error) { // was errorFunction(error) deferred.reject(error); } else { // was successFunction() deferred.resolve(); } return promise; };
This one's a pretty specific use case but if you're just trying to copy a data structure and not an object with methods on it, you can just JSON.strigify the original and create the copy of it with JSON.parse
this link was exactly what i needed. i feel like this should be higher up in the redux docs. thanks good sir
my sentiments exactly. just wasnt confident enough to come out and say it as im still a learner
You can pull in individual methods too if you don't want to have the entire library as a dependency. It's pretty great for "I have this one thing I want to do a lot (extend, clone, map, etc...) and don't want to write my own helper." Especially since lodash is optimized to all heck, sometimes even beating native Javascript performance.
&gt; But power through your emotions and start asking the engineers questions. Ask them how they manage their code, what (if any) is their peer review system like, what is the management style like. If the engineers come off as happy to talk about these things, then the working environment is probably not that bad. The happier the engineers are to talk about management style, the harder they fought management for a saner place to work. If they become dismissive of these questions or their mood clearly becomes agitated, then there is friction in the office between engineers and the suits that give them improbable deadlines to meet. this bears repeating. you absolutely need to ask them questions. do they write tests? do they have continuous integration? ask what their testing environment is like. ask about their tech stack and the tools they use. gauge the overall response.
Yeah, I've pulled in `lodash/assign` and `lodash/once` on their own into projects before.
One question I once had during an interview was to live code a basic "Promise" class (that respects the spec, which you should know).
You're welcome! (And as the author of that "Structuring Reducers" section, thanks as well! :) )
Yeah so in classical inheritance (class based which JS attempts to emulate with ES6 class syntax) which is prominent in languages like C++, C#, Java, PHP (many others), a class that inherits from another class can refer to the parent class from within an instance. Using ES6 syntax for an example here: class Parent { constructor() { // some init code ... } getName() { return 'some name'; } } class Child extends Parent { constructor() { super(); // &lt;-- this here executes the constructor of the parent class. // child class init code ... } // override of parent class method getName() { let name = super.getName(); // &lt;-- calling parent class getName() method. return name.toUpperCase(); } } Super allows you to reference the parent class functionality from the child class. In the child constructor you can call `super()` if you need the parent class constructor function to run when the child class is instantiated. This is optional but if you do use `super()`, it has to be the first statement in the child constructor or it will throw an error since the assumption is that the parent should initialize first. Also, if the parent constructor accepts parameters, you can pass those to super as well. Using super in a method override is a little different in that you specify the method you want to call like `super.getName()`. You don't have to only call the function you are overriding either. Could be any function from the parent class but it's most commonly used with function overrides.
I can't remember the last time I've seen "mod equals" if ever. Nice.
&gt; In Promise, Anytime, When `.then()` method returned a promise and can be “unpacked” it to get to an actual value. Literally unreadable.
Check out ES6 Modules (import {x} from "y"). Design your code just as you would in Node.JS (you know, how you wrote the gulp file), just a different import syntax. Node's import syntax (CommonJS) still works, but you should just go ahead and get with the final standard way of doing it. The biggest learning curve when moving to Webpack is how CSS is handled. See ExtractTextPlugin for getting a .css file, or just leave it in your .JS depending on how your app works (If your entire page is rendered with JS, the only benefit to extracting it is parallel downloading and separate cache from the JS incase JS changes but CSS doesn't)
Yes technically you can, but I don’t think it’s useful. { __proto__: Array.prototype, 0: 1, 1: 2, 2: 3, length: 3, bar: 'baz', }
[removed]
That's not really the object, though, the object is usually to give up CPU cycles to the UI. "Making a synchronous process asynchronous" of itself isn't particularly useful, the object is normally to release CPU so that the UI can get some (cycles). At least in browser world. I've been using node for about 6 years now, and have literally never seen anyone setTimeout(x, 0) in node. So, what is the purpose then of the other items, such as msngr.immediate() ? 
FYI, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics.
Fair enough. Regardless, it's not like expensive operations aren't good fits for a standard library. Per example, the [crypto proposals](https://w3c.github.io/webcrypto/Overview.html). I'd be curious why PtaJ does think that deep copies are an antipattern. I've never heard anyone else suggest that, so maybe there's an interesting perspective there.
Thanks. I've been following the React track on Team Treehouse and branching out after that and checking out your suggestions. Treehouse is one of my favorite learning resources. Major kudos for that list! Thank you!
Object.assign does a shallow copy of both questions and state into a new object.
Gotcha, realized that there was no reason to store the array in the questions property so I took it out and mapped over the array. seems to be working now. Thanks a lot for your tips.
Why do you hate relative paths? Why don't you like other solutions? I'm sorry but software runs on real benefits and flaws, not emotions.
So relative pathing leaves much to be desired when you want to reorganize code and the other solutions I've found is really centralized around adding more paths to NODE_PATH so require can discover it. They all seemed messy when I just wanted to declare a folder structure that is more than one folder deep. I've also run into issues when I don't necessarily want to relative link my config file just so I can have access to all the modules of my framework. This in a way allows me to have a global *space* without putting anything into nodes' globals. [I was going off of these ways to fix relative pathing](https://gist.github.com/branneman/8048520) 1. I wanted a way to not have to symlink. Developing on Linux/Mac you don't have the problem, but on Windows/Vagrant(Linux) you quickly realize symlinking inside of vagrant doesn't work the way you want it. 2. Dirty globals that could be modified anywhere 3. This is closest to what I implemented but left defining paths still much to be desired. 4. Didn't feel like this was an appropriate way to pull in extra modules, or allow modules to define more spaces. 5. This is just messy 6. The name gives it away 7. Might end up adding this to the package as an alternative way to require from spaces. It's not bad but still pollutes the global variable.
See these are great solutions for client side code or if your code is already transpiled on the server. In the case you don't want to transpile or compile your server side is the use case for this module. I'm all for webpack though, loving it with Angular.
I just symlink the folders into node_modules. Been using the same strategy for over 2 years without any issues.
I'd say this would create problems if you want portability or want to have easy development using vagrant or docker. If your symlinking is manual then that's another hurdle someone has to go through when starting development on your project.
Wow, a more than 10 years old article. Fun to see what was considered as "good programming style" back then.
ironically at this time ws 2016.3 just can't debug node7.x and there is no reasonable way to fix it. either you wait till 2017.1 is out, or you downgrade either node or ws, or you install a EAP ver.
&gt; 7 Coolest JavaScript Tricks &amp;amp; Hacks ~~you should check out~~ *from more than 5 years ago that weren't even cool back then* ! FTFY
It's effectively no different from the yo generator-generator except that it is built to utilise ES6 for generator scripts. Running the bash script, configures babel etc so that you can get going with creating your own version of 'yo [angular-fullstack](https://github.com/angular-fullstack/generator-angular-fullstack)' for example. Once you publish it will be available as a [yeoman generator](http://yeoman.io/generators/)
Thanks for the reply. I will check out the ES6 modules. Most of the sites I've built usually have some sort of PHP backend, and often PHP templating as well (Laravel's Blade templates, Symfony's Twig templates), sometimes mixed with a front end like Vue or Angular. I'll take a look at the ExtractTextPlugin, thanks. When would the entire page be rendered with JS? Do you mean as opposed to, for example, PHP rendering the items in the DOM? If so, a lot of the things I've been working on have been rendering via JS, so I guess CSS is fine in the JS too.
Great job starting to learn JavaScript. One suggestion I usually offer to new developers in JavaScript is to try learn JavaScript outside the browser. By that I mean, do not deal with DOM(Document Object Model) to begin with - at least try to keep DOM minimal. DOM has too many quirks for beginners to deal with. And a lot of confusion and aversion around JavaScript is largely due to browser bugs in DOM than the core language features. You declared a "addElement" function inside an "if" block. We should ideally avoid doing that for reasons that will take a bit more space to explain. But overall, good start. Keep reading good books like YDKJS series and others like Eloquent JavaScript etc... All the best!
If you really want named components, I'd go for IoC as it has the added benefit of decoupling dependencies. 
Wow. This is amazingly detailed. Thank you for this! 
&gt; and its not released for the client...its a brand new startup with no marketing....so noone headed there yet....and im the client :) Fair enough! &gt; what issues did you find on desktop? On Firefox: Basically ```&lt;header&gt;``` stays fully expanded and does not let one see the content of ```#page```, ```#blogclub``` or ```#list-collections``` beyond about 30px. On chrome: The opening animation of the Koala is barely viewable, the koala's body appears below the fold and the head above the fold. Stylistically, you should add a bit of ```text-indent``` to ```&lt;h1&gt;Why Belair Club?&lt;/h1&gt;```. For me, ```text-indent: 15px``` looks fine. Hope this helps! EDIT: It seems that the culprit is that shopping cart image. It has a width and height of 591px in my case. Additionally, ```#list-collections```, ```#blogclub``` and ```#page``` have ```padding-top: 622.5px``` which pushes the content down.
This won't set magic `length` behavior though.
I just wrote this. Will open source it soon
Vuex is much closer to Mobx than to Redux
I stopped after I read the "pro" points of JavaScript 😓
man, learn react please
Thank you for the resource mate
Vuex is close but they still made decisions that cut it off the Redux ecosystem. You'll have a hard time shipping your logic from one project to another if you switch frameworks later while with Redux the app is abstracted and you can re-use it anywhere. That's why we opted to use Redux in Vue. You'll find that existing bindings (like react-redux) are often ineffective or crippled. Some render everything on every change, some don't support chained selects (users[id].something). But it's easy to make your own, see here: https://github.com/vuejs/vuex/issues/450 
`MVVM` View = presentational layout, usually a mark-up template Model = data or a store ViewModel = class to represent the view by exposing bindable assets which the view uses to inflate its layout or write changes back to the model `MVC` Model = same View = same Controller = receives user input, converts it into the view or modifies it at least Both are older concepts. Newer frameworks have all strayed from this because it is a complex and convoluted procedure that gets very messy once the app grows. You're dealing with an infinite succession of modifiers that are hard to control or compose. Today you would most likely use a one-directional approach. It started to be commonplace with Facebooks Flux pattern, here's the visual difference: http://iweave.com/assets/blog/mvc_v_flux.png Since then Flux has evolved into Redux, which trims down the overhead. As for the View, templates have evolved into a functional approach which was pioneered by React and has become a semi-standard, there are countless of libraries using it now. It literally works like a function: input in, UI out. Or in a real example: const Header = ({ children, color }) =&gt; &lt;h1 style={{ color }}&gt;{children}&lt;/h1&gt; const App = () =&gt; &lt;Header color="red"&gt;hi there&lt;/Header&gt; That's why people say that React and derivatives are the V in MVC. A state manager like Redux would now connect such components to a centralized store. If the store changes (through explicit actions), it calls the components that are affected with the new properties and they return the updated UI.
Just to get my spoon in. Redux detects changes by checking referential equality, i.e. is the returned state the same object that was passed in, i.e. `state === nextState`. &gt; const state = { hello: 'world', beep: 'boop' } &gt; const state2 = Object.assign(state, { beep: 'bzzt' }) &gt; state === state2 true &gt; const state3 = Object.assign({}, state, { beep: 'bzzt' }) &gt; state === state3 false So, just as you rightly conclude, assigning directly onto current `state` will not signal to Redux that changes occurred.
How does this differ from using local paths? https://docs.npmjs.com/files/package.json#local-paths
Nice, but i think this should probably also work with pointer events now that chrome and ie both support them.
`this` is not the problem. The problem is you can't remove a listener when you no longer have access to the listener. When you inline a `bind()` in `addEventListener()`, or even if you're inlining a function expression, you're creating a new function whose value is only being passed into `addEventListener` and not somewhere where you can access it again later, which is what you'd need for `removeEventListener`. The solution is to make sure you can access it again. You can do this by reassigning the function to its bound version in the constructor. let Button = function () { this.el = document.createElement('button'); this.clickHandler = this.clickHandler.bind(this); // bind &amp; assign this.addEvents(); } Underscore/lodash has a `_.bindAll` utility that can help with this, and there are also `@autobind` decorators out there for this in classes too.
I'm not saying go crazy with backwards compatibility. I don't test in IE6; heck I don't even test in IE10. But you should think about what your audience is and make decisions accordingly. Apple's own statistics report that a [full 24%](https://developer.apple.com/support/app-store) of their devices are running using ios9 or earlier. You'd be surprised how many people still run IE11, and those numbers aren't really going to change until Windows 7 and 8 drop off the map, because Edge is only available in Windows 10. Are any of your users visiting on a console or a smart TV? Unfortunately, people do actually use them to browse the web. Those numbers might not actually go down either if IOT manufactures get aggressive enough about sticking screens and browsers on everybody's fridge. ES6 is awesome and if you know your market well enough that you're comfortable with current support, or if you're compiling your code, use it. But it is not a one-size-fits all solution - especially because you can't feature-detect it or get it to fail gracefully. If you're using native ES6, your fallback model for old browsers is "they don't get Javascript." If you've built an awesome progressively enhanced site that doesn't need Javascript, then cool. If not, you need to think about whether you're comfortable with that - which is why I don't universally recommend it unless I know what the context is.