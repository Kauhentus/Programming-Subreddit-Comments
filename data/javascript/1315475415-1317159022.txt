The page says about the issues specific to certain IE versions, but doesn't say the program itself only works with those IE versions. From what I could tell, it is meant to intercept JavaScript calls and show things that could potentially cause memory leaks, without relying on a particular IE version (instead looking for the JavaScript calls/patterns that cause the leaks)
Thanks. I'll probably end up slicing my spritesheets into canvases. Also a little story about doing complex math during the draw cycle: I had an engine prototype that was using vector graphics instead of sprites. It also had a camera (what you call a viewport) that could rotate and zoom in and out. And I did that without using context.rotate, context.scale or context.translate. That meant copying and transforming my polygons on every frame, before drawing them. I wrote a little test and ran it, thinking that it would surely bring my browser to a halt with all that math going on. Turns out that it ran fine. And when I used chrome's timeline to find out how much time my math took, I found that it was insignificant compared to how much time the context actually took to draw the polygons.
Very impressive for a web-based rendering.
what?
for web this looks awesome
My thoughts exactly!
That is pretty damn awesome. I will have to go through the code when I have time.
For Chrome, I guess your issue comes from content scripts limitation. It is said [here](http://code.google.com/chrome/extensions/content_scripts.html) that scripts "cannot use variables or functions defined by web pages or by other content scripts".
It doesn't work as expected because Greasemonkey userscripts aren't evaluated in the same context as the JavaScript in the page. For more information see the [GM wiki page on the matter](http://wiki.greasespot.net/Security). FWIW to get it working you would change `window` to `unsafeWindow` in that code snippet and then it will work as you expect.
yeah, that didn't make much sense. Beer + Reddit + trying to be funny != good for me.
really awesome, gives amazing insight to the dom structure at a first glance
Excellent!!!!!!
I really, really need to learn how to write 3D visualizations with JS and canvas. :/
Yeah this thing is so cool. I stare at it for long periods of time every time its posted somewhere.
Man, I tried to be nice, but you're a dick.
Just 14 correct entrants so far -- pretty good odds for winning the prize . . .
Very cool, thanks!
All it needs now is self-shadowing.
Wut? Your link takes me to a login page for ebay web-based outlook?
Sorry that giving you the detailed help you needed didn't get you to "thank you." Funny how you were agreeing until I asked you why you wanted to do the things you were suggesting.
&gt; I will have to go through the code when I have time. It could use some comments. that's fore sure.
Ok, a little OT, but further to this, you now no longer need to use the Easing plugin. Instead, I've incorporated a little plugin called Bez (http://github.com/rdallasgray/bez), which allows you to specify easing as cubic-bezier co-ordinates, per CSS transition syntax, and is backwards compatible with jQuery.animate. Could be useful on its own as well -- you can basically create easing functions on the fly from numbers ...
I've been playing a bit with this thing. What I like most is that it's so light-weight. I like using jquery mobile, and there isn't really anything lightweight that seems to work well with it. iscroll is overkill for sure. Here is roto in a little project that I have been working on (only tested on iphone 4): http://pixeledblue.com/roto/
TIL about this JSFiddle thing. looks cool
This is awesome, thought about adding a little kill counter for each tower?
I apologize for calling you a dick. I was insulted that you think I'm stringing bullshit together. I'm not making any assumptions about you.
Quite impressive! And not much code for what it does!
paused is an undefined global. Unused variables: v6 'setLayer', v2 'setLayer', v3 'setLayer', d 'boxFaceFront', tree 'Tests', Stump 'tree', c 'terrain', rules 'calculate', power 'calculate', mouseLast 'Flier'
&gt; I was insulted that you think I'm stringing bullshit together. The easiest way to get me to stop thinking that is to explain how gestural interfaces are an AI topic, or why you'd be doing corpus work in a web browser. &gt; I'm not making any assumptions about you. Nor I you. I am making a deduction from a bunch of assertions which, unless they are later explained, really don't make any sense. If someone says they're going to convert their oven and their car to go to space, and one comes to the conclusion that that person knows relatively little about physics or rocketry, there are no assumptions being made. Having a request for explanation in is the offer you're looking for in order to show how your oven-car gets to orbit, no?
I don't use translate or scale in my engine. I prefer giving the viewports (you can have more than one) an x and y position, and when elements are drawn to each viewport, the viewport x and y is subtracted from each elements x and y. If the elements are out of view they are skipped. There is one other benefit I forgot to mention too. With a divided sprite sheet system you can add more or replace old sprites in sprite sheet object at any time. I also noticed that most of the process takes place waiting from the DOM too, but decided to divide my sprite sheets up anyway because of the new flexibility gives me. You also have to consider that with every element in view multiplies the draw cycle's overhead.
I answered some questions about it here: http://www.reddit.com/r/programming/comments/k7ewc/swarms_battle_very_cool_simulation_of_swarms/
Impressive! I love the art and music.
Thank you! I googled for something like that but didn't find anything. If only I had asked earlier you could have saved me an entire day of frustration! Edit: OK no errors in the code it just doesn't work :-(
I do a rectangle-based collision check between the viewport and the objects I draw (sprites and polygon based models) and keep the ones that collide with the viewport. Then I translate the context to the viewport's top left corner and I can use the objects' own coordinates to draw them.
Actually that was wrong (Its 3am here, and my brain is a bit tired). What I do after the collision checks is translate the context to the sprite's position and draw it at (0, 0). EDIT: this is wrong. (see comment about it being 3am)
Static code analysis can only find things which are obviously bogus and therefore are most likely incorrect. It's amazingly useful. Well, I suggest to keep an eye on the console. Check if some errors show up there. Also, try Firebugs or Chrome Inspector's debugger. Add some `console.log('foo')` statements at some key points in your code and check if it even gets executed.
Shirley, you must be a genius.
try url: 'td',
Yeah I've tried that... :/
Sounds like a good method. If you'd like to share notes add me on [Google Plus](https://plus.google.com/106289343978892459649/posts). If you don't have one email me from my Google Plus profile and I'll send you an invite.
I've tried using stringify with a form object, and it didn't turn out.. I'll be interested to see if there's actually a 1-liner solution to encoding a form. Otherwise, just build info manually eg var info = { field1 : $('#field1').val(), field2 : $('#field2').val(), ... };
Oh, well I found this snippet on stackoverflow that I've been using. I left it out in the question... $.fn.serializeObject = function() { var o = {}; var a = this.serializeArray(); $.each(a, function() { if (o[this.name] !== undefined) { if (!o[this.name].push) { o[this.name] = [o[this.name]]; } o[this.name].push(this.value || ''); } else { o[this.name] = this.value || ''; } }); return o; }; This function is called when I encode the data with stringify...
jQuery.ajax( url, [settings] ) So wouldn't you want: $.ajax('/td', {type: 'POST', data: info}) ?
Ok, added. (I'm Urmas Lamster btw) Also the method above won't work :) context.translate moves the context's (0, 0) coordinate on the actual canvas. Which would cause everything to be drawn off-screen. So you still need to subtract the viewport's position from the sprite's. Transforming the context (with translate, scale and/or rotate) comes in useful when dealing with vector graphics, so you don't have to recalculate your polygon data on every draw. If you didn't see my reply to my own post, then I'll say again that I'm pulling an all-nighter and my brain is a bit loopy.
It looks like you're submit event listener is probably being called, but the form is still submitting after the fact, and if an action isn't specified in the &lt;form&gt; tag, by default the form is posted to the same page. I think if you did something like: $('form').submit(function(e){ e.preventDefault() You should prevent this and the ajax request will go though. 
Holy Moley!!! I had no idea you could do that! :D Good stuff man, thanks for the help, it works like a charm.
I always make sure to put it at the top of the callback, that way if any of the subsequent code raises an error, the form doesn't submit, or the link doesn't go through etc.
To change to 60 fps, edit the second to last line and change 33 to 16, then click run.
pew pew pew!
I'm on here too, I'm trying to hunt down all the places that demo has gotten to. Quite stoked at how many people seem to like it!
The user can encrypt data in the browser (with a key only the user knows about), before it is being sent to the server, and vice-versa. I have no idea why you would like to do that, but it is not wrong from a cryptography point of view? Edit: Proved wrong, *it is not a good idea to use JavaScript crypto*, see the linked posted by [jorick](http://www.matasano.com/articles/javascript-cryptography/).
That's great -- nice to see what someone else can do with it! I know you haven't tested it on anything but iPhone 4 -- on desktop browsers and iPad, the 'Latest' section is sitting to the right of the navbar. Maybe a float that needs cleared or something? Be really interested to see where this goes!
http://www.reddit.com/r/programming/comments/jxb8g/javascript_cryptography_considered_harmful/
Awesome...I'll look at the code, so much I could learn from you. Thanks for posting this.
Nice. ok. I don't think you need to call stringify since the data parameter in ajax() accepts an object. 
it's the same thing as `onsubmit="return false;"` , or `onsubmit="return methodReturnsFalse();"`
read [this](http://www.mail-archive.com/jquery-en@googlegroups.com/msg71371.html) re: return false vs event.preventDefault() Also, remove the comma after data: info
You can use $('form').serialize() or $('form').serializeArray() http://api.jquery.com/serialize/ http://api.jquery.com/serializeArray/
I'll give it a try. thanks!
Check their sample app. Click on login (which works via Google). From the page on Google hit the back button. Enjoy the redirect back to Google. Fuck one page "web sites". This has nothing to do with the web, REST or HTTP.
* 8:30 problems with large applications in javascript * 12:20 intro closure tools * 16:00 highlighting common problems for js developers today * 20:30 dependency management * 26:45 overview of architecture of an application in closure, followed by more dependency management stuff * 35:40 closure compiler (this part was pretty impressive) * 42:30 static typing in js * 45:00 question period
I would think that it's wrong from a cryptographic point of view based on the "don't write your own crypto libs" rule. HTTPS/SSL/TLS serve this function, why try and replace them?
/r/netsec will kill your whole family for even suggesting this idea.
You may want to encrypt something using a key the server does not know or encrypt something for local storage. I know there are other reasons for javascript cryptography being indefeasible right now (see [here](http://www.matasano.com/articles/javascript-cryptography/)), but I think we should get out of this "javascript crypto is evil" mindset, and start talking about how we can make it possible.
It's not a "javascript crypto is evil" mindset, it's a "Good crypto is bad if implemented poorly" mindset.
Because node.js
Nice work. The interface is a little awkward even if it's quite attractive; not seeing a target when you start a drag is the problem. I don't even know that I'm *supposed* to drag until I fail a few times at trying to click. The animations are well done, but don't let style override functionality.
I'm using Chrome, and I can't figure out what I am supposed to be doing. Sometimes a set of arithmetic symbols appear, and if I try to click on them they disappear... EDIT: I think I found my problem, I think your system disagrees with the reddit chrome "top toolbar" extension thingy. When I close that, clicking behaves.
Click on a number and drag to the quadrant of the arithmetic expression you want to use. I know it's kind of clumsy. :-/ I tried to make it as fast as possible for extreme-speed playing (the way we tend to play it in my family), but I guess that comes at the cost of understandability...
Ooh, good call. Changed so that the target darkens right when you click. Maybe I'll change it so that if the user doesn't drag before releasing the click, it keeps the floating operations active until the next click. Think that would be more intuitive? Thanks tons for the input! :D
no sir, i don't like it
Instructions, please? Also, why is there a timer counting *down*?
How what do I click when where wtf?
We really needed a tool to make JS Unit Testing easy. This tool does it.
The two aren't really that comparable. One is a graphical engine and media platform, while one is a scripting library. I'm not sure what the point of this assertion is.
Also, based on the [same source](http://httparchive.org/interesting.php), jQuery is close to overtaking Apache too, and it has already zipped by the JPEG image format! Truly an exciting time for jQuery!
A thing we like has a bigger number than a thing we hate! Take THAT, other thing!
&gt;“Developers are choosing jQuery over Flash for new development” Ah, the tried and true practice of using Flash to select a couple elements from the DOM and apply a nifty style to them. We've all seen that, right? But no longer! Flash is dead! 2011 is the year of the JQuery desktop!
The point is to further rile the herd of HTML5 zealots against the evil supervillain Adobe and its money-grubbing, iPod-hating, proprietary multimedia platform. Which just so happens to be developed under duress by sweatshop workers in Tailand, and every time you download a swf it releases greenhouse gasses into the atmosphere, and it was partially responsible for 9-11. And well, its just... like, really lame. Real developers use jQuery to make banner ads. Oh and it kills puppies. Did I mention greenhouse gasses? 
was it the google closure library? http://code.google.com/p/closure-library/
I must be going blind because all I see is the response size comparison between "javascript" and jpegs. Where did you find what you said you did?
In other news, HTML is blowing up. It's on websites everywhere! We've got &lt;body&gt; tags up in this bitch!
I didn't. I deliberately misread several unrelated charts on that page, in much the same way the author of this post did. He picked a number from a chart listing JS frameworks usage per site and put it side by side with another number from an unrelated chart listing usage of flash per page. My own inane comparisons were done by grabbing a number from the pie chart labelled "Image Format", and another number from the "Most Common Server" pie chart. I'm going to go pray to the Altar of Souders for penance now. 
On the whole I've found jQuery to be a pretty good operating system, but it needs better support for JavaScript.
I agree that their sample app is a pretty poor implementation with regards to login, but don't throw the single page app paradigm out just because of 1 lousy example. There are plenty of single page apps that [get things right](http://www.rdio.com), they just require some intelligent design and thinking about the user experience. Something which Google sorely lacks IMHO.
love it! i actually had a similar concept a couple of months ago wherein users would be able to throw video's around against each other to discover music. i am not good enough with javascript yet to pull it off though(hopefully after i finish learning python). this is wonderful work though! keep up the good work, gonna follow on github!
This is a wonderful site. I have no doubt this will become the modern NeHe.
Code at 39:39... why does it start with this nonsense? Math.floor(Math.random()*2147483648).toString(36);
Added instructions at the bottom. The timer counting down is because there's a one-minute limit for each level (difficulties vary enough that keeping track of your best time for a puzzle is pretty meaningless once you get one that consists of 2, 1, 1, 12.) Thanks for the feedback, it really is useful!
how: by pressing the mouse button. what: the number. and then release on the operation. and then the other number. when: when you know what to do. where: see what. wtf: the fuck is not implemented in this game yet (seriously though, thanks for letting me know it was confusing. note to self: "mom can figure it out without instructions" means nothing when your mom has a degree in CS.)
Yup, that sounds like it would work wonderfully! Makes more sense to me.
Um... jQuery and Flash have two COMPLETELY different uses. This is just showing that people are getting lazier with their object selection (raises hand) and moving away from flash based sites (makes me happy inside).
No but this is great, thanks for the link! It was [Chosen](http://harvesthq.github.com/chosen/).
sounds like you might be after [Chosen](http://harvesthq.github.com/chosen/)?
&gt;jQuery code is still JavaScript; Coffeescript code isn't I don't think that's a meaningful distinction to make. The point I was making is that libraries and Coffee-script operate via different channels for different reasons... libraries within the semantics of the language, and Coffeescript augmenting the semantics of the language...mentioning that jQuery is Javascript code is just a tautology and doesn't make any sort of point without saying *why* that is an advantage. The point is one of the criticisms leveled was that it hides some things from devs...libraries also share this problem so they don't really represent a complete solution like suggested. The fact thatcode written using jQuery is technically Javascript does not change this. As I said, the only reason that would matter is if it somehow was a benefit itself, but I find that idea a rather weak argument. Libraries like jQuery have many of the same drawbacks as Coffeescript despite the fact that it is Javascript code. - Developers have to be familiar with it - It introduces complications in debugging - Etc. Again, it's also extremely important to consider that they solve slightly different problems...so it's more complex than a straight forward comparison of their problems. &gt;. I'm sure Coffeescript might have it's own niche place but definitely not in a project where a bunch of folks know Coffeescript and others don' You're basically proving my point right here, because *the exact same thing is true of jQuery* ....the people on your team need to be familiar with it to use it...and the fact that it is a library does not change this the tiniest bit...and does not make jQuery any easier to learn ipso facto. jQuery technically being a library doesn't provide any benefit here...except maybe you have less chance of making a syntax error, but that's offset by the increased likelihood of making a run-time error due to not understanding the library. The problem is I think people are making a stacked comparison: They say "You can just use X library", but then they don't take into account that you can't compare how it works for someone who doesn't know Coffeescript vs someone who DOES know X library. If you do an objective comparison of how it will work in comprable situations what you come up with is: - They both share many similar drawbacks - These drawbacks manifest in slightly different ways; this is because they do not solve all of the same problems. Coffee-script is ultimately JavaScript with some minor (but powerful) alterations...any **competent** JavaScript dev can learn Coffee-script in **at least** as long as it would take someone to familiarize themselves with jQuery...if not less. I would argue that jQuery introduces many more concepts than Coffee-script does. If you are familiar with Javascript, particularly 1.8, es5, and various future possible additions....then you already know most of Coffee-script. It's just a question of acclimating to the syntax and the increased expressiveness. Whereas jQuery brings it's own large set of ideas to learn.... If we were talking about something like ClojureScript...I would say this is a much more valid point however. Obviously it's my opinion that all these drawbacks are not enough of a problem to prevent choosing **either** a library or CoffeeScript....but my point is you can't bring up these issues in one without also bringing them up in the other. Libraries and Coffee-script have some overlap in goals, but they ultimately serve different purposes. Furthermore, they share some of the exact same drawbacks....so to say "Don't use CoffeeScript, just use a library" is not an entirely valid proposition. It's not a question of which one has less issues objectively, it's a question of which one fits your needs. For statements **are** error prone in JavaScript. It's a particularly easy spot to forget a "var", you have to remember to use the proper bounding logic, if it's a for-in you have to remember to filter out prototype properties....and lots of things that are easy to miss. These are not huge hurdles obviously, in fact they are rather minor, but it's unfortunate we have to navigate them for something as simple as "Loop through all the items in this collection" which should be something built into the semantics of a high level and dynamic language. It's not a big deal really to use a match to light a cigarette, but still lighters have become more popular because even though it's a minor effort....why go through it when you don't have to? The fact that one particular benefit CS provides is minor is deceiving... The idea is you get a collection of powerful additions and you pay a price that is similar to what you pay for most libraries. You can use options like Array.map, etc ...and those are very good.... but they introduce a run-time penalty and possibly extra run-time dependencies... not to mention they can be less expressive. My comment is a direct response to the comment I am responding to. They made a good point that libraries are another option, but I think it's very important to make clear that **whichever one you choose** is going to have some benefits and some drawbacks, and it's a question of objectively weighing those for your particular case and make a decision.
I really think the interface needs work. My experience: Read the instructions. OK I get it. How do I choose operations? Let's click the arrow. Oh all the numbers have changed. Ok let's drag one of the number. Click and start dragging, oh the operations have appeared, ok let go. Oh I let go over the arrow, all the numbers have changed. Ok I think I know what to do now. Let's see. Oh this is easy 12x2. Why's it not accepted that? Oh I have to use *all* the numbers. Ok click the arrow let's try again. I think I can do this one, 8/4=2, 13-1=12, 12x2=24! So, I'll click the 8 and get a divide, oh it's only given me a plus. Oh I have to hold the click down, right and I drag to the divide symbol... oh I've run out of time. Then I gave up.
JavaScript and actionscript are cousins. Flash is much more than a graphics engine and media player even if that is all it is used for today.
I must have left my sense of humor back at home when I read that.
&gt; jQuery and Flash have two COMPLETELY different uses. Well, they *do* overlap a lot. When the end the end goal is a website with some animations and interactivity, they are two valid, pretty much mutually exclusive options.
Ah, okay. Shouldn't the timer reset to 60 when you start a new set of numbers?
I came here knowing that there would be jerks pointing, without even having read the linked page, that jQuery and Flash are different kind of things. I'm a little sad I was right.
Nice work! a bit confusing at the beginning, but really interesting and nicely animated.
Just curious, what kind of testing have you done on this? You're using goog.provide('Sylvester.Line'), but declaring Line() as a global variable rather than in the provided Sylvester namespace. So rather than: Line.prototype.dup = function () { You should be writing: Sylvester.Line.prototype.dup = function () {
Good point, I've thought about doing this. I think I was wanting it to not be too unfamiliar to existing Sylvester users, but I think to really Googlify it I should do as you mention. Testing is a little difficult with this being a library I didn't create myself, but I think it would give it a lot of value. My mind is spinning with projects on how to use the library currently at the moment. ;)
http://www.reddit.com/r/vimcommands/top/?sort=top&amp;t=all&amp;limit=1000 for the first 1000.
You're using the same id twice.
Yeah, I realize that. It was my understanding that by using the same ID, the click handler would be attached to all of those elements. So I can't say "for all divs with ID button, if clicked, change the background color of that div"?
In HTML, you can only have one element with any given ID. You should probably use classes instead.
Ding ding ding. edit: [corrected](http://jsbin.com/uqukaz)
... Haha, I was just wondering recently if there were actually any functionally difference between ID and class. I was thinking it was just convention to use each for readability etc... I didn't realize that the browser actually differentiated between them. Thanks!
IDs can only exist once. JS: Retrieving elements by their id is faster than any other option. (Rarely matters though.) HTML: IDs can be used for fragment links. E.g. if there is some heading with an id, you can jump straight to it by appending '#' + the id to the URL. CSS: Zero advantages. Just downsides.
Yep, that was a bug. Fixing right now! 
You only need to really use attr if you are working with strings and/or you know the data- element is likely to change on the fly after the page has loaded. Personally if I need to pass data in an element I will use the data- attribute and then use the jQuery.data() command to adjust/retrieve when necessary.
Does [this](http://jsbin.com/uxewuf/4/edit#javascript,html) help? Un-comment the border settings to see the layout of each element (or just use chrome -&gt; inspect element)
http://jqueryfordesigners.com/ http://bonsaiden.github.com/JavaScript-Garden/ http://www.ecmazing.com/blogs/ http://jsmentors.com/ http://blog.nakedjavascript.com/ http://learnjs.org/ http://badassjs.com/ http://planet-javascript.com/ http://eloquentjavascript.net/ http://www.quirksmode.org/ http://ajaxian.com/ http://domscripting.com/ http://www.howtocreate.co.uk/tutorials/javascript/important
[Let me google that for you.](http://lmgtfy.com/?q=javascript+for+programmers)
http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/
http://bonsaiden.github.com/JavaScript-Garden/
&gt; CSS: Zero advantages. Just downsides. FOOL! What if you want to style a specific element that should only happen once per page?
Try this: http://javascript.crockford.com/survey.html
Namespacing and testing framework added. I'll try to flesh out some tests when i'm bored. =)
I hacked together an encrypted bookmark thing once... it probably doesn't work anymore because the encryption library referenced github directly, I think... and it wasn't very pretty. but the idea was simple... you install it as a bookmarklet, you click it and it creates a bookmark to the current page, but instead of storing the URL directly, it encrypts it using a key you specify at that time. Then it wraps that up in a bookmarklet that asks you for the password to decrypt it. That way you click the generated bookmarklet later, type the right password, and voila, you go to the original webpage. It was a perfectly valid use of in-browser encryption in javascript...although it might not have been quite as simple as I said it was :P edit: https://github.com/jamon/bookrypt if you're interested in seeing it.
It's not good for the sake of replacing SSL... but there are other uses for it. Here's a hypothetical one, but there are probably better ones. 1. Users trust that a host page is not malicious, but the host page would like to provide for a means of allowing users to communicate with eachother through the host page, where the host page does not see the communication. I.e. the host page could if it were malicious, but the user trusts it not to be. 2. Similar scenario as #1, but with a real life scenario. What if the host specifically wanted to NOT be privy to the communication for the sake of plausible deniability. I.e. a torrent sharing site where groups of friends can participate or something.
({}).hasOwnProperty(obj, key) should also work if you're trying to avoid the assholes and is a bit shorter.
I personally **hate** the syntax as provided in your post, but I see it everywhere. It annoys me to no end because you are having to indent twice for the single for loop. Pragmatism should win out over people's philosophical arguments. for (var key in obj) { if(!obj.hasOwnProperty(key)) continue; /* your code */ } It's clear, concise, and doesn't make you indent your code an extra time.
As mentioned above... this is how I think of it. An ID is just like a unique identifier, like your passport or drivers license only identifies you. A class identifies a group of things - a group of students may all belong to a 'class' and another group may belong to a different 'class'.
The two tools I have experience with for web fucntional testing are watir and TestComplete. TestComplete allows Javascript but I personally prefer using Watir and Ruby. That might be because I spent 3-4 years doing ruby before javascript so am familiar with it. Just based on the people around me (and the few interviews I have had to sit in on) the best questions for candidates are functional test related questions. Someone with weak FT experience and knowledge is not going to get the job done well regardless of the tools they use. Our best guys will pick ur anything and be able to test well in short order, the weaker ones get tied up making crap that doesn't help testing in the slightest. Watir experience is fairly common among testers so finding someone with that skill set might be slightly easier. If you want to make sure they are really up the the task, asking them to crawl a website using it to steal data and print some results is a task that isn't too taxing to ask and will help show who's got it right away. I've been asking interns to search/crawl reddit (after logging in (sometimes)) for some keyword. Make sure they get how to select elements quickly (and not walk the dom from document) and see if they are keeping latency/error conditions in mind. I've found that over half the kids applying to our spots did the one page tutorial on watir and figure they can fake their way through it. Have also seen the reverse, amazing ruby developers that don't have any idea what functional testing is. We have a lot of people that don't understand the difference between functional and unit, when manual makes more sense, useful automation and reports gathering, anything really. It's too bad it's not taught more (at least in the schools here) in CS cirriculum. All of our developers that at least spent some time in testing are much better for it. Mostly it's obvious for our Delphi/C# guys but they get what the whole process is anyway. Best of luck. (shameless addition: I'm a javascript/ruby developer and tester looking for new work, heh)
http://jqueryfordesigners.com/ http://bonsaiden.github.com/JavaScript-Garden/ http://www.ecmazing.com/blogs/ http://jsmentors.com/ http://blog.nakedjavascript.com/ http://learnjs.org/ http://badassjs.com/ http://planet-javascript.com/ http://eloquentjavascript.net/ http://www.quirksmode.org/ http://ajaxian.com/ http://domscripting.com/ http://www.howtocreate.co.uk/tutorials/javascript/important 
I love this sub reddit 
Thumb up.
http://jsbin.com/uxewuf/8
Awesome question! If someone has time/interest, go ahead and expand the [beginner's resources](https://github.com/bebraw/jswiki/wiki/Beginner's-Resources) page at the [jswiki](https://github.com/bebraw/jswiki/wiki). I added a link to this thread there (lazy solution :) ).
Interesting tidbit -- the "name" attribute -- in the old days it was pretty much synonymous with ID to identify elements on the DOM. It was also used for anchors to create page bookmarks -- these days you use ID for both of those things, and name is used to identify form elements. Multiple elements can have the same name (i.e. radio buttons) and you can use document.getElementsByName to retrieve them (as opposed to getElementById which is singular).
Padding adds size between the normal box and its border -- i.e. if you have a box specified at 100px by 100px with 5px padding on all sides, you wind up with what appears to be a 110px by 110px box when adding in a border.... This has broken many-a layout: where the author specifies 100% width and then adds padding. If your really want to have vertical alignment within a block-level element, you should set the line-height to the height of your box -- the only problem is when your text goes over multiple lines.
where are you based?
Just go look at the jquery source.
docs.jquery.com is what you want ... However (pro tip), don't limit your knowledge to jQuery you'll soon discover that learning "pure" JavaScript is much better and will let you choose other libraries, jQuery is a great tool to manipulate the DOM, however it will not be the best thing when it comes to building a complex javascript web app.
Why do people call the user interface a chrome? This is new for me.
JavaScript: The Good Parts
The manual.
If you learn raw javascript and already can program, the jquery docs should be all you need to learn jquery.
Then I put it just once on a page. CSS does not enforce this.
I'd suggest you just jump into making stuff with one of the Google APIs, like Google Maps. There are tons of examples, third party libraries, and you can get into the finer details of events and writing HTML to the page.
I guess these are the best sites for JavaScript. http://www.codecademy.com/ https://developer.mozilla.org/en/JavaScript The best for jQuery is the [jQuery Website, which also has some nice links](http://docs.jquery.com/Tutorials).
And thank you for that link. I make a ton of web forms and this will prove very helpful.
I am in eastern Washington, which has proven to be really hard to find qualified testers here, even with two universities with decent CS programs. We've been lucky in that we have field offices so we have places other than here to draw talent from but our development to test ratio is still putting more and more stress on our group to hire almost everyone that applies to test, which is already lower. Talking testers into moving seems to be really hard for some reason, too.
I never really thought the splitting solution was so awful, but meh. 
Uses jQuery, but this pretty much wins hands-down if you need to do this kind of thing a bunch. https://github.com/allmarkedup/jQuery-URL-Parser
THIS! I've been a programmer for 15 years and this is by far the best book about Javascript I've read.
Solution: don't use query strings? I never really understood the need for these. There's always (?) another way to do it that isn't so god damned ugly.
I think there is a general shortage. The impression seems to exist that it is an inferior career to development. 
While you read it, just be sure to keep in mind that while Douglas Crockford (the author) appears to know everything, and he does know most things - he does not in fact know everything.
Ahh, this is awesome.
I didn't either, but a friend sent me this and now I don't know why I'd ever go back to splitting.
Meh. They're really about the same size and complexity, and I'd bet that splitting performs better than regular expressions. We'd need to benchmark it, though. The example given also forgets to undo URI encoding like `+` and `%20`, though I guess that's an easy fix. I also don't really like using `replace` when we're not *really* replacing anything, since it feels like that could trip up a new developer. But, hey! It all works, and modern browsers can definitely handle it, so I guess it all comes down to style. var query = {}, pairs = queryString.split("&amp;"), pair; for(var i = 0; i &lt; pairs.length; i++) { pair = pairs[i].split("="); query[pair[0]] = decodeURIComponent(pair[1]); }
For sure. I definitely had that opinion out of school, going into testing. I really only took it because I was having a kid, jobs,etc. all scared me. Then again, since I kinda fell into my position and took it seriously I find that I have a good deal of advancement possibility and demand for my skills. Being part of the group that's looking for good people now though, it really bums me out.
I do plenty of jQuery each day but when i wanted to improve i began to learn more about closures, advanced methods (binding/curry, etc...) and digging deep into the prototype/__proto__ area. Since then i've built many closures and simply wrap a simple jQuery custom function around my instances when i want to reuse my modules. Also get to learning how to extend the prototype for String/Function but never override the original methods unless you have a legitimate purpose... the more you tinker around how jQuery/MooTools/Prototype/Underscore (etc..) internals work, the easier everything else gets.
This is something you typically only do once when a page is loaded, and it's only likely to have a few name/value pairs, so benchmarking one vs the other is irrelevant
It's 5Kb... Quite large for a small job..
Yup! Precisely why I didn't bother :) 
Terrible interface, suggestion: Allow drag and drop between 4 numbers and have operations between them. Operations are changable. A op B op C op D = calculated number
Love the middle one! Small tip: Your clear() function would be much faster if you use fillRect(x, y, width, height) rather than doing it via a path. I see you're already aware of window.requestAnimationFrame(), which is great! The more people start using that, the less friction for moving to js/canvas banners instead of those pesky flash things. :)
https://raw.github.com/gist/992227/e230510e3d21073185983720ff934800fc40a36e/extract-url-params.js
But you've got better things to do. :)
Add the line... console.log(weirdPrivate_3); ...immediately after *Obj.bonus()* to see what you have done. The explanation is that weirdPrivate_3 is just a global variable. You could also type... console.log(window.weirdPrivate_3); ...and this will print the same value. The interpreter doesn't know which scope you want the variable placed (since you specify neither this.\* nor var \*) and so it climbs the scope chain looking for something named "weirdPrivate_3." When it gets to the root scope (window.* in your browser) and still doesn't find the variable, it assumes you wanted to create it and attaches the variable to the top-most scope (again window) making it global across the entire script.
Thank you for this. You were absolutely correct. I would have thought such a statement would have caused some sort of error, such as not having declared the variable in any sort of scope. In any case, thanks for the response!
When you assign to a variable not declared with the var keyword, you actually create a property on the global object (which is the same as the top-level scope and "window" in the browser). It will be accessible literally anywhere, it's not private at all. It's considered bad practice to use undeclared variables, and it's explicitly forbidden if you use JSLint or ES5 strict mode.
FYI, I did some performance tests relating to how vectors are represented in JavaScript. See [JsPerf](http://jsperf.com/typed-vector-vs-object-vector-math). The results do not favour Sylvester's array-based approach (in my version of Chrome). I would love to know why this is.
This wins for being far more readable.
If you want to have public and private parts to object literals then use Closure. Begin with "var Obj = function() {" then declare all the private variables and objects you want. then for the public parts wrap them within return {} . This will give everything inside the return statement access to the private vars but no outside access to any other script. Make sure you place (); at the end of Obj outside the final bracket unless you plan on creating new objects with the "new" operator. 
This feature has bitten many JavaScript developers in the ass, and it's being phased out. [If you put `"use strict";` at the top of a file or a function](http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/), newer browsers will stop you from doing that and a few other dangerous things.
You probably should chomp out possible anchor (#foo at the end) before figuring out the pairs. Given the ordering of the returned query doesn't matter, you could probably use something like "while(i--)" with proper init. No idea if that would yield any benefit except for being more terse, though.
Coming soon: MVC for CSS!
So tragedies get funnier the more time passes but are always funnier if more people died, but tragedies are not considered funny if it's been less than a decade since?
This is a really cool project. I agree with the author that it can be very tricky to differentiate between all these as so many are coming out so fast.
None.
I assume that the input here is already the proper query string. Thankfully, if we grab from `document.location.search` the anchor isn't attached, though we do need to remove the `?` at the front. 
I'm wanting to try out [JsDuck](https://github.com/senchalabs/jsduck). It's created by Sencha Labs and powers their [Ext Docs](http://docs.sencha.com/ext-js/4-0/#!/api).
Hi guys, January this year we created "cdnjs.com - the missing cdn". Since then we have acquired full sponsorship from CloudFlare.com who have stabilized the hosting infrastructure and reached new speeds Amazon S3 could not. Cdnjs has had measurable popularity and going into the new year we thought it's time to step it up a notch and host popular CSS snippets/frameworks. The idea itself is in a trial and once the community has spoken we will again make informed decisions on infrastructure if we are to go ahead. At the moment we are inviting anyone and everyone to contribute to the cdncss.com project. Simply create an issue or comment on issues that you think are important, if you have the time we would greatly appreciate populating the actual repository via a fork request.
In otherwords Crockford has very strict ideas behind best practices of developing JavaScript in a professional environment, most of which have very sound reasons behind them, and it makes the rockstars/ninjas that want to write clever**\*** or lazy code upset. ***\*** Clever being synonymous with unreadable and/or unmaintainable.*
I've had this idea *forever* after using cdnjs: "Why do I have to download 960gs? They need a cdnjs for this" Kudos!
Don't document in code. That's just my opinion, but it _never_ works for me. I always document separately. Especially with JavaScript, it's sometimes hard to define what is a "class", a "method" or a "static" function/variable. Plus, sometimes you want to document an API differently than it is structured in code. Extra pages (e.g. how-to's spanning multiple modules, and performance and integration tips) will most likely be a pain with auto-doc tools, too. I prefer Sphinx, and it works pretty well with JS documentation (though I wish you could format some parts a little differently; the args/params/retval section is a table, not a &lt;dl&gt;). 
Sounds like IEnumerable map -&gt; Select() take -&gt; Take() filter -&gt; Where()
Definitely some handy tools if you're doing some data-intensive work in JS. I wouldn't call it "extraordinary" by any means though. As the author even stated, these concepts have been around for awhile in other languages.
Prototype uses [PDoc](http://pdoc.org/), of course. We built our own because all other doc tools that existed at the time tried to make (faulty) inferences from static analysis of the JavaScript, or else were too JavaDoc-ish to stomach. PDoc doesn't look at the code at all, only your doc comments. But the comment syntax is intuitive enough that it looks like it was written for humans rather than a parser: /** * Element.Offset#relativeTo(offset) -&gt; Element.Offset * - offset (Element.Offset): Another offset to compare to. * * Returns a new [[Element.Offset]] with its origin at the given * `offset`. Useful for determining an element's distance from another * arbitrary element. **/ 
Waiting for the day Google analyzes millions of web pages to find popular code-based X library and start including it directly in the browser. You know, like they did for the new HTML5 elements. Really, why can't versions of jQuery (minimized, with a flag to use the non-min version for any debugging) be right in the browser? Especially with the move towards rapid-release/always up-to-date browsers. You can download all that shit in the background if need be.
Generation functions! I swear Javascript and Python are starting to look more and more alike.
Nice to have a library, though. However, I think I'll probably use ClojureScript if I need to do lots of functional programming.
Cool, but this seems poorly timed given we are about to get MediaStreams in browsers, which are actual streams of the more familiar IO / file kind.
It's a nice set of code examples for JavaScript, but from a pragmatic point of view, it feels like a solution looking for a problem. Most of the code examples given either don't occur in real life, or can already be trivially solved with existing methods. Are there any real, practical examples of real-life problems that this would solve?
freakin yes!
I wish I knew =) Even with float arrays the results favor objects. http://jsperf.com/typed-vector-vs-object-vector-math/2 Browser jit magic.
YUI Doc. It's alright.
All hail minor point releases!
I didn't even know 1.6.3 was out....
Is ClojureScript production ready yet?
They *are* in the browser, in the cache.
Good effort, but it seems like it'd be of little use in the real-world; I can't think of a single instance where if I needed to do mathematical programming I'd choose Javascript over a specialist subject. Secondly, this seems quite limiting, given that the benefits of functional programming are only provided for this one structure. I can't help but feel that you'd be better off using something like [underscore.js](http://documentcloud.github.com/underscore/) to provide functional programming techniques for all the existing datastructures in javascript.
To be fair, it was only released 10 days ago.
Exactly what I was thinking too, wonderful in theory, but I'd have liked to see some real-world applications
Well, I'm stuck at 1.6.1 until they fix the stop() animate method which is broken 1.6.2+. They don't plan on fixing it until 1.7.
For reals? I was having problems with that the other day and couldnt get it to work. NOW I UNDERSTAND
undefined in JavaScript isn't constant, but void(0) will always return undefined.
I wish the downvoters would be brave enough to comment why. I'm with you on this. FTA, he claims that only Scheme uses datastructures actually named "stream". Meanwhile, _streams_ are known in all sorts of contexts as input/output paradigms. I saw the title here and though it was genuinely going to be a JS lib for reading/writing output streams...
DZone =&gt; DownVote
Alternate title: _Why I jumped on the "Module" Bandwagon_
You might like [Uniform](http://uniformjs.com/)
How do you decide on version names, I work on Servercyde.com and we just push stuff, hmm maybe we should use the SVN revision count as the version number: "Version 573 Released!"
I'll wait till i can code in dQuery. Am I worried if it will kill my JS based [startup](http://servercyde.com) before it even begins? Nah.
Not gonna sign up to leave a comment on that site. Anyway, what's wrong with this? function Mammal(species, defining_characteristic) { this.print = function(){ return "Hello I'm a " +species + ". " + "I have " +defining_characteristic + "."; }; } Also, it's a bad practice to name non-constructor functions in UpperCamelCase. UpperCamelCase is the de-facto standard for indicating `new` needs to be used on the function (and you'll expect the invariant `(new Foo()) instanceof Foo` to be true).
I like your way better but I have a question. Is there any difference between what you did and: function Mammal(species, defining_characteristic) { return { print: function(){ return "Hello I'm a " +species + ". " + "I have " +defining_characteristic + "."; } }; } What's the difference between returning an object and changing the this pointer when defining constructors?
You're on the right track, here's some stuff to get you further: You need a for loop to loop through each word in split word. You need a function that when you pass it a word it will convert it into pig latin, then call this function in the loop. Then see what you can glue together from there. That should put you 90% of the way.
As I write, the `(new Foo()) instanceof Foo === true` invariant should (ideologically) be kept for constructor functions. With your example, that invariant is *not* kept; `(new Mammal(a, b)).__proto__ === ({ }).__proto__`. In addition, when just patching `this`, you can still use the object's prototype. The problems with this method are: * `m.print` cannot be overridden using prototypes. * `m.print.call(foo)` won't call `print` on `foo`. * `var x = m.print; x();` will call `print` on `m`, which often isn't expected for experienced JavaScript programmers. (The code looks wrong or suspicious.)
Fixed in ES5 strict mode. (function () { 'use strict'; undefined = 5; }()); TypeError: undefined is read-only With Firefox w/o 'use strict': alert(undefined=5); //5 - you can set it alert(undefined); //undefined - setting it to something else didn't actually work
The problem is that Douglas Crockford has deemed it bad so anyone who writes javascript has to do it his way. (sarcasm) Don't get me wrong he has some good ideas (JSON was a great idea) in this case using the prototype version actually makes for more readable code with everything being more compartmentalized. Calling: var cat = new Mammal('cat', 'has claws'); It way more ideal than calling var cat = Mammal(); cat.init('cat', 'has claws');
Thanks for the response! The prof told us it could be done from 1 line but he doesn't care how we get it though, he just mentioned it was doable in one line which I have been foolishly trying to emulate. Again, I thank you and will definitely hack at it tonight after work and see if I cannot get it through a string. As a side note again, I am 100% newbie with JS which is why I am more than a little distraught he started at the end of the book, but I do understand programming logic so I will try and build something from what you have given me!
Okay I'm usually a Python programmer, so you're going to have to explain what you expect on the last one.
Could it be done in one line? Probably, but: 1) It would be a pretty long line, and in terms of real world programming, would be discouraged as difficult to maintain. 2) IMHO it would be better to learn how to do it the long way, then learn how to condense it down to one line.
Wow! Fuckin' redditors... Never dreamed I'd get downvoted for a perfectly on-point post. Just in case people somehow thought I was being inaccurate, here is a link to the **Stream API**: http://www.whatwg.org/specs/web-apps/current-work/multipage/video-conferencing-and-peer-to-peer-communication.html#stream-api
Did you read the post? Alex Russell seems to agree with you, and he works on Chrome at Google.
Bandwagons &amp; pitchforks. Bandwagons &amp; pitchforks. 
Sometimes it seems like constructive criticism pisses people off more than pure rage. I commented on someone's soundcloud once, saying I really liked their song, except where the bass and vocals class. Their response (along with some of their friends) was to flame at me like mad, talk shit about my choice of nick, and then acknowledge that it wasn't mastered yet... I was like, damn, I said I liked your song, then I pointed out a problem that you admit is there... it's called fucking constructive criticism you dumb fucks. Quit being so touchy on the goddamned internet!
Sadly, [I know what you mean](http://www.reddit.com/r/javascript/comments/jwzb2/quick_simple_and_arguably_proper_ajax_without/c2g1ku2).
This is great! I was originally looking for [Chosen](http://harvesthq.github.com/chosen/) but this is awesome too, thanks!
Why not : var Mammal={ init:function(species, defining_characteristic) { this.species = species; this.defining_characteristic = defining_characteristic; }, print:function() { return "Hello I'm a " + this.species + ". " + "I have " + this.defining_characteristic + "." } } var cat={},dog={}; Mammal.init.call(cat,'Cat','claws'); Mammal.init.call(dog,'Dog','a wet nose'); alert(Mammal.print.call(cat)); alert(Mammal.print.call(dog)); 
I'm not so sure about that. Your first bullet is true, but the others are not. m.print.call(foo) will call the function print, with this set to foo. var x = m.print; x(); &lt;- 'this' will be set to window. No javascript programmer would be surprised by that.
Lol. "Cool lesson on REST bro."
I don't see the point of this. I think they should leave classes out, and a lot of the comments in there agreed, yet then the author leaves a comment saying that anyone mentioning "class" was missing the point. Ok, I thought the point was trying to improve Javascript. In many opinions (mine included), Javascript should not be changed at all unless to add additional interfaces e.g. binary data, sockets, stuff like that. The language syntax itself should be left alone. And did they fucking propose "-&gt;" for the new function syntax? That is the one thing that is actually more hideous than "function".
The thing is that *running* a regular expression is extremely fast, it is compiling that takes some time. There is no reason this solution couldn't just compile the regex once and reuse it. Then it should be pretty fast. Also, maybe one draw the the regex way is that it is more encapsulated than yours. But that could be fixed with a simple closure.
&gt; Worse than that, the script files are cached and won't get replaced when the user moves off 3G and back on to a decent ISP: in effect, T-Mobile has broken websites permanently," said the dev. A misleading description of how caches work, to say the least. &gt; The T-Mobile JavaScript comment-stripper appears to be searching for '/\*' and '\*/' and removing everything in between. So it breaks on var foo = "/\* hello \*/"; A ridiculously clumsy oversight, but worse, did they even test it on even a single real website? &gt; The apparent indeterministic nature of the bug – which attacks only occasionally – has made it harder to track down. This is giving the bug too much credit. It's a blatantly obvious blocking bug that should never have gotten through testing and into the wild.
 function initObj() { var privateVar1 = 10; return { publicVar1: 3, publicVar2: 6 } }; x = initObj(); There are of course other ways to make objects, using prototypes, etc. But regardless of how you do it, the way to get privates is exclusively by using a closure.
&gt; I don't see the point of this. I think they should leave classes out, and a lot of the comments in there agreed, yet then the author leaves a comment saying that anyone mentioning "class" was missing the point. No, he said anyone mentioning `class` without _reading [the proposal](http://wiki.ecmascript.org/doku.php?id=harmony:classes)_ is missing the point. Harmony classes aren't a new paradigm. They don't represent a shift away from prototypal inheritance or toward Java. The `class` keyword is designed to be a syntactic shortcut for the sorts of OO patterns that JavaScript developers use every single day. If you do `class Foo`, that `Foo` object will still have a prototype and still have late-binding `this` and everything. Anything you can do with the proposed `class` keyword is something you can already do in existing JS with more keystrokes. He's telling you to RTFA before you do the Chicken Little thing. In fairness, a lot of this information is communicated on the language-designer level rather than the everyday-web-developer level. As someone who belongs to the second group, it took a while for me to get familiar enough with the terminology and the tone. Even Brendan's blog posts are quite information-dense and intimidating. TC39 needs better developer relations. &gt; Javascript should not be changed at all unless to add additional interfaces e.g. binary data, sockets, stuff like that. The language syntax itself should be left alone. If you remember nothing else, remember this one thing: **JavaScript will evolve in backward-compatible fashion**. The syntax for existing things _will not change_. Additional syntax is being _added_ to the language where appropriate. If they introduce a new shorthand function syntax and you don't like it, don't use it.
I don't know. It still seems wrong. So what you're saying is the language will continue to grow, i.e. continuing to add new ways to do the same thing. I don't use Python on a daily basis, but one of the central design aspects of the language is that there should be exactly one way to do something, more just adds unnecessary complexity. (yeah yeah, list comprehensions are just loops). So maybe what you're saying is the author was the one missing the point. When I (and other commenters) say to leave out the class keyword, we know damn well it is just sugar and we don't like it. Just maybe.
This function is overly complicated. charAt and substring are definitely not needed as they use extra cycles and with substring you're assuming the word character length. As your learning, I'd suggest using [jsperf](http://jsperf.com). Make sure you're writing efficient and fast code. Your professor was also right about this being short enough for 1 line. See if you can make that happen while still making the code readable. var string = 'Hi my name is Sneakyfloormop', // Create your string, you can query a selector to get your string arr = string.split(' '); // Create an array of words from your string for(i = 0, c = arr.length; i &lt; c ; i++) { console.log(arr[i].toLowerCase().split('').reverse().join('') + 'ay';) } Iterate over each word in your for loop doing the following to each: * force lowercase characters to the word or you will end up with something like 'iHay' * create an array of each word for each character, e.g., 'hi' will become ['h', 'i'] * now with the previous array created, reverse the items: 'hi' =&gt; ['h', 'i'] =&gt; ['i', 'h'] * now with reversed items set above, merge the array into a string: ['i', 'h'] =&gt; 'ih' * while still iterating over each word, now add 'ay' to the end of your string: 'ih' =&gt; 'ihay'
Just sharing my experience: I program Javascript every single day and I rarely create classes. Lots and lots of module pattern, but if I have data it's usually just JSON. Complex composition scenarios aren't compelling to me either, I see this as a minor use case. I don't think class sugar will add much productivity to the language, and in fact think it may hinder it as it makes it easy to just use this class construct when not using it would be less complex. I feel a lot of people are already too eager to build their applications using classes in Javascript when many other patterns would be better suited. It will also be a target for newbies to get tripped up. The this keyword already gets a lot of shit for being broken (when in fact it's just different from other languages). Class sugar will be next.
&gt; I don't know. It still seems wrong. So what you're saying is the language will continue to grow, i.e. continuing to add new ways to do the same thing. Not _all_ new syntax will be like this. Most of new syntax comes with new features (like [modules](http://wiki.ecmascript.org/doku.php?id=harmony:modules_examples) or [weak maps](http://wiki.ecmascript.org/doku.php?id=harmony:modules_examples)). "Exactly one way to do it" is not one of my language design precepts, but I respect the way it's been done in Python. I just don't think it fits well into a JavaScript context. We've got an existing imperfect language and an obligation to preserve as much backcompat as possible. But JavaScript (as it exists now) makes the commonest use cases far harder than they need to be. Developers have been asking for shorter function syntax _for years_. It would be ridiculous not to grant their wishes. There are at least a dozen implementations of classical-ish inheritance schemes for JavaScript, and they're useful, and some of your favorite libraries are written atop them. It would be ridiculous not to pave that cowpath. &gt; When I (and other commenters) say to leave out the class keyword, we know damn well it is just sugar and we don't like it. Just maybe. That's fine. I don't want to put words in your mouth. But he was responding, in part, to a commenter who said: &gt; Leave classes the hell outta JavaScript. I wish people would understand that it doesn’t follow Classical inheritance. So there is no need to make it look like it does. JavaScript is Prototypal, which is awesomely powerful. If you take the time to learn how to use it. It's endlessly funny to see someone imply that _Alex Russell doesn't know enough about JavaScript_ to understand why prototypal inheritance is awesome. Alex Russell has written more JavaScript in his lifetime than I've written _English_ in mine, and as a reward he gets a bunch of patronizing drive-by commenters who spout Crockford talking points without understanding them. (Again, I'm not including you in this group. I'm explaining what his comment was rebutting.) Here's what makes prototypal inheritance awesome: it's flexible enough to support whatever OOP paradigm you can dream up. (For instance, you can implement classical inheritance within prototypal inheritance, but you can't do the reverse.) But even though JS lets us generate a new instance of _any_ function (so you can, for example, use an existing instance to make a new instance), nearly all of the JavaScript I've seen in the last decade prefers to make all instances originate from one special function. _That's classical inheritance._ Adding an _optional_ sugar for that pattern strikes me as the most reasonable thing TC39 could do.
For sure. That is exactly the problem. Because a lot of people implement something that is sort of like using classes, they want to add this keyword that is just a short cut for exactly *one* way of making something like classes. And that's just it, it is only *similar* to classes, making it even more confusing. You think people get confused about the **this** keyword because it doesn't work how they expect? Try adding a class keyword that doesn't really make classes. Edit: wow, that's what I get for skimming your last sentence, you said exactly what my last paragraph said :)
I don't understand the "class" bit... We have constructors and prototypes in Javascript rather than classes, so why not use "constructor" as the keyword rather than class? I do like the module proposal that the article links to. The two major asks I have off the top of my head would be: 1) a simple way to control property visibility on objects constructed from prototypes, and 2) an easier way to pre-load dependencies (such as the module fore-mentioned proposal).
That's all fine. I don't think Alex means to silence all criticism of classes; he just wants people to be informed about what they're criticizing, as you clearly are. But I'll throw in my two cents anyway: &gt; Complex composition scenarios aren't compelling to me either, I see this as a minor use case. Compared to the module pattern, classical inheritance is a minor use case, but then so is prototypal inheritance. People use JavaScript objects for namespacing far more than they do for inheritance. But that doesn't make it a niche use case. jQuery UI, Dojo, Prototype, Mootools… they all use classical inheritance to great effect. Even jQuery itself introduced the ability to subclass the `jQuery` object not too long ago. &gt; It will also be a target for newbies to get tripped up. [As Brendan points out](http://brendaneich.com/2011/08/my-txjs-talk-twitter-remix/), "this might confuse n00bs" is a meta-discussion. It's valid to worry about, but it's extremely hard to rebut with evidence (hmm, let me try to think like a n00b…) and shouldn't hold up efforts to solve the gripes of _existing_ JS developers.
Also, 3) a way to set values for prototype properties that are computed when instances are constructed, but using the prototype (maybe something like MyConstructor.prototype.myValue .= new Array(); ). I'd rather set up arrays and other objects at the prototyping stage rather than in the constructor itself. Not sure what to call this... deferred prototyping?
js fork in 3..2...1.
&gt; I don't understand the "class" bit... We have constructors and prototypes in Javascript rather than classes, so why not use "constructor" as the keyword rather than class? I don't know that there's any _official_ reason, but I can think of a few: 1. `constructor` isn't a reserved word in JavaScript. `class` is, and has been since nearly the beginning, along with a bunch of other Java keywords that have never been used. For backcompat reasons, it's better to use an existing reserved word than to introduce one that wasn't there before. (In ES3 it's valid to have a variable named `constructor`, but if `constructor` were a keyword that code would have to change. It's never been valid to have a variable named `class`.) 2. The pattern, as it's described, _is_ a class. It's an abstract object description whose only purpose is to generate instances of itself. 3. `class` is shorter. Keystrokes matter.
&gt; Compared to the module pattern, classical inheritance is a minor use case, but then so is prototypal inheritance. You're right that any kind of inheritance is a minor use case compared to module pattern, I didn't mean to contrast the two. But I don't think classical inheritance (creating a base class and child class, defining some constructors, setting up the inheritance relationship) is useful nearly as often as just using a simple prototype and Object.create or similar patterns. I don't think Dojo and JQuery UI use classical inheritance to great effect. I dislike how these libraries are designed, and I don't think they need to be as complicated as they are. With everyone using class because it saves typing, you'll end up with a lot of overly complicated designs. &gt; As Brendan points out, "this might confuse n00bs" is a meta-discussion. It's valid to worry about, but it's extremely hard to rebut with evidence (hmm, let me try to think like a n00b…) and shouldn't hold up efforts to solve the gripes of existing JS developers. I don't know why it's a meta-discussion. When considering a proposal, the obviousness of how it works is clearly important. Obviously it's a balancing act between making the language transparent and friendly for new developers and giving existing developers the power tools they need to be most productive. Here's what it comes down to I guess: class sugar is basically saying, are you creating objects? Then use a class because it looks like what you're used to and it takes the least amount of typing. Never mind that it might not behave you you expect and does a lot more than you need in a majority of cases. I KNOW you can still use the old patterns, but people won't. People love sugar. I certainly appreciate that sometimes classes are the right solution, and the class sugar will help a great deal in those situations in terms of amount of typing and clarity of implementation. I just don't think the trade offs are in favor of adding the sugar.
You had me at "the pattern, as it's described, is a class." I have so often explained to other developers that there are no classes in Javascript, but I see now that I was wrong! Doh.
Property visibility is handled by this proposal: http://wiki.ecmascript.org/doku.php?id=harmony:object_literals. I realllly hope the syntax changes substantially, though.
Can you give an example of what you mean?
Awesome!
&gt; Never mind that it might not behave you you expect and does a lot more than you need in a majority of cases. I KNOW you can still use the old patterns, but people won't. People love sugar. And here's why it's a meta-discussion: I disagree with all of this, and we have no way of knowing who is right. Obviously standards bodies take the learning curve into account when writing specs, but if you're working on a feature and you can't come to consensus on what's n00b-friendly and what's not, you've got to set it aside. One person's hunch against another's does not equal an impasse.
&gt;He's telling you to RTFA before you do the Chicken Little thing. Downvoted for being a fat cunt
My short version would use regular expressions, but I suppose that's a bit out of this submission's scope: "Hi my name is Sneakyfloormop".replace(/(\w)(\w+)/g, function(word, firstLetter, theRest) { return (theRest + firstLetter).toLowerCase() + "ay"; }); Definitely much clearer to me.
Every time you instantiate Mammal, the print function will be recreated. That's probably not what you want. So, Mammal.prototype.print = function() { ... };
Just to clear something up: void isn't a function. It's an operator. void(0) works because (0) is the expression being evaluated.
CoffeeScript's popularity is testament to people's willingness to employ sugar even when it's not necessary or even desirable :)
I guess you missed the point? The point is to encapsulate some variables (here, `species` and `defining_characteristic`) so they cannot be accessed from outside of the class (here, `Mammal`). How would you hide these variables (passed to the constructor) while maintaining a prototypal `print` function without requiring manual garbage collection (e.g. a separate map of `Mammal` instances to `species` and `defining_characteristic` values)?
 With the closure method: var cat = new Mammal('Cat', 'cute paws'); var dog = new Mammal('Dog', 'mad jaws'); cat.print.call(dog); // "Hello I'm a Cat. I have cute paws." With the prototypal method: var cat = new Mammal('Cat', 'cute paws'); var dog = new Mammal('Dog', 'mad jaws'); cat.print.call(dog); // "Hello I'm a Dog. I have mad jaws." I know that the `this` binding is correct. However, the closure is *not* rebound. That's what I mean to explain. Sorry if I wasn't clear.
If you want to get technical, this is really just how CSS selectors work. They evaluate right-to-left. The Sizzle engine takes advantage of document.querySelectorAll to achieve this.
Research "`this` binding in JavaScript". There are numerous articles explaining this part of the language (i.e. why `a = b.c; a()` is not identical to `b.c()`*). *For `b !== (function () { return this; }())` and not ES5 strict mode, if you want to be pedantic.
Why not use prototypes then? What's the advantage here?
Lol, believe it or not I came to this conclusion myself when I was making an IRC bot too XD. Was this: function reload() { var full = require.resolve(filename); if( full in require.cache ) delete require.cache[full]; Bot = require(filename); Bot.reloadFunction(reload); } EDIT: It might be interesting to compare and contrast certain methods. For instance my bot is a driver that runs off of a reloadable js file that contains and array of objects with functions in them. Stuff like var funcs = [ { //joined channel -------------------- on: 'joined', func: function() { this.say('%loli'); this.say('%value'); } }, { //inventory --------------------- on: 'notice', equals: { to: me }, match: { notice: /^Hello/ }, func: function(from, to, msg) { // } } ];
derp.
Was it this: http://fiddle.jshell.net/FS34t/3/show/ Also, there are expanding grid plugins, like: http://demos.zulius.com/jquery/peepshow/ http://charlesmarshall.co.uk/jquery/2009/08/02/expanding-grid.html
Maybe [Isotope?](http://isotope.metafizzy.co/)
Passing messages to objects without boring with new operator, prototypes, encapsulation, nor java-like class emulation.
See this comment: http://www.reddit.com/r/programming/comments/kcxbr/sockjs_websocket_emulation_done_right/c2jb41v
I think with your last quote he meant that it's really hard for a webdev to track this down. Imagine just getting this: "Website doesn't work" and upon further questions you may be told that it's from a mobile device, but that may be all the info you can get.
I feel like I've just gone back in time 5 years
Are you saying I'm reinventing the wheel?
hahahaha! +1 What the...seriously, he discovered object properties?! What's the point of the article anyway? Because either I'm too blind to get it or the post is extraordinarily self-evident.
I probably approached the post in the wrong direction. I'm totally aware that there are application that are using this method. I think Twitter is using it and other web application. My point was raise the awareness, this method is super easy to implement saves web traffic and can help improve the UX.
I'm just saying that most modern websites have been storing/transmitting data in JSON for a long time. As a developer, I've been using JSON for about 5 years, and have read hundreds of blog entries on the subject, so I'm really not sure what the point of your article is. As for your JS library, I honestly can't see what it does besides provide a wrapper for stringify and localStorage stuff, of which there are plenty of libraries that will do that anyway. Getters/setters of properties are 1 line-of-code commands in JavaScript anyway, so I don't see the point of wrapping it up in your library. When your 'library' is just a wrapper for calling other libraries but just in your own vocabulary, I'd be questioning what benefit it really has.
 The purpose of "o - library" is simply to gather some useful methods for Object manipulation. I did for my personal use and later decided to make it public. Why I did it, because I needed to organize my code into library to simplify my code organization. Naturally everything can be hand coded, but it is a question of preference.
It's curious to note that this actually performed significantly better in canvas than WebGL on my work laptop (shitty on-board video but a decent processor). I guess there's no speed considerations when rendering on the GPU vs CPU, it just blindly does it. Something worth noting if you need to target a mass audience.
The main differences between SockJS and Socket.io: * The protocol is simple, the intention is to make it very easy to create alternative server implementations - you should be able to use SockJS with any language on the server side ("polyglot" is the new buzzword :P). * The API's are simple - very close to WebSocket API. You will be able to upgrade from SockJS to native WebSockets when they're ready. * There are some technical low-level differences: cross-domain handling, cookies, misbehaving proxy detection etc. 
This is an example of why important functionality of your website should not rely on JavaScript. Edit: Anyone willing to explain the downvotes?
I don't think so, but at this rate it probably will be by the time I need to do some serious JS.
tldr: x mod y != x rem y when x &lt; 0
Sure! function City() {} City.prototype.people = []; var seattle = new City(); var bellevue = new City(); // both seattle and bellevue share the same people array This is a bit frustrating to me. I can declare the people array instead in the City constructor, but I'd rather keep it on the prototype in some situations. I think it would be cool if we could set a prototype property every time an instance is created: function City() {} City.prototype.people .= []; // the JS engine doesn't set the value of "people" on the prototype immediately. instead, it waits until instances of City are created and sets up "people" arrays on the constructed object.
In your second example, every city will still share the same people array, it's just that it will get reset to an empty array with every new city you create. Initializing a property on the prototype later doesn't change that the same prototype object is shared among all cities.
If your browser supports hardware accelerated canvas draws it might be faster, but for most people canvas will be slower than WebGL. I've tested both and I find that the WebGL implementation might be a bit lacking, but for a beta it's very good.
Yes, and % != mod
i suppose its a copy from the middle of some code so an equals sign before and some logic after the whole snippet makes sense. in fact a search brought me to this thing: "ga="closure_uid_"+Math.floor(Math.random()*2147483648).toString(36)" http://www.google.co.il/search?q=Math.floor(Math.random()*2147483648).toString(36)%3B
uhm...I re-read your article again and read your comments here but still failing to see your point :/ At the beginning you make a list of various advantages, but then you don't expand on the subject, don't show exactly what you intend to talk about... (a list would be of better use as a final summary,but everyone has his style). Nonetheless, you don't show even half line of code to show your point, so one has to open the demo and dig through the source; I did that and still was left clueless... :| Now, let me clarify: I understand that you know this is nothing new but...what was that you wanted to point out? That you can use an object to store data?! Oh wow...guess what? That's what js objects are for! Act as a data dictionary/hashmap/whatever you prefer to call it! Again: am I missing something? :D
&gt; encapsulation Where? `cat.species` is still accessible to anyone. The article provides a method of encapsulating this access away to only the methods which are supposed to have it (the constructor and `print`).
I hear you. You are right, I should have some code added to make things clear. The point of the article is awareness, I think there are few applications that actually using Objects for temporary data storage ... I could be mistaken. I was hoping that people will share their experience and concerns about this approach. Like security issues, how you sink data from the server with the local data ... 
there are objects in JavaScript?! /mindblown
Looks great, how does it run on android/ios browsers? What is the underlying drawing?
I'm working on a WebGL only sprite graphics library: https://github.com/richardanaya/Juniper You might find the code interesting. 
A few of the Demo's seem to run really good. 
1) use document.getElementById('my_checkbox_id').checked 2) stop using the == true bullshit. 3) use visible = true or false. = is for assignment, == is for testing equality
And this is why people who remember this shit get paid more than you.
Do you have any details on how the framework do the drawing? Especially the map thing?
Thanks! Why on #2? Wrong ==/= sign there? Doesn't work with the .checked thing? 
The 'checked' property returns true or false depending on the state of the object. You should simply be able to use: if(document.getElementById('my_checkbox_id').checked) { // code to execute } Depending on the value of the checked property the if statement will evaluate without needing to define whether you're checking for true or not. As a test run the following examples in an HTML file: if (true) { document.write("test true"); } // works if (false) { document.write("test false"); } // nothing This occurs because the if statement is attempting to evaluate if something is true. So placing a boolean of true works. But placing a boolean of false doesn't because false cannot be true. Of course if you use a NOT modifier on a false value it will evaluate to true: if (!false) { document.write("test NOT false"); } The code OP is talking about is merely pointing to the variable and letting it's state evaluate within the if statement. Much like these examples.
Could this work with the App Engine Channel API?
x == true should just be x x != true should just be !x x == false should just be !x x != false should just be x
I'm trying Alexa The Allegator, and currently Opera is using 170% CPU on my machine. EDIT: The TMW and melonJS tutorial work fine, though. EDIT: Spoke too soon. Arrows don't catch properly on the melonJS tutorial and instead scroll the page.
Looks good. How does it compare to impactjs?
&gt; How would you hide these variables (passed to the constructor) while maintaining a prototypal print function without requiring manual garbage collection (e.g. a separate map of Mammal instances to species and defining_characteristic values)? You wouldn't. The module pattern lets you hide information, but uses far more memory as a result — each instance uses a different version of the `print` function. If there are 1000 instances, 1000 `print` functions exist. If it were defined on the prototype, only one would exist no matter how many instances there were. (This means that the latter approach is more memory-efficient, but for most people that doesn't matter; it's not like you're going to create a thousand instances of something. But if a library like jQuery used the module pattern instead of prototypal inheritance, it'd have a huge effect on a page's memory footprint.) There's also the fact that if `print` exists on the prototype, I can redefine it later (or add a new method to the prototype) and have that method instantly exist on all instances of `Mammal`, even those already initialized. I use the module pattern when I'm making a singleton; otherwise I define methods on the prototype. To me, information hiding is nice, but ultimately YAGNI.
The problem with == true is it's just redundant. if(expression == true) is nearly identical to if(expression). As a somewhat side issue, if you want a bit of advice that will save you a lot of trouble, forget that == exists until you can understand exactly what it's doing and know you'll get predictable behavior. It's really only useful in niche situations.
Ah, that's some good stuff. I try to use it because I have to in C#, and I'm out of practice with both at this point.
I get it now. That logic is a tricky thing. :)
I know that. The article discussed encapsulation, not efficiency or overrideability. I suggested a (IMO) better alternative to the author's solution to the problem (encapsulation). Going back to using prototypes does not solve the problem the original author discussed (encapsulation).
Free jQuery &amp; jQuery UI eBook Update: http://www.heronote.com/files/jQuery.htm
Yeah, sorry. This thread has a lot of replies and I didn't realize what context I was in.
You might want to try using document.getElementById("radio-checkbox"); Then give the &lt;input&gt; element an id ("radio-checkbox" in this example) The question marks you are referring to would be the "name" attribute of the form element. 
The whole test and assign and branch is unnecessary. Set the value of `.visible` to the current value of `.checked`. function showHide() { document.getElementById('textAreaId').visible = document.getElementById('otherRef').checked; }
Actually, the whole comparison is unnecessary. Just assign to `.visible` the current value of `.checked`. [Here's how](http://www.reddit.com/r/javascript/comments/kfrsm/new_at_javascript_question_about_radio_boxes_and/c2jydru).
&gt; isNaN(parseFloat('a')) true &gt; isNaN(parseFloat('1')) false
 &lt;script language="javascript"&gt; //Validates for empty text boxes. function validateText() { if (document.getElementById("textbox1").value == "") { alert("Please enter a text. "); } else if (isNaN(document.getElementById("textbox1").value)) { alert("Invalid input; do not enter numbers1. "); } else if (document.getElementById("textbox2").value == "") { alert("Please enter a word to search in the text "); } else if (isNaN(document.getElementById("textbox2").value)) { alert("Invalid input; do not enter numbers. "); } return false; } &lt;/script&gt; Not sure what I am doing wrong here, can you help? can't get it to work for detecting the numbers in the text box. I'm validating a HTML form. 
I dig it. &gt; JavaScript is not the Assembly of the Web. It’s the C of the web. The to-JS languages are lining up to become the C++ of the web. Does this make jQuery the ANSI C standard?
 $('.numeric').keypress(function(){ if (!/[0-9]/.test(String.fromCharCode(e.which))) return false; }); ... &lt;input type="text" class="numeric" /&gt;
isNaN(parseFloat(document.getElementById("textbox1").value)) isNaN(parseFloat(document.getElementById("textbox2").value)) If you use else if would ignore the rest of your validation function validateText() { if (document.getElementById("textbox1").value == "") { alert("Please enter a text. "); return false; } if (isNaN(parseFloat(document.getElementById("textbox1").value))) { alert("Invalid input; do not enter numbers1. "); return false; } if (document.getElementById("textbox2").value == "") { alert("Please enter a word to search in the text "); return false; } if (isNaN(parseFloat(document.getElementById("textbox2").value))) { alert("Invalid input; do not enter numbers. "); return false; } return true; } On this new function would be invalid just when the if evaluation gets true and other case would return a true value as a valid input 
Since IsNaN only detects if the value is NOT a number, how would i write the code that when a number is detected it should alert that it would be a invalid input. edited to clarify. 
not to mention that prototypes are much more memory efficient than cloning every method in every object. you notice this in backbone if you are showing/hiding views and you have 100+ instances backbone will use *a lot* more memory and create more potential for memory leaks than spine (which uses prototypal inheritance and the 'evil' new) also every closure creates a whole new scope on the stack. if you have lots of them and lots of instances it could get noticable. this is where memory leaks come from since it can't work out if the variables inside the closure are still required. for eg. var Test = (function(boo, ye)) { var boo = boo; this.ye = ye; } var first = new Test; var second = new Test; first = undefined; second = null; do that a hundred times and workout if 'boo' and 'ye' inside the closure are ever released and garbage collected :) I get different results with different browsers (much more complicated real-world examples) but I can never seem to get the memory usage back down to a normal fresh instance, even with the latest chrome. if you are building larg-ish javascript apps you want prototypal inheritance and new, along with clean ways of releasing and re-allocating variables inside closures. especially if your javascript web app is long running (ie. like gmail, no page refresh for hours at a time)
Ah. Makes sense.
I've written a language that compiles to JS, and it _does_ generate different JavaScript for different browsers. This is done mostly for performance, but also to generate extra JS for features the browser doesn't support, to get around corner-case differences between JavaScript and JScript (yes, even with Chakra), and to take advantage of browser specific features. Although he is right; JavaScript is really being used as IL rather then assembly, I think he is mostly being pedantic about terminology. You also can't just disregard GWT as "not the norm in the to-JS world", when it's easily one of the most (if not _the_most) popular 'to-JS' compiler.
Reverse the if? Edit: As in: &gt; if (!isNaN(parseFloat('a'))) Would return false wheras: &gt; if (!isNaN(parseFloat('1'))) would return true.
thanks, exactly what I looking for. I'm not too bright in programming. 
Aw man, I missed the reply. :(
Who the hell has called JavaScript "web assembly?"
This seems more or less like a semantic argument. Maybe others interpreted "JavaScript is the assembly of the web" more literally than I did, but to me it just emphasizes the idea of JavaScript as a compilation target. If there really was confusion about this then I suppose this article is useful. Otherwise, it just seems nitpicky.
Never, ever heard anyone refer to Javascript as "web assembly".
what about 0.3? :) and when you add a "." to that, what about 3.0.0? :)
all of these techniques will return true for values like: * 1abcd * 0.3asdflkj * 0.2.1 because it will parse the number up front until it no longer parses as a float... "1abcd" =&gt; 1, "0.3asdflkj" =&gt; 0.3, etc. What degree of validation you want to do depends on the task at hand, but likely the best answer is to adopt a framework (like jquery or dojo) and if it has a mechanism for helping this, use it, otherwise find someone else's library that does this kind of validation. You could keep adding things like... if(parseFloat(VALUE).toString() === VALUE), but that has other problems, like not handling the various formats of numbers, since the toString will convert back to a different format than you started in, in some cases, and will result in rounding. It's a LOT harder problem to solve than it appears, and how correctly you need to solve it (how much work you should put into it) depends on why you're doing it.
Would this do? I'm on a mobile phone right now so I may be off. var val = document.getElementById("textbox1").value; if (+val != val) // not numeric
http://dl.dropbox.com/u/35146/js/tests/isNumber.html is a set of 30 unit tests and a list of a bunch of techniques for doing it. If you want to jump straight ahead to the simplest answer that passed his test cases, it is: !isNaN(parseFloat(VALUE)) &amp;&amp; isFinite(VALUE)
The argument I usually hear is that the browser is the new VM (which I believe is where he's inferring the web assembly bit).
http://lmgtfy.com/?q=javascript+is+assembly+language
I've just recently open sourced my Javascript MVC... it's not very well documented, but you can see it in action at http://sofea.net and you can see the source at http://github.com/jamon/SOFEA. As time permits, I might look into implementing this demo app :) Mine is significantly different from these in that the host page just fires off the framework, and navigation is managed using hash fragments... meaning linking works with "a href"'s back/forward work, and only the developer is in better control of the page. The demo uses closure templates as the templating implementation, but you could really use anything. Pages are lazy loaded (controllers, really, not pages) and their dependencies loaded with them, and there's probably other features that people might find interesting... it's really quite a bit more evolved than the ones I've seen out there, even if it's a tad bit rough around the edges :)
oh, one more note about it is that the purpose behind this is to be able to have more re-use in your application. You can build a web app using this, and embed it into an existing web app simply by including a js file and adding a couple of lines of JS (pointing it at the right div to embed itself into). Additionally, the concept behind it is that you write your application one time as services that are agnostic of the UI, and both your web ui and native mobile UIs or alternative web UIs can all call the same services.
I've heard this term more than web assembly as well.
He(she?) said something like "How can people remember stuff like that" then a mini rant.
Have you considered using making a JQuery UI widget wrapper for canvas and using it to manage game assets, drawing elements etc? Alternatively, backbone.js etc?
Start saying that all the time, let it catch on with the rest of the JavaScript world. Then a few months from now we'll see a reddit post: "JQuery is not the ANSI C standard of the web!"
ActionScript is the COBOL of the web. There. I said it.
well shit.. TIL.
I dont understand, am I missing something? The idea of using js objects as a means to storing data is part of the point of them.
at a glance, you're missing some semicolons on the ends of most lines, and you should wrap your ifs in parens: heads -= 6; if(heads &lt; 0){ also, correct link is: http://pastebin.com/jZSBQCm0
Thanks, but can you tell me how to find the minimum value from an array? 
 Math.min.apply(Math, myArray); will do the job
 Math.min(array) EDIT: downvoting because it's bullshit.
that doesn't work. The way that I posted does work. Your way doesn't work because Math.min returns the minimum value from its arguments. So Math.min(2,3,5,1,6); will return 1, but var a = [2,3,5,1,6]; Math.min(a); will return NaN - because Math.min was only given one argument. You need to call Math.min with n arguments, where n==array.length. The easiest way to do this is to use apply, which takes 2 arguments, the first is the context for the call (what 'this' should point to within the function call. In our case we don't want to mess with this so we pass Math itself in). The second argument is an array of arguments to pass. Thus: var a = [2,3,5,1,6]; Math.min.apply(Math, a); is equivalent to: Math.min(2,3,5,1,6);
He is absolutely right.
http://www.timeanddate.com/counters/customcount.html?p0=179 just put tomorrow at 00:00:00. and there you have a countdown to midnight EST (new york)! And kinda confusing what you mean by UTC as time source, doesnt matter what time zone you are in, it is still the same amount of time to midnight EST. Say its 15:00 here in Norway, which make is 15h to midnight in EST, if i live in China right now, it would still be 15h to midnight.
:) thanks
If the first part returns true, it executes that part, otherwise it defaults to the second part. MYAPP = MYAPP || {} //if MYAPP is not null, set it to my app, else set it to an empty object This would be the same as: if (!MYAPP){ MYAPP={}; }
Returning Inner simply outputs the variable itself, which is a function. To return the value, you need to call Inner();
You are on the right track here. When calling Outer("hello world") it's creating the Inner function, and closing the variables around it, so you get a function that is functionally function Inner() { alert("hello wolrd"); }. In order to see the magic, don't alert inner after the function, call it instead. function Outer(p) { var v = p; function Inner() { alert(v); } return Inner; } var TestInner = Outer('hello world!'); TestInner(); Think of a closure as a function factory, it's returning an entirely new function that has it's data set for it.
Specifically, the "*window.jQuery || ...*" part acts as a shortcut, which checks if jQuery already exists, and if it doesn't, outputs the script tag for it to be included. An alternative would be "if( ! window.jQuery ) document.write( ... )" The same thing is commonly used for setting default values for function arguments: function( one, two ) { one = one || 1; // Default value is 1 two = two || []; // Default value is an empty array }
That is not a bitwise or |, it is a logical or ||. This takes advantage of boolean logic. It does not evaluate the right side if the left side is "truthy". However, you are correct that it is shorthand for the ternary (?:). 
Is there a benefit of node.localName as opposed to node.tagName or node.nodeName?
I think the concept that you are missing here is that functions are variables too in JS. See: http://en.wikipedia.org/wiki/First-class_function So, Inner is the function itself, while Inner() is the value returned from calling the function.
Now the program runs without any errors but it gives the wrong answer :(
The "why" you'd do this, is to ensure the object/value is initialized, but don't overwrite it if it already is.
The &amp;&amp; and || operators return the value of the last operand they evaluated. They evaluate their left argument first, then their right. If the left side of || is truthy (not false, null, undefined, etc), then || returns that value and doesn't bother evaluating the right side. One truthy value is enough to make the whole statement true. Similarly, if the left side of &amp;&amp; is falsey (false, null, undefined, etc), then &amp;&amp; returns that value and doesn't evaluate the right side. One falsey value is enough to make the whole statement false. Using that behavior of || is handy for setting default values of objects when you're not sure whether something is defined: function foo(providedValue) { var obj = providedValue || 10; return obj + 1; } foo(5); // == 6 foo(null); // == 11 foo(); // == 11 foo(0); // == 11 -- be careful using this idiom! On the flip side, &amp;&amp; can substitute for a null check in some cases function bar(providedValue) { return providedValue &amp;&amp; providedValue.length; } bar([5, 6, 7]); // == 3 bar([]); // == 0 bar(null); /// == null. null.length would have thrown an exception bar(5); // == undefined bar(''); // '' -- again, be careful! Note that you can chain things together as well, so `a = b || c || d || e;` will set `a` to the first truthy value among b, c, d, and e. It's a nice concise way to describe things like default values, replacing checks for null/undefined. Just be aware that null/undefined aren't the only things that will evaluate to false (see examples above). The user may actually want to call your method with false, 0, '', or similar.
what is it supposed to be doing?
I've described the problem here- http://stackoverflow.com/questions/7403829/monster-heads-problem-in-python
Can you point me to some application that are using this approach?
Very nice explanation. [Related Wikipedia article](http://en.wikipedia.org/wiki/Short-circuit_evaluation) (deals with "short-circuit evaluation" but also makes note of _last value_ short circuiting).
You're returning a function here, Inner, not the variable v; a reference to Inner No surprise it's acting like this. What you see as text is just the implicit type coercion (conversion) from function to string that your console (firebug,shell,etc) is performing for you. [to be precise, the interpreter is executing Outer.toString() or Outer.toString()] Anyway, if you want to return the value of v from the closure, you have to use it like this: function Outer(p){ /* code */ } var inn = Outer(42); // now inn points to Inner, and the value 42 is being *closed over* inn(); // will alert 42, or log it or return it, depending on Inner's implementation It could have been written in a more compact way, but I preferred to show it step-by-step. Hope this helps you ;)
I guess it's a rite-of-passage that as soon as a new JS dev begins to grok closures, they feel the need to make a blog post over it. Personally, I consider `comp.lang.javascript`'s [notes on closures](http://jibbering.com/faq/notes/closures/) the definitive text; although other good texts exist, I think it's the most accurate and comprehensible collection of information on the subject. They also have a thread [Closures Explained](http://groups.google.com/group/comp.lang.javascript/browse_thread/thread/df602506ee48b400/e65e00f5cad07676?pli=1), which is also helpful for newcomers.
What you're doing here is returning a reference of the Inner function. If you output the return value from Outer to console.log or alert, it would automatically call toString on it, which is why you're seeing the function definition as a string. Since the Outer function is returning the Inner function, you would have to invoke the returned function to see the v value, Outer('hello world')(); 
You guys have all been a huge help, I've definitely got a better idea on how closures function at this point. However, I'm still having an issue, but I think it's more with my implementation of the closure than the closure itself. Currently, I'm using it in this block of code: for (var j=1; j &lt; 13; j++) { var jCurrent = jOuter(j); links[j].onclick = function() { showOverlay(); showImage(jCurrent()); return false; } } function jOuter(jHold) { return function() { return jHold; }; } jOuter is still my closure function, I was able to trim it down a bit from the one I was using. What I'm trying to do is assign an onClick handler to 12 images in an image gallery, which causes the screen to dim (showOverlay), the image to appear (showImage), and causes the link not to execute as it normally would (return false). While it's assigning the handler to all 12 images, it's still using the final value of j, as opposed to the current value when the loop executes. Any insight is greatly appreciated!
I suggest looking at this page for all the fun little JS details. :) http://bonsaiden.github.com/JavaScript-Garden/ To go through it step by step on what's happening, - The loops iterates 12 times assigning the handler to each element - When the loop is done, jCurrent's value is jOuter(12) - When onclick happens, it looks for jCurrent in the local scope, but doesn't find it, so it goes up the scope chain to look for it - When its found, jCurrent's value is jOuter(12) A common way to get around this is, for (var j=1; j &lt; 13; j++) { (function (jCurrent) { links[j].onclick = function() { showOverlay(); showImage(jCurrent()); return false; } })(jOuter(j)); }
It worked! Thank you so much, that was exactly what I needed.
To be clear here, it will set MYAPP to {}, not only if MYAPP is null, but if it is any falsy value. That means values of 0 and "" (empty string).
also undefined, null and NaN. edit: is it downvote-the-right-answer day in /r/javascript or something? undefined, null and NaN are falsy values. So &gt; That means values of 0 and "" (empty string). also undefined, null and NaN.
Also, you don't need that var v = p; you can just use p directly in the alert.
extra bytes, over time that could add up to kilobytes of data. i would also suggest using camelCase to make the variables and functions more readable.
I think I mentioned this elsewhere in the thread. `localName` works better with XML (e.g. MathML, SVG). `tagName` looks lame, and I don't know about `nodeName`. Just pick one which works, right? ;P
nope, only on typing time and mantainability :) (what's readable for you might not be for others)
When looking at style, never think about performance, and vice versa. I think your style is fine. I would prefer a better indication of where one word ends and another starts (it'ssometimeshardtoreadreallylongstringswithoutwordseparationinEnglish).Typically, people use underscores (`_`) or camelCasing: `find_left_position` and `positionOfNavigationDiv` (or `positionOfNavigationDIV`), respectively.
 function findLeftPos(navDiv) { var navDivPos = $(navDiv).css('left'); }
Rather than inventing your own style "because you can", why not rely on the opinions of experts you can trust? Google publishes a [Javascript code style guide](http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml). It's not very long, and it's not very complicated. It's easy to comply to the conventions they lay out. What they say is: function findLeftPosition(navigationDiv){ var positionOfNavigationDiv = $(navigationDiv).css('left'); } Most JS coders would probably use shorter variable names, just for visual economy. like this: function findLeftPosn(div){ var divPosn = $(div).css('left'); } The reason you want to use a common style is twofold: it allows your eyes to be comfortable reading code from other people, and it allows other people to more easily read your code. You might also look into using JSHint , which is a free, community-driven JS code linter. it can make suggestions about your code, including style suggestions, involving, I think, variable names, function names, code formatting, and so on. 
I commonly use something like this when I can't be sure that someObj exists and that if it does exist that it has someAttribute. if (someObj &amp;&amp; someObj.someAttribute &amp;&amp; someObj.someAttribute != someVal) { // some code using someObj.someAttribute } 
everythinglowercaseandalsonotusinganyunderscoresmakesitkindahardtoreadbutimsureyouvealreadynoticedthat
I used to do this, but then I can never remember if I've abbreviated a word or not - is it navDivPos or navDivPosition? or navigationDivPos? The only thing I'd change in OP's code is to put it in camelCase and indent (which I assume is just a markdown fail): function findLeftPosition(navigationDiv) { var positionOfNavigationDiv = $(navigationDiv).css('left'); }
The variable name `navigationdiv` creates an unnecessary weak cohesion with `findleftposition`. Why should `findleftposition` only be used for navigation divs? It's a general purpose function that can be used for any element, so don't constrain it needlessly. That said, I would call it: function getLeftPos(el) { return $(el).css('left'); } Edit: This function is a getter, not a finder. Find is usually reserved for searching/traversing.
Wouldn't this be the same as var MYAPP = (MYAPP) ? MYAPP : {};
The first thing I'd query is why would you write this particular function? If I have a function that is one line long it usually means I'm overly complicating things. var myLeftPos = findleftposition('.myDiv'); is the same as var myLeftPos = $('.myDiv').css('left'); One doesn't gain anything from making this particular situation a function but you will pay a penalty for the function call (albeit negligible unless you're calling it thousands of times per second). Oh, and try not to make things global. It can byte (pun intended) you later on when something get's overwritten. e.g: var myFunctions = { findleftposition: function(selector) { return $(selector).css('left'); } } Others commented on _ and camelCase to make names more readable (my preference). Whatever style you end up with PLEASE don't make it the kind where you do things like this: var nvgtn = xxxx as opposed to var navigation = xxxx; Removing vowels actually makes it harder to type as you have to think about not putting the vowels in.
Shoot, did I call it `findLeftPosition` or `getLeftPosition`? Hmm, must be a `get` since I probably also made a `setLeftPosition`. Dang, did I call that one `assignLeftPosition`? Edit: This function is a getter, not a finder. Find is usually reserved for searching/traversing.
I would use the [revealing module pattern](http://www.alexanderdickson.com/articles/jquery-javascript/a-new-way-of-creating-objects-in-javascript/) and get rid of all the references to 'this' in the code where you don't actually need them. It's a nice way of encapsulating code and not polluting the global namespace. Other than that, you might gain something by separating the model from the view and controller aspects.
the sample function is an example to display style, nothing more.
That makes two of us, this is why I usually spell things out...
yep. i usually camelCase ninjaEdit
I do, periodically, check my code w/ [JSlint](http://www.jslint.com/) and it always comes back clean. Was more concerned with potential performance hits from long(er) var and function names. 
yep, good point.
yes, only 13 characters shorter.
To actually answer your question, there is a very slight decrease in performance when using large names for everything because the script engine has to process more bytes to understand your program. This is fairly minimal, and is completely negated by minification in production anyway, so it's not worth worrying about. You should definitely camel case, but otherwise I'm a big fan of long expressive variable names. Abbreviations usually cause more confusion than they're worth.
default value when undefined...
And, arguably, more readable.
i appreciate what the author is trying to do - that is, thoroughly teach javascript - but frankly i find this author's information density to be far too low. the 140 character approach should be applied a lot more.
Yes. What you have is not what most would consider _readable_, I don't believe. dothislooklikeaveryreadablepieceoftexttoyouordoyouagreethatitisvirtuallyimpossibletoread? Learn to name your identifiers (variables) in a standard way: camelCase, PascalCase, unix_style, or whatever.....but not all-lowercase &amp; lacking underscores. You also need to learn how to indent properly.
Truer words were never spoken. Especially since I usually end up maintaining my own code and I *do* know where I live...
Extra bytes shouldn't matter in source. If you are concerned about bandwidth, you should be using a javascript compressor when you deploy.
In terms of JQuery that particular snippet checks to see if JQuery exists, if not then load it from a local file. The reason they put this in is because in html5 boilerplate the default is to reference JQuery from a CDN (content delivery network), I believe it's google. So an html5 boilterplate project will try to load jquery from google's server (faster, cached and often a great idea), but IF it fails you load a local copy stored on your server.
Well, those files don't exist. By the way, the current version of jQuery is 1.6.4. Something like 6.1.2 doesn't exist. "qm.js" does exist though. Are your scripts in the same directory as that file?
Did you upload the js files to the web server as well? Because I get 404 errors trying to reach them. And I doubt you're living in the future, so perhaps your jquery should be 1.6.2.js. Also, spaces in script filename are usually frowned upon. Try renaming your files to jquery_*.js.
You haven't uploaded them; http://www.hebetsmccallin.com/jquery 6.1.2.js takes you to 404.html Upload the files, you should be fine. Though personally I dislike spaces in URLs (for exactly the reason you see above with the fact that reddit doesn't process the URL properly - having spaces in URLs breaks things), use a hyphen instead, or even better load jQuery from google's CDN.
Yes, but more specifically and to cause less confusion: x mod y != x rem y when x &lt; 0
do javascript compressors rename variables and functions before deployment?
This headline is much better if you just glance at the second half...
"it executes that part" is an incredibly inaccurate way of saying "the expression evaluates to that part"...
Then, why didn't you here?
I really need to get on learning Three. Thanks for this!
meh. was writing a function off the top of my head... 
Yes, the compressors shrink and obfuscate the code (so nobody can copy/steal it). You keep your original source code but when you deploy for live use you just compress it. As for JavaScript file size affecting performance, only in a very very minimal way. The browser still has to download the code, so the longer it is the more time it will take, but obviously speeds are so fast having a few extra underscores in your code will be insignificant. The real performance issues have to do with what your code is actually doing (modifying the DOM, Ajax calls, etc.)
alternative: MYAPP || (MYAPP = {})
i understand that, i've just never seen one change both variables and function names to be compressed (a, b, etc.).
It’s common in Ruby as well, where there’s even a combined operator for it: `myapp ||= {}`
If you look at something like the JQuery minified code you'll see how it does that: http://code.jquery.com/jquery-1.6.4.min.js compare to http://code.jquery.com/jquery-1.6.4.js
Please don't post spam.
I would do it thus: var sum = 0; for (var i = 1; i &lt; 1000; i++) sum += (!(i % 3) || !(i % 5)) ? i : 0; document.write(sum);
It looks interesting thank you. I already had a look at the code.
Or in a way that lets the max be variable: var sum = function(x){var temp = 0; for (var i = 1; i &lt; x; i++) temp += (!(i % 3) || !(i % 5)) ? i : 0; return temp}; document.write(sum(1000));
Thanks - This is definitely more terse... shows me some The_Cleric juju, but not javascript ninjitsu, which is what I'm hoping to achieve in this post.
[whoopsLooksLikeIMessedThatOneUp](http://www.sadtrombone.com) 
Why create the isMod function? Is isMod(1241, 12); somehow better than 1241 % 12 == 0 ? What would you do if you saw someone else write: function addTwoNumbers(num1, num2) { return num1 + num2; }
Is that the best way to get that variable? Can't you just pass it from where it was clicked? Seems so much easier because you have the element at the time of the click
I found this to be a rather clear and helpful explanation, thanks!
Obfuscation is not a requirement, sure it saves some characters, but gzip saves a lot more, while still enabling easy production debugging. If you have proprietary and secret code or a huge client side codebase, obfuscate. But for simple sites? Navigation menus? Not worth the effort
I can think of a couple of workarounds, though I don't think they are necessarily better than what I am trying to do. One would be to just prebuild all the possible forms and forgo the ajax call. Another would be to just ditch the lightbox and open the form on the original page. Both of those require me to have markup for multiple forms, though, instead of just the one I populate with ajax. I had to modify prettyPhoto to even pass this information. If there is a better way to grab that id without causing event errors I'm all ears.
In most cases, you don't need your second guard here, unless you want to also make sure someVal is not undefined.
It sounded like he was asking more about the performance of the browser, i.e. does it take longer to parse or run it. I would say probably not, but I can also say GZip definitely has no effect on the answer to that question.
I set naming standards... navigation is always nav, no matter where it is leftNav, mainNav, etc. Pos is always position, etc. Stick to the same conventions every time and you'll never be lost. But I guess that doesn't help when viewing other people's code or vice versa.
I refactored it out afterwards on purpose to play around with passing a function as a parameter, which as a C# dev I think is cool as hell.
yup
It's a good thing I've just started learning it then.
Hey does this writing suck?: bldjbnbowngwegfweufe wegwegwe rrg ! Don't worry I usually write good English.
Not sure how cool this is, but it's a better way to use functions as objects, and keeps the running total out of the global space: filteredSum = function(count, filter) { var sum = 0; while (count-- &gt; 0) { if (filter(count)) { sum += count; } } return sum; } simpleFilter = function(x) { return x % 3 === 0 || x % 5 === 0 } filteredSum(1000, simpleFilter); Now, with the filter details fully embedded in a function, you can then use closures to create whole families of filters as needed: createFilterForModOfAnyOfList = function(vals) { return function(x) { for (var j = 0; j &lt; vals.length; j++) { if (x % vals[j] === 0) { return true; } } return false; } } filteredSum(1000, createFilterForModOfAnyOfList([3,5])); filteredSum(1000, createFilterForModOfAnyOfList([3,5,7])); 
&gt;unique to JavaScript (and other ECMAScript languages) I winced.
&gt; the compressors shrink and obfuscate the code (so nobody can copy/steal it). I wouldn't say this. With sites like [jsbeautifier](http://jsbeautifier.org/) around, reading minified javascript files becomes a lot easier. The point of minification is not to secure your script, but to reduce the file size.
But my gut tell me this... &amp;#3232;\_&amp;#3232; Edit: Kept reading, very well written, and *my* gut tell *me* as a C# dev [I need to be learning javascript](http://www.reddit.com/r/javascript/comments/kh0l4/euler_puzzle_1_good_solutions_that_illustrate/), thoroughly, and soon.
This is a bit of hyperbole from an over-enthusastic technologist. Big Systems are still being built in C. Network devices, firmware, embedded systems, microcontrollers, operating systems - they will continue to be C-based. Hard problems will still be solved in close-to-the-hardware languages. Javascript is getting more powerful, for sure. But, if the past 10-15 years show you *anything*, it is that the pace of evolution in software is accelerating, and the variety of software platforms, tools, languages and runtimes is absolutely exploding. Who knew anything about C# 10 years ago? PHP? Ruby? What about Python? Objective-C? How many languages have experienced explosive growth during the past decade? (hint: all of the above) How many predicted that in 2001? For that reason I don't think it's safe to conclude that Javascript will "drive" the industry, whatever that means. It seems more likely that advancement will continue in many different areas. Cross-pollination of ideas will be very important. All it will take is one surprise "killer" device, a la iphone, and a brand new language that none of us have heard of, will explode onto the scene. Even though I don't think Javascript will "drive the industry", I do think it will be a very, very important language. It is already ubiquitous, and people will soon concede that it is the most popular and widely used language on the planet. It will be used in surprisingly sophisticated systems - node.js is just the beginning. As people continue to use the term "scripting language" to refer to Javascript, the term will seem more and more out-dated and inadequate. 
Nevermind, The_Cleric wrote it first. ---- Was: function f() { var tally = 0; for (int i=0; i&lt;1000; ++i) { tally += ((i%5)==0)? i : ((i%3)==0)? i:0; } return tally; } Simpler, no? 
But ... you can do that in C# too, and it's only cool when it's purposeful. http://msdn.microsoft.com/en-us/library/bb397687.aspx
I should also point out that this code doesn't even run because you're referencing isMod before the function is defined. Edit: AyeMatey pointed out that my comment is incorrect.
Thanks I hadn't considered that the order is important (thought it ran fine for me in chrome though).
Lambdas are beautiful, but they're relatively new (.Net 3.5+). First-class functions aren't a familiar thing in .Net, so treating functions as such is fun &amp; new.
If you're using it exclusively for Firefox (eg, for an add-on) you can do some fun python-esque thing like: function eulerOne (aMin, aMax, aMatchSet) { function isMultiple (aCandidate, aMatchSet) { // some() is in ECMAScript 5 return aMatchSet.some(function (aValue) { return (aCandidate % aValue == 0); }); } // Generator is non-standard function range (aMin, aMax) { for (let i = aMin; i &lt; aMax; i += 1) { yield i; } } // Array comprehension and let are non-standard let matches = [i for each (i in range(aMin, aMax)) if ( isMultiple(i, aMatchSet))]; // reduce() is in ECMAScript 5 let answer = matches.reduce(function (aPreviousValue, aValue) { return aPreviousValue + aValue; }); return answer; } alert(eulerOne(0, 1000, [3, 5])); As commented, you can use the extra array methods with ECMAScript 5. 
 function sumOfFirstNNumbers(n){ return n * (n + 1) / 2; } function sum() { var iterations = arguments[0] - 1; var sum = 0; for (var i = 1; i &lt; arguments.length; i++) { var num = arguments[i]; sum += sumOfFirstNNumbers(Math.floor((iterations)/num))*num; } return sum; } sum(10, 3, 5); // 23 sum(1000, 3, 5); // 266333
Yeah - I should have been clearer: I appreciate terseness, but this exercise is about discovering new constructs, patterns, and methodologies that makes you guys love js. That said, I've learned a lot from this post, and may try Euler #2 tomorrow. :)
Thanks - I'll definitely appreciate it as I learn more about the core language's features.
[Func&lt;T&gt;](http://msdn.microsoft.com/en-us/library/bb534960.aspx) is the generic type of a function in .NET. this arrived in .NET 3.5, as you pointed out elsewhere. But the delegate has been available since .NET 1.0, and gives you the same thing, with a bit more syntax. A delegate is simply a typed function pointer. In JS, the function is loosely typed, like the rest of Javascript. But it's not accurate to say you couldn't pass a function or method as a parameter in a C# program. It was possible, even in the very beginning of c#. 
It's a syntax error. One part is you didn't assign the lambda, and the other part is that you never called the lambda. What you meant was function Outer(p) { var v = p; var Inner = function() { window.alert(v); } return Inner(); } Unfortunately, most of the answers you're getting here are wrong. There is no such thing as "a closure function." What you're looking at is called a lambda function. A lambda is a function expressed as a value: that is, you can assign it to variables, you can pass it around, and in some languages you can even operate on and alter it (not JS though.) The gimmick here is that in constructing `Inner` as a value, `v` has to be brought in from the exterior context at its current state. As such, the state itself is either copied or referenced, depending on the language. In Javascript, it's referenced - that is, you don't just have what `v` was at the time, but rather what some languages would call a reference or pointer to the real thing. We can demonstrate that thus: function Outer(p) { var v = p; var Inner = function() { window.alert(v); } v = 'New Value'; return Inner(); } Outer('Initial value'); If it was a copy, the alert would come up 'Initial value', but it does not. The reason it returned something other than the result of running the function was that you didn't pass an argument list, so it thought you meant the function as a value, rather than to actually call the function. The reason it came back as text was because you declared it incorrectly. var FuncName = function(arg, arg) { foo; bar; return baz; } So, like var ArithmeticOperators = [ function(A,B) { return A+B; }, // array of functions :D function(A,B) { return A-B; }, function(A,B) { return A*B; }, function(A,B) { return A/B; } ]; for (index in ArithmeticOperators) { // iterate over the array window.alert( // give to window alert ArithmeticOperators[index](8,4) // the result of calling that function in the array with the args 8,4 .toString(); // when represented as a string ); } Right? What we're looking at aren't closures; what we're looking at are lambdas. The closure is just the part where when you make the lambda, it keeps track of what `v` was. I mean they're important, but they're not a big player in the story, like spark plugs and your car. Do you need them? Yes. Are there different kinds? Yes. Do you care? Not much. Lambdas, though. Lambdas matter a lot. This is why a lot of people say, for example, that JS has "ad-hoc" object orientation - there isn't an object, really, it's just a k/v map of values, mostly lambdas.
Was just thinking the same thing.
Could have done without the author putting himself up on a high horse for the first 2 paragraphs. We get it, you are a software engineer, and all the crap you say you did in the past doesn't sound any different from every other software engineer I know. Other than that, I liked the article.
Euler pretty quickly degenerates into math problems. When you get bored, look for the prolog-99 question list.
Not true. Function Hoisting means it works. It must work. It is required to work. The EcmaScript standard doesn't use the term "hoist" , but that word describes what really happens. What the spec says is: *defined functions are not required to have their declarations appear textually before calls to them.* See section 4.2 of the [EcmaScript v3 language spec from 1999](http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf). 
Ignore what that guy said. order is not important. *defined functions are not required to have their declarations appear textually before calls to them.*
you can't do "int" in a javascript module, as far as I know.
nope! Not PascalCase and not unix_style. just camelCase. only camelCase. [Google's Javascript style guide.](http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml) It's not just google that says it, either. 
Er, derp. Quite right.
You're right. It didn't work in the Firebug console so I guess that doesn't conform to the standard. Thanks!
....yes
Yeah, good point. Guess I didn't realize I was in r/javascript.
Yes, it's a tad hyperbolic, but I'm also seeing some companies starting to adopt a "JavaScript First" kind of attitude. Discussions with technologists in my community show me that they are starting to look at a JavaScript source solution first when it comes to building customer-facing applications (whether native, or subsequently compiled to another language via an SDK). If that fails, then they look at other technologies. The article is projecting into the future, obviously, but is based on many seemingly disparate machinations in the industry and trying to find a coherent thread among them.
Thanks for the feedback. I threw this article together late one night and meant to go back and update it, but now I got the kick in the pants I needed. I was expecting vitriol thrown at me when I originally wrote it, so I was feeling defensive before it was even published! I've finally gone back and revised the article with a few more supporting and/or objective statements, and less defensive language.
It works the same way in Python, Lisp, Perl, and Ruby.
At the moment we are seeing a huge explosion in small applications, which typically aggrogate data and then display it in a pretty way. The large number of Twitter applications is a good example. For these types of applications, JavaScript and HTML5 are moving into a position where they can be king. You can easily build a solution, in less time, which is very nice to interact with, and is (mostly) cross-platform. It could/would be faster if built in say C++, but as long as the JS version is smooth and lightning fast, then no one really cares. JavaScript will clearly move further into this domain, from web applications and into more general purpose ones, and as a byproduct it will almost be used on more large applications in the future. But building large applications in tradition languages, such as C++, Java or C#, is still very difficult. This is even though they have had decades to mature and concentrate on solving these problems. I have built large applications in JavaScript, and I personally think it's even more difficult. A big issue is that there are few clearly defined levels of abstraction, such as packages, modules and classes, to help break up a project. You can fake those in JS, but in a large project everything needs to be as clear as possible. Faking modules and inheritance is not as clear cut as having the real thing. But I have no doubt JavaScript will get there. The biggest issue for me is simply 'what is the point?'. It is not that JavaScript is a bad option for building large applications, it is that Java/C#/C++/Ruby/Python/Erlang/PHP/etc are still excellent options. Until JavaScript becomes a _better_ option, there really isn't any reason to use it instead, for larger applications. It might be this that really helps to drive the next 10 years, because it's not like the other options are just going to be standing still while JavaScript does more to catch up and overtake.
&gt; JavaScript is going to be the virtual machine that drives the next 10 years of software evolution. Speaking as someone who's been programming for 42 years, I share the enthusiasm for the recent developments in Javascript and the work toward establishing support and best practices for modular development in Javascript. However, I find it most unfortunate that the browser as a platform standardizes the *language* Javascript, and not the the virtual machine on which it runs. And I really hope we don't have to put up with that state of affairs for the next 10 years. (Because, ya know, I intend to *keep* programming.) If not for Microsoft, the JVM might have been standardized in browsers, and we could have a choice of languages for client development. And the JVM itself probably would have evolved more quickly than it has. But no, we got Javascript. So I'm hoping someone will build a decent virtual machine on top of Javascript, and it will be fast enough to be practical. And then our favorite languages will be targeted to that VM (even Javascript itself!), and within a few years it will become a de facto standard that browser vendors implement natively. I know there have already been attempts to implement the JVM itself in Javascript. Another possibility would be to have a program that decompiles JVM .class files (for example) into minified Javascript. Generally speaking, I see web technologies as ripe for revolution, with fast, standardized Javascript as the enabling factor, though not necessarily surviving the revolution in its present form. 
Yup just like .NET's IEnumerable - lazily evaluated. Im thinking the most practical applications might be graphics coding. Say you have a stream of 100 coordinate triples representing polygons. You want to project these with a function, but only 1/3rd of the larger object represented by these coordinates is in your viewport. Lazy evaluation ensures that you are only computing the projection for whats visible now; once other portions of the object move into the viewport they will get projectex. This is all speculative - I dont have much experience with 3D coding. Can anyone confirm (or deny) if what I said makes any sense?
I like Javascript, I really do. But as the platform that drives the next 10 years of software evolution, I'd rather see a language with better design and more capabilities. That could be Javascript if they would just fix the design errors that have been lingering in the language since Netscape haphazardly tossed the language together. And let's please hold different engine implementations to a stricter standard. I'd also like to see some native AOP stuff. And let's have some sort of native standard libraries so we don't have to keep reinventing the wheel to do trivial things.
Lol I didn't mean for the author to actually read my comment. Now I feel bad. Just be glad you actually write, something I am too lazy to do myself. :)
I couldn't agree more. It's also much easier to support and control software when it uses the "service model" (ie: login to our website and use our web version) and javascript enables the intuitive interfaces that we've come to expect. While it doesn't work for everything, browsers keep getting better and better, it's not long before I can see them handling more complex tasks like video/audio editing, image manipulation and who knows what else.
|| as the "or" operator is *pretty common*.
I agree with the general sentiment of your comment, but I think the JVM is irrelevant. What the article is talking about is ECMAScript specific virtual machines, not Java Virtual Machines. That makes me excited. Javascript is such an awesome language (well, the "good parts"). These days we can write a simple web app that runs (with or without an internet connection) on almost any device. I don't see any reason why we would change the language significantly in the near future (10ish years). There are still some rough edges, but even at this point there's very little that can't be done with javascript bundled into an .html file which can be served from a webserver or run locally. 
Come on io!
I would have shot myself in the face 1 year ago saying this, but I agree. Having now used JavaScript for 1 year in a professional software engineering environment I do believe that JS is the future. 
A rather terse answer: var total = 0; for(var i = 1; i &lt; 1000; i++) total += i % 3 &amp;&amp; i % 5 ? 0 : i; EDIT: Fun bonus, consider if the problem was to sum over a much larger set of numbers. Increasing the max value of i in the code above would cause the browser to become unresponsive during the calculation and appear to hang (e.g. the user can't scroll or click on stuff). In practice, most javascript should try to provide opportunities for other actions to occur if possible to avoid hang-like behavior. As a crude example, the code below would release control of the thread after each iteration (this is much slower, but keeps the browser responsive during the entire process). var total = 0; var i = 1; function iterate() { if(i &gt;= 1000000) console.log(total); else { total += i % 3 &amp;&amp; i % 5 ? 0 : i; i++; msSetImmediate(iterate); } } iterate();
problem two is a very very fun one. If you get it done and think "oh that wasn't too hard" then try it with all the fib terms less than four *hundred* million instead. Your code should be almost as fast.
Right, in addition to minifiers there are obfuscators which hide the code, but the 2 don't always go together.
I just finished a new shiny Sphinx documentation: http://readthedocs.org/docs/spritejs/en/latest/
This feeling feels a lot better when I started properly learning AS3 again only to realise how dead it's going to be in the next few years. Still, the syntax is similar to Javascript so I guess it isn't all bad.
It is always good practice to assume that your comment will be read by the subject. It helps keep the comment objective and more-or-less polite.
I don't think Euler is a good place to experiment with cool features. Most of the problems are short math problems that don't give you an opportunity to exploit the features of JavaScript. Unless you consider looping a lot a feature.
I think your example doesn't really illustrate closures very clearly. Try this, called currying. var Outer = function(p) { return function(q) { return q + p; }; }; var two = Outer(2); two(3); // returns 5 The variable p (the one you pass in to Outer, in this case 2) still existing when two(3) is called is the closure - a variable that should not exist due to scope does exist.
&gt; JavaScript itself is not a virtual machine, it’s simply a programming syntax, right? I refuse to take advice from programmers who don't know the difference between a "syntax" and a "language".
This is great. I can get why id selectors are faster than class selectors. I had no idea they were 55 times faster :P http://jsperf.com/dh-jquery-1-4-vs-1-6/6
I read this a while ago but to anyone who doesn't really want to read the whole thing for specifics I took away this. Probably 90% of what you're doing with jquery you should just do in raw javascript. And always use the latest JQuery.
var sum = (function a(i,j){return (i&lt;j)?i*(!(i%5)+!(i%3)-!(i%15))+a(++i,j):0;})(1,1000);
I'd say if someone didn't know at least 1/2 of what was presented, they are still pretty green when it comes to jQuery/JavaScript.
[#67 was my favorite](http://projecteuler.net/index.php?section=problems&amp;id=67). Definitely proves the value of recursion (so does #2 I believe)
Node needs to run on windows? I think not.
I don't completely understand the reason for this type of interaction with the rows but I put together a simple example using jQuery. http://jsfiddle.net/4etw8/1/ 
This doesn't necessarily show you anything *cool* but this solution (I'm pretty sure it's right) is more optimal: var s1 = 0; var s2 = 0; var a1 = 3; var a2 = 5; var sum = []; var it = 0; while( s1 &lt; 1000 || s2 &lt; 1000 ){ it++; if( s1 == s2 ){ sum.push( s1 ); s1 += a1; s2 += a2; }else if( s1 &lt; s2 ){ sum.push( s1 ); s1 += a1; }else if( s2 &lt; s1 ){ sum.push( s2 ); s2 += a2; } } console.log( it + ' Iterations', sum ); // Only takes 468 iterations instead of 1000 Obviously you would change `sum = 0` and `sum+=s1|s2` but I was checking to make sure it was giving me the correct values. This code could probably be shortened a bunch but I just wrote it in the last 5 minutes or so before I'm leaving work! Edit: Changed &lt;= to &lt; in the loop, didn't realize 1000 shouldn't be included. 
The thing is: has by-class selection speed ever been the bottleneck? Write maintainable code first. Optimize the details when you need to.
My guess is it would depend on the total number of nodes in your document, and that it could be far worse.
1. in jQuery you can do something like: $('tr').click( function() { loadContent( this.id; ) } this will set up a click handler for every TR row, which passes the value of the id attribute to loadContent() (which you would need to code...) 2. you could do something like this: $.map($('tr'), function( row, index ) { return row.id; } ); The $.map function takes an array and applies a function to each member. In this case, it takes all the TR nodes and applies the function which returns the id for each node. The result is an array of ids. 3. If you have a dedicated div at the bottom, the loadContent() function should be able to reuse it. 4. it sounds like a reasonable approach but... it's hard to tell without knowing the overall requirements...
But JavaScript is more portable than C right now. It runs on everything and can do everything. If we can use JavaScript syntax for real applications, then that's a really good reason to use the language. The only thing we are missing are good IDEs for JavaScript, but that's probably due to the nature of the language.
The web page says Hydra is Extensible! Framework-agnostic! Modular! but what does it *DO*? 
selecting by class forces you to look at a greater number of nodes than by ID. Hell, you can hook onto an ID to minimize your scope, then select by class. That's better than by-class only. Ex: `$('#mysection .myclass')` is better than `$('.myclass')`
&gt; But JavaScript is more portable than C right now. Let's examine that claim: How many Javascript "engines" (interpreters) do you know of? Name them all. Which of them are NOT written in C? I know one - Rhino; it is written in Java, which itself is written in C and/or C++ (depending on the JVM). Every Javascript platform I can think of, is a C-language platform. There may be a few, but I don't know them. Now, how many C-language cross-compilers are there in the world - things that compile C onto some specialized processor? Z-80, Intel 8051, All the PIC microcontrollers, 6502, 68000-series, and many many more. Hundreds. Literally hundreds. And they all run C. Do you suppose that every one of those specialized processors runs Javascript? what you said seems very unlikely. C is more portable. The statement is nearly a tautology. Also: I believe there will be an explosion in the number of connected devices. Everything will connect. Most of those devices will run on dedicated micro-controllers, which will be programmed in C, and will not run Javascript. Your home thermostat, the 48 microprocessors in your car, the chip inside your MP3-player, your digital wristwatch - all of these run C, and not javascript. 
Addy osmandi has gone over a lot of this already on his vimeo channel, worth a [look!](http://addyosmani.com/blog/) also, waiting on that follow up to the deferred promises video, addi! :)
um, yes. class iterates over the whole dom. id finds a specific node and breaks. the best thing is to find an id, and select down from there. ex: $('#someDiv').find('.someClass'); It will radically speed up things in loops/each statements, etc. this isn't 'optimizing a detail', its good practice to begin with. Also stop appending to the dom in your loops! This is the ultimate performance killer. 
It already does. Microsoft has even partnered with Joyent to provide support during development. Why is this a bad thing?
I laughed =)
My MVC is only slightly bigger, and it's a legitimate MVC :) https://github.com/jamon/SOFEA/blob/master/htdocs/js/ydmf/Mvc.js or the main link at https://github.com/jamon/SOFEA :) it's not well packaged yet, but it's the source code of http://sofea.net if you want to poke around with it in a live demo.
Create a scalable, maintainable and **module oriented system**.
Don't listen to me, loops aren't actually useful in the way I was thinking.
Be sure to include a doctype in your HTML: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;!-- ... --&gt; and a title: &lt;head&gt; &lt;title&gt;My guessing game &lt;/head&gt; --- Onto the JS: value = document.forms[0].elements[0].value; Refer to element by name when possible, like this: value = document.forms.guess.num.value; You should also declare `value` as a local variable: var value = document.forms.guess.num.value; --- The following line will *not* do what you want: else if (answer-2 &lt; value &lt; answer+2){document.write("Close!!")} The `if` expression is treated as `((answer-2 &lt; value) &lt; answer+2)`. Let's say `answer = "5"` and `value = 1`. The runtime will evaluate as such: ((answer-2 &lt; value) &lt; answer+2) ((5-2 &lt; value) &lt; answer+2) ((3 &lt; value) &lt; answer+2) ((3 &lt; "1") &lt; answer+2) (false &lt; answer+2) (false &lt; 5+2) (false &lt; 7) true Notice that: * `value` is a string (`"1"`). When you use the binary `+` operator, you are not adding, but in fact *concatenating* strings. `"1" + 1 = "11"`. Confusing? Yes. It's one of the bad parts of JavaScript. You can resolve this by casting `value` to a number: `value = Number(value);` * The three-part `&lt;` operation is actually treated as two two-part `&lt;` operations. This leads to comparing a boolean (`true` or `false` on the left) with a number (on the right). It does *not* check if the middle is between the left and right as you expect. Instead, split the expression into two: `answer-2 &lt; value &amp;&amp; value &lt; answer+2`. In case that went way over your head, here's your code refactored: var value = Number(document.forms.guess.num.value); if (value == answer){document.write("Correct");} else if (answer-2 &lt; value &amp;&amp; value &lt; answer+2){document.write("Close!!")} else {document.write("Incorrect");} --- &gt; Also, how do I allow the player to make another guess at the game? You're using `document.write`. Calling `document.write` after the page has loaded blows away the current page entirely. Either you write the entire page *again*, or you change your code to do something else. That "something else" could be, for example, updating the text of a paragraph on the page: &lt;p id="message"&gt;&lt;!-- Updated using JavaScript --&gt;&lt;/p&gt; &lt;script&gt; function showMessage(text) { document.getElementById('message').textContent = text; } &lt;/script&gt; Now when you call `showMessage` the paragraph's text will be updated. Replace your `document.write` calls with `showMessage` calls. An alternative is to avoid the DOM and simply use `alert`. No one likes `alert`, but it can save you from boilerplate code like the above snippet in cases when you really don't care about the player hating you. =] 
How will loops solve the problem? I'm curious how loops could fit into this event-driven game.
He wants it to make you keep guessing until you get it right, correct? You're doing the same thing over and over based on a condition.
Can you mock up what he'd do? JS is asynchronous, which typically means loops are not written in JS to communicate between game logic and the environment.
I don't get it. =(
Derp. You're right, that's not very useful in JavaScript in the way I was thinking. I could do it, but not in as simple of a way as I thought.
But that doesn't *mean* anything. There's no real meaning to that buzzphrase. *What does it DO?* 
Thanks, the program works more like the way I want it too and I also learned a few things. :)
This is pretty funny but also spotlights the sad state of things, specifically how the amount and frequency with which JS MVC frameworks are popping out of the woodwork is approaching terminal velocity and breaching saturation limits.
Shouldn't it start with var? Or window.M?
He's actually correct, it lets you make an application that's separated into compartmentalized modules.
I saw the link and thought ‘This obsession with smaller and smaller “frameworks” is getting out of hand; I shall reply to this one with a JavaScript framework that consists of nothing but comments,’ and then clicked through and discover that I was too late.
I'm wondering what is the size of minified version :]
First, i said "why is this gist?" without looking at the code. I went to this guy's github page searched "ligament", no result. Then i said let's check the code. And i saw it. &amp;#3232;\_&amp;#3232; 
At first glance the idea of classes seems at odds with prototypal inheritance. There is a lot of special syntax here. Are there any redeeming factors to this solution? :)
...which solves... what problem? ...... 
I think the problem might come with the noise:signal ratio... I am all for options, but there is such a thing as too many....
Are you kidding? Javascript's weird prototype orientation and the poor DOM API make it hard to write loosely coupled, maintainable code.
no, I'm not kidding. I still don't know what this framework does. There's no clear statement of the problem it solves. "Maintainable modular code" is not something that comes from a framework, as far as I am aware.
An MVC architecture separates our your code into three conceptual objects: * the Model: the actual data your code is dealing with (articles, tweets, whatever data your page or widget is working with) * the View: how your system renders and displays the data (the template and templating system used to render each item) * the Controller: the code that allows users to change what's displayed, or add/remove/alter the data in the Model (the ability to re-order content or sort it by different attributes, the functionality to add or remove items from the Model, or alter how the View renders and displays items). The point of an MVC architecture is to separate out the three concerns of a program or system, so that (for example) you can redesign the "look" of an app without breaking how it works, or redesign the functionality without altering the format it uses to store and process data. An example of an MVC architecture is a well-architected web page - the HTML is the data, the meaning. This is why you hear such a lot about "semantic" HTML being important, and "presentational" HTML (which mixes up the Model with the View) being bad. CSS is the view - it takes the data and decides how it should appear on the screen, or how it should be read out on a screen-reader, etc. Finally Javascript (and/or HTTP and back-end code running on the server) is the controller - it allows you to manipulate the view (eg, by opening menus or moving elements on the page) and add, remove or manipulate the Model (by dynamically creating HTML elements on the page, or by posting new content to the server). MVC architectures vary greatly in complexity, where some give you an astonishing proliferation of tools and options and ready-made functionality, and some are very bare-bones, giving you comparatively basic functionality to work with and expecting you to add your own modifications where desired. Simultaneously, there's a trend in JS programming circles to try to pack the most (or at least, the most impressive-*sounding*) functionality into the least number of bytes. There's a legitimate reason for this, because the smaller your JS library the quicker it downloads, and on a popular enough site even small inefficiencies quickly add up. However, when "smallest number of bytes" is allowed to become the priority over "useful software", you get people producing feature-poor libraries and systems just so they can crow about how few bytes they take up. This is a joke referencing those two aspects of programming - it's an "MVC architecture" that gives you three objects: M(odel), V(iew) and C(ontroller). The thing is that it's so stripped down it literally only gives you those three empty objects - they have no structure, data or functionality beyond what you choose to subsequently add to them. They're technically "an MVC architecture" (which sounds impressive) and they're "only a handful of bytes big" (which theoretically confers bragging rights), but functionally they're little more useful than an empty file for you to write your own source code in. The author is taking the piss out of exaggerated descriptions of libraries and size-of-library cock-waving competitions, by providing a library that's *technically* allowed to call itself something that sounds incredibly complex and clever, and is packed into only a few bytes, but only at the expense of being totally and utterly useless.
True. We're long post-scarcity for most types of content on the net now. A new MVC architecture, or a new opinion, or a new editorial on a news event is no longer inherently valuable in and of itself, because we're neck-deep in them all already, and the tide is rising. What we need now is not raw content so much as *good filtering mechanisms* to aggregate the best ideas and highlight the best content and discard the rest. Sadly, people's instincts typically lag a *long* way (years or even generations) behind the current state of the world... hence the current still-widespread belief that "more is always better", even when we're generally already in grave danger of *drowning* in a sea of whatever is being discussed. &lt;:-)
It provides a strict way for modularizing applications that the programmers can stick to. If you're programming with a team you might have noticed that everybody "attaches" his code in a different fashion, because of JS' flexibility. It can be solved with good practices and coding standards, sure. And how to modularize JS is not so trivial because there are different kinds of beasts (it's not all classes, like for example in java). The "vanilla" JS MyClass = function () { }; MyClass.prototype.myMethod = function () {}; .... The "singelton object" MyObject = { myMethod: function () {} }; The "hide your privates" object function Stuff () { var privateStuff = 42; var myMethod = function () {}; return { myMethod: myMethod }; } And, oh the horror, "Prototype © Classes" (as in prototypejs.org) var myClass = Class.create(MyParent, { myMethod: function () {} }); And so on. 
I think of explicit getters like this (which implies setters) to be a Bad Thing. It breaks encapsulation and leads to this foolish notion that all members need getters and setters, which leads further to classes being used in a way that defeats OOP principles. This is not OOP, and it's a blight. This is an attempt to make the new Javascript look and behave like other class languages, all of which have gotten OOP wrong as well. I don't like what I see here.
JAVASCRIPT IS NOT JAVA. REPEAT JAVASCRIPT IS NOT JAVA. However, [this](http://clamato.net/) is something I can get behind. Smalltalk in the browser.
My feelings exactly. Given you can write perfectly good class-based systems if you really need them using Javascript's built-in prototype-based functionality, what does baking classes into the language really do for you that offsets the additional complexity, additional syntax, additional reserved keywords and additional developer-education needed to learn the quirks of the system (because lets be honest: *all* class systems have them)?
ok - there are challenges when building anything substantial in Javascript, owing to the flexibility of the language. I see that. &gt; It can be solved with good practices and coding standards, sure. Ok, I see that too. I see the shape of *one possible solution* as a combination of: - a style guide - code police, code reviews that happen every so often - a tool suite for static analysis that flags likely problems (length of methods, nesting, violating prescribed conventions, etc) Now.... about this Hydra framework.... ? It does what, exactly? How does it relate at all to the problem? It claims to "solve it" I guess. (not really, but we are expected to conclude that by reading the blurb). How, exactly? Hydra, says the web page, is "designed to...." - Avoid failing your full application for some little error. - Be extended. - Be framework agnostic. - Create a scalable, maintainable and module oriented system. !! and there is no more detail than that. 
I'm in the same boat. I am learning JavaScript and loving it. I think one of the things standing in the way of me taking so long to learn it was goddamn webforms. The id mangling makes JS a pain in the ass. After switching to MVC I'm loving JS.
You know, I also think it's kind of pointless. I was just guessing the "why". Also "avoid failing your full application for some little error" is a bad practice: it makes bugs harder to detect and makes you application unpredictable. 
&gt; Given you can write perfectly good class-based systems if you really need them using Javascript's built-in prototype-based functionality, what does baking classes into the language really do for you You can build them by following a design pattern. This is something that lots of JavaScript users, even experienced programmers coming from other languages, have to research. Given how popular it is for people to need classes in JS, it does not make sense to not have proper support. It is also possible to implement classes in multiple ways, each with varying degrees of quality. For example this: function Foo() { this.someMethod = function() { } } is generally slower then: function Foo() { } Foo.prototype.someMethod = function() { } Further if I give you a piece of code, where I am touching 'this' or 'prototype', how do you know I am defining a class? There are lots of other, legitimate tricks, I could be employing instead. Having one, clear and standardized way of defining a class will help to remove these ambiguities. If that isn't good enough, then another advantage is that I'd expect it will use less characters, and so produce more minimized code (although this is just my gut feeling, I haven't checked).
&gt; Given how popular it is for people to need classes in JS, it does not make sense to not have proper support. I'd query that *need* - people may *want* classes, but there's no reason why you can't write functionally the same code and solve the same problems with prototypes. "Want" is a fair argument, but "need" strikes me as over-stating the case. Moreover, "want" is still of debatable merit as a reason, especially when it's just because it's what people are familiar with (familiar != good). For example, people coming to JS from VB6 back in the day might have *wanted* a GOTO statement, but that isn't really a valid argument for adding goto to JS. &gt; It is also possible to implement classes in multiple ways, each with varying degrees of quality. That's true, but I see that as a strength of JS. Want multiple inheritance? There are class systems which can do that. Want single inheritance? There are class systems that can do that. Want a form of polymorphism? There are class systems that can do that. Hell, want something comparatively exotic like aspect-oriented programming? There are JS systems which can do that. I guess my fear with implementing a class system in JS is that it may inherently restrict the creativity of people who would otherwise build their own, and will bless one particular type of class system as "*the* right one", to be showered with approval, optimisations and tutorials, leaving any user-derived ones out in the cold and potentially impoverishing the language as a result. It also concerns me that this is primarily of use to people who know other languages and would like to be able to code like those languages in Javascript, rather than learning the language they're using and learning to play to Javascript's strengths. (Edit: By sheer fluke, there was [a post related to this](http://www.reddit.com/r/programming/comments/kikut/think_in_go_gos_alternative_to_the/) in r/programming just this evening, which could be paraphrased here as "wanting classes in Javascript is thinking in C++ or Java or C# or whatever. Don't do that. Think in Javascript.". Compare also concepts like "[pythonic](http://faassen.n--tree.net/blog/view/weblog/2005/08/06/0)" - the idea that you should try to program idiomatically for the language you're working in is not new, or (to my knowledge) particularly controversial. ;-) FWIW I'm torn on the issue of baking classes into JS (much as, as the slide implies, Brendan Eich apparently is). On the one hand there are legitimate benefits... it's just that the vast majority of them appear to be benefits primarily to newer users, and achieved by changing Javascript to be more similar to other languages... rather than new functionality or idioms that benefit everyone by making it an inherently more powerful language. :-/ As I said, I'm more torn about the idea than definitely against it, but you make some good arguments so have an upvote. ;-)
I am so glad Brendan is proposing `@` instead of `this.` instance-scope access.
I fucking love proxies. Probably once a week I have a problem that could be solved neatly with proxies. My favorite ES.next feature for sure.
I proposed the same feature for Lua when 5.1 was being implemented. Sadly, it never made it in. It would be extremely nice to have syntactic sugar for constantly typing self.foo, self.bar, etc. I hope it makes it into javascript.
I think using the form name and input name is a valid solution. I don't see the reason in using ID's.
Who said it is? Javscript already has prototypical constructs, this is just a way of formalizing the various methods. Javascript will still be as dynamic as it always has been.
I'm really not a fan of this. This is my vote: https://gist.github.com/1224324 
Am I the only one who thinks JS works just fine without any of this OOP non-sense? The last thing JS needs is to become more like Java. Fix scope issues and other real JS problems, leave the prototype system alone.
This is the solution I used! &lt;script type = "text/javascript"&gt; &lt;!-- function pigLatin() { var myForm = document.getElementById( "myForm" ); var sentence = myForm.input.value; sentence = sentence.toLowerCase(); var tokens = sentence.split( " " ); for ( var i in tokens ) printLatinWord( tokens[ i ] ); myForm.output.value += "\n"; } // end function pigLatin function printLatinWord( token ) { var myForm = document.getElementById( "myForm" ); var convertedWord = token.substring( 1, token.length ); convertedWord += token.charAt( 0 ); convertedWord += "ay"; myForm.output.value += convertedWord + " "; } // end function printLatinWord // --&gt; &lt;/script&gt;
I still haven't made the switch to mvc - I've played with it, but I do mostly enterprise projects, quick to turn around, and lately don't have much time for trial &amp; error.
It's special syntax for the common use case. It doesn't change the underlying engine, it's more intuitive to newcomers. It results in code that more closely looks like what the developers mean rather than what they are currently forced to write. 
Hi, guys! I checked the code and there is a error handler class to log the errors. This error handler class could be overwritten with your own implementation if you need something special when logging errors. If console object exist the error is logged in the console showing wich module and method is failing. (If the browser allows it then the line and file are showed too) If console object doesn't exist as Internet Explorer &lt; 8 or Opera, this errors are logged to one hidden layer that you can show if it's needed. There are different libraries that avoid failing and doesn't implement any error handler and fail silently as LABjs if something fails in any "wait" method callback. But this is not the case
I've only been really grokking Javascript for a short while, but I think if prototypical inheritance works, then why bother with the classes? I think I've gained something re-wiring my brain to think in prototypes and I think in the future, if classes are added, this feature will be looked over by new learners and it may cause more confusion than it does now.
I'm curious. What do you think JS's scope issues are?
I once built an object-oriented GUI testing kit in VBScript. Inheritance isn't supported in VBScript, so I faked it through wrapping objects, which were set to a 'super' field (it might have been called something else). It worked, but it meant you had to use the classes in a certain way, in order to use it. The way you can build classes in multiple ways, with different features, is a good example of the flexibility of JavaScript. It handles the job far better then most languages (including VBScript), and I fully agree it's a huge strength. But like in my example above, it still tend to show around the edges. Specifically, a class definition does not look like a class definition. Given how popular it is to use modules and classes in JS, it just doesn't make sense to not have these features provided, out of the box. I think the solution which would be most JavaScript-like would be to give the means to add more syntax to the language. Then your 'fake' classes or modules, would actually look like typical class/module definitions. For example in Ruby the syntax is flexible enough that you can write natural looking DSLs. 'class' could then be provided by the browser, but you'd be free to replace it, add functionality, or build your own alternatives (such as aspects that looked like aspects). Just like you can with the standard functions. But I have no idea what this would look like. You get an upvote from me btw.
I couldn't find the exact article I read it in. Basically I've seen some weird instances where "this" has bizarre meanings, and can sometimes be confusing the the output will be. It's all technicalities, and I personally never run into issues. My point is JS has real problems that need solving. If your going to bother adding in a whole new Class syntax, you might as well change the whole language. Hell, throw in multi-threading while you're at it.
This seems like a simpler version of brequire https://github.com/weepy/brequire/blob/master/browser/brequire.js for reference Not saying that it isn't good, it's just been done before. I like the simplicity though
Yes, the syntax was almost exactly the same. The majority of changes over the years have been additions to the base objects. The biggest syntax change I can think of is the addition of for...in
The DOM api has changed quite a bit, but this is not javascript...
Sorry if this is obvious.. Why does mystack.length return 1 and not 2 in the second example?
[MDN Docs - JavaScript Logical Operators](https://developer.mozilla.org/en/JavaScript/Reference/Operators/Logical_Operators)
Yeah, but it wasn't understood nearly as well as it is today.
What about [Dart](http://www.theregister.co.uk/2011/09/14/google_project_kill_javascript/) though, a language by Google that could replace JS?
What I would really like in javascript is the "yield return" syntax of C#. It allows for separation of code that does not belong together. Also, shorter lambdas.
Look at previous version of the spec... http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm
The syntax was the same, but javascript coding style has matured over the years a lot, I wouldn't expect good old javascript to look much like good new javascript.
If you haven't, you'd do well to watch the [Crockford on JavaScript](http://www.yuiblog.com/crockford/) series. Douglas Crockford is the world's defacto expert on JS. The series is revelatory!
Lots of good people on this. Will subscribe to it!
Nitpicking: `in` is an operator, and doesn't really have anything to do with `for`. You can use it elsewhere, such as `if (foo in bar)`
And it was mainly used for evil which is why there's still a few old grouches who run script blockers. I'm pretty sure it was around the time Gmail came out that people started realising it was actually useful; AJAX was coined, libraries popped up, the web got better.
That is a fair assumption since inheritance isn't immediately obvious in its current form. I'm curious, did the standards committee evaluate alternative solutions, like delivering this through the standard library?
Not really. While `in` is indeed one of the operators, the `in` inside a `for-in` statement is not the same as the operator. It is treated separately and is a part of the statement itself—which is hinted by the fact that it's called a "`for-in` statement" in the specs.
Here is the link to the [original implementation](http://mxr.mozilla.org/mozilla/source/js2/semantics/) of JavaScript in the Mozilla CVS.
This is exactly it. HTML/HTTP/REST and Javascript were surprisingly well-designed systems that were clearly intended to be used in some very clever ways from the very beginning, and it's been really fascinating watching how the entire industry seized on a few simple patterns and subsets of functionality and used (and abused) them exclusively... and how it's only now (ten to fifteen years after mass-adoption started) that people are really getting to grips en-masse with the way things should be done (semantic HTML, HTTP verbs beyond GET and POST, proper use of prototyping and the more advanced features of Javascript), etc. It just makes you appreciate how very, very clever the early pioneers and developers really were, that they invented systems with clear patterns and use-cases that were so clever that it took the wider industry a decade or more to even really *discover* them, let alone work out how to use them optimally.
I love REST, however, REST is more of a methodology than a technology. REST is more or less "a best practices" thing. REST definitely exists without Javascript. Also, not every URL should be a RESTful URL. Once you start nesting resources, things get real ugly: /planets/:id/hemispheres/:id/countries/:id/states/:id That's an extreme example. A good rule is to keep your REST resources nested no more than 2 deep. 
&gt; REST is more of a methodology than a technology... REST definitely exists without Javascript. Actually you'll note I intentionally used the non-specific word "systems" rather than "technologies", and explicitly offered "HTML/HTTP/REST" as a completely separate example to Javascript, not intending to imply any connection at all. The point was that in many situations (with HTML/HTTP/REST and Javascript being *two* examples) there's a lag between a system, technology or feature being introduced and the wider industry getting to grips with the optimal methodology regarding how to use it. &gt; Also, not every URL should be a RESTful URL. I also never said every URL should be a RESTful one - in particulate any URL you POST to shouldn't/can't be, by definition. I'm not sure what points you were making or arguing against in your comment, but they don't appear to be related to anything I said in my post. &lt;:-)
Glad to see I'm not the only one. ಠ_ಠ
Sorry. Just woke up. I do notice now you noted "systems". I totally agree with what you're saying. I wasn't trying to argue. Apologies if that's what it seemed like. Why does the Internet always make it seem like people are arguing? 
Ah, I was thinking of `for each (in)`, which was added in 1.6
Nitpick: AJAX was coined in 2005, gmail didn't go public until 2007. Google Maps (which did launch in 2005) was probably a bigger turning point, since it was the first of its kind. Before it came out, every map site was still using image-map form submission to scroll and zoom.
No probs - sorry if I came across as snappy. &gt; Why does the Internet always make it seem like people are arguing? For my money, "lack of emotions adequately communicated in text". Hence my (probable over)-use of emoticons. ;-)
&gt; it took the wider industry a decade or more to even really discover them You can thank the dot com crash for that. There WERE companies out there who were using JS the way people use it today (I worked at one), but many of them went poof when the bubble popped. Their IP vanished into dusty closets and their engineers wondered from start-up to start-up. Many of those coders landed at Google and were responsible for the resurgence.
&gt; You can thank the dot com crash for that. I don't know - on the other hand it helped to weed out a lot of the appearances-are-everything on-line marketing and advertising firms and businesspeople who thought of the web as nothing more than a way to put adverts in front of eyeballs... and in my experience they tended to be the worst advocates and causes of presentational HTML, Flash-only websites and the "who cares how it works, as long as it looks nice" mindset. When they realised that the web wasn't a magic ticket to vast riches a lot of them either left the industry or metamorphosed into SEO consultants, who *necessarily* had to know at least a little bit about good URL- and link-structure and basic web technologies... I guess it's swings and roundabouts. ;-)
Yeah, I can barely remember how mindblowing the Google Maps application was when it was first encountered. We take that kind of fluidity for granted now, but it was entirely different just a few years ago.
Know how to fix this?
I didn't downvote you, but I can explain the fallacy in your statement. This is a server bug that mangles text sent from the server to the browser. It *happens* that this particular bug affects JavaScript code, but it's just as possible that a similar kind of bug would mangle CSS or HTML code. If the bug happened to mangle HTML code instead of JavaScript, then following the same logic, one would say "This is an example of why important functionality of your website should not rely on HTML." Of course no one would say that - but it's exactly the same class of bug.
There was a major addition to the syntax in JavaScript 1.2: object literals and array literals. Before that, you had to write old fashioned code like this: var obj = new Object; obj.foo = 'bar'; instead of: var obj = { foo: 'bar' };
What about when you console log and you end up crashing the whole thing. :/ Just got that now, removing the logging removed the crash. But yeah, whats your JS code? Does it work if you just run a blank application? 
Exact repro steps help. We're watching feedback like a hawk :)
&gt; A good rule is to keep your REST resources nested no more than 2 deep. **I N C E P T I O N**
I gave up after crashing 5 or 6 times. I find it funny they release a *developers* preview where the developer tools don't seem to work.
It's not the concept that's the problem, it's that the implementation can be awkward at times. Having a syntax for defining classes removes ambiguity.
Mind if I ask you for some help troubleshooting a problem using the XAML designer in VS11?
Sounds good, you should check out my library; [Red Locomotive](robertwhurst.github.com/Red-Locomotive/). I think you should really think about some other kind of back end though. PHP only runs when apage request is made. This makes it unsuitable as a game platform. Have a look at [NodeJS](http://nodejs.org/). Good luck and have fun.
Well, if you put Ubuntu on a USB stick, it will keep the changes you make to the filesystem if you select that option (at least when you use usb-creator-gtk). Then you can just run "apt-get install nodejs" and you'll have nodejs available.
To be fair, Gmail was practically open long before 2007. Wikipedia notes that [*"on 3 February 2005, Gmail users were awarded 50 invitations and later 100 invitations"*](http://en.wikipedia.org/wiki/History_of_Gmail), at which point it was basically available to anyone.
Video was simple and interesting, definitely will try it out once its released. 
LOL LOOK GUISE, THESE GUYS RELEASED AN ALPHA WITH BUGS
This is really cool. What is the extent of the modifications to DrJS? Is there a chance the changes would be ported back or is this a parallel effort?
Or you could run a linux distro in a VM like Virtual Box or VMware...
Sorry, just to clarify you are talking about the full background image having a title and/or being clickable given some type of meta data? Probably fairly easy to do, just don't want to send you a solution if I misunderstood the question.
The fact that it only has function scope, and loops do not create a new scope. Have you never come across this?
Just run a regular distribution in a virtual machine. Well, the official Windows executable from Node actually does work pretty fine. NPM doesn't work yet, but virtually everything else does.
Thank you very much. I thought it was only affecting external js files. I've heard of proxies doing that sort of thing.
Note that the Node.JS in apt is pretty old (0.2.7 IIRC). Better off building from source and getting npm from [npmjs.org][1]. [1]: http://npmjs.org/
You are describing your method of development, which apparently is broken, and therefore irrelevant. For future reference if you are seeking strategic guidance describe what you want and not what you are doing. It sounds like you are receiving a data collection and once that payload is delivered you are building the page on the client-side using some framework. I can tell you from experience this is a horrendous and costly mistake. Initially build the page on the server, ALWAYS! I say this is absolutely horrible for two reasons: 1) You are likely increasing initial page load by a factor of 8 or more. If I were a customer and this were an e-commerce site I would abandon you and never come back. Don't waste my time because you want to provide some amount of interaction from the client-side. 2) You are burying some depth of application development into some framework. Unless you have reviewed the framework's code and understand that code well you cannot guarantee that framework will execute your style of coding efficiently regardless of how fast the framework claims to execute. Furthermore, you are adding an additional layer of crap to your application that will increase complexity of maintenance and will likely be impossible to unbuckle from your site without starting over. That is a business failure. Then you make this worse by supplying functionality from more than one framework. You would never build anything else with such a lack of due diligence or planning, so why are you building websites this way? If you need to receive a data payload to supplement dynamic re-population of results then fine, but deliver an initial pre-populated page to your users. If you want to build the interactions using assistance from a framework then fine, but do so in such a way that the framework can be replaced by a separate component in a heart beat without throwing away the entire page. If you cannot do this then you are better off not using the framework.
You cannot. A CSS background image is non-functional. What you can do is supply HTML child elements to an area that contains a background image and use CSS to properly size and position those transparent child elements.
What problem are you trying to solve with Backbone.js?
Having the background image contain a title/link would be ideal, like in the Supersized image slider http://buildinternet.com/project/supersized/slideshow/3.2/demo.html. I've tried adding the .class { background: url(http://www.google.ca/); } but no luck just yet. I've never used rel="" to create a link before, so I'm somewhat at a loss as to add any attributes to the new background image.
I don't think the view should create any models. So, your BookListView listens to the BookListCollection. BookListView = function() { BookListCollection.bind('add', 'renderBook'); BookListCollection.bind('remove', 'renderBook'); // But we also need to keep track of individual BookViews, // so let's create an array that keeps track of that: this.BookViews = []; } So every time a new BookModel is added to the BookListCollection, we call 'renderBook' renderBook : function(model) { // Create a view for this specific model var newBookView = new BookView(model); // Keep track of this sub-view within this parent view this.BookViews.push(newBookView); // Finally render the sub-view within this parent view's DOM element this.el.append(newBookView.render()); } When a BookModel is removed from the BookListCollection, same idea, remove and destroy the sub-view. Your views should *listen* to your models/collections. This is the approach I took, but Backbone is pretty flexible about how to do things. Their todo.js tutorial actually uses an anti-pattern, where the view knows about the model, and the model also knows about the view. 
I got this error as well. Install Win8 in a VM (VirtualBox), run VS2011, create new JS Grid application. F5 to run an I get this error. Creating a new C# Metro app does the same. I haven't touched the code in any way (I wanted to see what was the base UI stuff before messing with it).
So far, the patches are not extensive, though they touch both [DoctorJS](https://github.com/clausreinke/doctorjs/commit/2815cad6d361d4961cf64c558dd3efaec51f6a06) and [narcissus](https://github.com/clausreinke/narcissus/commit/6d1ae3f179ba0d000c4d8ceafbc967439273138a) (these are the main patches, there are a couple more for catch clauses). Mostly adding line:colum source spans to a few AST nodes, and outputting extra tags based on scope links and source spans. I would like the patches to end up in the main repos. My bug fix patches are in the DoctorJS ticket tracker, but have not been noticed, so I haven't put forward my feature patches yet.
If you just want to get started, you can alternatively get the [latest official .exe file](http://blog.nodejs.org/) and drag&amp;drop your source file onto it. No further installation required. Even though you cannot use npm, which is required to maintain libraries, you can at the very least create your hello-world app and play around a little.
JIMMENY JONES WINDOW$ SUCKS
My main problem with using tags in Vim is that I need to regenerate the tags when stuff "doesn't work" anymore. Is there a good way around this problem?
"yield return" is what makes ruby great too.
I forked off the virtualenvwrapper code to work in several directories and non-python code: https://github.com/mitechie/workit The idea is that you hit workit someproj and it runs some init code (start mysql, run ctags, etc). So whenever I need to update my ctags I just workit $proj I'm working on.
HTML5 is Future! FLASH is Present Flash will be extinguished! RAWR!
Calling something an X killer before it's proofed is the surest way to tell it's not. While I eagerly await something that can replace flash/silverlight, let's not get ahead of ourselves.
So [here's](http://i.imgur.com/sEPnf.png) the error, it happens no matter what XAML file I try. In this case it's a file from one of the MSDN samples.
I read an article not-to-long-ago demonstrating how most uses of memoization in JS were actually less-performant than their counterparts. Sadly, I can't find the text now.
Pretty sure that's what has been happening for the past 15 years in JS, and after 15 years of failed trial &amp; error, they've finally realized that the run-of-the-mill JS developer is _not_ going to waste much time learning prototypal OO.
&gt; and additional developer-education needed to learn the quirks of the system (because lets be honest: all class systems have them)? Because the _quirks_ with the current system aren't working. There are literally hundreds of hand-rolled scripts and functions out there aimed at "solving" the JS inheritance problem, and so to say that the current method is adequate is a stretch by any means of the interpretation. While _"you can write perfectly good class-based systems if you really need them using Javascript's built-in prototype-based functionality"_, I could argue that mowing my lawn with tweezers is also possible. So, while the current JS implementation is technically adequate, it's a gigantic failure when it comes to developer adoption. If developers are spending so much time writing countless scripts to do things _that are supposed to native to your language_, then your language's native implementation is wholly inadequate and alternatives must be sought.
Finally, an MVC "microframework" that hits the mark.
So they're basically trying to replicate the Flash IDE but get it to output HTML5 animations... Adobe already has this tool. It's called [Edge](http://blogs.adobe.com/jnack/2011/09/download-preview-2-of-adobes-html5-animation-tool-edge.html). I'm not saying this can't possibly be an improvement, but Adobe has a huge head start. The obsession with "killing" flash is getting pretty old. The main arguments against Flash are typically: - Annoying banner ads - which will just be made with HTML5 instead if Flash goes away. - Slow performance - which HTML5 suffers from, too. Animation takes CPU cycles. Flash has made big improvements in this regard, especially with the forthcoming version (11), and I'm sure HTML5 will too. As it stands right now, javascript-driven HTML5 animations aren't exactly "fast" - in fact, Flash 10 outperforms them. - Security -- okay, finally we have a valid one.. except even that's getting better with easier updating, etc... Still, I can respect that security is a concern. Meanwhile, HTML5 provides no means of delivering rights-protected video. Not that I *like* rights-protected video, but content owners require it and aren't about to change their minds any time soon. Flash isn't going to die tomorrow, but even if it did, people would just end up realizing that the same crap they're sick of seeing built with Flash will be STILL be built - it'll just be built with HTML5
Alternate Title: _How I Implemented the **Registry Design Pattern** in Javascript_
_Yawn_, nothing new here. A good read for jQuery noobs and not a bad reminder for the rest of us, but definitely nothing new here as far as I'm concerned. Also, #5 and #6 are the same; the fact that the author considers them different signals to me that he doesn't really know what he's talking about. This [SO question](http://stackoverflow.com/questions/182630/jquery-tips-and-tricks) contains all of these and more.
So, it looks like this allows passing arguments to timer functions. Anyone know if this will be implemented like setTimeout(0) or setTimeout(10)?
Yeah, I understand I can execute a script periodically to rebuild ctags. Still, I often just forget to update, or it takes a while (for larger C++ code bases). Maybe there's some Makefile-based solution which could be triggered on :w...
&gt;Anyone know if this will be implemented like setTimeout(0) or setTimeout(10)? The minimum interval is clamped in all browsers. E.g. 0 is the same as 10 with Firefox. IIRC with Chrome it's clamped to 4.
Flash Killer ? Flash is not dead and I don't think it will die soon either. There are still things you can ONLY do in Flash (ex.: P2P communication) and it can provide fallback for technology that aren't widely implemented (ex.: WebSocket). Flash isn't only about animation and games.
At work we made an open source implementation of this that'll use the best method available (setImmediate/setTimeout/postMessage, etc). It does everything except eval. https://github.com/NobleJS/setImmediate
Ignore this dinosaur. 
Thank you very much for this, its hard to find best-practice guides on backbone :)
I was there for his talk yesterday. Great stuff!
This is just a question to spur discussion. I think the OP just provided a proof of concept that could foretell the future of apps. It may not be widespread soon, but it's definitely the future. This shouldn't be far from the truth, hence Google's move on the Chromebook and everyone and their mother's move to the cloud.
wow, thanks for posting this... have you ever done any Firefox Addon-SDK based extension development? I wonder if postMessage uses might conflict...
Is there the video anywhere?
Might I suggest checking out [underscore.js](http://documentcloud.github.com/underscore/)? It let's you replace a great deal of nested loop type things with semi-functional alternatives which aren't necessarily better but I find that I screw up much less. They generally give you a new scope at every level of what would have been a loop but more importantly let you say things like _.each(array, function(element) { /*do something with element*/ }); instead of for(var i = 0, n = array.length; i &lt; n; i++) { var element = array[i]; //do something with element } eliminating the need for lots of variables that you all want to name **i** and **n**.
Ahh, that's what I thought. Javascript distinguishes between scope and context. Most languages don't. I think it's a good thing. A lot of people don't. I too wrote a lot of Javascript that simply didn't use the **this** keyword. If you like Javascript now then I think you'll like Javascript more and Object Oriented programming more with a little more experience using **this**. At least, that was my experience.
this is similar to what underscore tries to do with its _.defer function, which currently just does setTimeout(0), but I'm sure will adapt to using setImmediate when it can.
&gt; [Boris Zbarsky (:bz) 2011-09-11 09:50:46 PDT](https://bugzilla.mozilla.org/show_bug.cgi?id=686201#c1) &gt; &gt; It's not clear that this will end up in the spec (for now, Microsoft just stuck it in the editor's draft, but the WebKit folks seem opposed to it). &gt; &gt; Given lack of use cases proposed by Microsoft and the fact that the spec as it stands is definitely wrong, I think we should hold off on implementing this until at least the spec issues are resolved, if not longer. &gt; [Andreas Gal :gal 2011-09-11 14:00:07 PDT](https://bugzilla.mozilla.org/show_bug.cgi?id=686201#c2) &gt; &gt; Wow that spec needs a lot of help first before we can implement that. Windows 3.0 called and wants it's numeric handles back. Any document.write loaded ad can cancel immediates for code it doesn't own. Those handles should be proper capabilities/objects. Also, setImmediate is poor naming considering that the spec explicitly says it's not guaranteed that execution is immediate. Did IE at least prefix this? 
You missed the most important reason to drop flash. It's proprietary. This alone is why I dislike flash.
Your not saying anything that everyone doesn't already know. It's not a stretch of imagination to assume the web will eventually be as feature full as flash. Combine that with the fact that the web is free and open where as flash is proprietary. Flash is dead.
Give the poster a break. Is it wrong to get excited about something new?
Surely you're familiar with the concept of something getting overhyped, building unreasonable expectations and ultimately becoming a disappointment when it cannot meet those expectations? E.g., Diaspora the Facebook killer, Cuil the Google Killer, etc
Hacker News? :)
yeah. nothing else in the world is proprietary... exactly what is your definition of the word "proprietary" - Flash may not actually fit that definition. Furthermore, you don't say anything about advantages or disadvantages of something being "proprietary"... I'm willing to guess/bet that you have a lot of proprietary software installed on your computer and/or portable devices.
Holy crap do I want block lamdas!
If the OP's screenshot is any indication, it could be that you're using a resolution below the minimum of 1024x768? Something to try. Otherwise, you could try asking this on [the forums](http://social.msdn.microsoft.com/Forums/en-us/category/windowsapps), you'll most likely get a response there.
(Copying previous response as the advice is the same :) If the OP's screenshot is any indication, it could be that you're using a resolution below the minimum of 1024x768? Something to try.
The whole point is that there's no timer. The closure will be added to the event queue and will run as soon as the current execution thread and previously queued events are handled. 
Nope, 1440x900. Thanks though, will do.
Thanks for this. It was helpful to get me on the right track.
Honestly, I didn't choose the framework or anything, so I'm not sure what parts of it necessitate using it, but I've been told to learn it. But it's a web app where users have to walk through a process (progress indicator) and at the end the information is compiled in a useful format for them. (sorry for the holding back of details, don't want to risk getting in trouble). So far, to me, I think I'd be fine with some straight up JS and some Jquery but maybe I'll get it after a while.
It is vendor prefixed. In the IE10 platform preview you would use msSetImmediate to get access to this feature in its current state.
...or just use a bootable cd distro.
FWIW, in WebKit both CanvasGradient and CanvasPattern have nothing that binds them to a specific rendering context. There used to be some ambiguity in HTML5 with regard to the behavior of the 'currentColor' value on CanvasGradient color stops (since it implies that the color should be fetched from the canvas element itself), but the spec was changed so we wouldn't have to tie the gradient to the canvas.
Can anyone explain why they have chosen to do module M { export function foo() {...} } instead of what is already a standard with CommonJS exports.foo = function() {...} The latter just seems to be the standard these days, and Eick said in the first slides that they wanted to use the standards already in place.
If your building anything CPU intensive, this would be *very* useful, to avoid locking up the browser. I built my own library to automatically do this (plus some more tricks), just like the many alternatives out there. Two issues I have, first I don't see any point in passing in values, when you can just use a closure do this today. Personally I'd prefer it could take multiple functions instead: setImmediate( task1, task2, task3, task4, ... ) Second I'd also like it if a function being called in setImmediate, has it's 'setImmediate' calls, placed directly after. This is so you can have sub-tasks, like task2b and task2c, which are run before task3. But overall it is nice to see MS bringing new HTML/CSS/JS, just like the other browsers do, which isn't heavily MS specific (like the DirectX transforms).
I'm well aware of many libraries that offer semi-functional alternatives, thank you.
Two issues I have, first I don't see any point in passing in values, when you can just use a closure do this today. Personally I'd prefer it could take multiple functions instead: setImmediate( task1, task2, task3, task4, ... ) Does this solve it for you? tasks.forEach(setImmediate); [task1, task2, task3, task4].forEach(setImmediate); Typically, if you can break something into tasks, you can fire up a web worker to do the work. Do you have a use case where web workers won't solve a "CPU intensive" problem? 
Thanks.
That did it. Nice.
i don't have flash, where can i see it in, for example pdf...
Ahhh, thank you! =)
Follow the link to the Slideshare website. No Flash is no problem as the download link at the top of the slideshow does not require Flash. You will have to make an account if you do not have one. The download is formatted as a PDF.
The player has become faster, but the flex framework has gone backwards and has become even slower than it was. The player seems to be moving into the Director world, targeting online games. 
My shortest version: (function(i,r){r=0;while(i--)if(!(i%3)||!(i%5)r+=i;return r;})(1000);
They should have just called "shamboozle", "shizzle" or "whatever" instead of "class" as this just confuses java developers even more into thinking they can do javascript without actually learning it.
I've created my own (modified) version of a postMessage script from http://benalman.com/projects/jquery-postmessage-plugin/ with solid success. We used it to have resizing iframes and other magic for a client site (even animated!) which was a fun challenge to get working. I would strongly suggest using the above link for inspiration and for consistent use of `postMessage` in all browsers (even IE6) that might help and I'd be happy to dig a bit further if you wouldn't mind just replying with a "yeah -- poke it!". I always seem to find these helps threads, spend some time, then hear "got it bro, nm". :(
yeah -- poke it!
I don't know a ton about Flex myself although it's used here where I work... how is it slower, exactly? Got any good reading material? I'm asking because I'm curious about it -- not because you need to "prove yourself".. I'm genuinely interested in seeing if we should be avoiding Flex.
Yet another.. 
I am genuinely curious, can you point to other libraries that support databases, tables, queries etc.? I wrote the library as I couldn't find any that did those things. Most out there simply support key-value operations, and not structures like tables.
dirtydb ? Ueberdb ? Note: These are key value only afaik
Does this only work on top of SQLite? Like, in WebKit versus the IndexDB in Mozilla? Also, for a more abstracted approach to local storage, take a look at [Persistence.js](https://github.com/zefhemel/persistencejs/)
I didn't downvote you, but I think you might be getting downvotes because the Stream API has almost nothing to do with this post, other than the word "stream." The author of this JavaScript library really shouldn't have used the word stream; "collections" is a better word.
Yes, exactly. They are key-value only, and moreover, they are server side libs. On the other hand, localStorageDB is a client side lib for storing data structures.
No, this is not linked to WebSQL (SQLite or IndexDB) in any way. It's simply a layer over localStorage that emulates a few database like functions. Beneath it all, the data structures are stored as serialized JSON. PS: Persistence.js looks interesting---very advanced. Maybe an overkill for simple apps though.
Yeah, this is a pretty cool project. Nice job. Persistence is a great product. It can sync tables between the client and server, which is really nice. I use it for mobile webkit-based apps (phonegap) and sync it with a mysql back end.
How do you know I am a dinosaur? Frameworks are only useful if they are not a crutch for incompetent people. Today I found a collision in a project I am working between use of conventions from Blueprint CSS and use of jQuery that will cause a failure for IE only without room to repair short of starting over from scratch. What a waste of time. Best intentions are still worthless if the result is crap.
coolio :)
yeah, don't worry. I got sucked into flex from 1.5 till version 4. basically with the new skinning model from flex version 4 it got slower. the reason for this is the skin file which has its own invalidation cycle, akin to the components invalidation cycle. now you use a skin file on a component, and as such you have a component which has 2 invalidation cycles. this is a simplified way of explaining it. on the subject of jobs in flash, banks invested a lot of money in flex, i know this having consulted to banks in the uk and us during the last 6 years doing flex, they are still throwing silly money at it and there will be work in it for a long time. personally i have not got any adobe software installed on my computer and turn down any flex jobs without asking a single question about it.
Cool! What browsers does it support?
It should work on the latest versions of all browsers that support localStorage (Firefox 3.5+, Chrome 11+, IE9 etc.). [Here's](http://www.quirksmode.org/dom/html5.html) a compatibility chart.
What's the problem and where is the link to the issue?
This is clearly awesome. +1
This is clearly awesome. +1
Separation of concerns. Your project would be more flexible and widely useful if it was decoupled from the persistence layer. Offer a way to serialize it and let the end developer worry about how to persist it. You should focus less on persistence and maybe consider adding indexes, type constraints, sorting, aggregation, etc. Make it a tabular data access library. Just my two cents.
Not to be a hater, but the original design patterns were made for C++ and Java and many (most) don't apply to javascript. Eg, What's the point of a command pattern in a language with first-class functions? What's the point of a Singleton in a language with global variables and no classes? Design patterns for javascript would be an awesome idea, but it requires more thought than simply translating them from other languages.
I didn't know that. That is huge. I have come to love Javascript largely for the array and object literals. It makes JSON possible (it *is* JSON), which makes XML seem like a bad joke.
nice. request: SQL and some kind of rowset/cursor object to hold query results.
Where i work, we have deployed PhantomJS using Hundson as a build step. I want to warn you of the slippery slope that this is though; PhantomJS is not a browser (I know that sound stupid but bear with it). We've run into numerous issues during development, with random build failures due to bugs in the JS implementation of PhantomJS, including the Date object, and issues with hidden/visible elements. We're now making the switch away from PhantomJS, using a Selenium runner to run QUnit tests in an actual (target) browser. You have been warned!
&gt; Because the quirks with the current system aren't working. Oh really? That explains the total lack of powerful new software being developed in pure Javascript these days.
I'm surprised that anyone expects loops to create a scope. What gave you that idea?
http://jsdesignpatterns.com/ http://shop.oreilly.com/product/9780596806767.do Maybe there are a lot of people interested on design patterns, no?
I'll wait while you read my reply again since you evidently didn't grok it the 1st time.
http://jsbin.com/aledec/2 this one works. doing $(...).click() only creates an event handler for the currently existing elements. I changed your click handler to be a [jQuery .live() handler](http://api.jquery.com/live/) which also works for elements added later. Generally, you could also use event delegation where you attach a click handler e.g. to the table and get the actual target element via the provided [event object](http://api.jquery.com/category/events/event-object/). $("table").click(function(ev) { alert("target was" + ev.target ); });
Try using [.live\(\)](http://api.jquery.com/live/) to bind the click event to the TD elements (as a live event). .live() binds an event to all elements that match the selector, even if they were created after the live event was bound (the problem is because the TD elements are getting added after the click event is bound as you guessed). To use .live() in your code: $("TD").live('click', function(){ alert('hi'); }); 
Ah, beautiful. I wasn't aware of that capability, and quite an easy fix to boot. Thanks for the help! :D
Count me amoung them! I'm just saying that JS won't get good design patterns simply by porting them from other languages as has been done here. In my perusal of this code, I think that a lot of the implementations are actually much more idiomatic than a direct translation would've been, but some of these patterns just don't make sense at all and shouldn't be translated. Javascript has a different set of problems that plague it than java does. It needs patterns that address those. (eg. MVC is actually a useful pattern for both languages. The command pattern though is not.)
Thanks for the help. It works wonderfully. What I don't understand however is why does that occur? On page load does jquery find all the elements that match the selector and then bind them?
Yes, the way you had it set up was that on page load ($(document).ready()), a click event was bound to all TD elements when .click() (which is actually a shorthand for .bind('click')) was called. The table elements would then be added to the page after this initial binding (when the AJAX requests returned) and so they would have no click event associated with them.
Thanks! You might want to take a look at [Persistence.js](https://github.com/zefhemel/persistencejs/) as suggested by grendian earlier.
If you want to use CommonJS, use CommonJS -- no Ecma standard required. If, however, you want browser caching, network loading without having to use callbacks, compile-time linking with early errors for import/export mismatches or unbound variables, and programmatic sandboxing... well, then, you're gonna need some help from the language. Dave
You're an idiot then.
If they kept it under wraps for a few more months everyone would bitch if it had problems on release, why didn't they test it more? What's one of the biggest reasons we don't have more open source drivers? Developers embarrassed about the code they had to write to get things to work, How bout we give kudos where they are due? Being able to build MS apps in HTML5 and JS/JQuery is a big step in a good direction.
I understand an alpha has bugs. Probably a lot of them. And a lot of restricted things. But when you're asking people to build apps, and give them a tool in which to test them, letting it work on the examples would seriously be high on my priorities for an alpha release. 
You'll need to at least post an error message.
Here's a post I've written about coding phonegap plugins.
Correction- that was actually HTML
&gt; Because sound support on the web is shit, *applause* Especially mobile web browsers. 
Mobile browsers are the new IE6. Their presence is greatly limiting standards adoption on the web. Example: Android's default browser doesn't support SVG *at all*.
I hope I am not the only one that was expecting the web page to have a highly technical and elegant sound implementation that made farting sounds.
This is the error message: undefined:15 ReferenceError: Can't find variable: QUnit undefined:15 ReferenceError: Can't find variable: QUnit It prints that to the console twice and then hangs.
I have abstracted all the functions I am testing so that it really doesn't depend on the browser environment. IE, if a function was going to use the location object it would take an optional argument where you can pass an object that can take the location objects place. It adds a little weight to the code but is really nice for testing purposes.
That can be arranged ;)
That's a pretty stupid comment. Again, I have no idea why one would **expect** that variables in a loop have their own scope. It is an idea that is in a couple languages, not all. C doesn't do it, Python doesn't, PHP doesn't, etc. These are 3 popular languages that do loops just like Javascript.
And that is sort of... exactly what my point was. These are not Streams according to the most common conception of what a stream is. Streams usually refer to file streams or other IO. Given that browser Javascript is getting that kind of stream soon, it creates confusion to make a new sequence type that is called the same thing.
If you want to post to an iframe, remember that the iframe's window object is located at .contentWindow. videoFrame.contentWindow.postMessage(...) I didn't see "contentWindow" in the source you linked to, so that might be your problem.
From the github readme: [three.js - Getting Started](http://www.aerotwist.com/lab/getting-started-with-three-js/)
Where I work, we recently started using [JsTestDriver](http://code.google.com/p/js-test-driver/) to run our qunit tests. It runs all your tests in multiple real browsers, without having to fire up your whole application. We have about 100 tests that run on remote browsers, all within ~15 seconds.
I love this engine. I put together a little PoC a little while back: http://dracsoft.com/tactical/game/
Why is this better than the ones I already know?
Interesting, but motivation needed as ExtraGravy says. Might the style() and getStyle() functions accept and return a single hash? Is the mouse tracking or event handling any better than, say, jQuery?
Main differentiator is that it's under 4kB gzipped, and is still general-purpose (events, DOM, AJAX, animation, selector engine, etc). It can also asynchronously load other JavaScript including third-party JavaScript. So all up it can reduce the impact of first-visit page load time, if that's important.
Thanks for taking a look! I've tried to describe its event handling capabilities as well as I can [here](http://neonjs.com/watch). It's a thin cross-browser wrapper on top of the browser's event registration. I guess in that way it takes a similar approach to jQuery (and most other cross-browser frameworks) in concept, though it's fairly lightweight. It does things like emulate mouseenter, mouseleave, focusin and focusout on browsers that don't support it, it provides cross-browser pageX, pageY, etc for location of mouse events, stopPropagation(), preventDefault(), etc. It even synthesizes currentTarget and relatedTarget on browsers that don't have it. I maintain a test suite for the library to ensure cross-browser compatibility. style() is for setting inline styles and is pretty powerful. If you supply more than two parameters, it does animation at ~60fps and you can have your own easing function and a callback function for when it's complete. It's chainable. If you start multiple animations (even at different times) it still does everything within a single timer and without calling functions inside a loop so it should be performant. To get a style you use .getStyle(). That's not nearly as sophisticated as jQuery since it does no translation into a common format, it's a wrapper on top of currentStyle/getComputedStyle. Neon does have a getPosition() method though which is like jQuery's offset() but with more flexibility, as you can get the coordinates of an element relative to the window, or the document, or any other element: // Get position of selected element relative to body element position = neon.select("div.myelement").getPosition("body"); Feel free to let me know of errata in the documentation or other issues.
Very cool. I'll be testing this out in a current project.
Neat, feel free to let me know how it goes (via here or twitter)
Mr. Doob is a javascript magician. Here he goes again.
Nice website and good documentation, so it gets a thumbs-up from me.
Thanks! I don't understand why many good little open source projects are badly documented. Projects like jQuery, etc - even PHP, come to think of it, are successful in part due to good documentation.
yup, this was the issue. good eye :)
Is there a list of eventnames handled by the watch method ? Are they all handled back to IE6 ? One case I have in head is the mouse wheel.
Apart from the ones mentioned in the docs as being synthesized across browsers (mouseenter, mouseleave, focusin, focusout) they are as provided by the browser at this stage. I find quirksmode.org by PPK a valuable first resource when determining the browser support for events or other features. I haven't done any specific tests or work on mouse wheel events, sorry - it'll just be a case of what each browser supports.
[Learning Three.js](http://learningthreejs.com/) teaches beginners on how to work with this.
I'm intrigued. This looks promising. Great documentation!
Small file size isn't as important as you may think. If I want low file size I will just use straight up DOM.
The problem with support of mouse wheel isn't only basic support : it's always present (don't know for IE6). It is in the difference of registering and on the different values. So you have to test the browser to adjust.
When I started out a year ago or so I wanted just a little bit of code that was only big enough to asynchronously load other Javascript (such as larger libraries) as a bit of a 'bootstrap' - ie not much more than making up a script element with a src attribute and checking when it's loaded. If you load a large JavaScript library asynchronously then at least it won't hold up the initial page load, and the page will still be readable while the JS loads (although the script won't run yet). On a high-speed, high-latency connection, loading stylesheets and JavaScript files can still take a non-negligible time - it all counts. Whether you care depends, I guess, on your application. A good 60% of visitors I personally get are first-time and view only a single page, so they get the full uncached experience, and that can matter to their initial impression - also if it's a landing page for something it can affect conversions, whatever you consider them to be. Of course, now Neon has all the functionality of a pretty decent JavaScript framework though it's still 3.8kB gzipped, which I figured was still small enough that I can just include it (as the *only* blocking external JavaScript request) without thinking. My plan is to keep the API completely stable and to keep it under 4kB.
I see. [Found this here](http://www.adomas.org/javascript-mouse-wheel/). For now, you'd still have to do much of that working around browser differences (wheelDelta vs detail, and accounting for IE and Opera) yourself in your handler, and possibly register on both event names, as I haven't added extra code for that into Neon at this time.
You can use Ubuntu. It has an option to "install in Windows", which will basically create a VM for you. From there, feel free to mess around. Downside - you WILL have to learn to use Linux. Upside - you SHOULD know how to use Linux anyway - it can only help you in the long run. When you're OK with the Linux environment, check out Gentoo.
Actually before I wrote that I was sure that Nodejs still doesn't have a windows version, but apparently it already have :) I'm pretty familiar with linux, I wasn't trying to solve this problem locally, but rather create a solution for other users too, and wasn't sure how to do that. So, if you're looking to run nodejs in windows, head to www.nodejs.org and download the binary :)
I see. It was a good idea, but the time of liveCD / liveUSB distros is more of less past. Solutions are much more local nowadays. I'm glad you're happy with the nodejs binary :)
&gt; fat-free LOL Like jQuery _et al._ are purposely "fat". Let's let the bug reports, compatibility issues, and feature requests roll in, and see just how long the library stays at 4kb. protip: unless you offer a paradigm-shift in the way a "framework" is implemented or operates, save us and yourselves the time and just put your framework on your resume and go about your business. There is probably less than a 1/1e6 chance that this project -- or any of these new "micro" "frameworks" -- will last longer than a year or gain more than 25 users. Quit wasting our time with nothing but a rehash of what's already out there. _Oh look, you use the verb `watch` in lieu of `bind`, how cute. Everyone should use this!_ EDIT: Gutless downvoters, care to chime in? Probably not, just more "microframework" bandwagoners...
Happy?! HAPPY?! I'm flushed with joy. The best part is that I started getting really into Nodejs just at the start of the week, and I've also started a new job on Tuesday, and guess what server-side technology I'm using? I'll give you a hint, it's Nodejs. Honestly I never had so much fun coding like I do now, Javascript is going to overtake PHP in the next 2 years when it comes to server-side projects. It's just that good.
Well, let me give you a hint - Coffeescript. Of course, I come from a Ruby/Rails perspective, but Node does look like it's going to rock all sorts of worlds. Coffeescript just makes JS more palatable :-) (and it IS compatible with Node, of course).
Ah, a CoffeeScript lover. Could you tell me why would I want to switch over to CoffeeScript? what's the advantages over Javascript except the slightly different syntax?
jQuery and PHP both have terrible documentation. It may look nice but the content is lacking, which is why you have to read through the comments on those sites to get anything more than a basic feel for how a method works.
Coffeescript, like most of the stuff coming out these past few years, is at least slightly opinionated. It makes it difficult, for instance, to mistakenly create global variables (it has to be done explicitly). It makes it easy to create classes and modules. Loops are easier. Indentation matters -- instead of using curly brackets everywhere, you use indentation. That's actually not as painful as I expected it to be, because I'm so used to Ruby. Also, it requires fewer lines of code and fewer characters to write code that does the same thing (well - it compiles to Javascript, so...). For me, coming from Ruby and always hating Javascript, it organizes the information in a way that makes sense. I can actually imagine myself writing plain Javascript now, although I do prefer Coffeescript :-)
Why would you want the job of ensuring that all of the above works in all browsers? You must be some kind of masochist. What did you leave out or optimize to make your library so small?
Tells me my graphics card doesnt support WebGL although all the other three.js examples work.
isn't the singleton pattern in JavaScript technically just var obj = {}; ?
Same error. Care to provide a video demo? I've been stuck on picking from the browser graphics libs for a while. edit: works on chrome+mac. downvoted self
I enjoyed learning about the job of a JavaScript framework at low level. I may also be a bit of a perfectionist. To keep it so small, I've just been very conservative about what functionality I have included. I've tried to include all the most-often used features of other libraries like jQuery but leave anything that would be rarely needed (it's easy to extend Neon with modules, which can be loaded at run-time). I've excluded anything that could be done in bare JavaScript almost as efficiently (or more efficiently, such as an each() method). I've tried to minimise having multiple different ways of doing the same thing, so I don't have shortcut methods that are shortcuts to other methods, like hide() or show(). Instead I've trusted that the programmer knows their CSS and can use the appropriate property like style('display', 'none'), etc. I've also hand-optimized a lot of stuff so it compresses well (without sacrificing source readability). I consider it in beta, so am keen for people to report issues with browser compatibility or with the documentation.
Hopefully people can get some use out of it. If not, I'll still be maintaining it, because I use it in my own sites/projects. The key to keeping it under 4kB will be to be very conservative about what to include in the core. I'll accept bug fixes that can be done cheaply, but I'm happy with the core in terms of functionality now. I can always just write external modules to extend functionality that way. It also plays nicely with other libraries (like jQuery) and can be used to load them asynchronously if you like, so you don't need to invest in completely replacing whatever library you're currently using. I have a great amount of respect for other libraries, including jQuery. The "low fat" tagline is an attempt to convey that this one's pretty small.
Well, that sounds like fun if nothing else, and likely a good learning experience. I'm curious what your thoughts are for what you include? I ask because many of the items in your list aren't what I would personally think of as a 'core' offering, especially since many have existing solutions and others are situational at best.
Up-vote cause this guy has done some awesome stuff before and this is pretty cool.
I've written a [rich text editor control](http://tom.typespark.net/neon.widget/demos/richtext.html) based on Neon. It's still *very* unfinished. One day it'll have a website and documentation. Here's also a very, very basic/ugly [animation/events demo](http://tom.typespark.net/neonjs/demos/animate.html). And here's my [test suite sofar](http://tom.typespark.net/neonjs/tests/tests.html) (note: may not be current version - see github for that).
This is awesome (Chrome, Mac OS X)
It includes some features that would be a major headache to get working cross-browser without any JavaScript framework: event registration, CSS-like selectors, simple AJAX requests, animation etc. It includes some features that, while simple, would be used quite a lot and save repeating some tricky code, like addClass() and removeClass(). build(), append() and the like I just think are really cool and flexible and can potentially save a lot of code and make building elements easier. It's true that there are a few features like setAttribute() that really don't save much, but they don't take much space, and they still add a fair amount of convenience (such as when chaining methods). Features I've added but then made the decision to remove include a JSON *encoder*. The code for it is fairly bulky, and I think it's less crucial than a decoder. When *sending* data, you probably don't send as much structured data, and you can always encode simple values as application/x-www-form-urlencoded keys and values, which getHttp() can do for you. But if you want a JSON encoder, I've actually included one as a separate module which can be loaded dynamically, not in the core. I also elected not to include an each() method. For this method it was because calling a function within a loop has poor performance, and I don't think it's good to encourage (call me a guilty of premature optimization if you like). JavaScript's for (;;) construct should be used. I also omitted a set() and get() method to set general properties on an object. They are too simple to just implement in JavaScript and I think setAttribute() would be used more. I'm happy to admit it may also have a bit of personal bias - that is, "stuff I would want/use".
On the one that works, mp3 files and ogg files are specified in audioPlaylist, but in the one that doesn't only ogg files and no mp3s. IE can't play ogg files natively.
You seem to be missing a small amount of code at brmdev.info in the head: &lt;!-- the mousewheel plugin --&gt; &lt;script type="text/javascript" src="js/jquery.mousewheel.js"&gt;&lt;/script&gt; &lt;!-- the jScrollPane script --&gt; &lt;script type="text/javascript" src="js/jquery.jscrollpane.min.js"&gt;&lt;/script&gt; &lt;!-- styles needed by jScrollPane - include in your own sites --&gt; &lt;link type="text/css" href="skin/jquery.jscrollpane.css" rel="stylesheet" media="all" /&gt; After the body tag: &lt;script&gt; $(document).ready(function() { $('.scroll-pane').jScrollPane(); }); &lt;/script&gt; There's also a substantial number of changes to the css, but I think that you'd get more help from the css or web_design subreddits on this.
TIL'd. Ill check this out and see what happens. 
You're a genius and a god. It worked masterfully. 
No go in Chrome 11.
Thanks! 
Wow, wow. Very nice! I can't believe what's possible now in WebGL.
Bah, animations are queueing if I move the mouse around quickly and doing crazy stuff. They're chaining indefinitely when they should be getting cancelled.
Can haz better typing?
You should probably test multiple browsers, for instance Chrome.
Is there a system that enables the use of WebGL as a Canvas? Like emberwind implements?
Only the first 2 HTML5 sounds works for me. Is that normal?
Indeed, serious need of $.stop() if ever I've seen one.
Turns out I wrote `height` instead of `heights`.
I will consider Neon for a new project. Currently I'm using jQuery a lot, but that's because that's what I know. Only thing I use heavily, and Neon does not support, is animate().
Not only that, but a lot of people don't really understand jquery (as far as what's going on under the hood). If people would take 10 minutes to understand how jQuery parses the DOM and uses selectors, they would write faster jquery applications. 
What kind of difficulties could I face with a team that is experienced to jQuery. Will introducing this be a big switch, a small one, or seamless? What type of things might I still need jQuery to handle that neon.js won't?
One thing I will say though - learning jQuery prompted me to want to learn JavaScript better. I had avoided JavaScript for a long time, then started using jQuery - then I started to enjoy working with JavaScript and started to realize 'using jQuery for /everything/ isn't always a good idea' - and started to take learning the fundamentals of JavaScript a bit more seriously. 
jquery has good docs in the form of googling stackoverflow :)
You could use Neon alongside jQuery if you wanted. This would be a legitimate option if your application is using jQuery anyway and you want to minimise conflict. Whether you miss functionality in jQuery or not would depend on how much of jQuery you use. I had an idea to draw up a table matching up jQuery functionality to the equivalent Neon functionality, but haven't done that yet. For now you can have [a look](http://api.jquery.com/) at [the comparison](http://neonjs.com/reference). Neon is thin. There's no question that jQuery is a much larger and more comprehensive library whereas Neon is a thinner layer on top of the browser's interface. If you rely specifically on parts of jQuery that have gone above and beyond just robustly fixing up cross-browser compatibility, then you may find yourself having to code a bit more yourself. If you use jQuery as a lower-level tool, then maybe less so. Neon doesn't really venture into creating its own event types, its own CSS selectors, etc. It doesn't have code specifically to do event delegation, though saying that, it still makes event delegation trivially easy through its cross-browser implementation of things like event.target. These are just examples. Another example is that jQuery is very friendly with shortcut methods like .show() and .hide() - Neon omits such shortcuts and expects you to know what CSS property you want to set eg .style('display', 'none'). In that way Neon expects a little more knowledge of CSS and JavaScript. Neon also has less sophisticated error handing capability on AJAX calls (thing is probably the thing I'd like to fix up most).
I was actually the opposite, I liked JavaScript - but not jQuery. So I tried to use other frameworks like Mootools and learned a lot about JavaScript before I gave in. ;)
Neon's got pretty good animation support actually - it's all in .style() It's as easy as supplying three parameters to .style() instead of two, so you have both an initial and a final value. But it is also highly configurable. You can supply an optional duration. You can choose a pre-defined easing function or write your own, and you can have a callback function run when the animation's finished. Multiple animations run on the same timer and it does its best to sync to 60fps even on older Windows which has coarser timers.
Interesting, but is more fancy aggregation than blog engine.
i feel there are patterns that obsolete the whole namespacing proble and offer up additional flexibility to boot. Instead of loading anything into a namespace, you can put modules in files, and have them define their objects as local vars which are passed as params to a single globally defined dependency manager. Require.js is an example of this, and im currently working on an alternative that is more efficient and versatile by managing dependencies through callbacks instead of a single queue (like require.js does).. it will also handle optional dependencies (instead of crashing when loading a missing file) Https://github.com/jamon/includejs
Hmm, this guy has a pattern fetish :). I came up with this little utility function to create simple modules and namespaces (obviously it doesn't handle dependency management or exporting). I think it works well, but to be honest I don't find myself using it a lot as I try to avoid complex namespacing schemes. var namespace = function(path, context, args) { var finalLink = namespace._generateChain(path, window); context.apply(finalLink, [finalLink].concat(args)); }; namespace._generateChain = function(path, root) { var segments = path.split('.'), cursor = root, segment; for (var i = 0; i &lt; segments.length; ++i) { segment = segments[i]; cursor = cursor[segment] = cursor[segment] || {}; } return cursor; }; namespace("MyApp", function (self, $) { // you can also use `this` instead of `self` if you wish self.hello = function () { $("p").text("Hello World"); }; }, jQuery); MyApp.hello(); 
True, but it also supports URL routing to different pages. Comments can be added through disqus.
Should probably mention that somewhere's. I'd have never know that since your demo sites doesn't appear to do either and the intro page says nothing about it.
 /* The following options *do* check for variable/namespace existence. If already defined, we use that instance, otherwise we assign a new object literal to myApplication. Option 1: var myApplication = myApplication || {}; Option 2 if(!MyApplication) MyApplication = {}; Option 3: var myApplication = myApplication = myApplication || {} Option 4: myApplication || (myApplication = {}); Option 5: var myApplication = myApplication === undefined ? {} : myApplication; */ Maybe I'm missing something, but I don't see how options 3 and 4 are in any way preferable to option 1, as the author asserts. I can see how #5 covers the (fairly unlikely) case that myApplication will be a falsy value other than undefined. But IMO #1 is the best way to write this, as it's the clearest, most direct method.
This is of particular interest to me because at my last job I re-implemented about 85% of [IBM's ICU4J](http://icu-project.org/apiref/icu4j/) in JavaScript ("ICU4js"). Unfortunately, closed source. :-( So it's nice to see something like this! 
So does anyone know why there seems to be this disparity between chrome and other browsers? And which would be better to use then? (I suspect that it is modulo) EDIT: http://jsperf.com/modulo-vs-divide-and-subtract/2 . For comparing a larger integer as well. Now it seems as if the subtraction method is with the larger integer is faster...
Two points that I bet you already know: % is remainder, not modulo; and JS doesn't have integers, only floats. The former is important because of how negative numbers are calculated, which adds time. The latter is important because floating point subtraction and division are not as fast as integers. So, depending on implementation of primitives and operands, one will be only slightly faster then the other. But, as for why one browser reacts one way and not another? That's a crap shoot.
Doesn't seem to do language-only fallbacks. E.g. say there is an en-US locale and some string with "color" in it. Now, someone with a en-GB locale comes along (they should get "colour"), but there is no en-GB translation for that string. In this case it would make sense to check if there is some en-*whatever* translation available instead of using some random language which will be most likely far worse. tl/dr: &lt;my language&gt;-&lt;my territory&gt; **-&gt;** &lt;my language&gt;-&lt;*some* territory&gt; **-&gt;** whatever the default is
What do you think Mootools does better than jQuery?
Can someone please tell me why you would want to do i18n clientside??
This sure is some quirky code. Really quirky code. Since your link is dropped on a textarea, drag&amp;drop events don't fire correctly. This should do the trick: http://jsfiddle.net/GysSY/
Thank you so much! You're my hero!
Because your entire UI runs clientside?
I just added a .store() option using your code into TaffyDB.
I think you can help me with one thing that I don't understand. What is happening in Option 3? 
&gt; you select a unique prefix namespace you wish to use (in this example, "myApplication_") and then define any methods, variables or other objects after the prefix as follows ... can result in a large number of global objects once your application starts to grow As an Emacs user, this is one thing that frustrates me when writing code in Emacs Lisp. 
What browser and version are you using?
awesome! glad to be able to help!
Pretty sure case 3 is useless. The middle assignment would do nothing.
Yeah, I couldn't figure out what that middle assignment was for either.
OK, that makes sense, but in the absence of a benchmark that shows a decent speed improvement, I would still choose the assignment on readability grounds.
I posted links to a site using this a few months ago and received some helpful suggestions about making the library easier to use. I have made some changes and have just posted it on bitbucket. It includes documentation and an example page showing some of its uses. Comments or suggestions would be welcome.
&gt; % is remainder, not modulo Uh... the modulo *is* the remainder... &gt; and JS doesn't have integers, only floats Doubles, technically. &gt; But, as for why one browser reacts one way and not another? Yep, one of these is that browsers can (and do) try to optimize numbers to integers if they're sure the semantics won't change.
Would you mind putting the example generated by mk_example.sh somewhere online for us to see?
API docs? What makes this better than SVG?
I'm new to repositories, so sorry for the silly questions: Is there a way to view the examples, on bitbucket? Or I have to download everything and set it up on my machine?
For one, it works on android phones (though tablets seem to support svg).
Modulo is not the remainder. They are equal for positive numbers, but not negative. -5 mod 4 = 3 -5 rem 4 = -1, also -5 % 4 = -1
I haven't tried it, but wouldn't a shim like [canvas-svg][1] work well? [1]: http://code.google.com/p/canvas-svg/
Good idea. In the meantime, the site that I developed it for is available - http://www.drawyouridea.com/drw.html - which has the same functionality
There is a documentation file present documentation.txt. Originally, I started with SVG but Opera didn't handle images well in SVG so I moved to canvas. This library persists the drawing objects (which SVG would do but raw canvas would not). I have not tried to keep up a feature by feature comparison of SVG as I developed it but I think that the feature sets should be very similar. I haven't tried dragging items around in SVG, though.
No worries, I've only just started using bitbucket. It is possible to download it from bitbucket - go to the downloads page and you will see a line labelled 'tip' - this offers downloads in various formats and will give you a suitable set. In addition, to make it slightly more obvious, I have put the source in to a tarball and set that as a download. This doesn't have all of the revision history (which is probably a good thing). You can find it by going to the downloads tab but here is a direct link to it. https://bitbucket.org/imcdowall/drawlib2dv/downloads/drawlib_download_20110926.tar.gz You can view any of the source files directly by going to the source tab and selecting a file. However, viewing one file at a time will probably not be very helpful so I suggest downloading either the 'tip' set or my tarball. EDIT: Updated the download link as I have just fixed two bugs in the example.
[webgl-2d](https://github.com/gameclosure/webgl-2d) implements a subset.
At least from a quick read of the text and the canvas-getsvg.js file, it appears more that this is a way to use canvas commands to draw on the canvas, and read the commands back later in svg format - so the browser must support both svg and canvas to use this. 
`require()` isn't built into web browsers, where did it come from? Utilities that load scripts in the browser are *usually* asynchronous, meaning that the script won’t be finished loading right away. They usually let you specify a callback function which they run when the script is ready, something like this: require([ "position.js" ], function(){ var Sprite = function(x,y) { this.postion = new Position(x,y); } } );
You might want something like this: function require(files, callback) { var head = document.getElementsByTagName("head")[0]; var func = (function(files, callback){ var n = 0; return function() { if(++n == files.length) callback(); }; })(files, callback); for (var i=0;i&lt;files.length;i++) { var script = document.createElement("script"); script.src = files[i]; head.appendChild(script); script.onload = func; } }; Example of it in action: http://jsfiddle.net/SHaek/11/. So you would place your code in the callback function. Like so: require(["position.js"], function() { var Sprite = function(x,y) { this.postion = new Position(x,y); }; });
Bitmaps seem like a good differentiator. Thanks for mentioning that.
They are two different animals. jQuery is "just" a DOM wrapper while MooTools and others provide more than that. Often having a DOM wrapper is enough, though. If you are doing something bigger, you might benefit from other solutions or solutions that complement jQuery.
This is exactly what I was looking for - bit embarassed I didn't think of that. :P Thanks a lot
You may want to look into http://requirejs.org/ before you roll your own. Same syntax you're looking for too. Its an awesome utility.
Bitbucket? Ew :(
Oh dear god in heaven and hell. You do this: for (var itemName in this.p_items) { // Blah // More blah blah } // -- not level with the starting brace line That makes my brain bleed. I am literally pissing blood out of my nose and ears. I'm going to die. Are you satisfied?! You're braces have killed me!
Something Im working on. It now has a "preferred language list", so you can give it an order of ['en-US', 'en-AU', 'zu'] and if you specify en-GB it'll go to the first available (en-US). It will eventually fallback to the first, non-localised language - e.g if you specify ['zu', 'en-US'] as your language list, and en-GB as your local, it'll first hunt for en-GB, then en-*, then whatever the first choice is from the language list.
This was for two projects, which I am currently working on, which involve only client-side generated HTML. This could also be very useful for projects where JS is the server side component, say, for example, nodeJS
Don't be embarrassed; I like to think I know my way around JS decently enough, but I doubt I would have come up with using a closure.
Well, I'd like to use the right mouse button on a strategy game for flash. I can't. Why? Because Flash *must* show the context menu as an advertisement for Flash (the last option). This doesn't happen in javascript, because no one really "owns" javascript. So, no one really cares about advertising it. That is the difference between proprietary software and community based software.
you're actually half-wrong... solutions exist to allow right click in Flash without ever showing the context menu... because Flash and Javascript can communicate, this can be done very easily... However, the reason Flash can't do it on its own is for security reasons, not because it's proprietary...
So basically you need javascript hacks (like putting a div on top of the Flash or something) for right click to work. What security reasons?
flash allows access to security settings via the right click context menu
Heh, that's the most popular alignment.
What alternative do you suggest? I am using Mercurial for revision control.
But couldn't you get that with the require syntax fom CommonJS? Or am I missing something?
Github, man. It's cliche and popular for a reason -- it's awesome.
Does it work well with Mercurial or does the whole world have to move to Git simply because of the power of Github?
Oh, and I don't know how well SVG handles dragging, panning, zooming and rotation. I have a feeling from the time I worked with SVG that it might handle these well but I'm not sure. My library has been used to create a picture that can then be zoomed, rotated and panned and objects can be dragged around. I suspect that SVG probably can do these but I don't know what performance is like with large drawings.
Ah thanks! I should've looked better :)
thanks. Yes, I understand how to download them. My question is, is it possible to view them as parsed HTML directly from bitbucket? That is, I want to see the HTML run just like any other Web page, not the source. (Clicking on the "raw" button displays the source code as well, though the URL address line in my browser shows .html at the end of the address - I would have thought that button would force my browser parse it as HTML) I found the same thing with github examples. So, in light of my clarification, is that correct, the only way to view examples html stored on bitbucket is to download them?
Is this the 5th snakes-on-a-canvas tutorial posted here OR is this the same tutorial posted for the 5th time?
What exactly are you testing? Are the 2 code snippets even computing the same thing? I can't see how they could be... Why do you have the same code running for both tests? mins = (s/60)|0; It would seem like you'd want to reduce the tested code down to only the code that differed, no?
I'll be honest, the latter. Hg and Git are quite similar though; almost interchangeable.
Hey, what are the benefits of using a "Class" object? Why not just add methods or whatnot directly to the prototype? var Class = { create: function(prototype, extensions) { var ctor = function() { if (this.initialize) return this.initialize.apply(this, arguments); } ctor.prototype = prototype || {}; // instance methods Object.extend(ctor, extensions || {}); // class methods return ctor; } } 
Yes, you are correct, I'm afraid. I suppose that I could have created the example html with all of the Javascript directly embedded. One issue is that would mean a slight maintenance issue (could be fixed within the make script) but I'm also not sure if bitbucket serves the source in such a way as to be 'actioned'. If you want to see the library in action, try http://www.drawyouridea.com/drw.html
Hmm.. I was aware that I keep seeing lots of projects on github and none on bitbucket. It would be worthwhile getting familiar with git anyway. Out of interest, can you give me some examples of how github is better than bitbucket?
You too can have markup like this: &lt;nav id="paging"&gt; &lt;a id="all" href="#" data-bind="click: function () { pageSize(ko.utils.unwrapObservable(people).length); currentPage(0); }, css: { disabled: pageSize() === ko.utils.unwrapObservable(people).length }"&gt;Show all&lt;/a&gt; &lt;a id="last" title="Last Page" href="#" data-bind="click: function() { currentPage(totalPages() - 1); }, css: { disabled: currentPage() === totalPages() - 1 }"&gt;Last&lt;/a&gt; &lt;a id="next" title="Next Page" href="#" data-bind="click: function (event) { navigate(event) }, css: { disabled: currentPage() === totalPages() - 1 }"&gt;»&lt;/a&gt; &lt;ul data-bind="template: 'pagingTemplate'"&gt;&lt;/ul&gt; &lt;a id="prev" title="Previous Page" href="#" data-bind="click: function (event) { navigate(event) }, css: { disabled: currentPage() === 0 }"&gt;«&lt;/a&gt; &lt;a id="first" title="First Page" href="#" data-bind="click: function() { currentPage(0); }, css: { disabled: currentPage() === 0 }"&gt;First&lt;/a&gt; &lt;/nav&gt; &lt;label id="pageSize"&gt;Show &lt;input data-bind="value: pageSize" /&gt; per page&lt;/label&gt; &lt;script id="pagingTemplate" type="text/x-jquery-tmpl"&gt; {{each(i) ko.utils.range(1, totalPages)}} &lt;li&gt; &lt;a href="#" title="View page ${ i + 1 }" data-bind="click: function() { currentPage(i) }, css: { on: i === currentPage() }"&gt;${ i + 1 }&lt;/a&gt; &lt;/li&gt; {{/each}} &lt;script&gt;
I was going to bring up some features like repo Wikis, Fork &amp; Pull Requests, static HTML hosting...but it appears BitBucket has added lots of these features recently (in fact, the way they implemented them seems to be a cheap knock-off of Github; you can tell what they're inspiration was). However, I'd say forking a repository becomes more useful when there are good repositories to fork and quality developers in the community. Github definitely has the larger community. Also, they're UI/UX design is much more polished, but that's somewhat subjective.
None really, the functionality is the same, it just leads to slightly tidier calling code (subjective)... MyClass = Class.create({ init: function() { /* constructor */ }, foo: function() { /* instance method */ } },{ bar: function() { /* class method */ } }); Instead of... MyClass = function() { /* constructor */ }; MyClass.prototype = { foo: function() { /* instance method */ } }; MyClass.bar = function() { /* class method */ }; The former is slightly DRY'er, it only mentions MyClass once, doesn't need to mention prototype at all and is a single atomic block, the latter tends to get messy on larger classes. But its a very cosmetic difference, really just a personal preference. 
How is anything javascript closed source?
Ta. I won't move for now for now but I'll probably set up a test project on github and try it out.
You can do data binds unobstrusively 
If it is never published on the www. I work on a closed-source JavaScript web app for intranet usage.
is this supposed to be more clear? Looks quite confusing.
Knockout 1.3 support unobstrusive databinding. Knockout's power though is that you can achieve a lot of functionality by just using bindings and it makes it much easier to build a testable JS heavy app. I love JQuery and won't write a line of JavaScript without it, but for larger applications it becomes easy to blur the lines between application logic and ui logic. Knockout enforces a nice separation. Also, Knockout and JQuery work well hand in had. Typically I use Knockout for binding textboxexs and spans, but I like to use jquery to handle click events.
The html is confusing and in fact you shouldn't have bindings like that in markup. The most recent version of knockout support unobtrusive binding where you can have that all in a separate binding file. While that may look confusing, the javascript code behind it is pretty straight forward and robust.
It is exactly that. Internal enterprise app.
It's an architecture. Sorry to be rude, but that's what it is. 
Also interesting, is [this](http://www.pocoo.org/~blackbird/github-vs-bitbucket/bitbucket.html). That's fairly old, and confirms my suspicions on where they got their "inspiration". And to back up my claims: https://github.com/blog/936-one-million I couldn't find any information on the number of active users BitBucket has.
I don't understand REST? Excellent. Thank you for pointing that out. "RESTful applications maximize the use of the pre-existing, well-defined interface and other built-in capabilities provided by the chosen network protocol, and minimize the addition of new application-specific features on top of it." &lt;-- That sounds like a "best practice" to me. The architectural constrains REST offers leads a developer down the road of "best practices". Look, I do understand what REST is. You think I don't, but I do. I was using it before Rails made it easy to implement such architecture. 
Why the down votes? I thought that was clever. 
The markup I posted is from the linked tutorial. If there is a better way to use this library then perhaps someone should link to that.
Reddit hates overused jokes :)
"User friendly URL". Is that better? I'd love to hear your side of the story why you think REST protocols must treat URLs as opaque identifiers when Roy Fielding says they don't have to be treated as opaque identifiers. And we all know Roy Fielding is the pioneer of REST. &gt;REST does not require that a URI be opaque. The only place where the word opaque occurs in my dissertation is where I complain about the opaqueness of cookies. In fact, RESTful applications are, at all times, encouraged to use human-meaningful, hierarchical identifiers in order to maximize the serendipitous use of the information beyond what is anticipated by the original application. - Roy Fielding ([source](http://tech.groups.yahoo.com/group/rest-discuss/message/3232)) 
Overused jokes? Nope. Chuck Testa. 
That's true, but then that's a failure of that article at expressing the different ways you can use Knockout. The post is just one person's opinion and style, but it's not the only way you can use Knockout. Here's a post with new features written by the author of Knockout JS http://blog.stevensanderson.com/2011/08/31/knockout-1-3-0-beta-available/ In particular, take a look at this sample. It uses a proposed syntax for external binding, but the new binding mechanism allows you to define any type of binding you want http://jsfiddle.net/StevenSanderson/n7h2A/1/light/
That's true, but then that's a failure of that article at expressing the different ways you can use Knockout. The post is just one person's opinion and style, but it's not the only way you can use Knockout. Here's a post with new features written by the author of Knockout JS http://blog.stevensanderson.com/2011/08/31/knockout-1-3-0-beta-available/ In particular, take a look at this sample. It uses a proposed syntax for external binding, but the new binding mechanism allows you to define any type of binding you want http://jsfiddle.net/StevenSanderson/n7h2A/1/light/
This code is not just adding a closure: $( function(){ // code here }); It's the same as this code: $(document).ready( function(){ // code here }); In other words, the "code here" part will not be executed immediately. It will be executed when jQuery decides the DOM is ready for use.
It's a shortcut to attach handlers to the document's onready event From the jQuery documentation http://api.jquery.com/ready/ All three of the following syntaxes are equivalent: $(document).ready(handler) $().ready(handler) (this is not recommended) $(handler) Your example is the third form. It's specifying a function that will run when the document is ready.
Blocks of code like this can be used to stop memory leaks. You can google circular references for more info.
There are no variables living on beyond their parent's scope in your example. Anonymous functions and closures are not synonymous.
Oh, really? I was unaware of that. I may be wrong about this, but I seem to recall seeing this used multiple times in a single file before. Would doing so ever be necessary? I have never needed to call $(document).ready more than once in a single program.
Why is the second format not recommended?
So if I had code that looked like this... var d; $(function(){ d = 1; }); ... that'd be considered a closure? Or would this be a closure? var d = function()( var e =2; return e*e; } Thanks for the help.
Neither of those are closures. The first just uses a variable in the global scope, the second just uses variables in its own scope. Here's some closures: var nextFactory = function(inc){ var count = 0; return function(){ return (count+=inc); }; }; var x = nextFactory(1); var y = nextFactory(10); x(); // 1 x(); // 2 y(); // 10 x(); // 3 y(); // 20 `nextFactory` returns an (anonymous) function that has references to the scope it was created in. Everything in this scope would normally be garbage collected, but since these return values keep references to them, closures are created. 
I find them elegant and concise.
None of those are closures. Here is one... var a, b = function(c) { a = function() { alert(c); } }; b(42); a(); [JsFiddle](http://jsfiddle.net/W7dZ2/). As you can see, `b()` is called with `42`. `b()` then sets `a` to an anonymous function which alerts the parent's argument. Then `a()` is called, which still has `c` in scope. 
Some modular scripts employ their own document.ready code. Just makes it easier sometimes. I wouldn't say its the best practice, but some developers just like to isolate related code tasks and keep one document.ready script separate from others.
 If you're not sure whether `$(fn)` and `$(document).ready(fn)` really do the same thing, it's easy enough to find out. (By default `$` and `jQuery` are the same object, so I'll use the terms more or less interchangeably. If you've redefined `$`, e.g. using `.noConflict()`, the rest of the discussion would still hold true, but for `jQuery` only instead of `$`.) Open the [jQuery 1.6.4 source code](https://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.js) and find this section near the top: // HANDLE: $(function) // Shortcut for document ready } else if ( jQuery.isFunction( selector ) ) { return rootjQuery.ready( selector ); } `selector` here is the argument to the `$()` function, and `rootjQuery` is assigned in this bit of code which was run earlier during jQuery initialization: rootjQuery = jQuery(document); So in effect, `$(fn)` is doing this: var $doc = $(document); $doc.ready( fn ); and of course that can be simplified to: $(document).ready( fn ); Now regarding the use of these functions once or multiple times, that's just a matter of how you like to organize your initialization code. Each time you call `$(fn)` or `$(document).ready(fn)` before the DOM is ready, `fn` is just appended to a list of ready functions. Later on, when the DOM finally is ready, all those functions get called in the order they were added. It works the same way if you only use one of these functions a single time: in that case, the length of the list is 1. :-) 
Looks good to me. I wonder why you got downvoted.
I guess we'll never know.
If I had to hazard a guess, probably because you're not actually capturing any variables-that-would-otherwise-be-out-of-scope, you're just setting the state of a global variable. Now if in b () you declared some variable that was then used in a (), THAT would be a closure, because normally said captured variable would be out of scope and unavailable for a () to use had it not been for closures.
There is a variable from `b()` that is used in `a()`, and that is the argument `c`.
If you transfer only data (ala AJAX) from the server to the client, you have to generate clientside big parts of the UI (dialogs and so on). So you have to generate strings. I had to make my i18n component too.
 (function($) { … })(jQuery); Would be an additional closure a) isolating the modules variables from global scope and b) making sure that $ is really the jQuery object inside the closure. $(function() { … }); Is not really a closure, but one of the ways jQuery attaches functions to the ready handler. (Calling the jQuery function $ with another function object). The ready handler is called when the DOM is completely available. In contrast to the load event it does *not* wait until all images and other resources are loaded.
If I ever have to have a website that needs to process faster than 32 million closure reads per second on Opera, I may consider using prototypes! In all likelihood? Premature Optimisation
I always preferred the prototype way, the closure way just seems weird. If I want private variables I just add an underscore to the name. Done.
Valid point.
I don't understand why people feel like they *need* private variables. Using a underscore gets the point across.
You don't need to process 32 million function calls for this to show a difference. You only need thousands, which is very easy to do with a javascript web app.
It's just a matter of preference. I find using closures + private vars easier to read and write and that I make fewer mistakes. Underscores may get the point across but I've seen too many cases of their "publicness" being abused.
What happened to the IE benchmarks? I always find myself optimizing for IE since Chrome and Firefox are usually fast enough.
I was profiling a JavaScript ray tracer's code and noticed it spent a ridiculous amount of time calling Prototype's class() function for vectors. I decided to rewrite the code to use proper prototypal inheritance and managed to get about a 30% increase in speed just from removing Prototype.class() from the Vector() function's definition.
I find this benchmark particularly interesting myself, mainly because I work with node.js.
Well the rest of the quote from Donald Knuth about premature optimization is: &gt;We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3% This exercise just points out the inefficiencies of the Closure code. It'll be up to the developer to decide if their implementation is critical code or not.
Ditto. This is useless to me.
Just ran it in IE8 on XP. Terrible performance, so the graph is pretty useless. Here are my results: Prototype init: 133,720 ops/sec Closure init: 52,931 ops/sec Prototype read: 832,996 ops/sec Closure read: 965,673 ops/sec Prototype write: 458,512 ops/sec Closure write: 606,141 ops/sec
Because the other ones are preferred. More specifically, IIRC, the third one is the preferred way to do it, the first one is just there for backwards compatibility. We're all better off if programmers would stop questioning style guides and just stick to them rather than try to be clever. You don't write for the interpreter, you write for the human reader, who might be yourself in six to twelve months wondering WTF you were thinking at the time.
I wish I could properly attribute the following quote, but alas, I can't seem to find consensus on the origin. Regarding Python's attitude to private variables, ["we are all consenting adults here"](http://mail.python.org/pipermail/tutor/2003-October/025932.html). Frankly, if a developer can't be bothered to respect a private variable in a class and manages to screw something up, it's their fault for coding incorrectly; you don't blame the language when you accidentally implement an infinite loop or an O( n^6 ) algorithm, nor should you blame the library developer when you misuse the library. If it turns out that using closure-based modules in Javascript is *orders of magnitude slower* than prototype-based modules, then do you make the conscious decision to sacrifice performance in favor of readability? In all fairness: if it does help you read and write code and make fewer mistakes, then there is something to be said for that. It's just unclear to me where the line is drawn between "benefit to developer" and "really, really slow".
30% is impressive. Was it an easy rewrite or was the syntactic sugar of Prototype extremely helpful in writing the code?
Michael Bolin (one of the Google Closure guys) wrote a good post about the performance differences: http://bolinfest.com/javascript/inheritance.php
I agree with your remark about consenting adults. However, corners will be cut, mistakes will be made and conventions will be ignored. Don't get me wrong, I do use prototyped methods, but only in the cases where any performance gain will actually be noticeable. If I would have to guess, more than 99% of the code I write is run only a handful of times per user session. To me it makes sense to optimize that code for maintainability, not performance.
For objects that don't inherit anything the change was as easy as going from: Vector = Prototype.class({ init: function(x, y, z) { this.x = x; this.y = y; this.z = z; }, ...more code... }); To this: Vector = function(x, y, z){ this.x = x; this.y = y; this.z = z; } Vector.prototype = { ...more code... }; Almost doesn't seem worth it considering the performance costs. If an object extends another then the code is somewhat more ugly and verbose than the Prototype equivalent.
A million reads and 2/3 million writes a second is more than you're likely to need on a JS app.
JavaScript does not have classes, so what is it you are actually comparing, property assignments versus function calls? You did not need a benchmark to guess at what would be faster to call. Furthermore, your test demonstrates use of constructors and not closure. Speed in JavaScript always comes down to only two items: 1) look ups 2) operators If you don't understand how those work your code will not be fast and your benchmarks irrelevant.
&gt; so what is it you are actually comparing, property assignments versus function calls? No, it's function calls in both cases. It's comparing: 1. Looking up the method directly on the object versus walking up `.prototype` to find it. 2. Having a method access the object's state through its closure versus through `this`. 3. Creating a new method on each instance versus storing them once on `.prototype`. The test correctly validates what it says it does. 
This benchmark is unrealistic. No real program has an execution pattern like this. I can make any small difference bigger by multiplying it.
&gt; if a developer can't be bothered to respect a private variable in a class and manages to screw something up, it's their fault for coding incorrectly; That's a nice idea, and I have some sympathy with the point of view myself, but speaking as a developer *I've* been whacked far too many times by *other people's* abuse of private variables to agree with this argument. It's a nice, simple, pat argument that assumes: * the original writer is the only person ever responsible for a piece of code * that nobody ever inherits anyone else's code * that nothing is ever built on top of other people's code * if you do end up building something on a foundation which through no fault of your own turns out to abuse this sort of functionality, you're al ittle bitch who had it coming And none of these things are reasonably true. All in all it strikes me as programming's equivalent of "you got raped because you dressed like a slut" - it's convenient and pat, and allows people to dismiss a difficult or unpleasant incident as the fault of the person who brough it to their attention (rather than... you know... anyone else whose fault it might be), but while it's emotionally appealing it's also ridiculously simplistic and hugely unreasonable. :-( The fact is that bad code *usually* harms many more people than just the guy who wrote it... and very often it doesn't even harm *him* (eg, if he's moved jobs, or someone else has inherited the project).
I am inclined to agree. 
Nice, it's great to see that it was such an easy (relatively) switch to increase the performance by a huge margin!
100% with you on "if it isn't a bottleneck, make it easy to maintain"!
You're probably just seeing immediately-invoked anonymous functions (IIAF) mixed in with jQuery's `$().ready()` mixed in with normal anonymous functions (AF), which can all look alike at first glance: (function(){ // IIAF myApp = myApp || {}; myApp.init = function(){ // AF $(function(){ // jQuery().ready() myApp.isInit = true; }); myApp.mod = (function(){ // IIAF return function(e){ // AF $(e.target).show(); }; })(); }; })(); The reason you see the outer-most AF is typically to silo your code in it's own execution context, so that you can use local variables freely without worrying about polluting the global scope.
_**NEWSFLASH: NATIVE LANGUAGE FEATURES ARE MORE PERFORMANT THAN USERLAND CODE**_ p.s. most of Crockford's pearls are not directed towards extreme optimization; they are more closely related to code readability, maintainability, and doing things in a way so as to mitigate the _bad parts_ of Javascript. He's not Resig, eternally looking to optimize every line for performance; he's more of the PM that is looking to get an entire team to all use the same idioms in an attempt to provide for a saner JS development environment.
Agreed, there is definitely quite a bit of wishful thinking involved in assuming the fault lies entirely with the developer using somebody else's code improperly. Unfortunately, in Javascript, it appears a choice must be made: actively *prevent* people from doing the wrong thing (in the same way that using private variables in a language that supports them does), or run extra fast (because using private variables apparently incurs a rather significant performance cost). As menno mentioned in the other reply to my comment, if the function gets called only a few times per session, then increased performance is not really worth the loss in maintainability/usability. I do have to argue with the analogy of "you got raped because you dressed like a slut": the victim there did not actively attempt to violate some set of rules and suffer consequences resulting from that, whereas the developer knows full well that touching private variables is not something he's supposed to do, but does it anyway. I'd say it's more like jumping into someone's backyard when there are signs posted everywhere that read "BEWARE OF DOG", and then s/he got mauled by a dog. I understand that there's the "it can be done, so it will be done by someone" mentality, but until good factual evidence proves otherwise, touching private variables in Javascript that are so marked by an underscore affix is akin to changing the scope from "private" to "public" in C++ header files. One of them is just easier to do. EDIT: It occurs to me after writing this that your argument focuses on preventing bad coders from leaving unmaintainable messes. It also occurs to me that that satisfies the "good factual evidence of severe harm" I mentioned. Guess it's time to start thinking about moving non-performance-critical code into closure-based modules in the future!
What did you use to profile it?
It's not that surprising really. The closure approach is effectively creating new "methods" each and every time an object is created, whereas the prototype approach creates them only once and shares them among all instances. If you're creating thousands of object then the difference will be significant. If you're creating one or just a handful of objects of a given class then the different won't be noticeable. 
I profiled the code using Firebug and Chrome developer tools. The 30% number itself comes from the time the ray tracer takes to render the same image. Firefox seems to spend a lot more time (something like 10x) than Chrome creating objects (in any manner.) Therefore the slowdown caused by the method Prototype uses was much more apparent in FF. In Chrome, the speed improvement was still a bit above 10%.
It doesn't assume any of those bullet points! * Everybody knows what underscores in front of variables mean. If they screw up the code, it is their mistake. Same argument for not blaming the language if you code an infinite loop. * Same as bullet 1. * Same as bullet 1. * Same as bullet 1. These are all the same argument. The argument is actually nothing like the "you got raped ..." comment. It is more like, "you rolled your vehicle because you ignored the 15 MPH sign around that corner". Absolutely obvious, everyobody knows what it means, and you decided to go 55 anyway. 
I'd like to make a general comment in reply to most of the comment posted here. First of all using underscore for private variable is a bad idea, because it has a major downfall when you need to do inheritance (and you never know when you will need to extend a class). If class B extends class A and class A has a "private" field named foo and class B wants to have a "private" field named foo, well they will use the same variable and you might never notice it until it causes some nasty bug. The point of the comparison of speed is ridiculous, because the difference of speed is very rarely significant in real application. It only happened once in my life that for 1 class it made a significant difference in a profiler to use prototyping v.s. closures. If you really want to optimize your application, use a profiler and you'll realise there are thousand of thing in your application that are slowing down your application more that using closures. Also using closures has advantages that are very interesting. You don't need to care about binding "this" forever. With a proper implementation of closures, var foo = new Foo(); foo.bar(); will give the same result has var foo = new Foo(); var bar = foo.bar; bar(); Also, if you realise that a class is slowing down the application you can always transform it later with a prototype approach. So don't fall into the trap of doing optimization that won't change anything early in the design of an application. 
**NEWSFLASH: Closures are native**
They are not the native construct for creating instanced objects, though. Nice try junior.
Then maybe you should have been more specific. Your comment implies this is obvious simply because prototype inheritance is the normal way to make something class-like (not object, the fastest way to make an object is "{}"). Both prototypes and closures can be effectively used for similar things. So the results of this benchmark are not that obvious, and it is nice to see the results.
Hah. That's what I get for replying while groggy. Mea culpa, didn't parse it properly.
That isn't the point. A benchmark is meant to make large calculations to gauge how quickly code executes. You will most likely never make that many calculations, true, but javascript is growing in popularity at a considerable rate. This makes it reasonable to assume that increasingly complex code will be written in javascript so knowing what might cause slow downs is important. 
More specific....did you not RTFA? If you had, you would have understood what I was talking about. There are probably hundreds of obtuse ways in which one could create an object instance (what you might call "class-like" wherever you are) with instance methods in JS, but my point is that it should not be a surprise to anyone that the native way of creating these objects -- by using prototypes -- is the most efficient. This is as fundamental as all of the Chicken-Little type posts around here with the \*brilliant\* revelation that vanilla JS outperforms jQuery.....oh no shit?!? /s
If someone abuses private variables, of course it's their fault if something bad happens. However, I took BlitzTech's comment as a hand-waving argument to imply that if someone abuses private variables then it doesn't matter, because the only people who are harmed are the people who had it coming anyway (ie, the original developer), and it's that implication I was addressing with my comment.
Honestly I have never cared much for many of Crockford's suggestions. He seems to view writing code as more of a rigid science than an art form which I think is a huge mistake. If programming weren't an art then anyone who knew the "rules" could do it well which in my experience is not the case.
"Belated pessimization is the leaf of no good." --Len Lattanzi
something's wrong with that initialization code var person = function(name) { return { 'get_name': function() { return name; }, 'set_name': function(newName) { name = newName; } }; }; var b = person('John'); calling b.getName() returns undefined..
Oh, I didn't read his comment that way at all. I can see that if you assume underscores mean private in some library, but some previous developer didn't think so, there might be issues. But come on. Even "real" private variables don't guarantee you anything. If someone else worked on code before you, and they were an idiot, you are going to run into problems.
Very nice. Thanks for posting this.
try `b.get_name()`
If you don't understand prototypes and use them, you are just fooling yourself about javascript and anyone who looks at your code.
Have you done any kind of progressive code isolation to whittle the codebase down to the smallest complexity still capable of provoking the leak you're seeing?
lol talk about a /facepalm moment.. thx
I probably would have done the same, really who still uses `_` when naming methods?
We are in the process of trying to narrow down the culprit, but our in-house framework is all over the place and pretty old. I thought I'd post my question now since it seemed like an odd occurrence. Most people are reporting that IE9 is cleaning up a lot of their leaks, not enhancing them.
Can you download the IE10 platform preview and see how it compares? http://ie.microsoft.com/testdrive/Info/Downloads/Default.html
Please people.... Stop using the underscore to wipe your privates.
But that's not *actually* private. The point of a private variable is to avoid outside access. Sure, I can see the leading underscore and think, 'oh, I guess I shouldn't use this,' but that is completely different from actually making outside access *impossible* which is actually the point of private variables. I suggest a mixture of the two: function Person(myName) { var name = myName; this.get_name = function () { return name; } this.set_name = function (newName) { name = newName; } return this; } var person = new Person('maushu'); window.alert(person.get_name()); // maushu person.set_name('o_hai_mark'); window.alert(person.get_name()); // o_hai_mark This creates actual privacy and is not done in the closure format. I can't speak to the speed of this method, though.
I'm curious how it would stack up against the following closure performance wise: (function(){ var _name; Person = function(name){ _name = name; }; Person.prototype.get_name = function() { return _name; }; Person.prototype.set_name = function(name) { _name = name; }; })();
No. I will only stop when javascript has proper syntax to support them. I will not use ugly hacks. THESE ARE MY DEMANDS.
Technically, it still uses closures.