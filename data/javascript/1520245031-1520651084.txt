&gt; a function that receives boolean configuration parameters is bad design to begin with and should be avoided as much as possible. Can you explain why? Thanks
 VUE is lightweight, quick to learn and it is something between React and Angular. I find it fun. React is whatever you make it to be, but learning devops and endless libraries for your use case might take a bit longer. Both can be server side rendered for SEO bonuses. Both have easy CLI’s that let you create a starter project. If you have 3-4 days to learn, get Maximilian Schwarzmuller’s Course on Udemy and learn VUE2. If you have a week or more, learn react. Max, Stephen Grider, Andrew Mead have great courses on React-Redux-Router. Bonus of learning React is you will learn React Native much quickly later if you choose to. Learn once, code everywhere :-) 
It should refer to object instance, not the execution scope. Execution scope is irrelevant.
"Refreshing little parts of the page" sounds like it is possible to do it without libraries like Vue or React., vanilla js (or jQuery, since it's already there) should be sufficient. Vue/React might come in handy when there's more interaction/logic running on the client.
Wtf is this shit lol
Just let people format their own phone numbers. They know better than you.
Lots of Boolean parameters usually means that there's some sort of state machine in your code that you haven't explicitly turned into a state machine. For example, take a traffic light. It has three lights, all of which can be off or on. We could turn that into an object: { red: true, amber: false, green: false, } This shows the traffic light state where the red light is on, and the other two lights are on - all the cars are stopped waiting for the light to change. Except what happens if something somewhere returns the wrong value and you start passing around the following object? What does it mean? { red: true, amber: false, green: true, } Now both red and green are true, which is clearly an invalid state, but it's represented in the same way that a valid state is. Our "view" code might try and display both red and green lights, which is obviously going to cause not a little bit of confusion. I'm reality, there are only four states a traffic light can be in - "go", "about to go", "stop", "about to stop". If we instead have an object that doesn't tell us which lights should be on, but instead tells us which state we should be in, it's generally easier to keep everything in a real, known state, and you don't end up accidentally showing the red and green lights at the same time. If we get into an incorrect state, it tends to be easier to notice (it's the default case of a switch statement, usually), which saves us from making so many checks all over the place. Hell, with something like typescript, we can even statically prove that we'll always be in a valid state. There are other problems with booleans as well - for a start, there's only two values, so if you try and extend a Boolean parameter by adding another value (yes, no, and sometimes) you'll end up in trouble. Additionally, they aren't always clear in parameter lists (but using named parameters helps a lot, which is what this article is basically suggesting). However, the biggest issue, at least in my eyes, is that they almost always imply some sort of implicit state machine that should be made more explicit.
I'll try to give you an explanation of rxjs in 2 ways. 1 is a bad analogy and the other is more technical. Hopefully one, or both, will help. 1. Streams can be thought of as water pipes. On one end you have the input, usually a subject, that emits new items into the stream. Then you can have any number of observable operators between the initial input subject and any outputs you want. Outputs are when you subscribe to the stream. Basically something goes in the input, flows through all the connected operators, and finally gets seen by the output subscriptions. In between you can use operators to both change the values going through the pipes and how the pipe itself handles values flowing through it. But like water pipes you have an initial input and then other code doesn't see the stuff until it comes out one of the outputs like a faucet. 2. Observables are just promises that can resolve more than once. A promise is always 1 asynchronous action that resolves 1 time with a final value. An observable stream can resolve any number of times and each time it resolves the final result will be seen in the subscription. So basically an observable is like a continuous promise instead of a single atomic promise that only ever finishes one time. I hope that helps.
React is the [most popular](http://www.npmtrends.com/angular-vs-react-vs-vue-vs-@angular/core) by far. It has the most support and largest eco system. In the beginning it shouldn't be a question which to pick. Despite what some people claim, it is very easy to learn because it is actually tiny. The entire api could fit written on your palm. Compared to Vue alone it is a fraction, perhaps 1/100 of what you'd have to study. Even less if you compare it with Angular. A good starting point is [egghead](https://egghead.io/courses/react-fundamentals), takes an hour and you know React. 
What's a computer?
Yes. Server rendered first renders the page on server and sends down a mock html document which looks like your app but no js interaction. This html requests the actual app scripts and the original page loads in a second or two depending on your bundle size; this brings back js interaction. Look up Next.js (React) and Nuxt.js (vue) once you learn the library you want. Not difficult. 
Binding events always leads to this, even in your own projects. It can get in your own way. Thats why I prefer using event attributes in my projects. There are some who see this all as a benifit, as it sort of obfuscates thins from the mythical hackers who are digging into your app. I have never been able to warp my brain into agreeing, but you got to obey your dev lead.
I encourage you to check [Marko](https://markojs.com/). It may be simpler and more straightforward to use than React or Vue, especially if you are starting out. Here's a [video overview](https://www.youtube.com/watch?v=i6eZA8Y_GgA) by one of its creators. If you're thinking about using JavaScript on the backend as well i.e. to have only one language for the whole application, check [Huncwot](https://github.com/zaiste/huncwot). It's a tool I created to teach web programming to newcomers.
Aw geez, now you've done it, you broke everyone's collective brains. A quick way is to just make .html files, and save them wherever you want. They open in a browser. The ultimate way is to get a web server. Ideally, you install and run one on your dev machine. That is not crucial now, but is a vastly underrated way to learn things in a production-like environment. There is a thing called WAMP you should look into.
Your benefit can benefit a lot from using framework other than using the past conventional means as you will be able to do a lot with much fewer tool. That means that modern frameworks will reduce the amount of code and work needed for new features, improve maintainability, integrate better with other libraries and ease the learning curve for new peoples on your project. I would definitely recommend porting your project to a framework as soon as possible. You will notice that your project will become much more structured and easy to come back to after periods of time in between coding. As for deciding what framework to use, I would suggest that you check out react or angular simply because they have more support and there are many jobs offer for you should you be interested in getting a job afterwards. Therefore, if you need to learn programming languages from scratch, I will suggest that you go to a good programming school like Holberton School (https://www.holbertonschool.com/) and learn programming from scratch. Go there and ensure that you raise your competency levels in various frameworks and in the end you will have a much easier time in doing projects. Good luck. 
https://github.com/gpujs/gpu.js 
If you guys are interested in learning Vue, get [Vue JS 2 - The Complete Guide (incl. Vue Router &amp; Vuex)](https://www.udemy.com/vuejs-2-the-complete-guide/), it's a fantastic course. Max also has a *very* indepth React 16 course and Angular 5 course, though I can't speak to his Angular course as I've never taken it. I've purchased several of his courses (haven't watched his Nuxt.js one yet), they are all excellent. He's killing it with video tutorials.
&gt; [React] isn't an arbitrary language hack to make html into something it isn't Can you explain this in different words? I don't understand what you are asserting. Are you commenting on the "JS in HTML"/"HTML in JS" discussion? In other words: template DSLs vs JSX or plain render functions? &gt; React is a javascript-centric pattern around functional composition. Can you give examples of what you mean? &gt; The amount of material to study [React] to get going and the cognitive overhead in general is very small compared to templating oriented frameworks which ship their own syntax and emulators [Gitlab's dev team praised Vue on it's simplicity and speedy onboarding experience.](https://about.gitlab.com/2016/10/20/why-we-chose-vue/#simplicity-and-ease-of-use) I definitely agree not having to learn a whole new DSL is nice, but I think you're overestimating the cognitive load of learning Vue's template DSL. Most web application UIs are accomplished with some combination of list rendering, conditional display and dynamic styling - that's not a lot of syntax to learn. I'm sorry if this comes across as combative (I hate how that's the default tone of discussion on Reddit whenever folks don't 100% agree). I'm really just curious about your assertions. I picked up Vue as my first SPA framework and use it for personal projects and at work we use Angular. I don't have much experience with React outside of a few tiny toy projects, I'm genuinely curious if I should invest more time in it.
Vue has a much lower learning curve than React, though they share some similarities. The biggest difference would probably be JSX, which you can use in Vue, but I don't think many people do. You might want to spend an hour and check out this [vue crash course](https://www.youtube.com/watch?v=z6hQqgvGI4Y). I haven't watched it so can't speak to it, but the title sounds worth the time and it has a high view count. Also worth your time is to check out [Academind](https://www.youtube.com/channel/UCSJbGtTlrDami-tDGPUV9-w/videos), scroll down until you [see these vue videos](https://imgur.com/a/sNDPa) and check those out. Those are the videos that got me into vue. If vue is something you want to continue with, I can't recommend Max's course on Udemy, [Vue JS 2 - The Complete Guide (incl. Vue Router &amp; Vuex)](https://www.udemy.com/vuejs-2-the-complete-guide/). He also has a *very* in-depth React 16 course on Udemy I highly recommend if that's the way you end up going. 
I'm looking at integrating with PrintNode.js You host a client app on your computer where the printer is connected, and then you can send print jobs via their api from the web app, and those get pushed down to the client which then sends to the printer. It allows pdf and raw zpl prints. I'm using this mostly to get the zpl prints. I haven't found a better option besides writing my own client app for each operating system. I was hoping node.js and electron would have a good library for this, but there are issues with most, so I'm going with a paid solution for now.
Reading through the source. What is the concept of a "kernel" ?
I don't know how to do the formatting right.
It's even worse than that. He went to other projects such as Selenium and aggressively made PRs to edit their changelog to remove lines like "PhantomJS deprecated" saying that PJS is fully alive and well as he is working on it (while subsequently complaining that he is doing all the work and telling them that they are welcome to contribute).
I learned Vue after learning React and I think Vue is harder to understand. There’s so much magic going on in Vue. It just *feels* weird to me. With React, everything is explicit, and it’s easier to visualize how all the components are connected (in my opinion). 
The snippet is too short to fully understand the context, but yes, that looks _very_ hacky indeed. What was the intent there, and how is it being used?
Why do you need a singleton class? Why not just use context?
The intent is to avoid using the withRouter function from react-router. My colleague wants to expose push/pop history functions from a single instance of the browserRouter component from react-router. He does this by taking a reference to the router (ref="router") and then exporting this instance by doing something like module.exports.push=this.refs.router.push
Because in order to write .length &gt; 0, they first had to create `imagesNotLoaded` with `Array.prototype.filter`: const imagesNotLoaded = res.filter((status) =&gt; !status.loaded); if (imagesNotLoaded.length &gt; 0) { ... } As I said in my comment `imagesNotLoaded` isn't used for anything else. 
Okay, so following your argument: `const imagesNotLoaded /* name for clarity */ = res.some((status) =&gt; !status.loaded); if (imagesNotLoaded) { ... } ` I would have simply opted for a classic for loop, where finding the first non-loaded file would be blurted out in the error warn. However, you were too quick to say it's unused. ` if (imagesNotLoaded.length &gt; 0) { console.warn('🚨 [loaderz] some image(s) have failed to load:', imagesNotLoaded); } ` That means it's going to be blurted out if there's any errors. With filter, you have an array you can enumerate. Your point is moot. 
Yeah, and that's the sort of uncertainty you wouldn't want in your project. You basically have to inform everyone who is and will be working on this project to not use these methods anywhere outside of React, either in a util or a redux rehydration from the server, for example.
Please stop adding “like a pro” to titles. 
what possible reason could you have for wanting to let this happen? Any sort of white paper you could point me to about this? 
Just experience. There are too many variations in phone numbers for automatic formatting, and doing it wrong looks worse than not doing it at all.
To me `this` is important to use in a `new` constructor. Makes things clear and possibly allows for some optimizations regarding object creation (see https://mrale.ph/blog/2014/07/30/constructor-vs-objectcreate.html, which I think was posted here a while ago?). But I'm also new to JS and coming from C++. 
You're right. I missed that.
why don't you just use the history module: https://reacttraining.com/react-router/web/api/history
I would counter with: breakpoints is love, breakpoints is life 🙂
Yeah, but I learned about console.count and console.assert, so despite the reek of naiveté, OP gets my upvote 😐
Unfortunately, it seems that the Webpack team opted to ship the v4 code first, and finish updating the docs later. Personally, I would have waited another few weeks to publish v4 final so that the docs were ready and the ecosystem had a bit more time to update. Looking at the Webpack docs repo, [here's the PR for merging in the v4 docs branch](https://github.com/webpack/webpack.js.org/pull/1856). It was opened up a week ago, but not yet merged in.
&gt; In other words: template DSLs vs JSX or plain render functions? Almost. JSX is a dsl, it doesn't get parsed but transpiled, thereby retaining scope and all assumptions. Templates don't do that, they break everything and state has to be pumped back in. &gt; Can you give examples of what you mean? const A = props =&gt; &lt;div&gt;{props.text}&lt;/div&gt; const B = () =&gt; &lt;A text="hello" /&gt; Impossible in a templating framework to refer to A from B, unless you'd make A global or register it in B. That's the simplest inconvenience, but depdency injection gets worse. Composition also means that you can literally compose, also impossible otherwise: const Inject = text =&gt; Wrapped =&gt; props =&gt; &lt;Wrapped {...props} text={text} const A = props =&gt; &lt;div&gt;{props.text}&lt;/div&gt; const B = Inject("hello")(A) &lt;B /&gt; // -&gt; prints out "hello" &gt; Gitlab's dev team praised Vue on it's simplicity and speedy onboarding experience And later on they rewrote their app with Vuex because they went against a wall. The same would happen with React and seState of course, so it's all relative. &gt; I definitely agree not having to learn a whole new DSL is nice, but I think you're overestimating the cognitive load of learning Vue's template DSL The dsl revolves around a single function signature: React.createElement(name, props, children), that is literally it. I don't think i overestimate it, because that dsl doesn't block you from having types, 
You don't have to manually wrap the value in a promise as await does that for you. From [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await): &gt; If the value of the *expression* following the `await` operator is not a `Promise`, it's converted to a [resolved Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve).
Cool. I thought I got an error at one point by not using a promise, but it may have been caused by something else, so I just assumed it needed to be a promise. Thanks!
You do if you're not sure if those values are going to be promises are not. But this is also the downside of this approach: its forcing all uses to be asynchronous. It's not just the con "return will be a promise", it's that if you aren't providing promises, you're getting forced into an asynchronous behavior that otherwise wouldn't be. Generally, if anything doesn't have to be asynchronous, you wouldn't want to make it asynchronous and instead let the callers await any promise values before they get passed into your function. 
It sounds like you haven't done much programming before? If so, I'm afraid there's not really much you can do to plan this enough to not have spaghetti code at the end. Even the best programmers rarely get to avoid refactoring entirely, especially when it comes to coding new things.
I would only accept a Promise as an argument if the function was *always* going to be asynchronous, so that there would be no conversion of previously synchronous functions to asynchronous just to support the Promise argument. For example, I frequently use some curried map functions, such as: const map = mapFn =&gt; arr =&gt; arr.map(mapFn); This is a synchronous function, so I wouldn't accept a promise as either argument. However, in an asyncMap function, such as below, I would happily accept Promises as arguments because the function is already asynchronous: const mapAsync = mapFn =&gt; arr =&gt; Promise.all( Promise.resolve(arr).map( Promise.resolve(mapFn) ) );
so many "simple state management" packages these days
What is the alleged benefit of not using withRouter?
“Looks weird”, or “don’t want to wrap my my class in a function just to inject something”. Things like that.
Good call
I actually have quite a bit of programming and I understand Javascript pretty well. I'm just looking for how others would approach this. I will say that most of my experience is back-end though.
Thanks for the thorough response, you bring up a lot of great points! I was confusing simplicity with easiness - your point about complexity really rang true for me. Vue's SFCs definitely make composition awkward, although it's not something I've had to struggle with yet. (Tangential but seeing that chain of `=&gt;`s makes me wish Javascript had Elixir's pipe operator)
Tell them: Wrapping a class in a function is **[the recommended pattern for higher-order components](https://reactjs.org/docs/higher-order-components.html)** in React's own documentation.
Yeah show this thread to your coworker. Don’t do this
You can check http://twinery.org/ and source code https://github.com/tweecode/twine
Yes, I know, there's a whole legion of react form implementations for React out there. It's a well understood area and there are a lot of solutions to the same problem. But, you know how it goes,... I was looking to build something with the new React context API set to release in v16.3 anyway, and I figured it would be a great match for a form component. So I created [react-minimal-form](https://github.com/ambewas/react-minimal-form) - Tiny, simple, and blazing fast react forms. Tiny? Yes, only 5kbs currently. No direct dependencies (except for one package to make this new context thing backwards compatible) Simple? Sure, as simple as it can be while still allowing for full control. See the demo code. Fast? Yeah. It includes a similar implementation of a PureComponent -- except it is context aware. This allows for very fast updates, even with hundreds of form elements on one page. And I do mean hundreds, checkout the [demo](http://react-minimal-form.surge.sh/) Would love to hear /r/javascript 's opinion. Tell me why it's bad, and it'll become a better package!
The wiki article is pretty good: https://en.wikipedia.org/wiki/Prototype-based_programming Basically, the only major difference is that prototypal inheritance is done at the object level ("instances" in class-based inheritance parlance), and class-based inheritance is done at the class level. People also make arguments about duck typing and static analysis, but those are merely unrelated features that are common in mainstream languages with respective inheritance models.
This specifically would be called from an asynchronous function, so I don't consider it real problem. It being a con is more like if I wanted to use it in a synchronous piece of code, I'd have to have a synchronous version, as well. I know my example probably doesn't do a great job of conveying it's usefulness in my specific situations, but I'll try to explain a reason for doing it. Let's say I want to instantiate a class immediately, but I don't necessarily want to wait for those values to resolve before the class is instantiated. I can pass just the promises to the constructor, and it can set the properties when they resolve, rather than waiting until everything is ready to create the object.
I agree. I wouldn't be able to handle it like a synchronous function in a lot of cases, but suppose the whole point of this type of exercise is to attempt to embrace the asynchronous functionality so that I'm more familiar with those types of issues and how to solve them.
I would avoid that for a few reasons: - eventually you'll run into a case where you will want the return synchronously, and you'll be forced to duplicate code - all those ticks will eventually add up in your unit tests - you could've just done `doSomething(await a, await b)`, which would look obviously silly with sync args. This indicates that you're stuffing too many assumptions in your unit. - the type `T|Promise&lt;T&gt;` is not monomorphic (whereas T is), which indicates that your interface is more complex than it needs to be - An author "not caring" to be explicit in a call site leads to a reader "not understanding" the code surrounding that call site. You always have to care about whether the value is a promise or not, whether that is in `doSomething` or one stack frame earlier. By making `doSomething` not care, you imply its caller may be polymorphic to someone debugging from a stack trace, which can be confusing.
I want to like it so badly but you asked for stars
His PWA course is great too!
The difference is in (language-level) implementation - they're paradigms, not design or architectural patterns. *Classes* are definitions/code templates that instances (objects) are created from. Traditionally they are a compile-time feature (although of course you also have languages like Ruby that have metaclasses and classes as objects, allowing classes to be created at runtime). Imagine you ran a hammer factory, and your designer prepared the blueprint of a hammer which you use to build many basic hammers to spec. When you want to make a claw hammer, your designer creates a new blueprint working off your existing hammer blueprint, and you start build your claw hammers to that spec. Et cetera. *Prototypes* on the other hand are themselves instances. Instead of a factory you have a cloning machine, and instead of building hammers to a blueprint's spec your designer crafts an actual *prototype* hammer by hand and every time you want a hammer you clone it with your machine. When you want to start making ball-peen hammers, you take your hammer prototype, clone it, and then remove/reshape the head into a ball-peen head making a new prototype claw hammer that you clone every time you want a claw hammer. 
In Java, classes are where inheritance occurs. Class instances are objects and play no role in inheritance. In Javascript, classes are functions and class instances are objects. Prototypal inheritance occurs with objects, whereas functions play no role in inheritance.
Hi all I started this project about 2 years ago but sadly got caught up in life and never totally finished it with a 1.0 release or by releasing this write up. However now I have and I thought I would share with you all. The medium article covers the basics of react, react-redux and then redux-synapse and the differences there. Ultimately if you are familiar with the others you can scroll down to the redux-synapse section. If you are interesting in contributing to the project, be it unit tests, demo page, general improvements the repository is here: [redux-synapse](https://github.com/glitch100/redux-synapse) I am sure there are other libraries like this out there, perhaps much better, but thought I would finally dust off the project and give it the write up it deserves instead of letting it get too old. Thanks for reading
Thank you for you feedback! What's wrong with 'asking' for stars? 
The point is that objects are called instances stemming from instantiation, which has nothing to do with what object orientation paradigm a given language implements under the hood (and thus is not "class-based inheritance parlance). And again this continues to mislead (JavaScript has no classes although ES2015+ uses syntactic sugar over functions and prototypes) while glossing over what a class even is (like it's a given that a person who has only written JS should just know what a language feature that JS doesn't have is). 
Very frustrating trying to get webpack going on v4 when the docs refer to things that don't exist anymore :( Hope they can get the docs updated soon
This explanation might be complicated by languages such as Python, Ruby, or Smalltalk. In those languages, classes are objects, and inheritance is implemented with a runtime delegation chain starting from the instance, just like in JavaScript. I feel like, after realizing this, even I can't say exactly what class-based or classical inheritance means exactly. Does the phrase "classical inheritance" imply a particular implementation -- the Java/C++ style implementation? If so, then none of Python or Ruby or Smalltalk have classical inheritance, which would be awkward since Python pre-dates Java and Smalltalk pre-dates C++.
It's fantastic! Great job :) I'm not sure if the over-the-content UI is supposed to change the scene (I'm on mobile and lack some troubleshooting abilities) all I had was rain but I was able to adjust the rain via the side menu. I'd recommend providing a little feedback whenever the user reaches the minimum and maximum for a given variable. I probably smashed that bigger and smaller drop button 50 times not knowing if I could find greater extremes.
seems like a pretty poor choice...
Are you on a xkcd 386 mission lol. Classes are "blueprints". Happy now? Maybe take a chill pill? :) 
If you hard code it, you'll end up with spaghetti code with deeply nested conditionals and such. If you go this route I'd definitely make sure to have unit testing coverage (which I would recommend anyway). I think the best representation is a finite state machine, similar to a graph, where nodes are states, and you can transition between them with actions/events. Each node can have its own state machine, for things like what have you interacted with, have you been there before, etc. and there might be some global/shared state too. Anyway, this engine makes it easy to change the data and not the code, when you want to make changes to the game. Here's an example that's not necessarily how I'd do it but written up reasonably well: https://www.gamedev.net/articles/programming/general-and-gameplay-programming/state-machines-in-games-r2982/ (I searched for "node finite state machine text based adventure game")
Yeah, I had to go back to 3 because of that.
Must be from the UK, since the only weather it can simulate is rain.
Technically, I guess. But you'll notice that Firefox only has it on Windows 10 and only in 1 language, where all the others have dozens of languages and voices available on all platforms.
It is very beautifully done. Its very soothing and took me back to my childhood days when my mom would make comfort food (onion pakodas )and hot tea, when it rained and whole family was at home for the evening. I am on mobile; the sliders were unresponsive. However, everything else seemed to work well. Consider adding a few more scenes and few other sounds if it's feasible. Great work!
Sure! In Ruby and other Smalltalk-inspired languages, classes themselves are first-class objects (like functions are in JS and other languages that follow the functional paradigm) of type (usually) `Class`, and metaclasses are classes whose instances are themselves classes. Combined, this allows you to create a class at runtime using a metaclass, since classes are themselves just another type of object; all this is part of Ruby's heavy focus on metaprogramming (generating, modifying and analysing code at runtime). But classes (and metaclasses) are still blueprints that instances are _built_ from, rather than prototypes that instances are _cloned_ from. To continue with the hammer analogy, imagine your designer came up with and built a tool that could create and edit hammer blueprints on its own. So now instead of going back to the designer you can tell the tool "Hey, I need to build a claw hammer" and it builds a claw hammer blueprint that you feed into your factory setup and it starts churning out claw hammers happily. But then you notice that the gap in the claw is a bit too wide to grip the nails most of your customers use properly. No problem - you can just punch a button on the tool that says "narrow down gap" and it modifies the claw hammer blueprint to adjust the gap by a millimetre or so. A nifty setup, sure, but really not the same as having a cloning machine.
Well, I've managed to collect some Firefox on Windows 10 data that has more voices! The page is already giving valuable data.. managed to recreate the scenario, once you install more voices in Win10, some of them can be used on FF as well.. Also one Linux machine had 94 voices(!), another anomaly needed investigation... thank you all for visiting!
"current geo location support is limited to the UK and Seattle"
 javascript:var%20baseURL%20='https://google.com/?url=" + encodeURIComponent(location.href);
What’s a JavaScript only developer...? 
&gt; The reason I say Ruby instances aren't "built" is because they actually delegate to their class object. That means we can, for example, monkey-patch a Ruby class at runtime, and already-existing instances will immediately reflect that patched behavior. https://repl.it/repls/DevotedSuspiciousBighornedsheep ...that's Python you're writing, which I can't comment on because I only have passing familiarity with it. But I can tell you with confidence that that's not how Ruby works (for one, since everything that's not an object is a method you can't just create a property without the requisite method definition (via `attr_accessor` (or reader, or writer, or just `def whatever`, or logic in `method_missing?`)) &gt; Likewise, JavaScript instances aren't cloned; they delegate. If I run Object.create({foo: "foo", bar: "bar"}), then the object I get back doesn't have "own" properties foo and bar. ...of course it doesn't? The argument that's passed to `Object.create` is cloned to produce the new object's _prototype_, not the object itself. It's prototypal _inheritance_, not instantiation.
&gt; ...that's Python you're writing I apparently pasted the wrong link. I fixed it.
No version of webpack has good documentation. 
I guess the difference is that you can't monkey-patch the inheritance relationship between classes. That is, if `C` extends `B` you can modify both `C` and `B`, but not the fact that `C` extends `B`. Meanwhile, changing the prototype chain itself in JS is pretty trivial. Note: Not 100% sure but you might be able to in Smalltalk sending the class a #superclass message. But, well, Smalltalk is Smalltalk.
&gt; The argument that's passed to Object.create is cloned... That's not what cloning means. To be a clone, we'd have to get back a fully independent copy of the original.
&gt; Meanwhile, changing the prototype chain itself in JS is pretty trivial. It wasn't always. \_\_proto\_\_ was non-standard, and `Object.setPrototypeOf` is new in ES6. So unless JavaScript only *just* became prototypal in 2015... :-P
A couple of nitpicks: On mobile the Safari section is off the screen. Also, the Apple operating system is called macOS now, not OS X anymore.
Pure oop and pure functional aren't mutually exclusive- we can still be friends!
Yeah, maybe clone is the wrong word here, but I can't really think of a word that conveys what I mean. The idea though is that objects themselves, *any* object (not just a special type of object (Smalltalk-style classes)) can serve as the prototype for another (including `null`), as opposed to definitions/templates. I'm not sure how else to put it in real-world terms except as a machine that scans an existing thing and produces a copy with the appearance and behaviour of the scanned thing, especially since actual physical objects aren't neatly divided into a prototype and own properties.
You could change the source of *future*, yet-to-be-created chains, but once a chain was made, it stayed that way forever.
&gt; https://repl.it/repls/WearyBitesizedRedundantcode First off, ewww parentheses :P Secondly like I mentioned delegation is not unique to languages with prototypal inheritance. All OOP languages have (explicit) delegation.
Try reaching out to Sean Larkin on Twitter. He's usually really good about helping people with Webpack.
Yes, absolutely right.
it's funny because it's true
Just because it's launched doesn't mean it must be used straight away. Once the docs come, use it then.
&gt; Edit: D'oh! Copy is the word I don't think copy is the right word either. ;-) Copy and clone are pretty synonymous. [This is what we mean by copy/clone.](https://www.computershopper.com/var/ezwebin_site/storage/images/media/images/canon-pixma-mx922-printing/1087034-1-eng-US/canon-pixma-mx922-printing_400-Wide.jpg) You get back a duplicate of the original. JavaScript's Object.create, on the other hand, is more like [tracing paper](https://cdn.shopify.com/s/files/1/0103/0142/files/tracingpaper_step5.jpg?4016). The original is allowed to show through, but that doesn't mean we have a "copy".
In practice, there's not a huge difference, and you really shouldn't have to think about it much. It's mostly an implementation detail. Prototypes give you the power to treat inheritance chains as data that can be manipulated at run time. In my experience, actually working with prototype objects almost never happens because ES6 classes are supported pretty much everywhere. In the past, you had to work with prototypes directly in order to define class methods.
&gt; (Implicit) delegation is how a lot of the JavaScript community currently distinguishes prototypal from classical. That doesn't determine what the term does mean though But to bring the other thread back into this, the idea is the difference between having definitions (or special definitions which can be manipulated at runtime) that determine how objects are instantiated/behave vs. having _any_ object at all be the source for the behaviour of another
This is mostly a modelling exercise. I could think of something like this... You have a `Character`. A `Character` has `traits`. You can model this as 5 different booleans if you want or, more flexible, as an array of `Trait`s. This will depend on the complexity of your character system, but I would go for the array. Then you have whatever system you use to manage the "current scene". In there you'll have some way of getting the `Scene`'s `exits` or `paths` or how ever you prefer calling them. Now, in a simpler `Scene` model, the `exits` could just be an array and you'd simply read it and that is that. Now, the only thing that is different is that you have to have some way to figure out from a certain `Scene` and some certain `traits` which `exits` are _valid_ or _available_. This can be done in a number of ways, with varying degrees of complexity. I'd model the `exits` as having some `requiredTraits`. With this in mind, you could have a model such as... - `Character`. A character has a number of properties. Among them, there is a `traits` array which you fill with the `Trait`s chosen by the (human) player. - `Trait`. These may be as simple as an enumeration of constants (`const CHARACTER_TRAITS = { AGILE: 1, STRONG: 2, INTELLIGENT: 3 ... }`). Or, of course, if you need to, you can turn them into "proper" objects with properties and whatever. - `Scene`. A scene has whatever properties you need plus an `exits` array. At load time, when you parse the whole `Game` with all of the `Scenes` you also parse the `Exit`s and assign them. - `Exit`. An `Exit` takes you to a certain other `Scene` has a description, etc, but also has a `requiredTraits` array. (Please, note that while I seem to refer to those as "full entities" i.e. an `Exit` class or object or whatever, they may **not** need to be so. E.g. `exits` may simply be defined in the same `Scene` object which may all be just a large JSON file with everything and loaded as a single object or whatever. The idea, however, doesn't change much) Now, when you print a certain `Scene`, you print the description, blah, blah, and then you get the `Scene.exits` and... you can opt for a couple of approaches. 1. You may simply filter `Scene.exits` to print only those whose `requiredTraits` are present in `Character.traits`. 2. You may opt to show all the `Scene.exits` and only when the player tries to choose a particular `Exit` _then_ you check that that particular `exit.requiredTraits` are present in `Character.traits` or tell the player that "You're not strong enough to move the rock" or whatever. You may change from one approach to the other without having to change a thing in the model. So, if you try the second approach and then decide you don't like it and prefer the other, you'd only need to remove the "exit check" and add the "filter exits" both of which are reasonably simple things. (The second approach, IMHO, has a number of advantages. It gives the player a better impression of what choosing different traits may mean for the game and give a hint that the game is bigger. Also, you could build on it to allow other mechanics, such as an inventory: You may allow the player to carry an item, and only go through certain exits if they have the correct item along with the required traits.)
&gt; to accommodate for habits of newcomers (from other languages) I strongly disagree with this claim that it's to accommodate newcomers. Before ES6, lots of JavaScript experts were writing class-like constructs into libraries, such as those found in React, YUI, Prototype.js, Dojo, Mootools, and others. ES6 class alleviated the need to reinvent the wheel in every library. &gt; Many of these concepts are not fitting well into the fundamental design of Javascript. It fits just fine, and it reuses the same fundamental concepts JavaScript has had since day 1.
Here's the tutorial: https://tympanus.net/codrops/2015/11/04/rain-water-effect-experiments/
Yeah I guess I really just need to learn webpack and babel. We use them at work, but its all done via the framework cli, so its not something I configure or ever mess with. The framework handles all of the build processes.
with a generous use of `var`
It all comes down to the language and OOP. The 4 pillars of OOP are: * Abstraction * Encapsulation * Inheritance * Polymorphism Prototypical inheritance covers all except polymorphism. You can force this behavior with a transpiler or ES6, but both are syntactic sugar. JavaScript doesn't enforce polymorphism in any meaningful way. By default there is no check, and even if you use a transpiler like typescript you can always set the type to "any" and just pass whatever you want without any validation. Classical inheritance enforces this at compile time and you have to go far out of your way to allow it to compile and still work.
I swear I had an example once, but I cannot seem to reproduce what I thought happened. I may just be wrong on this.
One difference is that JS only has dynamic dispatch while other OO languages (usually statically typed, compiled) do both static and dynamic dispatch. For example in C++ and C#, unless a method is declared `virtual`, the call will be resolved at compile time. So if `doSomething` is not a virtual method, then these may call different methods even though `cat` and `animal` are references to the same object: Cat cat = new Cat(); cat.doSomething(); Animal animal = cat; // works because Cat is a subclass of Animal animal.doSomething(); Because the compiler will say "oh you're describing that thing as an Animal, so I'll use the Animal method" rather than looking at the object at runtime to check if it's a subclass that overrode that method. JS being dynamic the above makes no difference of course: var cat = new Cat(); var animal = cat; animal.doSomething(); // calls Cat.prototype.doSomething anyway So in Javascript (and Typescript) you *only* have 'virtual' methods.
It does not. Because js originally had only 1 scope, function scope. Full stop. Many implicit things that comes with classes, super calls, shared variables are all creating more unnecessary overhead than convenience. With prototypes you get to create all those scopes and shared variables. This is not reinventing the wheel, for an 'expert', it is TRIVIAL. You are exaggerating on purpose to justify. I do not know and do not care one bit about what is a js expert for you but I do know one thing, not every js 'expert' that creates useful stuff works for a framework. We cannot get to any conclusion based on what other's do. And new specs looks just fine of course and 'under the hood' uses the exact same concepts of prototypical pattern. Because everyone knows one thing =&gt; we cannot (and should not) break the web. However, not everything is ergonomics. With ergonomics comes implicit issues that seem to bring convenience at a cost of confusion. Less is more, less is anti-fragile. With all these unnecessary juice, it looks to me that js devs are becoming like people that chase the latest mobile phone every month. Did we finish what is on our plate yet? I do not think so. 
And function()
This is not a very good analogy for prototypes in javascript since no copy is actually being made. If we want to continue the hammer analogy, a prototype is like having a hammer that has a friend hammer that it can call up to do certain tasks. That friend hammer may be the prototype of many other hammers, but at the end of the day he is just one hammer that the others are delegating to. Javascript can be better described as an OLOO (objects linking other objects) language rather than what "traditional" OOP is. I recommend reading [Chapter 6 of YDKJS](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch6.md) for a deep dive on what prototypes in Javascript are all about.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [getify/You-Dont-Know-JS/.../**ch6.md** (master → 6f51ed6)](https://github.com/getify/You-Dont-Know-JS/blob/6f51ed6746300f51bc6c930c080b8a7426b7629b/this%20%26%20object%20prototypes/ch6.md) ---- 
&gt; vs. having any object at all be the source for the behaviour of another I've been poking holes in a lot of arguments as I try to reconcile -- even for myself -- classical vs prototypal in light of languages like Python, Ruby, and Smalltalk, and so far this is the only view I can't poke any holes in. That JavaScript lets us inherit from any arbitrary object does seem to be the one feature that separates it from the rest.
That seems pretty specific to your application. Bootstrap badges can help with the “look” if you’re using it. The majority of the work would probably be in the backend anyway. I would argue it’s probably easier to just roll this one yourself. 
&gt; It does not. Because js originally had only 1 scope, function scope. Full stop. Scope and inheritance are different things. JavaScript has had constructor functions and `new` and prototypes literally since the very beginning, and ES6 class is a cleaner syntax for using those three things. &gt; This is not reinventing the wheel, for an 'expert', it is TRIVIAL. You are exaggerating on purpose to justify. Actually the justification I gave was literally the reasoning used by the standards committee.
My GPU didn't like that.
Javascript is not owned by TC39. They are not the emperor of js devs.
Hey thanks for posting this! I’m new to React but I’ve been searching for something like this. I have a question about how to extend this, if you don’t mind, but I don’t want to derail win personal projects 👍🏻
How does prototypical inheritance cover encapsulation?
Really more JS objects than prototypical inheritance, but you can store data in an object. [Here's an example](https://jsfiddle.net/0f1txh1h/8/) I've added a method to the Array prototype and encapsulated the data. Now the hidden data is part of the prototype and will be updated regardless of the instance of the object.
What part are you having trouble with? At the most basic level you can just have a collection of HTML files (not recommend because not DRY), and at the very least if you want to write in SASS and ES6, you need something to transpile them. Whether that’s as simple as the sass and babel CLIs or a Gulp/Webpack thing is up to you. I would, however, suggest using a web framework even if it’s only for the templating language, as it saves so much repetition. There’s nothing more annoying than having to change a common element across a bunch of files. Django has a great templating language so I suggest sticking with that.
Like a pro!
While it definitely achieves some of the work, it still requires that additional if conditions are hit. If you have 1000 components that's 1000 more conditions that need to be checked in comparison to only going to the relevant components and then calling that. 
&gt;My Googling has led me to believe appending onchange="this.form.submit()" to the current radio buttons is the right solution That is wrong. Using inline event handlers is bad practice and results in poorly factored, hard-to-manage code. Same thing for ".onclick", ".onchange", or "on" anything. Seriously consider attaching your events with JavaScript, instead, eg: https://developer.mozilla.org/en/DOM/element.addEventListener If you're just starting out with JS, I highly recommend getting a firm grasp on the syntax of the base language before trying to learn the syntax of any particular library. Jquery isn't needed for much these days because browsers are pretty standards-compliant.
Thank you very much for that, I will take a look now and see what I can figure out. Its one of those things where I am trying to jump ahead and find a solution before understanding, which I know isn't great... but hoping to learn/solve in tandem :) Thank you for your help! 
I always wanted someone to make these tools, and I feel like I finally found it. I am really grateful for making this. There are some questions. 1) Do I have to only use components like Box or Textinput instead of components derived from HTML, for it rendering as a desktop app? 2) Then Can not use React UI libraries? 3) What about icons? I would appreciate answering your question.
I always wanted someone to make these tools, and I feel like I finally found it. I am really grateful for making this. There are some questions. 1) Do I have to only use components like Box or Textinput instead of components derived from HTML, for it rendering as a desktop app? 2) Then Can not use React UI libraries? 3) What about icons? I would appreciate answering your question.
I always wanted something like this, and I feel like I finally found it. I am really grateful for making it. There are some questions. 1) Do I have to only use components like Box or Textinput instead of components derived from HTML, for it rendering as a desktop app? 2) Then Can not use React UI libraries? 3) What about icons? I would appreciate your reply.
That was indeed a bad choice. Webpack had bad reputation because its confusing docs. They brilliant managed to fix this with the new v3 docs, and now they made this error. I won’t complain as i love webpack and contributors deserve all my respect - but hurry up releasing a major version of such important tool without updating the docs first?
Sadly with npm these days it's a case of you go first, I won't be trying this on my CI builds until a bit of time has passed. npm quality has gone down massively since v5. Is this actually a production release? They have a tendency to publicize releases then claim you shouldn't have been using because it was only in beta.
Next time you'll probably have better luck in a deobfuscation or CTF subreddit. Also, try to pretty print the code. My transcription of this code (I'm on mobile so this will take a while): class StringArray { constructor (length) { this.length = length for (let i = 0; i &lt; length; i++) { this[i] = '' } } } const image = new StringArray(10) images[0] = '1.gif' images[1] = '2.gif' images[2] = '1.gif' images[4] = '2.gif' images[5] = '1.gif' images[6] = '2.gif' images[7] = '1.gif' images[8] = '2.gif' images[9] = '1.gif' const imagesPerSecond = 60 / images.length function randomImage () { const date = new Date() const seconds = date.getSeconds() const index = Math.floor(seconds / imagesPerSecond) return images[index] } function renderImage (path) { const image = document.createElement('img') image.src = '/' + path document.body.appendChild(image) } renderImage('1f2e73705207bd' + 'd6467e109c1606ed29' + '-' + '21213/' + randomImage())
I found the Kyle Simpson disciple... and I agree with you. 
Thank you for such a thoughtful reply, this definitely helps me down The Path. I absolutely want to learn best practices out of the gate, and it sounds like vanilla is probably the best first step. And thanks for your welcome into the world of JS, I am certainly excited for my initiation into this wild and crazy JS universe!
There is quite a few lib's you could use to work with canvas etc, but I doubt any have exactly what you need. Might require a bit of development. But these are a few. I would suggest you would need to play around with them a bit. https://threejs.org/ https://two.js.org/examples/ http://ocanvas.org/
Then you google how to get started and it turns out there is al kinds of plug-ins that are basically mosthaves. Installing those turned into a giant shitshow. Each plugins requires it's own package manager that doesn't install like it's manual says it should, then there is some plugin that has a version conflict/hidden setup option you need or a shitty error message that tries to tell you you're missing another packagemanger/library. Somewhere along the line you'll run into a missing dependency that returns some error that isn't documented. That happended to me several times that day.
Thanks
Why is this not the default for the regular install command?
While I don't always agree with him, Kyle has a deeper understanding of JS than most and is great at communicating that knowledge.
They are named functions so nothing wrong with that
fixed won't help... the other thing yea.. but had hard time to find working javascript code, don't want jQuery https://www.reddit.com/r/css/comments/82baja/open_expand_footer_but_it_pushes_downside_out_of/dv9ahaw/ 
I was a student at MakerSquare (which became Hack Reactor) and had the opportunity to meet Kyle personally while my cohort was the first to be introduced to the new curriculum under Kyle Simpson. First of all, he’s a really great dude. As far as his approach to educating others goes, here’s my thoughts: I like his philosophy in regard to coding and how he approaches coding in JavaScript from a well thought out and calculated/learned/clean code approach. I love that he keeps up with the actual EcmaScript Standard, it’s important. I absolutely love his Front End Masters classes, they’re amazing and every JavaScript developer should take these classes just because they’re that good. I am also looking forward to reading his next iteration of YDKJS because I know it will be great and I’ll be able to learn something from it. Buuuuuuuuut... as far as his ability to teach (JavaScripters) in the beginner to intermediate level, he’s pretty *terrible*. Maybe it’s his focus on JavaScript alone, or his assumption that learning to code in JavaScript is coupled with an understanding of software architecture best practices (Uncle Bob what’s up), but I think his biggest flaw is making assumptions about his audience. If he could figure that part out and incorporate it into his educational approach I think he’d be the ... who’s better than Bruce Lee? He’d be the Pei Mei of teaching people how to code.
A lot is going to depend on your project leads and the company / projects you are working on. In the real world of non-tech corporations (like insurance companies, retail companies, manufacturors etc) , business requirements tend to drive a lot of changes to software and the pressure is on to get code out quickly and efficiently. A good project lead is going to have the code reviewed if possible, ensure its commented and maintainable and is tested against requirements. But the code may not be perfect, and there may not be time to make it perfect. Typically you move on to the next task in the project and if you revisit the code to implement new requirements you might fix some technical debt at the same time. Some companies with more time may constantly revisit their code base, upgrade to the latest frameworks etc. especially if they are start-ups and tech-focussed. But most corporates that I have worked for just want to get onto the next requirement to solve a business problem, and rarely visit legacy systems except to fix bugs or add new functionality. The exception is when that old system is not too maintainable nowadays so a conscious decision is made to replace/upgrade it to new technology. But that does really not happen that often. 
Were we in the same cohort? lol I was in MKS 37. &gt; his biggest flaw is making assumptions about his audience I think you are correct here. Coming into MKS I had already been working in the industry for over 5 years, so the barrier didn't really impact me personally, but I would certainly regard his teachings/material as intermediate+ in general.
MKS 33 || HR-ATX18 lol
I've only ever used mocha/chai/sinon but I feel like I hear more and more people moving to jest
From a business view rewriting code has a significant opportunity cost. It adds little in terms of features or bug fixes to the system and takes up time that could have been sent producing something marketable. Getting time to rewrite anything is rare in my experience so here is my advice. Stop the creation of more technical debt, you will never pay it down if more keeps being added on. When in certain areas of code for smaller fixes, tidy up and leave it in a better state than when you found it. After that it depends if the technical is architecture based or not. If the code is poorly structured with the same functionality copy pasted in multiple places (in your case Js files) you can introduce a front end frame work when you need to write a new one. This is good as you can isolate the change and use it as a example or POC going forward. If things are organised pretty well and there isn't much code duplication, don't create a new way to do something. Everything using the same function is better than nearly everything using it and one new thing written using a framework to do the same thing. To introduce a framework to this you will have to wait for the feature to be designed and then implement a framework. Make sure to keep functionality and the calls to it, and that testing knows to test those satellite bits of functionality. As a note you may need lead Dev and management sign off as using a front end framework is a business decision. You may be a great react Dev but if everyone else doesn't know react using it could be detrimental to the business. 
Thanks! Actually have been thinking about the bay area recently, just love ATX so much. If you ever find yourself moving to Dallas or Austin I have a pretty solid network in both cities. I’d move to Austin over Dallas a million times over, but both are cool cities :)
Because yarn already does that /s
Let's review it. I have created a JSFiddle with a corrected version of it here: https://jsfiddle.net/ufs3fg4r/7/ Things to comment: - The logic to add the CSS class and add the event listener must be performed sequentially, because otherwise you are trying to get a reference to elements with className donation-amount but they might not have been set yet (that's why I put them both in document.ready. You could also wrap that logic (from var donationSubmit = ... onwards) in a function, and then in document.ready call that function after adding the class. - document.getElementsByClassName returns an array (notice the s in getElements instead of getElementById, for example). Therefore, to add the event listeners you have to iterate on each element of the array (with the simplest loop, a for-loop). If you had done it with jQuery selector, like $(".donation-amount") you could have done it $(".donation-amount").click(...), but this is because of the magic jQuery does: the result of the $(...) is not a HTMLElement or Array, but a special jQuery type that allows you to add a CSS class, or event listener, for example, to multiple elements matching with the selector all at once. It also allows you to perform chaining, for example $(".someclass").addClass("anotherclass").click(myClickHandler).focus(myFocusHandler) - all in one line. - Last but not least, you're trying to call this.submit on a radio, but they have no such method. They should be wrapped in a form, and then use this.form.submit. A most elegant way would be identifying the form. For example, &lt;form itemId="donation-form"&gt;...&lt;/form&gt; and then use $("[itemId=donation-form]").submit(). Feel free to ask anything else that might be itching :)
Replies like your are why I love Reddit! Sincere thanks 🙏🏼 I am going to review when I get home, but I can already feel my understanding growing. Hopefully I’ll have a grasp soon and can pay it forward in the near future. I will let you know how it goes and really thanks again!
While I've heard Austin is a great place, I don't think I'll ever find myself moving there; I've always lived somewhere I can surf, climb, and mountain bike regularly, and I'm not sure I could give that up. Thanks though :) I'll ping you if I ever visit; feel free to do the same.
Don't *beg* for likes, stars, reddit gold, money, candy, beer or anything else. It's unbecoming and tacky as hell. People know the star thing is up there and they'll use it if they want to.
To some of us curmudgeons asking for affirmation is part of the general descent towards something like Black Mirror's S3 episode "Nosedive". That and elsewhere 5* suddenly being normal &amp; 4* an insult, "why not like and subscribe?" being the second thing every video says these days, and constant pop-overs to the same effect while trying to read something. So nothing specific, it is just part of a general malaise. Us dinosaurs will be gone soon enough, so I wouldn't worry about it too much, but we intend to make our disapproval known while we can!
If you're using a framework like react you'll end up doing it inline anyway.
Jest is faster than mocha
The choice of the "ci" for "continuous integration" over simply fixing "i" seems messy. This looks like marketing... 
You're welcome. Learning a new language can be confusing or overwhelming sometimes, Im glad I have been able to help :)
It's still a bit messy atm, webpack is now stable but all the critical parts had still some issues and documentation is still missing mostly other than the bits and pieces you get from twitter and gists. html-webpack-plugin was broken, webpack-dev-server was broken (last time i tried it didn't parse `--config` any longer), webpack-dev-middleware is broken (on windows only). We do have a buildsystem on webpack 4 at work, the gains are pretty incredible, but yeah it pretty much remembers me to the old days, getting webpack 1 to work. 
This is your process whenever you touch code: 1) cover with tests 2) refactor If you just do that only to pieces of code you are touching as you work on normal tickets, then pretty quickly the bits that change or break often will be nice and clean and tested. The rest doesn't change or break often, so it doesn't need to be fixed. Job done!
I have! We're actually using ESLint at the moment, one part of the doc is making sure everyone has the same configurations for it
Check .eslintrc in with the code and make sure eslint runs on commit (npm install lint-staged --save-dev)
You needn't look any further than the prepublish/prepublishOnly debacle to realise that how things are named means nothing to npm.
It doesn't change anything visually right? The sliders are just volume controls.
You may study Frontend on the web. Tutorial sites such as Udemy help a lot. But the courses are mostly in English, and not all have closed captions. That light pose a problem for you.. 
I truly appreciate your jolly cooperation 🙏🏼 ☀️ ⚔️ 
Reporting back... it works! Now to dig in and wrap my head around it all. Might need a few days or weeks :)
This should have been the top answer...
React seems pretty hot on the west coast. I think it's fairly region-dependent.
Learn plain JavaScript well. Learn whatever framework you need for the job you want.
Glad to hear that! Keep on the good work ♪＼(^o^)／♩
Try cytoscape maybe? http://js.cytoscape.org
As if there were any other way. You left off blood....blood is a very important part of learning webpack.
In react we have to update the react, typscript and all other npm packages OFTEN! But we try to do it as quick and often as possible. Becuase the more often we update our versions the smoother the process will be. Also not javsacript specific but a little tech debt is fine but a lot of tech debt is not good.
I have used https://jsplumbtoolkit.com/ in react, and it workded. Although, i needed to read in docu and source much to wrap my head around their api. And its not specifically for react, i redrawed it on componentDidUpdate()
Put the JavaScript code in a function and call that function when you need it.
This is awful. Doesn't even explain what the arrow function does. It's not just a shorthand way of writing functions. It changes the context of the 'this' keyword.
I just released a lightweight library to do something similar. The customization options are very poor though... It might be enough for your purpose, you can still give it a shot! Feedback is welcome :) I haven't posted anything about it yet, this is the first time I talk about it. https://github.com/pierpo/react-archer
Well, it IS dirty. But since jsplumb is not for react... that react-js-diagrams seems nice!
Wow, this looks very nice. I will give it a try and provide feedback for sure! What is the Licence BTW? I can not see one.
Tell me about it! People don’t seem to get that we have lives, families, and other responsibilities. Even if we develop a project as our full time job, we have to work on the things that most people need and not just he who shouts loudest.
I really need to look into getting windows test environments going. Ours are all Linux and I’m really not looking forward to adding Windows to the matrix.
Jest and testcafé
Webpack and React are the obvious choices. Webpack ends manual labour, React ends the idea that frameworks must be huge and complex. Webpack is [towering over its competition] and React is bigger than [all other frameworks combined](http://www.npmtrends.com/angular-vs-react-vs-vue-vs-@angular/core), applies to most of the job market as well. Otherwise jest is pretty good testing framework. 
how would people know there're updates for their dependencies if their CI don't install the newer versions? /s
https://github.com/airbnb/javascript
You should check out what other companies are doing. I based our office's doc and linting rules heavily on airbnbs, because I really like it. I swapped out just a few things, but mostly I thought it was good: https://github.com/airbnb/javascript/blob/master/README.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [airbnb/javascript/.../**README.md** (master → 396166b)](https://github.com/airbnb/javascript/blob/396166b1d3266c3bd4c9a83a8f3142c7bcc58865/README.md) ---- 
Looks like great minds think alike.
Yeah we're currently using their code style, i'm conscious of repeating what they say mind you. What things did you swap out? 
The license is MIT :) (it's in the package.json)
I did just that but it involves ugly hack using settimeout to let the browser recalculate the height. https://jsfiddle.net/bxycstyv/34/
Put the JavaScript code in a function like this: function newPhotos() { // Code to be run } Then, to make it run when the document loads add this attribute to your &lt;body&gt; tag: &lt;body onLoad='newPhotos()'&gt; Then, Put a button somewhere on your document and use it to fall the function like so: &lt;button onClick='newPhotos()'&gt;Get new photos&lt;/button [Example](https://jsfiddle.net/tyqmwyr1/9/embed/)
When you define a named function (e.g. `tick`), you may call the function by that name within its own scope.
With `let` and `const` the variable is deemed "uninitialized", and attempting to access it before it is initialized [causes an error](https://flems.io/#0=N4IgZglgNgpgziAXAbVAOwIYFsZJAOgAsAXLKEAGhAGMB7NYmBvEAXwvW10QICsEqdBk2J4AbhgBOAAmrSAvNIAUSgJTyAfMCFxasfFFoBzJdVUBuaZJjEArpLTSArK1VrpAHTSxi0gEYKymqa2vS6+oYmfhZWNvaOLm6qXjq+GIEq6lo6ejAGxkoYMdZ2Ds6uamwcIJg4ePjUcAI09IzMPGwAuqxAA): var c = (()=&gt;{console.log(c); return 3})() // logs undefined let b = (()=&gt;{console.log(b); return 4})() // errors out with "can't access lexical declaration `b' before initialization" const a = (()=&gt;{console.log(a); return 5})() // likewise for `a'.
&gt; What do you most love using Tape, or whatever uses the least amount of magic and globals &gt; What do you recommend for unit tests, and what for E2E tests As always, it depends. At work, we use Jest/Enzyme for unit tests and we have couple of puppeteer scenes for screenshot testing. We don't really use any actual E2E tests, unless screenshot testing counts for that. &gt; I heard about Tape/Ava I think on a spectrum from minimal to everything included it goes Tape --- Ava --- Jest. Do with that whatever you will. 
This. But only as long as it's a named function _expression_. Function statements do not share this behavior instead only adding a variable to the current surrounding scope. function Foo () { console.log('Foo', Foo); } var Bar = function Bar () { console.log('Bar', Bar); } var tempFoo = Foo; Foo = null; tempFoo(); // -&gt; Foo, null var tempBar = Bar; Bar = null; tempBar(); // -&gt; Bar, func Bar 
I'm not sure I trust these results. It looks like they lifted tests from https://github.com/pnpm/node-package-manager-benchmark and didn't clarify what test scenario they ran. In my own testing, I saw minimal difference between ci vs i (~15s vs 16-20s) except if you removed the node_modules first, which saved roughly 5s during `npm ci`. It seems `ci` isn't really better for local development outside of ensuring your lock file contents are your own package contents. For CI usage, where you don't already have a node_modules folder `ci` would be ~1.5x to 2x faster installs based on my local test. 
You should be able to have it in an external file and use it on multiple pages. Just make sure it is a function and it is linked &amp; called correctly. If you have it as an external file and linked via a script tag &lt;script src='example.js'&gt;&lt;/script&gt; You should just be able to call it using the function name I showed in the example. 
I've been job hunting for a few months myself, and it seems the overwhelming majority of employers are looking for React-Redux or React Native experience. I've seen a few Angular 2+ and one or two AngularJS, but it's mostly been React.
Is this method preferred over adding a "DOMContentLoaded" event listener to the document? I'm a newb myself, and just wondering best practices (since I rarely, if ever, use those HTML in-line function calls, and usually do it with event listeners).
I always use them, There is probably a better practice but I find it useful because there is no limit to how many I can call. Ex. &lt;body onLoad='one();two();three();'&gt; And it isn't very complicated 
Great thanks. Quick question - does this support multiple relationships? I.e, can the root element connect down to two other nodes or is this limited to one?
Then it doesn't matter what value is held during initialization. The invariant is that the `const` binding can't be modified once it has been initialized.
Memo what?
Memo what?
Go and build a project. A website, webapp or whatever you think that would be useful. You will quickly see where your limits are. Google your problems and continue.
Wes bos has a JavaScript 30 that he walks you through a project everyday for 30 days. That could help you out. 
I'm hiring for a front end role right now, and my number one thing I'm looking for is for the candidate to have a complete understanding of JavaScript itself. If you have a solid core understanding, you can learn to use any lib-du-jour as they come and go. Experience with popular frameworks is nice, I suppose, but in my experience an "Angular dev" isn't usually suited to a role that doesn't involve Angular.
Chart.js is pretty nice. You can just import your desired graph as a component and set its options, styles and data via props. https://www.npmjs.com/package/react-chartjs-2 https://github.com/reactjs/react-chartjs
The flaw is to include un-trusted 3rd party JS. And the author, says oh nowadays it is too hard to make sure that all 3rd party library is safe, so give up on that. What ? Everything you do after this point, including displaying sensitive data with just HTML is as risky as using localstorage. 
I find their description to be very confusing. What does "ignores package.json" mean? Normal `npm i` should always be using the lockfile. If it wasn't, then npm 5 is wildly broken. In my current project that has almost 1,500 packages (timed the 2nd run of each to make sure cache was populated): npm 5.7.1 ``` $ time npm i real 0m38.920s user 0m38.500s sys 0m11.549s $ time npm ci real 0m16.426s user 0m13.267s sys 0m2.578s ``` so `npm ci` must be skipping a massive amount of stuff internally. I suspect it is just looping over the lockfile and copying the files from the cache into node_modules, without any further dependency checks. The lockfile contains all the hoisted locations so it can reconstruct `node_modules` without actually building a dependency tree from package.json. Though it really makes you wonder what `npm i` is doing that makes it take twice as long. You would think copying tens of thousands of files would have been the slowest part. For comparison, yarn v1.3.2 ``` $ time yarn real 0m18.901s user 0m15.546s sys 0m11.293s ```
https://en.wikipedia.org/wiki/Memoization
I think `npm ci` doesn't check package.json for changes. So if you manually edit package.json and add/remove a package or change a version, `npm i` will notice and update the lockfile. I'm pretty sure `npm ci` just accepts the lockfile as the source of truth, so doesn't look at package.json for changes.
**tl;dr** Don't store sensitive data in localStorage. Use sessionStorage if at all possible. Well of course! Why would you store sensitive data in a client-facing **publicly-accessible** (by the browser, anyway) browser-implemented store? Asking your readers not to use a technology simply because it's possible to store sensitive data in it is an overreaction, and I completely disagree with your article's premise.
Have you tried changing transform: translateY()?
Yes it does!
Something like [this?](https://jsfiddle.net/dpt8311v/15/)
Why the quotes around "fastest"? Are you not quite sure about it?
&gt; I worked with Angular 1.5/SCSS/ Gulp/karma/Jasmine/Bower The most common combination now is probably React/SCSS/Webpack/Jest/NPM. If you want to get up to speed quickly, decide whether you'd rather learn Angular 2 or React+Redux. Those are pretty much the only games in town. Learning Webpack is pretty much essential because nobody wants Gulp now. The rest is either not that important, or easy enough to pick up.
But what if you are trying to detect someone else’s extension, like the Chromecast APIs?
technical debt is inevitable. It's important to schedule some engineering time every sprint/release/whatever to addressing some of the technical debt or it's going to become a big ugly problem. But you have to spend a majority of your time on making progress, too.
React is a paradigm shift, Webpack isn't though. I'd be surprised if it were still the bundler of choice in 5 years. React (or React-like libraries) will still be here in 5 years.
mocha + unexpected + mocha-webpack
This
I like mocha and chai, and a good test runner makes a big difference. I like karma set to watch, istanbul for coverage and a minimal reporter like text-summary / dots. That doesn't really fit my work setup, but at work I'm using Nightwatch for e2e and really like it. If using Nightwatch, I recommend adding a debugger helper, something like this: https://gist.github.com/elliotchance/63f2ebebe8d457307339 to let you pause the test and poke around a bit.
The best way to communicate requests for programming convention is through code reviews. You don't get team consistency by typing up a manifesto and handing it out in a meeting, you earn it through two-way collaboration with examples. If you don't have time for that, you don't have time to manage developers.
What would you define as a basic level? Totally agree go and build something, or try Codewars to test your applied knowledge. Make a list of things to try and build and go through each one using the documentation as a guide. In parallel I found certain books (in combination with the practice projects) made me realise how much I didn’t know about the theory behind it. The “You don’t know Javascript” series was particularly useful for me (it’s a tough old read though). I would do this before trying libraries/frameworks like React, Vue and Angular. 
This... so much. This is/would/should be totally redundant with the lockfile. Also.... FWIW, specifying versions &gt;= should really handle *most* issues in the first place, and it's arguably a feature to be made aware when your build fails because Joe-leftpad JS dev made backwards-incompatible changes to his SDK/lib.
I'm experiencing the same thing. Looking at https://github.com/zkat/node-package-manager-benchmark/tree/zkat/cipm the blog post may have chosen the scenario where the lockfile exists, but `node_modules` and the cache don't exist. `npm install` outperforms `npm ci` in Kat's test case where the cache, lockfile, and `node_modules` all exist.
https://stackoverflow.com/a/16751620
Yep, I agree, have it in a section of the doc already that helps to define when a task is done.
async.js or Rxjs
Try with `yarn --frozen-lockfile` since that's more common for CI builds. 
JS doc is my own preference. If you pair it with an eslint to enforce properly documented code, it works fairly well. 
I think it skips the reconciliation process. 
Another downside is that you end up creating a lot of garbage. This is probably okay in business logic but hot code paths should avoid allocation as much as possible. 
In five years, I imagine the new paradigm will be using Web Components and/or wasm.
`for(uri of uriList){ await requestURI(uri); }`
This suggestion will probably be different than others.. but I think it's imperative for all front end developers to be familiarizing themselves with web components. The native performance is going to really change the way frameworks deal with DOM manipulation. IMO, virtual DOM frameworks are going nowhere faster than we think. Check out libraries like HyperHTML/lit-HTML and how they are showing off the capabilities of the browser and DOM.
It also doesn't do exactly the same thing as `npm i` so I don't think it would have made sense to replace it.
This is the best advice you are going to get. Recently I interviewed a couple of Jr developers who had recently graduated from code schools. Their knowledge of React was pretty good but they both struggled immensely with very basic vanilla Javascript coding challenges. Learning the language will get you further.
Web components mask a naked dom, nothing more nothing less. Not very exciting tbh. That dom needs driving, meaning that you pull 5 web components you could end up with five frameworks underneath. There's no common interaction between them, they are outright clueless when it comes to rendering on other platforms, especially native and they are imperative by nature. I wouldn't bet on this spec going anywhere. Wasm on the other hand will likely drive a vdom in the future - there are some already.
[Great Video on this](https://www.youtube.com/watch?v=MmRmxzrr4lk&amp;t=959s)
I agree with this, but I'll say React, maybe angular if you are on the west coast, and maybe Vue if you want to try the cool new thing and be prepared for what the market will possibly be years down the line. I learned React, but also had a good understanding of fundamentals like algorithms, data-structures, OOP, Functional programming, and how to write readable/clean/extendable software in general. I was also very good with vanilla JS. I went to interview for my first real software job last week, and it was a js/angular job that required 5 years of experience and a bachelors degree - neither of which I had. I also had never used angular. In the interview we just talked about programming and they asked me some general javascript(framework/library agnostic) questions as well as my opinions on different ideas/concepts like testing and external dependencies. They said they'd review all the candidates and get back to me the next week, but then I got a call from the hiring manager 15 minutes later and they said they really wanted to hire me and gave me an offer. I spent a couple months making a huge React project and learning it inside and out and in the end I didn't need it at all and still did great on the interview. This isn't always the case, but I didn't understand what people meant when they said things like 'the framework doesn't matter, just learn javascript well' until then. I do think that having any framework to put on your resume/use in a portfolio project will help you with getting interviews, regardless of whether the job is for that specific framework or not. Also, learn to write AMAZING cover letters, and how to interview very well(it's as much about making the interviewers comfortable with you/like you as it is about proving you know what you are doing. Making them like you will help you convince them you know what you are doing as well).
&gt; Anyone who says XML is too verbose but likes configuring webpack should have their keyboard confiscated. XML is too verbose and I like configuring webpack. Come at me. 
So, you don't need any libraries to do what you want. I'm going to give you a pure JS solution that you can adapt to bluebird, typescript, and whatever else: function requestAllWithDelay (urls, delay) { return urls.reduce((promise, url) =&gt; { return promise .then((responses) =&gt; { return fetch(url) // Or whatever request library you're using. If it doesn't support promises, you can wrap it in `new Promise((resolve, reject) =&gt; someLib(url, { onSuccess: resolve, onError: reject }));` or something similar. .then(response =&gt; { return new Promise(resolve =&gt; { setTimeout(resolve, delay, responses.concat(response)); // replies.concat might not work, depending on how you want to accumulate all the data. Maybe you don't even care about the responses? }) }) }) }, Promise.resolve([])) } requestAllWithDelay(['http://...', ...], 1000) .then(allRequestsInAnOrderedArray =&gt; { ... }) .catch(console.error); But just having the code isn't good enough, you need to understand what's happening and why it's structured like this. First, why a reduce? If you're not familiar, reduce works similar to a map, but instead of returning a new array of the same size, you can return any type of data, and augment it each loop. So why not a recursive function? Javascript, from what I've been told, has poor function recursion. Maybe someone smarter than me can chime in on that. Okay, so if you're good with why a `reduce`, let's move onto how it works. Since we can augment the data we are passing into a reduce, we can build a big promise chain but returning the previous promise with a `.then()` attached. The next iteration will have access to the last part of the promise chain, so we can guarantee that these api calls happen sequentially. So for each loop, `promise` is the last promise in the chain of promises we're building up. The last param of `.reduce()` is the initial value that promise is set to. All promise libraries let us automatically resolve a value, and we're automatically resolving an empty array. This is equivalent to `new Promise(resolve =&gt; resolve(valueHere));` To chain from the last promise, we return `promise.then(responses =&gt; /* stuff we want to do after the last promise */)`. Notice how we have a `responses` param in our `.then` - this is because we keep building up all the responses per promise. More on that shortly. Inside a promise, we can nest promises, and we're going to need to do that to process our requests. Since we're inside the main promise, we have scoped access to the previous requests, so we can resolve that later. After we get our data, optionally, we could validate if it belongs in responses, and if it doesn't, we could just `resolve(responses)` to persist the previous responses without adding the current one. That may not work well _if_ you care about responses and the responses and urls need to be lined up - the basic summary of that is, if we have two requests, but only one response, which request generated that response? Now for the delay, this is just some cleverness. So we know that we can create a promise using `new Promise((resolve, reject) =&gt; { /* call resolve or reject after some stuff is done */ });`, which means we can set a timeout, do a network request, or some other asynchronous action. In our case, we just want to implement a delay, and `setTimeout` is great for that. So `setTimeout` has a cool argument structure that I just leaned which is `setTimeout(functionYouWantToCall, delayTime, arg1ForFunction, arg2ForFunction, arg3..., ...)`, so I'm taking advantage of that. This could be re-written as: setTimeout(function () { resolve(responses.concat(response)); }, 1000); This guarantees that the next promise won't be resolved until this timeout is complete, giving you a delay. Make sense?
VueJS 
You might find [Dagre](https://github.com/dagrejs/dagre) helpful. It doesn’t have quite the flexibility of something like Graphviz, but it does nicely isolate laying out the graph, so you have some pure data ready to feed into your React component(s) to do the actual rendering.
Last time I tried it (few months back), it failed horribly with cryptic error message. It turned out to be because of older Node. I didn't see anything regarding supported Node versions on their page. Sadly, it seems really immature, I wouldn't risk it using in production.
I would recommend SVG for this type of work. 
How many millions of unit of tests are you running where your test framework itself becomes a factor in your testing time? 
Here's a quick example of how to implement that functionality. const uris = ["http://one", "http://two"]; map_serial_with_delay(test, 100, uris) .then(results =&gt; console.log("done", results)); function test (uri) { return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(uri.replace(/http/, "https"), 1000))); } function map_serial_with_delay (f, ms, list) { const init = Promise.resolve(); const results = []; return list.reduce((p, uri) =&gt; p.then(after(ms, () =&gt; { return f(uri).then(result =&gt; { results.push(result); return result; }); })), init).then(() =&gt; { return results; }); } function after (ms, f) { return () =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(f()), ms)); } 
Bullshit. I can't believe it. Also `pnpm` is pretty the fastest, not only feels that way. So graphs that shows it is the slowest manager is definitely not for believe.
What he said. 
that's not a hack but making it work + unusable at the same time. well I didn't really specify that it would need to be "perfect" to even use it, but yea.. it's actually weird to me this wouldn't exist somewhere actually, I mean, something popping up from the very bottom and pushing the divs before it upwards... maybe I am wrong
Internet explore is the one behaving incorrectly, see the documentation for [string.replace](http://devdocs.io/javascript/global_objects/string/replace)
Its not accessible though https://github.com/chartjs/Chart.js/issues/3970 https://github.com/chartjs/Chart.js/issues/1976
https://glitch.com
does your solution fulfil this requirement? &gt; However, each request has to be delayed by 100ms (to avoid rate limiting). 
&gt;document.getElementsByClassName(id) getElementsByClassName returns an HTMLCollection of elements whose *classes* match the inputted string, as the function name suggests. There should never be more than one lement with any particular ID. I'd recommend never using any of the HTMLCollection methods though - they can't be directly iterated over with forEach, and they're *live*, which makes reasoning about them more difficult than it has to be. It's probably better to prefer *querySelectorAll* in almost all cases. &gt;Assign elements an itemId (&lt;input itemId="submitBt"&gt;...) and then use jQuery selector to retrieve it $("[itemId=submitBt]"). That's not a jQuery selector: that's an ordinary CSS selector, just like querySelector and qSA uses. (It's also bad practice to use nonstandard attributes when they're not necessary) It quite irritates me when I see people recommending the integration of a big library (with a whole new batch of syntax to learn) just for the sake of saving a couple characters when typing code.
* Don't post screenshots, post actual code if you want people to be able to interact with it and debug it (I recommend JSFiddle when it isn't broken) * /r/learnjavascript * W3Schools is a poor resource. Using ".onclick", ".onchange", or "on" anything is bad practice and results in poorly factored, hard-to-manage code; as well as limiting you to one event listener per event. Consider attaching your events with addEventListener, instead, eg: https://developer.mozilla.org/en/DOM/element.addEventListener
This. You want to avoid fatigue? Choose the framework that is most appealing to how you write code. Meanwhile get better at vanilla, because it dictates how well your career advances.
 function requestAllWithDelay (urls, delay) { return urls.reduce((promise, url) =&gt; { return promise .then((responses) =&gt; { return fetch(url) // Or whatever request library you're using. If it doesn't support promises, you can wrap it in `new Promise((resolve, reject) =&gt; someLib(url, { onSuccess: resolve, onError: reject }));` or something similar. .then(response =&gt; { return new Promise(resolve =&gt; { setTimeout(resolve, delay, responses.concat(response)); // replies.concat might not work, depending on how you want to accumulate all the data. Maybe you don't even care about the responses? }) }) }) }, Promise.resolve([])) } That looks very much like the callback-like promise antipattern...
You are trying to access a variable that is never formally declared(meaning it wasn't passed in as a param in your function, doesn't use the 'function' or the 'var' keywords to store it in memory). What u/name_was_taken is showing you is how to fix your issue using the var keyword to store the variable 'sum' targeting the dom element 'sum' (by id). etc etc. Let me know if this wasn't super clear.
One funky way is to use system-sleep, might be the most readable 
It was clear enough. Thanks!
Sure, that's why at the bottom of my code, I've also included an async/await. Now to address the main issue, we're technically dealing with nested promises. There is the over-all promise chain, that we just care about having an array of responses. **But**, each of those promises in the chain need to do an internal request, process that data, then return it to the parent chain. Sure, we could refactor this into separate functions to avoid nesting, but this is just example code.
`--frozen-lockfile` ends up the same time. Internally yarn will still check the package.json file and validate it against the yarn.lock file. If there is a change to package.json, on a normal `yarn install` the lockfile will be updated to match package.json. However if `--frozen-lockfile` is passed and yarn detects that the package.json and yarn.lock are out of sync, yarn will exit with an error instead of updating yarn.lock. This is recommended in CI builds because it usually means a dev updated package.json without committing an updated yarn.lock file.
I would use `.reduce` and `await` for the cleanest looking code. const urls = [ 'https://reqres.in/api/users', 'https://reqres.in/api/users', 'https://reqres.in/api/users', 'https://reqres.in/api/users', 'https://reqres.in/api/users', ]; const resolveAfterSeconds = function(sec) { return new Promise(res =&gt; setTimeout(res, sec * 1000)) } const getURLs = async function() { const results = await urls.reduce(async (listP, url) =&gt; { const list = await listP; // await the resolution of the promise of the previous iteration await resolveAfterSeconds(1); // wait 1 second const response = await fetch(url); const responseText = await response.json(); console.log('have response'); return list.concat([responseText]); // with async, this gets automatically converted to a promise that resolves with this value }, []); console.log(`done, results ${results}`); } getURLs();
I haven't done work in the Java space in ~15 yrs now, and never had the change to play with Maven. Could you enlighten me as to how it solves the issues that the Node community struggles with? (honestly. I'm not trolling. I'd actually like to know.) As far as I know, Bundler from the Ruby space suffers from nearly all the same problems but it's much less public when things blow up (i.e. users unpublishing packages, users using weak passwords and having accounts hacked, users selling their libraries to hackers to spread malicious code, package name squatting, people publishing packages with very-similar-to-real-packages names to spread malicious code, etc.)
Yeah Polymer is supposed to be like a web components polyfill, and if Youtube's new Polymer-based front end is any indication, performance isn't great
I released two packages to npm last week. One, which has only one other similar package on npm, got 112 downloads on the first day and 56 on the second day. The other, which has several similar packages, got 34 downloads on the first day and ~12 on the second day. I had read this post earlier, so I wanted to see if the first package is actually generating organic interest. I added Google Analytics data gathering to the more popular package to track install events only. 24 hours later, nothing on it and I thought something was wrong with the analytics script. I tested installing my package on a couple of machines and the events showed up on Google Analytics immediately. The packages have been on npm for 8 days and the analytics script has been part of the more popular package for ~6.5 days. The more popular package has ~900 downloads but only ONE install event (apart from my test installs) has been registered. 1. The analytics script is a postinstall script in my package.json and postinstall scripts can be ignored while installing. I doubt that all but 1 of the 900 'people' who downloaded it ignored scripts while installing. 2. Postinstall scripts may not always be as trivial as mine where you track install events. So I doubt that researchers, npm mirrors and network aggregators would ignore scripts by default for all packages they are scraping/researching. 3. My package is fairly straight forward and has no CI tests. 4. @bradrlaw's suggestion seems to be one of the explanations here. Malicious downloads to scan packages for keys / access tokens will probably not be interested in scripts/dependencies Correct me if I am wrong above. Also, I have added the less popular package as a dependency for the more popular package since day 1 (actually needed). If a "person" (normal person who wouldn't ignore dependencies) installs a package, shouldn't the download counts for the installed package AND its dependencies be updated? If so, the argument inclines heavily towards malicious scanning because my package has ~900 downloads and the dependency has about 120.
Learn javascript in and out and learn the basics of DOM manipulation you will be able to pick up frameworks incredibly quickly once you understand the fundamentals every framework is abstracting.
Google analytics tracking script can be added if one is really keen.
Hi /u/sgnl_, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
Hi /u/yuri3330, For javascript help, please visit /r/LearnJavascript. Thank you!
This is exactly what we look for. We add "framework knowledge" as a plus, but don't care one bit which one. If you're good with vanilla, then you can get up to speed with any framework within a few weeks. Our expected time for a new hire to get up to speed with our setup is typically a month. During that time, we give small non-urgent tasks or features we'd like done. 
Just to add a bit of context and describe a subject where such generator can be useful. Let's say we are building a turn by turn game in JavaScript (2048 for instance). Each time the player plays a round the IA uses an internal random generator to guess its next move (adding a 2 or 4 in the grid). If we want to add some kind of cancel operation, then replaying the user input might lead to a completely different situations given we use unpure random generator. Using a pure one we just have to ask the generator again for its value. Such problem can easily be encountered in implementations of 2048 allowing the back operation.
I prefer Jasmine.
I don't believe that bluebird's `all` method has a concurrency option, only `map`. I'd do something like the following: const Promise = require('bluebird') const request = require('request-promise') const uris = ['http://google.com', 'http://facebook.com', 'http://newyorktimes.com'] Promise.map(uris, (uri, i) =&gt; Promise.delay(5000).then(() =&gt; request(uri)), { concurrency: 1 })
First &amp; foremost, Flux is an architectural pattern. It defined the Unidirectional flow of data down a component tree. This fit reacts virtual dom perfectly. The flux library came later, based on that idea, but not perfect by any means. Then came the era of "flux wars". A new impersonation of that architectural pattern every day. Redux did it very well, as evidenced by the end of the said flux wars. Now, coming to your question. Where does it end? It depends on what you aim to build. I highly recommend reading Redux documents thoroughly. Even if you don't choose it. It gives you a good idea of how to visualize. Would highly recommend spending some time understanding: setState() Functional setState React Context (coming soon) Redux Mobx (if you are into reactive programming) Unstated The correct answer would be a combination of some or all. For many applications, setState may be more than sufficient. You can perfectly mix and match, The architecture is just an answer to a question. Whether that question is applicable to your project is something only you/your team can say. 
Definitely, but I think the example needs to explicitly do that, since it's likely that OP isn't as familiar with promises/async+await.
Use your standard library state management until it is absolutely too complicated without a state management specific library. Then consider our lord and savior RXJS, Redux, MobX, Vuex, or whatever the hell else is popular. Goodluck
Yeah you can only use the native components. You can't use UI libraries. Icons aren't currently supported, I'm still waiting on libui and libui-node implementation. 
I'm not exactly sure what you mean, you can call the func by passing no arguments. const func = (a, b) =&gt; console.log(a, b || 'test'); const s = slurry(func); s('a', null)(); //=&gt; a test The primary goal is to allow partially applying arguments, very similarly to using `bind`, but just in with a more terse syntax (and no `this` replacement).
React
Vanilla JS (ES6) // wrap setTimeout into a promise so we can use async/await async function wait(ms) { return new Promise(resolve =&gt; { setTimeout(resolve, ms); }); } // loop over uris and fetch each, waiting 1s between. async function doRequests(uris) { for(const uri of uris) { await fetch(uri); await wait(1000); } } const uriList = [ 'http://example.com/one', 'http://example.com/two', 'http://example.com/three' ]; doRequests(uriList).then(() =&gt; console.log('done'));
I am sure that it is slow. 2-5-10 times slower that "normal" memoization libraries due to magic under the hood. They key point - it could memoize anything, and perform more "deep" memoization, making it (in some cases) - the fastest library.
Thanks to everyone who replied, nice to see even a new friendship formed in this thread lol ... my understanding of this has become: var Life = {} var Animal = Object.create(Life) var Monkey = Object.create(Animal) var Human = Object.create(Monkey) var kevin = new Human(); in prototypal, we would have new five objects in the system, but creating more humans wouldn't create more Life/Animal/Monkey/Human objects, because all new humans would just refer/delegate any respective functions and variables to the corresponding ancestors. So for this system, we'd have (number of humans) + 4 Objects. In classical: we'd just have one object, the kevin. Life/Animal/Monkey/Human would only exist in code and not to the client browser (if JS was a classical of course). So only kevin would affect memory, performance, and [whatever else]. However, kevin itself would contain everything that Life/Animal/Monkey/Human has, so classical kevin is a larger object than prototypal kevin; quantity vs quality type of difference (?). So in terms of memory space the difference would be that if we have a billion new Humans. Prototypal = billion * (each new human's additional bit size) + 4 ancestor's bit size. classical = billion * (each new human's additional bit size) + billion * (resulting Human bit size from Life + Animal + Monkey + Human). So it would seem like prototypal saves a lot of memory space????? However in practice this difference is trivial because we'd have A LOT of object types but each type probably doesn't have any inheritance or very few level of inheritance; composition over inheritance. A later thread also mentioned prototypal doesn't have polymorphism, but, for example, a function wants to handle a string and a number js can handle it albeit adding complexity to the function. A different thread mentioned the possible convenience of virtual method, but js can achieve that provided having to delete all the same function name space from children up to the desired parent level. in conclusion: the biggest difference lies at the memory space taken when there are a lot of the same object, like A LOT. There are some additional functionality in classical inheritance that js prototypal doesn't have. however, memory or additional functionalities wise, the difference should NOT matter because we should abide by good coding practices and concepts (ex: composition over inheritance, good name spacing, good separation of concerns ...) 
Jsfiddle ☺
 for(uri of uriList){ await requestURI(uri); await new Promise(res =&gt; setTimeout(res, 100)); }
Not in my experience.
Cool
I honestly don't know in detail how the whole stack works because it's so rarely a problem. But short answer is that all versions of all dependencies for all your projects are downloaded to a single folder and the correct version is just associated at run-time. Transitive dependencies on different versions is a bit of black magic that will on rare occasion cause a conflict, but it's generally incumbent on library developers to be backwards compatible or to fork your artifact if you're radically changing the API. When you run a build it just checks if a satisfactory version of the dependency is present in that folder and then skips the download step. Using a standard "fat jar" deployment model, all the appropriate dependencies are extracted and then stuffed back into an archive with all your source code giving you a single file with all the needed bytecode. As of Java 9, you can also bundle the runtime into that archive. In terms of artifact governance, it was never owned by a single source. Sonatype was the company behind the initial development, but it's been owned by apache since early on. Both Sonatype and Apache have authoritative repos, but there are others out there. Sonataype also has offered enterprise repository software on a freemium model since very early.
ELI5 reactive programming vs. normal react development?
Pretty neat! Curious, what are you trying to achieve here? Using more math in code seems like an odd goal. Are you trying to learn math specifically or wanting to gain knowledge to become a developer or ...
I came here to suggest `RxJs` or some other `Observable` library. Everything else will be you hand-rolling the methods on the Observable.
did u even read my post 
I've been playing around with redux + createContext. I think it's quite a nice pattern because you can get that feeling of multiple stores and data encapsulation whilst having the benefits of single store middleware and redux devtools
Thanks! But I think that in this case FireFox\Chrome\Opera should behave just like Internet Explorer, because if the first parameter is a string instead a regex pattern, so, everything in the second pattern should be treated as string and any regex pattern should be ignored! But anyway, that's the way it is so I can live with that! Thanks!
Remember that the simplest app architecture is this: class App extends React.Component { state = { // THE ENTIRE APP STATE } render() { return ( {/* THE ENTIRE APP IN ONE FUNCTION */} ) } } It's REALLY easy to forget There are certainly reasons to start abstracting things out of the App's render function. I think that you should be starting to get annoyed first before you start splitting things out. Having said that, I would keep an eye the new React.createContext API. It seems like a beast for vanilla React state management when used in tandem with setState. 
Too late in the day for me to ELI5, hopefully this link helps https://gist.github.com/staltz/868e7e9bc2a7b8c1f754 also, reactive programming and react development are independent of each other, you are fully free to use one without another. Also, I see that the formatting of my answer is not how I typed it on my cell. 
This is the simplest solution I could come up with: const sleep = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms)); async function getUrls(urls) { const results = []; for (const url of urls) { const data = await fetch(url); results.push(data); await sleep(100); } return results; }
setState + createContext is finally the vanilla React solution that scales
Related to having a detailed understanding of the ins and outs of vanilla JS and OOP, here are two relevant sources you could check out as a refresher: https://watchandcode.com/ https://javascript30.com/
Love this answer (and the wording)
So learn basic javascript first, then learn a little about the different frameworks, and you should be able to land a junior dev role?
First and foremost you should bet on writing **clean code**. It's a fundamental thing, next you should choose some well-known code/design patterns :) https://github.com/ryanmcdermott/clean-code-javascript https://github.com/rwaldron/idiomatic.js **https://github.com/DrkSephy/es6-cheatsheet**
Yeah, so happy about that, too. Though i doubt this will be used raw. I made notes regarding some issues we bumped into [here](https://github.com/drcmda/react-contextual/blob/master/PITFALLS.md). (We have a large context heavy app at work and the minute they merged the api we tried to evaluate it).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [drcmda/react-contextual/.../**PITFALLS.md** (master → 4506f68)](https://github.com/drcmda/react-contextual/blob/4506f68269a5f6a05791de2e7076f9330b5d7ee0/PITFALLS.md) ---- 
As someone who also sucks super bad at math, I think "using more math" is a great goal, and I hope to do something similar. Math is something which we all need and use, and unfortunately isn't often taught well etc. so here we are
Generally they look good and your code is quite readable, if not entirely efficient. Utilising math does not necessarily improve your code, using algorithms on the other hand improves your efficiency. However you may want to write up accompanying posts about why you chose the specific library and why you made certain decisions ? It does help 
I suggest reading about the [model-view-controller pattern](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller). Redux and Flux trick you into thinking you're using a library when really you're just separating concerns, because why is your business logic in your UI code anyway? Let's imagine you wanted to create an alternate UI for your app. If your react components are responsible for managing their own state, you'll have to duplicate the business logic in both versions of the components. This is very error prone because you'll have to remember to update both to add new features or fix bugs while remembering the subtle difference between them. Of course you can [lift up the state](https://reactjs.org/docs/lifting-state-up.html) from your UI components into a container component, and put all the business logic there. But now imagine you have to create a version of the site to support users without JS enabled and need to put the logic into the Node JS backend, or your CTO decides Vue is the new hotness, or you need a command line version where React doesn't make sense. *You need to lift the state out of React itself.* A state container is just a place to put that state and business logic, or the "model" in MVC, so you can plug it into whatever "view" you like. Libraries like Redux make it convenient, but we've been doing basically the same thing since Smalltalk-80. So should you refactor your app? Unless you're hitting the problems above that led us to the MVC pattern, remember YAGNI. But if you expect your app logic to grow and grow and grow, or expect to support multiple clients, MVC could be right for you.
You can mostly definitely return await in an asynchronous function
Nice work man! Also, Coding Train! 👍
Don't really have a goal as such just wanted a small fun side project in which I can learn new techniques and expand how I programming by making use of math and algorithms.
Thanks for checking. I actually think this is a huge deal in terms of being a potential footgun of `npm ci`. Ignoring `package.json` entirely opens the door up for `package-lock.json` desync-ing in the opposite direction. Imagine a scenario where a Perforce user checks out `package.json` and forgets to check out `package-lock.json` updates/adds/removes some dependencies, then submits and triggers a CI build. In that case, it will be as if no changes were made according to the CI, so all tests will pass. User 2 creates a new perforce client and runs `npm install`, getting the new dependencies and still not updating the lockfile. Somewhere down the road these inconsistencies will break, but without failing fast devs are going to waste a lot of time trying to figure out wtf is going on. 
Thanks, algorithms is definitely something I'm starting to learn about and trying to use in future projects. I chose not to use a compiler so others can see the code and what's going on, a write-up for each is a good idea I'll try to start doing that. 
Best channel on YouTube, only found it recently but has given me so much inspirational to start this project
I like what you have so far, and it is inspiring me to try something similar myself. Looking through your code of the first week's animation, I am a bit confused by the use of map(). I tried looking up documentation of this function (which I'm assuming is a prototype), but all I'm finding is member functions of arrays and whatnot. Could you explain what is different from that to the map() function you used, or point me to some documentation about it's use?
I don't think you can clear the clipboard but you could replace it with a space or ... [https://jsfiddle.net/swL8ftLs/1352/](https://jsfiddle.net/swL8ftLs/1352/) 
Then this technique will not help you I'm afraid. I haven't looked into finding out how to detect someone else's plugin.
This is the most straightforward way I can think of doing this. const uris = [ 'https://jsonplaceholder.typicode.com/posts/1', 'https://jsonplaceholder.typicode.com/posts/2', 'https://jsonplaceholder.typicode.com/posts/3', 'https://jsonplaceholder.typicode.com/posts/4', 'https://jsonplaceholder.typicode.com/posts/5' ]; async function fetchPathsWithDelay(paths, delay) { const results = []; for (const path of paths) { await fetch(path) .then((res) =&gt; res.json()) .then((data) =&gt; { results.push(data); }); await new Promise((res) =&gt; { setTimeout(res, delay); }); } return results; } // Example usage fetchPathsWithDelay(uris, 100).then((results) =&gt; { console.log(results); }); 
Best I have found is to send an XHR to chrome-extension://${extID}/cast_sender.js, but that requires knowing what scripts exist for all extensions.
On what, football?
I've been in on these types of interviews as well and had similar experiences. Frameworks are great. They do some amazing things for us as developers but I've seen plenty of developers, of all levels, struggle with something because they never invested in the browser runtime or vanilla js. I get it. There's a lot going on. Micro task queues, CSS object models, function execution contexts and closures, etc... It's hard and you don't need it to build an app but it's way easier to build better apps if those things aren't a mystery. It also makes it easier to understand exactly what those frameworks do for you and how to leverage their power.
I agree, but there is no way to know that all the expected arguments have been given. I could make it so that number can be provided on creation, but then the pattern would break down for functions with a variable amount of args (ex. `(a, ...b) =&gt; ...`).
That sounds ok for a Jr. role, as well as a firm grasp on layout since that's what we like to give Jr devs to keep Sr devs on the more difficult tasks. Not only learning different frameworks, but all the different pieces of dev, but those are the things you'll pick up as time goes on. Hopefully you'll get a job that cares about lifting up the team by giving free time to look into new things. It helps everybody, not only the individual. 
I stand corrected
Enum values and unique IDs.
So, far as I'm aware, Observables are a subset of Promises. RxJS offers the `fromPromise` and `toPromise` operators to convert freely back and forth when possible. [Here's the relevant RxJS interface](http://reactivex.io/rxjs/class/es6/MiscJSDoc.js~SubscribableOrPromiseDoc.html).
In my opinion Redux is the best state management tool out there, but also the one with the highest learning curve. If you already know how to use it then I think it's the right tool to pick for all but the simplest project. However, if you don't already know how to use it you should put off learning it as long as humanly possible ... which means sticking with `setState` until it becomes so painful that learning Redux looks good by comparison ;) The same very likely applies MobX or any other high quality state management tool, but since I've gone with Redux that's all I can really speak to.
Here is my over engineered attempt at a solution. I've tried to add as many comments as possible to explain my process. // construct an object for each request to hold it's state const request = (data, sendRequest) =&gt; { const request = { promise: null, isInFlight: false, isResolved: false, isRejected: false, value: null, error: null, attempts: 0, send() { request.inFlight = true; request.attempts = request.attempts + 1; const promise = sendRequest(data) .then(response =&gt; { request.value = response; request.isInFlight = false; request.isResolved = true; request.isRejected = false; }) .catch(error =&gt; { request.error = error; request.isInFlight = false; request.isResolved = false; request.isRejected = true; }); request.promise = promise; return promise; } }; return request; } // use this to find requests that can still be sent out const requestIsWaiting = request =&gt; !request.isInFlight &amp;&amp; !request.isResolved; // use this to determine if a request is resolved const requestIsResolved = request =&gt; request.isResolved; // expects: // - an array of data // - a function to take each item of data and send the request // - and some options const queueRequests = (data, sendRequest, { throttle = 1000, maxAttempts = 1 }={}) =&gt; { // return a promise to promise chain easily return new Promise((resolve, reject) =&gt; { // map each item in our data array into a request const requests = data.map(item =&gt; request(item, sendRequest)); // loop until all requests are resolved const intervalId = setInterval(() =&gt; { // find a request which we can send out const waitingRequest = requests.find(requestIsWaiting); // if a request can be sent out if (waitingRequest) { waitingRequest .send() .catch(error =&gt; { // reject the promise if a request has reached it limit for failures if (waitingRequest.attempts === maxAttempts) { clearInterval(intervalId); reject(error); } }); } // else check if we all promises are resolved else if (requests.every(requestIsResolved)) { clearInterval(intervalId); resolve(requests.map(request =&gt; request.value)); } }, throttle); }); } // list of uris to iterate over const uris = ['https://google.com/','https://google.com/']; // here is where you would wrap your request function, which should return a promise const sendRequest = uri =&gt; { return Promise.resolve(uri) } queueRequests(uris, sendRequest, { throttle: 1000, maxAttempts: 5 }) .then(console.log) .catch(console.error);
I think AppJS has been end-of-lifed, or is at least no longer maintained. You should check out [Electron](https://electronjs.org/). You can [write addons in C/C++](https://nodejs.org/api/addons.html) fairly easily, and communicate to/from the V8/JavaScript side. Good luck!
"Lord and Savior &lt;framework I choose&gt;" hehe
I may have asked you this before in another thread, but: What concerns do you have with the learning curve for Redux? Is it anything we can improve through updates to the docs? If so, any suggestions?
community reddit clone for devs webdesign
a common approach is to turn a promise into an observable &amp; then use the observable syntax. This is favorable to creating a new Resolvable API. Personally, I'm not a fan of observifying all the things. They are harder to read, and you'll either forget to close the observable when data is received (resulting in a memory leak) or you'll have to always send a data frame followed by a "completed" frame that closes it. Sending an extra message for every async request is not great, but I see it everywhere &amp; it's preferable to chancing a leak. Although they aren't sexy anymore, this is something that event emitters got right: expecting a single response? use `once`, else, use `on`. 
Oh Yes ! am sorry i didn't mention it, but not the american football.
What is the end result of this? Is it still an issue? I'm trying to follow the rabbit hole but I came up with at least two other issues for subsequent versions of npm.
https://nodejs.org/api/child_process.html
Rxjs is not good for state management. Great for things that deal with lots of events, but it falls short with data because due to "glitches" 
Absolutely you can. Software engineering is not about any specific language technology. Software engineering is about understanding the various concepts that software engineering employs, and using the knowledge of those concepts to design build and maintain software systems. But here’s the thing: if you can’t see beyond python and JavaScript then you’re not a software engineer. You can’t be a software engineer if you just stop at two languages because so much code you will encounter professionally will not be python or JavaScript. Now, this doesn’t mean you can’t get a job that has the tittle “software engineer” if all you know is JavaScript and python. It just means that despite having the tittle, you’re falling short of why software engineering is. You can absolutely prefer JavaScript and Python as your go-to tools and be an absolutely fantastic software engineer. But if you can’t utilize any other language technologies you will never be able to use the right tool for the job in all the jobs you encounter for numerous reasons.
https://j11y.io/jquery/#v=1.11.2&amp;fn=jQuery.fn.slideToggle
It's bad enough having to leave my local spots on days they're firing to drive into the city to work, at least Austin has NLand! :D
C++ is an incredibly powerful, and cross platform language that will not only teach you a lot, but is something almost any employer would take as a plus. C# and the .NET framework are also fantastic if you plan on developing native Windows apps (and a bit of cross platform) but won't teach you as much as C++ Any flavour of SQL is also ridiculously important in a world where data means everything
I code in Javascript 100% front and back end, and we have a hell of a time finding qualified JavaScript ppl.
Not sure what information you’re trying to pass along here?
That makes a lot more sense, thanks for the help.
So... I take those comments rather seriously, since I'm the unofficial keeper of the Redux docs. I also spend most of my time answering questions about Redux (and React) everywhere online. Some people say that the Redux docs are fantastic and covered everything they needed. Others (like you) tell us that they're not very helpful. Part of the issue is that there's a lot of different learning styles out there. Some people just want code to copy-paste and have something that works. Some people want to be taught all the concepts in small pieces, and pull them together. Some people want a full-blown real-world app to dive into. Dan Abramov's teaching style is primarily the "teach the principles and pull the pieces together" approach. The main "Tutorial" section is still basically what he wrote originally. If you look at the Redux issues list, you'll see [I have a bunch of open issues tagged "docs" right now](https://github.com/reactjs/redux/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3Adocs). I've got a bunch of ideas for things I'd like improved. I completely want to revamp all of our docs around React-Redux, we've got more FAQ entries to fill out, and we're desperately lacking a "Next Steps" section that covers the gap between writing a Todo app and building a real-world project. Unfortunately, I'm already overwhelmed with all the stuff I _want_ to do. I've got workshops I'm planning to teach, presentations to prepare, blog posts I'd like to write someday, docs improvements on my todo list, and then there's all the discussion going on around React 16 and how React-Redux is going to work with all the new async behavior. I am completely swamped right now, and simply do not have time to go make extensive changes to the docs. So: **I sincerely request that you (or anyone else reading this) FILE ISSUES AND PRs TO HELP US MAKE THE DOCS BETTER!!!** If they're not good enough, then we need the community to step up and help us improve them, not just express concerns.
Free Code Camp maybe..
Amen, and please accept my apologies as I realized (before you even responded) that my post was a little disrespectful, so I edited it to fix that. But I think at least part of the problem is something only someone in your shoes can solve. I could for instance submit a PR to make the Core Concepts page leverage people's existing knowledge more, but I can't make one to solve the signal to noise issue. Someone with control of the GitHub front page and site needs to make a constant decision to "direct" new users to the "correct" path of learning, and ensure that direction isn't overshadowed by the millions of other Redux details being presented.
did you just call yourself a 'rock star' software developer? I thought that was just recruiter spam.
You mean adding a new import DeprecatedI18NPipesModule? It was pretty painful, man. I had to call in sick from typing those extra letters.
https://www.10xmanagement.com/
Imagine ripgrep plus faster hard drive.
It's setting the innerHTML of some element (`p`) to `p.` plus some seemingly arbitrary number every 64ms. I have no idea what the purpose of this is. 
Sure, apology accepted :) Like I said, part of the issue is learning styles. We seriously do get a lot of people saying "the Redux docs are great!", so it's not immediately apparent what other approaches or docs structures might be more helpful to people. Could you at least add some examples of what you mean by the "signal to noise issue"? Even better, could you open up an issue and write up some of your concerns, even if it's just copy-pasting most of your comments?
"You can’t be a software engineer if you just stop at two languages because so much code you will encounter professionally will not be python or JavaScript." I was suggesting that was untrue based on my experience. Javascript alone is a perfectly viable path in todays job market, has been dominant on the front-end, and is now hugely popular on the server with Nodejs. In the past that wasn't the case, now it is. That said, it is definitely good to have a wider array of experience with sql dbs and strictly typed languages as well.
You do not sign up with the best "Rock Star" agencies, they come looking for you. If you still call yourself a "Rock Star" then they will not look for you. If you need someone to setup "Gigs" for you. You are not that good. I have the social ability of a stone, but when I freelanced I had 5 years of back to back contracts, because I know my shit.
There's a point where it becomes not so noticable
It *should* be pretty trivial. Do you have a link we can test out?
Sadly it is an internal site but I can probably set something up in the morning to illustrate the issue. I know it sounds trivial, and that makes it extremely frustrating.
That's a machine piece of machine learning code. The variables and corresponding integers express a data set which should produce some form of active data visualization.
I think these are great. A someone who hires from here and there, a small portfolio/project like this is a really great way to get interested in a developer. It shows some initiative and passion. Kudos to you.
Also do check 30 seconds of code repo on GitHub. It'll give basic concepts of how to solve problems regarding Array and Objects in JavaScript
Yeah - we just upgraded to the beta version of Gitbook, and unfortunately a lot of the docs pages don't seem to be redirecting properly. We're tracking this in [Redux issue #2846](https://github.com/reactjs/redux/issues/2846). I'm sorry to hear that Dan's videos are coming across as "too advanced". They're intended to be small bite-size lessons that walk through basic concepts (using the the "teaching from basic principles" approach that I mentioned above). Like I said, I know everyone has different learning styles, but most people seem to find those videos helpful. Could you maybe provide some feedback on what aspects of those videos seem too "advanced" ?
Might be useful for variadic functions, but in most cases I prefer an implementation more like Ramda's where you explicitly declare the arity or infer it from function length. Interesting work in any case. 
As someone just starting out.....me looking at this stuff: https://m.imgur.com/gallery/vh1oNEk
I mean that you can't do for example `const add = (a + b) =&gt; a + b; const add1 = slurry(add)(1); const result = add1(5);`.
It sounds like you tried to solve the case multiple redux stores could solve. I've mean - put data into different stores and they will not interference, consuming CPU when it non needed. Next one could use something like redux-restate to join different stores together.
Also have a look at NWjs, previously known as NodeWebkit. In my experience it is a bit easier to use than Electron.
Can you post what you have so far? Maybe someone can come up with something that builds on it.
Yea possibly . Thanks for the feedback dude 
It's quite nice once you get used to it. The best part is it's much easier to create your own observable operators or even higher order operators that combine multiple existing ones without having to then monkey patch your custom operator into the observable prototype.
My team and I work building RIAs. We have been doing that for years with ExtJS and now with React+Redux. Its overwhelming how simple and useless most tutirials are for this kind of webapps. The context is a tiny todo app, whereas we have SPAs with websockets, dozens or hundreds of view, complex visualization data... Hell, where the examples show you a grid with an array of data we have a tree with sorting, filtering, reorderable and resizable columns, buffered data... I understand the context is simplified for the sake of learning, but it seems like nobody's doing (or willing to share expertise about) complex UX applications.
Nobody uses Cypress?
Is that a process in which they check whether the lock file actually satisfies the requirements of package.json? (Which makes sense to only skip in CI, though I wouldn't have expected that to be such a massive speedup.)
https://github.com/posabsolute/jQuery-Validation-Engine
I have learned redux for 2 months,and starts understanding why it has this structure.I understand it after I found out it's so easy to call state or actions from anywhere. The doc itself,I barely know how,but don't know why.As you said,I copy-paste the example,it works.Then I focus myself to remember how to create a new state.Trying to make a Click Counter make sure I know how to do it. I admire it explains well how it improves state management.But the other part,I have read several times,I still don't get it why.I can only "just do it".I think other ppl may wonder a few questions,which I can answer now. Why Action?Why Reducer?Why Pure? Why action?I know redux make state globally,so why don't you just let me setGlobalState(),instead of dispatching action? Because declarative and imperative.Declarative gives you better reading.Also to share the action to every components. Why reducer?Isn't that we have action to dispatch to tell it what to do with the state? Because action tells you what to do with your component,and reducer tells you what to do with your state.The reason is similar with declarative. Why pure? Imagine there are 20-50 balls and you need to count them all,not that hard.What if the balls keep moving around,changing its position,can you count them? Then imagine the balls are variables,which keep changing from anywhere,anytime.How do you manage the variables?If you understand blockchain,you surely understand why. Luckily I have learnt functional programming before,understand the advantage behind it,otherwise it would takes me another period of time to understand why I'm doing it.But the other concepts,it really takes you a long time to understand why.Otherwise,you just have a gun,but using using it like a knife to fight.
Redux itself it's not hard to learn. The API is extremely simple, actually. The problem of Redux is that it is based in some complex concepts. So, when you learn Redux, you are actually learning Computer Science. 
Manually editing package.json should be forbidden, and every package install should go through `npm install X`. Using `npm install` without a 3rd argument should do what `npm ci` does now. Sounds much better to me.
Can you call system commands ?
Nope. Facebook does not use redux. Source: https://twitter.com/dan_abramov/status/882626668627709952
&gt; https://nodejs.org/api/child_process.html This is done in an non-blocking way? Is it possible to wait for that process to finish ("blocking way")?
Downvote.. In week one on your helix project, in your setup function you named the array `colours` but the elements `color`. Haha jk man! Awsome work! What has been the biggest challange thus far? 
Anyone 
1d old Reddit account. 
Rx isn’t a state management library in the same way Redux and MobX are
Redux is an implementation of Flux. It begins and ends where you need a big state management solution. Need to share state between components and passing by props isn’t practical? That’s when you might reach for something like Redux
thanks! this helps!
IMO you need to be able to trust that your CI build isn't causing false positives or negatives in terms of failure. Considering how common forgetting to check in your lockfile is, I think CI builds should not only check but fail fast in the event of a mismatch. 
Is that common, yes? Luckily, you are able to choose for yourself whether to use `npm ci` in your CI :)
This is a basic explanation, well written but nothing new or mindblowing if you already know it
Probably an easier way, but... If the image top left is at (0,0), and the center is at (50,50), and the user clicks (25,75), for example. First you will have to multiply the target coordinate system by the zoom level. If the final zoom level is 5x, then the user click is now at 5x(25,75)=(125,375) Assuming the center of the *container* of this image is still (50,50), to center it you need to move the image to (centerX-zoomedUserX, centerY-zoomedUserY) to center it after zoom. x = 50-125 = -75 y = 50-375 = -325 This will also work if the user click is &lt; centerX and centerY.
Why use someone elses implementation you know has flaws when you can make your own state management framework for only 9.99$ ! 
I don't call myself a rock star, I'm just using a term people would recognize the meaning without me having to be overly verbose, I suppose. Yeah having someone to coordinate freelance work for me is what I mean. I want extra income but I don't have the patience or creative marketing ability to do it myself. 
 thank you. I'll look at them. 
Not off the top of my head - but maybe this would work - you can provide a specific stylesheet for print and hide the pages you don't want printed.
Which sound like an urban legend. 
Glitches are when you have two streams emit in quick succession, which causes some downstream computation to run twice. This is a well known problem and results in wasted computation, and can make you guard against things that should never happen. Things like mobx trace the dependency graph and runs computations in topological order to avoid this sort of thing. 
Brad Traversy’s Udemy course - Modern Javascript from the beginning . 
source code: https://github.com/slatom/glitter
If you’re not building this as a learning project and just want to get it done, I highly recommend this library called panzoom. We use it for viewing giant PNG voter data maps and it works great across devices. Has a decent API too. https://github.com/anvaka/panzoom/blob/master/README.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [anvaka/panzoom/.../**README.md** (master → 6832ec3)](https://github.com/anvaka/panzoom/blob/6832ec302bd552e288898f5579eebdbd0ed7f230/README.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dvbiokf.)
Nope
Ok
&gt; Glitches are when you have two streams emit in quick succession, which causes some downstream computation to run twice. This is a well known problem and results in wasted computation, and can make you guard against things that should never happen. Wow, I have never ran into this but I would love to read some more about it so I can start implementing fixes in my RxJS heavy code. Do you have any resources for this?
I wouldn't say that `RxJS` has `redux` baked into it as much as I'd say that `RxJS` can implement the ideas of `redux` with `.scan(reducer, startingState)` and a `Subject`. The former makes it sound like you have `dispatch`, `getState`, et al out of the box with `RxJS`, which you don't in my experience.
I love this one: https://devexpress.github.io/testcafe/ It says: "supports desktop, mobile, remote and cloud browsers (UI or headless)."
I suspect the limitation is simply that many developers working on web or mobile apps today have only ever worked in those fields. Even senior web developers with several years of experience might never have worked on a large, complicated UI — or a large, complicated application more generally, for that matter. There are people working in those fields who do have some background with desktop UIs, or perhaps with designing UIs for environments like control rooms or vehicles. However, we’re probably a small minority, so I expect it will take a while for knowledge and ideas gained from that experience to spread more widely through the web community. In the meantime, most people in the field work mostly with very simple UIs, and so it’s natural that most tutorials will reflect that and we won’t see as much discussion of more advanced ideas. And at least we can smile as the enthusiastic young React developer tells those of us who were working on MVC architectures before they were born about this radical new “unidirectional data flow” idea. :-)
Using vanilla would be trivial to create a dispatch or getState so . . .
I 100% agree and tried to express that above. That doesn't mean it's baked in anymore than `flatten` is baked into the `Array` prototype because `[[1]].reduce((a, c) a.concat(c), [])` is trivial in vanilla.
ES stands for ECMASCRIPT
I agree, and understand what you are saying. 
I build front-end for airlines. We had to work with legacy code that wasn't React. So I had to create a new State Management system that could be easily digested by Vanilla apps *and* React apps, when we upgrade. I put the library out there for people to use. Check it out and lmk what you think [SubState](https://github.com/TomSaporito/substate) 
Civil discourse?!?! *Get out of here*
This is a very cool project. Well done!
American football? Oh, Armor Rugby, right? 😂😂
American football? Oh, Armor Rugby, right? 😂😂
wow this game is awesome
Thanks for your reply. Then, do you think there is possibility to use the React Native UI libraries?
Really fun! 
Thanks for this :) When I started out 8 years ago I was working as a front-end dev/designer, I gained experience with HTML/CSS/**jQuery** and built sites using Expression Engine as this was the CMS of choice at the agency I worked for. I picked up HTML, CSS quickly but often struggled with jQuery. To get to the point, I moved away from a dev role, and since 2012 been working solely as a UI Designer, mostly because I lacked the necessary knowledge of JavaScript and grew increasingly frustrated. As of this year, I've set a personal goal to learn **JavaScript** – I've been dabbling with the likes of NPM, Webpack, SCSS in small side projects so I'm quite up to speed with these. But in terms of JavaScript this is something I really want to learn and understand fully. As the role of a pure **UI Designer/pixel pusher** is somewhat fading, I'm hoping to progress back into the role of a front-end developer. 
A good overview is ironically given by this article that disagrees with me: https://staltz.com/rx-glitches-arent-actually-a-problem.html His suggestion is to avoid those situations by not writing small independent pieces of data that are combined into others, and instead pull your logic into a single stream. If you follow this logic to its extreme, we're basically talking about redux (one big reducer function) with rx managing events on top. 
&lt;input type="text" class="form-control validate[funcCall[isUniqueNic]]" id="nic" name="nic" placeholder="NIC"&gt; youre code isnt right. 
No sorry, I meant mixing custom syntax as properties on HTML elements. I'm not a fan of breaking convention like that. I prefer writing in pure JS such as React. I find it easier to reason about because it is just JS, nothing proprietary. I'm currently using Polymer now at work and I don't so much mind that because you define the properties you set so it's not breaking convention or using anything proprietary. As you said, it's personal preference. I do however feel vue.js has more popularity because it has a low barrier of entry, much like how jQuery rose to popularity. That's not to say it's a poor framework at all.
Now that I've been able to read that and a few of the linked articles around it, I can definitely see the issues we are calling "glitches". I am with Andre ( barely ) that this is a user-error and not "glitches" caused by Rx anymore than `promises.forEach(prom =&gt; prom.then())` doesn't work as expected unless you fully understand both `forEach` and `promises`. I might look into MobX a little more though if it offers refuge from this ever becoming an issue with my complex async logic that is abstracted away in observables! Thank you for the details!
If it were not jQuery, check out [HTMLInputElement on MDN](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement), specifically, search for `setCustomValidity()`. Your code may look something like: $('#nic')[0].setCustomValidity(data.valid ? '' : 'Value is not unique'); That said, I haven't use jQuery in years, and never heard of jQuery-Validation-Engine, but [looking at their documentation](https://github.com/posabsolute/jQuery-Validation-Engine#data-errormessage-custom-error), it looks to me that you could do something like: $('#nic').setAttr('data-errormessage-custom-error', data.valid ? '' : 'Value is not unique'); To address the lack of response, I think it's probably because: 1. This is specific to a jQuery plugin 2. The /r/javascript typically is more like a subreddit for showcasing tools and sharing articles 3. It's not clear that you've read the documentation for the plugin you're using 4. It's not clear that you've tried anything beyond this initial code. This is a big one, because no one wants to plainly do your work for you.
sorry i missed to type validate here . my code looks same as you suggested and it calls isUnique function . ajax also working . only thing is no validation popup.
Can you provide more information about "isn't working"? Does the process exit? How many messages get send currently? etc.
i think you have to return false and not the error message but i am not 100%. that bit should be in the docs though. 
thanks 
Naming private class members to avoid collisions/overshadowing by extending classes.
this is the example in doc https://github.com/posabsolute/jQuery-Validation-Engine#funccallmethodname I have use this before for some other custom validations. but not with getJson call . if i validate like below it works, //js function isUniqueNic(field, rules, i, options) { if(data.valid) { return '* User NIC is not Unique.' } } 
Wonderful! Loved this
whether you're called a developer or an engineer seem to depend mostly on which company you work at. I'd take a front-end specialist who is very experienced at engineering complex web applications in a given framework, over someone who knows a bit of this and a bit of that.
Pretty cool game. Can you enhance it so that it works better on mobile? I would love a win % statistic and a give up button.
React also have custom syntax with JSX. The Vue template is just hyperscsript under the hood. If you like you can use Hyperscript directly, or use JSX. 
Nice, simple to understand and straight to the point! Didn't know about the diff profiler in the memory tool, thanks! 
I’ve only used vue when it first released. It’s possible to do loops without having to use a property on an html element? Interesting development if so. Out of interest what custom syntax do you need for react? To me it’s always been pure Js, no custom templating element properties 
Not with templates, but you can just use JSX with Vue if that's your thing. 
Design skills are some of the least common skills I see in the developers I interview, even though it is a somewhat sizeable portion of the role. If you have a strong design background, and are able to supplement that with the programming side of things you will be very happy. If you're looking for resources, this youtube channel is a great one: https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q as well as this book series: https://github.com/getify/You-Dont-Know-JS
I'd like to see the reasoning why some people choose async/await/promises over reactive programming (RxJS and alike).
Why xvfb and not chrome headless?
A lot happened behind the scenes when Vue 2 was released. It now uses a virtual DOM, the template you write isn't HTML/DOM, it gets converted to javascript. There are some DSL (Domain-Specific Language) in JSX. Like class is classname. Anything with dashes must be written with camelcase. React/JSX doesn't differentiate between onchange and oninput, so in theory you only have oninput. You also have to mix a lot of logic in the view. The list goes on. They are both good, but JSX isn't as pure as many people believe. 
Looking forward to it then :)
Do you mostly build smallish sites?
It's open source guys! Make it even better!
Why is that relevant to what I said?
I just played that for like 10 rounds, thanks!
Thanks. I do appreciate your input. Actually I am not too proficient in vanilla js, although I can get certain things done that way. I use jQuery mostly because it is quick and easy. But I guess you're right I should start polishing my JS as browsers may start dropping the hat on JQ and then I will have to redo things.
I completely agree about usability of this now. I never felt right about using it.
I built my own JS framework. Ha ha, laugh if you must. Anyhow, for me, the router and componentization are the hard parts. Data binding is surprisingly the easy part. I honestly predicted the opposite. To do binding, I borrowed the syntax concept of built in directives from angular. Complicated attributes in the view, basically. Also, data that is data bound must be in a single big namespaced state object. The trick is you can use the native JS 'querySelector' function using attribute selector wildcards to target and update only elements bound to a given state property. Say I want to one-way bind a value of persons name to a div. &lt;div superframework="bindValue ||| State.person.name"&gt;&lt;/div&gt; Now, in my controller, I want to change the name, and have it instantly show as changed in bound elements. I just do that through a special function. superFrameworkUpdate("State.person.name", "Sammy") That function just gets a collection of elements bound to that value. It does it like so collection = document.querySelectorAll("[superframework*='" + State.person.name + "'] That returns all the elements bound to that specific property. The rest is easy. The 'bindValue' part just says it is a simple one way binding. I also have hide, loop, two-way, classes, attributes, end expressions. I have been fighting with componentization and how to do dependencies (my god its confusing), but the binding works like a charm. And I don't have to do a diff. I just use selectors.
That’s cool, nice way to reduce the ceremony around Redux. It’s still a bit facetious to say it’s a state management library and has Redux baked in. You’re essentially just using it as part of a Flux implementation, that’s like saying JavaScript has Redux baked in.
Although I have nothing to share this week, I really like this idea. I hope people contribute.
That isn't what they're arguing, their point is that what it means to be a software engineer is that you are someone who has command of the tools of programming on the whole and can thus pick the correct language to use for a given task based on this knowledge. 
Thanks for all the feedback &lt;3 I started this project around 4 years ago and have been slowly chipping away at it. It's nice that it's finally seeing the light of day and not just buried in my GitHub account. I'm planning on writing a series of blog posts on how I actually built the game. There's some interesting tech in there for things like generating the maps, AI, handling UI interaction, etc.
[className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className), [htmlFor](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/htmlFor), etc. are part of the web api standard. &gt; You also have to mix a lot of logic in the view. The is a largely misunderstood thing. React was literally made to divide business logic and the view. App logic comes comes in as props and therefore is easy to bind to external stores or sources. You probably mix it up with presentational logic, and that absolutely should be part of the view. It is part of Vues templates as well of course or else couldn't do loops, conditionals, etc. 
They're both good choices but if I had to pick I'd go with Tyler's courses because you'll be done with the courses within a year so you'll have access to more topics. However there's also a third option [egghead.io](https://egghead.io). It has a bunch of [free](https://egghead.io/courses/the-beginner-s-guide-to-reactjs) [videos](https://egghead.io/courses/getting-started-with-redux) you could check out before deciding to get a subscription. Only downside, it's more expensive BUT it has a lot more topics than just React and Redux. A subscription also allows you to download the videos which is nice. So I'd say if you have time to look at egghead do so and then make a decision.
This is actually quite fun. Nice job!!!
Bro! Awesome! Any chance you are in LA and are looking for a job?
Cheers! I actually live in Australia and I'm gainfully employed. Thanks for asking :)
Good points.
Good points.
A more interesting question is who would in in a fist fight? Jokes aside. Thanks for writing this up. A few comments. 1. I'm 27. 2. You can see all the projects being built on my GitHub. GitHub.com/tylermcginnis 3. I have a monthly option for $20 a month along with the yearly option. Theoretically if you learn quickly, you could get through all (6 of) the courses in a few months. Making each course pretty cheap. With that said, both options are great. I've also heard great things about Stephen Grider's udemy course. 
No, I'll see if I can get something happening.
Thanks for saying.
This is borderline not a memory leak, but it is to the point. A few more examples, from a simple google search: [link](https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/)
Thanks. It's actually based on an old iOS game called Strategery. I originally had it so the remaining armies would duke it out, but turned it off because occasionally it would take a while due to low dice rolls, AI, etc. Maybe it's not such a bad idea to turn it back on?
Cool, glad you enjoyed.
Thanks, as you can tell design isn't my strong suit.
Mostly no. I do use it occasionally for smaller projects but for the most part I don't really feel the need to use it for smaller projects.
I just spent about an hour playing it on my phone. It's very addictive. The only bug I found was I should have been able to move to an open touching spot and it wouldn't let me. Thanks for open sourcing this!
Thank you! :)
Thanks for the links, I just happened to discover the YDKJS series this morning :) Ha ha that YouTuber is brilliant, I've been following him for the past month, quality videos. 
As long as you provide a restart button / link, so it wouldn't get stuck, I think that would be cool.
&gt; This is a well known problem and results in wasted computation, and can make you guard against things that should never happen. http://reactivex.io/documentation/operators/switch.html There's an operator for that™
Wow, that was a long time ago!
&gt;Eloquent Javascript, which seems like a pretty good book to me, but is it up to date? https://github.com/marijnh/Eloquent-JavaScript Guess so
If you look at the script page on the docs : https://docs.npmjs.com/misc/scripts you'll see they have prepublish that has the broken behaviour described in that issue, but now they have prepublishOnly which will only run after you use `npm publish` So it does work, it just doesn't make sense
I googled https://www.google.com/search?q=eslint+function+declarations and found https://eslint.org/docs/rules/func-style Function expressions are sometimes preferable due to lack of hoisting, and due to ability to use `const`, making it clear that there's no possibility of reassignment.
I have to work on my google-foo ... Thanks!
Switch does not help here, there is no stream of streams. Example: ``` const a$ = someNumberStream(); const b$ = a$.map(a =&gt; a * 2) const c$ = combineLatest(a$, b$, (a, b) =&gt; a + b); ``` When A emits once, C will emit twice
fun game. i get best results when i attack my neighbor on turn 1 -- you either kill them and almost always win the whole board, or know that the game is over.
I had quite a bit of fun. Cool little game.
Just my initial impression, but: It's not clear where exactly the highlighted section will appear after scrolling. At the instant that it disappears and reappears at the newly calculated line/paragraph segment, it's very easy to lose track of where exactly the previous segment was, especially if one's scroll wheel scrolls many lines (as opposed to only 2 or 3, for example). If I had to make something like this, I think I might make a transparent rectangle of sorts around the current &lt;middle section of text&gt;. On scroll, the rectangle would stay where it is for a moment, the *new* calculated rectangle would appear around the *new* middle section, and the old rectangle would fade out over a second or two. Sorry, not trying to redesign/shit on your idea, just thinking out loud here.
What is this? A comment describing the link would be helpful. 
They are recruiting agencies, and also companies tend to like people with humility, so you might want to take that into consideration.
I have no idea how to play Risk, but I had a blast playing that for 30 minutes. Good stuff!
I'm glad of your attention, this is just the first experiment, i made it now in 5 minutes, I can make it better and more fast, I already make it fast now excluding checks on words out of the screen, it results more fast now, i continue, thank you again :)
Really enjoyed the game. A little simplistic and wish the computer was harder BUT literally can't complain since I can't fathom how to do this yet
People don't really choose; they're different solutions to different problems. async/await/promises allow you to wait for a single value (or collections of likely unrelated single values with things like Promise.all) while RxJS deals with streams and sequences of multiple values. It's like the difference between a number and an array of numbers. You work with a single number a certain way, but an array of numbers requires you to work with them a completely different way.
For those interview questions when they won't let you directly use "reverse()"
Same here. I started working on a tough( for a single man} proj since couple o f days, and i like this idea
Nice dude. 
What is it? 
I don't see any on-anything in the fiddle (which is good, always attach event handlers properly using addEventListener). What I noticed: Rather than nesting requests inside callbacks inside requests and so on, it's undoubtedly better to use Promises and Fetch - they make code much more readable and linear, and avoids unnecessary indentation. It would be better to Fetch natively than to rely on an external library to accomplish the same thing in a worse fashion. https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch I see `var name = document.getElementsByClassName('trackNAME')` *Consider always using semicolons when logical; sometimes using them and sometimes not using them is not a great style. (You might consider using a linter) *querySelectorAll is generally better to use than any of the HTMLCollection methods. querySelectorAll returns a **static** NodeList, which can be directly iterated over using forEach. The HTMLCollections are *live*, which means they can sometimes change while you're doing stuff with them (not fun or efficient to reason about), *and* HTMLCollections do not have a forEach method. *When iterating, code is clearest to read when the iteration is automatic, when the items being iterated over are automatically abstracted, and when the purpose of your iteration is clear at a glance. As ecmabot says: &gt;ECMAScript's Array contains a number of built-in methods for iteration (e.g., map, reduce, every, some, filter, and forEach). They relieve the need for manual iteration, provide better abstraction than a `for` loop, and make it clear what your iteration is doing. See https://gist.github.com/ljharb/58faf1cfcb4e6808f74aae4ef7944cff For example, instead of this: var name = document.getElementsByClassName('trackNAME') var val = document.getElementsByClassName('trackNAMEVALUE') for (let i = 0; i &lt; response.items.length; ++i) { name[i].addEventListener('click', function() { var value = trackPlaceholder.getElementsByClassName("trackNAME").getAttribute("value"); console.log(value); genericAjaxCall(value); } ); val[i].addEventListener('click', function() { var value = trackPlaceholder.getElementsByClassName("trackNAMEVALUE").getAttribute("value"); console.log(value); genericAjaxCall(value); } ); } you can achieve the same thing much faster like this: const valueElements = document.querySelectorAll('.trackNAMEVALUE'); const values = Array.from(valueElements, valueElement =&gt; valueElement.value) ); document.querySelector('.trackNAME').forEach((trackElement, i) =&gt; { trackElement.addEventListener('click', () =&gt; { genericAjaxCall(values[i]); }); }); valueElements .forEach((valueElement, i) =&gt; { valueElement.addEventListener('click', () =&gt; { genericAjaxCall(values[i]); }); }); Not entirely sure though - your fiddle's logic is confusing. Are the values you want really located in the .trackNAMEVALUE elements, and you want to call the function when the value element is clicked *and* when the main element is clicked? In your fiddle `var value = trackPlaceholder.getElementsByClassName("trackNAME").getAttribute("value");` doesn't work because getElementsByClassName returns an array-like HTMLCollection, not an individual element, so you can't .getAttribute from the whole array - you need to select an element first.
There goes 2 hours. It’s seriously addictive!
&gt;but I don't have a clue what I'm looking at. Can you elaborate a bit on what you mean by this? &gt;He's missed deadlines, deadlines i asked him to set for himself so he could work at his desired pace. That's not a great sign, although projects often take longer to finish than one initially expects. &gt;How do I know that I have everything he built for me while under our employment? I don't have experience in this sort of thing, but could you, for example, build the company's application(s) from the source files, and if any of the features don't work when you would otherwise expect them to, that could indicate that you don't actually have all the source files?
Happy to distract you 😜
both put in a word they think is popular on twitter, then the program goes through as many tweets as possible in a minute and counts the occurrences of the chosen words.
This is solid advice op. 
Well done! I played a ton of Strategery but always felt it could benefit from the cards system from Risk since once one player gets ahead they just steamroll. Any reason why you went with SVG? Did you test Canvas or WebGL?
I read a book by Gretchen Rubin she described a tendency called obliged which basically means they fail to meet their inner expectation so they need external accountability. So , see if you assigning him a deadline helps or not, and check in with him on a weekly basis to give him that accountability. 
Oh, one other thing: `for (let i = 0; i &lt; response.items.length; ++i) {` The `++i` is needlessly confusing - even if someone was to use a for loop, they should probably use `i++` as is used everywhere, for the sake of easy reading.
lolz. I’d like to see speed tests against Mithril.js 
&gt; He will show me it if I ask but I don't have a clue what I'm looking at. One option is an external code audits. I was asked to audit another developer because it was a similar situation as yours - a solo developer with managers that didn't understand what he was doing. It was pretty basic, a checklist of the basics (source control, test coverage, some sort of task tracking) and then a quick walk through the code. I was able to make a few suggestions to both the developer and management, as well as give the company a warm fuzzy feeling about their investment. 
Exactly this. Make an account first, then approach them and say that you've decided to start using an online git repository to store the code. If they are legit, they'll agree that this is a good idea and help you set it up. Give them max a week to comply, it's a very simple thing to do. If they are not legit, they will try to avoid this. There is no way a developer worth their salt will ever argue against source control management unless they are trying to hide something. They may of course suggest SVN or something else instead of git, that's a valid request if they are more comfortable with it.
Best answer you'll find here, try this before trying anything else
This all sounds great, but without a single line of code or practical example to back up anything the author says, it's very hard to tell whether its all waffle or not.
Hey thanks for the feedback. You can click the question mark icon to show the How to Play modal.
Cool stuff. I didn't realize I was blue, at first, though.
Good advice. Basically a 3 paragraph crash course in software project management. 
&gt; I started a company recently and hired my first employee. Congrats! &gt; I don't have a clue what I'm looking at. Then you're in the same situation as if you had hired someone to write a novel in a foreign language. Let's pick Arabic or Chinese to really make things difficult. There's really no way for you to understand if progress is being made or not. You can look at the strange language in front of you and see that the number of lines are growing. It could be brilliant. It might be total nonsense. Just like you might hand your foreign language novel to a few friends who know the language, your first step might be to hire a senior JavaScript programmer on an hourly basis. Or two. And pay them for a couple hours of their time to audit the code and tell you what they think. Then don't need to read every line. They just need to reassure you that things look fairly normal or that it's a disaster and you're being conned. Or something in between. Without even spending much you'll have way more information than you have now. &gt; He's missed deadlines, deadlines i asked him to set for himself so he could work at his desired pace. Programmers are horrible at estimating. Even the best of them. I won't go into why, because I could write almost a book on the subject. You should stop estimating and adopt an agile process as suggested in another comment. If you see progress made every week, then you at least know that you are getting closer to the end goal. Even if you miss deadlines badly, you always have a slightly improved version of the product each week. But what about technical debt? If you pressure the guy too much for certain kinds of progress within deadlines he is probably going to make bad decisions and do sloppy work which is going to add up and eventually your product will not be maintainable. &gt; I would like to know what to look out for How would I act as editor for an author writing a book in a language I don't know? You've probably already figured out where I'm leading: you are in over your head trying to manage a developer if you know nothing about it. Managing developers and managing projects is a skill all of its own, and people take years to get good at it. There are just so many beginner mistakes you can make that will hurt you. For example, an inexperienced manager is going to add developers to a late project. Which will make the project even later. This stuff is hard enough and sometime counter-intuitive that plenty of people get certified in how to manage tech projects and some companies (especially Europe) will not hire someone who isn't either certified or has loads of experience already. You might want to consider hiring a part time CTO or technical manager with a proven track record and a long list of references. Anyone who is good at this should be able to explain the best practices they will put in place and explain what those are in plain English. These folks are used to talking to non-tech management and upper management so if they can't explain things in plain English, they don't have the experience they claim. You're looking at things like: - Automated build and deployment processes. These must be repeatable and work on other computers. - Source code versioning. - Coding standards. - Code reviews (you cannot do this with only one person - but you can pay for someone else to do code reviews). - Issue management (bugs). - Processes and work flows. For every tool (like git) there are lots of choices to make about how to use that tool. Someone needs to make those choices, and document them. - Application architecture. - Documentation both within the code, and external docs. - Requirements management. - Automated testing (perhaps even test driven development or behavior driven development). - Package management - when a new version of a library you depend on is released does it break the automated build? - Security? - Operations and infrastructure - The real list is longer. You might need some of it, very little of it, or all of it depending on your product and your plans. Even a senior programmer is going to be weak or have some doubts in some areas. Which is ok. But knowing which risks you are taking on and why is far better than finding out a year later that you have to rewrite all your code when that's not what you wanted to do. For some companies and some products and budgets, throwing out code after three months and starting fresh is perfectly fine. Build a prototype, learn a load doing that, and then build the real thing. One last piece of advice I can give any startup that needs developers. Be ruthless in getting rid of requirements you think you need, or you think users will need. Even a small looking requirement can be hard for a developer to implement or create huge complexities when combined with other requirements. Everything will take way longer than you or the developer thinks. Everything. And it multiplies with every requirement. The work you don't give your developer will be far more important to your success than any other factor related to managing technology. Oh yeah, JavaScript! That actually doesn't matter much. You'll want a manager / CTO who has experience in that. But what I described above applies to almost every programming language if you are building a product. I hope that helps. 
Oh man this is cool, certainly something I'll think about trying to do way ... way way way down the road just for my own project.
SVN isn't valid any more. Mercurial could be, but even then you'll find way more people you might hire in future know git but don't know mercurial. Using SVN is just shooting yourself in the foot.
SVN is at least something. But I kind of agree, with the prominence of github/lab, it's probably best to start there. While OP might not know what to look for in code, with those tools, OP can at least see that updates are being made and when, etc.
~~Reddit Poll~~ Option 1: This is a joke Option 2: This is not a joke
It's not a joke, read through the comments. I thought it was too... https://imgur.com/a/4TBU7
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/VZuzmBJ.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dvd11xa) 
As an engineering lead and former contract developer, this comment couldn't hit the nail squarer on the head.
There is bitbucket as well that allows you to hold private repositories for free up to 5 ppl team size
Huh? Since when? I still see this when trying to make a private repository: &gt; Public Anyone can see this repository. You choose who can commit. &gt; Private You choose who can see and commit to this repository. &gt; Upgrade my account &gt; In order to make this repository private, you’ll need to upgrade your account. &gt; This will cost $7 / month and you'll get unlimited private repositories. You can cancel &gt; anytime. &gt; Choose your payment method: &gt; Credit card &gt; PayPal account
I've already starred, way ahead of you ;^)
lol its over
Another interesting and quite deep discussion around this. https://twitter.com/TheLarkInn/status/971497544067964930
Plenty of people prefer SVN, Perforce, CVS or any manner of system. I think they're masochists, but their choices aren't invalid.
Is he really an employee or a contractor? Contractors own the code unless it's explicitly assigned to you. Are you paying him? If your side isn't on the up and up too, then he might not owe you anything. Try learning some JS and looking deeper at the code. If he can't explain what it does then maybe he wasn't great to begin with. It's hard to hire good people if you don't know what to look for. Best of luck.
I use redux with react and I read your post, the HN article, and I’m still not sure what this does and how it’s better than just redux. Can you say in plain English why it’s better than redux? Your first sentence is Restate is a redux AND a state management library, but I can manage my state just fine using actions and reducers. Right now I don’t really see any benefits from using this library :/
&gt; unless they are trying to hide something. The OP definitely reads like the guy is trying to hide severe incompetence.
Give him short goals to accomplish and do some little bit of forcing him in order to make him work hard.
Another option is bitbucket. Git repository from Atlassian. Free unlimited private repos, but team is limited. 
I am a developer, and I definitely use source control, but because I do freelance I have a hard time sharing my code with the client, because I may get conned and don't get my money. Due to this I send them bundled code so they cannot carry out development without me. When the contract is completed I share the code
Yes, this is another good alternative. I will admit to not being a huge Atlassian ecosystem fan. For every good thing they do, they try 5 other ways to lock you into their ecosystem. Bitbucket isn't yet tainted. Same with Trello.
If you do get it into source control, I'd be happy to donate an hour or two to review and make sure he's not making stuff up.
If deadlines are being missed. You should break the project down into even smaller pieces, so these can be delivered on time. Don't rely on deliveries of large portions of functionality, until the smaller chunks can be delivered.
Beware of reversing strings that may contain Unicode: https://github.com/mathiasbynens/esrever
Are you his manager? Then start managing him. He is your employee and it is absolutely within reason for you to ask for all of the above. If he has any industry experience he shouldn’t complain. It sounds like the real problem is that you’re too worried about being this persons friend and not enough about his impact on your company
This one is better than redux for the ones who are looking for comparison with redux, cos this IS redux. You have your redux "backend" - the state, middlewares and reducers. You have you react "frontend" - a component connected to redux state. You have "connect" function, which selects something from a state for a current component, but it is better to say - "connect" is an adapter. It adapts the state for the component. Restate is adapter for adapter. And it works ONLY on "react" part of an application. You can have: * sagas and epics, able to access the whole store and dispatch any actions to modify that store * bunch of Focus components, to "lense" the parts of a huge store to for the isolated from each other applications (https://github.com/ioof-holdings/redux-subspace has a good theory about this) * You can stop bothering about how to deeply pass some props to the some deeply nested component, to let him select something from a store, but just create a nested store and let him select something from it with easy. So - you can build more easy testable components, using the more easy testable selectors, and them wrap them with easy testable restate sugar, and even get some performance gains, as long "focusing" and "scoping" will protect big trees from being updated (or affected) by each and every store update ( see https://www.reddit.com/r/javascript/comments/829ds0/redux_synapse_a_somewhat_old_but_observer_based/) But - not every application could benefit from this library. Only with the "deep nested structure". Or even it could possible be usefull in tests, as long it could fake the redux store's getState by the function you could provide.
Nice! Do you have any git repository for this that you'd like to share?
You can simply use the code which is provided by the Datatables. $(document).ready(function() { $('#example').DataTable( { "processing": true, "serverSide": true, "ajax": { "url": "scripts/jsonp.php", "dataType": "jsonp" } } ); } );
Except skip trello. Use github, and github projects. 
Yea, did a lot of that. It’s fine assuming the browser is fairly modern. 
I wonder why IE compatibility didn't affect many decisions but this does.
How did you organize your code? I always seem to be running into registering multiple click events for the same elements and expect only one to be triggered. Only later realising there were two events running and causing it to misbehave
Haha, I should have. Most items on that list could be question marks. I guess the reason I put it there is for reality. To do it right it's fairly expensive, the JavaScript guy isn't going to do it himself, and most startups are going to skip it in the beginning anyway and most of them get away with it. Then there are apps that just don't need it at all: - No user data - No sensitive data at all - If you get hacked you can just fire up another server in a few minutes - Marketing campaign that gets turned off after one month. Now take off the last item and you can still probably get by for quite a while until you start storing sensitive data. Why bother with more than a little basic server hardening? Am I missing something? 
One point to add to this fantastic list: Require that the project can be built from the code in the source control in one step, i.e. one command like 'npm build'. Often developers do certain steps manually, and finding out what they are can take a while. Also, this ensures that everything necessary for the build is in source control.
It is somewhat inaccurate to say "TC39 considers" without any action by the broader committee (such as discussing it at tc39). Even things which seem heavily trafficked on GitHub are not reviewed by the majority of TC39 members. A rename is somewhat likely, but smoosh is not at all in my opinion.
Yes and yes. When it's part of a real life big application with new features and changes from time to time it becomes chaos.
Any other framework or library you use along with jqurry, to make things easier and trackable?
&gt; **You should hold the keys and the admin account to your repository as well.** Repeating for emphasis! If you are paying for the code to be written, do not let anybody else control the code repository!
Use what works for you and your team. Don't let anybody tell you not to use something, but be open to hearing pros and cons. If a tool exists, somebody finds it to work for their needs.
Or "Rock Star" egotism. 
1) Use version control as others have suggested 2) Hire an independent developer to do a code review and see what you have.
It sounds like you hired a high school kid and not a developer, to be honest. Everything you’ve said is completely unprofessional and reeks of untrained freelancer.
Because old sites keep working in IE. For new sites it’s their own decision if they want to support IE. The problem here is that it would cause new browsers to break old sites. Not that I agree with their reasoning. It feels like a handful of poorly designed websites are holding the web at large hostage. This already caused us the includes/contains debacle, but now we get even more ridiculous alternatives. If this is a common theme, I’d say they better invest in an alternative compatibility mode or something for older sites.
I like this idea. Same 👋🏻
You shouldn't ask to see the code. You should ask to see the running app. There's already been so much great advice in this post. I'd just like to emphasize the 2 week sprints part. There should be a demo of working code at the end of each sprint. Set your developer up with small achievable targets and then audit what did and didn't get done at the end of a sprint. Then adjust (increase or decrease) the goals for the next sprint. You and the developer should both agree on what's achievable. 
ClientID is the correct one to use since it's a server control, but with a ID (#) or Name attribute selector in js 
Just look at the HTML there: the ID is not `hdneqptemp1`, it is `MainContent_hdneqptemp1".
Get ready to become more technical, the leaders of any tech organization should get comfortable with the jargon and methodologies. Create well defined tasks with detailed designs and then when he's done ask for a demo. You'll need to get to a point where you can drop in and run the application yourself at any time, just so you're not taking up his time while he runs a demo, but baby steps first. The more planning and detailed communication the better. Until you get to show a product to your users code quality isn't critical, but the better it is now the less you'll have to refactor later. This should not be your top priority right now. Keep in mind the goal: delivering a product to your users so you can drive sales and maybe get investment. Engineers want to engineer things, but you're running a business first, so don't let them over engineer in the beginning while resources are scarce and your business's survival is on the line.
Genius!
Well,you can definitely do it, however the code produced will most likely be very hard to maintain, especially if more people will work on it. You might want to spend some time learning React/Angular/Vue as it will eventually pay back in terms of productivity, code quality and reusability. It will also make you more valuable 
*yet Github is the industry standard, I'd go with that despite the fee for private repos. Remember: If you're not paying for the service, you're not the customer; you're the product.
Them: "Tell us one of your weakest points". Me: "I have extremely high expectations" (I let them turn that into a positive). Them: "If you could be any animal what would it be (Yes I got asked this once)" Me: "Giraffe" (I'm only 5 foot 9, maybe that's why it popped into my head, I don't know) Them: "Good, somebody answered snake once, that was just too weird and we wouldn't hire them"
what do you mean by bundled code?
In what ways would you say we're "the product" in Bitbucket's case?
Imo a solid understanding of the ES5 paradigm is very valuable. There are still many instances where I find myself writing ES5 because what I’m doing doesn’t warrant a full build environment... on the other hand, I know a couple of devs who basically just dived into ES6 React and as a result, aren’t very good at writing a basic UI component with plain old prototypes... in other words, all they have is a hammer and now everything looks like a nail to them. So that may be why you’re still seeing some old material circulating.
I use this pattern so frequently I think if I were in charge of a project I would make this the default and even try to add linting to require it. It makes things like adding home-rolled memoization a breeze instead of having to pull in lodash for that purpose, etc.
Literally everyone makes a Twitter API parser as a hackathon project. It's like "Smoke on the Water" for programming.
In general, SVN has its uses still, but maybe not with javascript. I know of a professional, who prefers SVN because it helps them store binary objects with more ease. From the top of my head, I won't be able to remember why is that, but the case is there. Also, mercurial is a solid choice. It may be not as widespread, but it is powerful. Unless you are limited to using git-flow, there is nothing wrong with mercurial. I would be cautious to hire a person, who cannot work out how to utilize mercurial tools.
I’m a new, self taught coder having used freecodecamp and now I am building applications for my own business and others. I’m originally a Business informatics and marketing guy. Here is what I learned why projects run late: - coding is as much developing the solution as it is exploring the actual problem as well. =&gt; Probably one of my biggest gotchas. Only during the coding of a challenge I often learned what I haven’t thought of when discussing and estimating a problem. For example how do I change and model data correctly and future proof, what effect has this on other components of the app etc etc. Error handling is a huge thing as well: what happens if someone takes “illegal” actions, what if the database doesn’t respond, validate user input and the list goes on - done coding isn’t done =&gt; the code might feel complete enough but then it needs to be q/a’ed, user tested ideally and deployed. This can be easily additional two weeks after devs claim: finished, where is the beer!? - coding is more about digging a tunnel than climbing a mountain =&gt; that plays a bit into the first because you really have a lot unknown in front of you. Especially if not a lot time was spent exploring the problem and people jumped straight into the code. There is also the problem that you can get stuck when an obstacle emerges. Sometimes it’s enough to hack around (more time than initially planned), bring bigger tools (more money) or and that’s hard: realise you need to dig somewhere else. Especially the latter is hard when one codes alone. Nowr one possible solution is already elaborated in the top comment but I wanted to give you insights why. Another suggestion is to put code reviews on with a mentor you guys choose together once or twice a week or on merge request of branches. It can give everyone more confidence and clarity. 
For a web project I use webpack. It concats multiple files into one, minify them and even optimizes some parts. 
To add to the whole repository business, I think it's also important to make your developer write descriptive commit messages. If there is a project management tool in use, make him link commits and branches to their corresponding tasks. It's especially valuable if we are talking about a manager looking through a developer's repository to track his progress.
First impression: Meh, silly joke. Second impression: OMG, please let it be a joke, please.
I know I suck at design and front-end so pls help https://github.com/Sprinting/simon-tg
If you want to hold code hostage, set up continuous integration but don't share access to build scripts.
This already happened with MooTools' `array..prototype.contains`. The reason we keep running into this is that with how MooTools is patching methods, whenever a native method is added to the array prototype, it will break. The _only_ reason we are having this (absurd) debate right now is because of the poor execution in MooTools. Personally, I'd like to keep flatten consistent: `flatten :: Functor f =&gt; f (f a) -&gt; f a` As opposed to some other name pulled out of a hat.
&gt; Require that code is stored in source control And enforce that this is kept up-to-date somehow. Perhaps have a "demo" branch that he merges changes from his development branches into so you can spinup a fresh demo instance from source. There is a business case for this beyond keeping track of work: you as the boos of a small company might want to be able to do that without bothering him. And when you expand the plumbing put in place to enable that will be helpful to a larger organisation for sales/qa/other. Setting up something like this will of course take a chunk of his time initially, and little bits of his time to maintain going forward, but means there most be a reliable up-to-date build in source control that you as a boss can see and other developers &amp; a QA team when you have them can also work with.
Atlassian is big into getting companies to use one of their products and then expand outwards into all the other areas. Bitbucket is obviously most peoples distantly second choice to Github, but when your employer buys Jira and it comes with Bitbucket, you get shitty account managers trying to save cash force you onto an inferior product.
This is probably the stupidest decision I have seen in a while on JS ecosystem. Because legacy website from 15 years ago haven't upgraded we shouldn't interfere with it ? In this case how about renaming the entire vanilla javascript ? Or maybe add a '$prototype' property to Array this way we are sure we don't interfere with anything right ? 
I think you're on shaky ground here playing detective to a one-sided story on reddit. This sounds, from what OP wrote, like a very small company, maybe only 2 people even. Who knows what sort of organizational problems they are having. Who knows how hard this one (first and only?) developer is having trying to get everything in place with a boss who has little to no technical ability. Please don't drop some poor guy in the shit so you can feel like *you the man*. 
I think the standard good "animal" answers are either 'elephant' or 'dolphin'
I fucking hate MooTools and really can't believe we have to cater to it. Fuck you MooTools team: - Fuck You Cristian Carlesso - Fuck You Aaron Newton - Fuck You Darren Waddell - Fuck You Jan Kassens - Fuck You Olmo Maldonado - Fuck You Valerio Proietti - Fuck You David Walsh - Fuck You Arian Stolwijk - Fuck You Tim Wienk - Fuck You Mark Joseph Obcena - Fuck You Djamil Legato - Fuck You Scott Kyle - Fuck You Fábio Miranda Costa - Fuck You Thomas Aylott - Fuck You Christoph Pojer - Fuck You Sebastian Markbåge
I do agree with the idea of hiring another, sometimes solo dev can be messy and tiring. Having someone to share the load is good, use git, it should be a routine already for a dev to use some version control.
Surely it's up to MooTools to rename their stupid prototype extension and provide a patch for old versions. Also - DON'T EXTEND NATIVE PROTOTYPE YOU IDIOTS!!
I chose SVG to keep things simple and to be able to style everything with CSS. I wanted to make sure I could iterate on the design quickly, so being able to edit HTML, SVG, and CSS live in the browser made things much easier for me.
 "foobar".split('').map((_, i, o)=&gt;o[o.length-i-1]).join('');
Having worked on projects using CVS, SVN, Bazaar, mercurial and git I see *no* reason why you would prefer SVN. 
Hi! You seem to have missed the first article. That was was more in depth that this last one, which was meant to be more of a wrap up of the context and the state of this tech. Here is the first article: https://www.imaginarycloud.com/blog/elm-javascript-reinvented-1-overview/
Haha and I thought my use of unshift was Perl-ish
It seems amazing to me that we're willing to worsen our language going forwards - that due to real backwards compatibility concerns we can't then change - for the sake of some developers that have abused the language long in the past. By that logic we can't add these methods at all, because it's genuinely possible that someone, somewhere has defined `Array.prototype.smooth`, `Array.prototype.smooshMap`, `Array.prototype.hodor`, and so on. Utter madness.
I know people are upset about this, but I think it's important to remember that at the time MooTools grew to popularity, the standard committee was extremely inactive for a decade and people weren't even sure ES5 would be a thing after ES4 got rejected. So I can kind of understand why the authors of libraries like MooTools made these kind of decisions. 
Good
Bitbucket is fine, GitLab is also great. GitHub is standard for Open Source projects and code sharing and NOT for private repos. Still, I agree. GitHub is definitely worth. Not only because every developer is kind of familiar with it, but also because it is very reliable and has a great GIT client (although it misses quite some features Source Tree has). At my company, we use Stash. I think Stash is fine, but I wouldn't recommend it. As others have already pointed out, it locks you into the Atlassian ecosystem, which you probably don't want to happen. Personally, I would recommend: * Bitbucket for private private repositories (yes, I mean _private_ *private*) * GitHub for Open Source * GitLab or GitHub for professional private repositories Honestly, though, it probably boils down to personal preference. For example, I heard that Amazon's Code Commit is supposed to be pretty solid, too.
If you think either of those looks like Perl you don't know Perl.
OK, that was perhaps understandable _then_ - but they should have since understood they did something wrong and changed their library accordingly.
This
FTI, the authors of MooTools are against this change. They don’t think the spec should cater to outdated libraries.
Yeah, fuck the people who contributed to the open source community, a community which has no doubt given _you_ something for nothing at some point in time. And nobody is ‘catering’ to mootools. They are catering to the millions of users who use websites which are no longer actively maintained and could break overnight. You should be ashamed of that comment. 
Wow, imagine that. They make a free source control system free to use for a small team in order for you to use until you grow into a mid-sized team or until you need the management systems that they can sell you if you want the integration. And I use both github and bitbucket, there's zero difference from a developer stand-point.
There's a bit of a difference from a developer stand-point when your business blocks github because 'we use bitbucket'.
&gt; fuck the people who contributed to the open source community More precisely - fuck the people who make amateurish decisions which affect the community, and in some cases just for the sake of becaming a star in the conference circuit &gt; a community which has no doubt given you something for nothing at some point in time ...and to which I have also given my share, thank you very much. &gt; They are catering to the millions of users who use websites which are no longer actively maintained and could break overnight Well then the problem is that the websites are no longer actively maintained, isn't it? Their problem. 
Trello has a lower learning curve and is thus easier to setup. It also provides everything that OP needs right now.
A) I didn't say mine *looked* like Perl, but in my 20 year career I've never seen unshift used outside of Perl B) If you don't think the one-liner looks like Perl, not only do you not know anything about Perl, you don't know anything about diddly squat
I prefer the term dumpster fire.
Or just keep a backup of it, git being a decentralized vcs, it doesn't really matter if the main repo gets blown away.
Seriously? I was making a joke. And further no just because the code is on one line doesn't mean it looks like Perl.
He shouldn't be working like this.
Basically if he is not using git already, he's a hack and not a developer. Get someone outside to perform periodic code reviews. Any good developer would welcome this and do it together. 
Haha just described Agile/Scrum/Kanban
u can use "off" before using "on". removing a listener before adding it is most of the time good practice
 Just a side note I know there are opinions on this but I really can't recommend VSTS enough especially for a small business. It literally has everything you need. Git, Build and Release, Work Management and a shit ton more. It's pretty cheap to. 
Or require the dev to write a "runbook" document explaining how to build the system from, say, a clean linux install. If you can get it down to one instruction, great! If not, it should still be something OP can follow and build for themselves.
This is the type of attitude that ruins a community. If this is how you act, then GTFO. We don’t need more poison here. 
I'm actually more excited about exploring ES2020.
I go back and forth on things like this and the answer for me often lies around ease of use. If I'm on a team, I separate concerns and keep things very modular as individual members are likely to be touching those individual components. If I'm working solo, maintaining separate codebases when I'm the only one touching them is a pain in the butt as I'll likely be touching multiples. If things are written well it's usually not a big deal to abstract components at a later date for reuse or if your team scales.
It was not uncommon at the time. Remember at the time JS was pretty much frozen. The only issue was that those libraries didn't play well together.
1) Yes. The problem is whenever a value that is reflected in the UI changes you need a line to update the UI. That is why databinding was invented. 2) Um, well.. That is not something I think of as inherent to jQuery, it is just life. I would recommend using native element event attributes to avoid the problem of loosing track of programmatically bound events (on click etc.). That, more specifically, *is* sort of a jQuery pitfall.
CVS is an invalid choice today. Even Subversion is an invalid choice if you have a team. Each will cause you extra work for no benefit.
Have you tried lerna or similar monorepo approach where folders include different npm packages?
You can also have a free private git with https://www.visualstudio.com/team-services/
I have as much of a right to my opinion as you, so piss off
You can have an opinion without being an asshole about it. 
I don't use lerna, but with my current project I am using a monorepo with packages in different directories at the top level. I haven't bothered with a single build script as it doesn't really for my needs.
Zero difference, eh?
&gt; Equity only at this point Lol. Good luck with that. 
Not a fan of having production environment variables in a file which will end up living in my GitHub repo for all the developers to see. People should stop using this technique.
Just to add to previous advice given by others... Regarding deadlines and estimation, you could check out evidence based scheduling. https://www.joelonsoftware.com/2007/10/26/evidence-based-scheduling/ While far from perfect, it's been the best option I've tried so far. Also, hiring some consultant (nothing fancy, someone experienced to read and review the code and overall project architecture) to give you both some pointers could help. If you don't mind looking at code, a general rule should be that it resembles plain English. Otherwise you're pretty much doomed. No expert coder will be able to make any sense of it even with a perfect knowledge of the language and the business domain. Simple subtle changes seemingly trivial to developers do make a big difference in the long run. One simple example expressed both ways: ``` formButton.on('click', handleClick) ``` VS ``` acceptButton.on('click', updateUserProfile) ``` I've seen the first one quite often, and to me it conveys little meaning. In short, one trait of good code vs bad it that it focuses on what the code does instead of how it does it. Hope it helps
IDK, `map` version seems much clearer. As a rule of thumb, `reduce` should be used to produce a single value from array, say like this `'string'.split('').reduce( (o, n) =&gt; n + o)`
&gt; and due to ability to use const, making it clear that there's no possibility of reassignment. If you redeclare a function, linters and TS' compiler etc will complain anyways. It changes nothing in practice.
True, but when the OP fully admits they don't know software development and is working in the web development space I feel it's disingenuous to recommend something that isn't almost an industry standard at this point. If I saw a startup was using SVN rather than git or mercurial I'd definitely consider it a red flag against working with them. A far higher percentage of potential future hires will know git as opposed to anything else and as you already mentioned, git has tooling around it that is far superior to anything available to SVN. That said, it's a long time since I used SVN, so if there's an advantage to SVN that you think makes it better than git in some situations I'd be interested to find out what that is.
&gt; Make an account first, then approach them and say that you've decided to start using an online git repository to store the code. Or explain to your expert staff member what you're trying to achieve (all code to be held in a proper source repository, so your business has ownership and visibility of its asset) and discuss with them the best way to achieve that. Dictating matters like this by presenting a *fait accompli*, when the person you're talking to is likely to be an expert and is also the person whose work will be most affected by the decision, is almost invariably bad management. If you can't trust them to be honest and collaborative on something as basic as this, you shouldn't have hired them in the first place. Assuming you can, why not take advantage of their knowledge and experience to guide your technical decisions?
Freelance is very different to employment, though. As a freelancer, retaining control of the assets you produce until full payment is received may be your only meaningful protection against not getting paid by a bad client. Moreover, legally speaking, any IP rights in those assets are probably yours until that payment is received. As an employee, your employment contract serves as your protection, and typically the IP rights immediately belong to the employer for anything you make in the course of your employment. There is no reasonable argument for withholding anything in this situation.
I worked at a start-up that had a non-technical CEO who was in charge of our SaaS application. We had a great product, it was growing well, but he simply had no idea how to set realistic timeframes or how to pick the right people for the job. He ended up making a lot of poor decisions that cost the project years of development time, which allowed competitors to obliterate us, while also blowing our budget, running out of money making it impossible to grow further. Even though we had a great product, because the wrong person was in charge, the parameters simply couldn't work in the end. You are going to have a very difficult time making a technical company succeed without appointing a technical director who can take charge of everything to do with the technology side of the business. As someone without development experience, you need to hire someone who can verify quality and reasonable timelines on the development side. That job cannot fall to you.
Lol. Good luck with that.
Maybe, but in this case it's still a good idea to ask them for a demonstration and watch them walk through that process starting from scratch to make sure any instructions are complete and accurate. It's still more future-proof to run scripts that in turn use simple, widely used tools to do anything important, though. At least that way the intent is clear, and when some build tool or JS library you rely on is totally broken in six months and your developer has moved on, whoever else comes in to replace them has a fighting chance of figuring out what needs to be updated to get things working again.
&gt; It may be not as widespread, but it is powerful. If anything too powerful. It has a crazy number of ways to use it, and it's far from clear to me that it actually enables anything you can't do with git. 
Yes 
&gt; SVN has advantages and disadvantages. As compared with more modern tools? I only see disadvantages as compared with git. 
we still want those sites to work, and the original developers of the sites may not even be alive anymore
Perforce locks: yes and no. Yes: their GUI and command-line do this by default. No: their core engine doesn't require it; you can spend a couple months (!) creating your own front end which operates more like SVN. I had to do this once, when our team outgrew SVN, but git was still a baby.
bitbucket offers free private repos to teams under 5 people (this is to hook you into the Atlassian ecosystem, which isn't bad per se). 
Centralization. Even in the SVN world I was mostly using SVK to work decentralized. This was back before I saw the light and moved exclusively to git. 
&gt; A contract for work product typically explicitly spells out terms like this, but even if it doesn't, some jurisdictions will still assign ownership of the work product to the company. Really? Which jurisdictions transfer copyright from a contractor to a client without an explicit contractual term doing so?
&gt; who prefers SVN because it helps them store binary objects with more ease. maybe Fixed now that Git-lfs is a thing. 
Correct! Thanks for filling in
Sure, I’ll post a link later - It’s not pretty though, as it was a 5 hour sprint kind of thing
Haha. We were restricted to using data streams from a company named ‘Satori’ - I live in the UK, and most of streams were American, Australian or Canadian - which we did not feel like would be super interesting to do. Twitter was the most global stream that was not about crypto, which frankly, I am super tired of.
&gt; Javascript is devolving into such complexity that nobody can reason about the code anymore. I think many people would argue that javascript has become more expressive and easier to reason about over the past few years.
Software architect and technical lead here - that is excellent advice.
Not sure how you can say this given you know nothing about the app being developed and that there is only one person working on it.
No problem man. I very new to node. Just looking to learn :)
This may be true, but he gets access to the code by contract, verbal or not, as the agreement is that he hired to guy to develop code for him. If the guy refused to provide the service he was contracted for he can be sued. He may accept being sued if the thing he made is so innovative that he thinks its worth it but he cant take money and not give code, if that was the agreement, regardless of copyright.
[Promises, or await/async](https://medium.com/codebuddies/getting-to-know-asynchronous-javascript-callbacks-promises-and-async-await-17e0673281ee)
you should take a look into this article http://ianbishop.github.io/blog/2013/01/13/escape-from-callback-hell/
If you can just return everything at once, that is ideal. Aside from that semi-magic answer, you can do them in parallel, and have one callback with a counter that knows when everything is done. Or, if you must do them in series, at least make them separate functions, so you can chain them without nesting.
The worst thing is that "smoosh" isn't even English, it's American English. As a native speaker of English, I've never heard this word.
BitBucket has free private repositories too :)
I would like to propose that MooTools never be considered again when implementing new language features. Honestly, the mistakes MooTools made should not hold the rest of the web back.
The problem wasn't even that they extended the native prototype. The problem is that they _conditionally_ extended the native prototype; such that a native implementation would override MooTools' implementation. [They fixed that problem](https://github.com/mootools/mootools-core/commit/2688f7bfe2a6725cd841169fbaee34b834fb9700) over 10 years ago. The problem isn't that a patch doesn't exist, the problem is that some sites still use the old version without the patch, and that as a result those sites no longer function properly in browsers that implement the new native flatten function.
It's worth the small monthly fee for offsite backup alone.
Great approach, good luck to you.
Yes. Everything you said is true. But even in a 3 week sprint, it should be possible to complete a feature that can be demonstrated to the client/boss/user. But the understaffed part is definitely a real problem. @op you should be asking your developer if they feel understaffed/overwhelmed. You say he is a JS programmer. So what is he building the backend with? There should be some kind of API he must communicate with? How is that being built? Can he do both? I'd wager thatight be tooich to ask, but again,we don't know much about your app. If you want, pm me today. I'd like to help with more immediate advice, if you like. 
&gt; why is your business logic in your UI code anyway Lets just call it logic. I like UI logic, so I will defend it. Consider a loop that makes a list from an array. You put the loop in the UI because that is where it matters. The UI elements are what iterates. The controller just needs to think of the data as an array it can put things in. The UI interprets that as a list in the view. If you have something like crude Angular directives, then your UI looks like &lt;div for="array"&gt; &lt;div bind="array[index].value"&gt;&lt;/div&gt; &lt;/div&gt; Which to me is the most conceptually straight forward way to go. 
I think i would pick other aproach, I would probably just groupy by and reduce for each campaign. I love functional, but I think you are going a little bit overboard with the aliasing and the point free style and in consequence readibility suffers. Just my two cents YMMV
JavaScript's `flatten` takes a `depth` argument that defaults to `1`. MooTool's flatten effectively has a hard-coded depth of `Infinity` (it recursively flattens all arrays inside the top-level array). So any code using MooTools' `flatten` method on a &gt;9-year-old version MooTools to flatten more than one level of array at once would be broken by the addition of JS's native `flatten` method. I wonder if that's a significant enough number of sites to bother worrying about.
SUN has the advantage of slowing down development so you can't code faster than people can make decisions.
I have an internal project where I use jQ a lot. On a recent threat a kind redditor pointed that I could do the same with plain JS which I agree wholeheartedly, but the reason I use JQ is for development speed, because it is easy to read, and because it simplifies things. One of the things I use the most is the .post function which makes calling an endpoint on my server extremely easy. That’s a wrapper for an ajax calls but takes care of a lot of the boilerplate that I would have to write. I’m kind of a lazy programmer so the more I can do with the less code, the better. Also, less code usually means less chances of errors. But overall jQ is nice to work with, it is mature, solid, works as expected, and the learning curve is quite short. The day I move away from jQ I guess I’ll just jump into vanilla js and most likely Vue.
Thanks, this wasn't obvious to me when reading the docs. What I think on the matter, though, is that old websites break every day with the browsers updating. MooTools shouldn't be treated differently. Either a site is actively maintained and will be updated, or it's not and so it's nobody's business that it breaks.
I'm personally terrible at that - my side projects all need at least one other party so I have someone to feel accountable to. Where possible, I try to do mini "standups" or other reports on them, so that I have to justify going and starting a new feature, rather than polishing/finishing/shipping the old boring ones.
Sure, sure. I think step one is the developer communicating his plan with real concrete tasks to the owner. Then you can assign relative complexity and start putting time spans to things, even if they are just relative or naive.
Agreed, communication is important here -- and i think is this guys ultimate issue. He seems to not be able to talk to his developer. Sprints arent going to fix that.
Googling “api football scores” brings up pages of options, did you try googling this? There’s even a team treehouse post on the best places to find free sports apis. If this is American football, try ESPN. La Liga for Spanish football, football-api.com has Premier League, really depends on what you want
It seems like you’re talking about Github as a git client versus Github as a repository. It’s true that as a git client it has no notable differences. As a repository, Github, GitLab, and Bitbucket all have numerous differences. For one, a “Pull Request”, as we are all familiar with it now, isn’t native to git and was introduced and popularized by Github. It’s now in all the major repositories, but that’s an extra thing that set Github apart. Each of the major systems have their own spin and features overlaying git. They are not identical. 
Create my_lib/helpers/index.js, and in that file import everything from my_lib/src/helpers/index.js and export it again.
I can show something meaningful in a few hours, and some guy who got hired couldn't show something meaningful in few weeks? Not sure if just a skid or trolling.
The guy doesn't know anything about code, and everyone is telling him to get a running demo in 2 weeks with no context. That is the troll. We should be teaching him to talk to the guy, not how to make artbitraty demands with no knowledge.
Of course that would work but that's a pretty ugly practice to have nonsense directories and files sitting around. The entire point of being able to import/export is organization. I'm back to the original thing I'm trying to avoid: root-level source
The iife is not immediately invoked. 
https://medium.com/@OmisNomis/recursion-263745d98999
Who is "we"? My guess is 99.9% of the Internet users dont give af about breaking the 10 websites still using a 8-years old version of Mootools.
I think the point is not about things like `const {foo, bar} = baz`, it's about the standardization efforts that will make stuff like this part of the language: class { #foo = 1 [bar]() {} // if you think this is ugly, say hello to the ASI rules } 
What a nightmarishly colossal tutorial. This is why create-react-app exists. Very soon, this pull request will give us webpack 4 speeds with create-react-app and no configurations: https://github.com/facebook/create-react-app/pull/4077 The SSR process is very much simplified by this library: https://www.npmjs.com/package/cra-universal Or if you're really feeling kinky, you can try a [parcel solution](https://github.com/reactivestack/parcel-react-ssr/pull/7)
See also: https://www.reddit.com/r/javascript/comments/82x8kf/an_introduction_to_recursion/
Are ***a*** nice, read fuck me
Cant argue with a word of this, this way of working will scale as you grow too.
I loved Flow for 2 years and more, used it on every personal project, got it adopted on every project at my job, but the amount of bugs and the almost non-existing support make me seriously thinking to move to TypeScript. 2-years old issues about object destructuring, object spread, exact types, enums... making Flow and Redux a hell for instance, haven't get any update for months or years. Only solution is to add comments to ignore the errors or to change all your code to workaround Flow's bugs. Just waiting Babel 7 to use TS as static type-checker instead of a compiler. 
I'm really not. I explicitly said the flow is the same; speaking about the developers role in working with GitHub and Bitbucket. They both have pull requests. Just because GitHub layered a button over a 'git request-pull' command first doesn't set them apart. As they both have this functionality today, which is all that matters. 
Yeah I'm moving a project from Flow to TS because it's sooo much nicer to use with VSCode. What's this about Babel 7??
it's just that kind of day
you can always use `.takeWhile` on the observables and set the callback to turn the takeWhile return into a falsy. ... it's still easier to just `.once` on the EventEmitter tho. _and sexier, if you ask me_
This is what I was thinking. If we let one library dictate how the language evolves, why not more? What libraries are popular enough to count? Who decides?
[babel-preset-typescript](https://github.com/babel/babel/tree/master/packages/babel-preset-typescript) coming to Babel 7. It will work like babel-preset-flow. So you will be able to use TS as static type-checker (eg. see the type errors in your editor) and Babel will the remove the type annotations during the build.
‘Use stricter’
I didn't even know I needed this *yippeeeeee*
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [babel/babel/.../**babel-preset-typescript** (master → f97d431)](https://github.com/babel/babel/tree/f97d4313c97341b1be6801dbd481dae23127b5a4/packages/babel-preset-typescript) ---- 
I think with yarn or npm you can create alias' in your package.json which you can name and then import in a neater fashion. I've seen it done and you just point the alias at the folder etc which allows for a cleaner import 
Does that mean ESLint will work? Because I hate TSLint
What's the advantage of this over using the Typescript compiler directly?
"Smoosh" isn't even a word, is it?
There is a difference between backward compatibility with old versions of JavaScript and backward compatibility with a random 8-years old library. It's not the web browsers job to ensure backward compatibility with every single library used on the web.
Flow has been great for me! Haven’t ran into anything specific yet. Typescript is a hard sell, I like to use es6 at the end of the day.. I know TS has most es6 features, but still
Readability &gt; Clever
It may seem like it, but I would strongly argue that in this case there is not a difference. It's not a random 8-years-old library. It was a _major library_ that many websites used. Here we have the choice of _knowingly breaking_ websites in the name of a feature. Not just one or two, but thousands. The hill to die here on is not "you shouldn't have done that with the language". The reality is that it was done and it exists. This should not be ignored because of "I told you so's". And that feature isn't something like adding Symbol or Map, it's a simple prototype helper method. If push came to shove, could we live without it? Yes -- anything that can be polyfilled is already implementable. We, as a community, simply don't want to repeat the work so we ask it be part of the language itself. It is more important that advancement of the language is careful, particular, and deliberate because the nature of the web is that these issues _will continue to arise_. This process has already happened with the implementation of other prototype methods, and will continue to happen in the future. It's getting press now because 1) the tongue-in-cheek suggestion to rename it to smoosh, and 2) the itching desire of modern javascript that what we have is not good enough. 
I did something quite similar to this. You use it to instantiate contexts where you need some kind of *mini-global* state am I right ?
Blogspam.
if you're starting a new project with svn, you're probably not doing yourself any favors.
Thank you for this. Flow it stays. 
Git's data model is significantly more complicated. There is a reason [this](https://xkcd.com/1597/) is funny. But also, sometimes having a central repository with a clear, linear history is just nicer to work with. Setting up Git hosting is more complicated. If you're doing it locally, it requires significant technical understanding. If you're using a remote service, there are security and reliability implications, as with any external dependency. Git is powerful, but also powerful enough to be abused. See history rewriting, branches as moving tags, etc. A lot of the ways people use Git in practice, from relying on centralised hosting like GitHub to preferring rebasing a feature branch over merging it in, are trending back towards the simpler model we used to have. If you think Git is inherently superior in every way, you might ask why that is.
Less dependencies are better for my goals.
Grab a chunk of his javascript code, post it here, and we will review it. Note : All reviews are negative. Its how negative that matters.
&gt; That said, it's a long time since I used SVN, so if there's an advantage to SVN that you think makes it better than git in some situations I'd be interested to find out what that is. Please see my other comment [here](https://www.reddit.com/r/javascript/comments/82tt0v/help_im_at_the_complete_mercy_of_my_developer/dvdwc62/).
&gt; Who decides? The idiots at EcmaScript apparently.
&gt; and the original developers of the sites may not even be alive anymore That's a MooTools overdose will get ya.
Personally I'd be a developer who can prototype and later, actually refine something instead of only talking about it until the last day and not delivering anything at all. Have a nice day.
i think you make valid points, but i don't think they are relevant to discussing git vs svn.
I didn't fucking say it "looked like Perl" at least until your response whereby you gave no indication it was a joke. I said it was "Perl-ish", there's a difference.
Exactly, I always try to optimize my code for reading, so that it's easy to understand. Lately, I started to learn about FP and introducing some of its practices and principles in my code, which actually improved it. In some occasions, I ended up with a more declarative style, which improved readability, but I was only able to achieve that when solving fairly trivial tasks. By reading FP "gurus", I got the idea that a program benefits from FP when you fully commit to its approach (I think I got this one from Eric Elliot, but cannot find the reference). Also, I've just finished Kyle Simpson's book "Functional-Light JavaScript", and in some parts of the book he mentions that if the functional style doesn't feel familiar it's because familiarity bias, being comfortable with it is just a matter of getting used to the FP style (you can see it at the end of [this section](https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch11.md/#stock-events)). So, I'm just in the path of discovering if FP is for me, or only some of its principles actually make my code better.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [getify/Functional-Light-JS/.../**#stock-events** (master → 13a3bda)](https://github.com/getify/Functional-Light-JS/blob/13a3bdafb4edb83207db76212312472aab20d06a/manuscript/ch11.md/#stock-events) ---- 
&gt;What a nightmarishly colossal tutorial. No kidding, and it's not because the tutorial is bad, it's just really difficult thing to set up and maintain SSR. I started using next.js for all of my projects which pretty much gives SSR for free. After doing a few projects with it, it's highly recommended. I basically weighed vendor lock-in (which I experienced before with Meteor) with dealing with SSR, and was an easy call to make. I highly recommend it if you need SSR.
Fair enough but what constitutes a "single value"? So maybe from one array to another of the same length is better suited to map, but what if you are somehow transforming the array to an array of a different length, or to an object? I do this quite frequently with reduce.
&gt; But that's a straw man because I'm hard-pressed to imagine a viable business that needs to hire a full time JS dev not having any sensitive data That's easy and not a straw man. An informational site but one that needs lots of user interaction. I can imagine hundreds off the top of my head. How about a site that teaches you to tie knots and you have to drag the rope around with the mouse? Sponsored by "Yoyo Camping Supplies" which is plastered all over the site. Brand awareness through free education that will help campers. I just now visited the Michelin site to search for Michelin star restaurants. Pretty interactive site and most of the functionality works without logging in. The site would work just fine without users. And that's what I would have recommended to them for MVP and launch. Forget about users until you've proven people have an actual use for your idea. Unless you're building a social network. I already mentioned short-lived marketing projects in my previous comment. They just want you to crank out something cool that the drugged-out creatives came up with and the deadline is already super short so you'll be working long nights finishing the insecure version and after a month the site goes away. Backup plan when insist on security? "Shut down the site. We've got TV, outdoor, print, and radio too. It's not the end of the world." Some clients just don't care for some projects. The cost benefit ratio doesn't pay off. &gt; I would never call someone a senior who isn't demonstrably competent in the security issues facing the stuff they own. I'm not going to say how many decades I've been programming, but I don't consider myself competent in security. I know some basic no-nos, but if any client told me to make an app secure I would just say "not my yob, go pay an expert to tell us what we got wrong." In every big company I've worked at the programmers did their best, but a separate security department was responsible for finding all the holes. If a hacker found a hole, the dev team was not at fault. That's the job of the security team. At the small companies I've worked for they've simply waited until they were big enough. And that's a good thing. Because a lot of them just never launched. Idea wasn't good enough or the market wasn't ready for it. If we had been spending money on security we would have run out of funding quicker and that would introduce a lot more doubt. Would have a little extra marketing budget attracted enough traffic to get the next round of funding? &gt; how will you even know if you are hacked in the first place This really goes back to what you are trying to protect. At some point if your app grows big enough, then I agree with you that your reputation becomes worth protecting. A lot of this stuff with startups is just about timing. &gt; I'm hard pressed to imagine an engineer who isn't thinking about security is still thinking about adding even minimal one-liner intrusion detection on their server I stay as far away from devops and security as I can. I like coding. Everything else is an interruption. And I'm ok with that. If your app is popular enough to need protecting, you should be able to find enough funding to pay for a part-time security service. &gt; It's a complex subject Well yeah, that's why I outsource it. I agree with the rest of your post. Security is definitely important. But I do think you have to do a risk analysis and cost benefit analysis. If the only thing you're protecting against is your server getting hacked, I would say you are going to save a lot of money by waiting until you have enough traffic to warrant protecting your reputation against getting hacked. And if you are storing sensitive data, then I agree, get the money from day one for security or don't do it. Anything else is irresponsible. And if you're already a viable business, you should have a security team that is part of the dev process for all projects. Thanks for your reply - it was helpful. We're mostly in agreement and I don't see any big holes in the way I approach security *for startups*. I'm fully aware there is *some* risk at the beginning with my approach and I do weigh that against the other factors. Every client and project is a unique case. 
So I modified the test (actually had to create a new/different one, jsperf is buggy like that) and amazingly on each of the first two times I executed the test, returning a function from an IIFE executed a fraction of a percent *faster* -- how could that be, some engine/compilation voodoo? https://jsperf.com/bare-function-vs-iife-wrapped2/1
I really like Flow but TS works better with VSCode for me. They’re both great options!
Serious question. Do you work as a developer?
FWIW, `tsc` does the trick, no need to wait for Babel, right? Is there something specific Babel is doing for you?
Doesn't TS have *all* ES6 features? Or are you referring to proposals that aren't in the ES2018 spec yet?
I can understand the motivatin, specially since you are transitioning but I would be wary of following FP gurus in EE settings. If you are working alone and will always have control over this codebase thats fine, point free style is great because it can guarantee purity in your functions. Having said this, if one of my coworkers wrote this I would question his choices. For example: - arrow function &gt;&gt;&gt;&gt; currying and partial application in javascript (readability). Use memoization on the function if you are worried about performance. - dot operator &gt; R.prop - reduce with imperative statements &gt; pipe 
If you are really on board the prog func train I would start looking into elm, elixir, clojure, haskell. This are languages with all these techniques builtin and thus their usage there is ubiquitous.
Hi /u/whingeypomme, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/Gilstroem, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
Yeah that reminds me of how everyone loved JS years ago but now they're jumping ship because no one can read it anymore. Stupid Google/Mozilla/Facebook/everyone who contributes to the state of Javascript!!! 
No, I don't.
You're missing the fundamental reality of backwards compatibility. The MooTools devs could (and for all I know, have) change their library, but that's not what matters. What matters is that there are thousands of websites out there still using the old versions for which there are problems, and there is straight up nothing we can do about that.
While I agree, you are not entirely correct: https://github.com/nolanlawson/optimize-js/blob/master/README.md
Not an App Script user, but all the examples I can find relating to it don't work directly on the parameter ("e" in this case) but on a subobject within it - e.parameter appears to be an object of some kind with the actual data passed. https://mashe.hawksey.info/2014/07/google-sheets-as-a-database-insert-with-apps-script-using-postget-methods-with-ajax-example/
I have come across this exact code a few times (its been referenced a few times), and have tried all of the parameters found in the [documentation here](https://developers.google.com/apps-script/guides/web). The data still comes through the same. I did find that adding parameters to the url (such as ?username=jsmith&amp;age=21 gets it to show up in the data, but I still haven't been able to parse it. I also am trying to pass a JSON object to it and not have the parameters in the URL.
Check out https://github.com/jaredpalmer/razzle
This is even simpler, thanks!
You didn’t just voice an opinion, you called out the devs by name in before you edited your comment. That my friend, is being an asshole. 
I think jquery has a method "once", where the event is trigger only once. Is a good method if u keep doing "off" and "on". 
Any idea how? I just set up Babel 7 to compile my .ts files. My editor won't typecheck .js files that are TypeScript, but ESLint won't work with .ts files 🤔
While that's true, if you're using Typescript, most of the time you want to stick to how TypeScript is written and not add extra features to that. Do you have any example where this might be the case?
Sorry I’ll reword my “yes.” It should unblock support but there might be issues still in the way. A quick googling turns up https://github.com/babel/babel-eslint/issues/505. But eventually it will work!
&gt; DON'T EXTEND NATIVE PROTOTYPE YOU IDIOTS!! This is the only proper response.
Yeah I get the feeling that this discussion is getting really hung up on motivations, as if the motivation for making a good decision is more important than making the good decision. I think it's a valid point when you are looking at the problems caused by a lack of critical thinking, but I also think it can be destructive, especially when you are talking to someone who is relatively new. Sometimes it's better to just recommend "best practices" than to say OP should look at all of the version control options and try to learn how to think critically about them.
VUE VUE VUE 
The linked tweet was tweeted by [@andrestaltz](https://twitter.com/andrestaltz) on 2018-03-07 21:39:44 UTC ------------------------------------------------- Here we go! I just published `prevent-smoosh` 📦 A package that you can use to have a voice among TC39 gods. [https://github.com/staltz/prevent-smoosh](https://github.com/staltz/prevent-smoosh) ------------------------------------------------- ^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •
Couldn't you do this: const c$ = combineLatest(a$.switchMap(val =&gt; val), b$.switchMap(val =&gt; val), (a, b) =&gt; a + b); It's kind of verbose, but I'm sure it could be finessed. 
Lol, why do you use front end framework if you want to render on the server ? No SEO mmkay? The whole fun is to push rendering to client and server serves the DATA. That's what's that all about.
A week? Make him do it that day. It takes like 5 minutes tops.
OP, u/certainperformance has linked MDN. MDN is a phenomenal resource for tutorials, examples and up to date documentation or browser compatibility with JS in the wild. Make a bookmark of MDN JavaScript and use it until you have trained your google foo to the point that the first searched link is MDN anyway. Also stay away from w3schools. &lt;= second that. 
https://www.npmjs.com/package/eslint-plugin-typescript But I'd really like to hear about what could be improved in TSLint!
I don't use SSR, but I keep wondering a few things about it. Why not just have the index page be the app in a sort of meaningless blank route, and show a server-side generated landing page generated by generic stuff, like PHP, instead of trying to run the SPA on the server? I can think of a few ways you could do that fairly easily. Wouldn't search engines get wise to SPA apps trying to get a higher speed ranking by supercharging the index page? What about a half-measure of simply populating the model with initial state? 
I'm sorry I don't understand your points. Yes my tests both call empty functions, but those functions are identical, so I figured that was sufficient for testing performance based on whether a function was returned from an IIFE or not. Am I wrong? Should I try testing with identical yet non-empty functions? Which comes around to your second point, the creation of the function. Aren't I creating them both in the same exact way? And only once? Not being snarky, just seeking clarification if you'd like to provide some, thanks
You're not wrong, Walter, you're just an asshole.
&gt; Whether that function was originally defined in another function (IIFE) or not is irrelevant when it comes to executing the function. I replied but deleted it when I re-read this. The above is the *entire point* of my test and is therefore *not* irrelevant in the context of the test.
My opinion is that they are idiots. And you a sanctimonious twat.
&gt; The MooTools devs could (and for all I know, have) I don't know if they have done that in later version - although they haven't released a patch for the offending version(s), apparently. But the point is... &gt; there is straight up nothing anyone can do about that except the thousands of respective website owners ...that that's the problem of those site owners. Why should we have to cater to them?
Yeah, that's a question I'm personally unprepared to answer. What I will say is that it would be *really* annoying to *me* if 10 years down the line a client called me up and said "Hey the site you made me in 2018 stopped working and I've lost all my revenue!" because JavaScript decided that React was now a reserved word or something. Maybe in 10 years we will look back at React and say, "God, what were we thinking?!" (I doubt it), but right now it's best practices, and at the time MooTools was best practices as well. That said, yeah, maybe it's not worth it. I'm personally not prepared to tackle that question. I do think the committee has *some* duty to not break old websites. I'm young, though, so I tend to think that duty is overstated.
It's not the library dictating how the language evolves, it's the language as it is currently used in real sites dictating how it evolves. The fact that it's a specific library is irrelevant.
Afraid it's 8 years late.
sure. I think telling someone that they should research the pros and cons of svn and git before making a decision is bad since we all already know that git is objectively better.
Well, a lot of websites I built in 2008 wouldn't work today - they were built with Flash... :-) Seriously that's why you put in your contract that you are not liable for malfunctions in future browser versions but are available to adapt the site, for a fee of course
I guess I've never had much problem with git, though that's most likely because I've been developing with it for the last ten years. Some of the commands could be improved, and I hear mercurial does a good job of that, but I still maintain that the biggest bonus git has is that, despite it being hard to understand, it's still the one the largest number of developers use, and thus easier to hire for. From what I remember with SVN, it doesn't even have comparable branching to git, and is much more heavyweight and not suitable for the same usecases.
Made one as well the minute context was merged: https://github.com/drcmda/react-contextual They're all eerily similar, but then again, it's probably the most natural pattern that would emerge out of this. 
&gt;But if the properties are of the same type won't the offset be the same? The offsets refer to the order in which the properties were added to the object. If an empty object gets property `a` added to it, and then gets property `b` added to it, then offset 0 refers to `a` and offset 1 refers to `b`. If you add the `b` first instead, then offset 0 refers to `b`.
Almost every backend api i've ever worked with has in some form worked with query string parameters like this. Many open source frameworks also take query string like this (loopback, json api, any get param working with arrays). My statement still stands and all the backend typically does is convert it to an object or an array. For instance, his query string "filters[product_filter_series][0]=product_line_a&amp;filters[product_filter_series][1]=product_line_b&amp;filters[primary_applications][0]=application_a" in PHP would simply become: $filters = array( "product_filter_series" =&gt; array( 0 =&gt; "product_line_a", 1 =&gt; "product_line_b", ), "primary_applications": array( 0 =&gt; "application_a", ) ); Though the representation of this sometimes also looks like: filters[product_filter_series][]=product_line_a&amp;filters[product_filter_series][]=product_line_b&amp;filters[primary_applications][]=application_a
I was only commenting in regards to "This looks like a strange querystring." Nothing to do with contrib packages of any kind.
Regarding the private syntax, agreed, it's horrid, but the computed property makes sense IMO.
I now know how to be a boss
Pfff as if browser vendors are unwilling to implement something that breaks compatibility. In Chrome 60 they changed http headers to lowercase knowing that it will break some sites but they went ahead anyway since it only affected a small number of sites. https://github.com/whatwg/xhr/issues/146 So TC39 concerns are totally unwarranted.
&gt; There's a middle ground in which a single developer can build an application that does handle sensitive information Sure that's fair. Stuff like redirecting HTTP to HTTPS is something a senior web dev is probably going to know how to do during the startup stage. &gt; go full on and outsource a consulting firm I've hired these firms part time and it sure does keep the devs happy if they are only responsible for the security parts that involve code. Another factor is that I really don't want a dev who is somewhat *security aware* be the one responsible for security. I'd much rather have someone who does it as a full time job and is an expert. You can hire someone like that for a few hours a month so it doesn't have to cost a fortune. I also have to factor in that I've seen senior devs who know better do things like check secrets into github. Forgot to put it in the `.gitingore` file. People make mistakes. Which is another reason to outsource on an hourly basis. Just to have another set of eyes. 
This is a very well written piece. Not sure why others are complaining. This is what it takes to make SSR work right now. Yes you can use Next.js or some other boilerplate but if you want to understand what is going on behind your boilerplate, then learn the black magic at least.
What’s the refund policy for the subscription? Doubt it’s worth the money
My point is that even they have different hidden classes assigned to it, the offset for both the classes should hold the same value since the properties are of the same type. Now I can see why assigning different classes would fail the inline caching but I don't understand why it would assign different offsets values even if they are assigned different hidden classes.
Okay, that makes sense. Thanks!
It looks to me like the mime type some kind of attachment. The PostData is a FileUpload object which you need to convert to a blob. The data length is about 11K so something arrived. I'm only on my phone so can't post more helpful links, but look into the FileUpload class and I think you'll make headway. 
I've been instinctively doing this for a while (with functions with larger numbers of arguments) but never knew there was a name for the pattern. Good to know
Yeah, just skip all that boring reading. Because who cares how it's wired up as long as it works…until it stops working and you don't know shit about the whys. Boss: "Our Website is broken, what do we do about it?" You: "Wait for the real devs to push a fix" The tutorial isn't even that fucking long…
 shape.addEventListener('mouseover', showGameOverScreen()) ?
I think you're on to something with thinking that Observables and Promises are similar, but I think the key insight you're missing (that other comments didn't quite explicitly say) is that Promises are just a specific type of Observable that emit one value and then close. Other Observables may emit many values, and may never close until the program halts, but an Observable already encompasses all the functionality and semantics of a Promise (as well as, of course, an Observable itself), so it seems unnecessary to create another abstraction to resemble both.
Yeah i know that, but wasn’t this the idea of fe in the first place ?
I spend a lot of time digging thru npm modules. I see a lot of "entry point files". 
&gt; your developer should be able to show you a working version of what he's building. Can't be overstated enough. If he disappears for days on end and tells you "I can't show you anything because none of it works yet", that's a red flag.
&gt; You shouldn't ask to see the code. You should ask to see the running app. **^^^ This 100%!** You need to be providing regular feedback in order for the project to succeed. Don't let him hide it away for months or years, the chance that it will actually do what you want it to do at that point is almost 0.
&gt; I like to use es6 at the end of the day.. I know TS has most es6 features, but still Which ES6 features do you need that TS doesn't have?
&gt; If you think Git is inherently superior in every way, you might ask why that is. Because I've used both? SVN was a huge leap forward from CVS, but it's vastly inferior, because it basically is based around a linear history which makes collaborative development much more difficult. 
Also, I don't find that cartoon funny. Git's model isn't hard to understand at all.
agreed
razzle comes to rescue
how do I put this in? https://www.khanacademy.org/computer-programming/maze/6063342979055616 
This seems to be a bit spiteful. I understand that flatten/ flatMap are much better names and what one might be used to seeing already in libraries such as Lodash. TC39 have their hands kind of tied here. The browser vendors will not ship a feature if breaks enough sites. This is one of those features. If you want the feature, you're going to have to either live with a name change, or come up with a plan to solve issues like this. Trying to prevent `smoosh`, and `smooshMap` just means they will be looking for yet another name, which you might object to and end up in a deadlock with the TC39 committee. 
Right... and the majority of my post was dedicated to using contrib modules, and not reimplementing things that have already been written. It is weird though, and the only reason I mentioned it was because two modules typically used for qs parsing and stringifying in the nodejs world wouldn't deal with it very well.
{"pay":{"peanuts":"monkeys"}}
I read the GitHub thread for the suggestion. It feels like a mix of subtle trolling, satire and people who stumbled upon the thread and contributed in seriousness. Though I'm afraid that they are all being serious :/ Several people mentioned that doing what the publisher of the package is doing would be considered a "dick move" so thanks for taking the hit for us, some guy I don't know 
&gt; both providers and consumers re-render their sub trees on changes, This is expected isn't? I'm not getting your point actually. 
I have not used it yet, as this feature is supported in alpha version of React. Waiting for the final release. But yes, planning to use for forms, localization etc. 
Twitter is probably a better place than instagram for this.
Bonus – let callers omit the parameter object completely: ({day = 0, month = 0, year = 2018} = {}) =&gt; ...
This won't answer your question, but it's important. There are two ways to make a game when you are self-taught: 1. Learn things while you build a game. 2. Learn things first, then build a game. People have made games both ways, only you know what you can do. For me, I tried #1 for a long time and never finished anything I was proud of. Learning things as I needed to use them was preventing me from really adding them to my toolbelt. The problem with learning first, *then* doing, is that it can be more boring. I would start making one file for each thing you want to learn, and as you complete each one you will feel good, and have a whole record of everything you've done. Then, when you make a game, you know 90% of what you need to know. For example, break it down into different goals: - Learning how to use eventListeners such as "mouseover" to make things happen - Learning how to change "screens", from a menu, to a game, to a game-over Each one isn't impressive on its own, but do enough small things and you will make a wicked finished game!
/r/lolangular 
But don't use `day = 0`. Assuming `day`, `month`, and `year` map to `setDate(day)`, `setMonth(month)` and `setFullYear(year)`, then passing in no parameters will land you on December 31, 2017, which is confusing.
The problem is that the people who push for smoosh only invoke the “don’t break the web” when they see fit, which means it’s dishonest. They also completely avoid the issue of namespaces polluting the prototype chain and instead push for stupid names for ideas they don’t like, while not complaining about breaking the web when it’s something they do like. Should also denote this is all Google.
Am I the only one who thinks this is just counter productive? You're naming your parameters already in your method definition, any good programmer would know to look up what each method is expecting. I don't get his examples at all ``` const formatDate = (day, month, year) =&gt; { return `${day}/${month}/${year}`; }; ``` Passing an object is just plain stupid, that makes it less readable.
Haven't tried that out but how is it supposed to help? The problem is fundamental to combine latest 
I'd personally love if I could just use ESLint plugins effortlessly! I know that's a tall order, but that's really my only grievance with TSLint
I can agree it would improve readability, but all modern IDEs have code hinting, so as soon as you type `foo(` it will show that it's expecting `day, month, year`. With passing an object, you're also making it harder for changes. Let's say someone decides to change the definition of `foo`, but you're still passing `{showLoading: true, wait: 2000}`. This will cause massive confusion, as you can just pass whatever keys you want, you can do `{ whatever: 2000, lol: 23432, showLoading: true`}. Is this now more readable? By specifying the exact amount of parameters, you know exactly what this method is expecting.
My IDE autocompletes objects as well fwiw. Actually when adding more parameters the object is more maintainable as well. Long parameter lists become harder and harder to consume. For example say there are 6 options that have all have sane defaults. What would you rather call? `foo({delay:2000})` or foo(undefined, undefined, undefined, undefined, undefined, 2000)` I really don't see the argument about passing in "bad" config options. It's bad practice in general and I don't see how is it any different from calling method that takes in 2 parameters with 3.
I'm curious what you mean by "full control"? You can do stuff with webpack in next.config.js. I'm not sure if you can change the version of it, but I've never run into any limitations beyond that as far as using loaders and plugins (granted, it does most of the optimizing I need out of the box so I haven't gone too deep there)
The right answer to that question is to roll it back to the previous build, even if you know everything about why it's broken.
Having done a ton of react tutorials and actually purchasing Tyler’s license for his courses, his are the best around. What I like about his courses is that he’ll teach with the most popular patterns/plugins/etc when a lot of course will stay vanilla
Sub 1-second content is really important now, and it's reaaally hard to get that without SSR on a complex app. Other than that... the second page, or the third page. Or any interaction on the page still uses javascript. There's a lot of reasons that every major website and business does SSR... but if you just do hobby stuff or are just learning, it's pretty safe to ignore.
Object literals initialized by a route identifier of some type is the way to go. 
* /r/learnjavascript * Don't post screenshots, post actual code. * It's not clear what you're actually trying to do or what the structure of what you're working with is. Do you want `&lt;object&gt;.items.forEach(item =&gt; ...`?
I can’t believe I clicked that
Nice and solid advice except he won't agree to share his source control with you until payment (and he is upwork contractor I guess, with one-off paycheck?). JS issue is any code that went public is went public, and is easy to reuse even if it is minimized/obfuscated so he doesn't feel safe until you actually pay him 
GitHub: https://github.com/samchon/econ Extension of TypeScript-STL Containers dispatching Events. TSTL is an open-source project providing features of STL, migrated from C++ to TypeScript. You can enjoy the STL's own specific containers, algorithms and functors in the JavaScript. If TypeScript, you also can take advantage of type restrictions and generic programming with the TypeScript. ECON is an extension module of such TSTL, providing special containers dispatching events. The special containers are almost similar with the original STL Containers, but you also can observe elements' I/O events with the special containers. Types of the event dispatched by the special containers are "insert", "erase" and "refresh".
How it WAS used, you mean. The problem isn’t even in the latest version of the library.
you can use your own webpack config with next. I recently converted a decent size react app to next and found it to be very intuitive and performant. There is even a nice https://github.com/segmentio/create-next-app kit. 
Why don't you just use actual named parameters? function formatDate (day = 0, month = 0, year = 2018) { return `${day}/${month}/${year}`; }; Works fine... 
For anyone interested, [here](https://medium.freecodecamp.org/elegant-patterns-in-modern-javascript-roro-be01e7669cbd) there's a similar article about a JS pattern called RORO (Receive Object Return Object) that's about using object as a function parameter instead of a sequence of non-named parameters. Probably a repost, already saw it on reddit somewhere. 
Do you have an example in mind of a past JS feature that did "break the web"?
Going to get more downvotes for this, but I really want to discuss. The problem with this approach is that when you change your method definition, you now not only have to change the values, but you also have to change all your keys twice. This is asking for wrong inputs. If you're ever need to pass `foo(undefined, undefined, ...)`, then you're doing something wrong, you should never need to do this in the first place. Passing bad config options is bad practice yes, and you shouldn't need to do this, but passing an object for the sake of readability isn't really a good practice anyway. These parameters are part of your method definition, this is what the method requires in order to execute correctly, obviously in many languages these would be strictly typed as well, therefore you wouldn't be able to pass invalid parameters.
Not really. What if the reason it broke is due to something outside of your control and you still have to come up with a fix? Rolling back to the previous version isn't going to help you.
Out of curiosity why do you say it's "all google"? 
I understand this, but so far I've only ever used Babel to transpile ES6+ code or jsx down to ES5 code. Since tsc does this for you, whats the added advantage of adding another tool like Babel to the toolchain assuming you're starting from scratch?
It is actually a great tutorial, even if somewhat long. React SSR is basically Express + React Hydrate. 
I believe that people who are pushing for smoosh would prefer flatten. They're just proposing one potential workaround to the web compatibility issue. &gt; They also completely avoid the issue of namespaces polluting the prototype chain. Well I guess they could do something akin to Object.freeze(Array.prototype); Object.freeze(Object.prototype); // etc... But, I'm sure that will break millions of sites, and cause issues for millions - billions of web users. I'm sure if there is a compelling solution to this problem, the committee would be open to hearing it. I've thought about importing flatten/flatMap, but it doesn't really work. Not all browsers have import, hard to feature detect, need to ensure that you don't conflict with existing npm package namespaces. The other issue I have with importing the feature somehow is that it would not really be worth the effort... import { flatten } from 'something-here' flatten([1, [2, 3, 4]]); vs [1, [2, 3, 4]].reduce((p, c) =&gt; p.concat(c), []); I've also seen suggestions of 'use es2018'; to opt into the changes. However this doesn't really solve the issue, as you could have scripts on the page that are both opt-in and not, and they share the same global Array variable. It starts to feel like the simplest answers are: * Break the web because we should care more about developers feelings than users whom use the sites that will break. * Rename the methods to avoid the collision * Change the default depth to be Infinity (although, I'm not entirely sure this helps, as looking at the bug diagnosis at https://webcompat.com/issues/15121 and then that of Array.prototype.includes https://bugzilla.mozilla.org/show_bug.cgi?id=1075059#c0 indicates to me that the issue with MooTools is that it expects that an addition to the prototype will be enumerable, but when override a property on the prototype it does not change the enumerability of the property. The fact that the depth is infinite in MooTools and 1 in the spec is just simply the icing on the cake.
Old versions of the library are also currently in use.
https://en.wikipedia.org/wiki/Not_invented_here
I don’t understand your issue with something like “use es2018”. We only need to make sure we don’t break the legacy sites, who won’t opt-in anyway. Make sure once you opt-in that all the scripts on your page actually work well with it is peanuts compared to that.
Check out coding train on YouTube. He does a lot in processing.js and probably covers your exact question at some point. Tldr: you're gonna have to do some math
Well unless they're using third party libraries like social integration, and other scripts that might be representing the latest version of something. For example: js.src = "//connect.facebook.net/en_US/sdk.js"; Does not contain a version, and is automatically updated. It could get quite tricky when it's not just about going to caniuse and determining if things are going to work, but also ensuring that people have opted into newer features. It creates other issues, that might not be obvious right away. 
It’s called using Maybe’s or Eithers ;)
Unit and/or integration testing being applied both to the quick solution and my project. Reinventing the wheel creates more technical and maintenance debt over time and a larger codebase. Versioning is simple, you just roll back and lock version if a problem does get through. Your example of a broken website is flawed because in your case, you are the "real dev" so it's the same difference. Most importantly, you ship on time. If, as a rule, you have a simple solution on a silver platter and don't take it, you most likely wouldn't make it past the job interview. The tutorial is fucking huge considering, as the comments on this post have made clear, there are many simpler solutions out there.
JS feature specifically? Not off the top of my head. That isn’t the issue though, to scope it to JS and act like the thousands of changes happening every day in browser engines aren’t breaking and fixing different parts of the web is the issue. It never becomes a concern until someone doesn’t like an idea. The truth is keeping back compat is unrealistic and standards should focus on the actual problem (pollution of the prototype chain) instead. That’s the dishonesty in it that’s annoys me.
The issue I have with it is the lie browser vendors tell themselves. Every code fix going into the browser has the possibility of breaking/fixing different portions of the web, yet I don’t see this concern halting browser development. It only comes up when someone dislikes an idea and they’re being intellectually dishonest or lying to themselves about it. Either we freeze the web and keep back compat or we agree that isn’t an actual reality and be okay with things breaking over time. There can be an entire browser business on just preserving different ages of the web for people who really need it but you can’t say “this change breaks things” while simultaneously shipping breaking changes left and right. How is this not okay but killing flash fine and dandy? The truth is it’s political.
My understanding is the person pushing smoosh is a Google rep who no ones questions because of seniority.
&gt; Is there another type of composition, where the functions inside of compose are optional? Make one? let i = 0; function compose(param, fn0, fn1) { if (fn0.shouldRun) { fn0.run(); } if (fn1.shouldRun) { fn1.run(); } } // --------------------------------------------------------------- compose( 1, { shouldRun: true, run() { i++ } }, { shouldRun: false, run() { i++ } } ); console.log(i); //1
It *is* a dick move, but this is an untenable policy, and I'd rather see that addressed now than when we already have smoosh. 
Function.prototype.bind had a similar effect on MooTools sites that flatten/flatMap would have.
How frequently do you read code vs write code. Imagine you had a weird date bug in your app, and you came across this code: FormatDate(2018, month, day) Vs FormatDate({ year: day, month, day: year }) Which one has the bug? Yeah this is a bit contrived, but this kind of thing happens ALL the time. Developers are fallible and mistakes, no matter how obvious, get made. Make obvious mistakes obvious.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [drcmda/react-contextual/.../**PITFALLS.md** (master → 9909b93)](https://github.com/drcmda/react-contextual/blob/9909b930b6becea99fe724847ce450e3e9d4885b/PITFALLS.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dvf7pve.)
Well, i'm in the business for around 17 years. What i do here is i laugh at the whole concept of react and other stuff when at the end you need to work out the stuff "normal way" ...
Because Flash is a security nightmare…
You're right. It absolutely doesn't make sense for dates. But the same technique is useful in other cases, particularly where the method can take a larger number of options. As a general guideline, if the number of parameters exceeds 3 or 4, and some or all are optional or there's no intuitive ordering for them, then use an options object.
The main problem is that, _in the way that you've written it_, that is not good. I mean, _as you've written it_ the execution of those functions seems to depend on some unnamed external conditions (if some bool is set??). That is a pretty bad idea, as it would mean that you're using impure functions and building on them to create more complex impure functions. That doesn't mean that there aren't any patterns for conditional composition. It's just that you have to specify better what the conditions are. There _is_ a pattern in which the condition is "simply" based on the return value of the previous function. That is, there's a composition which is meant to work like this: "if the current function returns something actionable, then call the next function; if not then stop (or call something different)". This is, basically what /u/Peter_Storm referred to: Using Maybe/Either/Promises as the return types. Say all your composed functions return a Maybe and receive a Maybe. Then conditional execution is straightforward, because each function is prepared to "not execute" when the received Maybe doesn't contain a value. With Either it's similar. Doing this, no special `compose` is **needed** (though you _might_ build a specifically purposed one, if you wanted: see as an example [this discussion](https://github.com/ramda/ramda/issues/512) about the merits of having `compose` be aware of Promises) There are other options, though. Say you wanted different actions on different results. Something where `compose( f, g, h )` can execute either `g` **or** `h` depending on the result of calling `f`. The problem here is how do you define the condition/check to be applied, but a general approach would be to compose `g` and `h` first into a `do-g-or-h` function, which is where you encapsulate the dispatching, and then you are back in the general/previous case.
It's not even modern MooTools, it's an 8 year old version of it. It bodes really poorly if an outdated library with extremely bad practices somehow is justification to rename functions that have standardized names in every other language to childish joke words.
hmm.. runtime type checking in 2018
It's been a pretty comical ride to get us here. cheers to 17 years
This pattern has been around for around 20 years though obviously not in an ES6 or higher context (so without the "bonus" default values). I learned about it in one of the earliest editions of David Flanagan's "Javascript: The Definitive Guide", and recall using it myself in 2001 or 2002.
It's a pretty ugly practise for your imports to not match your file structure.
When /u/mgoerlich is referring to "the real devs", they're referring to the maintainers of create-react-app and whatnot. If something happens over there that breaks your app, and you don't understand what's going on there, you'll be waiting for the maintainers to fix your bug report. Of course, this is a trade-off you have to make with every third-party package you're using. It's completely reasonable not to study the source code of every library you're using. That said, being dismissive over "colossal tutorials" that actually try to help you understand what's going on if you _do_ need it can rub me the wrong way as well.
It's not just about search engines... they're not the only type of scrapers out there. Some will be better than others. But serving HTML is always going to be more reliable on everything.
Yes Chrome changed the addEventListener API recently and it broke a few sites: http://tonsky.me/blog/chrome-intervention/
Have you experienced a problem with NaN in a real project? 
Honestly not, but I know that sometimes this kind of errors show up. Besides "real project" is a big word for me, I'm just a engineering student actually :) 
Yes. They have completely different purposes. I don't think they'll clash.
Yes. Using `cond` for pattern matching, `when` for `if(true)` and `unless` for `if(false)`, we can create functions that modify the behavior of functions passed to them. `cond` is the building block for behavioral function composition in JS. Here is an implementation of `cond`: const cond = conditions =&gt; value =&gt; { for (const [condition, action] of conditions) { if (condition(value)) return action(value); } return value; }; Here is how it is used: // checks if value is number or string and reports it, else reports unsupported type const fn = cond([ [x =&gt; typeof x === 'number', x =&gt; `${x} is a number`], [x =&gt; typeof x === 'string', x =&gt; `${x} is a string`], [x =&gt; true, `${x.constructor} is an unsupported type`] ]); fn(5); // "5 is a number" fn('foo'); // "foo is a string" fn([]); // "Array is an unsupported type" We can make it cleaner by defining a few helper functions: const always = x =&gt; () =&gt; x; const is = ctor =&gt; value =&gt; (value &amp;&amp; value.constructor === ctor) || value instanceof ctor; const T = always(true); // ...later const fn = cond([ [is(Number), x =&gt; `${x} is a number`], [is(String), x =&gt; `${x} is a string`], [T, x =&gt; `${x.constructor} is an unsupported type`] ]); Most of the time, our use case is a simple once-off check, and we don't want to be using `cond` directly. Instead, we want to abstract a single double-branch `if () {} else {}` flow. Simple enough: const ifElse = (ifTrue, then, otherwise) =&gt; cond([ [ifTrue, then], [T, otherwise] ]); Usage: const fn = ifElse( is(String), x =&gt; `${x} is a string`, x =&gt; `${x.constructor} is an unsupported type` ); We can abstract this further for cases where we just want the value to remain untouched in the `else` branch. We can do this with `when`. But we need an `identity` function: const identity = x =&gt; x; const when = (condition, action) =&gt; ifElse(condition, action, identity); Now, we can do stuff like this: const fn = when(is(String), x =&gt; `${x} is a string`); Of course, we need the inverse as well, so we implement `unless`: const complement = fn =&gt; value =&gt; !fn(value); const unless = (condition, action) =&gt; ifElse(complement(condition), action, identity); Now, we can do the inverse of `when`: const fn = unless(is(String), x =&gt; `${x} is not a string`); Using these building blocks, your example becomes: compose(when(condition, doThis), unless(otherCondition, doThat), when(boolIsSet, doOther))
You have a client-side bundle anyway it’s no effort to install webpack-dev-server for quicker development
&gt; Manually editing package.json should be forbidden what
If the parameters were set in stone and the program never change you may have a point. But software is a living and evolving thing, you start with three parameters then you add the locale as a fourth, then a fifth, then you often need to call the function with just the year so you are constantly doing formatDate(null, null, 1934, ) ... it gets ugly quick. Plus as others have said, you need to remember the order all the time. If you had ever programmed PHP, where the order of arguments is chaotic, you'd know exactly what a pain that can be. formatDate({ day: 25, month: 11, year: 0 }); The above makes it extremely clear what is what, without you having to double check you got the order right. Remember, higher level languages were created for making software readable to programmers, not machines (machine code is good enough for them) IMHO every programmer should read the book Clean Code &gt; Downvoted for trying to contribute to the discussion? Just because it's a different idea... Sometime people disagree but have no time / inclination to discuss. Also it helps in moving the "better" comments to the top. 
If you’re writing functions that take more than 4 parameters, you probably need to re-evaluate your code.
`addEventListener()` isn't a JS feature. That is from a different group of people than the TC39 people. 
Flow really hates destructuring errors in catch blocks for some reason
You could probably do something very clever with Folktales Validation library. They have a good example in their documentation for it, I think.
what about the situation when you're copying a bunch of packages from another package.json because you know you'll need it somewhere else, too? Had to to that on my recent project in work. Can't say that doing npm i for every package is very comfortable. 
reddit hug of death? :P
I used similar things here and there all the time since 2000's. Nobody ever understands that these type of utility functions should not be implemented anymore in the core language features. I sat now wrote this under 3 mins: Array.prototype.flatten = (function(){ function flattenArr(arr){ arr = arr || this; while(arr.some(function(d,i){return d instanceof Array})) { arr = flattenArr.flatten(arr); } return arr; }; function flatten(arr){ return Array.prototype.concat.apply([],arr); }; flattenArr.flatten = flatten; return flattenArr; }()); - Is it perfect? no! - does it work?yes! - is it efficient? no! - does do all the error checks?no! - what happens when my needs change, I have a huge array or something breaks? I go modify and rewrite it. This is trivial. This is not rocket science. Please stop adding these naming conventions/utilities into the language. It is already saturated. We have 3 microtask queues, we have async functions, weak maps, this, that... IT IS OK. I does not have to do everything out of the box to make everybody feel like home. Your fingers won't break if you sit once in a while and write some ultil function. What the TC39 will never try to reconcile and rest of the people want to see is that at some level (we are PAST that level), vertical and horizontal expansion should happen at the level of 'library', not anymore at level of fundamental features. When you want to expand a language, a spoken language like english, do you add new words or do you add a new letter? Alphabet should be updated time to time yes, but as the language grows, the word growth rate should dwarf the change count in the alphabet. This is the natural pattern. If it goes like this, at some point, it will be inevitable that backwards compatibility will take a lot hits, to a point that it will not need the slightest justification anymore to bring new things break all else or even put forward a new language proposition. And I am sure a lot of big companies are investing their plans on this assumption. 
&gt;TC39 have their hands kind of tied here. The browser vendors will not ship a feature if it breaks enough sites. If you want the feature, we're going to have to either live with a name change, or come up with a plan to solve issues like this. Well sure. But how many sites is "enough"? And will browser vendors ship `flatten` or not? This is just question begging. The feature is not being shipped due to a policy which can only be justified by assuming the feature cannot be shipped. If Mozilla says they won't ship it 'cause mootools, we have a reason not to adopt it. Until then it's all hypothetical. 
I guess I'm still a noob. What does this mean to vote with your code? What?
Good point. I’ll submit an issue to Typescript and Flow to let them know. 
NaN being a number is a correct implementation of floating point standards. There's a lot wrong with javascript, but this isn't
This has been adopted as a good pattern in Ruby. Would be great if the JS community would use it as well, given how quickly libraries are being updated.
I said vertical and horizontal expansion should happen at the library level not at the core language specs. And it is simple: - Look at the heading of this post. Look at all the headache it can cause to so many other people given the little convenience it offers. - I am not saying all of these from my high horse around a round table, I am saying this as an earthly ordinary developer who has things to loose and might break. I simply have "Skin in the Game". 
&gt; I said vertical and horizontal expansion should happen at the library level not at the core language specs. Yeah, you said that without even explaining what you mean with that. &gt; Look at the heading of this post. Look at all the headache it can cause to so many other people given the little convenience it offers. And because of this we shouldn't add any more features to the standard libraries? Just because the devs of some library were dense enough to modify prototypes? And it is not little convenience. &gt; I am not saying all of these from my high horse around a round table with a big companies name stamped on my buttcheeks, I am saying this as an earthly ordinary developer who has things to loose and might break. I simply have "Skin in the Game". And I am also an ordinary developer and I like the idea of having this added to the standard library. Now what?
Yeah you're right, but in bigger projects with multiple modules and components, the client-side bundle starts to grow and it build to be slow. That re-build in every code change is a burden and slow down the development. This [article](https://medium.com/@justinjung04/react-server-side-rendering-and-hot-reloading-ffb87ca81a89) point the problem more specific, but it's a little old, so maybe I need to change my mindset and test other frameworks to have a decent SSR with react, redux and not so different dev/prod environments. 
&gt; Am I the only one who thinks this is just counter productive? You're naming your parameters already in your method definition, any good programmer would know to look up what each method is expecting. Unless.... the function takes zillions (like 10 or more) of parameters. Need to add one, you have to shift them up in *every* call to the function everywhere, which is a maintenance nightmare. With named parameters, you can add only one *where you need it. 
What is this, FORTH? People have the freedom to use as many parameters you like. Stop complaining about this if they do. 
- Horizontal and vertical expansion means do whatever you like with the libraries using the core specs at the time. If you want make a new library (horizontal), or add a new feature to an existing library (vertical) - #1 A core language is spec is not a library. It is the building block. It needs to be as simple and bland as possible so that user implemented features on top have more space to make mistakes. #2 On the contrary these things should be implemented with different flavors within 3rd party libraries. Maybe I want to implement a 'depth' parameter, maybe I want is as a object method but not built into prototype. Maybe a third person does not want type checking. It is much better to implement all of these in 3rd party libraries without incurring the risk of breaking many websites. - You seem to forget a 2000 year old habbit that kept us humans alive on this planet: &gt; "primum non nocere" "First do no harm" 
Thank you. And like I said, it's not even THAT long. I've heard about people out there reading entire books about their toolchain…
First of all, there's a proposal to add `flatten` and `flatMap` to JavaScript; but some people argue that those feature will break the web, since the 5+ years MooTools already implement it. So, people who don't mind about the name, propose `smoosh` and `smooshMap`, so this feature could be pushed without breaking old website. Some other people argue that using different name would means JS isn't punishing bad behavior, like what MooTools do. So, they create a library that use the `smoosh` and `smooshMap` name, in hope if TC couldn't break old website, they shouldn't break new website who depend on this name too. Actively, using TC argument against themselves. _Yeah, JS is pretty weird._
Interesting... why not both, though? People want to add their own custom smoosh, let them, but flatten does seem like a more standard name.
NPM's job should be making sure everything is consistent, and not catering to every little usecase that might be uncomfortable once in a while. If you need to install multiple packages, you paste it into your text editor, reformat it so that they are separated by a space, and then use `npm install package1 package2 ...`.
Looks like the correct URL is this: https://thewebplatformpodcast.com/156-react-16-fiber-and-beyond
Especially in your day month year example, the argument order only makes sense in certain locales. Much more common is year month day, and even then i'd waste lots of time re-checking the function definition. 
Hardly. I'm just obscuring that everything is in a src folder. It shouldn't matter to my own user: me.
&gt; So, bro, have fun with your Typescript, it definitely feels a lot more like Java than ES6 but I’m going to stay close to the action on this one. Aren't Flow and Typescript basically identical, syntax-wise? And why are you calling everyone 'bro'
Hi /u/wizcaps, please refrain from personal attacks. Thanks.
Hi /u/our_best_friend, last warning on the personal attacks.
It's too much work considering that i never had any problem with typing or copying packages myself into package.json :P
how big is a house?
What about `swoosh`? :D https://www.youtube.com/watch?v=1C3obiS9c0w It's just fukin ridiculous situation. That mantra "don't break the web" is good, but to some extent. You can't support shit things from the times of 90s and don't move forward because some nerd use IE5.5 and/or some shit developer decided to use already libraries that do bad practices and goes against the javascript language. Codebases are to refactor from time to time, no matter what. Breaking and not so breakin' changes happens all the time. Even more, we are talking only for some versions of MooTools, and only for those that uses this versions AND uses flatten. So the number even won't be 7000, nor 5000, i'm sure.
Yeah but it's definetely not intuitive to say "Not a number" is of type Number. At least for me. 
I was generally speaking about pure javascript, not typescript or flow since I don't know them. I didn't know I was on stackoverflow.
It isn't but that's not javascripts fault
Video linked by /u/tunnckoCore: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Coone x Hard Driver x E-Life - Swoosh Fever (Official HQ Preview)](https://youtube.com/watch?v=1C3obiS9c0w)|Dirty Workz|2014-12-10|0:03:48|1,693+ (93%)|134,639 $quote The official video clip for: Coone x Hard Driver x E-Life... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/tunnckoCore ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=$comment_id\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
This was definitely worth all of our time and requires our full attention.
You can always enable hot reloading for your client dev server. Also a good way to get around large bundles in big applications is to segment it into several smaller ones, so you don’t always need to serve one giant bundle when only 10% of the components. They can share state through cookies, local storage, etc and with SSR the transition between apps isn’t noticeable.
Adding custom values should never be recommended or even hinted as a valid option, it creates the initial problem where if the language wants to add "flatten" it may not be able to because older code that added it's own "flatten" may cause issue.
&gt; in bigger projects with multiple modules and components, the client-side bundle starts to grow and it slow to build Hot reloading solves that problem for you. If the bundle size becomes an issue, a good way to get around it is to segment it into several smaller ones, so you don’t always need to serve one giant bundle when only 10% of the components are actually in use. They can share state through cookies, local storage, etc and with SSR the transition between apps isn’t noticeable. Before breaking apart your app and adding complexity, first consider removing some bloat from your project.
This article adds literally nothing to the discussion of React vs Angular. Articles of this depth are a dime a dozen.
`foo({showLoading:true, wait:2000})` means that if I change one of those variable names in foo, I need to also touch every spot in my code that calls that.
It's pretty rare you officially get a time stipend to do things not directly related to work projects. If you do, you either have a really great job, or a wise manager with balls.
Self-defence
I get why people don't like smoosh, but I cannot agree with potentially breaking that many sites. 
I think this is where the confusion lies with the original commenter. Yeah that is true but don't do that unless you have too. Same thing as changing the meaning of the first argument. I am rarely in the situation where I have to change the name of a named parameter. You guys do bring up a point for pure js users it is harder to change the name of named parameters. This problematic doesn't exist in typescript for example and happens very rarely. Also if you really hate the name of a named parameter you can always do `const day = d; const month = m`. 
Are you answering a question with a question?
yes?
Hehe
so why not share coding advice on imgur or youtube?
When I started reading the title, I was thinking of the other kind of "event" but then I realised it's about confrences that I do not have money to go to. :) 
What do you mean by bouncing? I don't like Tween.js. Here, I made this for you: https://codepen.io/anon/pen/QmwbmY
Yay! Thanks :) 
wow, thanks! But I'm not sure if I'll be able to use that. I'm trying to implement it in Snapchat Lens Studio, so this might take a little more tinkering.
Are there any benchmarks? "Native" typically sounds cool, but not in case of Promises.
Why? The native implementation is fine. Think of the future developers who'll have to learn another API just to maintain your code.
It's general optimization. Yes, you are free to use as many as you want, but over a certain amount, you have to question if your method is "doing too much". I recently started working at a Perl shop and one of the idioms here is sending flags into the parameter list to turn on or off features. This leads to thousand+ line methods that have use cases for every little edge case and parameter list numbering in the 20s+ and bullshit code like this: # Actual truncated code... my $pageContentHtml = $self-&gt;getPageForContentHtml({ 'flag' =&gt; $flag, 'email' =&gt; $email, 'user_is_authed' =&gt; $isUserAuthed, 'minimal_overhead' =&gt; $minimalOverhead, 'has_left_navigation' =&gt; $hasLeftNavigation, 'search_phrase' =&gt; $searchPhrase, 'reproduce_order_mode' =&gt; $reproduceOrderMode, 'reproduce_order_mode_old' =&gt; $reproduceOrderModeOld, 'reproduce_order' =&gt; $reproduceOrderId, 'display_return_to_backend_header' =&gt; $displayReturnToBackendHeader, 'user_is_admin' =&gt; $isUserAdmin, ... # of 31 total parameters }); 
I don't really know what Snapchat Lens Studio is... but if there's anything else I can do with respect to html, css, js... just let me know!
Python has named parameters and it really can make things more readable and refactorable, especially keeping in mind that you can still use nameless parameters. I find that I change parameter names very rarely, but add new optional parameters quite often, without named parameters new parameters can get messy.
Thanks, I appreciate the help!
Sure, I've used Python and at first I thought it was pretty neat, but then I got into the same sort of thing you talked about. Adding optionals. At some point adding more and more optionals makes the code harder to follow and probably means that you need to break out that logic into more methods to handle specific use cases.
https://codepen.io/adkuca/pen/wmvyxR I did get it to work, on ff and chrome, but on edge it doesn't work I didn't manage to use your code, could you imply it so I can see?
Isn't bluebird faster than native?
As a developer who has never been to a conference and has no real interest in it, can anyone explain why I should even go to one?
Bluebird take off exactly because it was very well designed performance wise. That's why it's hard not to ask oneself how performant is this new library when it tries to compare to Bluebird.
if you are just interested in the talks there is no reasont to. Most talks are available on the internet for free. However the benifit of such events is networking and talking with people in the business
Brian Lonsdorf, aka dr. boolean https://medium.com/@drboolean https://egghead.io/instructors/brian-lonsdorf https://www.youtube.com/channel/UCKjVLbSDoM-8-eEM7A30igA Mattias Petter Johansson, aka mpj https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q
For some it can be easier to learn and stay engaged listening to a real person talk in a compared to just a video as well. 
&gt; Type checking in general in javascript should not be used imho, since there's things like NaN whose type is Number and other non-trivial cases. Type checking prevents you from accidentally creating NaNs which you then have to track down. TS works great.
Hmm... guess I don't have many... Doug Crockford Kyle Simpson Wes Bos
If you're not interested in attending a conference, you should probably avoid it. I had the opportunity to attend one as a volunteer in the local area. While the cost would have been prohibitive otherwise, I had a chance to watch most of talks for free and I got to talk briefly with some really cool folks. My interest in them would be: - Exposure to libraries/thoughts that I had previously dismissed. - Exposure to people with similar/different work environments. There were people from large companies and small organizations, a mixture of toolchains, and folks that were trying to get out of the "stone ages" of web development - A change of pace. Attending the conference left me refreshed and excited about playing around with some new libraries and implementing different strategies. I love the job, but the day-to-day work can get boring sometimes. :-) 
https://en.wikipedia.org/wiki/NaN#Operations_generating_NaN The reason you're seeing it so often in JS is due to its weak types.
If you work for a company that will pay for something like this, it's a good break from the normal day-to-day drudgery. You can pick up a few tchotchkes, maybe make some new friends, and get to experience that waft of evening nerd BO that you just don't get watching online videos. It can be fun, especially if you like talking to people or even watching other people talk. I think it's worth checking out one at least once so you know what it's about - local if possible. When you have to travel and make hotel arrangements, often it doesn't seem worth it.
Your link gets caught by the uBlocker Origin plugin.
Sorry to go off on a tangent but Apple didn't kill Flash and smartphones didn't kill Flash, Adobe killed Flash though inaction. As a previous Flash dev from yesteryear, I feel like there's always a lot of rose-colored glasses put on when people reflect on Flash. Abobe flatly squandered their market dominance and opportunity to retain that position. By the time they started to turn it around they were 5 years too late. Flash was an undeniable resource hog that made it nonviable for early era smartphones. Flash even previously existed on Windows Mobile 5 and 6 (Flash Lite) that predated iOS by several years and it *sucked*. Adobe knew and did nothing to fix the situation. I don't see the iPhone as being a factor besides causing a surge in popularity where all the mobile problems became more obvious. Existing Flash codebases in the wild would have needed significant rewrites to dually support touch interfaces and a keyboard and mouse, so there was never going to be seamless continuity for existing code and Adobe never offered a great path for that transition. Likewise a *lot* of Flash out there was AS1 and AS2 based and would have needed rewriting anyways. You could call those modules from AS3 but the two languages were comparable to calling VB6 DLLs from C# code (AS3 literally ran in a separate virtual machine that AS1/AS2); it was doable but you probably weren't looking to keep writing VB6 in that scenario, especially if performance mattered. You might as well rewrite entirely where a proprietary and costly compiler wasn't needed and at the same time reach new smartphone users. It only later became free to compile Flash, after it was long obvious the product had no future. The Flash/Flex development process was also a huge PITA compared to competing alternatives (especially as a team scaled beyond a size of 1). Debugging, compiling, sharing code, diffing source (because code could be _anywhere_ in Flash, not just in a dedicated source code file), all terrible experiences. Great for artists who were used to animation tools, but bad for standard software development practices. Browsers are pretty well sandboxed and Adobe just kept poking holes in that security too, they kept fostering mistrust in the platform with end users so Flash would have never become a trusted interface for banking websites or anything critical. At the same time JS performance started improving by leaps and bounds and Chrome/Firefox/Safari rekindled the browser feature wars, the JS language itself started improving and IE6 met its demise so more ambitious web sites could be developed ("web 2.0" and beyond). The fact that Apple saw that writing on the wall was smart even if it caused some short term pain. They were heavily invested in WebKit and could see where the puck was headed (remember the first iPhone didn't even have an app store, they promoted web apps). If it was a compelling mobile product Google wouldn't have also yanked it back out of Android after already developing and deploying support for it, they had hundreds of millions of Android users by that point and were the de facto web video host between Google Video and YouTube. Adobe failed to address their own issues, whether intentionally or through incompetence and Adobe is solely at fault for Flash's demise. They had the lead, they were installed on like 98% of all desktops, they even had a laundry list of features we're only now starting to exceed with HTML5/JS/CSS based web sites and they squandered it all. 
Do they also check at runtime?
I stopped reading after that paragraph. 
The linked tweet was tweeted by [@endtest_io](https://twitter.com/endtest_io) on 2018-03-09 17:21:35 UTC ------------------------------------------------- We've just added some new assertion types. 😎 [https://endtest.io](https://endtest.io) [Attached photo](https://pbs.twimg.com/media/DX3OlZHXUAMlGPI.jpg:orig) ------------------------------------------------- ^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •
I have not taken Wes Bos's course, but I briefly subscribed to tylermcginis.com and I used Tyler's udacity program. My own opinion is that he has good techniques and strategies that can be beneficial, but his delivery is way too fast. He flies through content like nobody's business. I find myself having to pause and go back several times in each videos. Ultimately, I would not recommend him unless you are a seasoned react developer looking for tricks or advanced techniques. I would highly recommend Andrew Mead's course on udemy. It is very thorough and not overly fast. He has a TA that actively answers questions on the forum board. He also uses react v16 whereas most other courses use earlier versions. I would then recommend Stephen Grider's react courses on udemy. They are pretty good, but I thought Andrew was slightly better. Brad Traversy is good as well. I would not recommend any others.
I don't know much about flash, but that was a beautiful rant. :)
Ken Wheeler Guillermo Rauch Michael Jackson
Nothing against next.js (or other SSR frameworks) but I just finished build my first SSR React app and found the whole process extremely interesting and fulfilling. I’ll probably try out next.js in the future, but if you have a bit more free time I’d definitely recommend following one of these tutorials 
This is clearly promotional spam. Your post history shows that your account is entirely dedicated to spamming end test. You're violating [Reddits spam and self-promotion rules](https://www.reddit.com/wiki/selfpromotion) and [content policy](https://www.reddit.com/help/contentpolicy/). Get this BS out of this sub.
Do you need to wait for A to disappear before you can show B? Because that‘s not trivial as you‘d have to disable the button in between or hack around unmounts. Otherwise try this: https://codesandbox.io/embed/yj52v5689
core rebooting dir dir online rasputin online anna online Atlas online œ)Á offline del œ)Á œ)Á deleted
I found gold 😀 https://github.com/bnb/awesome-developer-streams/blob/master/README.md
Here's [google cache](http://webcache.googleusercontent.com/search?q=cache%3Ahttps%3A%2F%2Fengineering.innovid.com%2Fcode-splitting-using-lazy-loading-with-react-redux-typescript-and-webpack-4-3ec60140ec5a&amp;rlz=1C5CHFA_enUS771US771&amp;oq=cache%3Ahttps%3A%2F%2Fengineering.innovid.com%2Fcode-splitting-using-lazy-loading-with-react-redux-typescript-and-webpack-4-3ec60140ec5a&amp;aqs=chrome..69i57j69i58.1454j0j4&amp;sourceid=chrome&amp;ie=UTF-8) I do like that they included reference links in the bottom of the article.
I thought the same thing at first, but this is so much smaller than bluebird it really does serve a purpose. Bluebird is like 80kb or something, and (as far as I remember) re-implements promises. This is just a utility library on top of existing apis. If I want to map over async functions in sequence, my functional option is: `await [].map(() =&gt; async () =&gt; {}).reduce((p, f) =&gt; p.then(f), Promise.resolve())` A unit-tested, &lt;1kb function to get `await mapSeries([], async fn)` is absolutely easier to read. I was looking for a good utility library for this last week and it didn't seem to exist.
/u/wesbos (http://wesbos.com/courses/) and /u/stolinski (https://www.leveluptutorials.com/) and their podcast https://syntax.fm/
Yeah I need to wait for a to disappear before showing b. I’ve got it working apart from if you interrupt the mount/unmount
Thanks for the clarification. Clearly weex does not stand a chance against react native, but are things expected to improve on this end?
I'd suggest you have a go with both see if you prefer templates or Render functions/JSX as this is really the only major difference. However, Vue does support render functions/JSX, but the entire Vue community seems to route for templates and single file components. I found Vue easier to pick up when i was new to creating single page applications, but now i'm more experienced i prefer React.
&gt; Is it year/month/day or day/month/year? It should be obvious to any featherweight programmer that the argument values passed need to be in order with the function argument names. &gt; I don't want to have to waste my time looking at the docs or code to figure it out. What do you think is more readable? foo(true, undefined, 2000) vs foo({showLoading:true, wait:2000}) Mousing over any well documented function and its arguments using any decent editor, like Visual Studio Code, reveals a popup with the JSDoc code documentation. This is a much cleaner and immensely more efficient way of developing in JavaScript then unnecessarily creating and passing verbose, prototyped objects containing primitive values for this kind of trivial readability. Names parameters in most cases is complete nonsense and it would ***never*** pass our code review.
I write apps using both react/preact and vuejs... I learned Vue first and then moved to react, when I felt the need to have something more powerful. But I have to say that thanks to my previous knowledge of vuejs, learning react has been a lot easier! You should start with Vue because it has a simpler and easier to understand syntax!
I think Stephen Grider is great tutor. I've learned a lot of stuff from him. Also Wes Bos is among my favorites - he has some awesome tips and tricks on his twitter page. 
Define “simple”. Simple to me means limited JavaScript, and no DB access. Simple to me means static pages that can be served from S3. 
I really like Andrew Mead and his udemy.com courses.
This will get wildly complex though as you can mash the button and then what. A chain that waits will not stay in sync with user interaction. Most transitions will either cross fade or move the leaving item out of the way, for instance by shrinking it, sliding to the sides, etc. 
[Dan Abramov](https://github.com/gaearon)
Definitely agreed, Stephen Grider's tutorials are some of the best I've seen for the JavaScript ecosystem.
this reads kinda funny, considering where you put that comma :)
I didn't even notice I did that 😭
I mean, you have the right to create one function that handles all logic for the entire project, if you want. Doesn’t make it a good idea.
I am currently using lerna for a similar use case, widgets / ui components so far its pretty nice being able to install all dependencies to packages. Although the documentation not that great and and can be found in the readme on github because it differs from the lerna website. Also had to look through github isssues for some answers. It was tricky getting started but overall I think it helps. It is much easier then creating multiple repos and you can have one root level test suite that runs all your tests so you don't have to run a different test suite / setup multiple test environments I think that is one of best reasons for using a monorepo.
As a TC39 member, let me clarify that "don't break the web" is a principle, not a hard requirement. The fact that our specification has a section dedicated to explaining breaking changes we've made should be evidence enough of this.
Rollup has had codesplitting for a little while now; it lets you define multiple entry points and produces the same amount of output files plus a file with all the common stuff. This last file should then be added in addition to the main JS file of each page. This would be the most performant way to go, and Rollup is also very easy to work with, especially when you're just building static or semi-static HTML. Admittedly, though, it's marked as [experimental](https://rollupjs.org/guide/en#experimental-options). In addition, you should consider using the `async` attribute on the script tags (see [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script) for details); that way, your scripts can be placed in the document head so they are discovered early by the HTML parser, but they won't block further parsing. Beware that this could affect your code if it somehow depends on being executed synchronously.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script) - Previous text "MDN" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Typically you’ll need prerendered HTML, bundled JS+CSS, and smart scripts that try to parallelize the work they do. 
https://github.com/michalczmiel/vinci Node.js Todos Cli
Michael Jackson? Never heard this song of his
I can't speak much to the Vue perspective, but I absolutely love how enormous the React ecosystem is. It's shockingly mature and has a hilarious amount of supporting code. You can also eke more performance out of it if you use something like Inferno. I doubt you'll get these benefits with Vue. It felt quite immature comparatively last time I tried it about a year ago. 
Hi DzoQiEuoi, My name is Asaf and I wrote Awaity.js I realize now that I need to work on a better README (: Jsn7821 got it right. This is a utility library that abstracts away the boilerplate of using map / reduce / filter with async-await. The point is to be able to use an async iterator: const posts = map([1,2,3], async (id) =&gt; { const res = await fetch('/api/posts' + id); return res.json(); }) Under the hood, it just do: function map (iterable, mapper) { return Promise.all(iterable).then((arr) =&gt; Promise.all(arr.map(mapper))) } The real implementation does a bit more because it also supports concurrency limit, so for example, let's say you have 1000 promises and want to resolve only 3 at the same time: // will run only 3 concurrently const posts = mapLimit(hugeListOfIds, async (id) =&gt; { const res = await fetch('/api/posts' + id); return res.json(); }, 3); Using async iterators with map / reduce is the main purpose of the lib, and it does that while allowing you to take only the functionality you need, the same way lodash does: import some from 'awaity/some'; import props from 'awaity/props'; import reduce from 'awaity/reduce'; Or, with webpack, use awaity/esm to get tree shaking support, similar to lodash-es: import { some, props, reduce } from 'awaity/esm'; Let me know if you have any questions (:
I'll admit I never read the spec in full. The completion values and `returnIfAbrupt` stuff didn't make any sense to me until recently (after learning Rust Enums and algebraic data types, more generally). I should give it another shot. I do support the "Don't break the Web" mantra, it is one of the reasons for the Web's enduring popularity, and I understand that you sometimes have to break stuff. I wouldn't want to break sites that rely on old versions of MooTools though.
While I built it with performance in mind, I havn't ran a benchmark yet. I will soon. In light of async / await you might not need much from bluebird. The purpose of Awaity.js is and allow you to pick and choose the specific functionalty you want and only that. With Bluebird, you always and up with entire lib in your bundle.
What's wrong with native Promises? I love them.
Maybe I’m misunderstanding here, but aren’t you looking for a web app framework like angular or react?
I get that, but this is rather comparable.
You shouldn't be running a software company, if you're not versed with how software production works. I work, under similar terms about to quit. Unrealistic deadlines and too much overwork 
recommend away ...
Love the roll up suggestion! Thanks for that! 
Interesting, maybe it's an indicator that there is a need for better React state management libraries. That's how I felt at least.
Is this not a simple case of the wrong selector in the scenario? I've been playing with backstop for a bit as well, so let me know. Maybe I can help.
Not by default no, but to really be **worthwhile** (as I’ve stated in my opinion), it does
Okay? Sure? OP asked for an opinion, I gave one. Never said my opinion is law or correct. Just my view on it. But yeah, congrats? Not sure what I should say here...
The rejection handling of native Promises is a bit of a pain point. On an unhandled rejection, native will (currently, at least on node) print a fairly unhelpful message and continue execution. Bluebird will call a full stop with a stack trace, which is much more useful.
Looking at the current Context API documentation: https://reactjs.org/docs/context.html Yes, the context API seems like it can be a good solution. but it's not perfect just yet: &gt;If you want your application to be stable, don’t use context. It is an experimental API and it is likely to break in future releases of React. there are some other warnings too. my library works for me, it's stable. and it's super small and has no dependencies, and also has some other features which I personally find useful such as key obscuring, and dealing with "nested" state in an easy way. I am not saying the new Context is good or bad, I am just letting people know about an alternative that I personally like and use for my own stuff. Thanks for bringing the Context API up though, it's a good point and it will be interesting to see the stable version of it and where it goes in the future, and also the implications it has on Redux/mobX.
this is a great resource that compares react, vue and angular2 https://www.telerik.com/whitepapers/kendo-ui/choosing-the-right-javascript-framework-for-your-next-web-application
React. 
Unstated looks pretty cool, thanks for sharing that👍🏿👍🏽👍🏻
Double agree with everything you said!
As many people have stated, start with Vue JS it will make your journey easier, then move to react. By learning react you almost automatically learn react native. So that's a plus.
&gt; additions like redux React tooling is heavy in my opinion. I find I do not need vuex when working with vue and this my point. You are correct you can use graphql with Vue. I misspoke. No need to be a jerk about it. So I’m sorry you’re upset and you **really can’t understand my point!**. :) Anyhow. I like both framework. Personally had more fun working with Vue as most projects I used it on, anything more would have been overkill. And that’s just my experience and my opinion. Not trying to change your mind.
I don't get it because Vue and react both use props. Thus, if you don't need vuex in Vue then you also don't need redux in react. In any case, Vue is for sure more fun when you start. I think OP should go for Vue and move to react in the future. By learning react he can easily learn react native too. Plus graphql documentation for react is better compared to Vue and graphql for me is the future of api development.
I agree. I think vue is a good start but I am not sure how well it can handle large SPAs. While react is know to be great for this.
Remember, Java is to JavaScript as Pain is to Painting, or Ham is to Hamster. We don't know Java, and if you're trying to apply your Java knowledge to JavaScript, it probably won't work.
Alongside all the JS suggestions - don’t forget you can do some stuff like deferred loading of css; and pull out critical css into the DOM. 
&gt; In classical: we'd just have one object, the kevin. Life/Animal/Monkey/Human would only exist in code For C++/Java-style classes, yes that's true. But for Python/Ruby-style classes, then you would have 5 objects that delegate. That's part of what the deeper discussion revolved around. If Python and Ruby delegate and yet are thought of as classical and not prototypal, then what does it really mean to be prototypal? Admittedly, though, most folks in the JavaScript community would distinguish between classical and prototypal exactly as you did, and if you're going into an interview, that's the safe answer. &gt; classical = billion * (each new human's additional bit size) + billion * (resulting Human bit size from Life + Animal + Monkey + Human) Ultimately no because they optimize for that. In C++, for example, all the functions from Human + Monkey + Animal + Life are stored in a single table, called the virtual function table or vtable, and each human instance contains a pointer, called the vptr, to that table.