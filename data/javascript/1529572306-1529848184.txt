React-router is library, it's not part of React. If you don't like all the changes to React-router, there are a number of other routing libraries you could choose. That, I think, was GPs point. 
First it is smaller server is just 500 lines (not min under 25kb) client is under 7kb (not min), does not require to have separate files for broker, worker, configs. This library was build because of socketcluster (had alot of problem with implementation, stability, and the size of the actual library, i have found alot of redundant code and did not like the way how library works). To be able to clam that it is faster or other vise slow we need actual benchmarks and unfortunately it has not been done yet (we have plans to make benchmarks).
&gt; unsuitable for hobbyists and startups who want to move quickly Disagree. Intercom's CTO said Ember was the best decision they made, allowing them to focus on the quality and the product rather than arguing which React router to use. (last bit is me putting words in, Gavin didn't say that) They're a $1.2b company today founded just few years ago.
It's not dying and it's not meant to be sexy. It's meant to be get shit done.
Been working with both Ember and Vue for a few years and find Vue’s browser dev tool extension much easier and straight forward than Ember’s equivalent (where I feel lost and confused and end up writing console.log’s most of the time instead). Believe a more simple/clear browser inspector would do good for the future of Ember.
U keep the split value in var array but u r printing splitname\[0\] witch is a string and cuz strings can use some properties like an array 'somestring'\[0\] would return the first character as in your case
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
25 upvotes in 5min before 6:30am EST. Riiiiiiight
Well he is using everything he taught before. Didn't overwhelm me, but I did plenty of dom manipulation before already. The concept of the iifes as modules was new to me, but made good sense!
It's ok. Nothing to worry about. Learning stuff can be complicated. I do wonder about one particular thing, though. You mention lurking and reading, but... do you _ask_? I mean not necessarily here, but do you have someone or some place where you can ask questions and explain your doubts and difficulties? Maybe you do. I ask because I think going on your own is fine, of course, but sometimes it helps a lot to be able to ask specific questions. I know this doesn't address much of what you said, but, well, I hope it helps.
Keep practicing JavaScript till you get very confident building stuff. Jump into ES6 asap! I think it's too early for you to jump into any framework without understanding what's going on under the hood. I'm learning JS for a past 6 months ( Just went through async/await, promises etc. ) and I still fell I'm not ready to jump into any framework! 
Good point about generators as iterables being rather unusual. The reason why I ran into this behavior is probably related to a specialized use-case in the code I was working on.
My first javascript encounter was with a framework and i feel like you dont need to know alot about vanilla to get started with one. The javascript required to make it just work is pretty easy. Obviously if you want to write anything production worthy you'll need to know all about es6 n such, but if i interpret correctly what you mean when you say you cant get it to work, i think you should read the documentation of vuejs and perhaps start by remaking examples you find on the internet and adding to/changing them. It all depends on how you learn, but this has worked for me when trying to learn frameworks and es6 simultaniously. Dont know if this helps you in any wat, but good luck anyway!
I noticed that when I dug up the link. I was a little surprised about the lack of mention there (same with throw()). Usually mdn is pretty good about that stuff.
I'm still not convinced there are any actual, real world problems here. The onus isn't on me to prove your point, and making anti-arguments like 'it should be obvious'... I'm feeling more confidant this is a non-issue. But I'd love to be proven wrong, and broaden my understanding.
Thanks for your reply. I actually never considered asking my questions, to anyone really. We mostly make jokes about StackOverflow being so harsh on newbies that sometimes I just don't ask and try to solve it on my own by researching things. But this is something I'll consider from now own and whenever I get stuck, I'll ask. Much appreciated.
You are right. I thought about making small web apps but wanted to jump into a framework **and then** make one, but maybe I should first make one in plain JavaScript. Thanks for your feedback!
You can. The correct way is to use an JavaScript parser like acorn or babylon or something else. Depending on the situation you might get away with a hacky regex.
Well, I do know how frameworks work but this one was my first one. Never considered learning a CSS framework because I didn't feel like I needed to. So this is actually my first time learning a framework and reading through documentation of a specific subject. Might wanna take a better look at the docs instead of just watching videos and trying to solve the challenges.. 
The whole point of modules in JS is locality (or namespacing): Prior to ES modules, every variable defined at the top level was global which means a property of `window`. Two modules cannot access each others variables without importing it: &lt;script type="module"&gt; const x = 10; &lt;/script&gt; &lt;script type="module"&gt; const y = x * 7; // ReferenceError &lt;/script&gt; You can still use `window` though to cheat the system (avoiding export/import). &lt;script type="module"&gt; const x = 10; window.x = x; &lt;/script&gt; &lt;script type="module"&gt; const y = x * 7; // 70 &lt;/script&gt; Now, the names you specify inside e.g. the `onclick` attribute look for properties defined on `window`. So you write: window.objectWithFunctions = objectWithFunctions; **Note:** I discourage doing all of this. This is ugly as heck. Firstly: Refrain from using the `window` variable this way. And secondly: Refrain from using attributes like `onclick`: Use `element.addEventListener` instead: myElem.addEventListener('click', (event) =&gt; { objectWithFunctions.function_(); }); It's more flexible (you can add more listeners).
In your js file (not the script tag), you can make the module global by assigning: import theModule from './file' window.theModule = theModule When this file is bundled and included in the html page, theModule should be globally available, even to the onClick handler.
Oh, ok. The most annoying thing when debugging `ospec` was the fact that it was unable to differentiate some internal errors from test failures, and the stack trace cleaner left no useful info (or caused crashes). That's been removed recently, internal errors are now rethrown.
Thanks for your answer. I agree, this is ugly as heck and doesn't feel good. But the solution with the event listener breaks down to the same problem: I have my app-div which holds all my content. Now I render a new view "into" this div so how could you register the event listener afterwards. Tried it with a simple `&lt;script&gt;` tag but it won't register the listener. &lt;!DOCTYPE html&gt; &lt;html lang="de"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel="stylesheet" href="style/style.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; \-- script loading... -- &lt;script type="module" src="./function/app.js"&gt;&lt;/script&gt; &lt;script type="module"&gt; import App from "./function/app.js"; import Store from "./function/store.js"; document.addEventListener('DOMContentLoaded', function(event) { const store = new Store(); const app = new App(document.querySelector('#app'), store); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
Still not the target market. It does work – that’s actually exactly the situation I’m using ember in right now – but I wouldn’t have done it if I wouldn’t have known ember very well.
The route "model" function gave me many headaches especially when I needed to refresh data somehow
Semi-random: Are regular expressions more performant than formulae such as vlookup and find in applications like Google Sheets and Microsoft Excel? I ask because I have workbooks with hundreds of these types of lookups, and even on multi-core processors it’s pretty slow. May be a question for r/excel ?
True, my team followed and participated in Ember’s RFC process, which made them better software engineers and Ember experts. When there are more teams to read up on, it can be harder to follow the architectural discussions. I am getting into React for serious development for the first time and having a hard time identifying which libraries are going to mix well with React’s metaphors. Some of that comes from experience with the ecosystem, but without a central authority, it can be hard for newcomers to navigate all the options. 
LEGO bricks from a hundred manufacturers. What I would like is a set of core libraries that you can swap out if needed. That is how Ember works. Heck, if I like React, I can swap out Ember Handlebar components for React JSX components with only a few lines of code. The same can be done up and down the stack and is often done at the data layer since there is such a wide variation in API models. (JSON over REST is not specific enough to build a library around)
&gt; I'm still not convinced there are any actual, real world problems here that's nice . &gt; The onus isn't on me to prove your point stop being a stereotype. there is no onus to prove the point. i don't care if you believe me or not; i wasn't talking to you it was a kindness for me to respond to you at all learn to say "thank you" . &gt; I'm feeling more confidant that's nice . &gt; But I'd love to be proven wrong you already were. you didn't understand, and you responded in a way that pissed the person you were talking to off, meaning you won't be getting more help you could have said something like "i don't get it. could you help?" instead you followed the redditor flowchart for proving people wrong without looking like you're on the attack these are the appropriate steps for politely handling vaccine deniers, moon landing deniers, and homeopaths. of *course* someone isn't going to keep helping you after you treated them this way.
Async await would need to work with fetch. The dichotomy is Axios vs Fetch.
I've been on a team that used Ember for about three years, so I agree with everything you said. But it sounds like you dislike pushing Ember and you think React is a bad choice, so what exactly do you think is the best path forward?
man i just went to make this big sarcastic gif response i wrote out some html with a bunch of ren and stimpy jokes in it and i went to click the reload button, and ... and ... and what the fuck? wwwwwwwwhhhhhhhhhhhhhhhyyyyyyyyyyyyyyyyyyyy is ie caching values ***you are correct*** so i went digging in msdn. this is a result of a change to how ie11 sees autocomplete. this is ie11's idea of correct. (amusingly, not 10, and not edge. it's just 11.) there are basically two reasonable options 1) you can turn autocomplete off for that form &lt;form id="i_was_wrong" class="damnit" autocomplete="off"&gt;... 2) you can manually undo the jobber window.onload = () =&gt; { document.getElementById('yrform').reset(); window.onload(); }
If Vue was difficult to get your head around, I doubt react or any framework will be much easier. If you are subscribed to frontend masters then go through one or more of their pure JavaScript courses. I think they have a few and their stuff is generally highly recommended.
Ok maybe I misspoke on that point, there are definitely advantages to using a more complete framework that focuses on convention over configuration in terms of getting an MVP up and running quickly. But it still comes after an upfront time investment in learning those conventions and other idiosyncrasies and how everything integrates. Then as you iterate and certain conventions invariably don't fit your use case, you have to work out how to break them without making a mess, which sometimes involves peeking behind some abstraction to understand its (likely complex) internals. For teams of three or more people where knowledge can be shared efficiently (I'm gonna assume the example you gave falls under this category) it's probably not a big deal, but for one or two person "teams" it's gonna contribute significantly to cognitive overhead and limit the rate of results, at least for a while.
I'm sorry you feel that way
Why the hyphenation of the title? I can already see this is going to be full of utter bullshit. 
How is refactoring a quick way to end up with unmaintainable code? 
Hi /u/trinidadejo, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/Wheinz, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
Hey! I was in a similar situation. I jumped into React right away and was really just memorizing patterns, not really understanding the JavaScript behind it. I took a deep breath, did some self awareness, and did a deep dive on learning and experimenting with JavaScript. Then I started actually building things. After a while I went back to React, and I picked it up within a couple days. And this time I wasn’t just memorizing patterns! A couple of resources I found helpful. -[JavaScript30 by Wes Bos](https://javascript30.com/) -[JavaScript: Understanding the Weird Parts by Anthony Alicea](https://www.udemy.com/understand-javascript/) -[MDN Docs (yep I literally read through all of them)](https://developer.mozilla.org/en-US/docs/Web/JavaScript) Cheers and good luck! 
Hi /u/WeranioRacker, For javascript help, please visit /r/LearnJavascript. Thank you!
I'm not exactly sure how regex works in excel, but I do know that vlookups are pretty hard on the computer (and can scale up exponentially fairly fast). 
I wasn’t aware, but had a feeling when a 34MB Excel file would take 30 seconds to open on an i7. 
I did a lot of excel/sheets work before getting into JavaScript. I’d recommend using Sheets’s filter function. Insanely fast and flexible, add some queries into it and it’s also super flexible.
Awesome! I really appreciate the tip/reply. I wasn’t aware of the performance difference between vlookup and index/match! 
You misunderstood me. The real question you should ask yourself is, “Do I really need a single page app?” I would wager that 80% of single page apps should’ve been built with some server side rendering technology like Ruby on rails. It’s lightning fast, is extremely productive to work in, is dead simple to deploy, etc... If your site is mostly just presenting content and CRUD forms, you don’t need a single page app. If your site is highly interactive MAYBE you need a SPA. Ember is a great choice if you don’t care about hiring, are willing to learn the conventions and want a stable long term solution. React is the right choice if you’re desperate to hire and unsure about the future (i.e. building an MVP) and don’t mind you’re code base becoming a mess that only you really understands. (And if you’re insane and think JSX is a good idea)
So you typically want to draw with integer coordinates, not floating points. If there is a fraction of a pixel involved in the position or sizing, it'll have a blurry effect on the edges of your sprite. In your requestAnimationFrame() you should be using delta time to ensure your movement is consistent. You can do that with something like: let time = Date.now() (function mainLoop(){ const dt = Date.now() - time; time = Date.now(); requestAnimFrame(mainLoop); render(); update(dt); })(); Then inside update, multiply velocity by dt. So: this.x = lerp(car.x, car.x + x, 1) * dt; Then adjust the amount of speed you want accordingly. While you can use your lerp function for stepping the whole way between start &amp; end, if you just want to do that, it's probably better to just have. this.x += x * dt; Instead of using a lerp function. If you want to have your car move from one pos to another over a number of frames, that's where a lerp can come in handy. But then you would need to not use this.x, but store a startX coordinate of where the car was when you initiated the lerp.
that's a weird bug but yes #2 solve our issue but didn't tried first option.
&gt; Vue: It's... confused, it looks like Handlebars, JSX, Angular, and web components all at the same time. There is no accepted way of doing it right, every time you say "but in React you can..." they say: "We can, too!" It's a mess, to me anyway. This to me looks like a comment from someone who's never touched Vue before. It has much more "convention" than React. When articles stop coming out about "the best way to bind a click handler in React", maybe then your point will become somewhat valid. 
Thank you! I am actually a fan of the [syntax.fm](https://syntax.fm) podcast, so I should certainly check out Wes Bos' course. Much appreciated!
It's actually a decent article imo. 
The fuck do you have a help? Tag then?
I figured it out, thank you.
Misleading title. Only PWA and hybrid fits.
Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have [2-99999] problems.
That's impressive!
Is anyone else unreasonably excited about the pipeline operator? I started using it when I started playing around in Elixir, and then I added the babel plugin to use the pipeline operator in one of my projects and it's become probably my favorite language feature. Combined with Ramda, or other functional equivalent (sanctuary), it's really nice. I love being able to right code like this: 10000 |&gt; R.toString // "10000" |&gt; R.reverse // "00001" |&gt; R.splitEvery(3) // ["000", "01"] |&gt; R.map(R.reverse) // ["000", "10"] |&gt; R.reverse // ["10", "000"] |&gt; R.join(",") // "10,000" |&gt; R.concat("$") // "$10,000"
Part of his research might be getting insight from a large community of developers such as this one
What i especially like about learning by examples is that it already works. If you can now deduce why and how, you can replicate it and add it to your vocabulary of stuff you know how to do.
Correct. Using react doesn't bind you to react router. There are a million other techs you could use or you could write your own and it wouldn't be out of place or some nasty hack to get it integrated. The library approach leads to more innovation IMO. You only have to look at Reflux, redux, and even rxjs for an example of that in the react world. However, couple yourself with a huge framework and you are SOL if some part of that framework is busted or awful. Patching it or bypassing it will land you in a world of hurt if they decide to change things up in the future.
&gt; I have over 70 years of Good, then we can judge each others arguments without presumption of inexperience, nes pas. &gt; You’re part of the less than 1% of the developer community who actively pretends that types are something negative. This is true; im not quite so such its as low as 1%, but otoh there are foetid mountains of java devs who lose their gourds when taken out of the familiar tools and ides. That doesn not mean java + slow IDE is the ultimate programming environment. There are also significant numbers of people moving to python and JS. Hell, JS is outrageously growing to the point where it seems to represent a real risk of hegemony. I feel TS is like a "java reactionary" language - sometime trying to keep their comfortable fetishes with them into the new world. Surely some percentage of them are mystified by the additional productivity gained, and proceed to ruin it by making spaghetti. I have unraveled countless colanders of python. But some *get it* and actually use dynamic languages to their full potential. &gt; There’s no big codebase that wouldn’t benefit from being typed if not just for the clarity of sharing information between multiple programmers You are missing my point: its far *easier* to share interfaces without types. Functional interfaces and message interfaces are extremely good at this. Adding types to that is like putting nipples on a breastplate: useless adornment. &gt; Programming is social, unless you only sit on your own? Once you teach someone how to design modular encapsulated code, you can work in very large teams. I have done this for C, C++, Java and many other environments. JS just makes it a lot easier and faster, and less bug prone. Devs who just cant write non-spaghetti code are usually net negative productivity - I tend to weed them out and not keep them employed for long if they somehow slip past the interview process in the first place. 
Is this a joke? Chrome was never a replacement for Firefox if you valued customization or privacy. 
Add the events that you want to the dom elements in your script. const element = document.getElementById('target-element') element.onclick = myfunction or something like that.
&gt; Time and time again? I bet you did Angular before. I was part of a team that evaluated frameworks for a future project back in 2012/13. At the time, I was behind ember and thought it was the way to go. I was fully bought in to the sales pitch.. Until, they released a new version which broke my prototype, then a another one, then another one. All while we were still evaluating! Maybe things have gotten better for ember now, but that left a super sour taste in my mouth. After that, it was the angular 2.0 debacle. Prior to that, I was all in on RoR around the 3.2ish release (which, 3.3 broke me, and 3.4 broke me again, then 4.0 was released and basically required a rewrite to do things the "right" way). Sure, they might do things better now. But for me, the bridge is burned. There is no guarantee that they will continue to honor semivar, and even if they do, there is no telling how big a break will be caused by the next major release. After all, it is perfectly verboten in semiver to release 1.0 then 2.0 then 3.0 and stop maintenance of 1.0 and 2.0. So what has that major version saved you started with a 1.0 app? Certainly libraries can do the same thing, but by their very nature of being a library, the impact is minimized and localized to the area you are using that library. So what if the Yaml parsing library moves from 2.0 to 3.0 and breaks every single API? It would take work to replace it, but it wouldn't require you to rewrite your entire application.
Vlookups on a sorted data is the fastest. If gSheets,use arrayformula().
Meh, okay then. I’m surprised that you’re so casually uninterested in getting devs to use your preferred framework, but I guess that’s one of the reasons it isn’t widely used.
Are you looking to do this server-side or as something client-side in the browser? 
Sort of implicit there with the "with React and Node" qualification in title. It's not titled "The Definitive Guide On The Only Way To Build A Modern RSS Reader"
I usually use \`nginx\` with \`lua\` to do something like this. \[Here\]([https://github.com/bungle/lua-resty-template](https://github.com/bungle/lua-resty-template)) is a package that does something like that.
I doubt if you read it。
There's an old saying, 'You can't judge a medium article by the way someone chose to post it to reddit'.
1. Don’t 2. Don’t 3. Don’t 4. Don’t 
Looking at articles like that I always ask myself a question - did people became so dumb that they can't figure out such a simple pattern of using frameworks built in feature like slots.
It’s better when people don’t use it rather than use it for the wrong things and then complain about how much that framework sucks to everybody they talk to. Ember is a really bad fit for the traditional gung ho-style JavaScript programming world. It requires you to keep discipline and splitting your code into components and services in the right way, thinking about your architecture while you program along. It's not something where you get from zero to hero in 5mins, like it’s expected from modern JavaScript libraries. I've done that with React Native, but that code has instantly become a mess after 3 days of programming. Meanwhile, I've been writing a giant ember application for more than a year now (https://www.dungeonfog.com), and it’s still as tidy as it can be, because there’s no other way to do it with this framework.
Hey all, I am super excited for this release. It represents over a year's work of which I'm really proud. I hope the larger JavaScript community finds value in what I and others have found to be a really powerful and arguably the best way to write JavaScript applications. Here are the v1.0 release notes: https://github.com/andrejewski/raj/releases/tag/v1.0.0 I'm around all day to answer questions.
This one is both very basic and incredibly useful. // Match all printable characters someString.match(/[ -~]*/) Found it here: http://www.catonmat.net/blog/my-favorite-regex
Perhaps I'm just enforcing your point, but what you've written is the same as ´[2-9]´.
You put no effort into the title so I’m expecting the article to be the same. 
True native and React Native =/= turning your website into a mobile app unless you're writing a wrapper (e.g. if you need geofencing or other mobile-specific features). You're essentially rewriting your website as an app, at which point the support and development flow of it changes entirely (which in response changes the user flow as expected). PWA is something you can add around an existing website but doesn't give anything that's not also beneficial to your website (such as offline handling). Leaving hybrid apps which fall somewhere in between rewrite as nearly-wrapper and react-native. It's a good article to cover the main bases of mobile development, but the title doesn't match up with that.
https://regex101.com is the shit btw. It has a great feature that essentially shows the explain plan for the regex you constructed. Super cool.
I stand corrected. I am flabbergasted! Good catch, sir!
Now they have {2,} problems.
“Love” is a very strong word here. 1. Indifferent 2. Like a lot 3. Hate
For some reason, that pipeline operator just doesn't work for me. I find the samples hard to parse with my meat computer. Maybe I just need to use it a bit.
It's a good example but that function syntax replace is pretty sketchy ^what ^^is ^^^this
Wouldn't /( |.)*/ Work as well
But seriously Javascript has decent string parsing primitives and libraries like Voca, Lodash and Parsimmon extend it for more demanding tasks. Typically resorting to regexes is what you do when you already have small, otherwise hard to parse chunks. Doesn't stop Perl guys to treat everything like a regular language (cue Zalgo memes). 
So one thing to keep in mind is frameworks like Vue require thinking differently than vanilla JS or JQuery. Instead of manual DOM manipulation you are binding the DOM to your JS code, and it updates automatically. It definitely takes some getting used to. That being said, I would recommend taking some more time with Vanilla JS in general. Make sure you feel very confident in it. Focus on ES5 stuff at first, especially manual creating object prototypes, the behavior of "this", etc, before moving on to ES6. ES6 has made JS so much better, but there's a lot of syntactic sugar that hides what goes on behind the scenes, and that knowledge is useful. Once you've got all that down, dive back into Vue and take it slowly. It is very easy, but you need to understand the philosophy behind it first.
I know this is a zombie post, but it's been bugging me since I first read this... In this context, how would he replace those switches with prototypes? I mean at some point he still has to choose the player. I understand prototyping (and classes) and inheritance, generally speaking, but I don't get what kind of organization are you advocating here? 
And has a full list of regex commands and examples. Im barely getting around to remembering positive and negative lookahead/behind
That rare occasion when correcting someone makes their statement more correct...
Eh, I feel like if you want all printable characters that regex is going to lead to 😟 and ☹️
Sure, you'd need to choose a player type at some point, but then just pass that type around. In C# you'd just use an interface or abstract base class, all of your derived types would have the same methods as what you inherit from, and then you pass the interface or abstract around or use dependency injection. In JavaScript I guess you would just pass the object itself (compose it when you make the decision.) That way you wouldn't be having to figure out what type of player you have every time you call a method/perform an action.
Ah *ha!* Thanks, I was looking for this recently. Ended up at [Regexr](https://regexr.com/) instead, which also did the trick. 
Same! I can’t wait for this to be available in node and supported 100%. Going to be soooooo cool. 
Well this is just ignorant. I'm currently working on bringing a templating language into a react application to enable our partners to do some customization without draining our dev resources. It's an absolute necessity for us.
class Player { constructor(url) { this.url = url; } } class Youtube extends Player { play() { console.log("Youtube is playing:" + this.url); } } class Vimeo extends Player { play() { console.log("Vimeo is playing." + this.url); } } function somemethod(player) { player.play(); } let myPlayer; let playerChoice = 'youtube'; if (playerChoice === 'youtube') myPlayer = new Youtube('someurl'); else myPlayer = new Vimeo('someurl'); somemethod(myPlayer); Run this in node: node player.js Youtube is playing:someurl
Very basic and incredibly useful and also wrong. It's 2018 please stop assuming the whole world uses 7 bit ASCII because it doesn't. Do yourself a favor and use \S* which is more readable and more correct. 
The pipeline operator is definitely a personal preference/stylistic thing. The same thing above could be achieved with method chaining if that's your thing `data.map(fn).filter(fn).map(fn).forEach(fn)`. However, because I prefer a slightly more functional style and love Ramda &amp; currying, the pipeline operator usually is easier to implement than trying to do the same thing with method chaining. I'd recommended trying to write some code with it though, as that's how you can really find out where it's good and where it sucks. When I first saw it in Elixir I thought, "oh, that's neat, but I don't really see why I would want to use that a lot". Then I started playing around with it until it clicked, and I'm a huge fan. However, it's far from a silver bullet, I really like using it when I have some data that I need to transform/filter/validate, however it's not as elegant (to some) when there's a bunch of state that needs managed*. Just like anything, it's good when it fits the use case well and going full blown haskell "monads are monoids in the category of endofunctors" functional with the pipeline operator can be just as bad as drinking the Java Enterprise OOP `AbstractFactoryBuilderFactory` koolaid. *That's not to say it can't be used in these situations. For shits and giggles I created some wrapper functions around some shipit (deploy script lib -- comparable to capistrano) to allow me to right tasks using the pipeline operator to build up commands and finally pipelining them into a collapsing function that actually executes them. It's usage doesn't look appalling, however the implementation of similar functionality would be far more elegant with a simple class that chains the methods. remote |&gt; inReleasePath |&gt; run("find $(pwd)/html -type d -exec chmod -R 755 '{}' \\;") |&gt; run("find $(pwd)/html -type f -exec chmod -R 644 '{}' \\;") |&gt; execute 
Genuinely curious - is Perl still a thing? Out of all the languages out there, I very seldom hear anything about Perl.
I have a few thoughts. If you're confused, it means you're learning. This is a good thing. I'd be more worried if I weren't confused. Frameworks exist to solve complex problems. Going from the basic structures of the language to understanding how a framework.. works... is going to require a steep learning curve the first time you do it. Frameworks are there to make state management easier, rendering quicker, and composition possible. These aren't the concepts you're thinking about when learning how to loop through an array, for example. Chin up! Forge ahead! Stay confused.
I LOVE Regexr!
I think you're missing that in the second line "age" is passed into the function (first and only param). Its not singularizing or anything fancy. in line 6, you pass the *function* into .filter()...and .filter knows to iterate over "ages" and pass each each val into the function checkAdult() and only "keep" if the function returns true.
The key is in the description of the filter method on the previous page: "Creates a new array with every element in an array that pass a test" In this line: document.getElementById("demo").innerHTML = ages.filter(checkAdult); *ages* is an array and they are calling the filter method on it. The filter method takes a function as a parameter, and it's that function that will be used to test each value of the array. So providing *checkAge* to the filter method means that for every value in the array, that value will be passed into the *checkAge* as *age*, and if *checkAge* returns true, that value will be added to the new array produced by the filter method. 
What problem doc you see with jquery exactly?
It lurks deep in the depths of bad CS departments in universities around the world.
I still don't 100&amp;#37; get it. Why are the values being passed into \`age\` specifically? Where does that name come from? So basically \`.filter()\` does just take whatever the name of the array and singularize it? What if we weren't doing ages. What if it was an array of store products - and the variable was named \`storeInventory\`. What does \`filter()\` function name the single value array? 
1. This is Polymer in the real world: http://www.npmtrends.com/angular-vs-react-vs-vue-vs-@angular/core-vs-polymer-cli And it probably won't change. Keep in mind Polymer is one of the worst offenders in regards to the promises they made, throwing people into constant rewrites. 2. That won't happen. Polymers api is imperative, it is a severe regression. The shadow-dom is a small, perhaps insignificant feature that just masks a naked dom. Encapsulation hasn't been a problem for years. Polymer itself is not a standard, it is a massive framework introducing bindings, syntax extensions etc. Last but not least, web components, if they ever would gain traction, would increase fragmentation. You load 10 components, and in the worst case you end up loading 10 frameworks on top of one another. 3. You set up a project with cli's. The idea that the web will function without build tools is a pipe dream. Not to mention that they've stabilized: webpack, babel, typescript - if you insist doing it by hand instead of a cli setting it up for you.
I figured it out, but thank you for your tips.
Ok, ok. You are very smart. We get it. This community fucking sucks.
You are correct, in that the problem described is a classic producer-consumer &gt;In your final solution you do introduce a queue, and that is in fact what solves your problem. That's not what solves the problem, in the example code (which mirrors the problem we had) a queue was always in place and throttling is used just to trigger processing of the events in the queue. Let me try to explain the problem we ran into one more time. Let's assume for a second that no throttling/batching is in place (that's how one would start, until performance issues come up), due to the single threaded nature of JS at *any* point during the code's execution we can safely assume that all previous events have been processed - correct? Now, after discovering performance issues we introduce batch processing, (thus a queue + some trigger condition to perform the work, throttle, queue size etc doesn't matter), thus making event processing *async*. In this case we cannot make any assumptions about whether all events have been processed or not, when they'll be processed or if at all - isn't that non-deterministic? The point that I want to get across is: using debounce/throttle (or any batching methods) to improve performance **may** result in hard to reproduce/troubleshoot issues. If there is state you care about in the throttled/debounced function, the consumer of that state cannot make any assumptions. 
&gt;So basically `.filter()` does just take whatever the name of the array and singularize it? Not at all. When you define the *checkAdult* function, you name its parameters so you can refer to those names in the logic of the function. "age" is just a label for the first parameter of the function. The filter method doesn't name anything. All it does is create a new array, and apply a boolean function (predicate) to each value of the old array whose filter method is being called, and values that pass are added to the new array. You can supply any function you want (its return value will be interpreted as a bool) to the filter method. There is no relationship between the filter method, the name of the parameters of the test function, and the name of the array being filtered. 
&gt; It’s better when people don’t use it rather than use it for the wrong things and then complain about how much that framework sucks to everybody they talk to. Good gravy, two wrong assumptions in one sentence! &gt; [Ember] requires you to keep discipline and splitting your code into components and services in the right way, thinking about your architecture while you program along. I think the thing you’re getting hung up on is this “right way.” My apps are built with discipline, split into components and services in a logical and effective way, and I do think about architecture while programming. Yet my code is neither Ember, nor Ember like, except perhaps in one way or another. It is foolish to assume any one all encompassing framework could be the “right way” to structure code for every app, not because there is any inherent limitation to that particular framework, but because a given app may have completely different goals. For example, Ember would be hilariously overkill for a web app that counted the number of words in a string, or, in my case, my web apps require absolutely no routing, a feature that (at the time) was pivotal to using Ember. &gt; I've done that with React Native, but that code has instantly become a mess after 3 days of programming. Perhaps if you keep discipline and split your code into components and services in a reasonable way for your app, thinking about your architecture while you program along, you won’t face such issues in your React Native programs.
Вот кстати классный материал по регулярным выражениям в JavaScript [http://webdiz.com.ua/glava-4-stroki/metody-regulyarnykh-vyrazhenij](http://webdiz.com.ua/glava-4-stroki/metody-regulyarnykh-vyrazhenij)
Is this a meme?
jQuery doesn't make unmaintainable code, people make unmaintainable code.
Please do not divert the question. The question is not a rant about jQuery, it is asking if Github is still using for its major UI components, and if so, how do they manage it at that scale.
"How dare you not know this thing we didn't document". However, I've noticed that when you know something long enough, you forget you ever learned it. I have to remind myself when developers don't know about something I've come to think just *is*.
**Regex is the Best, Regex is the Myth, Regex is the Legend**, No matter what you All think
Might be easier if you see an implementation of a filter function. `filter` has an array, and takes a function that returns true or false when called with each value of the array. const arr = [32, 33, 16, 40] function filter(func) { // the check function is passed as the parameter "func" const returnArr = [] // loop over the values in arr declared above the function for (let i = 0; i &lt; arr.length; i++) { if (func(ages[i])) { // here we call the passed check function with the current value of the array returnArr.push(ages[i]) // if the check function returns true, we end up here and add the current value to the returning array } } return returnArr } function checkAdult(age) { return age &gt;= 18; } const filteredAges = filter(checkAdult) console.log(filteredAges)
Hey! Just wanted to thank you for your amazing advice! Thanks to your suggestions I got the job and I am now working full time as a Javascript developer :) every little bit of your message was a great help so from the bottom of my heart, thank you.
1\[0-9\]+|\[2-9\]\[0-9\]\*
Sounds really interesting! Looking forward to having a proper look at it!
To me, programming languages are the silly stuff dangling off the regex engine.
"Tricks"... RTFM?
jQuery does not support data-binding. It can be used to implement data-binding, but the usage of jQuery in no way implies data-binding (whether one-way or two-way). In fact, it's because of this that data-binding became a thing -- devs got tired of having to manually collect/copy/transfer form values in order to serialize and send to the server.
I feel fortunate to have done most of my JavaScript learning before the big explosion of frameworks in the last few years, and before things like ES6 came along. It's all second nature now, but imagining trying to get started with it all in this day and age is bone chilling. I don't really have any advice to give other than keep doing what you're doing, and don't be afraid to take a step backwards every now and then to remind yourself of the fundamentals. Be scrupulous about where you're learning from too as a lot has changed over the years and a tutorial that hasn't been kept up to date with how things are supposed to be done *now* can lead you down a path of confusion and frustration.
Greeping through their scripts, I do see a few references to jQuery, but also to rollup, regeneratorRuntime and custom elements, which would indicate the codebase is at least modular and somewhat modern. Things seem to be mostly server-rendered to me though, so my guess jQuery usage is likely only constrained to powering some legacy libraries that depend on it.
At first, I enjoyed the AdonisJS framework, and I guess still do. But the maintainers and community leaders are children on a high throne. They cannot discuss issues and reduce any constructive conversation to name calling and refusal to communicate at all. Thus, I would not recommend building anything serious with this project, as you won't get any support if you fall out of favour with the maintainers.
Military software probably. Written in Perl way back and runs on emulator on top of emulator on top of emulator. 
Hi /u/czechman45, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/kawnah, For javascript help, please visit /r/LearnJavascript. Thank you!
If there's one thing that really annoys me is a website forcing me to go to the app store to install their app, when all I'm trying to do read some comments or find store hours (looking at you yelp)
I think Booking used some Perl, dunno if they moved on since. irssi IRC scripts run on Perl too. You have basically the same regex in PHP and the language is nicer to write even for local scripts. Perl's CPAN repository used to be a ahead in the easy to use script repository department, and there's probably some libraries there for odd stuff you don't find elsewhere, but other scripting languages have repositories too (npm horrors aside). I don't feel myself there aren't many particularly strong reasons to choose it over the other options. Maybe it could be a better Lua if they worked on the simplicity/performance part of DSLs for mods.
At my last job we said that verbally, but it went: "if you're using a regular expression to solve your problem, now you have two problems." God i fucking hate them. I was introduced to them too late in life to want to learn the alchemy required to use them. 
The variable `$` exists in console, pointing to jQuery. Also, in Chrome Dev Tools, when I try to find event listeners registered for elements, they point to nonexisting files, such as https://assets-cdn.github.com/assets/github/menu.js . I've never seen anything like this before. How can Chrome point to file that do not exist? Are these from a source map? Source maps should be deployed to production.
$ in Chrome and Firefox consoles does not immediately mean jQuery is present. In fact they are just a shorthand for document.querySelectorAll, and that is the case for Github. $("body") &gt; &lt;body ...&gt; $("body").width() &gt; TypeError: $(...).width is not a function
I think you're incorrect here - The chrome devtools provide a jQuery-like `$` object for selecting elements. You can test this by opening [about:blank](about:blank) in Chrome and evaluating `$` in the console. On websites that use jQuery, `$` evaluates to something like `ƒ ( selector, context ) { // The jQuery object is actually just the init constructor 'enhanced'......` while on non-jQuery websites, like about:blank and GitHub, `$` evaluates to `ƒ $(selector, [startNode]) { [Command Line API] }`
Register the event listener right after you .appendChild your new view?
That's a cool that you didn't give any explanation at all as to why you shouldn't do any of these things, specifically #1. PWAs are fine for simple apps, and stuff that doesn't need an internet connection to work. Sure, you don't get some of the nice fancy features of a native app, but good lord you can't just write them off completely because you don't like them.
Check for `$.toString()`, not `$` to check for global jQuery. In this case, jQuery is not global, and `$` is defined only in the dev tools REPL itself. I'm not familiar enough with the code, but instances such as `o(e,"app/assets/modules/github/menu.js:196")` are likely references to file system assets from build system artifacts. Source maps do not actually need to be deployed to production per se, they only need to be visible to a relevant developer within their corporate network. 
You're my new hero :)
Umm. I'm not sure it works. Maybe I'm doing something wrong. Backreferences look borked. If you're on Windows, try Expresso from UltraPico. It's free and it's very detailed, which is what I needed to go from zero to useable.
Correcting mistakes is shit? Ok.
Suggestion: figure out and explain how Unicode works with regexps
Worked with Elm at a previous gig. I fell in love with a lot of aspects of the language's "structure" in applications but was annoyed by some of the details of the language (like Decoders and handling Index values for a List). So I'm really interested to check out Raj and see how it feels! Congrats btw, this is a really neat project.
Maybe switch up the engine, I think it defaults to PHP, not JS. 
Oh brother. It is his opinion, that's all. Even if it wasn't he could absolutely make the same comment in a non-toxic way. He wants to take the self-aggrandizing route over something so trivial, that's his problem. If he has a better regex, then he should send it over and I'll use that. 
Well, this is internet, not some British tea party. Not everyone is going to be polite.
Understand that. Not looking for a safe space but if you are going to be a dick and say the regex sucks, at least offer some improvement. We are in a programming sub after all.
([2-9]|[1-9]\d+)
These motives you keep ascribing to me are all in your head. Ironically, though, your instant and extreme defensiveness, and your total inability to provide evidence for your claims do actually have me wondering now whether this wasn't just a shoot-from-the-hip comment that doesn't really have anything to back it up. But, again, I am genuinely interested in knowing more about this, if there's something I need to look out for and be aware of in my day-to-day work. The complete absence of issues related to this on the react github repo, stack overflow, or anywhere else on the internet tells me 'no', but I'd honestly love to be shown otherwise so I can improve my knowledge and understanding, if it's lacking.
Looks awesome. How does it differ from HyperApp? 
101 also gives you code snippets for constructed exprs, which is really nice 
who else thinks they gonna forget it all in few weeks and will need to search the web for simplest regex. :D PS: Awesome article and I will try to put it to some use.
Good use of \\d, but that one would need to backtrack sometimes
Looks interesting - definitely want to work through the examples and dive into the source code as well!
need to learn how to do quite a few things to get the bot working as it should. random number generator for the q!roll, pick random response for inspirational quotes, fetching info from another site for the horoscope and weather commands too.
SO is only hard on shit noobs: if you make your question in an organized fashion _someone_ will answer it sooner or later :)
[https://www.reddit.com/r/javascript/comments/8svzjd/noobiest\_noob\_trying\_to\_make\_a\_chat\_bot\_for\_a/](https://www.reddit.com/r/javascript/comments/8svzjd/noobiest_noob_trying_to_make_a_chat_bot_for_a/) 
Raj is hopefully for you then. In October I wrote about my inspiration for Raj and the community Raj would grow in ["Why Raj"](https://jew.ski/why-raj/). Relevant to Decoders/Lists: &gt; [...] The reason not to use Elm is “I need to get things done.” The language’s constraints force you solve problems the right way, but this does not always align with the economics of a project. For example, for notably complex and difficult problems, you will find initial development is hampered by trying to fight to hack something together within Elm’s limitations. I definitely like Elm for certain things. Early this week I made a little [interest calculator](https://jew.ski/interest/) with it.
I'm not diverting anything. I wonder what potential problems do you see there. One of the approaches (not saying that is using that) is to use event bubbling for communication or a signal bus.
I try to follow HyperApp closely. When it first came out I was so anxious that something had beaten Raj to the market. They are pretty different and I think HyperApp 2.0 will widened the gap between the two. The biggest things are: 1) Raj is view-layer agnostic. I write a lot React and wanted to leverage that ecosystem, HyperApp is doing it's own baked in thing. For me as a maintainer, the state management problem was hard enough to solve so I'm happy to delegate to React, Preact, or other view libraries. 2) Raj has a huge value prop of forcing side-effects to the edges of your system. In HyperApp you have [async actions](https://github.com/hyperapp/hyperapp#asynchronous-actions) which I don't care for. In Raj the nasty async bits do not "infect" the business logic. This isolation is really powerful for understanding your system and testing because your `update` is synchronous and effects are inert until called by Raj (or called by tests). HyperApp's side-effect story I think is changing in 2.0 but I didn't care for the new approach either, if I recall correctly. I can't say much about larger HyperApp apps as I haven't looked at any to see how well they compose, but if they don't then that's another strength of Raj. I hope this helps.
Really helpful. I’m looking forward to trying it. 
Ah yeah, I must have skimmed through the IIFE/Module lectures too fast and made the learning curve nice and steep for myself. My JS in general was pretty rusty so I'm sure that didn't help either. 
Give a man a regex pattern and you'll solve his problem for a day. Teach a man regex and your give him problems for life.
Javascript has some weird but interesting parts that are applied in all these frameworks. Things like prototypal inheritance, first class functions, closures etc. I believe a solid understanding of javascript would go a long way in your career and also understanding frameworks. Also it cannot be achieved without practise.
We went through the exact same process about 4 years ago and went with angular because it seemed to have the best chance being around for more than a couple of years. It had the biggest following, the most momentum and the backing of Google. What could go wrong? Decades of man-hours later we're forced to acknowledge that we'll have to replace it all, and that's left a very bitter taste in my mouth.
&gt; These motives you keep ascribing to me are all in your head. i said nothing of your motives other than that the one you stated was not being reached by the behavior you keep doubling down on . &gt; But, again, I am genuinely interested in knowing more about this not enough to change your behavior have a nice day, again
/[\s\S]*/ is one way to do it but I'm pretty sure regular expressions are the wrong way to validate that your byte stream is valid Unicode. Sorry for the bile but you spend all day fixing the mistakes of people who make assumptions like everything is ASCII or all code points fit in one byte or all code points fit in 2 bytes or everyone uses the same date format or regexes are a good idea ever or everyone lives in the same time zone and you'll become a grumpy old man too. 
I didn't do tons of customization (added a couple plugins, changed some defaults and that's it) but I didn't run into any issues. You get full access to the webpack config: • supply your own config object which will be merged with the defaults • supply a config function, Vue CLI will pass it its webpack config and you can either directly mutate it or return a new one • use the webpack-chain API to adjust the config To make it less magic, you can also use `vue inspect` which prints out the exact config the CLI would use (sort of a dry run) so you're exactly in the know whether your config adjustments work. For me all these worked fine so far. :)
I have been following Elm for a while now and I am looking for it javascript version, more especially The Elm Architecture (TEA). Good job in implementing TEA in js, and impressively, in just 34 lines of codes. That's brilliant man! I tried it and it is really promising. I'm looking forward for Raj's development.
The thing they're talking about is things like encryption keys and general secrets. Instead of leaving it in memory, after you've used it, clean it up.... This basically means null out the value. This might look something like this: let secret = await get_secret() // do something with the secret secret = null // cleanup uhh, really rudimentary there. and actually in a lot of cases if you have functions and don't do anything with secret outside the function or block scope, it would be unnecessary as the var is already marked for gc. That side, the var is actually still in memory even if you null it out -- this is until v8's garbage collection cleans it up. You can't explicitly remove it from memory without some extra steps. You can be patient and let gc clean it up - but if memory swaps or you get a core dump or whatever, it'll be there. You can force garbage collection by exposing gc via node command line args (`node --expose-gc index.js), and invoking `global.gc()`. This is probably overkill - and gc isn't a trivial task - I wouldn't do it in a hot code path.... that's about it.
&gt; having types only prevents errors, only makes things easier. That is perfectly fine for you to say; but that is literally your opinion. I have a different opinion, whereby adding a field to an object I'm working with is "easier" if I don't have to also remember to update some type definition somewhere... which is both distracting and irritating when you're developing and changing things quickly. And if you address this by using `all` everywhere, what's the point? Anyway; if you want to learn more about the arguments for/against typescript (or type security in dynamic languages in general), google is your friend :)
Maybe with a typed array you could fill it with zeros. var a = new Int32Array(n) // fill a with secret... // then clear it a.fill(0)
The interview for any company worth working for is testing your ability to quickly learn new things and fit into their current culture more-so than your ability to memorize trivia, a good and thoroughly logical approach with an incorrect conclusion should rank you higher than a memorized, but not fully understood conclusion. The best resource to prepare you for a dev interview is Toastmasters International, juniors are a dime a dozen and the guys making the hiring decisions are likely to care more about a culture fit than how well you've memorized trivia. 
Looks good mate - I think this will be the framework-to-look-at this weekend.. .although at 34 lines... maybe it can't be called a framework :)
I like this because it doesn't wait for the gc. I'm thinking of filling the array with 0's then clean the array (marking it for the gc). This helps as the the offset for the data isn't consistently known as well. So the attacker can't poll that offset for the second the sensitive data is visible. 
?
Oh look, it's THAT stock image AGAIN
How does this line up with what TypeScript is already doing? Notably, they already use the at-sign syntax.
The term "framework" has a few meanings. The meaning that I think is most common is based on "inversion of control." A library is called by your code, a framework calls your code. In this regard, Raj is definitely a framework. It drives all state transitions and side-effects. Definitely take a look. I think you'll be pleasantly surprised just how powerful this small framework is.
Well I guess I should feel honored that you decided to spew today's bile on me. I'm not. It actually sucks to be talked down to by some random person on the internet. In any event, it's not gonna stop me from trying to be a positive helpful person.
This is so cool! It’s especially meaningful right now because I’ve been fighting with three.js all week on something far less complicated.
TypeScript implements the same spec, you just need to build your project with `experimentalDecorators` enabled. http://www.typescriptlang.org/docs/handbook/decorators.html
&gt; libraries like ... Lodash [You'll find `RegExp` under a lot of those things.](https://github.com/lodash/lodash/blob/158f38420b771e5816e4bac6a2b6990d0fb66d65/words.js#L3) 
Decorators are amazing
I have ~~four~~ react native option~~S~~ for you Would have liked to see electron or meteor as an option if they work on mobile...
All these things are related to the http protocol rather than fetch itself. So you need to learn that 
Craig's List still has a Perl stack. From the 2018 Perl Conference: &gt; Brad Lhotsky &gt; Brad hacks on Perl for Craigslist. He’s spent a career trying to replace himself with Perl scripts and still has way too much work to do! He’s trying to provide more people with the knowledge and curiosity to better themselves and advance their careers.
So having no knowledge of Redux, Elm or Raj, what’s the draw? I’m from a Node.js background mostly, how does this compare to Angular / Node? I read one of your articles about state management, but isn’t that a simple problem that can be handled through writing better code? No being a dick, just genuinely curious.
Why would I want ECMAscript decorators?
I only know basics of the GC system but I'm fairly certain this method would require GC too, and the new variable wouldn't just take the place of the old one's position in memory like it would in other languages. Nulling it would serve the same purpose, then you can force GC by following this: https://www.xarg.org/2016/06/forcing-garbage-collection-in-node-js-and-javascript/ source agreeing with me: https://stackoverflow.com/questions/23266676/is-there-a-way-to-reliably-delete-wipe-a-variable-i-e-key-password-in-javascr
Everything you could ever want to know https://fetch.spec.whatwg.org 
Yeah, it's oddly specific. Like, "want to use a regex _with_ capture groups, then I have just the thing for you!"
That all sounds amazing! It seems workable enough, I'm going to take a crack at migrating my current webpack-boilerplate to vue-cli. Thanks for the info and tips! Much appreciated.
I've found Mozilla's fetch documentation to be quite complete. What configuration properties do you feel aren't adequately addressed in the [Using Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) article? Or more importantly, what is it that you're trying to do that you haven't been able to figure out by reading the fetch documentation on MDN? If it's just HTTP stuff that you're not getting, as mohelgamal suggests, have you tried reading any of [HTTP documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP) on MDN? It's maybe a bit intimidating to just dive into, but it's easy enough to find specific topics. Just hit up Google with "http accept header" (or whatever you want to know about), and you'll almost always get the MDN link at the top of the list. 
This is a fair question I've certainly gotten a lot. The two hardest problems in building client applications (client as in client-server) are state management and side-effects. These two are a consequence of clients' and server's data drifting apart over time across the wire and also the complex user interactions that are commonplace in apps these days. I certainly write Node apps with Pug/Koa when I can get away with it, it's simpler when the interactivity is low. And when things need more responsiveness, Angular can get you where you need to go. What Elm and it's variants solve is really keeping complexity down. In Angular, Components can talk up/down to each other, data-bind, and call out to injected services any time. All of this interaction is async and there is a lot of internal state in each component. It is quite easy to end up with a plate of spaghetti, where "X calls Y but only once Z is mounted and Q is initialized." In the Elm architecture you have a single variable holding all the state, there's no disparity between components as your views and business logic are simple, synchronous functions. All asynchronous operations are pushed to the edge of the system. In Raj, the only way to move application state forward is dispatching messages. When something goes wrong, we can look to the exact message/point-in-time where it happened. This choke-point is a very powerful tool for not only debugging but also for testing. We don't need to mock server calls, we just give our plain JS functions plain-data messages and see if they return the correct state. Big Angular projects exist so it's possible to succeed without these designs. However, thinking in terms of "tech debt" which I'll define here as "the marginal cost of developing a new feature" the many foot-guns of Angular and others like it will eventually slow down progress as more and more pieces get interwoven, I'd give it an Ω(N\^2) growth complexity based on my experiences. Redux decouples things in a way that brings feature-cost down to O(N). This is because Redux has N reducers that wire together to form the state management system of the app. Raj has a feature cost of O(log N) because instead of a list of N, we deal in trees. The root program may call some subgraph of its children but each depth is only a O(1) cost. In terms of growth complexity, Raj I believe is optimal as most UIs tend to be tree shaped. As a project gets larger and larger and the problem space becomes intractable to a single person at a time. Better code is impossible if the underlying design encourages coupling, even if implicitly/unintended. There are concrete reasons to prefer isolated side-effects, synchronous business logic, separated concerns, and easily testable code. I hope this train of thought didn't come off as too lofty. Growth complexity, in particular, is important to me as someone who's come to save quite a few projects and it's how I've come to think of these differences because at the end of the day it is about delivering business value. I hope this helps and I'm sorry this is skewed towards Raj, I just know that best.
If the numbers encode something non-numeric, say some text or an object, or deserialize in memory at any point then it means at some point that data will live on the heap and live by heap rules. Even if you are not assigning the value to a variable, it will exist in memory as a string (or what-have-you) and will be subject to GC rules like everything else. Very short strings *may* exist on the stack... possibly, but to know for sure you would need to know how the engine was implementing memory allocation under the hood. If you are looking to build a secure memory application (one that securely manages RAM), JS is absolutely not a candidate.
Nicely written article, very comprehensive and puts everything in context.
Depending on your background, you might look into the (free) [https://www.theodinproject.com/](https://www.theodinproject.com/) Also, if you have any specific questions you are always welcome to DM me.
Thanks! I was also having a hard time learning about headers and http protocol stuff. I don’t remember seeing this on MDN even though I basically started learning programming with MDN Tutorials. 
Is [this](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) the MDN page you're referring to? It explains a fair bit and lists what's available, at least enough to google for more in-depth info.
Thanks for sharing. :) 
That syntax is borrowed from Python/Java
For example one of the topics that MDN page glosses over is credentials. What exactly are credentials? I think mohelgamal is right though - should learn about the http protocol and then learn fetch.
&gt; What configuration properties do you feel aren't adequately addressed in the Using Fetch `credentials: 'same-origin'` for example
neat so are decorators comming to js after all? I thought they were already stage 3 and then they pushed it back
Yeah that's right. A lot of the parameters are shared with other tools like jQuery's ajax methods, so you might have some luck reading docs on that.
Java annotations and Python decorators are not remotely the same thing.
Thanks for the feedback. I've rarely had cause to worry about the performance of my regexes, so this didn't occur to me before. I think in this case there is only a single character being backtracked, and at most once per input. I prefer the readability gained by shorter and mutually exclusive possibilities (until there is a performance-related problem, anyways). 
Alright Java's a little different, I was remembering the `@Override` syntax which is the same.
Decorators are great, if you feel like using them to build interactive things but you think Angular with typescript is too much definitely check Strudel.js (@) https://strudeljs.org 
To be able to mutate functions or classes.
RemineMe! 3 days
[Request.credentials](https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials)
Includes authentication cookies with the request. Valid options are `omit` (default, according to the [fetch page on GitHub](https://github.github.io/fetch/)), `same-origin` (send credentials if request and calling script are on the same domain), and `include` (send credentials regardless of whether request and calling script are on different domains).
I can't tell if this project is actually serious.
Interesting. Doesn't look like users can reach that page from the [MDN HTTP docs](https://developer.mozilla.org/en-US/docs/Web/HTTP) which is where I would have thought it should have been.
Yeah. I still don't get it.
&gt; is the shit I really have to get used to it to be a positive thing (German here). At first I was like "What? Why? I never felt that it is shit or something" :D
I don't lake the inconsistencies in the optional chaining syntax: Without optional chaining: module.object['function-with-string-name']() With optional chaining: module?.object?.['function-with-string-name']?.() Where it \*should\* be: module?.object?['function-with-string-name']?() The extra dots are superfluous. I imagine this syntax is required because it conflicts with the ternary operator? My preferred version does look a little busy, but I would just use dot notation: module ?.object ?['function-with-string-name'] ?()
Pipeline operator looks like it's similar to method chaining (return .this from each method).
Hey! there's an idea! a todo list!
&gt;We don't need to mock server calls, we just give our plain JS functions plain-data messages and see if they return the correct state Okay. I get what your saying, but I'm still not convinced that what you're doing isn't comparable to keeping a consistent state subscription in an Angular application. For example: I have an application that watches the state in the root app component. `If (logged in)` `do some stuff.` `if not logged in` `do some other stuff.` How is that any different than keeping the state consistent in Raj? I understand your talk about overhead, that much makes sense. But it also doesn't at the same time, because in Angular, you have a single parent component. Who has children, and whose children have children components. Similar to what you're talking about in your O(1) analysis, if I understood it correctly. It's single purpose programming at that point, if I understood you correctly. This function or class, or service should do one thing, and one thing only. Node.js is synchronous because javascript is single threaded, so how does Raj have the upper hand here? Overall, I'm just still confused about what Raj brings to the table that Angular/Node doesn't. Any application that reaches a large scale is going to be confusing to navigate by any one person, and I'm sure the same can be said about Raj. It just comes down to the programmer who creates it. They have to be diligent about separating concerns. About naming conventions, about moving business logic around, so that one error will not disrupt the entire flow of the application. 
You and me both, for now.
You could store the tasks in localStorage to solve the issue that there's no server to save the data at.
To be fair having omit be the default is probably unintuitive even if it is more slightly secure... 
Isn't a tad disingenuous to claim being "tiny" when most of the functionality is offloaded to other packages?
man I dunno what's with Japanese and their obsession with jQuery. most of the awesome websites made by Japanese company I see in Awwwards are usually powered by jQuery. animation, routing, data fetching etc. and now a to-do list app with jQuery? like are you serious.
Why do people downvote perfectly valid questions?
Sometimes you wanna make a big dinner, sometimes you just wanna heat somethin in the microwaves. You’re just as happy either way.
I wish the article started with code snippets of the new feature before diving into an elaborate explanation.
Hi, It's really great to leverage ELM architecture which is mostly great. Unfortunately I cannot see a lot of useful examples for the app. I think instead of this export default function effect (dispatch) { setTimeout(() =&gt; dispatch('beep'), 1000) } It would be better to show something useful: * Fetching data on button click. * Handling forms * Handling routing A good example of such documentation is react docs page. https://reactjs.org/docs/hello-world.html Cheers 
And I find the fact that it has no builtin support for query string parameter encoding to be shocking ...
You can use either for both. But I'd recommend sticking to just one for both sides, makes your pipelines a lot easier. One benefit Jest has is snapshotting out of the box, but you can get libraries to do that with Mocha.
💩
Hey, you're an idiot. Stop giving bad advice to make yourself feel good. Greetings, the Internet.
In the name of irony, I hope you're downvoted to oblivion :D
Because that question is the entire point of the whole article. It's not "valid", they need to read the article before going to the comments. 
Good work on this. I think, though, that the tutorial covers a bit too much, especially that it's supposed to be all about decorators. Correct me if I'm wrong, but aren't decorators just sugar syntax for functions that modify the target and return it back? (aka HOC in react?)
For examples in a great many frameworks (plus some non-framework examples), both direct JS and transpiled, there is always the venerable http://todomvc.com/
You can check out this course "[JavaScript TodoList](https://honest-recommendations.com/recommends/javascript-todolist/)". It's teaching you how to build fully functional todo list.
I wasn't implying otherwyse tho. I'm just saying that parsing &gt;&gt; regexing for majority of use-cases. Sentence to words falls under my "small enough" case, but even that particular case can be expressed with parsing, albeit not as tersely. Conversely, you wouldn't regex a CSV, would you, just like you wouldn't steal a policeman's hat :) Essentially, regular expressions should be used under specific constraints: * The amount of data you're extracting is significantly smaller than the string you're searching in. * The language/format you're extracting from is more/less [regular](https://en.wikipedia.org/wiki/Regular_language). * Conversely, the string you're searching in is relatively small and uncomplicated vis-a-vis the data you're extracting. In most other cases, you've aimed at your foot, chambered the round and removed the safety. It might not go off, but generally, parsing is what you should have used.
JS is my first language, so I'm probably somewhat biased :-) I also have spent a fair amount of time in a few OO languages. You can use OOP architecture concepts in JS, though some true OOP features are obviously missing, and the language itself definitely won't prevent you from making stupid mistakes. Solid OOP design skills will still help you to build maintainable architectures in JS, though they will be different than a true OO language. The best JS architectures that I've seen or used are built around functional programming concepts, rather than OOP - not 'pure' functional programming, but thinking along those lines - combined with a clear separation of concerns and clean coding habits TypeScript and other 'compile to js' languages can be helpful, but in many ways I feel that they just add more complexity to the development process and to the final code
&gt;How is information hiding implemented in ES6 it's possible, but idiomatically, information hiding isn't really a big deal in js and i don't think it's worth the trouble. having said that, create a closure inside a scope that is inaccessible outside the scope: const privateFunction = () =&gt; { /* foo */ }; export default class Foo { public publicFunction() { privateFunction(); // closure inaccessible to code using class Foo } } I answered your first question before I read your second and third question. Yeah, definitely use [TypeScript.]https://www.typescriptlang.org/) It's pretty close to what you're looking for. You may not be be following the exact same route when architecting code, but you'll wind up in nearly the same place. I also used AS3 and also thought it was a pretty good look into what ecma could be, and I think TypeScript is fantastic for communicating contracts and adding stronger enforcement. It will never be quite as powerful for architecting as a statically typed language, but it takes JavaScript and elevates it to about 90% of the way there, which is good enough in my experience.
&gt; How is information hiding implemented in ES6? There is no native support for private and protected properties with ES6 classes. Do I consider adding them? If not, how do I architect my programs without such a fundamental OOP feature? You can't in ES6, not natively. And I would ask you: Why do you think you need it? &gt; I loved abstract classes/interfaces. They enforced contracts on objects so I could create reusable code to operate on them. I understand that JavaScript is duck-typed, but in the absence of interfaces, I can't architect my software like I used to. So how does JavaScript want to think about my software? At what point, and using what criteria, should I consider using a library/language that gives me those features and transpiles? You can use TypeScript. Nothing wrong with it. That's the beauty of the JS landscape: you basically design your own programming language and cherrypick the features you like. Want strong typing: TypeScript. Want ES7+ features: Babel. Both come with a lot of optional configuration. &gt; For a few years, I coded in ActionScript 3 and loved it. The language may have a bad rep, but it worked just fine and the code I wrote is easy to read and maintain 8 years on. I'm now having to write a very similar program in JavaScript and the first thing that comes to mind is -- how do I use JS to create something better? Define "better". Once you learn the language I think you'll find it's hard to imagine anything you cannot do with it; like most other programming languages. &gt; How do I know if parts of JS are far stronger, or far suited, to what I'm writing? Should I consider TypeScript since it's close to AS? It was easier to understand the jump from C++ to Java -- but it's not the same here even though both AS and JS are ECMAScript based. Just use TypeScript, it's a fun addition for people like you. It makes the entire JS thing feel much more comfortable to work with. Just one piece of advice: Don't configure it to be too strict. I prefer a TS setup where it's fully optional; it should feel like a progressive enhancement tool. Because often (very, very often) you'll find that loosely typed JS is perfectly fine for many things.
&gt; the language itself definitely won't prevent you from making stupid mistakes. Can you explain this more?
1. Closures. Modules. I know sometimes it's _not enough_ or not at the level you'd like to. The answer is to assume this is so. I answer the particular question but the answer is generic, really. The different language characteristics give you different capabilities. You either assume the new situation or try to work around it. My opinion is that it is -almost always- better to assume the situation. It is not free (effortless), but it tends to be a better approach. 2. You don't have interfaces as such in JS, right. But that doesn't mean can't define what your interfaces are. What it means is only that the compiler/language won't give you tools to _enforce the implementation of an interface_. So... As a first/simpler approach, you can still _think_ about interfaces in design and creation. You ask at what point would you introduce a tool to _enforce/check_ implementation of a declared interface. That answer is, sorry, _when you need it_. Hey, I said sorry ;) But really, that's the answer: when you need it. Do you encounter the problem that someone tries to produce an entity that should conform to an interface but they don't? Is it a one-off problem or is it becoming a recurring situation? Why does it happen? Answer those and you'll have the answer to your original question: You should introduce such a tool when there _is_ a problem and the situation indicates that the benefits of such a tool will solve the problem better than other approaches and overweighting the cost of introducing it. (Going back to the first answer, my advice on this would be, of course, that you probably shouldn't need it. But I understand that different situations may advise differently) 3. Well, yes, you might want to consider TypeScript. Just do what works best for you. The jump from C++ to Java is, mostly, _restrictive_. The approach is similar, but you stop doing a bunch of things. TypeScript will give you a typing system that may be closer to what you're accustomed, so, it may make sense to use TS if you really feel you need that. Other than that, you'll still need to make some changes in the way you think. My personal opinion is that you _might_ benefit if you tried a more _functional_ approach. Or you might not. It really depends a lot on you. The main difficulty I see is you defining yourself as "a classical OOP programmer". I may be wrong -apologies if I am- but it seems to reflect a _strongish_ inclination to seeing one particular approach as either "the correct way" or at least "the way I know how to do it". OOP is a tool, just that. Not only that, _the particular flavour of OOP you are accustomed to_ is just that, one specific way to use one particular tool. So, thinking about this, I'll adjust my previous advice. Oh, do try to learn some FP, sure. But do it not as an end in itself but as a way of interiorizing that al of those approaches are just tools. Different tools with particular solutions to similar problems. Each with their benefits and their costs. Then _transcend_ these approaches. Understand the fundamental principles and goals that all of them share, and how each of these approaches tries to achieve those goals and serve those principles.
You should import exif.js as a module in your project
Woot! an easy to follow purposeful code exercise in react native! Thanks!!!
&gt; I think Booking used some Perl, dunno if they moved on since. I have it on good authority that at least some of the core backend parts are still Perl. I don't know the details tho. It's generally become a sort of a refuge for neckbeardy types, who still really love the language. In general case it was usually replaced with Python (system stuff), PHP and Ruby (web stuff). On the other hand the Perl codebases are not going anywhere and open-source nature of the ecosystem and emergence of the microservice thing acts like life-support for quite a lot of "legacy" codebases in much more passe technologies than Perl. My own company has a huge Perl codebase that's still being developed, and even improved, modernized with newer idioms etc. but also, a large part of work on that product is building around and atop of it in other technologies. I don't know if Perl 6 has made any traction, but I suppose it was a bigger schism than ES6+ and Python 3 were, and with a worse migration story, which probably didn't help much.
But isn't that already possible?
I meant that with the lack of type safety, private/protected members, etc, its very easy to mutate data in unexpected ways, or to introduce strange errors due to type coercion. You can make the same mistakes in an OO language, but JS makes it easier JavaScript's flexibility also makes it very powerful though!
Jest comes with pretty much everything you need. It's a test runner, it has mocks, coverage reports etc. The config is a bit simpler when you're getting started, so it's a good choice. I'd start with Jest and only add things when you come across a problem, some things are more difficult to test and in those cases it might make sense to add another library to help you out but don't do that prematurely. Testing the DOM in a node environment poses a few challenges depending on your setup but you can solve those problems as you come across them, there are plugins and / or solutions for most problems you will encounter.
Github's fetch is a polyfill and thus cannot do everything https://github.com/github/fetch/pull/56#issuecomment-68835992
Yes decorators simply wrap function calls allowing you to do something before/after the original function call. There's nothing special about decarators that makes this a must have ES feature imho. I really like decorators though, but I'm not sure I like them in ES. Since I see little value only confusion and multiple ways to achieve the same which makes the language more obtruse.
How does this actually make it any easier for me when I want one part of the app to share state with a different part? To me the proposed solution is similar to how react handles things when you have no state management library. The problem that I see is the lack of a built in way to access state in a child without the parent component having to pass it down, which ultimately means that I am just as good using only what React offers. 
I'll try to address the points you made: * Private properties, are by default prefixed with an underscore in JavaScript. There is nothing physically stopping somebody from using them, but it is well known these methods should only be used if you know what you're doing. Essentially, if you really wanted to, you could go into your source files and change the property to public, but you probably shouldn't. This is essentially the same thing. * If you really want to, you can use closures for information hiding. It creates a local scope that can be accessed after the function has returned. However, if you define functions in this closure, you'll use additional memory for each function object. I also believe the main JS engines are slower to access closures than properties. This is a trade off which you'll have to decide how to approach. * Because JavaScript is duck typed, any function you write is going to be polymorphic. It will just call the named methods. This means you just have to be careful about using generic names in your classes, unless that's the exact behavior that you want. Avoid "add" and "get" and such things. Transpilers will often have a feature that will check types in these scenarios as well if that's what you want. * If I really want to enforce a contract, I can use this clever little assert code, which will completely disappear during dead code elimination if I run my code through closure compiler. I'm sure there are other creative ways to achieve this. // usage: assert (() =&gt; predicate); // redefine NDEBUG during final compilation /** @define {boolean} */ var NDEBUG = false; var assert = NDEBUG === true ? () =&gt; {} : test =&gt; { if (test()) { return; } console.assert (false, test.toString()); console.trace(); }; * Javascript, supports all the OOP features that you've used before, but the difference is, it doesn't require the type checking and safety guarantees that other languages have. For example, abstract classes and interfaces, don't even have to be mentioned in the code. You can just write your methods, and have JavaScript attempt to run it with duck typing. It certainly feels like you're exposed with the lack of type safety, but to be completely honest in practice, It's not very often I get a bug that could have been prevented by such a system, and my code is a lot less verbose. * Use functional programming. Entire functions complete with arguments can be passed to other functions and used to modify the behavior completely. This allows you to truly not have to repeat yourself anywhere. That means even *classes or namespaces themselves* are first class objects and passed as arguments to other functions/methods. Programming like this has reduced my error count more than any other practice. I could probably ramble like this for ages, but that's probably a good start.
That's great! Congratulations on the job, that's really awesome. I'm glad to hear my comment was useful to you. Stay awesome, keep learning and have fun. ✌️
Wow, no one's ever made a todo list in Javascript before
It is not complicated. npm install -g typescript npm install -g @angular/cli ng new my-project cd my-project ng serve
*Definitely* use Typescript. It provides type safety and private/protected for your class methods.
I don't understand the trendy jquery hate. It's a library that simplifies a lot of things and uniforms many browser specific functions. We use libraries for quality of life enhancements all the time, yet jquery in particular gets a lot of hate. 
Yes, it’s just cleaner syntax, especially if you want to change the object properties (writeable, etc) on a function
Important to note that this a guide for the legacy decorators spec, the spec that is at stage 2 [works a bit differently](https://github.com/tc39/proposal-decorators/blob/master/METAPROGRAMMING.md) and there currently isn't a babel transform for it ([but it's being worked on](https://github.com/babel/babel/pull/7976)).
fetch is just a low-level API for sending requests. You can use other APIs like [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) or a higher-level API.
You speak as if Javascript isnt a **real** OOP language. It is. Contracts and private methods don't make OOP, Objects make OOP. Having said so the main difference between JS and typical OOP is that in JS we avoid the incredibly common pattern of single method objects. In almost every situation where you would pass an object in Java or C++ where that object has only one relevant method, the JS way is to pass a function object instead. Other than that, you already got few good answers but I'll go over some concepts. Private members: In JS we use the phrase "we are all consenting adults" meaning there is no need to **enforce** privacy. We use a few conventions to *suggest* it instead. If you are writing a module. Private elements are those you aren't exporting. Inside objects, members that users shouldn't bother with are prefixed with a "_", just like in Python. Use getters for read only members. In other words if users see an object like: { _completed: false, get isCompleted(){ return this._completed } } They aren't going to use _completed directly so you don't have to worry. Javascript makes closures extremely easy. You can write objects like this: function factoryFunction(){ var privateMember return { publicMethod(){ return privateMember } } } In that example `privateMember` is inaccessible outside code, but accessible to methods of that object. Also be aware that each "instance" gets its own `privateMember` just in case you were expecting otherwise. TypeScript is a valid option. It's good for teams. Specially good for large teams or teams with poor communication skills. But if you find that you *absolutely* can't live without TypeScript you may be having a problem of either over-engineering or just bad teammates.
I'm gonna go ahead and double down on the whole, this community sucks thing. 
Typescript will be your friend. It's essentially a OO superset that constructs to JS. I have a colleague who came from a Java background and he loves [Typescript](https://www.typescriptlang.org/). 
Disagree. JQuery was meant for a few sprinklings here and there to get buttons working or have a dropdown or something. When you start building an app, like an interactive todo list, you've left jQuery land. Yes you could still build it with jQuery, but you'll be killing yourself just to not let your code spaghetti out everywhere.
What did you expect? A participation prize?
&gt; though they will be different than a true OO language What part of ES is not a true Object Oriented language? Even the primitives in ES are objects (or can act like it at least). If you're comparing to C++ then there is a ton more things in C++ you can do that is decidedly not object oriented than in ES.
You should handle that console log inside second .then clause. That's where data variable is available. 
I don't really expect anything, but after your comments I will lower the bar further. Good day.
jQuery was not meant for just a few sprinklings here and there, that's a ridiculous claim with no basis in reality. jQuery was meant to make it easier to work with the DOM elements and events in JavaScript. It's concision and ability to be sprinkled here and there was just a side-effect of the brilliant ways in which it went about achieving these goals. There is nothing about jQuery that occludes the possibility of using it to develop complete web apps. 
You're correct. I meant that JS/ES is not in the same vein as some class based OO languages. It is OO, but different
Wow, no one's ever made this exact response before There's a reason there are so many to-do list examples out there. 
Yep, they're basically syntactic sugar over higher-order functions.
You could use an API to do this but since you are new and it's just as easy I would suggest practicing this with plain JS. It would consist of some DOM manipulation and JS objects. 1. HTML would contain a defined space for the meme/gif 2. The HTML would contain a button that has a click handler attached to it. 3. Your JS would contain an array of objects with your meme/gif information. 4. You could then generate a random meme/gif using the click handler and some type of math.random script. Good luck! This is a great project to learn from!
You should console.log the data on line 8, and then maybe even one on line 23 (although it would be line 24 once you add the one on line 8). I don't see any issue with your code, but I'm not familiar with pg-promises specifically, just regular promises.
React. Give Vue a look too. Angular is a big opinionated application framework. React is a view library for creating reactive components. There is certainly value in learning Angular, but React will come easier and is a good introduction to modern web concepts like state management and routing. Vue is good for that too.
low level comedy ^^^ 
I think he means that most OO is class-based, whereas js is prototype-based.
React is only for the view side of things. Make sure you understand that part of it. React is for UI only. All the application parts of your app, the actually meat of your app, should have nothing to do with React. That part of it can be built in Javascript, PHP, C++, Ruby.. whatever you want. It also depends where the "meat" of the app will reside. Are you intending on building a client-server architecture? is it completely standalone application? etc.
AngularJS is the old angular 1.x version of the framework. Angular is the 2+ version of it. And they are 100% different. Honestly the use of the same name just opens the door to confusion. Only some of the basic core concepts are transferable between them, the syntax is 100% different.
I was thinking that the variable that was assigned to get_result would pick up the return from get_address() function and I would be able to use that result as a variable. The thing is that I don't need to output the result (console.log()) but I need to somehow get it in a variable and use it anywhere in the code
From the release notes: &gt;An a-la-carte approach with recommended libraries for common things as opposed to batteries included. Raj, the package, solves two problems: * State management: it holds the state of the app and transition it from one state to another. * Side-effects: it calls side-effects provided to it. It's the foundation for everything that will happen in your app. Being able to offload functionality to libraries instead of needing them interwoven into the framework is a benefit. The community can invent new ways to do things, better and faster. People who don't need subscriptions, don't need `raj-subscription`. People with only a singe page don't need `raj-spa`. People who don't use React don't need `raj-react`. The framework is about designing a good architecture, with that the rest can and should be libraries. For an app the does need subscriptions, is a multi-page app, and uses P/React, you will be adding more libraries to your project. Each solves a specific problem so it does not make sense to always include them in the framework. I'll also point out, though it does not necessarily need to be the case, the packages I have mentioned are small: `raj-react` is 29, `raj-subscription` is 94, and `raj-spa` is 196 lines of source code. Thank you for asking, I certainly don't want to mislead people. I don't mean "framework" in a kitchen sink sense, I mean a "framework" where it calls your code (inversion of control) and helps you build a well designed system.
Yes but as I mentioned in the reply on the user above me (RustinWolf), I don't need to just output the result from the query. I need to store it in a variable and be able to use it anywhere in the code
It is serious, I have spent quite a lot of time working on this and a few of us (hopefully more soon) really like it. If you have specific concerns or questions please ask.
Although I "learned" Java first, I first flourished in JS, so I'm kind of going the other direction. I use both languages on a daily basis, but am happier in JS. I would recommend you to some of the talks by Rich Hickey about Clojure (which is, of course, very different - but has more in common than might appear), and maybe to some late talks by Douglas Crockford. The way I approach it is: Data is all data, is just objects, and is probably dirty anyway. (Almost any time you set up requirements about data, there's going to need to be an exception: "We don't have this person's ID#, but we need to just push it in anyway. I know this is supposed to have a state, but we need a Canadian province here.") Create data objects with literals on the fly, and process them tolerantly with functions. In JS, I haven't yet ever seen a need for a class - except when some library or framework I was using called for it. I'm actually in kind of the opposite boat as you - when programming in Java, I think, "Ok, this functionality has to be wrapped in a class to make it work - Let me think of it as a closure that partially applies all its methods..." LOL • Information hiding is through closures. Like, a counter that you could get but not set its value could be: ```function makeCounter () { let count = 0 return { incrementAndGet() { count += 1; return count; } } }``` As others have said though - I wouldn't use this as a "constructor" for a mess of objects: The internal method is defined for every instance rather once for all. Generally, though, if you're doing state management or business operations - you don't need a thousand copies; and if you're looking at data - you don't need methods; you can just manipulate the data with functions. Functions can be pre-bound with their arguments - so make use of that if it's helpful. Say I have some UI methods that I want to reuse, but take a lot of arguments for the particular widget they should be used with: I can do something like `let onClick = common.onClick.bind(null, controller, routeData)` and then just `onClick(event)` when I need to use it - the controller and routeData are already attached. (The first null is what `this` should be - which I tend not to use.)
get_adress returns owner, but that's still inside .then. It's not available outside because at runtime it evaluates to undefined (that's what promise is, you get results sometime later)
The example is contrived, I really just wanted to show the minimal effect that would dispatch multiple messages. The view and user interaction generally isn't dispatching multiple messages because on every message change the view is updated and passed a dispatch function, potentially a brand new one. Documentation is definitely an on-going effort. My writing is very dense if not kept in check and I certainly want to make these ideas more and more accessible to newcomers as we go forward.
&gt; How is information hiding implemented in ES6? Well, in modules - any non exported functions / variables - are inaccessible outside of the module, so you can think of them as private. &gt; I loved abstract classes/interfaces. Consider using something like TypeScript that transpiles down to Javascript. Then again, think about why you want to use abstract classes and interfaces - what is the problem you are trying to solve? And is there an alternative way to do this that leverages Javascript better? &gt; how do I use JS to create something better? Without knowing the program, its hard to say what you need to use to leverage it. One thing I would recommend is reading up on functional programming - its very very different to OOP, but comes with its own advantages. https://github.com/MostlyAdequate/mostly-adequate-guide 
Crying is typically done by creating a cropping rectangle via some docs and CSS, and attaching handlers to mouse moves to grab it's position relative to the image. A crop ends up being a map of coordinates where the values are a percentage of the image width/height. ```js let crop = { x: number, // offset of crop from the left side y: number, // offset of crop from the top w: number, // amount of width being kept h: number, // amount of height being kept }; ``` These numbers are usually done between 0-1 so they are relative to the scale of the image. You may have a 1000x1000 image being displayed at 100x100, so an offset of 25px becomes 25/100 = 0.25. that can be scaled up using the true height. Have a look at using this lib for all this: https://github.com/fengyuanchen/cropperjs
Coming from a mainly OOP background myself I say you definitely need Typescript. It also allows you to set strictness of type safety as needed. I sometimes use *any* types at the beginning and set a more specific type when my logic is close to solidified.
After months of experience, many tutorials, reading lots of documents and experimenting on production. My review: This is the most overrated , over-engineered, under-developed tool. Fuck you for stealing my time and happiness. 
Thanks , i will consider vue too
If you do understand, I can't tell from that analogy. How I've heard the backpack used is for describing how closures hold on to variables that are within an accessible parent scope. That would be where the closure is the student, and all variables in any parent scope the function has access to are put into the backpack. Where ever the student goes (returned from a function, sent to addEventListener as a callback, etc) the backpack goes with them and at any point in time when called on, the student can reach in the backpack and get to those variables. The hierarchy of those variables are mostly inconsequential except when there's a potential collision at which point you'll want to pick the closest variable. But this would mean only a single list of nesting vs a tree of multiple objects like a lunchbox and a folder. It's more like a single folder that contains pages and potentially another folder which itself can contains more pages and yet another folder and so on (until you get to the global folder). When looking for a variable you stop at the first folder that has it. The backpack analogy isn't the best because variables aren't copied into closures, they're referenced by closures. So if two closures (students) refer to the same parent scope variable, they need that variable to be the same in each of their backpacks. We can fix this by bringing the student into the future and instead giving them a backpack, we give them a PDA. But, due to budget restraints, the teacher (or school, really) only has one Office 360 account to share with the entire class so everyone logs in using the same credentials to access their files. Though everyone is accessing the same files, students' PDAs will link to specific folders after logging in rather than everyone having access to them all. Some students might access the same folders, for example if they share the same homeroom, but most likely the folders will be different (homerooms tend to be small in this school). Now, if two students (closures) need to access the same document (variable) in a folder (scope), they'll be able to, and if one changes that document (variable), the other one will see that change too.
Thanks , good to know
I was thinking of using React as UI front -end , and javascript for logic and back-end of an app if it possible 
You should not think in JavaScript. You should go and think in TypeScript. It won't answer all of your questions but at least won't make you question your sanity.
Well then you're using javascript for both front-end and back-end. You're backend will then require a web-framework. Something like [Restify](http://restify.com/) or one of the umpteenth frameworks and platforms available to handle your backend. 
Thank you, i will check it out 
##r/webdev --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/853qg2/ignore_list/)
JS was designed to be sprinkled into mostly static pages, for a little desired interactivity. JQuery was designed to make sure it worked in all browsers and could be written succinctly, back when JS had do `querySelector` and the browser wars left spec compliance in tatters. Those was their stated purposes; but, sure, how they came to be used is wholly different. &gt; There is nothing about jQuery that occludes the possibility of using it to develop complete web apps. The possibility? Sure. Hell, use vanilla.js, if you want. But is it a good idea? With today's choices, not really. It's like using an axe to cut down a tree. You *could* do it, but it's 2018 and we have chainsaws now. So instead of doing a bunch of extra work and likely making much more of a mess, why not get a framework involved? Even a simple thing like a to-do app is going to have to create new DOM elements and then initialize their interactivity. It's going to want some kind of undo/redo button, and need to load and persist todos. Most of the heavy lifting is gonna be done with CSS, but that's enough where I'd rather use Vue or Preact over jQuery, no doubt in my mind.
Thank you. I used Mithril in recent project, it's so comfortable and compact for SPA as you said, no need any other framework. Documents are great too. Thank Mithril and contributors.
I appreciate your interest, I am sorry to see you getting down voted. Some things I'll highlight: &gt; Node.js is synchronous because javascript is single threaded. Node is single threaded but code via callbacks/promises is executed asynchronously. Just as \`fs.readFile\` is non-blocking, so are AJAX calls and other asynchronous tasks that happen in the browser. In Node, async is less a problem because there much less drift from the source of truth, usually the database, compared to a web app that may be running in someone's browser all day. &gt;I have never been a fan of logic like this, where the view and business logic are one in the same. I must have misspoke, this is certainly not the case. The business logic is responsible for state transitions. The view is a function of the current state that returns most often a representation of what the HTML should look like. These things are decoupled, and can be tested independently in Raj. &gt;It's because the person(s) who are new, inexperienced, or simply don't care are creating it If everyone were senior, experienced, and really cared, I would still recommend Raj. I've seen a huge amount of man hours wasted by brilliant developers fighting bad paradigms. I think if it more as, "why should I have to think at an expert level to be successful?" "Why do I have to keep so much of the system in my head to make the correct choices in the small day-to-day?" There's a point where no one is expert enough and you cannot manage it in your head. Picking the right paradigm can made the job easier for beginners and experts alike.
The thing is, with a closure it actually only has access to the things you pass to the closure. I think you are correct with the Metafor, but doing this with code is easier: var backpack = function (){ var folder = function(){ var file1 = function(){ } var file2 = function(){ } } var pen = function() { } var lunchbox = function(){ var apple = function (){ } var sandwich = function (){ var peanutbutter = function (){ } var jam = function (){ } } var juice = function () { } } } I would recommend just putting console.logs every where and test your hypothesis. Also a nice to read is this post: https://www.google.nl/amp/s/amp.reddit.com/r/csELI5/comments/1q1eh8/eli5_closures/ Best!
I always say: a closure is a function that doesn’t lose the connection to the variables that existed at its birth place.
How does it feel to lose your hopes?
You can do that; you just have to ensure it's set before you continue. I don't know what code you have that relies on the variable, but it should be wrapped into a function and then called once the variable is set. You can't just have it "inline," because it will continue on and not wait for the variable. I also highly recommend using async/await. For instance: // I'll be using ES6 for my code logResult(); function async logResult() { await result = get_result(db, get_address, address); // code to use result } 
&gt;you'll be killing yourself just to not let your code spaghetti out everywhere You might be doing it wrong. I don't have that issue myself. Especially with templating libraries.
Fetch isn’t part of the HTTP protocol. It is a browser technology.
Here ya go! html &lt;button class="btn--get-meme" style="display: block;"&gt;Get Meme&lt;/button&gt; &lt;img src="" class="img--meme" style="width: 256px;"&gt; js fetch("https://api.imgflip.com/get_memes") .then(res =&gt; res.json()) .then(json =&gt; { let memesArray = (json.data &amp;&amp; json.data.memes) || [{ url: "no memes :(" }]; console.log(memesArray); const btnGetMeme = document.querySelector(".btn--get-meme"); const imgMeme = document.querySelector(".img--meme"); function handleGetMeme() { imgMeme.src = memesArray[Math.floor(Math.random() * memesArray.length)].url; } btnGetMeme.addEventListener("click", handleGetMeme); }); ^ that code will fetch/get an array of memes from an api endpoint and store them in memory in an array; then, when you click the button, it will assign an url src to the img element on the page... effectively showing the user a new meme randomly selected from the array of memes please let me know what questions you have in trying to understand/use the code!
&gt;comparing JS library to an MVC framework Seems like you're a bit in the weeds here.
No problems! I’m glad you found your way to the framework and I have no doubt your project is running like a finely tuned machine. I just completed my 6th project with Mithril and it still stands as the leader in the JS world for me. There are also some great things to happen in future releases. Happy coding. M() 
To reinforce what others have said, absolutely use TypeScript. I haven't read everything others have said so I'm sorry if the following is redundant... Also, JS has gotten closer to AS3 with ES6 classes (and TypeScript), so you should feel pretty familiar with that. One thing you'll still have to be careful of context binding. AS3 bound methods to instances whereas with JS, you're not getting that for free. More info: https://github.com/Microsoft/TypeScript/wiki/'this'-in-TypeScript Since you mentioned information hiding, while TypeScript supports a `private` keyword, this is a compile-time attribute for _public_ members. So there is no hiding per se. There also isn't any protection against collisions. So if you have a similarly named private in both a superclass and a subclass, they'll be the same variable. Typescript will actually call you out on this, but if not using TypeScript, it can be a problem (and it's good TS does this because it could easily be assumed two privates from two different classes in the inheritance chain wouldn't clash, but they do given that they're implemented as public members). There is an ECMAscript proposal for privates. I believe it's in stage 3 right now, so it's up there, but not quite finished and still subject to change. It's implementation basically matches the WeakMap approach which is something you can do to simulate private members. I can dig up a link for that... http://2ality.com/2016/01/private-data-classes.html #3 in that list ^ (I'm partial to #4 myself)
No worries! I think adding such real word yet simple stuff in something like tutorial section would definitely help to keep your project attractive to the user. Firstly I saw great looking homepage and just waiting to some great examples solving real problems.
&gt; I want to understand the mental models I should adopt for JavaScript and how they're different from those other "classical" languages. Download TypeScript and keep thinking about it like Java. You'll pick up the differences over time. Keep an open mind.
&gt; comparing JS library to an MVC framework [React is not an MVC framework](https://reactjs.org/blog/2013/06/05/why-react.html). Neither are Preact or Vue. They're ways to organize and compose the different pieces of a web app. That's jQuery's problem. They can do everything frameworks can do (which is everything vanilla.js can do BTW) but provide no plan for how to scope data and functions, and no sane methods for handling rerenders. Doing that from scratch, and in an optimized way, is a real drag.
If it was meant to be read, it wouldn't be on Medium, buried behind endless fixed headers and footers and popup spam.
if you want types back the way you think about them, set up typescript. that's what that's actually all about. inheritance is fine in javascript. the hipsters like functional programming instead, which you might think of as c++ template metaprogramming but without types. i confess, i kind of prefer it too. one good way amongst many in javascript is just a marsh of short top level functions, the way a lisp programmer would it's surprisingly liberating. give it a go
That's interesting. Although I used this library in the past, I wasn't able to fit this in for our needs. My concern is that cropping should be done manually and depending on the size units (mm, cm, meter, etc.). Or I was thinking I haven't just explored the library that much yet.
The feature is more of like this one: [https://www.youtube.com/watch?v=momGtUdfBZw](https://www.youtube.com/watch?v=momGtUdfBZw)
I was in a similar boat not long ago where I wanted to pick a framework to learn, though moreso for web development than cross-platfrom app development. I ended up going with Vue, though React was also closely considered. I recommend checking out their framework comparison page [here](https://vuejs.org/v2/guide/comparison.html).
&gt; Especially with templating libraries. Like Handlebars or Nunjucks, and server-side page renders? Sure. Though your templates won't be able to help you once you need to do a lot of DOM node creation client-side, like you would in a todo app. Then you're back to figuring out rerender methods that aren't super inefficient.
i will check the comparison , and how long did you take to start feel comfortable with vue ?
If you want to do it "the JavaScript way" you shouldn't be using classes. You should be using functions, closures, and object literals. [This is how you could achieve that.](https://www.youtube.com/watch?v=DePE0ffiMf4&amp;feature=youtu.be&amp;t=2579)
and lack of compiler. I once spent a day tracking down a mysterious error that turned out to be because of a line like `if ( myVar = value )` Assigning instead of comparing. A compiled language would mostly likely catch this, but Javascript just lets you do shit like that.
Please don't complete the exercise for learners. If you want to do it on your own and then share some tips/hints that is okay. Posting a complete exercise doesn't allow the learner to explore and discover the solution and there is a lot of things lost because of it. 
I used it to create all the image cropping and editing tools on this site here: https://artisanhd.com/secure/uploadconfigure/ It looks like to get a more native experience akin to the example app you showed, you'll have to get creative with hiding the image based on all the toolbar sliders. This looks like a good challenge with lots of positioning logic! Those are so hard to make responsive...
I used it to create all the image cropping and editing tools on this site here: https://artisanhd.com/secure/uploadconfigure/ It looks like to get a more native experience akin to the example app you showed, you'll have to get creative with hiding the image based on all the toolbar sliders. This looks like a good challenge with lots of positioning logic! Those are so hard to make responsive...
The point of this architecture is that you don't do that. It's not about making every part of your app easier or maximally polymorphic, but keeping all the relationships instantly understandable which is what matters more arguably. Refactoring might involve a little more text editing, but you will more than make up for that by not "staring into the void" as douglas crockford says.
Exactly. I find it challenging to actually fit it in our needs since this one is more of a manual thing with no sliders to depend on, just the values that were used in the frames.
Do you have an example of fractal state?
ESLint would have caught that for you: https://eslint.org/docs/rules/no-cond-assign
A good IDE or linter should catch these as warnings. It even beeps at you if you use == with type coercion instead of ===. 
I'm surprised that more games aren't made up of streams/observable sequences. I'm thinking about making a fighting game engine that uses RxJS to handle transforming a stream of inputs into things like special moves and it seems like the best way to solve the problem. 
AS3 (EcmaScript 4) is my most favorite language ever. With features like optional static typing it was a superior language 10+ years ago than current JavaScript. Like everyone else said, TypeScript is probably your best bet if you want to keep thinking in the same way. &gt; How is information hiding implemented in ES6? There is no native support for private and protected properties with ES6 classes. Do I consider adding them? If not, how do I architect my programs without such a fundamental OOP feature? You can create ES6 modules and only expose the things you want to expose with `export`. As for members of a class you can use closures to create private scopes, but it's not really the same thing. To code in JavaScript you have to throw all your OOP notions out the window.
``` // Anything in this file can access globalA but not a,b,c,d var globalA; function foo () { var a; var b; function innerFoo () { // innerFoo will have access to a &amp; b or d // foo will NOT have access to c var c; } function innerFoo2 () { // innerFoo2 will have access to a &amp; b or c // foo will NOT have access to d var d; } } ```
&gt; JS was designed to be sprinkled into mostly static pages, for a little desired interactivity. I think we can all agree that since 1995, JavaScript has far exceeded it's original scope, both in terms of its design and how it actually gets used. Regardless, it was never intended to be used for "a little desired interactivity", it was designed to provide a pretty complete interaction layer. &gt; JQuery was designed to make sure it worked in all browsers and could be written succinctly, back when JS had no querySelector and the browser wars left spec compliance in tatters. Those was their stated purposes; but, sure, how they came to be used is wholly different. That's a lot different from what you said it was designed for a couple of comments back, so I'll take you moving the goalposts as an admission that your original claim was incorrect. The effect of normalizing differences between implementations and providing high-level syntax sugar intended to make DOM manipulation and reacting to events more approachable to front-end developers was - *gasp* - people suddenly found it a lot easier to create full-featured web apps. I'm inclined to agree that we've mostly moved past the usefulness of jQuery, but jQuery still serves the same goals, and without the opinions enforced by frameworks. Go ahead and use Vue or Preact, if that's your preference. Personally, I think either of those are overkill for the purpose of building a to-do app, and I wouldn't want to use jQuery either. But compare the source of this app to the examples to examples of todo apps built in Vue or React, and I don't think it's clear at all that jQuery involves more work to achieve the same result. Granted, jQuery doesn't enforce any particular kind of code structure, but that's not necessarily a bad thing. And, of course, jQuery doesn't tackle every problem one is likely to come across when building a todo app. But then, neither do Vue or React.
Yup, that app looks like you'll have to roll your own. I edited my last comment a bunch, so if you didn't catch the latest edit, I suggested viewing that site and playing with Clusters/Splits feature. It should give you some ideas and inspiration for what kind of DOM manipulations could work. It's not as advanced as the app you're working on, but does play in the same space.
JS is built based on Scheme programming language. I always felt that trying to force langauge to work like other language is wrong so don't try to think in classes that was basically added to make the Java guys happy. BTW, I'm transitioning now from JS to Swift (due to some conditions) and I miss JS so I feel your pain. 
If only there were some kind of library that made client-side DOM node manipulation really straightforward! I don't know why you keep going back to ineffecient rerenders. This a to-do app we're talking about. It's not like we're going to end up re-rendering the whole DOM several times a second.
1. Probably, with closures 2. You can easily mix in multiple "classes" but be careful with methods/properties overriding – there is no automatical checks, also need to be careful with order in which you're mixing those things. E.g. you can create a class `MyInterface`, then create a class `SomeObjectClass`, then inherit `MyObject` from `SomeObjectClass` and then mix in `MyInterface`. In this order, properties from the `MyInterface` will be used instead of `SomeObjectClass` in case of the same names. But you can easily make it other way around, no limits. 3. You can use TS or other similar things, but always remember that in fact your program will still be compiled to the Javascript. It can make a difference for debugging or for some complex cases. I'd suggest to make yourself familiar with JS first and then try TS and so on.
Very good advice.
Sounds cool, drop in a link here when you are done or need help 👍
Yes, they are MVC frameworks. They squarely fit under the definition. Just because some PR dope on a blog wants to say "we aren't an MVC framework, we transcend MVC frameworks!" doesn't magic them out of it. &gt;That's jQuery's problem. It can do everything frameworks can do (which is everything vanilla.js can do BTW) Who knew a library written in JS to simplify JS can only do JS things? I mean, a powered drill can drive screws quickly and efficiently, but I can also do that by hand, so why bother with the power drill, right? &gt;provide no plan for how to scope data and functions That has traditionally been the job of developers. It's not JQuery's aim either. I think you're confused about JQuery. It's just another tool in the belt that makes life easier. It's not some sort of single solution for all problems in the JS world.
Thanks for making the notes! But you need to fix at least the first few. The definitions of shift and unshift are switched around in at least two places
I agree with your comment, but in this very case it probably would not help-the assignment expression is valid to put inside a condition even in any compiled language, if I am not mistaken.
Very true
For all of them, you use TypeScript and never look back. If you fancy ActionScript you'll love it.
For some reason I am still getting undefined for the result. I might be over complicating things. The whole reason why I need the result is so that I can pass it to the ejs template along with some other variables. ```res.render('template', { sample_data: sample_data, sample_data2: sample_data2, query_result: query_result }); ``` That is the reason why I need to store the result in a variable
No, it's not JQuery's aim. And sure anything is "just another tool" but this convo was sparked by someone saying: "If you're loading Bootstrap, you're loading JQuery, so why not use it?" To which I say, for a web app, JQuery is not the best tool for the job. That's why.
Exercise? Lol.. I provided a code example for what he asked for, much like you would find on places like MDN or SO. Code is all over the web; people learn by looking at other's code and playing with it. I clearly emphasized that he should ask questions if he doesn't understand any part of it. Chill.
as most of comments here said, you should use Typescript but I think you also should not forget that Javascript is a multiparadigm language. As it is not pure OOP (based on Prototypes), you can also mind to use lambdas, functional programming, streams etc when OOP don't fit for solving a problem.
I want to address abstract classes/interfaces, but just a recap of the other things and what people have said here: ### Private Methods/Properties Javascript does not inherently enforce the concept of private methods/properties. This is done through code and convention. The convention is to prefix private methods with an underscore. The code uses closures and is something along the lines of: const interface = (function(){ const public = {} const private = {} public.method1 = function method1(){} public.method2 = function method2(){} public.var1 = true public.var2 = true private.method3 = function method3(){} private.method4 = function method4(){} private.var3 = false private.var4 = false return public })() Also, as others have said, if you're using NodeJS, all code not explicitly exported from a module is considered private, though, there are ways of accessing it so don't assume it's "secure". ### Abstracts/Interfaces Again, not natively supported, but can be implemented through code. Inheritance is your friend here. class Abstract { method1(){ throw new Error('method1 not implemented') } method2(){ throw new Error('method2 not implemented') } } class MyThing extends Abstract {} const instance = new MyThing() instance.method1() // throws an error This will only throw an error at runtime when the method is accessed, though. I have yet to get on the TypeScript so I don't know if it natively supports this, but yes to TypeScript (or Flow) for type safety and whatever other features it offers. ### My Notes Javascript is a simple scripting language. It doesn't save you from yourself. There's no information hiding, there's no abstracts, there's not strong typing, etc, etc, etc. It takes code and runs it. All of these other features have to be enforced by your build process (Babel, etc) or your language super sets (Typescript, Flow, etc). You can fundamentally write the same algorithms you did in C++/Java but you don't have the compiler to enforce constraints and check for issues.
Your `get_address` function is where you should continue processing, because your processing is asynchronous at that point. Your `result` will only be available inside `get_address`, and thus you should be running `res.render` from inside `get_address`.
&gt; It's not like we're going to end up re-rendering the whole DOM several times a second. I don't know if you're being hyperbolic, but if you were rerendering that often, you would want Canvas, not the DOM. But I assume any app is going to be regularly rerendering DOM elements, which is pretty expensive, so it's definitely a concern you want to think about early in a project. Even in OP's link, we already see the problem with using JQuery for this project. Each time `submit` is pressed, all the event listeners for the new node that's being made have to be added, plus classes, and then again for all its children. For any full-featured app, there will be many features, so this will require a lot of organization, and even then -- likely not be very readable.
Or at the very least flow type your ES6
Firstly, you'll hear a lot of people argue that JS is either primarily an OOP language, or primarily a functional programming language. They're both wrong. After having worked in JS for many years, with many different people and projects, I can tell you for sure that the primary paradigm you'll use is not OOP, it's not functional programming, but it's plain old procedural programming. Most of your objects will be much closer to C's structs than to Java's class instances, and most of your functions will work with just objects and values (as opposed to functions, as with FP). Even in places where these features are used, it usually doesn't come in very advanced forms (e.g. no GoF patterns, currying, function composition, etc.) . Since you're experienced with C, your C programming experience might be a better starting point than your C++ or Java experience. OOP and FP definitely have an important place in JS, but it's absolutely not needed to put everything in classes, or to curry all your functions. Just use it when it provides a noticeable benefit, and for the rest, just keep it simple. &gt; How is information hiding implemented in ES6? There is no native support for private and protected properties with ES6 classes. Do I consider adding them? If not, how do I architect my programs without such a fundamental OOP feature? In reality, information hiding isn't done that much at all. And I'm not talking about JS, I'm talking about programming in general: look at your average Java class. How many of your properties have accessor methods? Most likely almost all of them have. When you _do_ need information hiding, then there are a few options: - For the equivalent of `private static` fields, you can simply use top-level variables in your modules (files). - Closures. E.g.: function dbConnect() { const session = connect(); return { query(q) { session.query(q); } } } const connection = dbConnect(); connection.query('SELECT ....'); - Hidden by convention: properties prefixed with an underscore are considered private (this is actually extremely common). - Using Symbols. E.g.: const session = Symbol(); class Connection { constructor() { this[session] = connect(); } query(q) { this[session].query(q); } } &gt; I loved abstract classes/interfaces. They enforced contracts on objects so I could create reusable code to operate on them. I understand that JavaScript is duck-typed, but in the absence of interfaces, I can't architect my software like I used to. So how does JavaScript want to think about my software? At what point, and using what criteria, should I consider using a library/language that gives me those features and transpiles? (Almost) every serious JS project nowadays uses a transpiler, don't be afraid of adding it. Most often this is babel (to bring in modern JS features to old browsers), but TypeScript is also extremely popular. Personally, I highly recommend TypeScript, it works extremely well for all of procedural, functional and object oriented programming, and it will give you all of the features you wish for. If you don't want to go with typescript, then you're left with runtime assertions and unit tests. &gt; For a few years, I coded in ActionScript 3 and loved it. The language may have a bad rep, but it worked just fine and the code I wrote is easy to read and maintain 8 years on. I'm now having to write a very similar program in JavaScript and the first thing that comes to mind is -- how do I use JS to create something better? How do I know if parts of JS are far stronger, or far suited, to what I'm writing? Should I consider TypeScript since it's close to AS? It was easier to understand the jump from C++ to Java -- but it's not the same here even though both AS and JS are ECMAScript based. It sounds like you've been a developer for quite a while already, so just follow your intuition. If you think "there must be a better way to do this", then there likely is. One easy thing to look out for is boilerplate: JS folks are far less tolerant to boilerplate than Java folks, if you find yourself creating a lot of boilerplate than there is most likely an easier way to do it. 
Why is the site suddenly so wide, with massive fonts? Are they assuming everyone's browsing the site on a 4K resolution? Also the font for the code blocks is really fugly. Not a fan. At first I thought I'd hit the mobile version of the site...
Amen to this, coding this way is a great pleasure.
Think in concepts of data transfiguration and piping. Not ownership. You will still have classes, or things that feel/function as classes. But the there will be only a few of them. Everything else in the app is usually some type of plumping. Only use OOP to GENERATE initial data. Then use clean immutable functions to pipe it through the application. JS has a mild form of type checking. Sanitize your inputs, I cant stress this. If you feel angry at the type system its because you arent writing asserts/error handling/validating. Or install TypeScript and then you dont have to change your thinking. But you wont learn much.
If you like this idea, please, support it by putting your hot Star on the github :)
Seems some people have no sense of humour... nor understand irony :D
Not very long at all - about two or three days before I was able to write code for my projects without needing to look up anything, though I'm sure there are still a lot of things I don't know about the framework.
Linters are great. Yoda conditionals would also have this prevented.
Please note that although TypeScript is a must (I’d argue for everyone but we can all agree at least for OP), OP should keep in mind that types and interfaces are syntactic only and after type checking literally go away. At the end of the day, JavaScript doesn’t have private/protected members, interfaces or generic. And classes are just syntactic sugar (albeit have a huge impact on performance). If you’re building a library, OP, you might still want to manually type check inputs to your API. 
&gt; That's a lot different from what you said it was designed for a couple of comments back, so I'll take you moving the goalposts as an admission that your original claim was incorrect. It's not, just a bigger picture. I still maintain JQ on its own is meant to be used same as JS on its own: to give a little interactivity here or there. The problem it was *solving* was JS's fractured implementation, and the verbose and limited DOM traversal API that JS had, but its intended use case was the same. But we know, right, that nothing's ever stopped a coder from using whatever tech they wanted for whatever purpose they have in mind, but were the results always great? No. You can say JQ lit the fire for web developers to want to do more, but that doesn't change the fact that attempting those goals with JQ was painful. My point, which it sounds like you're agreeing with (all while trying to put words in my mouth, and avoiding offering your own solution) is it's not a good tool for building web apps. So when someone asked "Why not?" I answered the question. I've built interactive and dynamic pages with JQ; probably you have too. It's not fun. JQuery is 30kb gzipped; Preact is 3.5kb gzipped. Not sure why you say it's overkill? Boilerplate maybe? If so, I've never understood that argument; I think it was first made by people who believe React and Redux are inseparable, which is not true. Maybe you have another reason, but there's like 5 lines of code involved to get started, and then you're off building your interactive components -- which include all the HTML you'd have to write anyway.
Excuse my ignorance, but why not use jquery? Doesn’t jquery enable cool stuff like ajax?
They loooove Internet Explorer
You can also implement private methods and properties in es6+ using Symbols as keys, or using WeakMap
Easy answer? Use TypeScript. It "feels" like C# (or Java). Indeed, they were created by the same guy. Long answer? There are numerous methods to implement many classic OOP ideas in JS. For example, to implement private instance variables, either use closures or use convention and prefix private variables with an underscore. I've seen and used both. You will have to learn all of the numerous idioms and patterns. Protected instance variables get a bit tougher. Obviously, ES6 has "classes" and other syntactic sugar. They are very helpful to be sure. In the end, I still maintain a very OOP mindset. Nouns become classes, verbs become methods. Information is hidden. I still use the concept of a main() where execution begins. I try to avoid pure JS when I can in favor of TypeScript due to the ability to have types, refactoring tools, etc, etc. I do use some functional ideas like map, filter, reduce, etc. Also, can't forget passing functions around. I would like to say a similar discussion happened back in the day when we transitioned from C to C++. We realized C can be written in a way that mimics OOP. In fact, Gnome is written in OOP C.
I wouldn't start with typescript if I was coming from a statically typed language and wanted to learn JS. Typescript is not training wheel for OOP in JS. If you don't know JS you're going to have a hard time debugging typescript transpilations.
Can't imagine using JS without a linter.
You robbed him of working through it by himself. I understand code is every where but (1) he didn't ask for code and (2) it is generally the feeling of this community that code should only be provided if OP has made an attempt to complete the problem.
I know, right?
&gt; I don't know if you're being hyperbolic, but if you were rerendering that often, you would want Canvas, not the DOM. I'm just saying, it's unlikely that you'd ever run into performance problems with rendering a to-do app. But I'm the one being hyperbolic lol. The example has its issues, but the event listener issue has nothing to do with jQuery, rather it is an organizational problem that is easily resolved by simply lifting the listener up a node.
Yes. The arrow functions avoid the usual .bind(this) call.
&gt; Am I assuming correctly that the arrow function 'this' doesn't exist instead 'this' of the containing function is called. Kinda. [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_separate_this) is obviously _the_ place to check the ruling. The way I think of it is that when I use an `arrow function`, it takes the `this` value outside of the function body and says "If you ask for `this` inside of the function body, here is the value". Similarly to `fn.call(obj, ...args)`, where you define a specific `this` object when calling the function.
Given your analogy, I would say closures are more akin to this example: You have a backpack full of things. You can't reach into the backpack but the items in the backpack can reach out to you. You have a box inside the backpack that is full of Oreos. Each Oreo has access to the box its in, the backpack the box is in, and can reach out to you but you still can't get the Oreo. The Oreo has some cream filling. That cream filling can touch everything the Oreo can plus itself while the Oreo cannot touch its cream filling. The idea being: Closure's go up, not down. When you create a closure, you are saying "I want access to everything above me but not let anyone above me have access to me." So your Oreo is a closure, that has access to everything you do, but you don't have access to the Oreo since its inside of so many closures.
you meant that entry level isnt hard and that is good to hear.
Maybe stop defining yourself as only being capable of following one pattern of thought. I'm not saying you cannot follow OOP practices if you really want to, just suggesting you could try leaving your comfort zone for a bit and see if the other side has a point.
I have an OOP background and I use TypeScript to scratch that itch. Lately, though, I have embraced JavaScript (node) as-is. Think about modules and functions instead of classes. Information hiding (encapsulation) can be done by not exporting a certain function. Separate command and query functions, push side-effects to your application's boundaries and carefully contain state. Dependency and (functional) composition still work, but there is no built-in way to enforce/check behaviors. That is why I would advise investing in testing and linters.
I’ll share my experience, after having inherited a prototypes app and switching it off of meteor(mostly). We now use meteor as a back end only, and likely will fully take it out in the coming months. Meteor is very good at making apps quickly. It’s built in libraries allow you to do some good great work in no time. You can also use react with it if you like, rather than blaze. That said, the popularity is waning. Many packages have not been maintained in two+ years. The environment is opprossive. You can’t not use meteor the way it’s designed without doing a fair bit of extra work. Also, at scale it has performance issues. Data takes a bit longer to load than rest on initial load. Sometimes figuring out what the API is doing can be challenging. I found the documentation for the API to be somewhat lacking for complex scenarios. I found this to be the case. Adding libraries is a challenge sometimes they just won’t work with meteor. It’s a full fat environment, so you need to play in its rules to work.
I've been doing pure JS in Node for about 5 months now, after 10+ years of primarily JVM work. I've wanted to move this direction anyway, after feeling like the Java way of doing things was wasting a lot of effort for little gain. Scala helped a ton, but JS has a library advantage like Java, and frankly some of Java's problems are the JVM which affects Scala as well (Type Erasure, biggest mistake since null). The biggest thing I've found is that because data contracts are easier to establish than APIs in JS, I'm documenting and conversing about the data far more. In Java we provide verbs (object methods). In JS we provide nouns (JSON objects). I'm finding the latter far easier to manage than the former, vis a vis my customer's expectations. Data shape is problematic either way, JS makes it cheap to focus on it. Further, I spend far less time thinking about how to organize my code up front. I find that as long as we maintain a culture of refactoring regularly, code organization grows organically and has been vastly more intuitive with far less discussion of proper class hierarchy. Even just the process of refactoring is simpler since I don't need a new file for a new closure. No more public/private/protected. Yes you can mimic these. No you should not. Trust in your contracts, let consumers decide if they want to do terrible things with it. This has been incredibly liberating (Scala somewhat moves in this direction), and reinforces data as the contract, not the actions. Anonymous functions are friendly and inviting! Java 8's arrow functions are significantly nicer than prior, but the implementation is kludgey, definitely not a seamless feature of the language. I'm passing functions around in my JS like it was LISP. It has all the power polymorphism provides without the class hierarchy. It's as though the Strategy Pattern just got super cheap to implement. Regex is your friend. It is hyper optimized in JS and is a first class citizen (no more "\\\\" to get a single backslash into the regex). What was always a mess of string operations is better handled by a single Regex, and much cleaner than Java's implementation. NPM &gt;&gt;&gt; Gradle/Maven. I thought the lack of namespaces was a hindrance at first, then I came to love not sharing dependencies. All dependencies are isolated (assuming no packing), no more Guava version mismatches. NPM isn't perfect, but it's far more intuitive than anything in the JVM world. Much of the useful compile time errors can be replicated through linting. Given controls over the rules set, you can even restrict to a subset of JS without changing the language at all. Now, for the downside: Truthiness. The biggest hurdle I've encountered. An unfortunate reality of JS is that its core code is super old and predates the transition to some better things. All values are boolean expressions and can (and should!) be evaluated as such. You'll have to figure out when to use `==` vs `===` (usually `===`, but sometimes `==` is correct). You'll have to figure out why 0s are being filtered out of your dataset for the umpteenth time this week. Why your sparse string data isn't sparse. And stare earnestly at each null check just in case it's doing something you're not expecting. Also 0 does not always equal 0 (hint: 0 is signed too). I think there's an implicit downside that many in the Node world don't have to deal with too. Javascript the Good Parts is what we consider Javascript, but many developers out there do deviate from the norms. So far my only suggestion when encountering these types is to wish them well and then run for the hills. Their code does not work like you think it does and dissecting it will drive you insane. So far have yet to encounter these types on the backend though.
Why would it not be a good idea? That's the whole purpose of a promise chain: to use data when it's available. So you put the code you need where you need it to fire. I would probably separate it into a function for readability, but basically the same thing: db.connect() .then(obj =&gt; { sco = obj; return sco.any("SELECT * FROM data_center WHERE similarity(address, $1) &gt; 0.5 LIMIT 1;", [address]); }) .then( data =&gt; renderTemplate(data[0].address) ) .finally(() =&gt; { if (sco) { sco.done(); } }); function renderTemplate(query_result) { res.render('template', { sample_data: sample_data, sample_data2: sample_data2, query_result: query_result }); }
No TS does not increase complexity it decreases it.
Thats why we have TS
Closures are gonna be useful for restricting 'classes’.
`&lt;div&gt;...&lt;/div&gt;` transpiles to `React.createElement('div', ...)
Because the &lt;div&gt;&lt;/div&gt; syntax is transpiled into code that requires react.
Starting my first web dev job, I built one single-page webapp with just JS (no frameworks), until I understood its limitations. Then I moved to TypeScript. There were some teething problems figuring out how to share variables between files (but if you're experienced in OOP to begin with, this shouldn't be a problem), and bringing webpack into the mix certainly made things harder, but bit-by-bit, I found that TypeScript solved all sorts of problems. It: * tells you when you've made a typo! * tells you when a variable's not in scope. * auto-completes, greatly aiding discovery. * is absolutely necessary for refactoring. * tells you when your promises have unhandled resolution/rejection values. ... I could go on. I'd recommend TypeScript even to an early beginner. But ultimately, one will have to learn both at the same time.
Personally I hate the entire JS “community”, but not as much as they hate each other.
I getcha. I suppose you run the risk then of him struggling and giving up cause he can't get anything working and he feels like it's impossible. I feel like it's sometimes more helpful to start with something working and deconstruct it/play with it in order to get an understanding... instead of starting with absolutely nothing. Different approaches I suppose.
Arrow functions do not have their own \`this\`, so \`bind\` does nothing and \`call\`, \`apply\` only work for arguments. In other words, the \`addEventListener\` is using trying to bind \`this\` behind the scenes, but it's doing nothing if you use arrow functions. Might also be worth noting that arrow functions do not have the \`arguments\` object either.
To the point of data hiding, you actually *can* hide data using closures: function createPoint(x, y) { return new class { get x() {return x} get y() {return y} } } Once a user creates a point with, say, `createPoint(1, 2)`. There is literally no way they can update x or y using the implementation above. Try it: const p = createPoint(1, 2) p.x // 1 p.x = 2 p.x // still 1
Aside from regular OOP stuff, one of the more important things in JS to know about is its asynchronous style. Many things, especially IO, is executed asynchronously. That is, you tell JS to load something in parallel, and then execute a callback when loading is done. I've recently found that async/await/promises is much easier to work with than callbacks, though. With async/await, you can write async programs in a sync looking way. Whenever you put an await while calling an async function, JS will stop right there and check if there is some other stuff to do, like other callback or await statements that are ready to be executed. 
This is obviously true, but I've never really seen an example of how that would ever get in the way of anything. That is to say, when will you ever say "Oh, shoot, I didn't realize JavaScript didn't have 'true' classes and that really messed me up because _______."? The only thing I can think of is that prototype methods (class methods) are dynamically mutable, but I think that's more of a function of JS being dynamic rather than a function of JS being prototype-oriented. Python, for example, also allows this in the same way despite having "class-based" OO since version 0.
I get all of those things from my IDE/ESlint/etc whether I am working in TS or JS...
Unfortunately, before ES6, I'm not sure it was a "real OOP" language. Not saying it against Javascript as much as *for* the defining rules of OOP: &gt; Encapsulation. Technically you can encapsulate with closures, but that's a bit of a headache. &gt; Abstraction. Interfaces. This OOP principle is basically an epic fail for Javascript and most dynamic languages. Don't get me wrong, we get to very carefully write things *MUCH* more bad-ass than interfaces because we can say "if this object implements method "A" and "B", then do something, else do something else." but like functional program, it's a language strength that doesn't necessarily make it OOP. To be clear, ES6 doesn't support interfaces. This alone technically kills it as an OOP language. &gt; Inheritance. Prototypical inheritance doesn't really honor the definition used in OOP. You don't have a clean "is a" all the way down. Lacking strict typing, you also lack the ability of enforcement of an object passed being "is a" of a parent/grandparent object. &gt; Polymorphism. Well... you do have that, on crack, with room to spare. 
I totally agree with this kind of approach. This gives more liberty to the developers to come up with their own idea/design on top of the free Elm Architecture provided by Raj.
&gt; I meant that JS/ES is not in the same vein as some class based OO languages. Can you clarify? What does "not in the same vein" mean from a practical perspective? That is, how would it impact "solid OOP design skills" with regards to "build[ing] maintainable architecture in JS"? --- For the record, my opinion is not that using traditional OOP in JS is a "good idea" but rather that JS is in most reasonable senses (which is just to say, as long as you never pull in libraries which do significant meta-programming or something) as equipped to do standard OOP as, for example, Java is. (unless you count strict/strong typing and relevant method overloading as critical to standard OOP, in which case you will have to modify your use of templates to dynamic type evaluation instead).
Disagree, JS is definitely different animal than C/Java languages and it often has specific ways/best practices to do things JS way. In case going straight to TS you may end up just writing the code in C/Java style. For me it was good shift after working mostly with Java, being able to understand asynchronous way of working with things, closures and functional programming aspects. 
THIS. This is how i understood it too. The oreos would also have access to each other, but not to the cream. The cream1 of oreo1 could access all the oreos, but no one could access the cream1. Correct?
&gt;arguments &gt; &gt; object Interesting, I was wondering why I can't use arrow function as constructors. This clears it up :)
&gt; best JS architectures that I've seen or used are built around functional programming concepts That has been my experience as well. I started in OOP paradigms, so naturally transported them to JS, which at the time looked superficially very OOP. But, once I started learning functional programming paradigms and techniques and applied them *in a general, attitude-based way* to JS things worked better and became more understandable.
A Java developer I used to work with said he had problems with it initially, especially where he would normally implement or extend a class, and he couldn't figure out how to do that with an object in Javascript, but once he got the hang of it, he actually said he liked it better and even admitted that he was thinking of transitioning to a js developer role.
It's because vanilla javascript doesn't support JSX, importing React adds JSX support to your environment so you can use it as part of your code. Try removing React and you'll get an syntax error like: `Uncaught SyntaxError: Unexpected token &lt;` which is your coming from your opening div
&gt; A compiled language would mostly likely catch this, but Javascript just lets you do shit like that. Worth noting this is also allowed in C/C++, which definitively has a compiler. Any compiled language that catches this at compile-time would also catch it at runtime if it were an interpreted/JIT compiled language because it's invalid. The issue here is that this is allowed by the language. (if `myVar` is defined as `const`, which most of the time it should be, JS will throw here as well)
TypeScript also makes JS more awesome in so many ways beyond type safety. IMHO one of the very best features is the way you can define interfaces. In most other languages, interfaces are used to purely express a certain contract over some methods (or none at all). But in TypeScript, interfaces can also have property members. An interface is describing a certain sum of available hash map or array keys, and their value's type, including function types fo course. That means that you can express and object's signature against an interface, rather than only some methods. This makes transport objects, value objects, POJOs so much more powerful and versatile, thus expressing the true nature of the beauty behind JS/ES, IMHO.
The first two points will 100% be caught by a linter, and the third point is merely aided by TS but can be accomplished to varying degrees using, for example, Tern.js. (that said, this is my favorite part of using TS/Flow/statically typed languages in general) I'm not sure how your fifth point is even possible. Seems like you would have to solve the halting problem to solve it in a meaningful way... Can you point to a resource that explains how this works? I'd say the main reason one should use TS is "it makes sure you're not using types in ways it's not allowed".
I personally think prototypal inheritance/dynamic typing is beautiful and more powerful than traditional class-based/static approaches (though less practical **for sure**). That said, I don't understand why they would have a problem implementing or extending a class in JS in any way they would do it in Java, though I'm not an experienced Java dev. JS's class syntax has always seemed to me to be a superset of Java's, aside from public/private.
Easy != simple https://www.infoq.com/presentations/Simple-Made-Easy
Start with everything is magic, and then work toward why it’s really science.
Best channel. Great guy.
If you're wondering why is this, it's because `classes` are already present in es6 so there's no more need for es6 (arrow) functions to self-bind. A fitting perspective could be: es6 classes fits oop, es6 arrow functions fits fp.
Okay! I will go for it! Thanks! Do you know where i can learn how to use apis with js afterwards?
Do you want to write front-end code or back-end code? TO my knowledge, front-end you can easily adopt TypeScript. I found a link online, https://blog.sourcerer.io/a-crash-course-on-typescript-with-node-js-2c376285afe1 which might make you feel at home with nodejs as well using typescript. Many Compiled Language programmers feel more comfortable with typing systems, and this will be your savior, it will also give you a foundation to make sure your applications are closer to bug-free than most vanilla JS development strategies. Typescript is here to stay. Microsoft has adopted it in full force. So has Angular (google), and google internally on other projects. TS is turning into the new go-to type-safety system for JS projects in general.
Yup, it even takes a bunch of medium articles &amp; stackoverflow threads to figure out: 1. Difference of fetch from xhr, what one has that the other lacks 2. How dysfunctional the fetch polyfills are on very select specific use cases
Not a bad bot, but a dick bot.
strongly typed languages support static analysis. That can do the 5th part, telling you when your promises have unhandled resolution/rejection values.
Please be aware that this technique is using what is effectively a singleton for the private value, and really only makes sense if: the value is immutable, or if mutable, will only be used by a single context. So, if you're writing a nodejs server that serves multiple requests, and you want a private value that can change between requests, don't do this.
&gt;Well, in modules - any non exported functions / variables - are inaccessible outside of the module, so you can think of them as private. True but they are limited use because they are effectively singletons. They do not allow you to implement private class members, because the value can't vary from instance object to object. That is, you can't have a Car class with a private engineTemperature property in which two cars have different engineTemperature values.
bind still works for arguments const add = (a, b) =&gt; a + b; const add5 = add.bind(null, 5); add5(10); // 15 
You could implement a sort of private storage but creating a map with the this being the key that returns an object which could be the private store for that instance and as long as the function is inside the module nothing but the class could access it 
Not having their own `arguments` object is not why they can't be constructors. They're just not allowed to be, like every other new function format added in ES6. const obj = { func: function (){}, method(){} // new ES6 method syntax } new obj.func(); // OK new obj.method(); // Error And to be clear, you can still access `arguments` in arrow functions, it'll just be the arguments of the wrapping function rather than its own. function foo (a, b) { const bar = (c, d) =&gt; { console.log(arguments); } bar(3, 4); // [1, 2] } foo(1, 2); 
Relax guys! I think it's kinda interesting to get the code because I find out new methods or properties that I didn't know before and that makes me want to learn further about them. Learning in this way isn't always that efficient tho'. As wijsguy said, it's better to learn when the answer does not come to you because whenever you deal with obstructions, this will improve you when going through them.
Refactoring across multiple project files will be an absolute gamble in a non-TS project, even with a good IDE.
Interesting idea. I think this would be a memory leak, though. The objects would not get garbage collected, because they're referenced in the map, and you don't know when to delete it from the map. You'd have to manually call some kind of cleanup function when you're done with the object.
Such a horrible made of do it. var span = $("&lt;span&gt;&lt;/span&gt;"); span.addClass("fa"); span.addClass("fa-times"); span.addClass("pull-right"); span.addClass("close"); They way he add classes to a simple element... var span = $("&lt;span class="fa fa-times pull-right close"&gt;&lt;/span&gt;");
Just look at: [http://vanilla-js.com/](http://vanilla-js.com/)
&gt; I still maintain JQ on its own is meant to be used same as JS on its own: to give a little interactivity here or there. And I still reject that premise. Repeating it does not magically make it more true. Even if it is your experience that plain JavaScript and jQuery are only good for little sprinklings of interactivity, that was never the intended purpose of either. &gt; My point, which it sounds like you're agreeing with (all while trying to put words in my mouth, and avoiding offering your own solution) is it's not a good tool for building web apps. Here's my solution: be wary of anyone attempting to tell you that there is a right to do something, as it is exceedingly rare that they are correct. If you don't think critically about received wisdom, then you are setting yourself up for a world of hurt once the validity of that dogma falls apart. &gt; I've built interactive and dynamic pages with JQ; probably you have too. It's not fun. I don't have extensive experience with jQuery, but my experience with it has been nothing short of delightful. In fact, I liked using jQuery so much that I seriously contemplated a career change into interaction design. Whatever the case, "fun" is a rather odd way to judge a library. &gt; Not sure why you say it's overkill? Because you don't need a freaking virtual DOM abstraction layer for a todo list! That's a lot of conceptual overhead to accomplish a trivial task, and for what? Faster renders? Not a chance in hell. You are not going to notice any performance advantages whatsoever using Preact or anything like it over native DOM rendering in a situation like this. Unless you are rendering thousands of elements, the difference in performance is negligible at best. But you do get to deal with an extra build step and your markup lives in your logic, so that's a plus! /s At least with jQuery, you're importing a library for the sake of *reduced* conceptual overhead. If you like using &lt;blank&gt; for this sort of thing, that's great. Use whatever you're comfortable with, but don't delude yourself into thinking that your way is necessary or "correct". I prefer to use vanilla javascript, and reserve imports for things that I can't easily implement myself. That's what I'm comfortable with. But I don't delude myself into thinking it's necessary to do it that way, nor do I pretend that it's the "correct" way just because it works for me.
As far as I'm concerned, that's just a non-answer. First of all, weakly typed languages also support static analysis, just to a lesser degree. Second, "static analysis" is obviously what we're talking about and describes a plethora of features. Example of where you'd basically to solve the halting problem to solve this problem: ``` function returnsPromise(canReject) { return new Promise((resolve, reject) =&gt; { if (Math.random() &gt; 0.5) { resolve('hello'); } else if (canReject) { reject(new Error('Oh noez')); } else { resolve(new Error('Oh noez')); } }); } returnsPromise(false) .then(something =&gt; { // handle something somehow }); // We didn't attach a catch handler, but we didn't need to either. Is this a false positive? ``` Assuming the static analysis assumes there must *always* be a catch handler (which may be valid), ``` const myPromises = new Map(); const p = returnsPromise(false) .then(something =&gt; { // handle something }); myPromises.set('p', p); myPromises.get('p') .catch(nothing =&gt; { // handle nothing }); ``` I'm not saying you would really ever want to do something like this (though it's certainly possible given a sufficiently generic program), but I fail to see how types/TypeScript are ever going to help determine when your promises have unhandled resolution/rejection values beyond knowing that `returnsPromise` returns a Promise.
Ah, yeah you're right, not specifically the compiler, my mistake. My overall point is that javascript will interpret that code as valid, i'm guessing because it uses type coercion.
You're not incrementing the counting variable, you're incrementing the counting parameter, which is a new variable defined in the local function scope that overrides the original variable there. You can also see it as: var counting = 4; function increment(somethingElseEntirely) { somethingElseEntirely++; } increment(counting); Here, somethingElseEntirely is changed, not counting. If you want to change counting, don't pass in counting as a parameter (causing a separate variable with the same value to be created), instead passing nothing at all. var counting = 4; function increment() { counting++; } increment(counting); This then allows the function to reference and change the original counting variable.
&gt; i'm guessing because it uses type coercion. Partly, but if `value` is a boolean, it won't need to do type coercion for this to be valid. The issue is that the `=` operator returns the righthand value.
Pretty much all linters yell at you for the ==, but in my experience they don't yell at you for assigning within an if statement because it's technically valid javascript. 
Little oversight there, passing in `counting` on the last line.
&gt; increment(); FTFY
&gt; Indeed, they were created by the same guy. Whoa. TIL!
Learn the difference between [passing by reference vs passing by value](https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value). Also, look at block/function scoping in JS, and the differences between var, let, const.
Learn about [passing by reference vs passing by value](https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value). Also, look at block/function scoping in JS, and the differences between var, let, const.
Oh, I see. Thank you!
You're correct that it's to do with transpiring JSX, but the react module is not adding JSX support to your environment. That's typically done with Babel and [this plugin] (https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/). By default it assumes react is the target for the JSX since it was first popularised by react and comes from Facebook. With that Babel plugin, you can write JSX and target other view modules, in which case importing react is not necessary. I have also seen a plugin (I think [this](https://github.com/vijaysutrave/babel-plugin-react-import-extends) was it) that automatically inserts a `import React from 'react'` to the top of your modules so that you don't have to.
This more philosophical than technical. OO is all about coupling together data with the methods used to operate on them. This has several downsides. For example, if your objects represent a tree, then you will only be able to traverse the tree through methods on each individual child. It enforces an ant's level view, passing execution from one class to another, instead of just having concise algorithms that fit in a single loop. Information hiding is then the (mistaken) belief that you only need one set of methods to interact with that data. When this inevitably fails, you have a few options. One option is to just keep adding more methods to the same class, which leads to a mess you can never clean up. Two is to crack open the abstraction by adding public Get/Set methods for everything. But now you have little reason to justify any code being part of the class at all. So this is really equivalent to having all members be public. JS is best when you follow the second approach. Treat your data as just data, in the form of well defined, non recursive JSON structures. Use these as your source of truth. Have your code deal only in these handful of reusable data types. The benefits are huge: ability to serialize and mock any inputs trivially. Even better if you can do it immutably and avoid shared state. When you ask how to apply typical OO to JS, this is not a great question. JS shines when you treat it functionally, and focus on lightweight data instead. Composition instead of inheritance, and closed algebras instead of endless type specialization.
Sorry to interrupt this heated debate. I am just trying to learn here. It seems like Z's core point is that There are currently more effective ways to do these things and JQ isn't the bes option. All of his other comments aside, is this core point true or false?
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Backend I would I go with Node &amp;&amp; hapi or express (the express community is huge) and React for the frontend (React === ❤️) 
In JS its always by value. A more relevant SO: https://stackoverflow.com/questions/6605640/javascript-by-reference-vs-by-value
My suggestion? Use Typescript. 
It’s a setting in the linter whether you want it to yell at you for assignment in if. Someone posted the ESlint version below.
APIs are basically a tool with objects in them with key value pairs. You will want to learn about accessing data with objects first. Reading the documentation of the specific API that you want to use is very important. Here is a good source to start (I love this video. This guy is really awesome): [https://www.youtube.com/watch?v=ecT42O6I\_WI](https://www.youtube.com/watch?v=ecT42O6I_WI)
With plain old js, a lot of the design patterns can be thrown out the window since you're able to directly access almost anything. There are different patterns for js, and there's a free ebook (I think the author is Obeid Ayadi). On the other hand if you would like to remain strongly typed, there's typescript which is amazing for helping tame the extremely dynamic nature of js.
Its not cutting edge JS, but this pattern has been around for a longtime. function AddClass() { let count = 1; function add()=&gt; count++; return { add } } let foo = new AddClass() foo.add()
Privacy is much simpler and straightforward with a closure: export default function Foo() { let privateBar = 0 function getBar() {return privateBar} function setBar(n) {privateBar = n} return {getBar, setBar} } And with Typescript, we can have a public Foo interface type: type Foo = ReturnType&lt;typeof Foo&gt; 
Why are you returning a class? Just do function createPoint(x, y) { return { get x() {return x} get y() {return y} } }
Why are you returning a class? Just do function createPoint(x, y) { return { get x() {return x}, get y() {return y} } }
* don't worry about private vs. protected. that's not important and you shouldn't waste your time implementing your own versions of it. consider using a naming convention to distinguish the intended public interface from internal helper methods. it's popular to prefix an internal helper method name with an underscore to indicate this. * you might want to just go ahead and dive into TypeScript. more to the point though is that you simply don't have abstract classes in JavaScript. it isn't a thing. everything is an object instance. your more useful programming paradigms are going to be from functional languages where you're thinking in terms of closures and not in terms of classes. * I think you should set up a transpiler toolchain and play around with ES6 and also with TypeScript and see which you relate to more. ES5 is going to feel more like AS3 but is very different from what you've described as your preferences. 
Here's something different This 2D physics engine for JavaScript: [https://github.com/liabru/matter-js](https://github.com/liabru/matter-js) I've used it for a project before, and got to looking at the source code one day. It's structured similar to a typical C program but with objects used for namespacing. So the global \`Body\` object contains all of the "methods" for body objects, and the first parameter of each function is the object being accessed/mutated. It's basically objects without inheritance or abstraction, but since JavaScript has dynamic types you can mimic those concepts. It seems to have worked well for this 2D physics engine, but it's also something that works really well as a procedural program. This is a good example of a way to think in JavaScript that may not be applicable to all situations, but is fantastic for some. On a completely different tangent There's a really great JS package called \`async\`, which I've used to make very complicated code with multiple levels of nested callbacks become very clean and elegant. It provides structures for control flow, and calls your callbacks in the correct chain of events - so you can turn 6 nested callbacks into a list of 6 callbacks.
Yeah, thanks for clarifying. In Javascript, it's always 'pass by value'. And if you pass a non primitive (object, or array) the value references that object/array, so: var game = { count: 0 } var increment = game =&gt; { game.count++ } game.increment() // game.count === 1
You can use this as a key. And in unmount it could be removed - or maybe a weak map could be used however I’m not sure on those as I’ve never used them 
Hey NKC, sounds like I've made my opinion clear. Won't try to talk for anyone else. The reason there's a lot of debate on this topic is because there are now more options than ever to get things done on the web. It's really staggering how many routes you can go, and everyone's got their preferred method. One of the most crucial decisions a dev will make is what technologies they'll choose to use for their use case. And the new thing is to say "make everything an SPA!!!" and that's not really true. Some situations give clear preference to the template page model over a single page application. But I am of the mind that if one of the core features of your website is going to require DOM node creation (like a to-do app) then I would strongly suggest a modern framework, since that's like ... their core purpose.
When you say "real OOP" I think you mean to say "Class-based OOP". https://en.wikipedia.org/wiki/Object-oriented_programming#Class-based_vs_prototype-based JavaScript has objects, not classes. It is a multi-paradigm language which can support OOP through objects. Just because it doesn't follow languages like Java which is designed around and forces a class-based OOP approach does not mean it is not a "real OOP", just very different. Honestly though, I don't know what the obsession with OOP is, especially class-based OOP.
&gt; Encapsulation Encapsulation doesn't mean what you think! Encapsulation is about having objects hold their state and being able to handle them. JS has it so it does have encapsulation. It's not about making everything private. It's about not having conceptually related values spread across multiple variables. &gt; Abstraction. &gt; Interfaces. Stop. Interfaces are not the be-all and end-all of abstraction. Abstraction is a more... abstract thing. Needless to say you can use abstractions in any high level language. Interfaces aren't even about abstraction! Interfaces are about static typing and self-documenting code. You can do the same things with or without language support for explicit interfaces by documenting your code. &gt; epic fail my ass &gt; Inheritance JS has supported inheritance from day one. Once again you are talking about mainly static typing stuff, not OOP stuff. And you can even use typeof and instanceof and isPrototypeOf to test for class types anyway. &gt; Polymorphism. Polymorphism, in the context of OOP is a concept that only makes sense in statically typed languages because dynamic languages are polymorphic by default. Even so you can use typeof and instanceof, isPrototypeOf or hasOwnAttribute for polymorphism.
Read the series "You don't know JS". Realize there is more to this world that class-based OOP. Learn about the different options. This will improve your JS and overall ability as a programmer. After this, re-read these questions. Are they still the right ones?
This is nonsense. I literally did this just this morning.
You can keep the current function by doing this: increment (aValue){ aValue++; counter = aValue; }
I have a feeling some turn to their friend alcohol.
Well, I'm not an expert when it comes to parsing information. People who are smarter than me write a lot of these tools, so I'm going to say it's foolhardy to claim you know how the static analysis algo can do it or not do it. Just because you don't know how doesn't mean there are not ways of making a best judgement, or that a special flag can enable/disable this type of fuzzy acknowledgement to the ability to know it does or does not have one. It might provide a warning, that it's an idiomatic thing to provide, just warning you it didn't find one associated to the specific promise to catch, or if it find the callback somewhere does nothing, or atleast sends out a console.info/debug/statement. 
Sorry to have upset you so much by expressing my opinion. I don't believe I'm deluded, because I never suggested nor believe a framework is the only correct choice, but it's ok If I needed to be insulted twice. Anyway, I'm glad you have a system that works for you and your coworkers.
Before counter-quoting, you realize the 4 pillars of OOP aren't just 4 *words*, but 4 concepts that are summarized as those words, and further described. Your targeting of "inheretence" is the strongest piece, to me, that fails to capture that. &gt; Encapsulation doesn't mean what you think! Encapsulation is about having objects hold their state and being able to handle them. Eh? So "encapsulation = variables"? No. From Wikipedia with references: "A language mechanism for restricting direct access to some of the object's components.[3][4] A language construct that facilitates the bundling of data with the methods (or other functions) operating on that data.[5][6]" Moving forward... &gt; Abstraction I'll give "no contest" on this one. Perhaps it's more of "countless experts calling it something different" but I can't find any fault in your argument for abstraction except precedent. But to be honest, when referring to OOP, the definition given is usually: "In object-oriented programming theory, abstraction involves the facility to define objects that represent abstract "actors" that can perform work, report on and change their state, and "communicate" with other objects in the system. " (Also wikipedia) &gt; Inheretence C'mon. You're getting rude here. Do you have some personal skin in the game of Javascript strictly adhering to the term OOP? Second, I'll give in on this one. I don't like it, but some sources do consider "prototye-based" inheritence a subset of OO. But it *is* not cut-in-stone, either. &gt; Polymorphism You're agreeing with me here. There's really nothing to argue on polymorphism. Look, if *you* want to call Javascript properly OOP, you can... but you're nudging the term, and muddying the water. You can call Java "unctional" with the same logic, because you can write a bunch of functions that don't affect state. It's really not worth fighting over. Everyone has already done all that. https://stackoverflow.com/questions/107464/is-javascript-object-oriented with the best summaries being: &gt; So if your criteria for object orientation is the classic threesome of polymorphism, encapsulation and inheritance then Javascript doesn't pass. or &gt; As such, it is indeed somewhat subjective whether to call it object-oriented or not. or finally, siding with you: &gt; The term “object-oriented” was coined by Alan Kay in 1967, who explains it in 2003 to mean &gt;&gt; only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. (source) ...that last quote basically tells the 4 pillars to fuck off (almost literally, minus the swears). So this is where it's complicated. If you're using the formal definition of OOP that most people, especially coming from Java/C#/C++/etc use, then no, Javascript is nowhere near OOP. If you're using Alan Kay's 1967 definition, or get loose on the meanings of the pillars (or fuck em!) then sure, you can call it OOP. Back in college, I would've gotten marked points off if I said "yes" to javascript being OOP. 
Thanks for the responses, and the link to the guide. 
That would actually explain a lot. 
Can you elaborate what you mean by "in a general, attitude based-way"? It feels a bit strange to me that JS isn't purely functional/procedural, so I have to concern myself with knowing when to be in functional mode, and when to be in "OOP" mode. Did you experience that too? 
Your analogy about transitioning from C to C++ is helpful, thanks!
Dont listen to the typescript trolls - they are not answering your question. If you were asking how you can use JS just like it was java, then typescript is your answer. But we can do so much more instead. * Every js object is an interface - just rely on functions instead of data members * Try to avoid using "require/import" as much as possible. Make your code self contained, and pass in other interfaces to the constructor instead of directly requiring them. * Make unit tests for your self contained modules - good coverage is key * Consider using message based interfaces for even more flexibility * Take advantage of functional interfaces, such as set operations, promises, and RX A message based interface is much like a internal RESTful api. Rather than creating modules with lots of functions to call, try to make discrete actions which are represented by a message. For example, rather than API.setMemberValue(newval) you can do API.update({member: newval}) This allows you code to be split across process boundaries and even separate computers without needing to be refactored. The more generic, type-blind, and modular you can make your code, the less code you will have to write overall, and the fewer refactors you will need. 
It's called structural typing. It's awesome. Golang has it too. I think there's also protocols in Obj-C which is the same idea. Python lately is also trying to adopt protocols.
Since JS and most of the associated libraries aren't truly functional, you sort of have to pick and choose, and have a mindset towards functional programming. That's what I mean about attitude. If you have a functional approach to JS, there's nothing to force that, you have pursue it. JS works well with many functional ideas though, so it's worth it. Many functional programming ideas have been brought into JS. For example, map() and reduce() come from the functional world, and they are a godsend to JS. But, we're not fully functional, so things like implementing [monads](https://en.wikipedia.org/wiki/Monad_\(functional_programming\)) and going full Haskell, aren't necessary for JS. So, by attitude, it means, I'm going to be functional where it makes sense. For example, immutability is also a common paradigm you run into in functional programming. This causes functions to often be purely forward mechanisms, they have everything they need to calculate or perform and then pass the information forward without touching the data they are passed. Now in JS, since immutability is still new, this style isn't necessary, but once you adopt it, you see a lot of benefits. So to sum up, JS isn't really a strong, strict language, so you can write it in different 'styles'. Functional programming style isn't required to make a good JS program, but I feel it makes processes easy to follow, and taps into JS's strong points better than the OOP paradigm.
TL;DR; URLs are not simple strings, they are complicated structures, just like SQL queries. One should use specific tools to build them, and not only mash a bunch of strings together. Or: interpolate your strings. Sql queries, command lines, HTML, URLs, emails, headers and others all have their own escaping methods and you are open to attacks and bugs if you dont use them
I enjoyed reading your comments, thanks! It feels a bit unusual being put in a situation where I have to decide on a ratio of procedural : functional : OOP going into a project. So many people have said that the more "OOP" features of ES6 are syntactic sugar, so the functional part of me wants to keep away from them... but TypeScript is almost all sugar and feels closer to what I'm used to. 
It's [kinda complicated](https://medium.com/@fay_jai/react-elements-vs-react-components-vs-component-backing-instances-14d42729f62)
I meant not having a this is why I can't use them as constructors, anyway I am using 'class' now instead of using a function, much cleaner.
Lots of good points already, I'll add my 2 cents as I too recently went through this journey ( Java to react). Try not to hammer the OOP concepts here, js is fundamentally different. I am assuming that you'll be developing front end apps and not writing node based Backend. The rest of the post is based on that assumption. Conceptual differences that I faced ( in no particular order) 1. JavaScript is more functional in nature and that brings a lot of fundamental change. The "purer" your function, the better. Being functional also makes its outcome depend on execution context, particularly if you use 'this' Key word. I highly recommend reading "you don't know js" by getlify, it's freely available in GitHub. This also changed my opinion on unit testing. As the outcome is dependent on execution context, unit tests may not give you the guarantee that you would expect or desire. Try writing tests which mirror how your code would be interacted with, not how you wrote it. Don't worry there are libraries which help with that. 2. Conceptually thinking in UI is different from thinking in Domain. If doesn't necessarily complement each other and it doesn't have to. 3. I'm guessing you'll use a framework or a library, currently it would probably be a choice between Angular, react or Vue. They also bring their own way of looking at things, do pay attention there. For e.x. React recommends looking at your front end as if made up of components, each being responsible not just for their logic, but their "data" as well. It encapsulates them well. This is a huge deal, as it solves trying to fiddle with events and trying to synchronize your UI. It makes it predicable. I think Vue encourages the same, but can't be certain. Do take time understanding your choice, as a wrong one will become painful very soon. Some general recommendations, though many have suggested using type script, I would advice against that for now. Reason being, it may seem familiar and that can lead to a false presumption on your side. Also the journey you're taking will have a lot of different things for you to learn. Remember, you'll have to look for and learn the runtimes (node, browsers), build tools (npm/yarn), packaging (webpack/parcel), testing library, editor setup, language specs... All at once will burn you badly. I've excluded the terms that'll be thrown at you in every talk/blog post... SSR, isomorphic, web workers, wasm... Take your time. Learn one at a time. Static typing helps, but you can survive with a little overhead for a while, be it with tests or even using backbone (it's not dead, it's a time tested library. It works well). Overall, try not to over whelm your self. Would recommend steering away from experimental features in the spec for the same reason. They're experimental and can change heavily. This comment got longer than I anticipated. I'll close with a final recommendation, start with React, it has a gentler learning curve, allowing you to solve one problem at a time. Start with create-react-app to scaffold your project, it's opinionated but well documented and reasonable. It hides away the complexity of setting up Babel and webpack and such. Feel free to pm me if you have questions about my journey. 
I'm not the creator, but I think it's meant to copyright protected as each logo can be used by 1 project only. So the creator will waive the rights for that project, but no one else can it. Check this for context https://github.com/arasatasaygin/openlogos/issues/32
Thanks for the info. The bit about clashing private variables was very interesting.
You have to solve two problems: 1) Make sure your content is available to Google. If you are using angular in a single page application you will most likely need to use server side rendering (SSR) so that when google crawls `/reviews/photoshop-vs-gimp` the content will be rendered at the server instead of the browser using JavaScript. 2) You need good search engine optimization (SEO). Both of these topics are pretty deep.
Could someone explain this to me? Let's say there's an "entryway" into your app, but whether the data arriving from the outside is labeled as type `any` or `number` or `custom`, from thereon the rest of your code would then only have that much information, no more or less. So am I wrong for saying you &lt;don't&gt; have to build typechecking into every function in a paranoid way, and that you only have to build API *sanitation* into the entryway of your app?
Since OP asked specifically about OO patterns, I wanted to show that returning an instnace of an Anonymous class is possible. Also, it can be adapted to: `return new class extends SomeBaseClass ...`. OP might find that useful.
Actually: &gt; Javascript is always pass by value, but when a variable refers to an object (including arrays), the "value" is a reference to the object. So yeah, it's always pass by value but it is important to explain that variables with objects in JavaScript are actually pointers.
If your code is running on browser, it is compiled to just javascript. And other scripts may be able to interact with it, or users can view and edit the source
&gt;it seems like Z's core point is that There are currently more effective ways to do these things and JQ isn't the bes option. That is his/her opinion, yes. What Darlene and I are attempting to convey is that JQuery is a simple effective library for the job, and is a perfectly valid tool given the scope of the project. I think this would be a fitting analogy: Problem: There is a fire in the grass Solution 1 (vanilla JS): Stomp it out with your feet. This works on very small fires effectively, but you'll struggle if the fire gets larger. Solution 2 (JQuery): You look to your right, and you have a fire extinguisher. It's a handy tool that makes putting out small to moderate fires quick and easy, but you do have to go to the store and get an extinguisher beforehand. Solution 3 (Large Framework): Stop everything. Call the fire dept. They know the best methods and procedures for putting out this fire. Sure, it's a lot of overhead dragging out that engine, connecting everything up, and getting the crew on site, but by god that fire is going down. The task manager is a small grass fire in this example. It's fixable with all 3 solutions, however, some ways are "better" than others, subjectively speaking.
I actually was thinking about node as backend , i will check out express , to be honest there is so much frameworks and libraries sometimes i fell so confused and lost.
I do frontend not backend but it's really not that bad on our end. Our stack is basically React, Redux, React Router, webpack, lodash. What else do you really need to build an app? Occasionally we'll get clients who use Vue and the Vue CLI has been awesome. To keep up with new tools we have a dev meeting every two weeks where people present / discuss interesting stuff they've seen or have been working on. I'd say something like 90% of tools end up being in the category of "neat but we have a tested current solution", the other 10% we roll into our stack and use it moving forward. 
Well, you can change the ’class’ of an object after it was created. (on many js environments)
&gt; When you say "real OOP" I think you mean to say "Class-based OOP". In college, they used to teach the 4 pillars of OOP. They'd ask you things like "is Javascript OOP? Why or why not?" and you'd get points off for saying "yes" because it was a formal definition that wasn't being adhered to. Terms need to have meanings, so I figured that meaning didn't much change. By historical definition, Javascript lacks 2 of the 4 pillars. &gt; Honestly though, I don't know what the obsession with OOP is, especially class-based OOP. If you're raised in Java-ville, you think OOP is the sign of a good language. It's indoctrinated. You learn that dynamically typed is "scripting" and functional is "a toy". You don't look to learn how to properly use a new language, but how to do "the way I know" in the language presented. That OOP is such a big deal is *scary* because of what it means for code quality. If you can't embrace the paradigm of a language you jump to, then you're just going to write terrible code in that language.
In your code, the value `result.name` is inside of the `.then()`, so it's not available in the outer `__init()` function scope. Due to the asynchronous nature of Promises and async functions, `result.name` wouldn't even have resolved yet before the next line of code is called. To get around that, you can make your `__init()` function async also, and use the `await` keyword inside. ``` async function _init() { let result = await async1() // do whatever you wanted here console.log(result.name) } async function async1() { return { company: "company", name: "name" } } _init(); ```
yeah i saw that, but this assumes everyone has the authority to change lint settings within a project... if you work in a large company or team environment this may not always be possible, and you're often stuck with IDE defaults or a company standard or what have you. Though I suppose you could do something like maintain your own lint settings that extend the shared one and gitignore it.
I learned interfaces through TypeScript. I actually dont understand why it wouldn't always be this way? If an interface defines what a consumer can "touch" without implementation specifics, why would that only include methods and not properties? Do some languages use getters for everything?
Well I get all that from properly configured text editor
Right, that is what I meant when I said you have to have an awkward class definition. In ES2015 class definitions, doing this is even more ugly, because the `add()` function has to be defined and assigned to `this` inside the `constructor()` definition, not as a separate (normal) class method.
Thanks for your insight! I hope you don't mind if I pick your brain a bit. &gt;Our stack is basically React, Redux, React Router, webpack, lodash. What else do you really need to build an app? A year or two ago, that would have been Angular, Grunt (maybe Gulp) and Express. &gt;I'd say something like 90&amp;#37; of tools end up being in the category of "neat but we have a tested current solution", the other 10&amp;#37; we roll into our stack and use it moving forward. Does this ever lead to projects with dramatically different setups? That seems like it could easily turn into a maintenance nightmare if an older project isn't using the same tools/workflow as newer tools being built. 
A really short and incorrect answer below: \- In JS, classes are there just to keep state (they're a shim actually). JS classes are NOT module/path systems like they are in java; Statements below only apply to "functional pattern" (writing things not using classes at all). Which is only one of the patterns, but the most popular among libs: \- Internal private state is held by variables inside closures; \- Classes can be represented by a function which returns an object. This object's "methods" have access to the "private" vars declared inside the scope; \- "method overrides" could be achieved my explicitly passing in an optional argument to the function; Or by "monkey-patching" the returned object \- Since having a lot of arguments to a function is clumsy, we frequenly pass objects as parameters to functions ("option bag pattern")
Brad really has a great style of teaching, and that is also because he also learned by himself. He did not attend computer science.
&gt; You can use this as a key I'm pretty sure you can't. If you try to use an object as a property name, it will be stringified as "[object Object]" and therefor all such objects will be mapped to the same property. var x = { 'foo': 'bar' }; var y = { 'baz': 'qux' }; var mapping = {}; mapping[x] = 10; mapping[y] = 11; console.log(mapping[x]); // 11
Newbie q: How is this a singleton? ...because the private value is a const? I'm lost.
I'm wondering why this isn't getting more upvotes. Isn't this the 'correct' approach with Javascript?
Yeah and I’ve never heard of a situation where you can’t change your own ide settings but I see the scenarios you’re describing. In that scenario you probably couldn’t update your own gitignore either. You’d probably have to run a linter manually on the command line somehow
Yeah good point.
&gt; it's foolhardy to claim you know how the static analysis algo can do it or not do it. I mean, knowing whether `.catch` ever gets called on an object in any arbitrary program is a pretty simple example of solving the halting problem. You don't have to be any sort of expert to know that this is categorically impossible. I'm not suggesting that nothing is done, and I don't even care how it's done. I just want to know *what's* done. You're saying TS can catch an unhandled Promise resolution or rejection, but I don't know what that means. If it means what I think it means (what I'm suggesting), I'm 100% positive that's impossible. That's the kind of thing that *has* to be done at runtime. Googling "TypeScript unhandled promise rejection" just gives me the dynamic catching that Node does right now, which is where if a Promise rejects it will spit out a warning saying that an unhandled rejection occurred. This is not a TS thing and it is done at runtime. What I want to know is what you (and/or u/Bamboo_the_plant) are suggesting TypeScript can catch at compile-time. I imagine that it can catch whether you *ever* call `.catch` on a Promise object in a standard/static way, and if that's the answer, fine, but I just want to know that. That is to say, would ``` const p = returnsPromise(); if (true) { p.catch(handler); } ``` pass the TypeScript compiler? Or maybe the `catch` has to be in the same expression (seems very unlikely to be this simple, as then returning an unhandled Promise would be not allowed, which would be very inconvenient for APIs)? I'm just not seeing any documentation on this, so I'm asking what the claimed behavior is here.
But I’m not talking about using an object, I’m talking about using es6 Map which can have complex keys 
&gt; A year or two ago, that would have been Angular, Grunt (maybe Gulp) and Express. Right but the point is that you pick the right tool for the job. The move to React (I think) was more than just "ooh shiny". It provided actual benefits if it hadn't it would've fallen into the "neat" pile. There's also nothing wrong with continuing to use Angular if that's what you've started a project with. Just put an upgrade plan in place if you're planning to move forward with a new stack. &gt; Does this ever lead to projects with dramatically different setups? That seems like it could easily turn into a maintenance nightmare if an older project isn't using the same tools/workflow as newer tools being built. It hasn't so far but we're pretty good about upgrading our projects as the need arises and making sure that our projects don't really depend on each other. Honestly I might be at an exceptionally good company but we've never had a problem finding time to upgrade apps. It's part of maintenance just put it in the sprint and work on it like anything else. The other thing that I think is important is that if you know how to write javascript (not how to use frameworks) you'll be able to pick up most things in a few days so it's not really that bad to pick up a new tool. 
Z’s, as best as I can decipher, is that using the trendiest framework *du jour* is the correct way 
There is more than enough material for you to wade through here, so I'm not going to add more, but I wanted to thank you for your question. So many people coming from other languages immediately jump to the conclusion that Javascript is awful because it doesn't work the way they expect it to. Thank you for actually trying to trying to actually understand how to approach rather than just trying to jam classical OOP in and giving up in angry frustration. 
TypeScript gives you type safety from within your own code. If a third party is using your functions or classes, it is not restricted to the same type checking that you were when you wrote it. When I write `function doThing(p: number)` in TypeScript, I can only call doThing with a number parameter. Once I compile it to JavaScript and include it in a webpage, anyone can call doThing with any parameter they want, number or not.
You shouldn't do this. Just prefix your properties with underscore, that's the convention for private properties. There's a reason JavaScript doesn't have access modifiers.
Instead of TypeScript, you may want to consider Kotlin. I've been eyeing it for a while and like the idea, especially now that I'm used to transpiling and build chains for JS. Kotlin is aiming for a language that can compile to JVM, Android, JS, or Native. Plus it's one of JetBrains babies and I've been impressed by their tools. Still though, I haven't found a large use for classes and tons of OOP in JS. I look at Java now for "here's an excellent example of working in an OOP paradigm", but I still find myself moving more and more from iterative OOP to more declarative functional programming in JS. It really is multi paradigm, but that's also it's cost. It's not as easy to hang yourself like with straight C, but I've done a bang-up job many times. Many of my programs worked fine, but each different styles and designs until I found habits and tools I liked. Many love JS for it's adaptability. I feel it's a sharp double-edged sword. The community has made several solid libraries that can be leveraged for that though. When trying to switch mindsets, be prepared that if there are 5 ways to do something that will compile in Java with 1 right way for your situation, in Javascript you'll have what feels more like 17 ways to do something, 5 that work, and then will have to weigh them out. As for team: code style, frameworks, dependencies, copyrights for those depencies, build chain/tools/method can be very customized to the project. 
Err, just to be clear, do you mean like changing out a method on an object's class after that object is created? For example: ``` const obj = new A(); A.prototype.someMethod = () =&gt; 'new'; assert(obj.someMethod() === 'new'); ``` (this is also possible in Python with just `A.someMethod = # ...`) or do you mean you can somehow change what class `obj` is? I would normally agree with you that that sounds like it breaks traditional class-based OO, but I actually don't know how you'd do that in JS (Googling is unhelpful due to HTML classes), and it seems like [you can do it in Python](https://stackoverflow.com/questions/8062161/can-i-dynamically-convert-an-instance-of-one-class-to-another). The reason I bring Python up is not because I think Python is some paragon of OO but rather because I don't think anyone would argue Python has OO that's "not class-based". I think people tend to ascribe odd traits to JavaScript just because it's a little funkier ("prototype" not "class") but will happily let things slide when it comes to other languages that are made fun of less (Python being my favorite example for being extremely similar to JS conceptually but almost never gets made fun of/"design stress tested" for some reason). If you think Python also breaks "class-based" OO for either of these behaviors, I accept that as a valid definition of "class-based" OO, accept that JavaScript also breaks this definition, and weakly assert that no one in their right mind would do either of these things in 2018 (certainly not a classical OO programmer) so it won't really affect behavior in the real world. I actually find this really curious -- it looks like you can't do either of these things in Ruby (by language definition, though you can hack into it in some engines), which is the language I would be more keen to believe you'd be able to affect in this way than Python. I'm not sure whether that adds or subtracts points from Ruby for me. ;)
Definitely DON'T use TypeScript. It provides with the same mental model you've had. You will not improve that way. To learn ES, do ES.
This is why long term support (LTS) versions of node exist. Staying on LTS versions requires you to switch to a new major version only every few years.
Looks fine to me, though you should consider using await syntax for improved clarity. 
We all get developer fatigue, the start will be rough but just keep working and one day it will all click. If you choose React the more you will learn javascript if you go with angular the more you will learn angular. 
This is nonsense.
You can flatten your promise chain a little bit. (see [https://gist.github.com/AkyunaAkish/4ef6efd7240bf08913b232d4d5387f1d](https://gist.github.com/AkyunaAkish/4ef6efd7240bf08913b232d4d5387f1d)) but it is far from garbage!
&gt; Well, in modules The more usual, correct answer here is "with closures", not by creatively abusing modules.
That's what I thought but I couldn't figure out how to replace Promise.all with await.
Thanks for the link!
I've done (programmed and/or dabbled) anything from C++, Java, JavaScript, TypeScript, PHP to Bash, GWBASIC, Pascal, AMXX, PLSQL, Intersystems Cache, Groovy, C#, Haskell, Lisp, Prolog... I don't even see the code anymore, it's all just about the concepts, what they mean, how do they express in different languages. So: 1. How is information hiding implemented in ES6? - Closures, IIFEs, Symbol's... Forget out the "new" ideas of re-implementing what you see in Java/C++/AS in JS, you already know that, not much more (different) to learn that way. 2. Don't just love concepts, or you'll limit your self to only using it, what you love, and discard what is not. Think about it this way, in SOLID, I is for Interface segregation. What does it do? It creates many low count method bundles named interfaces... Well... that's just a short step of duck typing (you just don't write interface keyword). If you've trained yourself in not being secure / not patient enough about your self to write disciplined code, you can't appreciate what is and how duck-typing works. 3. &gt; I'm now having to write a very similar program in JavaScript and the first thing that comes to mind is -- how do I use JS to create something better? Well, forget about what you've been thought. If you want to continue writing the same style code, use the languages you already know. If you want to improve your mind view with something different, learn how JS came to be what is there now (see the Crockford videos about pre-ES6 JS for example, videos about more functional style JS like from Dr Boolean). NB: you can't love JS until you first hate it, it's just that gut punching... But, if you do survive through it, you'll have better understanding about programming concepts, even if you later go on to just writing TypeScript or any other classical (looking) language.
Yep there is certainly lot of benefits to using TS, but I don't see any of them in that comment.
I don't do server-side Node stuff, but that's definitely **not** "garbage". There's probably ways to flatten the logic a bit, particularly using `async/await`, but the code itself is fairly readable. Please don't be so hard on yourself :)
A flattened version might look something like this: [https://gist.github.com/jonnycook/aa11a015a3cd010fc2a4bf76cb32bcab](https://gist.github.com/jonnycook/aa11a015a3cd010fc2a4bf76cb32bcab)
I would would defeat that most big agencies etc aren’t that agile and a lot are still using old tech. And that’s simply because it’s much more difficult to change larger teams and bigger projects. I’ve no evidence for his other than my experience with larger companies in the past. You’ll probably find freelancers and small teams using the latest tech while larger teams are still using Joomla and jQuery. Just a hunch. 
That's much better, thank you!
Something like this: [https://gist.github.com/jonnycook/91151f99ec244b5b5ed8d27a7c58bfa7](https://gist.github.com/jonnycook/91151f99ec244b5b5ed8d27a7c58bfa7)
Good on you for posting the solution to your problem :)
think of it as of a huge pile of shit... or spend a lot of time and effort to get mentioned attitude 
Thanks, that makes sense. So to answer the other question, the return of the very last 'then' just goes and dies. JavaScript is weird..
psvm is now a function name(){code}
no triple tick support for code blocks here on reddit :( Need to indent by four spaces &lt;-- 4 spaces for code blocks
Simple, our new apps are written in react. Our slightly older stuff is written in angular, even older is jsf, and legacy is mainframe, and we just get to support it all...
VSCode is incredible. I recently started a small top-down shooter in JS and it went from 2 files, to refactoring it so each model was a seperate file and serving it w/ web pack, then changing each one to use ES6 imports. Throughout this whole process VSCode would intelligently move import locations or refactor variable names accross files, etc. Even give me hints that a file was included or not by presenting JSDoc if it succeeded. VSCode is dope
&gt; From what I've read, you're not supposed to be able to get info out of an async function Just out of curiosity, where have you been reading that? There's nothing preventing you from getting information out of an async function. They work like most other functions except you can pause and resume (like generators) and when they return, they always return promises that resolve to the value returned. This is how you're able to log `result` in `_init()` &gt; Does it just go off into the ether to die? In this case, yes. What's happening is that `result.name` is given back to the `then()` which then returns a promise resolving to `result.name`. Because you're not doing anything with this return value, to the ether it goes. You could capture that promise and do something with it... function _init() { let namePromise = async1() .then(result =&gt; { console.log(result); return result.name; }) namePromise.then(name =&gt; { console.log(name); }) } Or, which might be more common, return it back to the caller to let them deal with it if they want function _init() { return async1() .then(result =&gt; { console.log(result); return result.name; }) namePromise.then(name =&gt; { console.log(name); }) } async function async1() { return { company: "company", name: "name" } } _init().then(name =&gt; { console.log(name); }) The key thing to remember is that its all asynchronous, so to get any of that information you have to go through a `then()` or an `await` in an async function.
The big frameworks seems to have settled in with react and angular seemingly stable
Honestly, I don't know. But static analyzers are not always or even usually part of the compiler. The transpiler may not have that part. But a static analysis tool may have the ability to do it now or in the future. More stuff I don't know. I just don't like to say things are "impossible" since impossible often becomes possible with the right minds to something. For my limited knowledge on this planet, many things are impossible within the scope &amp; context of my own understanding. But for others, who are either more experienced or smarter, the impossible becomes possible. So..
I'm not suggesting that the js ecosystem doesn't change rapidly but for a little perspective on this issue, here are some release dates, they obviously didn't get adopted *en masse* straight away but still: - React: 2013 (~5 years) - Redux: 2015 (~3 years) - Webpack: 2012 (~6 years) - Lodash: 2012 (~6 years) - AngularJS: 2010 (~7 years) - Angular: 2016 (~2 years) - Vue: 2014 (~4 years) They're hardly old and there have been significant iterations on what they all were when they originally released (with the exception of lodash perhaps) but it isn't like we need to learn a new library every year. Vue is only recently starting to get mainstream adoption and has been in its current form for about a year or two. React had a pretty major internal change about 8 months ago but the API was mostly unchanged. React didn't get mainstream adoption for years either, all of these tools have reached a pretty good level of maturity recently (past year or so) with great tooling and extensions available. Taking these as an example, you'd probably be making a mistake to adopt anything major into your stack upon release unless it's really game-changing. &gt;A year or two ago, that would have been Angular, Grunt (maybe Gulp) and Express. All of these tools are widely used, they didn't suddenly become terrible, people just migrated because they felt other tools did just as good of a job and offered other benefits. Serious businesses/ teams only switched because they felt that these newer tools were an improvement on what they already had. Angular is a bit of a unique case but Gulp, Grunt and Express are still used heavily. As for node versions themselves, use an LTS release it will be supported for 3 years, plenty of time to manage an upgrade. And as for upgrading, you have to do this for security reasons regardless. Every year you see more important security patches being released for tools in every language/ ecosystem. Not upgrading because its difficult is not a good policy, if you're looking for stability you have to have some kind of way of upgrading your stack even if its just security updates. SemVer and good documentation and communication make working out which upgrades will break your code much easier, most of the above libraries generally don't break on upgrade or have well documented upgrade paths. The main problem with the Js ecosystem is not the rate of change but the amount of noise. The really game changing tools only come around once in a while, but a lot of people make a lot of noise about the next big thing. I think the biggest changes recently have been in tooling and development (arrival of Prettier and improvements to Webpack), as well as server infrastructure (the big serverless shift that is ongoing and popularity of static sites). The things that have excited me the most recently have been additions to the Vue and React ecosystems, with an emphasis on tooling and dev experience. All of these things are pretty optional 'nice-to-haves' rather than essential trends you have to keep up with.
Yeah I noticed that a few days ago. 3 months ago, it was within a reasonable container width.
Came here to say this too. async / await FTW
I work with some companies that literally re-write their website/app every year or two with the newest trendy platform/framework/library/etc. Other smaller companies are stuck using really outdated stuff. The current project I am working on for a startup is still using node 6.2.2 and Angular 1.6, and can't really be upgraded without a big rewrite due to package dependencies.
if you don't see sense, it doesn't mean it has none
... we could deliver portable js binaries ten years ago
Yeah, I get what you're saying. I like to err on the side of optimism as well, or at least acting on the presumption of ignorance when something seems uncertain. This is really not one of those things. We're sure that unless we come up with something more powerful than a computer (the human brain actually does not count as something more powerful), this is impossible. Turing proved it mathematically and if you could do this, it would be worth possibly trillions to the industry. There are heuristics that are even quite good, but it's mathematically impossible to show that any arbitrary line will be executed, so if you just replace that line with `p.catch(handler)`, you can prove that it is impossible to determine whether that promise has a handler. Moving along, I don't really want to talk about computer science right now. What I do want is to understand what Typescript does that you two seem to be claiming it does. 
From an OOP perspective, objects are modelled by what they can do. Enforcing a field/property would only really restrict how a method may function, leaving the details upto the implementation is more powerful I guess.
What reason is that?
&gt; Alright Java's a little different, Java's is not a *little* different, it's something completely different. &gt; My point was it's not TypeScript's it's exactly the same spec as typescript's decorators 
I think CDURF is talking about web-based RESTful APIs that return JSON data, rather than APIs in general. An API is an Application Programming Interface, which is basically a bunch of definitions that you can use to build an application. They take many forms, every javascript library has an API, that is it has an interface (methods or functions) that you call in order to interact with it. So an animation library might have a `Animation.swoosh()` method: this is part of the API for that library. I'm not sure which resources are best for learning how to work with web-APIs but there are lots of tutorials out there (check youtube). I think [Free Code Camp](https://www.freecodecamp.org/) has a bunch of challenges regarding web APIs too, you might find some fun projects there to challenge yourself and learn more about working with them. I'd recommend learning the basics of Javascript and its built in data structures (Arrays and Objects) before you start working with web-APIs as they will make a lot more sense if you have that knowledge.
Not to ios
I work at a large company and work with lots of JS, front end and back end. Short answer is to pick a stack and stick with it. Just because a new UI framework or state management library or build tool exists and is popular that doesn't mean you have to use it. Standardizing everyone on a few tools makes everything a ton easier, especially when it comes to the build+test+deploy pipeline. We ran node 0.10 for like 3 years, it was never really an issue. We've been behind on React for a year, it hasn't really affected us. Old React still works and has (mostly) the same API. Every once in awhile we'll take a step back and reevaluate but honestly we've got services in production using libraries that are older than a decade (Java services, not node), they still work fine and there's no reason to update them unless there's a security patch.
yes, to ios.
You decrease complexity in one place, you increase it in another. It's just the way it is.
Do you know any ES6/NodeJS at all?
I've been going about learning development the entirely wrong way by taking tons of courses, but not really making a lot of my own projects, the best resource I've found for modeling vanilla.js with the MVC pattern is https://www.udemy.com/the-complete-javascript-course
I have a passing familiarity with ES6 but have yet to invest the time in really learning it thoroughly. I want to soon, though. I have messed around with NodeJS a little bit: I have built a few super basic command line apps and I briefly experimented with Express. I had a similar experience with Node, though, where I felt I was lacking essential knowledge in "modern JavaScript" and familiarity with the ecosystem.
Oh, okay. Any good resources for that? I am fond of Mozilla's MDN, that's largely where I learned most of the HTML, CSS, and JS I know. 
Looks good to me. Nothing too fancy, gets the job done! Maybe you could use async await but other than that its good readable code.
Unless you have good reason to switch to node js, you should still be using java/c++ for your backend. Then all the data you pass to the page is public. After that, keep your js as simple as possible. The more you try to force it to work like those classical languages, the more problems you'll have. IDE's DON'T UNDERSTAND JAVASCRIPT! The myriad of shortcuts I use to navigate around a large java app, just don't work for js. Once in a while you get lucky with a piece here and there. But for the most part, they'll just send you somewhere you don't want to be. Eventually you'll get pushed into a technology like React, and you'll be forced to use js in ways it wasn't really meant to. It'l almost feel like you're learning it all over. Keep it simple and functional. Be consistent with how you organize your code. And, if you can do something in the backend, then you probably should.
I guess this is a secondary redesign then? I ended up applying some custom css to it but it still looks weird
&gt; Could five years ago we even dream about deliver working executables for all the major platforms without writing a single line of code that isn't JS? Yes. We didn’t just dream of it either.
Easily best comment in this thread; very pragmatic. Thanks for your input!
Just to note, Clang will complain if you assign inside of an if even though it's technically valid. It will ask you to put parenthesis around that expression.
Look up the UMD (universal module definition) syntax. It wraps library functions in an immediately invoked function expression (IIFE) which exposes only the functions you want to be public facing so you aren’t mucking up the global scope. The syntax caters to three of the most common module schemes, AMD, Node Modules, and CommonJS pattern. When I’m writing a library, I always use another, simpler library as a template. Sindre sorhus has a simple one called cows (https://github.com/sindresorhus/cows) that is nice. I’ve released a few as well which demonstrate the pattern pretty nicely (https://github.com/lacymorrow/movie-art). 
Yes, GCC will as well with `-Wall`. (unless by "complain" you mean "error") Warnings are the equivalent of linter errors, which JS does not have natively in any regard AFAIK.
Maybe this? https://www.youtube.com/watch?v=2LeqilIw-28&amp;list=PLillGF-RfqbZ7s3t6ZInY3NjEOOX7hsBv I haven't actually watched it but it looks like a good series. MDN is good if you prefer written tutorials/references instead.
Top guy on youtube, everything I have done is learned from his videos. Hes one off the very few I can watch in relation to programming tutorials 
At some point, you are going to need a javascript preprocessor for minification or for esnext features, you might as well use a dedicated bundler like [webpack](https://webpack.js.org/) or [parcel](https://github.com/parcel-bundler/parcel). You can write your project using es6 modules, and your build system can output a package for AMD, commonjs, traditional self-applying function (`(function(){...})()`) style, or [all of them simultaneously](https://github.com/umdjs/umd). You also get super convenient features like hot reloading and non-javascript asset handling/preprocessing as well
Nobody is forcing anyone to migrate or upgrade. Just use what works and upgrade when you need new features, to address security vulnerabilities, or when you have time.
You shouldn't use `new` here because there is no `this`.
You aren’t fixing anything, it wasn’t broken. You’ve changed your linting rules and you’re updating your code to be compliant. There’s nothing wrong with this, but usually you would decide linting rules based on developer preference, not on popularity. The Airbnb rules are the preferences of their engineers, not recommendations or best practices. 
You actually want to use a WeakMap, which can take anything for a key (even objects) and will gc the value when then key is gone (hence "weak", as it holds the reference weakly).
Use const unless you need to mutate the variable.
Uhhh IntelliJ? No?
Thank you for your reply! That was very helpful!
Jesus, calm down. I was never claiming Java is just a “little” different to anything. The syntax doesn’t belong to TS as could be implied by the comment, as I said, it’s not. It was borrowed from Python.
Thank you for explaining in such detail. That really cleared it up for me. I totally spaced about having the var counting as a param. That really helped! Thanks!
I've heard of scopes and I have also heard there are benefits, but I haven't learned much about them yet. I just starting the precourse work before I attend the web development bootcamp DevMountain. All of that stuff is to come. Thanks for giving me some further study. Much appreciated.
Ah I see now. When writing an app, typescript does indeed mean correctness, but when writing a library, it's still good to treat it as vanilla JS -- build type checking into your re-usable functions.
I believe it just enforces that they're handled in the same block. So it definitely prevents situations where they're unhandled, it just also prevents a lot of other situations that are really fine. 
I stopped reading after talking about "the 4 pillars of OOP" that don't even mention Objects.
Not because it's a \`const\`, but because it's declared at the top level of a module's scope, and modules are singletons. The use of \`export\` in the example is what gives that fact away: you only \`export\` from the top level of a module scope. I recommend experimenting with this yourself until you really grasp it intuitively, it will save you lots of pain down the road once you grok it. In my case, I began writing a client side React application using these module variables as part of state management, and then when I tried to get my application to run server-side it failed horribly and I had to do deep refactoring. In the client, the browser's per-page JS interpreter is a convenient place to stash globals and things that will still only pertain to the page; but in the server, the one JS interpreter is used for everyone. Hence, you can't use this sort of technique there.
I know a lot of people love async/await, but async/await isn't a magic bullet. Not that it's not necessarily the right answer, I just don't understand why any time someone posts a question about promise code, the immediate response is "just use async/await." Anyway, enough rant What a lot of people don't realize is that promises can be returned in a promise chain to flatten them. What does that mean? Well, you don't have to do: function doThingThenCallback(callback) { somePromiseThing() .then((data) =&gt; { return someOtherPromiseThatUsesOther(data) .then((moreData) =&gt; { callback(moreData); }); }); } doThingThenCallback((dataIWant) =&gt; { console.log(dataIWant); }); Instead, you can do this: function doThingThen() { return somePromiseThing() .then(someOtherPromiseThatUsesOtherData) } doThingThen().then((dataIWant) =&gt; console.log(dataIWant)); At work, I've had to coach a lot of people on how to use promises effectively, because they weren't really taught how to use them properly, and how they can improve your code. I think a lot of people are told that promises can help you avoid [callback hell](http://callbackhell.com/), but when they write promises, they fall back into the old callback pattern, completely missing the point of promises. Even in my example, I removed 3 levels of nesting. Yes, async/await can do mostly the same thing, here's what it looks like: async function doThingThenCallback(callback) { const data = await somePromiseThing(); const moreData = await someOtherPromiseThatUsesOtherData(data); callback(moreData); } Is it better? At this point, it's mostly opinion. Technically, both have a callback, the promise just lets you set it later with a follow-up `.then` call. I think if you don't get promises, work on understanding them (including asking lots of questions :D) before adding async/await, which can be used just as improperly as plain old promises. Oh, did you know async/await is just sugar over promises? Yup, an async function, behind the scenes, is a [generator function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*). A generator function is a type of function that can be paused and resumed later, keeping it's scoped data after a resume. Generators use an iterator mechanism, and in the case of async/await, the iterator is a promise that is chained off the previous promise. Sorry for the tangent dive, let's look at your code and do some cleanup. router.post('', passport.withRole('admin'), (req, res) =&gt; { let addresses = [] let contacts = [] if (req.body.addresses) addresses = Address.validateAddresses(req.body.addresses) if (req.body.contacts) contacts = Contact.validateContacts(req.body.contacts) Promise.all([addresses, contacts]).then(([validAddresses, validContacts]) =&gt; { return Vendor.create(req.body).then(vendor =&gt; { let bulkAddressPromise = [] let bulkContactPromise = [] if (validAddresses.length) bulkAddressPromise = Address.createAndSet(req.body.addresses, vendor) if (validContacts.length) bulkContactPromise = Contact.createAndSet(req.body.contacts, vendor) return Promise.all([bulkAddressPromise, bulkContactPromise]).then(() =&gt; { res.status(200).json(vendor) }).catch(err =&gt; { throw err }) }).catch(err =&gt; { throw err }) }).catch(err =&gt; { res.status(500).json(err) }) }) Let's clean up some of the initialization code first: router.post('', passport.withRole('admin'), (req, res) =&gt; { let addresses = [] let contacts = [] if (req.body.addresses) addresses = Address.validateAddresses(req.body.addresses) if (req.body.contacts) contacts = Contact.validateContacts(req.body.contacts) This pattern looks maybe wrong. [Tell don't ask](https://www.martinfowler.com/bliki/TellDontAsk.html) might be a good approach here. Address.validateAddresses and Contact.validateContacts should maybe be able to handle their empty-cases rather than your routing controller: router.post('', passport.withRole('admin'), (req, res) =&gt; { const addresses = Address.validateAddresses(req.body.addresses); const contacts = Contact.validateContacts(req.body.contacts); I see another similar pattern up ahead, so let's bring that in, too: router.post('', passport.withRole('admin'), (req, res) =&gt; { const addresses = Address.validateAddresses(req.body.addresses); const contacts = Contact.validateContacts(req.body.contacts); Promise.all([addresses, contacts]).then(([validAddresses, validContacts]) =&gt; { return Vendor.create(req.body).then(vendor =&gt; { let bulkAddressPromise = [] let bulkContactPromise = [] if (validAddresses.length) bulkAddressPromise = Address.createAndSet(req.body.addresses, vendor) if (validContacts.length) bulkContactPromise = Contact.createAndSet(req.body.contacts, vendor) Before we refactor, I'm going to change some styling of the promises. This is just my preference, but I think it makes the chaining easier to follow: router.post('', passport.withRole('admin'), (req, res) =&gt; { const addresses = Address.validateAddresses(req.body.addresses); const contacts = Contact.validateContacts(req.body.contacts); Promise.all([addresses, contacts]) .then(([validAddresses, validContacts]) =&gt; { return Vendor.create(req.body) .then(vendor =&gt; { let bulkAddressPromise = [] let bulkContactPromise = [] if (validAddresses.length) bulkAddressPromise = Address.createAndSet(req.body.addresses, vendor) if (validContacts.length) bulkContactPromise = Contact.createAndSet(req.body.contacts, vendor) So let's apply ask don't tell again: router.post('', passport.withRole('admin'), (req, res) =&gt; { const addresses = Address.validateAddresses(req.body.addresses); const contacts = Contact.validateContacts(req.body.contacts); Promise.all([addresses, contacts]) .then(([validAddresses, validContacts]) =&gt; { return Vendor.create(req.body) .then(vendor =&gt; { const bulkAddressPromise = Address.createAndSet(req.body.addresses, vendor) const bulkContactPromise = Contact.createAndSet(req.body.contacts, vendor) Remember how I talked about promise chaining? Let's flatten this out a bit! router.post('', passport.withRole('admin'), (req, res) =&gt; { const addresses = Address.validateAddresses(req.body.addresses); const contacts = Contact.validateContacts(req.body.contacts); Promise.all([addresses, contacts]) .then(([validAddresses, validContacts]) =&gt; Vendor.create(req.body)) .then(vendor =&gt; { const bulkAddressPromise = Address.createAndSet(req.body.addresses, vendor) const bulkContactPromise = Contact.createAndSet(req.body.contacts, vendor) Now let's close this off: router.post('', passport.withRole('admin'), (req, res) =&gt; { const addresses = Address.validateAddresses(req.body.addresses); const contacts = Contact.validateContacts(req.body.contacts); Promise.all([addresses, contacts]) .then(([validAddresses, validContacts]) =&gt; Vendor.create(req.body)) .then(vendor =&gt; { const bulkAddressPromise = Address.createAndSet(req.body.addresses, vendor) const bulkContactPromise = Contact.createAndSet(req.body.contacts, vendor) return Promise.all([bulkAddressPromise, bulkContactPromise]) }) .then(() =&gt; { res.status(200).json(vendor) }) .catch(err =&gt; { res.status(500).json(err) }) }) So another thing is that we don't seem to care about the result of the validate functions, just that they don't throw, and we're creating a lot of variables that maybe are okay to be inlined, so let's do a little more cleanup: router.post('', passport.withRole('admin'), (req, res) =&gt; { Promise.all([ Address.validateAddresses(req.body.addresses), Contact.validateContacts(req.body.contacts), ]) .then(() =&gt; Vendor.create(req.body)) .then(vendor =&gt; { return Promise.all([ Address.createAndSet(req.body.addresses, vendor), Contact.createAndSet(req.body.contacts, vendor), ]) }) .then(() =&gt; { res.status(200).json(vendor) }) .catch(err =&gt; { res.status(500).json(err) }) }) That doesn't look awful, as far as node controllers go. And it's not too far from the code you posted, so good job :)
Ah ok gotcha. I took your "map" more generically instead of the es6 map object. Also, yes I see now that WeakMap would indeed do the trick here. Cool.
&gt;Is it better? At this point, it's mostly opinion. Yes. Objectively speaking it is better. It accomplishes the same thing with less characters, and more clearly conveys the flow of logic. There is absolutely no debate: await/async is far better than promise chaining.
Thanks, I'll check that out for sure!
thanks, that's very helpful. 
I like to use MVC when doing Vanilla JS apps. It really helps things scale and stay organized. 
Is less characters better? Is the logic _more_ clear? The points you make can't be made objectively. I don't have a problem with async/await, and it's fine if you think it's better. My point is that this is programming preference, but more importantly, if you don't understand the underlying mechanism of part of a programming language, you're likely not to well understand the sugar that's been put on top of it.
So this thing uses Google Analytics to understand the pathway through your app your users take most frequently and lets you prefetch that content so you have it around. Interesting idea, I just wonder if the value it provides is tangible.
As much as they are trying to get you to think about JS as classical dont...its prototypical in nature and should be understood as such to avoid issues down the road. 
&gt;Is less characters better? All else equal, yes, the less characters, the better. &gt;Is the logic *more* clear? Yes, that was part of my previous argument. The logic is *far* clearer. The function of await/async syntax is basically self-evident, whereas that is not the case with Promise logic. Await/async syntax follows the normal flow of procedural code -- Promise logic involves callbacks, and therefore is not obvious as to when the code may be executed. Await/async is a more declarative syntax, and as a rule declarative syntax is easier to read. It is so clear to me that await/async syntax is superior that I'm surprised I even have to make any of these points. \&gt; if you don't understand the underlying mechanism of part of a programming language, you're likely not to well understand the sugar that's been put on top of it. That's absolutely not true. A person can use await/async without understanding Promises, just as a person can use ES6 classes and not understand the prototype chaining. In both cases, the syntactic should represents a much more accessible abstraction.
I've been wanting to try TypeScript for a while, but manually adding types and verifying their versions is a huge pain. Is there anything out there that'll do this for me?
Everything is is an instance.
I see... But what about where it's just a wrapper for callbacks? function p() { return new Promise(r =&gt; setTimeout(r, 1000)) }
Like 3/4 of your points are demonstrably wrong, unless you're maybe using a super old version of Ember for some reason?
I don't want to argue with you, but I do disagree. &gt; &gt; Is less characters better? &gt; All else equal, yes, the less characters, the better. You are saying `let i` is better than `let index` because there is fewer characters? Less reading does not mean more readability. I'm not saying it's worse, I'm just trying to make a point, and it's okay if you want to continue to disagree on it, too. &gt; &gt; if you don't understand the underlying mechanism of part of a programming language, you're likely not to well understand the sugar that's been put on top of it. &gt; That's absolutely not true. A person can use and understand await/async without understanding Promises The OP made it clear my point is true, as their immediate question after being suggested async/await was: &gt; That's what I thought but I couldn't figure out how to replace Promise.all with await. That all said, I'm not saying that async/await is better or worse, just saying it doesn't have to be the only right answer. So taking my final code refactor, let's see what it looks like as async/await: router.post('', passport.withRole('admin'), async (req, res) =&gt; { try { await Address.validateAddresses(req.body.addresses); await Contact.validateContacts(req.body.contacts); const vendor = await Vendor.create(req.body); await Address.createAndSet(req.body.addresses, vendor); await Contact.createAndSet(req.body.contacts, vendor); res.status(200).json(vendor); } catch (err) { res.status(500).json(err); } }) What makes this code better? Do you think littering the code with a bunch of `await`s is better than littering with a bunch of `then`s? I'm not saying one is better, I'm rhetorically asking if it actually is better, and the only one that can really say is OP, because it's their code, and they have to maintain it.
Generally speaking there is a very high bar for implementing any sort of switch. It can't just be "this is a cool new thing", there has to be tangible benefits to switching and the cost to switch must be outweighed by those benefits (and usually pretty heavily too). LTS (Long-term Support) versions of Node are almost always what companies are using (at least for production purposes). Same holds true for other packages -- if it doesn't provide a tangible benefit (like some new functionality you _need_ not just want) then it will stay untouched.
You're right, fixing isn't the right word. However, as someone relatively new to JS I feel like their style has helped me improve my coding habits immensely so I feel a sort of duty to conform to any new rules they come up with. The new rules also make a lot of sense in terms of readability and maintainability (only one jsx expression per line, and always restructuring this.state and this.props at the top of the function).
It doesn't die, it becomes the resolved value of the promise returned by `.then`. If you want to access it, do something with the return value. Otherwise it just gets garbage collected like any other ignored value.
I like OO because I find it to be a higher level of organization. The inheritance vs composition stuff is just advanced ctrl-c to me, or advanced code re-use, which is only an okay "force multiplier" for productivity. But for organization I like to think of apps as the sum of communication between objects, hopefully linked together in a causally unidirectional manner.
&gt;I don't want to argue with you, but I do disagree. Why not? Discussion is the best way to arrive at the truth. &gt;You are saying let i is better than let index because there is fewer characters? I'm saying if all else is equal, less characters is better. All else is not equal in the example you gave, as less information is conveyed by "i" and by "index". &gt;I'm not saying it's worse, I'm just trying to make a point, and it's okay if you want to continue to disagree on it, too. I'm familiar with the dynamics of a debate. &gt;The OP made it clear my point is true, as their immediate question after being suggested async/await was: No, the OP did not make it clear your point is true, as we don't know what kind of instruction OP has been exposed to. A person could be taught await/async without any knowledge of the underlying mechanics, and be able to use the feature just fine. The fact that OP didn't know how to use await/async is merely suggestive of the fact that he has never properly learned the feature itself. &gt;What makes this code better? Everything I mentioned in my first comment. The flow is obvious and is similar to what a person would expect coming from a procedural background. Even if they haven't encountered the syntax before, they'll likely be able to understand how the code will execute at first glance, which simply would not be the case for the corresponding Promise version of the code. Also, there's less syntax for the brain to process, which decreases the mental load. And it's not accurate to compare the word "await" with the word "then", as the Promise syntax comes with *a lot* of additional characters.
Yes, if you have a large C# server side project, then using TypeScript can be a way of getting consistency across code bases - so you don't have to think differently when crossing them. That's definitely a point of advantage in my current code base.
Protocols are in swift, obj-c does have something of the sort in a very infant stage. Most would describe swift as a protocol-based language in fact. 
I suppose that does strictly answer the question, so fair enough. The point I would make is that maybe he's better off with TypeScript so he basically doesn't have to "think differently" to solve the same problems.
This. Absolutely this. Best answer that could possibly be given.
Yeah, but many requests include query string params so why not include them? They’re as critical to some requests as request headers are to others. And yet request headers were included but not query string params. I think that was a very poor decision ... Thoughts?
next, do a jsperf between each of those. for science. I have a sneaky suspicion that the latest and shiniest may not be the fastest, but it's hard to predict if you're not obsessively tracking what V8 has been optimizing lately. 
I don't think async/await and promises is a one is right, one is wrong situation, especially when examining a small corner of someone else's code. I personally think reading promises is nice, I can see a logical chain of code, it is ordered, and I think it can make handling chained exceptions nicer. &gt; And it's not accurate to compare the word "await" with the word "then", as the Promise syntax comes with a lot of additional characters. In the background, `await` is using `.then`, these are literally the same thing, but the async generator wrapper is hiding this. This has nothing to do with character count, I'm just making an observation that both async/await and promises both come at the cost of extra code to deal with asynchronous functions. I'll say as much that yes, async/await means less function overhead - plain old promises do need callbacks, and some people may not like that, and using `await` hides and manages those functions behind the scenes.
Think of it as a language designed to handle simple mouse click events and not much more. Then think about all the frameworks thrown on top of it to try to make it a little better for real application development, but then realize that none of those frameworks are designed to work together. Sigh... 
&gt;I don't think async/await and promises is a one is right, one is wrong situation, especially when examining a small corner of someone else's code. Yup. That's the debate we're having. I disagree with that. &gt;I personally think reading promises is nice Not really a valid argument. &gt;I can see a logical chain of code, it is ordered, and I think it can make handling chained exceptions nicer. All of which applies to await/async, to *at least* the same degree, with fewer characters. &gt;In the background, await is using .then, these are literally the same thing, but the async generator wrapper is hiding this. I'm aware of that, however we are having an argument about syntax, so whatever happening in ther background isn't relevant. &gt;This has nothing to do with character count, I'm just making an observation that both async/await and promises both come at the cost of extra code to deal with asynchronous functions. It has *everything* to do with character count, as I'm making the observation that async/await performs the same function with *fewer* characters. That is literally the entire premise of this discussion.
This. My team has a rather large (and esoteric) Node.js production environment, and we standardize on Node LTS for our engine. We make sure to pretty strictly require exact minor semver on our dependencies (`~x.y.z` instead of `^x.y.z` like npm does by default.) Now that npm 5 and 6 provide security auditing, we use that to stay up to date with security patches and alert us when updating might break things. All these practices help cool the coffee of otherwise fast-paced JS ecosystem developments, while not leaving us so far behind that we're missing out on performance and security improvement.
If you're trying to do this without having to give into the world of Babel, webpack, parcel, and all that other fun stuff, then what you really need understand is Immediately Invoked Function Expressions", often abbreviated as IIFEs. Basically, they are the pattern you described above. I'd recommend the whole *You Don't Know JS* series by Kyle Simpson, but if nothing else, you should read [this chapter](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch3.md), which goes over IIFEs in depth. On top of that, if your library is of any significant size, you may want to look into minification as well. Learning ES6 is definitely worthwhile, but it's no small undertaking. I wouldn't wade into that world if you're just trying to package a library you're already happy with, but over the long-term I'd definitely recommend it if you want to write JS in any serious way. This is both because ES6 brings with it a lot of nice features that really make life easier and because it's going to be harder and harder to find resources as the community moves on with the newer iterations. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [getify/You-Dont-Know-JS/.../**ch3.md** (master → f0d591b)](https://github.com/getify/You-Dont-Know-JS/blob/f0d591b6502c080b92e18fc470432af8144db610/scope%20%26%20closures/ch3.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e158cfo.)
Were still using Node v4 at the company I work for. lol
Sounds like an opportunity for TypeScript to add some more magic syntax to preserve type checking post-transpilation, in cases where you’d like it enforced.
are you saying js doesn't adhere to your/Wikipedia's definition of abstraction? any constructor function, class, or object can fit all pieces of that much at least 
That's a great idea. It would be fascinating to see the performance impact of the learning curve.
It sounds like you're at the point of maybe wanting to consider a framework like react, angular, or Vue. Some may jump on me for going to frameworks straight away, but this is exactly the problem they are meant to solve. The general idea is to break things down into modular components that you compose together to create more complex behavior. It helps to break things into smaller, more manageable chunks so you don't have to try to hold the whole app in your head at once. 
You can simulate C++ inheritance by writing your own features while wait with vanilla features, I've done that to some extend. I think it's worth using class in ES6, the trend is going definitely toward features that allows you to have a cleaner and more opti code (Types, Promises, Class, etc) and I don't want to be stuck with prototype inheritance when they make the jump to a better an more advanced inheritance because I didn't prepare it. Don't forget to look into WAsm, I plan to do that since they will add DOM support for Wasm at some point.
This hasn't been true since Babel 7 went into beta.
Look at jquery on npm. It's a good example of a UMD module. It even has type definitions! 
What would be the gut punching for you ? TBH, until wasm can handle the whole website, I'm not switching back to c++ for websites.
I haven't proofread this yet, just finished it yesterday but maybe it will help. http://imperativedesign.net/insights/the-anatomy-of-an-ngmodule-and-how-they-differ-from-other-js-modules/
But how does TypeScript make the transpiled JavaScript use private/protected methods/variables for the classes? When you figure that out, just use that instead.
I’m currently working as SPA architect in a bank, and is really hard to upgrade stuff and settle some patterns for the company. Not everyone follows it, and the big purpose is: dates. Everyone has a release date to it’s project, and the managers of this bank are just thinking on release the projects ASAP, so the released projects are really bad in quality (Like no unit testing, pretty big components, projects with just one module, nothing modularized). So, if we try to improve too much, people won’t follow the trend. We usually stick into the LTS and when a major release of some framework comes out, we start some tests to see the impacts on the projects and we make a wiki telling what people should keep an eye on (right now we are testing Angular 6, aiming on Angular elements and Angular schematics)
It only checks if a rejected promise is handled. If you call reject you need to handle it. It doesn't explicitly account for unhandled errors and doesn't care about resolved promises. That being said I'm not 100% familiar with this so I'm probably not going to have answers for edge cases. 
thoughts -- for js libraries in the past I've usually used rollup. It usually results in smaller builds than something like webpack and less code/work than something like grunt or gulp. There are plenty of other tools out there I'm not familiar with, but if I was starting from scratch on a library today it would use rollup. It sort of assumes you are using `import` and `export` syntax. One of the problems you may encounter for interoperability with some frameworks is the use of things like `window` and `document` which may not exist on the server (i.e. for server rendering).... I'd make sure you're awful careful about checking `typeof` on document/window before actually using them. i.e., if in your library in the mainline you do something like `document.addEventListener('DOMContentLoaded', () =&gt; {})` and someone doing react server rendering tries to import your module it will promptly explode on them during start up. By `mainline` I mean any code that runs when your module is required. It's ok to export a function that references the dom.... usually for react ssr, the best bet is to put any initialization code for external front-end libraries in `componentDidMount` which confirms you now have access to DOM - and that's where they'd call your function that references dom.
The compiler enforces private and protected members.
sooooooo.... this is what I have so far - https://pastebin.com/dCPA5z6n let's say I wanna use vue... how would I incorporate my code with vue?
my short answers: privacy: leave it behind... any you get will be illusory abstracts/interfaces: write functions and either call them in a wrapper function that can chose which sub-functions to call in which order, or with which arguments to pass them, or or to permute the arguments or alter/ensue their types... or enforce contracts within them... (default values, check if are certain values present, or the right type... generally don't assume you got any values or that they may be invalid, but do embrace the flexibility of passing objects or functions ( which can accept varying numbers and types of arguments into one function ) as arguments ) use js to iterate on AS3: not sure if you mean something flash-like, in which case... svg is useful, but libraries like d3(and extensions), threejs for 3d, phaser(or many others) for games... are super useful otherwise learn good habits, use === and !== (they do what you think == and != do) read something like "Javascript patterns", use modules or at least the module pattern to avoid polluting the global space, don't use for-in over arrays unless you hate speed, use eslint in your editor with as strict an profile as you can stand, use strict mode where your usecase doesn't preclude it, maybe adopt a minification tool like google closure (other options are available), maybe a compatibility tool like babel... don't taking any one of us at our word... as a community we're a fragmented bunch of hermits with chips on our shoulders from no one thinking we're "real"
Oh i've tried. There's always some other plugin that might work.
Really love this idea! Nicely done. 
Howdy. &gt; How is information hiding implemented in ES6? There is no native support for private and protected properties with ES6 classes. Do I consider adding them? If not, how do I architect my programs without such a fundamental OOP feature? Private and protected properties are part of Typescript, so you may find it more comfortable to go straight to that. But I can answer your question with ES6/ES5. A lot of stuff enforced by C/C++/Java and other languages did make it into ES6 (like the class keyword) but ultimately, there were a lot of design decisions in Javascript to *not* require the safety of other languages. That said, programmers have come up with conventions to help with this. For example, if we want to keep something a property, we don't set it as a property of an object. We use closure to encapsulate it (often using currying). Some programmers are in the habit of prefixing variables that we want to be "private". ``` const memoize = (funcToMemoize) =&gt; { const _hash = {}; return (...args) =&gt; { let argKey = JSON.stringify(args) if(!_hash[argKey]){ _hash[argKey] = funcToMemoize(...args); } return _hash[argKey] } } const square = (x) =&gt; x * x; const memoSquare = memoize(square); memoSquare(9) // 81 memoSquare._hash // undefined. ``` In the above function, we can't get access to _hash, but the hash exists. That said, if we *wanted* to write a method that allowed us to get access to the hash... ``` const memoize = (funcToMemoize) =&gt; { const hash = {}; this.getHash = () =&gt; hash; return (...args) =&gt; { let argKey = JSON.stringify(args) if(!_hash[argKey]){ _hash[argKey] = funcToMemoize(...args); } return _hash[argKey] } } const square = (x) =&gt; x * x; const memoSquare = memoize(square); const otherSquare = memoize(square); memoSquare(9) // 81 memoSquare(2) // 4 memoSquare.hash // undefined. memoSquare.getHash() // {"2": 4, "9": 81} otherSquare.getHash() // {} ``` So, how does this happen with classes? Well, keep in mind that the "class" keyword in ES6 is just syntactic sugar for the pseudoclassical pattern. So these three code snippets do pretty much the same thing: ``` // class keyword class Dude { constructor(name){ this.name = name; } speak = () =&gt; { console.log(`Hello, I'm ${this.name}`) } } const kevin = new Dude("Kevin"); kevin.speak() // $&gt; "Hello, I'm Kevin" ``` ``` // Pseudoclassical Pattern const Dude = function(name) { this.name = name; this.speak = () =&gt; { console.log(`Hello, I'm ${this.name}`) } } const kevin = new Dude("Kevin"); kevin.speak() // $&gt; "Hello, I'm Kevin" ``` ``` // Prototypal Pattern const Dude = function(name) { this.name = name; } Dude.speak = () =&gt; { console.log(`Hello, I'm ${this.name}`) } const kevin = new Dude("Kevin"); kevin.speak() // $&gt; "Hello, I'm Kevin" ``` Notice that the prototypal pattern (in many ways, the *preferred and canonical* javascript way of doing things) requires that the language *doesn't* support encapsulation, as you can assign a new method or a property to an object without problem. This does make it possible to overwrite properties - and if you're working with a multi-programming team, namespace collisions could happen. That's why the underscore convention got instituted. ``` // class keyword class Dude { constructor(name){ this.name = name; this._age = 1; } doBirthday = () =&gt; { this.age += 1; } speak = () =&gt; { console.log(`Hello, I'm ${this.name}, and I am ${this._age}`) } } const kevin = new Dude("Kevin"); kevin.doBirthday(); kevin.doBirthday(); kevin.speak() // $&gt; "Hello, I'm Kevin, and I am 3" kevin.age = 5 // does not throw an error. kevin.speak() // $&gt; "Hello, I'm Kevin, and I am 3" kevin._age = 5 // JS will not prevent you from doing this, but by convention, you don't. kevin.speak() // $&gt; "Hello, I'm Kevin, and I am 5" ```
&gt; I loved abstract classes/interfaces. They enforced contracts on objects so I could create reusable code to operate on them. I understand that JavaScript is duck-typed, but in the absence of interfaces, I can't architect my software like I used to. So how does JavaScript want to think about my software? At what point, and using what criteria, should I consider using a library/language that gives me those features and transpiles? To add abstract classes and interfaces to Javascript, use Typescript. There's really no way to enforce contracts in vanilla ES6. 
Yes, use a framework. I prefer Mithril.js, it's all what you need for a SPA. In addition, it's supper fast and just Vanilla js.
Depending on what you're working on, OOP is much less needed in javascript than in other languages. I very rarely use it in client side web page logic, for example. Sure, I could create a Javascript Class called Carousel for a simple image slider, but most of the times I just create a small object with a couple functions that finds carousel divs and sets up the right event listeners in its children. It's fast and effective. When in doubt, keep it simple.
That was a great read, thanks for the post! 
At the moment I'm on a phone on an airplane with quite a bit of turbulence, so I'm not in a position to write much. Also, I know absolutely zero Vue (I work mainly in react), so I can't help specifically there. I do know Vue is a really great choice for this sort of thing and it's documentation is very friendly and easy to understand, it's just not something I've worked with yet. I'd recommend going to the Vue web page and walk through some of their guides. If I remember correctly, they have interactive code examples that you can play with directly in the documentation so you can get a feel for how things work on the fly. Either way, looking through any code I write is going to be next to meaningless to you without at least a rudimentary understanding of how the framework works
Humor me - how long have you been developing? 
Build fast. Build often. Pipelines. Docker.
HTTP2 does offer additional features and performance, but it's not a magic bullet, it does not increase speed exponentially and while it does offer push, that push still requires manual configuration. But ultimately, unless you api is the world's shittest and slowest thing conceivable, most of the benefits of guess can simply be achieved through asynchronous component loading. Global modules and code split into vendor and app, while unique component or route specific code sits in separate chunks. Now if you had an app that say had a charting library that was only applicable to 1 section or page, if it where an important page you'd shift that code into vendor, but if not, guess could help improve performance further in those cases. Assuming it works well, it can remove the need for someone to sit and scour analytics to determine if d3 should be in vendor or chunk, is this page visited significantly often enough to justify the cost to those who do not use it for the benefit of those that do, often no. Something like guess could step in determine the chain that would lead to this page and reduce, hopefully greatly, the amount of users we punish with the additional d3 payload. In a world where performance is king, any tool that helps improve that, even marginally slow without any adverse impacts to the process or other users is a valuable one.
I actually feel the API itself is just badly designed. It will throw an exception for some times of errors. But not all types. So you see examples everywhere that catch() but don't actually detect all errors.
Stick to the LTS releases if you're worried about node. Properly version your dependencies at particular versions *while making time to upgrade some weeks after a major release*. Otherwise, stick to libraries backed by Big Co or where there is a community consensus (ie: many Github stars and an active maintainer). The ecosystem has crystallized a fair amount and there isn't nearly as much churn as in the prior few years. You'll likely use React / Vue / Angular. You'll likely use Webpack. You'll likely use one of 2-3 testing frameworks. You'll likely use one of 2-3 http frameworks. And so on.
We still use backbone with marionette and underscore. Quite old stuff. But gets the job done. Although we are looking into moving our UI over to VueJS in the near future.
The world is running on legacy software. Lots of folks want to try out the latest, sexiest tools, but many of us spend most of our days working with tech that no greenfield project would even consider.
That was tru couple years ago - today platform provides native solutions (Babel fills the gaps most of the time) to problems that query solved back in the days (and hat off to jquery for that). Many “jquery developers” doesn’t even know what progress native platform made over a course of time...seems like they don’t care and shovel unnecessary kB into users throats...
Thanks for sharing this great list!
Great, and here's what I think: that adding this will slow down your app as much as it'll speed it up. Instead of using rocket science to figure out if you have to preload a 5kb module, it's better to roll it up into the initial app where after compression it'll become an even smaller 2kb, and so yeah... KISS.
Don't switch versions if you don't have to. That's really all there is to it. For example, Angular 1 is still receiving regular security updates. Smart teams avoid unnecessary changes, and they pick libraries that allow them to do so.
Been there, like some people here suggest it might be interesting for you to switch mental models for a more functional programming or even [reactive programming](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754) mindset. I find [flux (unidirectional data flow )architecture to be pretty neat too](https://github.com/facebook/flux), if your building web apps. About **information hiding**, [this nice article points out how you might do i](https://itnext.io/a-minimal-guide-to-ecmascript-decorators-55b70338215e)t with property descriptors, and also how it could be made easier in the future with decorators (still in proposal stage in ECMAScript, but advanced) \`\`\` var myObj = { myPropOne: 1, myPropTwo: 2 };// modify property descriptor Object.defineProperty( myObj, 'myPropOne', { enumerable: false } );// print property descriptor let descriptor = Object.getOwnPropertyDescriptor( myObj, 'myPropOne' ); console.log( descriptor );// print keys console.log( Object.keys( myObj ) ); \`\`\` 
It's also (technically) less efficient. When you use prototypes, you share references to the same function. When you create functions like you did above, you create a new versions of those internal functions each time you make a new `Foo`. Not always a huge deal, but something to keep in mind. 
Prevented this, yoda conditionals would have.
It's important you look at JS in terms of 'what is cool and unique about JS and not how can I replicate x, y, or z from Java, or C, or C ++. First off JS has the most reliable and user friendly dependency systems of any language. If you're like me and you used to lose whole days fighting with maven or gradle you'll absolutely love NPM. It just works. Second of all the way JS handles concurrency is fantastic. Not having to worry about thread management takes a considerable cognitive load off your plate. Quite frankly even in Java Composition over Inheritance is a well established pattern nowadays, and javascript is phenomenal at doing that because functions are so easily appended to classes and objects! Even better try a functional approach! There are some very cool libraries like \[ramda\]([https://ramdajs.com/](https://ramdajs.com/)) which really encourage functional programming and make it easy to see some of the power of the paradigm. TS is good, but let's be honest this sub is HIGHLY biased in favor of it (sometimes for good reasons, sometimes for not so good reasons) and in my experience many people try it and just continue using bad OOP patterns as a crutch. I encourage you to give vanilla JS a chance. 
That should work — please include some example code!
This is the only way to declare instance variables class Foo { constructor() { this.myVariable = "some string"; } } All other alternative are transpiled by babel and or not in the language specification yet
Honestly, I'm sick of style rules. Show me logic bugs, show me performance hits (The latest thing is that console.log prevents GC of referenced objects) and better ways to do things.
 class Foo { set(val) { this.value = val } get() { return this.value; } } const f = new Foo(); f.set(true); console.log(f.get()) f.set(false); console.log(f.get())
Here's my opinion, You should, if you are really need mobile apps and dont know the java/kotlin/swift/objc, I made few apps using react-native, im really bad at design so i use community component like shoutem and nativebase at the same time. and the result was ... suck, the performance wasn't great, because i had so many community component, and lots hacky stuff. 
Just posted some sample code in the original post.
You're setting the variable inside a closure so 'this' is not what you expect. Try binding the closure to 'this'
Thanks! Doing that fixed the variable issue. All those hours wasted for something that trivial, ugh. Still not sure about the function problem though. When I call otherFunction() ( even after switching to the arrow syntax ), its says otherFunction is undefined. Any ideas on that one? Thanks again.
It's something needs to be tested on a case by case basis, it will either help or hinder, being in alpha, it will almost certainly hinder, but it could have potential with a large scale app, you don't do this shit on your blog The one we working on at work, we probably around 5 to 7 % of the way through the entire scope, and maximum compression, chunking and bundling gets our essential payload down to 1.1mb, the idea behind guess, could have performance advantages down the line for something of this scale, for us not likely as the chunk splitting has been designed in part for performance, but around permissions and access to remove major sections that are almost certainly not going to be accessible to the base use access levels. As it stands now scanning analytics will give it a small piece of the puzzle and the logic you really need is "what is the current active user likely to want" and that shit you are not sticking into js into the users payload and then expect performance gains. What you getting with this amounts more to tree mapping than machine learning from point a, users when to b or c, if they went to c most users moved to x or z and so on, further down the tree the smaller the potential directions become, and that's a simple example, what about a massive news site when the options from point A are b through Z, how do you guess where this user will go, without knowing who the user is, Google has stalked us for long enough so take a site and a user, feed that into GA and pretty sure google could work out based on who you are, what you've done and where you are now, what is most likely to be next, taking 25 directions and turning it into 2 or 3. Based on the description og guess it's effectively building a predictive map off your site map. But this is just the first step, I have not seen any other attempts at something like this for Web, and who knows, it could be the next step in performance for Web once it's able to outline these routes without impacting the user, we easily looking at 2 to 5 years before we have beneficial applications for something like this, but everything has to start somewhere. Hek, for all we know once it hits production it somehow generated a map of a 1000 possible directions based off 10 possible entry points and it's taking like 5kb of payload, but improves user engagement 20% and reduces perceived loading time by 99%. We just don't know what can happen, as I said about with the 1.1mb website, it was 1 pluggin, brotli compression in webpack that did that, it was 8.4mb before, and that pluggin actually got it to 1.5, I went through the way I had setup the bundle splitting and optimized that further and got it to 1.1, all of that potential, starts with ideas and attempts like this.
I'm grateful to have been able to play around with an emerging spec in babel. But the TC39 proposed decorators spec now [looks completely different](https://github.com/tc39/proposal-decorators) from the one implemented in `babel-plugin-transform-decorators-legacy`, which hasn't [substantively changed since 2015](https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy/commits/master/src/index.js). Yet the legacy version is still explicitly recommended in blog posts like this and in many APIs (e.g. [mobx](https://github.com/mobxjs/mobx#observable-state)). I'm worried when decorators eventually make it to Stage 3 there is going to be a ton of Twitter rants about how the legacy syntax worked fine for years before TC39 screwed things up.
Try \`this.otherFunction()\`
You laugh, but we still have some minor applications (non-critical) running on v0.12.18. The upgrade is fully developed, but no tester available to verify full regression on it 🤷‍♂️
ES classes are still a work in progress, with multiple proposals at stage 3, meaning they're likely to make it into the standard once any remaining kinks are worked out: - https://github.com/tc39/proposal-class-fields - https://github.com/tc39/proposal-private-methods - https://github.com/tc39/proposal-static-class-features Obviously they would be nice to have now, but to do so you would need to transpile. Babel is one option, but as everyone has already been telling you, if you want something that has had these features for a while and also includes interfaces and all that other good stuff, Typescript is what you want.
Thanks, that worked! You probably just saved me another 5 hours of getting nowhere :)
I'd be more inclined to suggest using closures, android either classes or functions with prototypes to create a pinch and private set up, rather than modules, because it's easier to have multiples instances of a constructed function - obviously you could still use a module to hold this 
If we're being picky, arrow functions don't bind `this` at all - they just don't have their own `this`, so you end up with `this` referring to the same `this` that's outside of the arrow function. If arrow functions bound `this`, then you'd be able to modify the reference to `this` by using `call` or `apply`, but that doesn't work.
Would you wrap the whole class in a closure ? If so, then that closure wouldn’t be instance aware of itself. Would you place it in the constructor ? Then you would only be able to access the private variables in the constructor. If you expose any of those variables (by for instance setting this.) then they are no longer private. If you have to wrap the whole module in a closure then you are not gaining anything over just using the module level closure that is automatically provided.
Thx mate for the links.
Wasn't this possible in ES3: var flatten = function (arr) { return [].concat.apply([], arr) } ES6: const flatten = arr =&gt; [].concat(...arr)
I would say, having used both, that the first thing you need to do is understand that JavaScript whilst object oriented, is not a classic oo language, and works in a basically completely different way. It takes time to understand the approaches involved bit a good understanding of the base types, objects, and prototype system is the best way to get going.. In terms of what to do, typescript is a way to go, but I think it'll deprive you of fully understanding the language - you'll be a typescript developer, not a js developer. Try something like flow, which allows to write is with a type checking system, but doesn't fundamentally change the existing language. Gives you a crutch of the strong typing you're used to, without abstracting you from the fundamentals. If you want to use js, you can just hack away at it, but if you want to know it, there are some odd paradigms to get used to. They are useful though, so I'd say do that
See the answer from /u/dvlsg, I was a little off on my comparison between binding and arrow functions
It's a cool idea and really nice logos. But in the spirit of open source, wouldn't it be appropriate to share the "source-code" for the logos and not just the .jpg ?
I didn't realise this, thanks :) 
Yes!
No, I'd create a function and export it, and then put "private" functions within the constructor, and public functions as members of the prototype. That way, an instance created with new get all the public methods the constructor has access to private methods, and an instance exports no private methods It has downsides, like public methods than need access to private functions having to be passed them by the constructor, but it is actually rarely necessary to do this. Alternatively, module exports closure, closure returns public methods, but not private ones. Neither solution is exactly like say, Java classes, but it's ok.
Good post, but it furthers one common misconception about the AirBnB post that I see being spread now: &gt; AirBnB [will] stop using React Native and remove it from their codebase, in favor of traditional Swift/Obj-C/Java/Kotlin development. The crux is in the word “traditional” here. If you read the last part of their blog series, you’ll notice AirBnB are using some very high-level, custom-built library for building UI components now. That’s good for them, it’s native Swift/Kotlin, but I would hardly call it traditional. Also, you’ll see they’re investing in server-rendered pages, where basically JSON definitions from the server will decide what native screens should look like. To me, that sounds really interesting, and it might be a better approach if you got the infrastructure in place. But those things combined make it sound like they’re not really moving back to the “traditional” way of building native screens using MVP or MVVM patterns as are quite common on those platforms, and which would be a big step backwards coming from React Native, in my opinion.
Good point. I’ll update the post. 
Outdated != Doesn’t Generate Profit
Yup, and the proposal has been at stage 2 for almost 2 years now. They're obviously not coming in a hurry, so it doesn't seem prudent to rush to use them. I'll continue waiting patiently while they presumably get the design right.
For such simple tasks, Redux is not very effective. For example, there is https://github.com/acdlite/recompose. It provides the ability to manage statr in Redux style.
This is my first NPM package - so ALL advice/criticism is welcome! Also - I'm not very good at semver :-D
GeaphQL is good for React. Due to the fact that the query structure is the same and can be comfortably changed, it can be fine-tuned for React by installing the appropriate PropTypes. The ability to choose the required data for a client is convenient for API management on a variety of platforms.
At the start of the year we talked about how we need to upgrade to 10 now that it's the LTS. We've kept pushing it off because there always seems to be more important work. The reason we have been avoiding it is that there could be changes with any one of the npm packages we use and we don't want to risk breaking things. We're still using a lot of older versions of many NPM modules too. And some of the npm modules we have made minor tweaks to locally to fix bugs or make them work better for our particular use cases.
We tried out RN at my former company about an year ago, made several POCs and were quite pleased because we had no mobile experience and only knew JS. But once we’ve gone deeper down the rabbithole and started to put everything together, we found the performance to be really bad, especially on older devices. Aside from the performance issue, we had to struggle with learning the iOS ecosystem by bits and pieces, because RN was not really as advertised, and for many of the modules you had to dwelve into the build phases of XCode and learn how the tooling works anyway, maybe read some native code from some bridge libraries. So we went with starting to learn swift and make it native. It led me to believe that it’s not for JS devs that want to make mobile apps, but for native devs that already know the tooling, ecosystem and native components, that want to build cross platform apps. I think it can work well for simple apps, with a bit of patience from the devs, I would choose it for that. But then again, I’m not really familiar with the latest developments, maybe many issues and bugs were fixed in the meantime, and my points are invalid, just my experience with the product.
Pulled my punches way ago, the only way I could do so many different languages/frameworks. Would love to be able to do some wasm, by hand even, but currently they're positioning it for transpiling large legacy applications, the memory hungry ones of the games kind. Soon, though, hopefully, it might be able to provide some language explosion/innovation like the JVM did 10 years ago.
Maybe they are better of. The only reasonable way to know it is for them to try something different and decide for them selves. Well, they can also go the dogmatic "not invented here" approach, but... then they will not even need OPs question to begin with.
Even if "latest and shiniest" is not fastest today it's only a matter of time as they are constnatly optimising the latest stuff.
Why `[].concat.apply` and not simply `[].concat` ?
You're only 20. Why not go get a degree? It's the best way to become one imo. I started at 21 and I'm graduating in 2 months :)
So just a quick question: yesterday React Native was the future and everybody should learn it, and now that a company stopped using it people question if it's not so great anymore? I understand why js libraries have so short life span then.
`[].concat(arr)` will add items of the array into the new array. If the item of the array is also an array, it will just be added as-is into the new array.`.concat` won't look at nested arrays within the array (which is the purpose of flattening). `.concat` is kind of unique in that it can accept any number of arguments, which may or may not be arrays. If it's an array, it will "look" one level deep into it. [1].concat(2, 3, 4); // [1, 2, 3, 4] [1].concat([2, 3, 4]); // [1, 2, 3, 4] [1].concat(2, [3, 4], 5); // [1, 2, 3, 4, 5] [1].concat([2, [3, 4], 5]); // [1, 2, [3, 4], 5] So these are all the same: [1].concat(...[[1, 2], 3]) [1].concat([1, 2], 3) [1].concat.apply([], [[1, 2], 3]) Spreading the array feeds each item of the top-level array (each of which is an array) into `concat`, which will add each item of the subarrays into the new array, thereby flattening it. `.apply()` is the ES3-way of spreading array values into a function as separate arguments.
Yes it is entirely possible to teach yourself everything you would need to know in order to become a successful web developer. I did it. Lots of people I know have done it. It's not uncommon at all. As for how long it might take you, that's hard to say and entirely up to you. All of the information is out there on the Internet available for free. You could learn CSS in an afternoon. HTML might take a couple days. JavaScript might take you a few weeks or months to learn the basics. Or maybe you need more time than that to fully understand all the technologies and how they work together. That's OK...if you keep moving forward eventually you'll get it. I wouldn't say there are "too many" web developers. Web development is huge and only getting bigger, and lots of companies are constantly hiring web developers, so there is no shortage of jobs. That's certainly true in the US and probably true in Croatia as well. As far as getting paid, you will find a wide range of salaries at different companies depending on what they're looking for. As a junior web developer in the U.S., you might expect to make $30-50K per year. As a senior software developer, maybe $80-120K. Those ranges vary wildly depending on which region you live in. I'm a senior software developer doing pretty well for living in South Florida, but I would need to be making about double my current salary in order to live comfortably in Silicon Valley.
as someone else said, you can consider a degree in computer science but you can also do a degree in math or physics and then pursue web development learning on your own. learn javascript, pick up a framework like react, learn webpack, node or some other system language, i recommend go, learn sql and you’ll be quite competitive out there already. plus, you’re young so being able to prove you got determination for self improvement is a huge plus. 
Alright! Thank you for your reply!
&gt; A library is just a bunch of code someone else wrote, which has some useful functionality that you can use. It might handle animations or maths or just about anything else you can think of. Libraries have an API, that is a bunch of methods you can call to make use of all that functionality. Most libraries have some kind of 'API Reference' which is Okay, thanks! 
This was a bug in one of the very early versions of JavaScript IIRC. I believe it was added to the standard later once people started using it that way. If it makes you feel better the base prototype of all objects is null at the end of the chain.
try this one: https://www.freecodecamp.org It a good resource and it's compatible with a job
I don’t think are really implying that you shouldn’t learn React Native anymore. In AirBnb’s blog post, they clearly stated that react native didnt work well for their unique use case. They also pointed out that smaller companies who start off with a fully React Native codebase may not experience the same problems AirBnb did. 
As opposed to using React, Vue, or Angular like every other to-do list app tutorial? Get off your fucking high horse bud, there's nothing wrong with jQuery.
TC39 tried to fix this bug, but it broke too much stuff on the web. Historically, in early JS versions, each value had a type tag, inside a 32-bit value. And null was zero. By accident, the type tag for objects was also zero and null wasn’t special-cased during `typeof`. Details: http://2ality.com/2013/10/typeof-null.html
Thanks a lot for the insight man
Im awful at math and physics,which is why i didnt go to college,do u think that will hold me down if i start learning on my own
Run this on your browser console: var a = {a:'a'}; var b = {b:'b'}; var c = {c:'c'}; console.log(a.a, a.b, a.c); Object.setPrototypeOf(a, b); console.log(a.a, a.b, a.c); Object.setPrototypeOf(b, c); console.log(a.a, a.b, a.c); 
Being awful in math / physics is just like being awful in JavaScript : lack of knowledge, not intelligence. You can do it just like anyone if you learn !
You don't. ES6 modules are nightmare fuel in Node. I'm joking a little. The ES6 module has to be saved in a `.mjs` file (no `.js` will not work), and then you need to run Node with the `--experimental-modules` flag.
I have nothing against libraries, I've used them myself. But doesn't anyone write their own js anymore? I mean, develop and entire project from start to finish without libraries. Maybe I'm just being cynical. But I thought the point of developing for the web was to not be dependant on one ecosystem. Instead, projects have adopted new dependencies. Excuse the hijack.
I like to write the way I want to read any article. That's my style. It's all about decorators, but you wouldn't be able to understand without knowing some background about Objects. Anyway, it's always good to learn something extra.
i don’t think computer science is enough. you will hit a plateau very quickly if you can’t apply your computer knowledge to solve real world problems. you mentioned web development but nowadays everything commercial relates to web. webdev with a business degree could open a lot of opportunities. it depends what you want to do. perhaps that’s the most important. there is nothing wrong with being self taught though, absolutely not. if you’re bad at school and you think you’re wasting time you can definitely move in your career in webdev by learning on your own. 
[removed]
Boldly renamed the JavaScript AI Mind as **[First Working AGI](http://ai.neocities.org/FirstWorkingAGI.html)** with link to **[MindForth](http://dl.acm.org/citation.cfm?doid=307824.307853)** First Working **[AGI](http://agi.topicbox.com/groups/agi)** for robots. One AGI enthusiast **[tweeted](https://mobile.twitter.com/rplevy/status/1008979273766486017)** his misgivings. 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://agi.topicbox.com/groups/agi) - Previous text "AGI" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
It's much simpler than that. Arrow functions just don't have a "this" to refer to, just like an 'if' statement doesn't. From there it's just basic scope inheritance
Because in JS everything is actually an object - not a bug, just lazy
Take a look at the various Elastic Stack products. Filebeat, logstash, elastic search, kibana etc might work for you and are retry easy to set up especially if you're using Docker. 
&gt;but whether the data arriving from the outside -- processed by your typed function -- is determined by TS to be type any or number or custom, from thereon the rest of your code would then only have that much information, no more or less. You've got things a little bit backwards. Typescript adds only \*static\* type checking to JS. It enforces type correctness at compile time, before the code is ever run. It cannot type check things "from the outside" such as from a network call or user input. That data is generated at run time. This means you will need to parse and verify data in your "entryway" logic to ensure that it is in the correct format. After that, however, Typescript can be used to enforce types statically, that is, before your code is even run. 
No, the point of developing on the web is to curate and share information. The implementation isn't as important as the result. If you see a lower barrier of entry, then you should take it if it gives you the result you want (aesthetically, functionally, etc) . 
True! I thought I could't use array methods because I'm working with objects... but of course they are still elements of an array! Makes sense now! Thanks for your reply. 
I disagree - there will always be performance increases and better legacy support when using native swift/Java/kotlin. Anything outside of the normal component pool especially if they are memory heavy will perform 1000x better than RN or Ionic. Not a step back if they are running into performance or compatibility issues. 
Thanks a lot for your reply! It has helped me to view arrays in the broader scale of their application, outside of simple exercises. 
No worries. It can sometimes be hard to understand why you're doing something at first, exercises like this often seem so simple and don't do a very good job of explaining why they are asking you to do something in a particular way. You're doing the right thing though, asking questions to fill in these gaps is the best way to maximise what you get out of simple exercises.
Thanks for your reply! It helps to view the array of objects as a list. Makes a lot of sense.
This was our experience at my previous job. RN seems great for getting a new project off the ground fast, but if you're building any kind of serious app, you're going to have to deal with the native stuff anyways. Ended up being less work to just build 2 native apps.
Thanks a lot for your reply. It has really helped me to form a better understanding. 
Yes! I just learned about constructor functions and prototypes yesterday. I've started to adjust my code accordingly. 
I think they just wanted to see if we understand what methods are and how to include them in objects. I'm now trying to improve my code by using constructor functions and adding the methods as prototypes. 
Brad is great. But make sure you play his videos at 1.25x/1.5x speed to get some extra efficiency on learning :P
IMO, ECMA shouldn't have classify `null` as one of the primitive types. A `null` should be a value of `object` type. Meaning that it's an empty object, or a reference which points to nothing. If `null` is really a primitive type, where the heck is its `Null` constructor? 
I'm not saying that `null` is a primitive type, I'm rather saying its a type of its own (just as `undefined` is a type of its own separate from `object`). And besides, its not me who is saying this, but this is what I get by running `Object.prototype.toString().call()` which is probably the most standard way of type inference in the JavaScript world: Object.prototype.toString.call({}) //'[object Object]' Object.prototype.toString.call(null) //'[object Null]' Object.prototype.toString.call(undefined) //'[object Undefined]' As you can see, when you pass any object (such as `{}`) to this function, it returns an `Object` type, but also returns `Null` and `Undefined` as separate types too.
&gt;Typically, intro would be defined on a prototype so that only one copy of it existed, but it was available to all Student objects. This would still be the case using the example that /u/kr3wn asked about (barring the point about it being defined on the prototype). It could be defined once and available within that modules scope or anywhere that imports it. Except for react components I haven't written OO JavaScript for a few years. I get more reuse by working with plain objects (data) and writing collections of simple functions that operate on the data passed to them. I'm still a relative newbie to functional programming, but I find it more satisfying and less maintenance burden than a sprawling OO architecture with multiple levels of inheritance. 
It sounds like that's because you're comparing good functional programming to bad OO programming. They're two equally valid paradigms.
I think `in` there meant "input". But in JavaScript, parameters are passed by values, so there should be no `out`, making `in` a bit redundant. Anyone has any idea?
This isn’t JavaScript, it’s Web IDL, which is used in browser specs. I think `in` distinguishes input parameters from output parameters. https://heycam.github.io/webidl/
This isn't really any more informative... \`\`\` function p() { return new Promise((s, j) =&gt; { if (Math.random() &gt; 0.5) { setTimeout(s, 1000); } else { j(); } }; } \`\`\` Still a wrapper and definitely not an edge-case: this is something libraries need to do constantly. Do you have any documentation for this? I'd prefer reading that.
Oh of course, don't know what I was thinking. Good catch!
When the hype was on, a lot of people started to use react native because it's cool, and blazing fast, and react devs can make "native" apps, and acted like this is the best thing that could ever happen to developers, but when the hype is over people suddenly start to reveal that how immature it is, and its performance issues, and how react developers actually struggle with it, and how it breaks on random shit, and native devs are required to be involved to fix it. I'm mad, because companies tries to ride these hype waves hoping that they will bring in clients or increase performance, but when things like react native happens the developers pull the short straw, and things like airbnb is needed to stop management to believe in bullshits like this. 
I wasn't disagreeing. I was actually agreeing that there's an inconsistency within the JavaScript specifications. As for `undefined`. It shouldn't be classified as a primitive type too. Just like `null`.
I sped up the matching for my [regex compiler](https://jasonhpriestley.com/regex) with a little [webassembly](https://jasonhpriestley.com/regex-dfa). I also started documenting my new approach to UI development called [flows](https://jasonhpriestley.com/flows).
I tried a react native app and did not enjoy the experience. There are too many native things to wire up. I think going forward our use case is best with ionic. But every project has different needs.
Oh... weird. Thanks!
All right, I admit that that I was a bit ambiguous in my comment, my intention wasn't that you were disagreeing. It was my own confusion about whether `null` could be classified as a primitive or a complex type! And yeah, the same goes for `undefined` although I don't think the inconsistency is with the specification, but this one odd `typeof` implementation. Indeed, as /u/pilotInPyjamas explained in their comment, the spec doesn't matter here as the implementation drives the spec. In this case, error was in the browser implementation and by the time they realized, it was too late for the spec to change the implementation, so they instead changed the spec to account for their mistakes!
What are your issues? Syntactically, PHP are both very similar C-style dynamically typed languages.
Don’t know why you would downvote this other than out of ignorance.
I might agree with you there... as bad functional programming is worse, IMO, than bad OO. So it might make sense to start with OO. I definitely took a "level up" as a developer when I learned it. But I do wonder what would've happened if I'd learned FP first... 
What about `undefined`? What about infix functions like `+` or `*`?
I’m having trouble finding the right way to express what I want JS to do. Conceptually, in PHP, I can think “if I need this, then I define this, and say this”, and can come up with a solution to the problem quickly. With JS, I know where to start with the function and defining variables, but then get lost with output of the function on the same page. 
Don’t be obtuse - you wanna “typeof +”?
The output is the DOM, unless you're working in Node.
We’ve been using Datadog successfully at work, especially useful for easy dashboards and reporting. The per host pricing can get a bit steep however and I am not sure how it works with lambdas. Prometheus / Grafana can be self hosted and give you very similar results if price is an issue.
That's not obscure. Lots of other languages allow for operator overloading, and in a number of those, functions are first class objects. It's not particularly far fetched to assign the function `+` to a variable and use it.
Flows look awesome, dude. Great work.
Not obscure - obtuse Question was about typeof returns - how will you do “typeof +” So your adding stuff that you can not do typeof on - that’s just obtuse
The original reply was not about things that you could call typeof on, it was a reply to you saying that everything is an object.
Dude read the actual title!
document.querySelector('.css .selector #here').innerHTML = yourOutput
Dude read the actual title!
I was replying to your comment, not replying to the OP.
So context does not matter for you I recon. Weird trait for a programmer.
Threw the keys of the object? Or an Array of Objects?
Or like anything that has only existed for a few years, it has its advantages and over time, we come to see some of its drawbacks. Nothing is a one size fits all solution in development, but people on the internet tend to paint things in broad strokes, whether its hyping something up or tearing it down. 
Personally I wouldn't use either and use a defer attribute on your script tag instead 
`button.onClick = null`? `button.onClick = () =&gt; {}`?
Second this! Finding the right teacher, and good old fashioned practice is all you need to get better at math. It’s just a skill :) 
You can at least test JS in the chrome console, but for it to be useful, the DOM and Node are your best platforms/entry points for sure.
We've been using Librato (SaaS statsd) for years and have been very happy with them. Also believe DataDog and New Relic have similar offerings. 
I don't know where you're located, but some people I know took some courses at algebra (https://www.algebra.hr/cjelozivotno-obrazovanje/programi-obrazovanja/) and found jobs.
Modern browsers remove the event listener upon destruction of the element as well. Older versions of IE could have memory leaks from this, unless the reference to the dim node was also destroyed: https://stackoverflow.com/questions/11838457/why-does-this-code-cause-a-memory-leak-in-ie/11838510#11838510
I am building a changelog system. A system used to structure and manage information for those of us that have very complex or many different projects to manage. One part of this system is to produce documentation, Developers sometimes need to create documenation on how to use what they are building. A task that may not be that fun to do. The changelog system have logic to produce docs where it is all about speed to do it. It also has logic for non registered user to access parts in changelog system to read information on what they might be interested in. Here is a sample on what I did yesterday, tested the perfect-scrollbar on github [Changelog: Sample code to use perfect-scrollbar on github](http://goorep.se:1010/changelog/report/rselect/page_result.htm?alias=guest&amp;query=Book+pages&amp;$TArticleBook1.ArticleBookK=2024)
Webdevs feel intimidated by the landscape, and defer judgement to external sources for protection from technical liability. That's why everything on this subreddit is libraries and frameworks, 'wheel reinventing' is shunned, and popularity is the ultimate guide for choosing technology. Safety in lack of thinking for yourself.
`button.removeAttribute('onclick');`
I'm sure /r/LearnJavascript has a good number of resources for you.
Maker Links are small buttons / badges in the bottom right of all of Pieter Levels' websites that when clicked opens a new tab and takes you to his website. Back in April he released a \[GitHub gist\]([https://gist.github.com/levelsio/9c531122e557da6282458bbc2a8e2aff](https://gist.github.com/levelsio/9c531122e557da6282458bbc2a8e2aff)) with the necessary HTML and CSS to make one yourself. I've been using JavaScript for quite a while now and was recently wanting to create my first JS library so I decided to use Maker Links for that very purpose. Introducing: \[\*\*maker-link.js\*\*\]([https://github.com/cedricium/maker-link.js](https://github.com/cedricium/maker-link.js)) I made it so that all you have to do is include the \`maker-link.js\` library, then you can instantiate a new \`MakerLink\` instance with an options object which gives you control as to how the Maker Link will look. Those options include: \- author: whoever to credit as the "maker" (Pieter uses his handle 'levelsio') \- photoURL: link pointing to an image that gets displayed in the Maker Link \- redirectURL: link that the new tab will navigate to when the Maker Link is clicked \- brandColor: color the Maker Link text will change to when hovered (can be any valid CSS \`color\` value, e.g. rgb(a), hsl(a), keyword, etc.) \- font: font-family used for the text shown in the Maker Link (can be any font that your site has access to such as a Google Font) To see an example of a Maker Link created using \`maker-link.js\`, check out: [https://cedric.tech/should-i-cli](https://cedric.tech/should-i-cli). Would love to hear what you think - this being my first library any recommendations for how to improve the project would be greatly appreciated. Thanks!
Thank you!
By using jQuery forever and having to support browsers which don't let you use any of the new fun stuff.
I extended es5 Maps to store multidimensional arrays in bitshifted numbers: https://github.com/spaceribs/numbmap
Hype driven development, solutions are not judged by merit but by nice/not nice comments in media.
I wouldn’t hire a self taught “web developer” who has JavaScript, html and CSS basic down, even as a junior. A web designer, maybe, if they had some design skills to go along with it. There is a huge difference between web developer and web designer, and you seem to be conflating them.
WOW, wtf is a () =&gt; {}, wow...what is this ?
fuck IE, seriously F.U.C.K IE.
Hi, which one is better ? Your method or button.onClick = null ? Thanks
ES6 syntax. It’s really clean and lets you do some cool things! Take a peek on google.
If you need top performance then yes, you're probably better off going with something more traditional using MVC or similar and building fully native apps, but at a rough guess I'd say 90-95% of apps don't need that performance. For most apps, trading some performance for an improved development experience, ease of maintenance, or increasing the amount of code you can reuse between platforms is well worthwhile.
Totally off topic, have any other iOS users noticed non working links once you’re in a repo on mobile lately ?
Yes, for sure. If you have a lot of instances with internal state classes may make more sense. Though in practice I think that's kind of rare - games might be an example where using classes for performance is justified (alternately you could go with an entity-component-system which takes a plain data approach.) Otherwise once you have enough instances to matter, I think it's usually better to start treating those as pojos or flat arrays. All that said, there are frameworks that will require you to use and understand JS classes regardless of how you feel about them.
hypebeast.
My impression was that RN is largely regarded as a tool for mobile MVPs that match native apps in feel, and that those businesses using it consolidate at one point, establish their business and switch to native once they can afford to employ dedicated mobile devs. RN as an onramp basically.
You can totally teach yourself. Here’s what I would do as someone who switched careers and via a bootcamp (codesmith) one year ago: -code academy to learn syntax and fundamentals of JavaScript -code wars or coder byte to learn basic JavaScript and how solve algorithms -Flexbox froggy to learn flexbox -clone a few static websites to learn basic html and css - learn React or vue, make an Instagram clone - make your own web app front end
They are both very similar. There will be an EXTREMELY minute performance difference with setting it to null, but I mean literally no person would ever know the difference. I’m talking like nanoseconds here. 
He's not saying "Just learn the absolute basics of CSS, HTML and JS and you'l get hired as a developer. He's saying that's the starting point. What do you recommend someone with zero experience do? Just jump right in to Angular or React and figure it out? You need to start with the basics first.
Self taught here, I've been working in the industry as a Front End for around 6 years now. Through self discipline and a bit of determination there is no reason why you can't teach yourself and go into the industry without a computer science education. I'm not an anomaly either, at least in the UK. I've worked with lots of seriously talented self taught developers in both agency and corporate environments, for both front end and back end. Yes a formal training is fantastic, but to say a it is required is completely untrue.
I actually asked the same thing on Twitter and got the reply "It’s 1 designer and i’m working on it kthxbye." So they really do work hard on good relationships with their customers eh!
It’s not just indication it prevents the developer from reassigning the variable accidentally. You might think that you are perfect until the day you make this mistake. Or a coworker does after working with your code. And with a linter you can prevent issues before run time
I find all caps to be super slow to type personally
I havent used react native, but I am a user of some apps built using Apache Cordova. I can't speak to the differences between Cordova and React Native, but the Cordova app has shit performance compared to similar native apps. I love the idea of RN, I love web development in general. But maybe something like PWA would be more of a way to go than RN? Either way, being able to write once and run on all devices is a great goal to help our industry, and I hope we manage to get there.
don't misuse let and const. 
Slim.js super fast library for building native web components. Http://slimjs.com 
Is it possible? Yes, certainly. &gt; and how long would it take to get a good grasp of knoweldge in Javascript,html,and CSS For a web design entry position? Maybe a year. But if you intend on doing web design, you are going to need to learn to *design* after all. And unless you are visually talented already, it might take a couple of years to become good.
In many different languages, we have final or constant variables. In some languages, like Java, the compiler can make further optimizations to speed up performance by reducing generated bytecode when a variable is marked as final. It can also be useful in cases where multiple threads may try to access the same variable. But with JavaScript, remapping it to ES5 will just replace it with \`var\` in both cases. Using it in an ES6 environment, the JIT should complain that you are re-assigning a \`const\` variable to a new reference. I'm not entirely sure if V8 or SpiderMonkey has performance optimizations for \`const\`. Either way, the best reason to use them is maintainability, readability and code sharing. Take for example, a particular linting rule called [no-parameter-reassignment](https://palantir.github.io/tslint/rules/no-parameter-reassignment/). This TypeScript linting rule, effectively treats parameters as \`const\`, so they can't be reassigned. There are multiple reasons why you may want to do this: \- Adding a new parameter could change the initial parameter value/type \- The reference in the function signature would no longer match the \`arguments\` array provided by the function scope The point is, someone proficient in the language should be able to pick your code up tomorrow and understand it. Reusing the same variable too many times can make things really confusing. Marking a variable as \`const\` can help you avoid writing bad code.
This article opened my eyes about using Promises a couple of years ago. https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html &gt; Rookie mistake #1: the promisey pyramid of doom Personally once you get the hang of promises I would use async/await to avoid these unnecessary nested structures.
google "js arrow functions"
Hi, I've been working on Reactive Relations as a side project in the past few years. I rewritten the web framework multiple times, but now I think it achieved a state where it can be used for more experimental projects. I don't know of any other framework that allows bi-directional data binding through all relational operations, and I believe this library is capable of composition of more expressive components than I have experienced with other frameworks.
[Support of Proxy](https://caniuse.com/#feat=proxy). Also from a comment on the article: &gt; It is worth mentioning that arrays are not handled by this function and push/pop/delete to an array needs to be handled by overwriting those methods.
I am a software consultant and my general agenda is to pick the least packages possible. Use web standards as much as you can. For example, create your ui components with web components and if you really require some framework then use it as a glue only. This way you could migrate to a newer framework with less pain. Split your code as much as you can. Microservices and nanoservices approach. Same for front end and backend. This split makes you more forward compatible which is the most important thing when you scale. 
It's about breaking down problems and solving them in an ordered manner. Algebra and algorithm are related words, and they basically mean just that. You're bad at math because you don't understand math as a language, or the methods used to solve certain problems. You're scared by the syntax. Similar to people who are scared when they see a block of code, or even a terminal window, and don't understand what's going on. You just need teachers with pacience, or good videos you can watch over and over, until you understand it. In regular public school classes it's impossible to learn at your own pace, and without parents that understand this stuff, and can explain it outside of school time, you're out of luck. But you understand english, and have access to the best teachers specialized in explaining this stuff in simple ways, and you can watch the videos over and over on video platforms until you get it. [Start here]( https://www.youtube.com/watch?v=lVlosNTbakY ) for Math/Algebra. [CS50]( https://www.youtube.com/watch?v=y62zj9ozPOM ) is also worth watching if you're new to computer science and problem solving. You can learn anything if you want! Most people don't realize the true value of the internet. It's disrupting education! 
We are deep (near the end) of the process of porting our native app (all in) over to RN. We have both native and JS heavy engineers on staff. Across the board we are very happy with RN. It works for our team, and I believe very strongly that it works for MANY, MANY team the world over. We are able to move way faster, at less expense, and produce 98% of our features with perfect parity to pure native. Will we find out 2 years from now that we need to port it back to pure native to close that 2% gap. Maybe, but probably not. I read the AirBNB article in it entirety and came to the conclusion that all of the points they made to justify their decision did not apply to us, and all the points they made in favor did. Do not let hype nor one company's decision make your decisions for you. Test, evaluate, and come to your own conclusions.
Hi, I've been working on Reactive Relations as a side project in the past few years. I rewritten the web framework multiple times, but now I think it achieved a state where it can be used for more experimental projects. I don't know of any other framework that allows bi-directional data binding through all relational operations, and I believe this library is capable of composition of more expressive components than I have experienced with other frameworks.
I was more commenting the reactions of peoples about this post
Exactly my point. The problem is not the choice of airbnb but rather the reactions and comments implying it should influence future choices by devs
Exactly my point. The problem is not the choice of airbnb but rather the reactions and comments implying it should influence future choices by devs
Look into async and await and you won't need to think about then()
Very interesting way of saying it because in fact "safety in abandoning all thinking for yourself" applies in a lot of other things in life.
You have to either use a callback, or return a promise.
Promise is something that is in future, that is why "return" will not work, you can return another promise, but not a value. Instead, you're given with 2 functions: "resolve" and "reject"; you call proper function when your result is ready, or in case of error - you can say so explicitly call reject. So take a look: function getValueFromDatabse() { return new Promise((resolve, reject) =&gt; { // here you can do all you need, keep in mind, exiting this function DOES NOT resolve promise, so it will stay in "pending" state forever. to indicate that you have value ready to return it --- you call "resolve(value)" }); } // some code does: getValueFromDatabse().then((value) =&gt; { // here value will be exectly that value that you passed when called "resolve" (the only way you say "promise resolved and here is the value") }).catch((error) =&gt; { // here, if you need, you can handle error. as you might understand -- its optional; but if you happens to call "reject('this is error string but can be anyhting')", then "error" here will contain what you passed to that "reject" call. }) // one more thing: // here might go some code that will be executed immediately after getValueFromDatabse() call, so you still dont have "value", just some code if needed. The value can be read only in that ".then(value =&gt;..." above i wrote. So basically if you cannot do anything until you have "value", all your code might go in that ".then(value=&gt;..." part.
Caps lock key is broken?
it's ES6 speak for: function(){};
absolutely this. There are so many libraries/frameworks and it is hard for newbies like myself to pick a framework to learn. I sometime defer to thoughtworks technology Radar to gain some insight but they are not always updated. At least I am finding that to be able to gain enough insight to make a judgement is a long process and may not always be worth the time investment. 
You are setting `result` to a promise which will be resolved sometime in the future, not the value of the `ipAddress`. This is stupid, but you *could* do something like this: let ipAddress; localIpV4Address().then(ip =&gt; ipAddress = ip); // some time in the future... console.log(ipAddress); But that doesn't really answer your question. What you really need to do is call the code that uses `ipAddress` from the `then` callback. Something like this: function doSomethingWithTheIP(ip) { // use the ip address here } localIpV4Address().then(doSomethingWithTheIP); Unfortunately, this answer probably does not help much. I doubt a simple example here will really help much until you have a better foundation. I would highly recommend reading [the async chapter](https://github.com/getify/You-Dont-Know-JS/tree/master/async%20%26%20performance) from YDKJS.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [getify/You-Dont-Know-JS/.../**async%20%26%20performance** (master → f0d591b)](https://github.com/getify/You-Dont-Know-JS/tree/f0d591b6502c080b92e18fc470432af8144db610/async%20%26%20performance) ---- 
so about your example, take a look (i didnt test it, i just wrote how it suppose to be in general). Notice "resolve" call and the way we console.log result --- we dont assign result to a variable (the function returns promise, not a value, value not ready; but as soon as its ready, we get it inside ".then(result =&gt; ...") [https://paste.ofcode.org/S6akLrJujUFe4eKV3AHeAs](https://paste.ofcode.org/S6akLrJujUFe4eKV3AHeAs)
Are you sure it was only a year ago and not two years ago? Three years ago it didn't exist, two years ago RN was super early and buggy, then one year ago it was quite mature, Expo made it convinient, but it had links and now it's super convinient with a strong eco system. I think it was just too young when you used it, if it was 16+ months ago.
It's called an [Arrow Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions). 
it's mapped to backspace (Colemak layout)
Similar to how Rails was used to quickly build web apps a few years ago to reach MVP as quickly as possible. Convention over configuration allowed for rapid prototyping and then the codebase would eventually migrate to something else once they secured funding/customers.
Hi /u/webflow99, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/JakeNollan, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/l-shaf, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/inform880, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Now THAT is a great reason to make the change. Anything that helps you improve as a coder is always worth the exercise. 
There are two main styles I've seen. 1. Use `const` as much as possible and only use `let` if a variable might need to be reassigned. 2. Use `let` as much as possible and only use `const` for variables that have a value that should never change like `const HOURS_IN_DAY = 24;`. The first style is followed a lot more, but there are still some pretty notable codebases using the second style (like Mozilla Firefox and Ember). So if you want to go that route I don't think it would be the worst thing in the world, just be consistent.
Did it get significantly better? I tried it out fairly close to its launch and everything just felt too limited? Like it was fine when you stayed inside the lines and stuck with default components but when you wanted something out of the ordinary it was just a nightmare that was easier to solve in native.
It’s also super negative in tone. We defer to people who have thought more about a topic. We recognize others have knowledge and skills which surpass ours in many facets of life. That’s not “abandoning” thinking for ourselves. Why should programming be different to anything else?
It gets returned as the value of the promise. ``` // returns Promise(id) const asyncId = async (id) =&gt; id // prints value after awaiting promise const awaitAndLog = async (prom) =&gt; { const msg = await prom console.log(msg) } // chain then to get value and print asyncId('Hello, World!').then(console.log) // Hello, World! // await value and print awaitAndLog(asyncId('Hello, World!')) // Hello, World! ``` Await should only really be used when you want to take the value _out_ of the promise. It has its uses, but most of the time it's going to be less code and easier to follow if you leave it in the promise. Constantly unpacking the promise with await just to put it back in a promise by returning an async function is just adding overhead that you don't need. It's kind of like using a for loop to do some work on each element of an array and just put the result back into a new array. You _can_ do it---and if you're uncomfortable with promises, it might be more familiar to you---but all you're really doing is a lot of extra work. ``` // this is like awaiting something to work on a value const doubleArray = (arr) =&gt; { const newArr = [] for (let i = 0; i &lt; arr.length; i++) { newArr.push(arr[i] * 2) } return newArr } // this is like chaining "then" const double = (x) =&gt; x * 2 arr.map(double) ```
&gt; But doesn’t anyone ... develop and entire project start to finish without libraries. Not in my experience, unless it’s a landing page or simple profile/portfolio page. Most frameworks handle a few major things: routing, data binding, templating, event handling, and some variation of dependency injection. (Btw, I’d love to see a series of blog posts cover this for the library-averse). By and large, these are solved problems with any JS framework, even the ones that have fallen out of popularity. This is a solved problem and unless one is really into building everything themselves, including the nuts and bolts, it’s largely uninteresting. Then there’s other issues like libraries for dealing with time. That’s a huge can of worms. Currency is another. Eventually you get to things like Lodash or form validation and one starts to think “yeah I could write that, but this one is battle tested and has covered edge cases too.” It comes down to what you really want to build. Interior designers aren’t given flack by home builders for just making one room in a house someone else built look nice. 
Yes so that’s why I think RN is still relevant to most startups that need to iterate quickly. As their org structure grows along with their code base, then and only then would it make sense to explore going native. 
Fuck yeah, VSCode. 
Some people can't afford the time or tuition
React Native is quite a bit better on both performance and "native feel". It's still not as good as true native, but I'm fairly happy with it.
Because knowledge and independence are the paths that lead to freedom, and a more intelligent way of doing things. Example of food is great one: "we defer to people who have thought more about" it. Except now we are realizing the nefast effects that had in the environment and some communities are going back in learning how to grow food by themself. The same should go about programming. Also because if you reason in this way, in a few years you will be easily replaced by AIs.
I really want to thank everyone for taking their time to reply to this thread and help get me on the right foot with asynchronous programming in JavaScript.
This is almost exactly the road I ended up going down. Really appreciate the input.
It is not complicated. **Environment** npm install -g typescript npm install -g @angular/cli **New Project** ng new my-project cd my-project ng serve
What exactly are you trying to accomplish? 
For creating mobile cross platform apps. React : React native, Angular : Ionic, Vue : Weex. 
In my experience, they use jQuery and target IE8 as the client browser. 
Pretty cool stuff for me to bookmark and use. Appreciate it.
As for salaries in Croatia: Junior 500-1000$; intermediate 1000-2000$ and senior 2k$+
What did you want to do that native components and CSS could accomplish presentationally? What native component didn't give enough access? How was JavaScript not powerful enough or fast enough to accomplish what you needed? Maybe in your use case there is a current serious weakness with RN. Also do you and your devs even like JS and React? For example I hate programming in Angular so much, that even without an objective rational, I think it's terrible :p
Enjoy! :)
Const is a special variable declaration in most languages, especially JS. It basically allows you to have a catch for if you accidentally try and reassign the variable. As in, I set something to constant, there's no way for me to change it's type. Let on the other hand doesn't have this assurance. Same with var.
Just to clarify -- this is mostly correct but there are differences. Scope is bound in an arrow function, they auto-return without brackets, you don't have access to `arguments`, erm... I'm sure I'm missing something, Google away!
how do you handle all the points they made not in favor?
Yeah we like JS and react, though we also like Vue and angular. I like most of the new frameworks, I hated angular 1 and I was never really a fan of backbone but things have moved on since 2010. It really depends on the project, project size, what the use case it. I try to swap framework on every side project to stay up to date. From what I can remember, what we were looking to make had a lot of video backgrounds and interactive tutorials, and combinations of both - say you started with a video that would then animate down into the tutorial which would then ask you a bunch of questions and then do different things depending on your answers. Internal training yoke basically. Anyways, my problem with RN at the time was basically it was kind of just the same thing you'd get if you opened up XCode and picked out the default UI components. You know your ScrollView, ListView, Image, etc and what we needed was to build custom UI components and it didn't really seem (at the time) that RN was going to be very helpful with that. Also this really really was pretty soon after it launched, like I'm pretty sure the version was in single digits, So I really have no idea what it's capable of these days!
raspberry pi
Ah interesting. Ya you could overlay any components on video now a days. I mean, you could literally down anything.
Object spread performs a shallow copy. It's equivalent to using `Object.assign()`. This means all properties are copied at the top level only and they will reference the same values as the original. If you want a deep copy, you'll have to do that yourself or using a library like lodash. If your object is serializable, you can also take the shortcut of converting it to a JSON string (`JSON.stringify()`) and back to brand new object (`JSON.parse()`).
Does browsers support object destructuring syntax yet? If so, I think this is a bit more concise: const { Engine, Render, World, Bodies, Composites } = Matter;
Thank you. The shortcur worked fine. Could you elaborate on the meaning of a shallow copy? What would be the difference then between assign the object `const a = b` and using the spread operator `const a = {...b}` ?
Ah, cool I’ve never heard of that one before. I always wanted to learn Dvorak, and tried a bit, but I just couldn’t stick with it. 
I wonder is or would be it possible to save recorded data from CI and load it into local Cypress without having to use Dashboard? I suspect not, because that's the only way Cypress can make money...
Primitve values vs. objects has a clear definition in the ECMAScript spec: – Primitive values are: undefined, null, booleans, numbers, strings, symbols. – All other values are objects.
Why not? `null` is a literal just like `123` is a literal that produces a number (also a primitive value). The spec has the primitive types Undefined and Null that each only have a single element. https://tc39.github.io/ecma262/#sec-primitive-value
Not by default, but you may find some [packages](https://www.npmjs.com/package/resource-router-middleware) in NPM that _might_ suit your needs to a certain degree. Or you may search in [Github](https://github.com/expressjs/express-resource), where you might find [other](https://github.com/jsdevel/node-express-crud) similar packages.
I threw your 3 versions in a jsperf. The results seem to encourage writing boring-ass code: https://jsperf.com/3-generations-of-flatten-in-javascript/1 
Thanks you for help me search, I like the way that express resource handle this, but doesnt gave support for express 4. I'll test the another packages.
Fucking javascript create modern javascript framework
We have been using React Native for several years now to build a MASSIVE app (hundreds of screens and components). A lot of AirBnb’s concerns ring true. The ecosystem is immature. There’s an uncomfortable number of bugs in the standard library. Tooling often breaks. BUT: the efficiency gains with React Native are incredible. For us, being able to have 95% code share across Android and iOS has saved us literally millions of dollars in developer hours.
The main points they made not in favor were things that pertain to having to interoperable between parts of their app that where already pure native, shared element transitions, and startup time optimization. Aside from the last one we have had no need for the optimizations they detailed as their deciding factor to transition. Again, when you are a company with the cash that AirBNB has, you can afford to spend the considerable amount of time and money that it takes to eek out those last few percent of optimizations. When you are scrappy startup that wants to deliver high (enough) quality/performance on a lean budget, there is no better approach than RN at the moment
Pretty much all evergreen browsers support object destructuring http://kangax.github.io/compat-table/es6/#test-destructuring
nop, express is a fast, unopinionated, minimalist web framework for node.
 Gotcha, then I'll have to do it by hand.
education is free in croatia
When you do `a = b`, you have two variables pointing to the same object. That means `a === b`. When you use spread like `a = {...b}`, you're creating a new object and going through all of b's properties and copying them into it before assigning it to a. Then, `a !== b`, but any properties of a and b of the same name will still equal, e.g. `a.delimiters === b.delimiters`. This is because spread only makes one object (actually, spread itself is not making any objects, you made the object with `{}` and spread copies properties into it), it doesn't make new objects for each nested object it finds when copying the values. If the object you're copying doesn't contain any objects itself, spread is all you need to make a copy. const b = {x: 1, y: 2, z: 3}; const a = {...b}; // complete copy Its only with those nested objects/arrays that become problematic. 
Absolutely insane!
BeeInstant has the most generous free plan out of all the monitoring companies, worth checking out 
It's interesting and I like the smaller examples of individual features. But the bigger examples like todo and simple facebook are an eye sore. I like that you provided multiple examples but cramming all that code together is pretty off putting. Maybe in addition provide a separate page that shows those types of examples where the code is organized into separate files and not just one big dump? Because the thought of maintaining an app that is one mass of chained function calls is pretty chilling but I'd be interested in seeing a real world example of what an app would look like.
If you prefer web view. check out this [link](https://coderplex.org/learn/reactjs/Choosing-ReactJS/) to view the same guide in website.
Thank you , never heard about ionic and weex will check them out 
Very interesting. With complete use of shorthand syntax and some renaming, it is only 2 lines (following the convention of keeping code &lt;= 80 characters wide). const use = (...middleware) =&gt; context =&gt; middleware.reduceRight((next, fn) =&gt; () =&gt; fn(context, next), () =&gt; { })(); The composability can even be improved by giving the returned function the same type signature as the middleware, so that the returned function can be used as middleware as well (and using default parameters helps mitigate some boilerplate for the end caller): const use = (...middleware) =&gt; (context = {}, noop = () =&gt; {}) =&gt; middleware.reduceRight((next, fn) =&gt; () =&gt; fn(context, next), noop)(); const one = use( async (context, next) =&gt; { context.key = 'foo'; return next(); }, async (context, next) =&gt; { context.value = 'bar'; console.log(context); return next(); }, async (context, next) =&gt; { context.fizz = 'buzz'; console.log(context); return next(); } ); const two = use( one, // &lt;--- here is the composition at work async (context, next) =&gt; { context.test = 'Systems operational'; return next(); }, async (context, next) =&gt; { console.log(context); return next; } ); two();
I get that it might be easier to simply go with a library for situation x, or one for problem y. But am I alone in thinking such heavy use of libraries robs you of the opportunity to get the most out of the language from a learning perspective? I'm personally more than happy to reinvent the wheel, if the wheel here is a library (widely used or not), if it means I've gained a more solid understanding of an aspect of js I never had before.
Neat!
So... just no? No wiggle room at all?Even for the seemingly butt-hurt responses like yours? I can split hairs too (and here come the inevitable downvotes). The point of the web is to curate and share information. I specified *developing* for it in what is clearly a context here of JavaScript, it's resulting libraries, and sites and applications built with them. The web is the platform with the most reach simply by virtue of being accessible on most other platforms (mobile, tablet, laptop, desktop, console, TV, IoT, etc), so developing for the web gives your project the widest reach possible. But seriously for a moment, I have to disagree when you say the implementation isn't as important as the result. I'd argue it's probably most important. Why be solely result-driven when you could implement a more accommodating approach from the outset with which to present those results, and maybe even come away with a greater understanding of and respect for js as a result? Sounds like a result to me.
I'm instantly sold when I saw documentation!
Here's exactly what I settled on in case you were curious: [https://gist.github.com/aaronfulkerson/ed1940ed8bc46ad51296480b5511e414](https://gist.github.com/aaronfulkerson/ed1940ed8bc46ad51296480b5511e414)
I don't know which one is "better". But this one is more equivalent to `removeEventListener`. 
I think people would be downvoting it because its not true.
Interesting little project. I have worked with Elm in past have a few open source elm libraries but none in the web interface space. For fun converted it over to typescript, as that's what I've been working with lately. I have pushed a project to github with raj.ts, raj.spec.ts, raj-react.ts a cut down raj-componse.ts. It is a create react app typescript project and has a running index with 4 example raj programs. See [https://github.com/rluiten/rajts](https://github.com/rluiten/rajts)
Nice! Looks very clean. The implementation using Promise.all would execute a bit faster, but this implementation looks a bit cleaner. I’d probably opt for the cleaner version myself, unless performance was critical. 
Thanks🙌
The time required to do programming isn’t usually limited by the number of letters typed, but rather, the endless hours spend staring blankly at already written code, wondering... where did it all go wrong? If it’s that big a deal to you, use a text editor plugin to assign the two letter key combo “cx” to inject the word ‘const’. That’s one less than “let”.
&gt; I’ve began making a very simple game in p5, and I’ve seen a few people around reddit saying that you shouldn’t bother making games in JavaScript. Depends if your goal is to ship it on web only or not, if it's web only then JS is fine. &gt; So I just need some motivation or reinforcement really that JavaScript is robust enough to make games, and moreover whether p5 is robust enough to make even a game of medium size. It is what it is. nothing in p5 that would stop you, it's a fairly minimal utility library as far as i can recall.
Kind of a bummer that it changes it to indented if you switch to "Fancy Pants Editor" and back, although that isn't as much of a problem now that they've got it remembering markdown mode.
&gt; If it’s that big a deal to you, use a text editor plugin to assign the two letter key combo “cx” to inject the word ‘const’. That’s one less than “let”. Brilliant! Any Atom package that does that?
Probably before ES6 tooling
[You Don't Know JS: this &amp; Object Prototypes](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/README.md) is a pretty comprehensive guide to `this` in JavaScript. Free and not too long, so it's definitely worth a read.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [getify/You-Dont-Know-JS/.../**README.md** (master → f0d591b)](https://github.com/getify/You-Dont-Know-JS/blob/f0d591b6502c080b92e18fc470432af8144db610/this%20%26%20object%20prototypes/README.md) ---- 
Considering web development is an ever-evolving rabbit hole with many languages (each of them incredibly deep that take significant effort to MASTER), tools, standards, etc that are constantly changing/shifting I don’t think there is an answer for “how long will it take me”. Depending on your aptitude you could learn enough to be a hack in a month or two. To really MASTER a language could take you years. Becoming a full fledged expert well-equipped to execute (and manage) complex projects with a high level of quality could take decades. Either way the answer is, its a steep climb that you should get started on immediately if you are serious. Good luck!
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Thought i’d share this as I brought the concept up in a previous post here. Works pretty efficiently in my case, queries with around 30k resources take from 20ms to 50ms. Feel free to read the code for a better understanding of the added methods for easier resource and table management.
One more _really_ important part (which makes closure so useful) is that the inner function will _continue_ to have access to those variables _even after_ the outer function has returned. So when you return `innerFoo` "first class" from `foo`, it can still access the variables that were in scope for `foo`, even though `foo` has finished running and its scope has "closed" (thus "closure"). ``` function foo() { // any variables in here are hidden from the global/outer scope const secret = "Very secret message" // returns a function, which has access to the variables of foo() return function innerFoo() { return secret } } const bar = foo() // foo runs and returns the innerFoo function, which is assigned to bar console.log(secret) // undefined console.log(bar()) // "Very secret message" ``` Or with arrow functions. ``` const foo = () =&gt; { const secret = "Functions are just objects, like 1, [2], or { three: 3 }" return () =&gt; secret } const bar = foo() // bar is assigned that anonymous function (() =&gt; secret) console.log(secret) // undefined console.log(bar()) // Functions are just objects, like 1, [2], or { three: 3 } ```
Wat.
Read the source code?
Which source code?
JQuery
You can more or less achieve it with snippets, looks like. Other than that, I don’t know since I don’t use Atom. https://www.sitepoint.com/use-code-snippets-atom/
If I read that means it will understand?
But I already finished all functions ?
Wait for the `load`event, not the `DOMContentLoaded`. `DOMContentLoaded` fires when the HTML resource is fully loaded, but before other external resources such as CSS, JS, images, fonts, etc. are loaded. You can still use the `onload` attribute, but you might want to use `addEventListener()` instead, if you want to make the web page future proof.
Yes. For one, it’s becoming an standard framework to build front ends in, and if you needed another reason, it’s pretty cool to work in.
you should consider using vue though, I find it a little easier to start with
Is there other thing(s) that can only be done using `var` except that it can redeclare a variable? And the fact that it's hoisted.
I make a request to the server for it. I cache some in localStorage so that some aspects of the UI don’t need to wait for the request to return.
&gt; It has everything to do with character count, as I'm making the observation that async/await performs the same function with fewer characters. That is literally the entire premise of this discussion. How does async/await use fewer characters? Async/await may have some uses (I can't think of any good ones, although I suppose they _might_ exist), but making code more terse and expressive is _not_ one of them. ``` // async/await (pretty bad) async function doThingThenCallback(callback) { const data = await somePromiseThing(); const moreData = await someOtherPromiseThatUsesOtherData(data); callback(moreData); } // raw promises (pretty good) function doThingThenCallback(callback) { return somePromiseThing() .then(someOtherPromiseThatUsesOtherData) .then(callback) } // with arrow function (better) const doThingThenCallback = (callback) =&gt; somePromiseThing() .then(someOtherPromiseThatUsesOtherData) .then(callback) // straight up (best) somePromiseThing() .then(someOtherPromiseThatUsesOtherData) .then(callback) // or whatever, now that "callback" doesn't make any sense ``` Promises implement a sort of bastardized version of the monad interface, with `then` serving as both `map` and `chain` (aka., `bind`; aka., `flatmap`), depending on context. If the function passed to `then` returns a promise, it acts as `chain`; if the function returns a nonpromise value, it acts as `map`. Return a `value`, get a `Promise(value)`; return a `Promise(value)`, get a `Promise(value)`. Using `await` just adds points that you don't need.
I like the examples, but how is it different from apollo-client? Does it have any advantages?
Yes and no. Start with learning vanilla JavaScript first. Then move on to a framework like react. 
Not entirely sure what you’re doing wrong but I’m surprised it’s not more than just that one thing. See redux form, its a great module and will get the job done until you figure out what your bug is. I’d start by extracting all of them inputs into a custom component with an err wrapper or something. Too much code definitely imho
But `null` and `undefined` don't have any constructor. Shouldn't all primitive types have their own constructor? Is is not possible to remove `null` from the primitive types and be made to a global variable/constant? Just like `NaN` and `Infinity` - where they're literals, but of `Number` type. So that it's compatible with what the current JavaScript engines implement.
Async/await almost _never_ improves clarity. It usually just adds noise. The _one_ place that I can think of where it _might_ be a _little_ clearer is how async/await is used in the `Hapi` documentation (starting with v17), since there are a lot of setup functions that have return values we just don't care about. ``` // with async/await const provision = async (server) =&gt; { await server.register([Blipp, Inert]) await server.route({ /* ... route configuration ... */ }) return server.start() } // without async/await const provision = (server) =&gt; server.register([Blipp, Inert]) .then(_ =&gt; server.route({ /* ... route configuration ... */ })) .then(_ =&gt; server.start()) ``` Whether that is really more "clear" is up to interpretation, but it's at least arguable. In any case where we _do_ care about the return value, async/await just adds noise and reduces expressiveness. ``` // async/await const letsDoSomething = async (data) =&gt; { const gotSomething = await doSomething(data) const gotSomethingElse = await doSomethingElse(gotSomething) const gotSomeOtherThing = await doSomeOtherThing(gotSomethingElse) return gotSomeOtherThing } // raw promises doSomething(data) .then(doSomethingElse) .then(doSomeOtherThing) ``` Now, maybe you want to `console.log` the value before continuing to do some other things with the data. ``` // # async/await const letsDoSomething = async (data) =&gt; { const gotSomething = await doSomething(data) const gotSomethingElse = await doSomethingElse(gotSomething) const gotSomeOtherThing = await doSomeOtherThing(gotSomethingElse) console.log(gotSomeOtherThing) return gotSomeOtherThing } const doSomeThings = async (data) =&gt; { const didSomeThings = await letsDoSomething(data) return doTheNextThing(didSomeThings) } // run our functions doSomeThings({ /* data goes here */ }) // # async/await with promise chaining const letsDoSomething = async (data) =&gt; { const gotSomeOtherThing = await doSomething(data) .then(doSomethingElse) .then(doSomeOtherThing) console.log(gotSomeOtherThing) return gotSomeOtherThing } const doSomeThings = async (data) =&gt; { const didSomeThings = await letsDoSomething(data) return doTheNextThing(didSomeThings) } // run our functions doSomeThings({ /* data goes here */ }) // # just promise chaining // tap allows us to intercept a value, log it, and then keep going const tap = (value) =&gt; { console.log(value); return value } // run our functions doSomething({ /* data goes here */ }) .then(doSomethingElse) .then(doSomeOtherThing) .then(tap) .then(doTheNextThing) ``` 
What is your goal? Why are you learning jQuery?
.wat
React is the standard framework. It’s totally different than traditional HTML / JS
I thought it was more like a library (like jQuery) than a complete framework like Angular.
&gt;LearnJavascript Okay, thanks dude.
I’d think of it as a light framework that enables a paradigm. You approach problems differently so there’s a lot of retooling that you have to consider.
Web design
I think you might wanna read up on how existing database software manages FS cache and disk writes/reads to keep things fast.
You read a lot. We like that. You’ve reached the end of your free member preview for this month. Become a member now for $5/month to read this story and get unlimited access to all of the best stories on Medium.
Thanks, i’ll make sure to.
I think it'd be a really good idea for you to _eventually_ get into a state manager like Redux. It really does make things easier. But, you will want to know how to do this stuff without Redux, whether or not you eventually go that route, so don't run off and start trying to learn that just yet. Here's a working example with one field. I don't have time to write up a whole explanation right now, but I'd be happy to answer any questions later when I do have time. ``` import React from 'react' import { Form, Button } from 'semantic-ui-react' const Field = Form.Field const defaultData = { name: '', industry: '' } class CompanyForm extends React.Component { constructor(props) { super(props) this.state = { data: defaultData, loading: false, errors: {} } this.clearForm = this.clearForm.bind(this) this.handleSubmit = this.handleSubmit.bind(this) this.handleChange = this.handleChange.bind(this) } clearForm(e) { e.preventDefault() this.setState({ data: defaultData }) } handleSubmit(e) { e.preventDefault() // do your validation here } handleChange(e) { const { name, value } = e.target e.preventDefault() this.setState({ data: { ...this.state.data, [name]: value } }) } render() { const { data } = this.state return ( &lt;Form onSubmit={this.handleSubmit}&gt; &lt;Field&gt; &lt;label htmlFor="name"&gt;Name&lt;/label&gt; &lt;input type="text" id="name" name="name" placeholder="company name" value={data.name} onChange={this.handleChange} /&gt; &lt;/Field&gt; &lt;Button primary&gt;Add company&lt;/Button&gt; &lt;Button onClick={this.clearForm}&gt;Clear&lt;/Button&gt; &lt;pre style={{ textAlign: 'left', padding: '1em', border: '1px solid' }}&gt; {JSON.stringify(this.state, null, 2)} &lt;/pre&gt; &lt;/Form&gt; ) } } export default CompanyForm ``` 
You should probably mention somewhere that it only works to query "flat" JSON objects, or implement recursive querying so you can query for nested objects. At the moment this has all the drawbacks of an RDBMS and all the drawbacks of a NoSQL DB, and none of the benefits of either. Obviously it's a work-in progress, but so far it's not even clear whether it's supposed to be a relational or document store, so it's hard to see a use-case for it beyond a personal hobby/learning project.
Webpack version?
Does "DD" have anything to do with DirectDraw / DirectX? Does the codebase contain anything with "ActiveXObject" in it? If not, to solve your problem, you need to provide this: What is the value of m_objDD in working browsers? What is its shape You can probably solve this yourself if you can track down how m_objDD is created and look for reasons why later browsers return null/undefined. 
Formatted code: StyleClass.prototype.syncDD = function() { while (m_objDD.length) { [***] m_objDD.remove(0); } var newOpt = new Option('Keine', ''); newOpt.style.color = 'gray'; selectAddLastOption(m_objDD, newOpt) for (var name in m_stylesArray) { selectAddLastOption(m_objDD, new Option(name, name)) } } This seems like the only thing that could produce that error is that `m_objDD` is `undefined`. Without knowing where `m_objDD` comes from, it's pretty hard to guess anything. As far as I can tell: - This looks like a function that fills some dropdown with various options, for choosing some style or theme. - You _could_ avoid the error by changing the line marked with `[***]` to something like: `while (m_objDD &amp;&amp; m_objDD.length) {`. This _may_ avoid the error, but nothing guarantees that things will actually _work_ as expected. - You might want to investigate the problem further by searching for the place where `m_objDD` comes from. This might be defined in a different part of the script, in a different script or in the HTML. Once you know that you _might_ have better ways to solve the problem. - You could just drop the whole thing and re-do it from scratch. IE5/IE6 means around 15+ years. Does it really make sense to keep maintaining that?
I think it's a safe bet that DD means DropDown.
I expect you're right. But "only works in IE6 and IE7" is a huge red flag for me. 
Thanks for your suggestions, I will have the chance to try that line later today, as for it it makes sense to keep the whole thing? Its a fair point, its just that the customer side is working perfectly fine still, its administrative side that has some hickups. You are right in what you think this page should contain. It is where I can define what customization options the customer has available on this product. I have looked at many solutions like shopify or other word press solutions, and for what im trying to do, they can't keep up. Mostly on the point of product customization and high resolution image output (for printing). 
Thanks for your reply. I tried to do that yesterday but I couldn't figure out how to debug properly in the old internet explorer. But I will continue on trying to find out. Im learning Javascript on the side, maybe I just have to return to this problem when I understand more about the subject.
Do you have a project you're working on? I've found that you can't learn coding just by reading. You have to try to build something. That gives you the motivation and context in which you grow your skills.
I understand that just throwing it all in the garbage can is not always an option. Still, I meant it more as in rewriting _that part_. You will still need to investigate and know where `m_objDD` comes from, but the idea would be to make a small improvement instead of just _patching_. If your contract is long term, then it may pay off to go with re-writing small pieces rather than just patching. In time, patching means each bug is more and more costly as the code becomes worse each time, while re-writing small pieces means you gain knowledge of the code and improve it a little (or at least keep the mess under control). If the contract does not make it worth it, then by all means spend as little effort as possible.
Yeah no I want to investigate further and im on that. Im learning Javascript on the side to understand this further and be able to rewrite this whole thing at one point. We're a small family print shop and we can't really afford a new professional solution at this point so im doing what I can to modernize what we have with moderate success. It has ssl certificate now, runs on a much newer Windows server then originally so its moving the right way. 
Webpack latest version. I use only wepback-dev-server. Below is my package.json \`\`\`js { "name": "css-grid", "version": "1.0.0", "description": "", "main": "index.js", "scripts": { "test": "echo \\"Error: no test specified\\" &amp;&amp; exit 1", "build": "webpack --config webpack.prod.js", "start": "webpack-dev-server --config webpack.dev.js" }, "keywords": \[\], "author": "", "license": "ISC", "devDependencies": { "babel-core": "\^6.26.3", "babel-loader": "\^7.1.4", "babel-preset-env": "\^1.7.0", "clean-webpack-plugin": "\^0.1.19", "css-loader": "\^0.28.11", "file-loader": "\^1.1.11", "html-loader": "\^0.5.5", "html-webpack-plugin": "\^3.2.0", "image-webpack-loader": "\^4.3.1", "mini-css-extract-plugin": "\^0.4.0", "style-loader": "\^0.21.0", "webpack": "\^4.12.0", "webpack-cli": "\^3.0.8", "webpack-dev-server": "\^3.1.4", "webpack-merge": "\^4.1.3" }, "dependencies": { "gsap": "\^2.0.1" } } \`\`\`
A-ha, I see. Then, well, have patience, keep notes on what you learn about the system and try to go little by little. And good luck... a bit of that always comes in handy :)
There are certainly prettier ways to do it, but here's an old-school log function that works basically on any browser platform, including almost every OEM Android browser. function log(value) { var out = ''; for (var thing in value) { out = out + thing + ': ' + value[thing] + '\n'; } alert(out); } Stepping through code is *maybe* possible nowadays assuming Visual Studio still has old hooks or that old versions of it are still downloadable. See [this](https://www.webpagefx.com/blog/web-design/javascript-debugging-techniques-in-ie-6/) for setting up the environment. I'm guessing you are working with VMs, so you may be able to find an old binary that works on these platforms.
Haha thanks, I suppose I can count myself lucky to still have a job in this industry xD 
That's really cool. I assume that most of the results aren't real characters, they just look 'kanji-ish'?
Thanks very much for the feedback! I'll add pagination/sidebar to the web page clean up / document / separate the bigger examples.
I highly suggest you to check out this course &lt;[React JS and Redux - Mastering Web Apps](https://honest-recommendations.com/recommends/react-js-and-redux-mastering-web-apps/)\&gt;. In this course you build 4 projects while you are learning.
Why would anyone want to take this paid course when there are courses that are of high quality and totally free..? 
Yes this course is paid but it's complete. The price is nothing about the information you get.
Be sure to check [this](https://egghead.io/courses/getting-started-with-redux) out. This is the course made by the creator of Redux itself and it is free. 
We just have to be able to google well... There are a lot of high quality resources that are free these days.. 
I second this. It will provide students new knowledge about ReactJS and Redux. I suggest newcomer must enroll this course.
Funny that you realize your code is "bad" when they release new rules. Why would you use **eslint-airbnb** in first place? Why to just use only rules you fully understand agree with?
Okay so, I made this using an array. What do you think of it? https://codepen.io/Unise/pen/WyyLav
*Bookmark and never use because you forget about it forever (this is me)
Cool to experiment with chaos, the true source of life\^
I highly recommend &lt;[The Complete JavaScript Course 2018: Build Real Projects](https://honest-recommendations.com/recommends/the-complete-javascript-course-2018/)\&gt;. 26.5 hours of video course
Not sure but you could use an external service for this instead, like Cloudinary.
"You can still use the onload attribute, but you might want to use addEventListener()" ?
No, because then the client would **still** have to experience high uploading time to the external service. Example: the original image is 4 MB. It's either: * the filesize reduction to 1MB (just an example) is done 100% client-side, then the uploading time is four times lower * OR the file is sent as-is (i.e. 4MB) by the client to any server (mine or an external service), and then the user experiences a long uploading time That's why I'm looking for a solution that does the work in the client's browser.
Thank you for the advice here, but it seems it still wasn't working for the nested elements in the way I expected.
So I have it working for storing the information input into the nested elements. Only issue is there is now a problem when submitting the form. I get the message of: "TypeError: errors is undefined" 124 | &lt;Grid columns={3} stackable&gt; 125 | &lt;Grid.Row&gt; 126 | &lt;Grid.Column&gt; &gt; 127 | &lt;Form.Field error={!!errors.name}&gt; 128 | &lt;label htmlFor="name"&gt;Name&lt;/label&gt; 129 | &lt;input type="text" id="name" name="name" placeholder="Company Name" value={data.name} onChange={this.onChange} /&gt; 130 | {errors.name &amp;&amp; &lt;InlineError text={errors.name} /&gt;} The code at the time of this error is: class CompanyForm extends React.Component { state = { data: { name: '', industry: '', assignedAgent: '', leadContact: { name: '', title: '', email: '', phone: '', notes: [] }, employees: [], billingAddress: { street: '', city: '', state: '', zip: '' }, shippingAddress: { street: '', city: '', state: '', zip: '' }, notes: [], tasks: [] }, loading: false, errors: {} }; onChange = e =&gt; this.setState({ ...this.state, data: { ...this.state.data, [e.target.name]: e.target.value } }); onLeadContactChange = e =&gt; { this.setState({ ...this.state, data: { ...this.state.data, leadContact: { ...this.state.data.leadContact, [e.target.name]: e.target.value } } }); } onBillingChange = e =&gt; { this.setState({ ...this.state, data: { ...this.state.data, billingAddress: { ...this.state.data.billingAddress, [e.target.name]: e.target.value } } }); } onShippingChange = e =&gt; { this.setState({ ...this.state, data: { ...this.state.data, shippingAddress: { ...this.state.data.shippingAddress, [e.target.name]: e.target.value } } }); } onSubmit = e =&gt; { e.preventDefault(); const errors = this.validate(this.state.data); this.setState({ errors }); if (Object.keys(errors).length === 0) { this.setState({ loading: true }); console.log(this.state); this.props.submit(this.state.data) .catch(err =&gt; this.setState({ errors: err.response.data.errors, loading: false})); } }; validate = data =&gt; { const errors = {}; if (!isEmail(data.leadContact.email)) errors.email = "Invalid email"; if (!data.leadContact.title) errors.title = "Please enter a title for contact name."; if (!data.leadContact.phone) errors.phone = "Please enter a phone number."; if (!data.billingAddress.street) errors.street = "Please enter a street."; if (!data.billingAddress.city) errors.city = "Please enter a city."; if (!data.billingAddress.state) errors.state = "Please enter a state."; if (!data.billingAddress.zip) errors.zip = "Please enter a zip."; if (!data.shippingAddress.street) errors.street = "Please enter a street."; if (!data.shippingAddress.city) errors.city = "Please enter a city."; if (!data.shippingAddress.state) errors.state = "Please enter a state."; if (!data.shippingAddress.zip) errors.zip = "Please enter a zip."; if (!data.leadContact.name) errors.name = "Please enter a contact name."; if (!data.name) errors.name = "Please enter a company name."; if (!data.industry) errors.industry = "Please enter a company industry."; if (!data.assignedAgent) errors.assignedAgent = "Please enter an agent."; return errors; }; render() { const { data, errors, loading } = this.state; return ( &lt;Form onSubmit={this.onSubmit} loading={loading}&gt; &lt;Grid columns={3} stackable&gt; &lt;Grid.Row&gt; &lt;Grid.Column&gt; &lt;Form.Field error={!!errors.name}&gt; &lt;label htmlFor="name"&gt;Name&lt;/label&gt; &lt;input type="text" id="name" name="name" placeholder="Company Name" value={data.name} onChange={this.onChange} /&gt; {errors.name &amp;&amp; &lt;InlineError text={errors.name} /&gt;} &lt;/Form.Field&gt; &lt;Form.Field error={!!errors.industry}&gt; &lt;label htmlFor="industry"&gt;Industry&lt;/label&gt; &lt;input type="text" id="industry" name="industry" placeholder="Industry" value={data.industry} onChange={this.onChange} /&gt; {errors.industry &amp;&amp; &lt;InlineError text={errors.industry} /&gt;} &lt;/Form.Field&gt; &lt;Form.Field error={!!errors.assignedAgent}&gt; &lt;label htmlFor="assignedAgent"&gt;Agent&lt;/label&gt; &lt;input type="text" id="assignedAgent" name="assignedAgent" placeholder="Agent" value={data.assignedAgent} onChange={this.onChange} /&gt; {errors.assignedAgent &amp;&amp; &lt;InlineError text={errors.assignedAgent} /&gt;} &lt;/Form.Field&gt; &lt;Form.Field error={!!errors.name}&gt; &lt;label htmlFor="name"&gt;Lead Contact Name&lt;/label&gt; &lt;input type="text" id="name" name="name" placeholder="John Doe" value={data.leadContact.name} onChange={this.onLeadContactChange} /&gt; {errors.name &amp;&amp; &lt;InlineError text={errors.name} /&gt;} &lt;/Form.Field&gt; &lt;Form.Field error={!!errors.title}&gt; &lt;label htmlFor="title"&gt;Lead Contact Title&lt;/label&gt; &lt;input type="text" id="title" name="title" placeholder="CEO" value={data.leadContact.title} onChange={this.onLeadContactChange} /&gt; {errors.title &amp;&amp; &lt;InlineError text={errors.title} /&gt;} &lt;/Form.Field&gt; &lt;Form.Field error={!!errors.email}&gt; &lt;label htmlFor="email"&gt;Lead Contact email&lt;/label&gt; &lt;input type="text" id="email" name="email" placeholder="johndoe@company.com" value={data.leadContact.email} onChange={this.onLeadContactChange} /&gt; {errors.email &amp;&amp; &lt;InlineError text={errors.email} /&gt;} &lt;/Form.Field&gt; &lt;Form.Field error={!!errors.phone}&gt; &lt;label htmlFor="phone"&gt;Phone&lt;/label&gt; &lt;input type="text" id="phone" name="phone" placeholder="555-555-5555" value={data.leadContact.phone} onChange={this.onLeadContactChange} /&gt; {errors.phone &amp;&amp; &lt;InlineError text={errors.phone} /&gt;} &lt;/Form.Field&gt; &lt;/Grid.Column&gt; &lt;Grid.Column&gt; &lt;Form.Field error={!!errors.street}&gt; &lt;label htmlFor="street"&gt;Billing Address Street&lt;/label&gt; &lt;input type="text" id="street" name="street" placeholder="123 Madeup St" value={data.billingAddress.street} onChange={this.onBillingChange} /&gt; {errors.street &amp;&amp; &lt;InlineError text={errors.street} /&gt;} &lt;/Form.Field&gt; &lt;Form.Field error={!!errors.city}&gt; &lt;label htmlFor="city"&gt;Billing Address City&lt;/label&gt; &lt;input type="text" id="city" name="city" placeholder="City" value={data.billingAddress.city} onChange={this.onBillingChange} /&gt; {errors.city &amp;&amp; &lt;InlineError text={errors.city} /&gt;} &lt;/Form.Field&gt; &lt;Form.Field error={!!errors.state}&gt; &lt;label htmlFor="state"&gt;Billing Address State&lt;/label&gt; &lt;input type="text" id="state" name="state" placeholder="State" value={data.billingAddress.state} onChange={this.onBillingChange} /&gt; {errors.state &amp;&amp; &lt;InlineError text={errors.state} /&gt;} &lt;/Form.Field&gt; &lt;Form.Field error={!!errors.zip}&gt; &lt;label htmlFor="zip"&gt;Billing Address Zip&lt;/label&gt; &lt;input type="text" id="zip" name="zip" placeholder="55555" value={data.billingAddress.zip} onChange={this.onBillingChange} /&gt; {errors.zip &amp;&amp; &lt;InlineError text={errors.zip} /&gt;} &lt;/Form.Field&gt; &lt;/Grid.Column&gt; &lt;Grid.Column&gt; &lt;Form.Field error={!!errors.street}&gt; &lt;label htmlFor="street"&gt;Shipping Address Street&lt;/label&gt; &lt;input type="text" id="street" name="street" placeholder="123 Madeup St" value={data.shippingAddress.street} onChange={this.onShippingChange} /&gt; {errors.street &amp;&amp; &lt;InlineError text={errors.street} /&gt;} &lt;/Form.Field&gt; &lt;Form.Field error={!!errors.city}&gt; &lt;label htmlFor="city"&gt;Shipping Address City&lt;/label&gt; &lt;input type="text" id="city" name="city" placeholder="City" value={data.shippingAddress.city} onChange={this.onShippingChange} /&gt; {errors.city &amp;&amp; &lt;InlineError text={errors.city} /&gt;} &lt;/Form.Field&gt; &lt;Form.Field error={!!errors.state}&gt; &lt;label htmlFor="state"&gt;Shipping Address State&lt;/label&gt; &lt;input type="text" id="state" name="state" placeholder="State" value={data.shippingAddress.state} onChange={this.onShippingChange} /&gt; {errors.state &amp;&amp; &lt;InlineError text={errors.state} /&gt;} &lt;/Form.Field&gt; &lt;Form.Field error={!!errors.zip}&gt; &lt;label htmlFor="zip"&gt;Shipping Address Zip&lt;/label&gt; &lt;input type="text" id="zip" name="zip" placeholder="55555" value={data.shippingAddress.zip} onChange={this.onShippingChange} /&gt; {errors.zip &amp;&amp; &lt;InlineError text={errors.zip} /&gt;} &lt;/Form.Field&gt; &lt;Button primary&gt;Add Company&lt;/Button&gt; &lt;/Grid.Column&gt; &lt;/Grid.Row&gt; &lt;/Grid&gt; &lt;pre style={{ textAlign: 'left', padding: '1em', border: '1px solid' }}&gt; {JSON.stringify(this.state, null, 2)} &lt;/pre&gt; &lt;/Form&gt; ); } } CompanyForm.propTypes = { submit: PropTypes.func.isRequired }; export default CompanyForm;
Yeah sure, I get that. But at least you (“server owner”) do not get hurt by the upload. Look up stuff like [https://github.com/brunobar79/J-I-C](https://github.com/brunobar79/J-I-C) or [https://github.com/idiotWu/canvas-compress](https://github.com/idiotWu/canvas-compress).
as a total beginner i found watchandcode’s free intro course super helpful
Yes right... I already looked at: &gt; https://github.com/brunobar79/J-I-C It's basically a wrapper with nice API around canvas.toDataURL(options.mimeType, options.quality)
Yes. React in 2018 = JQuery in 2010
[This rant](https://jamie.build/const) pretty much explains why I prefer let
That‘s the thing with saving bookmarks. :D
Use match groupings ()
I think it's totally worth getting into the React mindset of the current UI just being a function of state, but combined with that highly flexible component model. 
Great article, thank you very much for sharing this to us. :) 
Thank you for this detailled collection about mutation. I can imagine a lot of people don‘t now what mutates and what not. :) And in JS it‘s quite easy to mutate things.. 
Great article, it‘s a good starting point for people new to VSCode and willing to write good and efficient code. :) 
Paywall
``` chewieQuote.replace(/a/g,'') ```
I'm not sure what this is supposed to be doing. My kanji isn't great, but I tried writing some random things and it half just writes over what I wrote and half seems to be making up nonsense
Worthless crap
Thank you and exactly! 
Your `chewieRegex` will only match if the `a`s are missing. https://regexper.com/#%2FR%5B%5Ea%5D*h%2F
The ^ in the bracket means “ not ‘a’”.
PsychoPiggy - A thin wrapper around the widely used Postgres library - 'pg'. Adds named parameters, releases clients automatically, and avoids boilerplate around transaction commit/rollback. https://github.com/jeswin/psychopiggy
I guess css loader and mini css extract does the same job. 
Interesting - i think generators are quite underused in UI. I have a similar library called sailboat which does something similar (as in your example) but with React. https://github.com/nsoap-official/sailboat
Wes Bos’s JavaScript 30 is good for learning by projects, probably not as good for intimate knowledge of things like prototypes and more in depth details but it should make you pretty comfortable creating things.
I’m not one to recommend React for every project under the sun like some people in this sub, but learning React will definitely make you a better front-end developer, and a better JavaScript programmer in general. React Components are great. Build a Component once and you can reuse it anywhere. There are countless prebuilt components out there for the more common UI elements. This combined with sensible organization is a massive boon for front-end development. React also encourages the use of ES6 syntax that can make your code a lot more concise, readable and simple to reason about, as well as the use of some functional programming concepts and unidirectional code flow to help ensure that your code behaves predictably. Just beware of the hype - a lot of the reasons driving React’s use in mainstream web apps are being way oversold by the community right now, such as React’s concept of a Virtual DOM that allows for very fast and efficient DOM updates — you’re not going to see benefits from this in every situation. React was designed for the purpose of allowing very fast page rerenders for apps with thousands of elements. Below a certain threshold, native DOM rendering can be just as fast. Regardless, you still get the benefit of not having to think too much about what has to happen when an update takes place, however. React has a bit of a learning curve, but it’s well worth it.
Thanks for being honest. I was beginning to think about why the hype was so high. I'll take two days to get a feel for it and see if it suits me. 
I forgot to remove css loader. Mini css extract work well with my setup.
Any reason you're looking for a JS library? You probably want [mozilla/mozjpeg](https://github.com/mozilla/mozjpeg).
still keeps the "!"
A regex is for matching a string or substring, in your case you actually are trying to match two substrings (the leading R and the end of the string). The best I can up with is a regex where you’ll need to use groups. /(\w+)a+(\w+)/